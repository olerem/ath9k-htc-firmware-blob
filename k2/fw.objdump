
/home/oleksij/tmp/my/ath9k-htc-firmware-blob/k2/fw.elf:     Dateiformat elf32-xtensa-be
/home/oleksij/tmp/my/ath9k-htc-firmware-blob/k2/fw.elf
Architektur: xtensa, Flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
Startadresse 0x00903000

Xtensa header:

Machine     = Base
Insn tables = true
Literal tables = true

Programm-Header:
    LOAD off    0x00501000 vaddr 0x00501000 paddr 0x00501000 align 2**29
         filesz 0x00000ae0 memsz 0x00000ae0 flags r--
    LOAD off    0x0050cb40 vaddr 0x0050cb40 paddr 0x0050cb40 align 2**29
         filesz 0x00000bfc memsz 0x00000cc8 flags rw-
    LOAD off    0x00903000 vaddr 0x00903000 paddr 0x00903000 align 2**29
         filesz 0x00008053 memsz 0x00008053 flags r-x

Sektionen:
Idx Name          Größe     VMA       LMA       Datei-Off Ausr.
  0 .lit4         0001be00  004e5200  004e5200  00000000  2**0
                  ALLOC
  1 .rodata       000005a4  00501000  00501000  00501000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .literals     0000053c  005015a4  005015a4  005015a4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .dport0.bss   00000000  0050cb40  0050cb40  0090b053  2**0
                  CONTENTS
  4 .data         00000bfc  0050cb40  0050cb40  0050cb40  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          000000cc  0050d73c  0050d73c  0050d73c  2**2
                  ALLOC
  6 .boot         0000023e  00903000  00903000  00903000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .text         00007e13  00903240  00903240  00903240  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .debug_aranges 00000348  00000000  00000000  0090b053  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   0005b3ac  00000000  00000000  0090b39b  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00006074  00000000  00000000  00966747  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00012b26  00000000  00000000  0096c7bb  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00001d00  00000000  00000000  0097f2e4  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00008b39  00000000  00000000  00980fe4  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    0000c559  00000000  00000000  00989b1d  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .xt.prop      00004e54  00000000  00000000  00996076  2**0
                  CONTENTS, READONLY
 16 .debug_ranges 00000c08  00000000  00000000  0099aeca  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      0000006d  00000000  00000000  0099bad2  2**0
                  CONTENTS, READONLY
 18 .xtensa.info  00000038  00000000  00000000  0099bb3f  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
004e5200 l    d  .lit4	00000000 .lit4
00501000 l    d  .rodata	00000000 .rodata
005015a4 l    d  .literals	00000000 .literals
0050cb40 l    d  .dport0.bss	00000000 .dport0.bss
0050cb40 l    d  .data	00000000 .data
0050d73c l    d  .bss	00000000 .bss
00903000 l    d  .boot	00000000 .boot
00903240 l    d  .text	00000000 .text
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .xt.prop	00000000 .xt.prop
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .xtensa.info	00000000 .xtensa.info
00000000 l    df *ABS*	00000000 magpie.c
00501000 l     O .rodata	0000000d __FUNCTION__$3740
00000000 l    df *ABS*	00000000 usb_api_main_patch.c
0050cb42 l     O .data	00000002 cmd_is_new$5222
0050d764 l     O .bss	00000004 evntbuf$5220
0050d760 l     O .bss	00000004 regaddr$5221
0050d75c l     O .bss	00000002 buf_len$5219
0050cb40 l     O .data	00000002 cmd_is_new$5241
0050d758 l     O .bss	00000004 buf$5239
0050d754 l     O .bss	00000002 cmd_len$5238
0050100d l     O .rodata	00000012 __func__$5242
0050d750 l     O .bss	00000004 regaddr$5237
00000000 l    df *ABS*	00000000 ar5416_hw.c
00501020 l     O .rodata	000000d0 ar5416hal_10
00000000 l    df *ABS*	00000000 if_ath.c
0090640c l     F .text	00000014 __adf_os_mem_alloc
00906420 l     F .text	00000013 __adf_os_mem_copy
00906434 l     F .text	00000013 __adf_os_mem_set
00906448 l     F .text	00000005 tgt_HTCRecv_uapsdhandler
00906450 l     F .text	00000006 dispatch_magpie_sys_cmds
00906458 l     F .text	00000005 htc_setup_comp
00906460 l     F .text	0000005f tgt_ServiceConnect
00906ab0 l     F .text	0000010c tgt_HTCSendCompleteHandler
009064c0 l     F .text	0000002e tgt_reg_service
009064f0 l     F .text	00000010 tgt_HTCRecv_mgmthandler
00906500 l     F .text	00000094 ath_descdma_cleanup
00906594 l     F .text	00000014 __adf_os_init_bh$isra$5
009065a8 l     F .text	00000010 __adf_os_sched_bh$isra$6
009065b8 l     F .text	000000b7 ath_tgt_rx_tasklet
0050d77d l     O .bss	00000001 flg$7423
0050d77c l     O .bss	00000001 reset_pll$7417
00906670 l     F .text	0000008e ath_hal_reg_write_filter$isra$13
00906700 l     F .text	0000005a ath_reg_read_filter
0090675c l     F .text	0000004c ath_desc_free
009067a8 l     F .text	000000a0 ath_descdma_setup$isra$21$constprop$26
00906848 l     F .text	00000092 tgt_HTCRecvMessageHandler
009068dc l     F .text	0000003b tgt_HTCRecv_cabhandler
00906918 l     F .text	00000198 ath_rxdesc_init
0050cec4 l     O .data	00000004 ath_numrxbufs
0090724c l     F .text	00000012 ath_fatal_tasklet
00907260 l     F .text	00000012 ath_bmiss_tasklet
009072bc l     F .text	0000004e ath_hal_reg_rmw_tgt
0090730c l     F .text	0000008a ath_rc_mask_tgt
00907398 l     F .text	00000023 ath_rx_stats_tgt
009073bc l     F .text	00000042 ath_tx_stats_tgt
00907400 l     F .text	00000032 ath_int_stats_tgt
00907434 l     F .text	0000006f ath_node_update_tgt
009074a4 l     F .text	0000002a ath_detach_tgt
00501114 l     O .rodata	00000014 __FUNCTION__$7341
009074d0 l     F .text	000000ab ath_enable_aggr_tgt
0090757c l     F .text	0000002c ath_ic_update_tgt
009075a8 l     F .text	0000005a handle_rc_rate_update_cmd
00907604 l     F .text	00000052 handle_rc_state_change_cmd
00907658 l     F .text	0000002e ath_hal_reg_write_tgt
00907688 l     F .text	00000042 ath_hal_reg_read_tgt
009076cc l     F .text	0000005c ath_vap_create_tgt
00907728 l     F .text	00000052 ath_vap_delete_tgt
0090777c l     F .text	00000030 ath_node_cleanup_tgt
009077ac l     F .text	000000af ath_node_create_tgt
0090785c l     F .text	0000006a ath_setcurmode_tgt
009078c8 l     F .text	00000050 ath_flushrecv_tgt
00907918 l     F .text	0000003a ath_stoprecv_tgt
00907954 l     F .text	00000086 ath_startrecv_tgt
009079dc l     F .text	000000c6 ath_draintxq_tgt
00907aa4 l     F .text	0000002e ath_tx_draintxq_tgt
00907ad4 l     F .text	00000023 ath_aborttx_dma_tgt
00907af8 l     F .text	00000026 ath_stop_tx_dma_tgt
00907b20 l     F .text	00000040 ath_aborttxq_tgt
00907b60 l     F .text	0000004f ath_init_tgt
00907bb0 l     F .text	00000054 ath_enable_intr_tgt
00907c04 l     F .text	00000026 ath_disable_intr_tgt
00907c2c l     F .text	0000001e ath_get_tgt_version
00907c4c l     F .text	00000013 handle_echo_command
00907c78 l     F .text	000001a2 tgt_HTCRecv_beaconhandler
0050cdc0 l     O .data	00000100 Magpie_Sys_DispatchEntries
0050cec0 l     O .data	00000004 ath_numrxdescs
00000000 l    df *ABS*	00000000 ratectrl_11n_ln.c
009082b0 l     F .text	00000058 rcIsValidPhyRate
00501128 l     O .rodata	00000028 nRetry2PerLookup$7047
00908308 l     F .text	000001fa rcUpdate_ht$constprop$6
00908504 l     F .text	0000007a rcRateSetseries$constprop$11
00908580 l     F .text	000003bc rcSibUpdate_ht$isra$3$constprop$13
0090893c l     F .text	00000062 rcRateGetIndex$constprop$9
00000000 l    df *ABS*	00000000 if_owl.c
00908ed4 l     F .text	00000013 __adf_os_mem_copy
00908ee8 l     F .text	0000004d ieee80211_anyhdrsize
00908f38 l     F .text	0000004c owl_tgt_tid_init
00908f84 l     F .text	00000076 ath_tgt_txq_add_ucast
00908ffc l     F .text	0000005f ath_tx_update_baw
0090905c l     F .text	00000060 ath_update_stats$isra$1
009090bc l     F .text	00000024 ath_tgt_tx_enqueue$isra$3
009090e0 l     F .text	00000076 ath_update_aggr_stats$isra$5
00909158 l     F .text	00000014 ath_dma_unmap$isra$6
0090916c l     F .text	00000026 ath_tgt_skb_free$isra$7
00909194 l     F .text	0000009e ath_filltxdesc$isra$9
00909234 l     F .text	0000004e ath_tx_tgt_setds
00909284 l     F .text	00000013 __adf_os_mem_set$constprop$19
00501150 l     O .rodata	00000040 bits_per_symbol
00909298 l     F .text	000001f2 ath_buf_set_rate
0090948c l     F .text	00000016 ath_dma_map$isra$8
009094a4 l     F .text	000000c9 ath_buf_toggle
00909570 l     F .text	0000003c ath_buf_comp
009095ac l     F .text	00000083 ath_tx_freebuf
0090ae4c l     F .text	00000107 ath_bar_tx_comp
00909630 l     F .text	00000166 ath_bar_tx
00909998 l     F .text	00000010 ATH_SKB2_WH
009099a8 l     F .text	0000002f ath_tx_set_retry$isra$12
009099d8 l     F .text	000000e7 ath_tx_retry_subframe$isra$14
00909ac0 l     F .text	000000b7 ath_tx_comp_aggr_error
0090a950 l     F .text	0000005a ath_tgt_tx_comp_normal
0090a5b8 l     F .text	000001fe ath_tgt_txq_schedule
0090a8bc l     F .text	00000046 ath_aggr_resume_tid
0090a904 l     F .text	0000004b owl_tgt_tid_cleanup
00000000 l    df *ABS*	00000000 app_start.c
0090af60 l     F .text	00000029 io32_rmw
00000000 l    df *ABS*	00000000 ah_osdep.c
00000000 l    df *ABS*	00000000 wlan_pci.c
00000000 l    df *ABS*	00000000 usb_api_k2_patch.c
009046a4 l     F .text	0000002b io8_rmw
009046d0 l     F .text	00000021 io32_rmw$constprop$0
00000000 l    df *ABS*	00000000 k2_fw_cmnos_printf.c
00904ad0 l     F .text	00000051 _cvt
00904b24 l     F .text	0000002a cmnos_write_char
00000000 l    df *ABS*	00000000 if_ath_pci.c
00906338 l     F .text	00000005 ath_pci_suspend
00906340 l     F .text	00000005 ath_pci_resume
00906348 l     F .text	00000010 ath_pci_remove
0050cd80 l     O .data	00000020 ath_drv_info
00906368 l     F .text	0000007e ath_pci_probe
0050cda0 l     O .data	00000020 ath_pci_id_table
00000000 l    df *ABS*	00000000 init.c
0050d744 l     O .bss	00000004 loop_high
0050d748 l     O .bss	00000004 loop_low
00000000 l    df *ABS*	00000000 adf_nbuf.c
00000000 l    df *ABS*	00000000 buf_pool_static.c
00000000 l    df *ABS*	00000000 htc.c
00000000 l    df *ABS*	00000000 wmi_svc.c
00904488 l     F .text	0000000b WMIServiceConnect
00904494 l     F .text	00000007 _WMI_GetPendingEventsCount
0090449c l     F .text	00000007 _WMI_GetControlEp
009044a4 l     F .text	00000014 _WMI_RegisterDispatchTable
009044b8 l     F .text	00000005 _WMI_Shutdown
009044c0 l     F .text	00000086 WMIRecvMessageHandler
00904548 l     F .text	00000024 _WMI_SendCompleteHandler
0090456c l     F .text	00000030 _WMI_AllocEvent
0090459c l     F .text	00000036 _WMI_SendEvent
009045d4 l     F .text	0000006f _WMI_Init
00000000 l    df *ABS*	00000000 k2_HIF_usb_patch.c
00000000 l    df *ABS*	00000000 k2_cmnos_clock_patch.c
0050d778 l     O .bss	00000004 last_tick$3640
00000000 l    df *ABS*	00000000 ah.c
00000000 l    df *ABS*	00000000 ar5416_phy.c
00000000 l    df *ABS*	00000000 adf_net.c
00000000 l    df *ABS*	00000000 adf_os_irq_pvt.c
00000000 l    df *ABS*	00000000 adf_os_dma.c
00000000 l    df *ABS*	00000000 ar5416Phy.c
00000000 l    df *ABS*	00000000 ieee80211_output.c
005009e4 g       *ABS*	00000000 u16TxRxCounter
00903240 g     F .text	00000035 init_mem
00908e54 g     F .text	00000036 ath_rate_tx_complete
004e5200 g       *ABS*	00000000 _rom_literal_start
009034ec g     F .text	0000002b __adf_nbuf_dmamap_info
00903af4 g     F .text	00000079 bGet_descriptor_patch
00909b78 g     F .text	0000002d ath_tgt_tid_drain
009035dc g     F .text	00000011 __adf_nbuf_last
0050d784 g     O .bss	00000004 save_cmnos_printf
005009f8 g       *ABS*	00000000 u8UsbInterfaceValue
0090341c g     F .text	0000000c __adf_nbuf_copy
0050d780 g     O .bss	00000004 _assfail_ori
009034cc g     F .text	00000009 __adf_nbuf_map
005015a4 g       *ABS*	00000000 _bss_table_end
0090af8c g     F .text	0000000c __adf_net_register_drv
0050d768 g     O .bss	00000004 g_wlan_intr
009034b0 g     F .text	0000001c __adf_nbuf_dmamap_create
009041a8 g     F .text	00000087 HTCControlSvcProcessMsg
0050cec8 g     O .data	00000874 ar5416_11ngRateTable
00903bfc g     F .text	0000000f wlan_pci_module_init
00500000 g       *ABS*	00000000 _indir_tbl
00904f94 g     F .text	00000010 ath_hal_attach_tgt
00903798 g     F .text	00000023 buf_pool_module_install
00501000 g       *ABS*	00000000 _lit4_end
0090367c g     F .text	00000007 __adf_nbuf_is_cloned
00903924 g     F .text	000000ff usb_reg_out_patch
00903518 g     F .text	00000005 __adf_nbuf_set_rx_cksum
00906094 g     F .text	000000bc ar5416AbortTxDma
0090b053 g       *ABS*	00000000 _text_end
0090a9ac g     F .text	000003e8 ath_tgt_tx_comp_aggr
00904690 g     F .text	00000013 _HIFusb_isr_handler_patch
00908df4 g     F .text	0000002e ath_rate_attach
00905fb0 g     F .text	00000044 ar5416Set11nBurstDuration_20
00903a68 g     F .text	00000022 vUsbFIFO_EPxCfg_FS_patch
00903528 g     F .text	00000067 __adf_nbuf_create_frm_frag
00903800 g     F .text	00000022 cold_reboot
00501000 g       *ABS*	00000000 _lit4_start
00501ae0 g       *ABS*	00000000 _dram0_literal_end
00904230 g     F .text	00000040 AdjustCreditThreshold
00501ae0 g       *ABS*	00000000 _dram0_literal_start
0090504c g     F .text	00000029 ath_hal_wait
0090b053 g       .text	00000000 _etext
00905ff4 g     F .text	0000006f ar5416Set11nVirtualMoreFrag_20
008e408c g       *ABS*	00000000 vbuf_module_install
0050d740 g     O .bss	00000004 idle_cnt
00909798 g     F .text	00000043 owl_tgt_node_init
00903824 g     F .text	000000ff usb_status_in_patch
00903c0c g     F .text	0000000a wlan_pci_register_drv
009033c4 g     F .text	0000002a __adf_nbuf_push_head
009037bc g     F .text	00000022 _fw_usbfifo_recv_command
0090af54 g     F .text	0000000a ar5416AttachRateTables
00903d34 g     F .text	000000bf _HTC_Init
009033ac g     F .text	00000006 __adf_nbuf_realloc_headroom
00905de0 g     F .text	00000089 ar5416Set11nAggrFirst_20
009034e4 g     F .text	00000005 __adf_nbuf_dmamap_destroy
00909e8c g     F .text	000003cf ath_tgt_send_mgt
00906328 g     F .text	00000010 ar5416GetRateTable
0090369c g     F .text	0000000d __adf_nbuf_queue_init
008e4eb8 g       *ABS*	00000000 memcpy
00908e8c g     F .text	00000013 ath_rate_newassoc
005015a4 g       *ABS*	00000000 _rodata_end
00903520 g     F .text	00000007 __adf_nbuf_get_vlan_info
00908be4 g     F .text	00000172 rcUpdate_11n
00904fdc g     F .text	0000006f ath_hal_computetxtime
00500a00 g       *ABS*	00000000 u8UsbDeviceDescriptor
00908d58 g     F .text	0000009a ath_tx_status_update_rate
009036b4 g     F .text	00000007 __adf_nbuf_queue_first
0050d788 g     O .bss	00000004 htc_handle
00909998 g     F .text	00000010 ATH_SKB_2_WH
0090afa0 g     F .text	000000b3 ieee80211_tgt_crypto_encap
008e4da0 g       *ABS*	00000000 __udivsi3
00903e84 g     F .text	00000057 _HTC_Ready
00903b70 g     F .text	00000010 ath_hal_getuptime
00903618 g     F .text	00000024 __adf_nbuf_trim_tail
0050d740 g       *ABS*	00000000 _bss_start
0050cb40 g       *ABS*	00000000 _dram0_data_end
00903f44 g     F .text	00000066 ReturnBuffers
00909e04 g     F .text	00000088 ath_tgt_tx_send_normal
005009fa g       *ABS*	00000000 u8UsbInterfaceAlternateSetting
0050d73c g       *ABS*	00000000 __XT_EXCEPTION_DESCS__
0090a2dc g     F .text	00000092 ath_tgt_handle_aggr
00903240 g       *ABS*	00000000 _text_start
009037e0 g     F .text	00000020 _fw_usbfifo_init
0090a7b8 g     F .text	00000096 owltgt_tx_processq
009033b4 g     F .text	00000006 __adf_nbuf_realloc_tailroom
0090a25c g     F .text	00000033 ath_tgt_handle_normal
00905444 g     F .text	00000015 ar5416StartTxDma
00906258 g     F .text	00000055 ar5416SetRxFilter
00903bdc g     F .text	00000005 ath_hal_free
00904270 g     F .text	0000014e _HTC_SendMsg
009062b0 g     F .text	00000077 ar5416Attach
00903674 g     F .text	00000005 __adf_nbuf_cat
00905430 g     F .text	00000014 ar5416SetTxDP
00908ea0 g     F .text	00000013 ath_rate_node_update
00903648 g     F .text	00000019 __adf_nbuf_tailroom
0090366c g     F .text	00000007 __adf_nbuf_clone
008e3ca4 g       *ABS*	00000000 mUsbFIFOConfig
00904a60 g     F .text	0000000a cmnos_clock_init_patch
008e2b58 g       *ABS*	00000000 _HIFusb_isr_handler
009036f4 g     F .text	00000057 _buf_pool_static_create_pool
009036ac g     F .text	00000007 __adf_nbuf_queue_len
00501000 g       *ABS*	00000000 _dport0_literal_start
009063e8 g     F .text	0000000b exit_ath_pci
0050d808 g       *ABS*	00000000 _bss_end
009036ec g     F .text	00000005 _buf_pool_static_shutdown
009053cc g     F .text	00000061 ar5416UpdateTxTrigLevel
0050d78c g     O .bss	0000002c g_poolCtx
0090345c g     F .text	0000000c __adf_nbuf_get_priv
0090412c g     F .text	0000007b HTCProcessConfigPipeMsg
0090374c g     F .text	00000024 _buf_pool_static_alloc_buf
00906064 g     F .text	0000000a ar5416Detach
00905150 g     F .text	0000000f ar5416EnableReceive
005009cc g       *ABS*	00000000 usbFifoConf
005009e0 g       *ABS*	00000000 pu8DescriptorEX
00904a6c g     F .text	0000000a cmnos_refclk_speed_get_patch
00905a78 g     F .text	00000108 ar5416Set11nTxDesc_20
0050cb40 g       *ABS*	00000000 _dram0_data_start
00906358 g     F .text	0000000d init_ath_pci
008e2ec4 g       *ABS*	00000000 bGet_descriptor
0090545c g     F .text	0000002e ar5416NumTxPending
00907e1c g     F .text	0000043c ath_tgt_attach
00903cd8 g     F .text	00000013 _HTC_GetReservedHeadroom
00903328 g     F .text	0000003c Magpie_init
0050d73c g       *ABS*	00000000 __XT_EXCEPTION_DESCS_END__
00903590 g     F .text	0000004c __adf_nbuf_split_to_frag
005009f0 g       *ABS*	00000000 eUsbCxCommand
00904644 g     F .text	00000037 WMI_service_module_install
00903770 g     F .text	00000010 _buf_pool_static_alloc_buf_align
008e4df0 g       *ABS*	00000000 __umodsi3
00501000 g       *ABS*	00000000 _dport0_rodata_start
0050cb40 g       *ABS*	00000000 _dport0_data_start
008e4cac g       *ABS*	00000000 xthal_get_ccount
009033bc g     F .text	00000006 __adf_nbuf_expand
00905090 g     F .text	00000085 ar5416SetInterrupts
00905140 g     F .text	0000000d ar5416SetRxDP
009097dc g     F .text	00000010 ath_tx_status_clear
0050d76c g     O .bss	00000004 g_wlan_drv_handle
008e2bd4 g       *ABS*	00000000 hif_module_install
00903cec g     F .text	0000002e HTCSendDoneHandler
009046f4 g     F .text	000001c4 _fw_usb_suspend_reboot
008e3cec g       *ABS*	00000000 mUsbEPMxPtSzLow
00905118 g     F .text	00000026 ar5416GetTsf64
0050d774 g     O .bss	00000004 ref_clk
00903edc g     F .text	00000066 HTCCheckAndSendCreditReport
005009c0 g       *ABS*	00000000 ControlCmd
0050cb40 g       *ABS*	00000000 _data_start
005009f6 g       *ABS*	00000000 u8UsbConfigValue
00903bb8 g     F .text	00000022 ath_hal_malloc
00906070 g     F .text	00000021 ar5416StopDmaReceive
00903df4 g     F .text	00000005 _HTC_PauseRecv
0090af98 g     F .text	00000005 __adf_net_unregister_drv
00908280 g     F .text	0000002e __adf_os_dmamem_alloc
008e3c68 g       *ABS*	00000000 mUsbEPMap
009033f0 g     F .text	0000002b __adf_nbuf_pull_head
009063f4 g     F .text	0000000c __adf_os_setup_intr
0050d74c g     O .bss	00000004 m_origUsbfifoRecvCmd
00904a94 g     F .text	0000002b cmnos_tick_patch
00903468 g     F .text	0000001e __adf_nbuf_queue_add
00907274 g     F .text	00000047 wmi_cmd_rsp
00903428 g     F .text	0000000c __adf_nbuf_unshare
0050d7b8 g     O .bss	00000012 UsbDeviceDescriptorPatch
00903780 g     F .text	00000018 _buf_pool_static_free_buf
009036c4 g     F .text	00000010 __adf_nbuf_is_queue_empty
00905078 g     F .text	00000017 ar5416IsInterruptPending
00903be4 g     F .text	00000015 ath_hal_memcpy
00903000 g     F .boot	0000023e app_start
0090548c g     F .text	000001e6 ar5416SetupTxDesc_20
0050088c g       *ABS*	00000000 cticks
008e413c g       *ABS*	00000000 vdesc_module_install
009097ec g     F .text	000000c3 ath_tx_status_update
0050d73c g       *ABS*	00000000 _data_end
0090b053 g       *ABS*	00000000 _iram0_text_end
0090a370 g     F .text	00000245 ath_tgt_tx_form_aggr
00501592 g       *ABS*	00000000 __XT_EXCEPTION_TABLE__
0090a290 g     F .text	0000004a ath_tx_addto_baw
00903488 g     F .text	00000026 __adf_nbuf_queue_remove
00908258 g     F .text	00000028 ath_detach
00903278 g     F .text	0000004f wlan_task
005015a4 g       *ABS*	00000000 _literals_start
009036d4 g     F .text	00000018 _buf_pool_static_init
00903664 g     F .text	00000008 __adf_nbuf_len
00906150 g     F .text	0000003d ar5416StopTxDma
00903ca8 g     F .text	00000016 wlan_pci_isr
008e519c g       *ABS*	00000000 memset
00501ae0 g       *ABS*	00000000 _literals_end
00903cc0 g     F .text	00000005 _HTC_Shutdown
00904fa4 g     F .text	00000037 ath_hal_getcapability
00903434 g     F .text	00000027 __adf_nbuf_frag_info
00501000 g       *ABS*	00000000 _dport0_rodata_end
00904a78 g     F .text	0000001c cmnos_delay_us_patch
005009ec g       *ABS*	00000000 eUsbCxFinishAction
00903e48 g     F .text	00000016 HTCFreeMsgBuffer
00905e6c g     F .text	00000083 ar5416Set11nAggrMiddle_20
00903684 g     F .text	00000015 __adf_nbuf_peek_header
008e4cec g       *ABS*	00000000 __divsi3
009051f0 g     F .text	000001dc ar5416ProcRxDescFast_20
00501000 g       *ABS*	00000000 _dram0_rodata_start
00501000 g       *ABS*	00000000 _rom_literal_end
00906bbc g     F .text	0000005b wmi_event
00903ca0 g     F .text	00000007 wlan_pci_config_read
00906c18 g     F .text	00000634 ath_intr
00903fac g     F .text	00000010 _HTC_ReturnBuffers
008e1548 g       *ABS*	00000000 athos_indirection_table_install
0090a850 g     F .text	0000006c owl_tgt_tx_tasklet
008e3cc4 g       *ABS*	00000000 mUsbEPMxPtSzHigh
00903ba8 g     F .text	00000010 ath_hal_delay
005009e8 g       *ABS*	00000000 u8ConfigDescriptorEX
00903364 g     F .text	0000003e __adf_nbuf_alloc
009036bc g     F .text	00000007 __adf_nbuf_queue_next
005009f4 g       *ABS*	00000000 UsbChirpFinish
009043c0 g     F .text	000000be HTCMsgRecvHandler
009098b0 g     F .text	000000a0 ath_tx_status_update_aggr
009033a4 g     F .text	00000006 __adf_nbuf_free
008e3c84 g       *ABS*	00000000 mUsbFIFOMap
009032c8 g     F .text	00000005 htc_setup_comp
00501594 g       *ABS*	00000000 _bss_table_start
0050cb44 g     O .data	00000238 ar5416_11ng_table
009049d8 g     F .text	00000086 _fw_usb_reset_fifo
009034d8 g     F .text	00000009 __adf_nbuf_unmap
0090363c g     F .text	0000000a __adf_nbuf_headroom
0090ad94 g     F .text	000000b6 ath_tgt_tx_cleanup
008e328c g       *ABS*	00000000 bStandardCommand
008e2f7c g       *ABS*	00000000 bSet_configuration
00903c18 g     F .text	00000080 wlan_pci_probe
00903e04 g     F .text	00000041 htc_module_install
0050cb40 g       *ABS*	00000000 _dport0_data_end
00904ac0 g     F .text	0000000d cmnos_milliseconds_patch
00501000 g       *ABS*	00000000 _rodata_start
00907c60 g     F .text	00000018 ath_get_minrateidx
0050d808 g       .bss	00000000 _end
0090467c g     F .text	00000011 _HIFusb_get_max_msg_len_patch
00909950 g     F .text	00000046 ath_tx_status_send
0090b053 g       *ABS*	00000000 _iram0_text_start
00905ef0 g     F .text	0000007d ar5416Set11nAggrLast_20
00904008 g     F .text	00000043 HTCControlSvcProcessSendComplete
00903e60 g     F .text	00000021 HTCAllocMsgBuffer
0050cd7c g     O .data	00000004 g_pci_init_func
00903cc8 g     F .text	0000000d _HTC_RegisterService
00903b80 g     F .text	00000026 _ath_hal_attach_tgt
0090404c g     F .text	000000e0 HTCProcessConnectMsg
00905f70 g     F .text	0000003e ar5416Clr11nAggr_20
009089a0 g     F .text	00000242 rcRateFind_11n
009035f0 g     F .text	00000026 __adf_nbuf_put_tail
00908e24 g     F .text	0000002f ath_rate_findrate
0050d770 g     O .bss	00000004 g_wlan_drv
00905674 g     F .text	00000136 ar5416FillTxDesc_20
00903d1c g     F .text	00000017 HTC_AssembleBuffers
0050d808 g       *ABS*	00000000 _fw_image_end
00903dfc g     F .text	00000005 _HTC_ResumeRecv
00909ba8 g     F .text	0000025a ath_tgt_tx_prepare
00903240 g       .text	00000000 _stext
00903a8c g     F .text	00000023 bSet_configuration_patch
00906400 g     F .text	0000000c __adf_os_free_intr
009057ac g     F .text	00000021 ar5416FillKeyTxDesc_20
009032d0 g     F .text	00000057 _wmi_cmd_rsp
00903c98 g     F .text	00000007 wlan_pci_config_write
00903fbc g     F .text	0000004a _HTC_ReturnBuffersList
00904b50 g     F .text	00000444 fw_cmnos_printf
00905178 g     F .text	00000077 ar5416SetupRxDesc_20
008e3d10 g       *ABS*	00000000 mUsbEPinHighBandSet
00908eb4 g     F .text	0000001e ath_rate_newstate
0050cb40 g       *ABS*	00000000 _dport0_bss_start
00501000 g       *ABS*	00000000 _dram0_rodata_end
009057d0 g     F .text	000002a8 ar5416ProcTxDesc_20
00904480 g     F .text	00000005 RedistributeCredit
00903a24 g     F .text	00000042 vUSBFIFO_EP6Cfg_FS_patch
0050cb40 g       *ABS*	00000000 _dport0_bss_end
00903ab0 g     F .text	00000044 bStandardCommand_patch
0050d7ca g     O .bss	0000003c ConfigDescriptorPatch
00906190 g     F .text	000000c7 ar5416GetPendingInterrupts
00501000 g       *ABS*	00000000 _dport0_literal_end
00905b80 g     F .text	00000260 ar5416Set11nRateScenario_20
00905160 g     F .text	00000017 ar5416StopPcuReceive
009048b8 g     F .text	0000011e _fw_usb_fw_task



Disassembly of section .boot:

00903000 <app_start>:

extern BOOLEAN bJumptoFlash;
extern BOOLEAN bEepromExist;

void __section(boot) __noreturn __visible app_start(void)
{
  903000:	6c1004        	entry	a1, 32
#if defined(PROJECT_MAGPIE)
	T_EEP_RET retEEP;
#endif

	/* Zero BSS segment & dynamic memory section. */
	init_mem();
  903003:	58008f        	call8	903240 <_text_start>

#if defined(PROJECT_MAGPIE)
	fatal_exception_func();
#endif

	if( IS_FLASHBOOT() ) {
  903006:	12716b        	l32r	a2, 8df5b4 <_bss_end+0x3d1dac>
  903009:	14716c        	l32r	a4, 8df5bc <_bss_end+0x3d1db4>
  90300c:	0c0200        	memw
  90300f:	8320      	l32i.n	a3, a2, 0
  903011:	12716e        	l32r	a2, 8df5cc <_bss_end+0x3d1dc4>
  903014:	03035f        	extui	a3, a3, 16, 16
  903017:	74393d        	bne	a3, a4, 903058 <app_start+0x58>
		athos_indirection_table_install();
  90301a:	5b794b        	call8	8e1548 <athos_indirection_table_install>
		DBG_MODULE_INSTALL();
		A_CLOCK_INIT(SYSTEM_CLK);
  90301d:	1a716d        	l32r	a10, 8df5d4 <_bss_end+0x3d1dcc>
  903020:	232237        	l32i	a3, a2, 220
  903023:	0b3000        	callx8	a3
		A_UART_INIT();
  903026:	2a2213        	l32i	a10, a2, 76
  903029:	0ba000        	callx8	a10
		A_PRINTF_INIT();
  90302c:	232211        	l32i	a3, a2, 68
  90302f:	0b3000        	callx8	a3
		A_DBG_INIT();
		A_EEP_INIT();
  903032:	23225f        	l32i	a3, a2, 0x17c
  903035:	0b3000        	callx8	a3
		A_TASKLET_INIT();
  903038:	232269        	l32i	a3, a2, 0x1a4
  90303b:	0b3000        	callx8	a3
		_indir_tbl.cmnos.timer._timer_init();
  90303e:	232241        	l32i	a3, a2, 0x104
  903041:	0b3000        	callx8	a3
#if defined(PROJECT_K2)
		/*
		 * WAR: these variable is not initialized when boot from flash
		 *      either re-enumeration or config them to default value = 0 would fix the issue
		 */
		u8UsbInterfaceAlternateSetting = u8UsbConfigValue = u8UsbInterfaceValue = 0;
  903044:	14716f        	l32r	a4, 8df600 <_bss_end+0x3d1df8>
  903047:	c030      	movi.n	a3, 0
  903049:	234500        	s16i	a3, a4, 0
  90304c:	147170        	l32r	a4, 8df60c <_bss_end+0x3d1e04>
  90304f:	234500        	s16i	a3, a4, 0
  903052:	147171        	l32r	a4, 8df618 <_bss_end+0x3d1e10>
  903055:	234500        	s16i	a3, a4, 0
	} else {
		bEepromExist = FALSE;
	}
#endif

	hostif = A_IS_HOST_PRESENT();
  903058:	8a2e      	l32i.n	a10, a2, 56
  90305a:	0ba000        	callx8	a10
  90305d:	d5a0      	mov.n	a5, a10
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90305f:	137172        	l32r	a3, 8df628 <_bss_end+0x3d1e20>
#elif defined(PROJECT_K2)
	rst_status = ioread32(MAGPIE_REG_RST_STATUS_ADDR);
#endif /* #if defined(PROJECT_MAGPIE) */


	A_PRINTF(" A_WDT_INIT()\n\r");
  903062:	242212        	l32i	a4, a2, 72
  903065:	1a7173        	l32r	a10, 8df634 <_bss_end+0x3d1e2c>
  903068:	0c0200        	memw
  90306b:	8330      	l32i.n	a3, a3, 0
  90306d:	0b4000        	callx8	a4

#if defined(PROJECT_K2)
	save_cmnos_printf = fw_cmnos_printf;
  903070:	167174        	l32r	a6, 8df640 <_bss_end+0x3d1e38>
  903073:	147175        	l32r	a4, 8df648 <_bss_end+0x3d1e40>
  903076:	246600        	s32i	a4, a6, 0
#endif

	if( hostif == HIF_USB ) {
  903079:	655014        	bnez	a5, 903091 <app_start+0x91>
#if defined(PROJECT_K2)
#if MOVE_PRINT_TO_RAM
		save_cmnos_printf = _indir_tbl.cmnos.printf._printf;
  90307c:	272212        	l32i	a7, a2, 72
		_indir_tbl.cmnos.printf._printf = fw_cmnos_printf;
  90307f:	242612        	s32i	a4, a2, 72
#endif
		_indir_tbl.cmnos.usb._usb_fw_task = _fw_usb_fw_task;
  903082:	147176        	l32r	a4, 8df65c <_bss_end+0x3d1e54>
#endif

	if( hostif == HIF_USB ) {
#if defined(PROJECT_K2)
#if MOVE_PRINT_TO_RAM
		save_cmnos_printf = _indir_tbl.cmnos.printf._printf;
  903085:	276600        	s32i	a7, a6, 0
		_indir_tbl.cmnos.printf._printf = fw_cmnos_printf;
#endif
		_indir_tbl.cmnos.usb._usb_fw_task = _fw_usb_fw_task;
  903088:	24261d        	s32i	a4, a2, 116
		_indir_tbl.cmnos.usb._usb_reset_fifo = _fw_usb_reset_fifo;
  90308b:	147177        	l32r	a4, 8df668 <_bss_end+0x3d1e60>
  90308e:	242629        	s32i	a4, a2, 164
#endif
	}

	if( rst_status == WDT_MAGIC_PATTERN ) {
  903091:	147178        	l32r	a4, 8df674 <_bss_end+0x3d1e6c>
  903094:	74391c        	bne	a3, a4, 9030b4 <app_start+0xb4>
		A_PRINTF(" ==>WDT reset<==\n");
  903097:	232212        	l32i	a3, a2, 72
  90309a:	1a7179        	l32r	a10, 8df680 <_bss_end+0x3d1e78>
  90309d:	0b3000        	callx8	a3
#if defined(PROJECT_MAGPIE)
		reset_EP4_FIFO();
#endif
		*((volatile uint32_t*)WATCH_DOG_RESET_COUNTER_ADDR)+=1;
  9030a0:	14717a        	l32r	a4, 8df688 <_bss_end+0x3d1e80>
  9030a3:	0c0200        	memw
  9030a6:	8340      	l32i.n	a3, a4, 0
  9030a8:	b133      	addi.n	a3, a3, 1
  9030aa:	0c0200        	memw
  9030ad:	9340      	s32i.n	a3, a4, 0
  9030af:	60001a        	j	9030cd <app_start+0xcd>
  9030b2:	000014        	srli	a0, a0, 0
	} else if (rst_status == SUS_MAGIC_PATTERN) {
  9030b5:	717b74        	bgeu	a7, a1, 90312d <app_start+0x12d>
  9030b8:	390923        	excw
		A_PRINTF(" ==>warm start<==\n");
  9030bb:	22121a        	l32i	a2, a1, 104
  9030be:	717c60        	bnall	a7, a1, 903122 <app_start+0x122>
  9030c1:	000600        	rsil	a0, 0
	} else
		A_PRINTF(" ==>cold start<==\n");
  9030c4:	232212        	l32i	a3, a2, 72
  9030c7:	1a717d        	l32r	a10, 8df6bc <_bss_end+0x3d1eb4>
  9030ca:	0b3000        	callx8	a3
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  9030cd:	147178        	l32r	a4, 8df6b0 <_bss_end+0x3d1ea8>
  9030d0:	137172        	l32r	a3, 8df698 <_bss_end+0x3d1e90>
	SFLASH_MODULE_INSTALL();
	A_SFLASH_INIT();
#endif
#endif

	HIF_MODULE_INSTALL();
  9030d3:	1a717e        	l32r	a10, 8df6cc <_bss_end+0x3d1ec4>
  9030d6:	0c0200        	memw
  9030d9:	9430      	s32i.n	a4, a3, 0
  9030db:	5b7ebe        	call8	8e2bd4 <hif_module_install>
	HTC_MODULE_INSTALL();
  9030de:	1a717f        	l32r	a10, 8df6dc <_bss_end+0x3d1ed4>
  9030e1:	580348        	call8	903e04 <htc_module_install>
	WMI_SERVICE_MODULE_INSTALL();
  9030e4:	1a7180        	l32r	a10, 8df6e4 <_bss_end+0x3d1edc>
  9030e7:	580557        	call8	904644 <WMI_service_module_install>
	BUF_POOL_MODULE_INSTALL();
  9030ea:	1a7181        	l32r	a10, 8df6f0 <_bss_end+0x3d1ee8>
  9030ed:	5801aa        	call8	903798 <buf_pool_module_install>
	VBUF_MODULE_INSTALL();
  9030f0:	1a7182        	l32r	a10, 8df6f8 <_bss_end+0x3d1ef0>
  9030f3:	5b83e6        	call8	8e408c <vbuf_module_install>
	VDESC_MODULE_INSTALL();
  9030f6:	1a7183        	l32r	a10, 8df704 <_bss_end+0x3d1efc>
  9030f9:	5b8410        	call8	8e413c <vdesc_module_install>

	//init each module, should be put together..
	A_PRINTF("ALLOCRAM start 0x%x size %d\n", ALLOCRAM_START, ALLOCRAM_SIZE);
  9030fc:	147184        	l32r	a4, 8df70c <_bss_end+0x3d1f04>
  9030ff:	167185        	l32r	a6, 8df714 <_bss_end+0x3d1f0c>
  903102:	282212        	l32i	a8, a2, 72
  903105:	b443      	addi.n	a3, a4, 4
  903107:	04670c        	sub	a7, a6, a4
  90310a:	1a7186        	l32r	a10, 8df724 <_bss_end+0x3d1f1c>
  90310d:	dc70      	mov.n	a12, a7
  90310f:	db30      	mov.n	a11, a3
  903111:	0b8000        	callx8	a8
	A_ALLOCRAM_INIT(ALLOCRAM_START, ALLOCRAM_SIZE);
  903114:	c78c      	movi.n	a8, -4
  903116:	78410b        	beq	a4, a8, 903125 <app_start+0x125>
  903119:	da30      	mov.n	a10, a3
  90311b:	1b716a        	l32r	a11, 8df6c4 <_bss_end+0x3d1ebc>
  90311e:	764906        	bne	a4, a6, 903128 <app_start+0x128>
  903121:	600006        	j	90312b <app_start+0x12b>
  903124:	001a71        	excw
  903127:	69077b        	bnei	a0, 7, 9031a6 <app_start+0x1a6>
  90312a:	022322        	excw
  90312d:	510b30        	call0	945df0 <_iram0_text_end+0x3ad9d>
  903130:	006550        	extui	a5, a0, 22, 1

	if( hostif == HIF_USB ) {
  903133:	b413      	addi.n	a3, a1, 4
		_indir_tbl.hif._get_max_msg_len = _HIFusb_get_max_msg_len_patch;
  903135:	718723        	bbci	a8, 17, 90315c <app_start+0x15c>
  903138:	267e13        	s32c1i	a6, a7, 76
		_indir_tbl.cmnos.usb._usb_reg_out = usb_reg_out_patch;
  90313b:	718823        	bany	a8, a1, 903162 <app_start+0x162>
  90313e:	263213        	l32i	a6, a3, 76
		_indir_tbl.hif._isr_handler = _HIFusb_isr_handler_patch;
  903141:	718923        	bne	a8, a1, 903168 <app_start+0x168>
  903144:	268013        	l8ui	a6, a8, 19
		_indir_tbl.cmnos.usb._usb_set_configuration = bSet_configuration_patch;
  903147:	718a23        	bge	a8, a1, 90316e <app_start+0x16e>
  90314a:	262513        	s16i	a6, a2, 38
		_indir_tbl.cmnos.usb._usb_status_in = usb_status_in_patch;
  90314d:	718b23        	bgeu	a8, a1, 903174 <app_start+0x174>
  903150:	263313        	excw
		_indir_tbl.cmnos.usb._usb_get_descriptor = bGet_descriptor_patch;
  903153:	718c23        	bnall	a8, a1, 90317a <app_start+0x17a>
  903156:	262f13        	s32ri	a6, a2, 76
		_indir_tbl.cmnos.usb._usb_standard_cmd = bStandardCommand_patch;
  903159:	718d23        	bbs	a8, a1, 903180 <app_start+0x180>
  90315c:	262613        	s32i	a6, a2, 76
		_indir_tbl.usbfifo_api._init = _fw_usbfifo_init;
  90315f:	718e23        	bbsi	a8, 1, 903186 <app_start+0x186>
  903162:	269b13        	l32ai	a6, a9, 76

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  903165:	718f23        	bbsi	a8, 17, 90318c <app_start+0x18c>
  903168:	300079        	excw
		_indir_tbl.hif._start = _HIFusb_start_patch;
		_indir_tbl.htc._HTC_MsgRecvHandler = HTCMsgRecvHandler_patch;
		_indir_tbl.htc._HTC_ControlSvcProcessMsg = HTCControlSvcProcessMsg_patch;
#endif

		if (!(ioread8_usb(ZM_MAIN_CTRL_OFFSET) & BIT6))
  90316b:	3f0258        	excw
			vUSBFIFO_EP6Cfg_FS_patch();
  90316e:	022d13        	srai	a13, a2, 18
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  903171:	719024        	bnone	a9, a1, 903199 <app_start+0x199>

#ifdef FUSION_USB_ENABLE_TX_STREAM
		// For K2, enable tx stream mode
		A_PRINTF("Enable Tx Stream mode: 0x%x\r\n",
  903174:	22120c        	l32i	a2, a1, 48
  903177:	02008b        	excw
  90317a:	301a71        	excw
  90317d:	910b      	s32i.n	a1, a0, 44
  90317f:	4000da        	excw
			ioread32_usb(ZM_SOC_USB_MODE_CTRL_OFFSET));

		/* Patch for K2 USB STREAM mode */
		/* disable down stream DMA mode */
		io32_rmw_usb(ZM_SOC_USB_MODE_CTRL_OFFSET, BIT6, BIT0);
  903182:	30c0c1        	excw
  903185:	c4b0      	movi.n	a11, 64
  903187:	581f76        	call8	90af60 <io32_rmw>
#if SYSTEM_MODULE_HP_EP5
		io32_set_usb(ZM_SOC_USB_MODE_CTRL_OFFSET, BIT8);
  90318a:	da30      	mov.n	a10, a3
  90318c:	c0c0      	movi.n	a12, 0
  90318e:	2b1a00        	movi	a11, 0x100
  903191:	581f73        	call8	90af60 <io32_rmw>
#endif

#if SYSTEM_MODULE_HP_EP6
		io32_set_usb(ZM_SOC_USB_MODE_CTRL_OFFSET, BIT9);
  903194:	da30      	mov.n	a10, a3
  903196:	c0c0      	movi.n	a12, 0
  903198:	2b2a00        	movi	a11, 0x200
  90319b:	581f71        	call8	90af60 <io32_rmw>
#endif
		/* enable down stream DMA mode */
		io32_set_usb(ZM_SOC_USB_MODE_CTRL_OFFSET, BIT0);
  90319e:	da30      	mov.n	a10, a3
  9031a0:	c0c0      	movi.n	a12, 0
  9031a2:	2b0a01        	movi	a11, 1
  9031a5:	581f6e        	call8	90af60 <io32_rmw>
#endif

#ifdef FUSION_USB_ENABLE_RX_STREAM
		/* Patch for K2 USB STREAM mode */
		/* disable upstream DMA mode and enable upstream stream mode */
		io32_clr_usb(ZM_SOC_USB_MODE_CTRL_OFFSET, BIT1 | BIT3);
  9031a8:	da30      	mov.n	a10, a3
  9031aa:	c0ca      	movi.n	a12, 10
  9031ac:	c0b0      	movi.n	a11, 0
  9031ae:	581f6c        	call8	90af60 <io32_rmw>

		/* K2, Set maximum IN transfer to 8K */
		io32_rmw_usb(ZM_SOC_USB_MODE_CTRL_OFFSET, 0x20, 0x30);
  9031b1:	da30      	mov.n	a10, a3
  9031b3:	c3c0      	movi.n	a12, 48
  9031b5:	c2b0      	movi.n	a11, 32
  9031b7:	581f6a        	call8	90af60 <io32_rmw>

		/* enable upstream DMA mode */
		io32_set_usb(ZM_SOC_USB_MODE_CTRL_OFFSET, BIT1);
  9031ba:	da30      	mov.n	a10, a3
  9031bc:	c0c0      	movi.n	a12, 0
  9031be:	2b0a02        	movi	a11, 2
  9031c1:	581f67        	call8	90af60 <io32_rmw>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  9031c4:	137192        	l32r	a3, 8df80c <_bss_end+0x3d2004>
  9031c7:	240aa0        	movi	a4, 160
  9031ca:	0c0200        	memw
  9031cd:	9430      	s32i.n	a4, a3, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  9031cf:	137193        	l32r	a3, 8df81c <_bss_end+0x3d2014>
  9031d2:	0c0200        	memw
  9031d5:	8430      	l32i.n	a4, a3, 0
  9031d7:	137194        	l32r	a3, 8df828 <_bss_end+0x3d2020>

		/* set stream mode timeout critirea */
		iowrite32_usb(ZM_SOC_USB_TIME_CTRL_OFFSET, 0xa0);
#if defined(PROJECT_K2)
		/*0x10004020 is vaild in k2 but could be invaild in other chip*/
		if ((ioread32(0x10004020) & 0x2000) != 0) {
  9031da:	724704        	bbci	a4, 18, 9031e2 <app_start+0x1e2>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  9031dd:	c040      	movi.n	a4, 0
  9031df:	600001        	j	9031e4 <app_start+0x1e4>
  9031e2:	c049      	movi.n	a4, 9
  9031e4:	0c0200        	memw
  9031e7:	9430      	s32i.n	a4, a3, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  9031e9:	137195        	l32r	a3, 8df840 <_bss_end+0x3d2038>
	}
#if defined(PROJECT_MAGPIE) && !defined(ROM_VER_1_1)
	else if (hostif == HIF_PCI )
		hif_pci_patch_install(&_indir_tbl.hif);
#endif
	A_PRINTF("USB mode: 0x%x\r\n", ioread32_usb(0x100));
  9031ec:	1a7196        	l32r	a10, 8df844 <_bss_end+0x3d203c>
  9031ef:	0c0200        	memw
  9031f2:	8b30      	l32i.n	a11, a3, 0
  9031f4:	232212        	l32i	a3, a2, 72
  9031f7:	0b3000        	callx8	a3

	// patch the clock function
	if(1) {
		_indir_tbl.cmnos.clock._clock_init = cmnos_clock_init_patch;
  9031fa:	137197        	l32r	a3, 8df858 <_bss_end+0x3d2050>
		_indir_tbl.cmnos.clock._delay_us = cmnos_delay_us_patch;
		_indir_tbl.cmnos.clock._clock_tick = cmnos_tick_patch;
		_indir_tbl.cmnos.clock._milliseconds = cmnos_milliseconds_patch;

		//default clock, setup initial variable, SYSTEM_FREQ=40
		A_CLOCK_INIT(SYSTEM_FREQ);
  9031fd:	c2a8      	movi.n	a10, 40
#endif
	A_PRINTF("USB mode: 0x%x\r\n", ioread32_usb(0x100));

	// patch the clock function
	if(1) {
		_indir_tbl.cmnos.clock._clock_init = cmnos_clock_init_patch;
  9031ff:	232637        	s32i	a3, a2, 220
		_indir_tbl.cmnos.clock._refclk_speed_get = cmnos_refclk_speed_get_patch;
  903202:	137198        	l32r	a3, 8df864 <_bss_end+0x3d205c>
  903205:	23263c        	s32i	a3, a2, 240
		_indir_tbl.cmnos.clock._delay_us = cmnos_delay_us_patch;
  903208:	137199        	l32r	a3, 8df86c <_bss_end+0x3d2064>
  90320b:	23263a        	s32i	a3, a2, 232
		_indir_tbl.cmnos.clock._clock_tick = cmnos_tick_patch;
  90320e:	13719a        	l32r	a3, 8df878 <_bss_end+0x3d2070>
  903211:	232640        	s32i	a3, a2, 0x100
		_indir_tbl.cmnos.clock._milliseconds = cmnos_milliseconds_patch;
  903214:	13719b        	l32r	a3, 8df880 <_bss_end+0x3d2078>
  903217:	23263d        	s32i	a3, a2, 244

		//default clock, setup initial variable, SYSTEM_FREQ=40
		A_CLOCK_INIT(SYSTEM_FREQ);
  90321a:	580611        	call8	904a60 <cmnos_clock_init_patch>
	}

	Magpie_init();
  90321d:	580042        	call8	903328 <Magpie_init>

#if MAGPIE_ENABLE_WLAN == 1
	io32_clr(MAGPIE_REG_RST_RESET_ADDR, BIT10 | BIT8 | BIT7 | BIT6);
  903220:	1a719c        	l32r	a10, 8df890 <_bss_end+0x3d2088>
  903223:	2c5ac0        	movi	a12, 0x5c0
  903226:	2b0a00        	movi	a11, 0
  903229:	581f4d        	call8	90af60 <io32_rmw>
#if defined(PROJECT_MAGPIE)
	io32_set(MAGPIE_REG_AHB_ARB_ADDR, BIT1);
#endif

	wlan_pci_module_init();
  90322c:	580273        	call8	903bfc <wlan_pci_module_init>
	wlan_pci_probe();
  90322f:	58027a        	call8	903c18 <wlan_pci_probe>
#endif


	A_PRINTF("Tgt running\n\r");
  903232:	1a719d        	l32r	a10, 8df8a8 <_bss_end+0x3d20a0>
  903235:	222212        	l32i	a2, a2, 72
  903238:	0b2000        	callx8	a2
		_indir_tbl.cmnos.misc._assfail = exception_reset;
	}

	change_magpie_clk();
#endif
	wlan_task(); //never return
  90323b:	58000f        	call8	903278 <wlan_task>

Disassembly of section .text:

00903240 <init_mem>:
	}
}
#endif

void init_mem()
{
  903240:	6c1004        	entry	a1, 32
	int i = 0;
	uint32_t *temp = (uint32_t *)ALLOCRAM_START;

	/* clear bss segment */
	for(temp = (uint32_t *)&START_BSS; temp < (uint32_t *)&END_BSS; temp++)
  903243:	18719e        	l32r	a8, 8df8bc <_bss_end+0x3d20b4>
  903246:	19719f        	l32r	a9, 8df8c4 <_bss_end+0x3d20bc>
		*temp = 0;
  903249:	c0a0      	movi.n	a10, 0
{
	int i = 0;
	uint32_t *temp = (uint32_t *)ALLOCRAM_START;

	/* clear bss segment */
	for(temp = (uint32_t *)&START_BSS; temp < (uint32_t *)&END_BSS; temp++)
  90324b:	600003        	j	903252 <init_mem+0x12>
		*temp = 0;
  90324e:	9a80      	s32i.n	a10, a8, 0
{
	int i = 0;
	uint32_t *temp = (uint32_t *)ALLOCRAM_START;

	/* clear bss segment */
	for(temp = (uint32_t *)&START_BSS; temp < (uint32_t *)&END_BSS; temp++)
  903250:	b488      	addi.n	a8, a8, 4
  903252:	7983f8        	bltu	a8, a9, 90324e <init_mem+0xe>
		*temp = 0;

	/* clear heap segment */
	for(i = 0; i < ((ALLOCRAM_SIZE - 4)/4); i++)
  903255:	1a7184        	l32r	a10, 8df868 <_bss_end+0x3d2060>
  903258:	1971a0        	l32r	a9, 8df8d8 <_bss_end+0x3d20d0>
  90325b:	0a990c        	sub	a9, a9, a10
  90325e:	092914        	srli	a9, a9, 2
  903261:	0e9911        	slli	a9, a9, 2
  903264:	a989      	add.n	a9, a8, a9
		temp[i] = 0;
  903266:	c0a0      	movi.n	a10, 0
  903268:	600004        	j	903270 <init_mem+0x30>
  90326b:	009a80        	excw
  90326e:	b488      	addi.n	a8, a8, 4
	/* clear bss segment */
	for(temp = (uint32_t *)&START_BSS; temp < (uint32_t *)&END_BSS; temp++)
		*temp = 0;

	/* clear heap segment */
	for(i = 0; i < ((ALLOCRAM_SIZE - 4)/4); i++)
  903270:	7989f8        	bne	a8, a9, 90326c <init_mem+0x2c>
		temp[i] = 0;
}
  903273:	d10f      	retw.n
  903275:	000000        	ill

00903278 <wlan_task>:
	}
	return;
}

void __noreturn wlan_task(void)
{
  903278:	6c1004        	entry	a1, 32
	loop_low=loop_high=0;
  90327b:	1471a1        	l32r	a4, 8df900 <_bss_end+0x3d20f8>
  90327e:	1371a2        	l32r	a3, 8df908 <_bss_end+0x3d2100>
  903281:	c020      	movi.n	a2, 0
  903283:	9240      	s32i.n	a2, a4, 0
  903285:	9230      	s32i.n	a2, a3, 0

	while(1) {
		/* update wdt timer */
		A_WDT_TASK();
  903287:	12716e        	l32r	a2, 8df840 <_bss_end+0x3d2038>
  90328a:	28225c        	l32i	a8, a2, 0x170
  90328d:	0b8000        	callx8	a8

		/* UPDATE cticks - to be moved to idle_tsk, put here will be easier to read  */
		A_CLOCK_TICK();
  903290:	282240        	l32i	a8, a2, 0x100
  903293:	0b8000        	callx8	a8

		HIF_isr_handler(NULL);
  903296:	282280        	l32i	a8, a2, 0x200
  903299:	c0a0      	movi.n	a10, 0
  90329b:	0b8000        	callx8	a8

#if MAGPIE_ENABLE_WLAN == 1
		wlan_pci_isr();
  90329e:	580282        	call8	903ca8 <wlan_pci_isr>
#endif

		A_TASKLET_RUN();
  9032a1:	28226d        	l32i	a8, a2, 0x1b4
  9032a4:	0b8000        	callx8	a8
		A_TIMER_RUN();
  9032a7:	282245        	l32i	a8, a2, 0x114
  9032aa:	0b8000        	callx8	a8
		temp[i] = 0;
}

static void idle_task()
{
	if (loop_low == 0xffffffff) {
  9032ad:	8830      	l32i.n	a8, a3, 0
  9032af:	69800d        	bnei	a8, -1, 9032c0 <wlan_task+0x48>
		loop_low = 0;
  9032b2:	c080      	movi.n	a8, 0
  9032b4:	9830      	s32i.n	a8, a3, 0
		loop_high++;
  9032b6:	8840      	l32i.n	a8, a4, 0
  9032b8:	b188      	addi.n	a8, a8, 1
  9032ba:	9840      	s32i.n	a8, a4, 0
  9032bc:	63ffca        	j	90328a <wlan_task+0x12>
  9032bf:	00b188        	excw
	} else {
		loop_low++;
  9032c2:	9830      	s32i.n	a8, a3, 0
  9032c4:	63ffc2        	j	90328a <wlan_task+0x12>
	...

009032c8 <htc_setup_comp>:
#define MAGPIE 1

#if MAGPIE==1

void htc_setup_comp(void)
{
  9032c8:	6c1004        	entry	a1, 32
  9032cb:	d10f      	retw.n
  9032cd:	000000        	ill

009032d0 <_wmi_cmd_rsp>:
	}
}

void _wmi_cmd_rsp(void *pContext, WMI_COMMAND_ID cmd_id, A_UINT16 SeqNo,
		  A_UINT8 *buffer, int Length)
{
  9032d0:	6c1006        	entry	a1, 48
	adf_nbuf_t netbuf = ADF_NBUF_NULL;
	A_UINT8 *pData;

	netbuf = WMI_AllocEvent(pContext, WMI_EVT_CLASS_CMD_REPLY, sizeof(WMI_CMD_HDR) + Length);
  9032d3:	17716e        	l32r	a7, 8df88c <_bss_end+0x3d2084>
  9032d6:	2c6c04        	addi	a12, a6, 4
  9032d9:	287292        	l32i	a8, a7, 0x248
  9032dc:	c0b1      	movi.n	a11, 1
  9032de:	022a02        	or	a10, a2, a2
  9032e1:	0b8000        	callx8	a8
	}
}

void _wmi_cmd_rsp(void *pContext, WMI_COMMAND_ID cmd_id, A_UINT16 SeqNo,
		  A_UINT8 *buffer, int Length)
{
  9032e4:	04044f        	extui	a4, a4, 0, 16
	adf_nbuf_t netbuf = ADF_NBUF_NULL;
	A_UINT8 *pData;

	netbuf = WMI_AllocEvent(pContext, WMI_EVT_CLASS_CMD_REPLY, sizeof(WMI_CMD_HDR) + Length);
  9032e7:	d8a0      	mov.n	a8, a10
    
	if (netbuf == ADF_NBUF_NULL) {
  9032e9:	cda1      	bnez.n	a10, 9032fe <_wmi_cmd_rsp+0x2e>
		adf_os_print("%s: buffer allocation for event_id %x failed!\n", __FUNCTION__, cmd_id);
  9032eb:	227212        	l32i	a2, a7, 72
  9032ee:	1b71a3        	l32r	a11, 8df97c <_bss_end+0x3d2174>
  9032f1:	1a71a4        	l32r	a10, 8df984 <_bss_end+0x3d217c>
  9032f4:	dc30      	mov.n	a12, a3
  9032f6:	0b2000        	callx8	a2
  9032f9:	63fffc        	j	9032f9 <_wmi_cmd_rsp+0x29>
  9032fc:	0000c9        	excw
		adf_os_assert(0);
		return;
	}

	if (Length != 0 && buffer != NULL) {
  9032ff:	62c950        	j	8efc53 <memset+0xaab7>
 *         put, or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_put_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_put_tail(buf, size);
  903302:	db60      	mov.n	a11, a6
  903304:	9a10      	s32i.n	a10, a1, 0
  903306:	5800ba        	call8	9035f0 <__adf_nbuf_put_tail>
}

/* move a memory buffer */
static inline void 		__adf_os_mem_copy(void *dst, const void *src, adf_os_size_t size)
{
    A_MEMCPY(dst,src,size);    
  903309:	8975      	l32i.n	a9, a7, 20
  90330b:	dc60      	mov.n	a12, a6
  90330d:	db50      	mov.n	a11, a5
  90330f:	0b9000        	callx8	a9
  903312:	8810      	l32i.n	a8, a1, 0
		pData = (A_UINT8 *)adf_nbuf_put_tail(netbuf, Length);
		adf_os_mem_copy(pData, buffer, Length);
	}

	WMI_SendEvent(pContext, netbuf, cmd_id, SeqNo, Length);
  903314:	257293        	l32i	a5, a7, 0x24c
  903317:	de60      	mov.n	a14, a6
  903319:	dd40      	mov.n	a13, a4
  90331b:	030c4f        	extui	a12, a3, 0, 16
  90331e:	db80      	mov.n	a11, a8
  903320:	da20      	mov.n	a10, a2
  903322:	0b5000        	callx8	a5
  903325:	d10f      	retw.n
	...

00903328 <Magpie_init>:
}


void Magpie_init(void)
{
  903328:	6c1004        	entry	a1, 32
	A_PRINTF("[+++Magpie_init]\n\r");
  90332b:	12716e        	l32r	a2, 8df8e4 <_bss_end+0x3d20dc>
  90332e:	1a71a5        	l32r	a10, 8df9c4 <_bss_end+0x3d21bc>
  903331:	232212        	l32i	a3, a2, 72
  903334:	0b3000        	callx8	a3
 
	A_PRINTF("[+++VBUF_init(%d)]\n\r", MAX_BUF_NUM);
  903337:	1371a6        	l32r	a3, 8df9d0 <_bss_end+0x3d21c8>
  90333a:	282212        	l32i	a8, a2, 72
  90333d:	2b0a64        	movi	a11, 100
  903340:	da30      	mov.n	a10, a3
  903342:	0b8000        	callx8	a8
	VBUF_init(MAX_BUF_NUM);
  903345:	2822a5        	l32i	a8, a2, 0x294
  903348:	2a0a64        	movi	a10, 100
  90334b:	0b8000        	callx8	a8
    
	A_PRINTF("[+++VBUF_init(%d)]\n\r", MAX_DESC_NUM);
  90334e:	282212        	l32i	a8, a2, 72
  903351:	2b0a64        	movi	a11, 100
  903354:	da30      	mov.n	a10, a3
  903356:	0b8000        	callx8	a8
	VDESC_init(MAX_DESC_NUM);
  903359:	2222aa        	l32i	a2, a2, 0x2a8
  90335c:	2a0a64        	movi	a10, 100
  90335f:	0b2000        	callx8	a2
  903362:	d10f      	retw.n

00903364 <__adf_nbuf_alloc>:
 * @return newly allocated nbuf
 */
__adf_nbuf_t 
__adf_nbuf_alloc(adf_os_size_t size, a_uint32_t reserve, 
                 a_uint32_t align)
{
  903364:	6c1004        	entry	a1, 32
    VBUF *buf = NULL;
    VDESC *desc;
    
    buf = VBUF_alloc_vbuf();
  903367:	15716e        	l32r	a5, 8df920 <_bss_end+0x3d2118>
 * @return newly allocated nbuf
 */
__adf_nbuf_t 
__adf_nbuf_alloc(adf_os_size_t size, a_uint32_t reserve, 
                 a_uint32_t align)
{
  90336a:	d620      	mov.n	a6, a2
    VBUF *buf = NULL;
    VDESC *desc;
    
    buf = VBUF_alloc_vbuf();
  90336c:	2a52a6        	l32i	a10, a5, 0x298
  90336f:	0ba000        	callx8	a10
  903372:	d2a0      	mov.n	a2, a10
    if ( buf != NULL ) {
  903374:	64a028        	beqz	a10, 9033a0 <__adf_nbuf_alloc+0x3c>
        desc = VDESC_alloc_vdesc();
  903377:	2a52ab        	l32i	a10, a5, 0x2ac
  90337a:	0ba000        	callx8	a10
        desc->buf_addr = (A_UINT8 *)A_ALLOCRAM(size);
  90337d:	255252        	l32i	a5, a5, 0x148
    VBUF *buf = NULL;
    VDESC *desc;
    
    buf = VBUF_alloc_vbuf();
    if ( buf != NULL ) {
        desc = VDESC_alloc_vdesc();
  903380:	d4a0      	mov.n	a4, a10
        desc->buf_addr = (A_UINT8 *)A_ALLOCRAM(size);
  903382:	db60      	mov.n	a11, a6
  903384:	c0a0      	movi.n	a10, 0
  903386:	0b5000        	callx8	a5
        desc->buf_size = size;
        desc->next_desc = NULL;
  903389:	c080      	movi.n	a8, 0
    VDESC *desc;
    
    buf = VBUF_alloc_vbuf();
    if ( buf != NULL ) {
        desc = VDESC_alloc_vdesc();
        desc->buf_addr = (A_UINT8 *)A_ALLOCRAM(size);
  90338b:	9a41      	s32i.n	a10, a4, 4
        desc->buf_size = size;
  90338d:	264504        	s16i	a6, a4, 8
        desc->next_desc = NULL;
  903390:	9840      	s32i.n	a8, a4, 0
        desc->data_offset = reserve;
  903392:	234505        	s16i	a3, a4, 10
        desc->data_size = 0;
  903395:	284506        	s16i	a8, a4, 12
        desc->control = 0;    
  903398:	284507        	s16i	a8, a4, 14
        
        buf->desc_list = desc;
  90339b:	9420      	s32i.n	a4, a2, 0
        buf->buf_length = 0;    
  90339d:	282504        	s16i	a8, a2, 8
    }
    
    return buf;
}   
  9033a0:	d10f      	retw.n
	...

009033a4 <__adf_nbuf_free>:
 * @param hdl
 * @param adf_nbuf
 * 
 */
void __adf_nbuf_free(__adf_nbuf_t  buf)
{
  9033a4:	6c1004        	entry	a1, 32
  9033a7:	63fffc        	j	9033a7 <__adf_nbuf_free+0x3>
	...

009033ac <__adf_nbuf_realloc_headroom>:
 * 
 * @return new nbuf
 */
__adf_nbuf_t 
__adf_nbuf_realloc_headroom(__adf_nbuf_t buf, a_uint32_t headroom)
{
  9033ac:	6c1004        	entry	a1, 32
  9033af:	63fffc        	j	9033af <__adf_nbuf_realloc_headroom+0x3>
	...

009033b4 <__adf_nbuf_realloc_tailroom>:
 * 
 * @return struct mbuf * (buffer with the new tailroom)
 */
__adf_nbuf_t 
__adf_nbuf_realloc_tailroom(__adf_nbuf_t  buf, a_uint32_t tailroom)
{
  9033b4:	6c1004        	entry	a1, 32
  9033b7:	63fffc        	j	9033b7 <__adf_nbuf_realloc_tailroom+0x3>
	...

009033bc <__adf_nbuf_expand>:
 * 
 * @return struct mbuf* (NULL if something goofed up)
 */
__adf_nbuf_t 
__adf_nbuf_expand(__adf_nbuf_t buf, a_uint32_t headroom, a_uint32_t tailroom)
{
  9033bc:	6c1004        	entry	a1, 32
  9033bf:	63fffc        	j	9033bf <__adf_nbuf_expand+0x3>
	...

009033c4 <__adf_nbuf_push_head>:
 * @return new data pointer ,NULL if the len is more than the
 *         space available in the head frag.
 */
a_uint8_t *       
__adf_nbuf_push_head(__adf_nbuf_t buf, adf_os_size_t len)
{
  9033c4:	6c1004        	entry	a1, 32
    a_uint8_t *ptr = NULL; 
    VDESC *desc = buf->desc_list;
  9033c7:	8920      	l32i.n	a9, a2, 0
    
    desc->data_offset -= len;
  9033c9:	03034f        	extui	a3, a3, 0, 16
    desc->data_size += len;
  9033cc:	2a9106        	l16ui	a10, a9, 12
__adf_nbuf_push_head(__adf_nbuf_t buf, adf_os_size_t len)
{
    a_uint8_t *ptr = NULL; 
    VDESC *desc = buf->desc_list;
    
    desc->data_offset -= len;
  9033cf:	289105        	l16ui	a8, a9, 10
    desc->data_size += len;
  9033d2:	aa3a      	add.n	a10, a3, a10
  9033d4:	2a9506        	s16i	a10, a9, 12
__adf_nbuf_push_head(__adf_nbuf_t buf, adf_os_size_t len)
{
    a_uint8_t *ptr = NULL; 
    VDESC *desc = buf->desc_list;
    
    desc->data_offset -= len;
  9033d7:	03880c        	sub	a8, a8, a3
    desc->data_size += len;
    buf->buf_length += len;
  9033da:	2a2104        	l16ui	a10, a2, 8
__adf_nbuf_push_head(__adf_nbuf_t buf, adf_os_size_t len)
{
    a_uint8_t *ptr = NULL; 
    VDESC *desc = buf->desc_list;
    
    desc->data_offset -= len;
  9033dd:	08084f        	extui	a8, a8, 0, 16
  9033e0:	289505        	s16i	a8, a9, 10
    desc->data_size += len;
    buf->buf_length += len;
  9033e3:	aa33      	add.n	a3, a3, a10
  9033e5:	232504        	s16i	a3, a2, 8
    ptr = desc->buf_addr + desc->data_offset;
  9033e8:	8291      	l32i.n	a2, a9, 4
    return(ptr);
}
  9033ea:	a822      	add.n	a2, a2, a8
  9033ec:	d10f      	retw.n
	...

009033f0 <__adf_nbuf_pull_head>:
 * 
 * @return new data pointer
 */
a_uint8_t * 
__adf_nbuf_pull_head(__adf_nbuf_t buf, adf_os_size_t len)
{
  9033f0:	6c1004        	entry	a1, 32
    a_uint8_t *ptr = NULL;
    VDESC *desc = buf->desc_list;
  9033f3:	8920      	l32i.n	a9, a2, 0
    
    desc->data_offset += len;
  9033f5:	030a4f        	extui	a10, a3, 0, 16
    desc->data_size -= len;
  9033f8:	239106        	l16ui	a3, a9, 12
__adf_nbuf_pull_head(__adf_nbuf_t buf, adf_os_size_t len)
{
    a_uint8_t *ptr = NULL;
    VDESC *desc = buf->desc_list;
    
    desc->data_offset += len;
  9033fb:	289105        	l16ui	a8, a9, 10
    desc->data_size -= len;
  9033fe:	0a330c        	sub	a3, a3, a10
  903401:	239506        	s16i	a3, a9, 12
__adf_nbuf_pull_head(__adf_nbuf_t buf, adf_os_size_t len)
{
    a_uint8_t *ptr = NULL;
    VDESC *desc = buf->desc_list;
    
    desc->data_offset += len;
  903404:	a8a8      	add.n	a8, a10, a8
    desc->data_size -= len;
    buf->buf_length -= len;
  903406:	232104        	l16ui	a3, a2, 8
__adf_nbuf_pull_head(__adf_nbuf_t buf, adf_os_size_t len)
{
    a_uint8_t *ptr = NULL;
    VDESC *desc = buf->desc_list;
    
    desc->data_offset += len;
  903409:	08084f        	extui	a8, a8, 0, 16
  90340c:	289505        	s16i	a8, a9, 10
    desc->data_size -= len;
    buf->buf_length -= len;
  90340f:	0a330c        	sub	a3, a3, a10
  903412:	232504        	s16i	a3, a2, 8
    ptr = desc->buf_addr + desc->data_offset;
  903415:	8291      	l32i.n	a2, a9, 4
    
    return ptr;
}
  903417:	a822      	add.n	a2, a2, a8
  903419:	d10f      	retw.n
	...

0090341c <__adf_nbuf_copy>:
  90341c:	6c1004        	entry	a1, 32
  90341f:	cc21      	bnez.n	a2, 903424 <__adf_nbuf_copy+0x8>
  903421:	63fffc        	j	903421 <__adf_nbuf_copy+0x5>
  903424:	c020      	movi.n	a2, 0
  903426:	d10f      	retw.n

00903428 <__adf_nbuf_unshare>:
 * 
 * @return new nbuf
 */
__adf_nbuf_t 
__adf_nbuf_unshare(__adf_nbuf_t  src)
{
  903428:	6c1004        	entry	a1, 32
    __adf_nbuf_t buf = NULL;

    adf_os_assert(src != NULL);
  90342b:	cc21      	bnez.n	a2, 903430 <__adf_nbuf_unshare+0x8>
  90342d:	63fffc        	j	90342d <__adf_nbuf_unshare+0x5>

    return buf;
}
  903430:	c020      	movi.n	a2, 0
  903432:	d10f      	retw.n

00903434 <__adf_nbuf_frag_info>:
 * @param[out] sg (scatter/gather list of all the frags)
 * 
 */
void  
__adf_nbuf_frag_info(__adf_nbuf_t buf, adf_os_sglist_t	*sg)
{
  903434:	6c1004        	entry	a1, 32
    VDESC *desc = buf->desc_list;
  903437:	8820      	l32i.n	a8, a2, 0
  903439:	b439      	addi.n	a9, a3, 4
    int count = 0;
  90343b:	c0a0      	movi.n	a10, 0
    
    while( desc != NULL ) {
  90343d:	600013        	j	903454 <__adf_nbuf_frag_info+0x20>
        sg->sg_segs[count].vaddr = desc->buf_addr + desc->data_offset;
  903440:	2c8105        	l16ui	a12, a8, 10
  903443:	8b81      	l32i.n	a11, a8, 4
        sg->sg_segs[count].len   = desc->data_size;
        
        count++;        
  903445:	b1aa      	addi.n	a10, a10, 1
{
    VDESC *desc = buf->desc_list;
    int count = 0;
    
    while( desc != NULL ) {
        sg->sg_segs[count].vaddr = desc->buf_addr + desc->data_offset;
  903447:	acbb      	add.n	a11, a11, a12
  903449:	9b90      	s32i.n	a11, a9, 0
        sg->sg_segs[count].len   = desc->data_size;
  90344b:	2b8106        	l16ui	a11, a8, 12
        
        count++;        
        desc = desc->next_desc;
  90344e:	8880      	l32i.n	a8, a8, 0
    VDESC *desc = buf->desc_list;
    int count = 0;
    
    while( desc != NULL ) {
        sg->sg_segs[count].vaddr = desc->buf_addr + desc->data_offset;
        sg->sg_segs[count].len   = desc->data_size;
  903450:	9b91      	s32i.n	a11, a9, 4
  903452:	b899      	addi.n	a9, a9, 8
__adf_nbuf_frag_info(__adf_nbuf_t buf, adf_os_sglist_t	*sg)
{
    VDESC *desc = buf->desc_list;
    int count = 0;
    
    while( desc != NULL ) {
  903454:	658fe8        	bnez	a8, 903440 <__adf_nbuf_frag_info+0xc>
        
        count++;        
        desc = desc->next_desc;
    }
    
    sg->nsegs = count;
  903457:	9a30      	s32i.n	a10, a3, 0
  903459:	d10f      	retw.n
	...

0090345c <__adf_nbuf_get_priv>:
 * 
 * @return uint8_t* ( pointer to the data )
 */
a_uint8_t *
__adf_nbuf_get_priv(__adf_nbuf_t buf)
{
  90345c:	6c1004        	entry	a1, 32
    adf_os_assert(buf != NULL);
  90345f:	cc21      	bnez.n	a2, 903464 <__adf_nbuf_get_priv+0x8>
  903461:	63fffc        	j	903461 <__adf_nbuf_get_priv+0x5>

    return buf->ctx;
}
  903464:	bc22      	addi.n	a2, a2, 12
  903466:	d10f      	retw.n

00903468 <__adf_nbuf_queue_add>:
 * 
 */
void 
__adf_nbuf_queue_add(__adf_nbuf_qhead_t  *qhead, 
                     __adf_nbuf_t  buf)
{
  903468:	6c1004        	entry	a1, 32
    qhead->qlen++;
  90346b:	8822      	l32i.n	a8, a2, 8
  90346d:	b188      	addi.n	a8, a8, 1
  90346f:	9822      	s32i.n	a8, a2, 8

    buf->next_buf = NULL;
  903471:	c080      	movi.n	a8, 0
  903473:	9831      	s32i.n	a8, a3, 4

    if (qhead->head == NULL) {
  903475:	8820      	l32i.n	a8, a2, 0
  903477:	cc83      	bnez.n	a8, 90347e <__adf_nbuf_queue_add+0x16>
        qhead->head = buf;
  903479:	9320      	s32i.n	a3, a2, 0
  90347b:	600003        	j	903482 <__adf_nbuf_queue_add+0x1a>
    }
    else {
        qhead->tail->next_buf = buf;
  90347e:	8821      	l32i.n	a8, a2, 4
  903480:	9381      	s32i.n	a3, a8, 4
    }
    qhead->tail = buf;
  903482:	9321      	s32i.n	a3, a2, 4
  903484:	d10f      	retw.n
	...

00903488 <__adf_nbuf_queue_remove>:
 * 
 * @return the nbuf
 */
__adf_nbuf_t   
__adf_nbuf_queue_remove(__adf_nbuf_qhead_t *qhead)
{
  903488:	6c1004        	entry	a1, 32
  90348b:	d820      	mov.n	a8, a2
    __adf_nbuf_t  b0 = NULL;

    if (qhead->head) {
  90348d:	8220      	l32i.n	a2, a2, 0
  90348f:	c929      	beqz.n	a2, 9034ac <__adf_nbuf_queue_remove+0x24>
        qhead->qlen--;
  903491:	8982      	l32i.n	a9, a8, 8
        b0 = qhead->head;
        if ( qhead->head == qhead->tail ) {
  903493:	8a81      	l32i.n	a10, a8, 4
__adf_nbuf_queue_remove(__adf_nbuf_qhead_t *qhead)
{
    __adf_nbuf_t  b0 = NULL;

    if (qhead->head) {
        qhead->qlen--;
  903495:	b099      	addi.n	a9, a9, -1
  903497:	9982      	s32i.n	a9, a8, 8
  903499:	c090      	movi.n	a9, 0
        b0 = qhead->head;
        if ( qhead->head == qhead->tail ) {
  90349b:	7a2907        	bne	a2, a10, 9034a6 <__adf_nbuf_queue_remove+0x1e>
            qhead->head = NULL;
  90349e:	9980      	s32i.n	a9, a8, 0
            qhead->tail = NULL;
  9034a0:	9981      	s32i.n	a9, a8, 4
  9034a2:	600004        	j	9034aa <__adf_nbuf_queue_remove+0x22>
  9034a5:	008a21        	excw
        } else {
            qhead->head = qhead->head->next_buf;
  9034a8:	9a80      	s32i.n	a10, a8, 0
        }
    
        b0->next_buf = NULL;
  9034aa:	9921      	s32i.n	a9, a2, 4
    }
	return b0;
}
  9034ac:	d10f      	retw.n
	...

009034b0 <__adf_nbuf_dmamap_create>:
 * 
 * @return a_status_t
 */
a_status_t 
__adf_nbuf_dmamap_create(__adf_os_device_t osdev, __adf_os_dma_map_t *dmap)
{
  9034b0:	6c1004        	entry	a1, 32
    a_status_t retval = A_STATUS_OK;
    
    (*dmap) = A_ALLOCRAM(sizeof(struct __adf_dma_map));
  9034b3:	12716e        	l32r	a2, 8dfa6c <_bss_end+0x3d2264>
  9034b6:	c0bc      	movi.n	a11, 12
  9034b8:	222252        	l32i	a2, a2, 0x148
  9034bb:	c0a0      	movi.n	a10, 0
  9034bd:	0b2000        	callx8	a2
  9034c0:	9a30      	s32i.n	a10, a3, 0
    if(*dmap == NULL)
        return A_STATUS_ENOMEM;
  9034c2:	c023      	movi.n	a2, 3
__adf_nbuf_dmamap_create(__adf_os_device_t osdev, __adf_os_dma_map_t *dmap)
{
    a_status_t retval = A_STATUS_OK;
    
    (*dmap) = A_ALLOCRAM(sizeof(struct __adf_dma_map));
    if(*dmap == NULL)
  9034c4:	c8a2      	beqz.n	a10, 9034ca <__adf_nbuf_dmamap_create+0x1a>
        return A_STATUS_ENOMEM;
            
    (*dmap)->buf = NULL;
  9034c6:	c020      	movi.n	a2, 0
  9034c8:	92a0      	s32i.n	a2, a10, 0
    return retval;
}
  9034ca:	d10f      	retw.n

009034cc <__adf_nbuf_map>:


a_status_t 
__adf_nbuf_map(__adf_os_device_t osdev, __adf_os_dma_map_t bmap, 
                          __adf_nbuf_t buf, adf_os_dma_dir_t dir)
{   
  9034cc:	6c1004        	entry	a1, 32
    bmap->buf = buf;
  9034cf:	9430      	s32i.n	a4, a3, 0
    
    return A_STATUS_OK;
}
  9034d1:	c020      	movi.n	a2, 0
  9034d3:	d10f      	retw.n
  9034d5:	000000        	ill

009034d8 <__adf_nbuf_unmap>:

void 
__adf_nbuf_unmap(__adf_os_device_t osdev, __adf_os_dma_map_t bmap, 
                            adf_os_dma_dir_t dir)
{
  9034d8:	6c1004        	entry	a1, 32
    bmap->buf = NULL;
  9034db:	c080      	movi.n	a8, 0
  9034dd:	9830      	s32i.n	a8, a3, 0
  9034df:	d10f      	retw.n
  9034e1:	000000        	ill

009034e4 <__adf_nbuf_dmamap_destroy>:
  9034e4:	6c1004        	entry	a1, 32
  9034e7:	d10f      	retw.n
  9034e9:	000000        	ill

009034ec <__adf_nbuf_dmamap_info>:
 * @param[in]  bmap
 * @param[out] sg (map_info ptr)
 */
void 
__adf_nbuf_dmamap_info(__adf_os_dma_map_t bmap, adf_os_dmamap_info_t *sg)
{
  9034ec:	6c1004        	entry	a1, 32
    VDESC *desc = bmap->buf->desc_list;
  9034ef:	8820      	l32i.n	a8, a2, 0
  9034f1:	b439      	addi.n	a9, a3, 4
  9034f3:	8880      	l32i.n	a8, a8, 0
    int count = 0;
  9034f5:	c0a0      	movi.n	a10, 0
    
    while( desc != NULL ) {
  9034f7:	600015        	j	903510 <__adf_nbuf_dmamap_info+0x24>
  9034fa:	00002c        	excw
        sg->dma_segs[count].paddr = (adf_os_dma_addr_t)(desc->buf_addr + desc->data_offset);
  9034fd:	8105      	l32i.n	a1, a0, 20
  9034ff:	8b81      	l32i.n	a11, a8, 4
        sg->dma_segs[count].len   = desc->data_size;
        
        count++;        
  903501:	b1aa      	addi.n	a10, a10, 1
{
    VDESC *desc = bmap->buf->desc_list;
    int count = 0;
    
    while( desc != NULL ) {
        sg->dma_segs[count].paddr = (adf_os_dma_addr_t)(desc->buf_addr + desc->data_offset);
  903503:	acbb      	add.n	a11, a11, a12
  903505:	9b90      	s32i.n	a11, a9, 0
        sg->dma_segs[count].len   = desc->data_size;
  903507:	2b8106        	l16ui	a11, a8, 12
        
        count++;        
        desc = desc->next_desc;
  90350a:	8880      	l32i.n	a8, a8, 0
    VDESC *desc = bmap->buf->desc_list;
    int count = 0;
    
    while( desc != NULL ) {
        sg->dma_segs[count].paddr = (adf_os_dma_addr_t)(desc->buf_addr + desc->data_offset);
        sg->dma_segs[count].len   = desc->data_size;
  90350c:	9b91      	s32i.n	a11, a9, 4
  90350e:	b899      	addi.n	a9, a9, 8
__adf_nbuf_dmamap_info(__adf_os_dma_map_t bmap, adf_os_dmamap_info_t *sg)
{
    VDESC *desc = bmap->buf->desc_list;
    int count = 0;
    
    while( desc != NULL ) {
  903510:	658fe8        	bnez	a8, 9034fc <__adf_nbuf_dmamap_info+0x10>
        
        count++;        
        desc = desc->next_desc;
    }
    
    sg->nsegs = count;    
  903513:	9a30      	s32i.n	a10, a3, 0
  903515:	d10f      	retw.n
	...

00903518 <__adf_nbuf_set_rx_cksum>:
  903518:	6c1004        	entry	a1, 32
  90351b:	d10f      	retw.n
  90351d:	000000        	ill

00903520 <__adf_nbuf_get_vlan_info>:
}

a_status_t      
__adf_nbuf_get_vlan_info(adf_net_handle_t hdl, __adf_nbuf_t buf, 
                         adf_net_vlanhdr_t *vlan)
{
  903520:	6c1004        	entry	a1, 32
    return A_STATUS_OK;
}
  903523:	c020      	movi.n	a2, 0
  903525:	d10f      	retw.n
	...

00903528 <__adf_nbuf_create_frm_frag>:

__adf_nbuf_t
__adf_nbuf_create_frm_frag(__adf_nbuf_queue_t *qhead)
{
  903528:	6c1006        	entry	a1, 48
    VBUF *buf_tmp, *buf_head = NULL;
    VDESC *vdesc_prev = NULL, *vdesc_tmp = NULL;
    a_uint32_t cnt = 0, len = __adf_nbuf_queue_len(qhead);
    a_uint16_t total_len = 0;

    buf_head = VBUF_alloc_vbuf();
  90352b:	14716e        	l32r	a4, 8dfae4 <_bss_end+0x3d22dc>
 * 
 */
a_uint32_t  
__adf_nbuf_queue_len(__adf_nbuf_qhead_t *qhead)
{
    return qhead->qlen;
  90352e:	8322      	l32i.n	a3, a2, 8
    VBUF *buf_tmp, *buf_head = NULL;
    VDESC *vdesc_prev = NULL, *vdesc_tmp = NULL;
    a_uint32_t cnt = 0, len = __adf_nbuf_queue_len(qhead);
    a_uint16_t total_len = 0;

    buf_head = VBUF_alloc_vbuf();
  903530:	2a42a6        	l32i	a10, a4, 0x298
 * 
 */
a_uint32_t  
__adf_nbuf_queue_len(__adf_nbuf_qhead_t *qhead)
{
    return qhead->qlen;
  903533:	9310      	s32i.n	a3, a1, 0
    VBUF *buf_tmp, *buf_head = NULL;
    VDESC *vdesc_prev = NULL, *vdesc_tmp = NULL;
    a_uint32_t cnt = 0, len = __adf_nbuf_queue_len(qhead);
    a_uint16_t total_len = 0;

    buf_head = VBUF_alloc_vbuf();
  903535:	0ba000        	callx8	a10
  903538:	d7a0      	mov.n	a7, a10
    buf_tmp = __adf_nbuf_queue_first(qhead);

    __adf_os_assert(buf_head);
  90353a:	cca2      	bnez.n	a10, 903540 <__adf_nbuf_create_frm_frag+0x18>
  90353c:	63fffc        	j	90353c <__adf_nbuf_create_frm_frag+0x14>
  90353f:	008320        	excw
    __adf_os_assert(buf_tmp);
  903542:	cc32      	bnez.n	a3, 903548 <__adf_nbuf_create_frm_frag+0x20>
  903544:	63fffc        	j	903544 <__adf_nbuf_create_frm_frag+0x1c>
  903547:	008330        	excw

    buf_head->desc_list = buf_tmp->desc_list;
  90354a:	93a0      	s32i.n	a3, a10, 0
__adf_nbuf_create_frm_frag(__adf_nbuf_queue_t *qhead)
{
    VBUF *buf_tmp, *buf_head = NULL;
    VDESC *vdesc_prev = NULL, *vdesc_tmp = NULL;
    a_uint32_t cnt = 0, len = __adf_nbuf_queue_len(qhead);
    a_uint16_t total_len = 0;
  90354c:	c030      	movi.n	a3, 0
__adf_nbuf_t
__adf_nbuf_create_frm_frag(__adf_nbuf_queue_t *qhead)
{
    VBUF *buf_tmp, *buf_head = NULL;
    VDESC *vdesc_prev = NULL, *vdesc_tmp = NULL;
    a_uint32_t cnt = 0, len = __adf_nbuf_queue_len(qhead);
  90354e:	d530      	mov.n	a5, a3

__adf_nbuf_t
__adf_nbuf_create_frm_frag(__adf_nbuf_queue_t *qhead)
{
    VBUF *buf_tmp, *buf_head = NULL;
    VDESC *vdesc_prev = NULL, *vdesc_tmp = NULL;
  903550:	d630      	mov.n	a6, a3
    __adf_os_assert(buf_head);
    __adf_os_assert(buf_tmp);

    buf_head->desc_list = buf_tmp->desc_list;

    while ((buf_tmp = __adf_nbuf_queue_remove(qhead)) != NULL) {
  903552:	600022        	j	903578 <__adf_nbuf_create_frm_frag+0x50>
        cnt++;

        //adf_os_print("merge buf: %x\n", buf_tmp->desc_list->buf_addr + buf_tmp->desc_list->data_offset);

        total_len += buf_tmp->buf_length;
  903555:	28a104        	l16ui	a8, a10, 8
    __adf_os_assert(buf_tmp);

    buf_head->desc_list = buf_tmp->desc_list;

    while ((buf_tmp = __adf_nbuf_queue_remove(qhead)) != NULL) {
        cnt++;
  903558:	b155      	addi.n	a5, a5, 1

        //adf_os_print("merge buf: %x\n", buf_tmp->desc_list->buf_addr + buf_tmp->desc_list->data_offset);

        total_len += buf_tmp->buf_length;
  90355a:	a833      	add.n	a3, a3, a8
  90355c:	03034f        	extui	a3, a3, 0, 16
  90355f:	88a0      	l32i.n	a8, a10, 0

        if (vdesc_prev) {
  903561:	c861      	beqz.n	a6, 903566 <__adf_nbuf_create_frm_frag+0x3e>
            /* link "the last VDESC of previous VBUF" to "the 1st VDESC of this VBUF" */
            vdesc_prev->next_desc = buf_tmp->desc_list;
  903563:	286600        	s32i	a8, a6, 0
  903566:	d680      	mov.n	a6, a8
        }

        /* traverse VDESC list in this VBUF to find out the last VDESC */
        vdesc_tmp = buf_tmp->desc_list;
        while (vdesc_tmp->next_desc) {
  903568:	8880      	l32i.n	a8, a8, 0
  90356a:	658ff8        	bnez	a8, 903566 <__adf_nbuf_create_frm_frag+0x3e>
            vdesc_tmp = vdesc_tmp->next_desc;
        }
        vdesc_prev = vdesc_tmp;

        /* return VBUF to the pool */
        buf_tmp->desc_list = NULL;
  90356d:	98a0      	s32i.n	a8, a10, 0
        buf_tmp->buf_length = 0;
  90356f:	28a504        	s16i	a8, a10, 8
        VBUF_free_vbuf(buf_tmp);
  903572:	2842a8        	l32i	a8, a4, 0x2a0
  903575:	0b8000        	callx8	a8
    __adf_os_assert(buf_head);
    __adf_os_assert(buf_tmp);

    buf_head->desc_list = buf_tmp->desc_list;

    while ((buf_tmp = __adf_nbuf_queue_remove(qhead)) != NULL) {
  903578:	da20      	mov.n	a10, a2
  90357a:	5bffc3        	call8	903488 <__adf_nbuf_queue_remove>
  90357d:	65afd4        	bnez	a10, 903555 <__adf_nbuf_create_frm_frag+0x2d>
        buf_tmp->desc_list = NULL;
        buf_tmp->buf_length = 0;
        VBUF_free_vbuf(buf_tmp);
    }

    if (cnt != len) {
  903580:	8210      	l32i.n	a2, a1, 0
  903582:	725102        	beq	a5, a2, 903588 <__adf_nbuf_create_frm_frag+0x60>
  903585:	63fffc        	j	903585 <__adf_nbuf_create_frm_frag+0x5d>
        //             __adf_nbuf_queue_len(qhead));
        adf_os_assert(0);
    }
    //__adf_os_assert(cnt == len);

    buf_head->buf_length = total_len;
  903588:	237504        	s16i	a3, a7, 8

    return buf_head;
}
  90358b:	d270      	mov.n	a2, a7
  90358d:	d10f      	retw.n
	...

00903590 <__adf_nbuf_split_to_frag>:

void
__adf_nbuf_split_to_frag(__adf_nbuf_t buf, __adf_nbuf_qhead_t *qhead)
{
  903590:	6c1004        	entry	a1, 32
 * @param qhead
 */
void 
__adf_nbuf_queue_init(__adf_nbuf_qhead_t *qhead)
{
    qhead->qlen = 0;
  903593:	c040      	movi.n	a4, 0
  903595:	9432      	s32i.n	a4, a3, 8
    qhead->head = NULL;
  903597:	9430      	s32i.n	a4, a3, 0
    qhead->tail = NULL;
  903599:	9431      	s32i.n	a4, a3, 4
  90359b:	16716e        	l32r	a6, 8dfb54 <_bss_end+0x3d234c>
{
    VBUF *buf_tmp;
    VDESC *desc_tmp = NULL;

    __adf_nbuf_queue_init(qhead);
    desc_tmp = buf->desc_list;
  90359e:	8420      	l32i.n	a4, a2, 0

    while (desc_tmp /*&& desc_tmp->buf_addr*/) {
  9035a0:	600026        	j	9035ca <__adf_nbuf_split_to_frag+0x3a>
        buf_tmp = VBUF_alloc_vbuf();
  9035a3:	2a62a6        	l32i	a10, a6, 0x298
  9035a6:	0ba000        	callx8	a10
  9035a9:	d5a0      	mov.n	a5, a10

        __adf_os_assert(buf_tmp);
  9035ab:	cca2      	bnez.n	a10, 9035b1 <__adf_nbuf_split_to_frag+0x21>
  9035ad:	63fffc        	j	9035ad <__adf_nbuf_split_to_frag+0x1d>
  9035b0:	002741        	extui	a7, a0, 2, 2

        //desc_tmp->data_size = 0;
        buf_tmp->desc_list = desc_tmp;
        //buf_tmp->buf_length = desc_tmp->buf_size;
        buf_tmp->buf_length = desc_tmp->data_size;
  9035b3:	0694a0        	excw
  9035b6:	27a504        	s16i	a7, a10, 8
        buf_tmp->next_buf = NULL;
  9035b9:	c070      	movi.n	a7, 0
  9035bb:	97a1      	s32i.n	a7, a10, 4

        //adf_os_print("split - buf: %x\n", buf_tmp->desc_list->buf_addr + buf_tmp->desc_list->data_offset);

        __adf_nbuf_queue_add(qhead, buf_tmp);
  9035bd:	dba0      	mov.n	a11, a10
  9035bf:	da30      	mov.n	a10, a3
  9035c1:	5bffa9        	call8	903468 <__adf_nbuf_queue_add>

        desc_tmp = desc_tmp->next_desc;

        buf_tmp->desc_list->next_desc = NULL;
  9035c4:	8550      	l32i.n	a5, a5, 0

        //adf_os_print("split - buf: %x\n", buf_tmp->desc_list->buf_addr + buf_tmp->desc_list->data_offset);

        __adf_nbuf_queue_add(qhead, buf_tmp);

        desc_tmp = desc_tmp->next_desc;
  9035c6:	8440      	l32i.n	a4, a4, 0

        buf_tmp->desc_list->next_desc = NULL;
  9035c8:	9750      	s32i.n	a7, a5, 0
    VDESC *desc_tmp = NULL;

    __adf_nbuf_queue_init(qhead);
    desc_tmp = buf->desc_list;

    while (desc_tmp /*&& desc_tmp->buf_addr*/) {
  9035ca:	654fd5        	bnez	a4, 9035a3 <__adf_nbuf_split_to_frag+0x13>
        buf_tmp->desc_list->next_desc = NULL;
    }

    buf->desc_list = NULL;
    buf->buf_length = 0;
    VBUF_free_vbuf(buf);
  9035cd:	2362a8        	l32i	a3, a6, 0x2a0
        desc_tmp = desc_tmp->next_desc;

        buf_tmp->desc_list->next_desc = NULL;
    }

    buf->desc_list = NULL;
  9035d0:	9420      	s32i.n	a4, a2, 0
    buf->buf_length = 0;
  9035d2:	242504        	s16i	a4, a2, 8
    VBUF_free_vbuf(buf);
  9035d5:	da20      	mov.n	a10, a2
  9035d7:	0b3000        	callx8	a3
  9035da:	d10f      	retw.n

009035dc <__adf_nbuf_last>:
 * 
 * @return struct mbuf*
 */
VDESC * 
__adf_nbuf_last(VBUF *buf)
{
  9035dc:	6c1004        	entry	a1, 32
    VDESC *desc = buf->desc_list;
  9035df:	8220      	l32i.n	a2, a2, 0
    
    //for(; desc->next_desc != NULL; desc = desc->next_desc)
    //    ;
    while(desc->next_desc != NULL)
  9035e1:	600001        	j	9035e6 <__adf_nbuf_last+0xa>
  9035e4:	d280      	mov.n	a2, a8
  9035e6:	8820      	l32i.n	a8, a2, 0
  9035e8:	658ff8        	bnez	a8, 9035e4 <__adf_nbuf_last+0x8>
    {
        desc = desc->next_desc;
    }
    
    return desc;
}
  9035eb:	d10f      	retw.n
  9035ed:	000000        	ill

009035f0 <__adf_nbuf_put_tail>:
 * @return previous tail (data+len),NULL if the len is more than
 *         space available
 */
a_uint8_t *
__adf_nbuf_put_tail(__adf_nbuf_t buf, adf_os_size_t len)
{
  9035f0:	6c1004        	entry	a1, 32
    a_uint8_t *tail = NULL;
    VDESC *last_desc = __adf_nbuf_last(buf);
  9035f3:	da20      	mov.n	a10, a2
  9035f5:	5bfff9        	call8	9035dc <__adf_nbuf_last>
    
    tail = last_desc->buf_addr + last_desc->data_offset + last_desc->data_size;
  9035f8:	28a106        	l16ui	a8, a10, 12
  9035fb:	29a105        	l16ui	a9, a10, 10
    last_desc->data_size += len;
  9035fe:	03034f        	extui	a3, a3, 0, 16
__adf_nbuf_put_tail(__adf_nbuf_t buf, adf_os_size_t len)
{
    a_uint8_t *tail = NULL;
    VDESC *last_desc = __adf_nbuf_last(buf);
    
    tail = last_desc->buf_addr + last_desc->data_offset + last_desc->data_size;
  903601:	a899      	add.n	a9, a9, a8
    last_desc->data_size += len;
  903603:	a388      	add.n	a8, a8, a3
  903605:	28a506        	s16i	a8, a10, 12
    buf->buf_length += len;
  903608:	282104        	l16ui	a8, a2, 8
__adf_nbuf_put_tail(__adf_nbuf_t buf, adf_os_size_t len)
{
    a_uint8_t *tail = NULL;
    VDESC *last_desc = __adf_nbuf_last(buf);
    
    tail = last_desc->buf_addr + last_desc->data_offset + last_desc->data_size;
  90360b:	8ba1      	l32i.n	a11, a10, 4
    last_desc->data_size += len;
    buf->buf_length += len;
  90360d:	a833      	add.n	a3, a3, a8
  90360f:	232504        	s16i	a3, a2, 8
    
    return tail;
}
  903612:	a9b2      	add.n	a2, a11, a9
  903614:	d10f      	retw.n
	...

00903618 <__adf_nbuf_trim_tail>:
 * @param len (how much to strip down)
 * 
 */
void 
__adf_nbuf_trim_tail(__adf_nbuf_t buf, adf_os_size_t len)
{
  903618:	6c1004        	entry	a1, 32
    VDESC *last_desc = __adf_nbuf_last(buf);
  90361b:	da20      	mov.n	a10, a2
  90361d:	5bffef        	call8	9035dc <__adf_nbuf_last>
    
    adf_os_assert(buf != NULL);
  903620:	cc21      	bnez.n	a2, 903625 <__adf_nbuf_trim_tail+0xd>
  903622:	63fffc        	j	903622 <__adf_nbuf_trim_tail+0xa>
    last_desc->data_size -= len;
  903625:	28a106        	l16ui	a8, a10, 12
  903628:	03034f        	extui	a3, a3, 0, 16
  90362b:	03880c        	sub	a8, a8, a3
  90362e:	28a506        	s16i	a8, a10, 12
    buf->buf_length -= len;
  903631:	282104        	l16ui	a8, a2, 8
  903634:	03830c        	sub	a3, a8, a3
  903637:	232504        	s16i	a3, a2, 8
  90363a:	d10f      	retw.n

0090363c <__adf_nbuf_headroom>:
 * 
 * @return num of bytes available
 */
a_uint32_t
__adf_nbuf_headroom(__adf_nbuf_t  buf)
{
  90363c:	6c1004        	entry	a1, 32
    return buf->desc_list->data_offset;
  90363f:	8820      	l32i.n	a8, a2, 0
}
  903641:	228105        	l16ui	a2, a8, 10
  903644:	d10f      	retw.n
	...

00903648 <__adf_nbuf_tailroom>:
 * @return num of bytes
 */

a_uint32_t 
__adf_nbuf_tailroom(__adf_nbuf_t  buf)
{
  903648:	6c1004        	entry	a1, 32
    VDESC *last_desc = __adf_nbuf_last(buf);
  90364b:	da20      	mov.n	a10, a2
  90364d:	5bffe3        	call8	9035dc <__adf_nbuf_last>
    
    return last_desc->buf_size - last_desc->data_offset - last_desc->data_size;
  903650:	22a105        	l16ui	a2, a10, 10
  903653:	28a104        	l16ui	a8, a10, 8
  903656:	02880c        	sub	a8, a8, a2
  903659:	22a106        	l16ui	a2, a10, 12
}
  90365c:	02820c        	sub	a2, a8, a2
  90365f:	d10f      	retw.n
  903661:	000000        	ill

00903664 <__adf_nbuf_len>:
 * 
 * @return total length of packet (sum of all frag lengths)
 */ 
a_uint32_t
__adf_nbuf_len(__adf_nbuf_t  buf)
{
  903664:	6c1004        	entry	a1, 32
    return buf->buf_length; 
}
  903667:	222104        	l16ui	a2, a2, 8
  90366a:	d10f      	retw.n

0090366c <__adf_nbuf_clone>:
 * 
 * @return Read-only copy of the nbuf (including clusters)
 */
__adf_nbuf_t 
__adf_nbuf_clone(__adf_nbuf_t  src)
{
  90366c:	6c1004        	entry	a1, 32
    __adf_nbuf_t buf = NULL;
    
    return buf;
}
  90366f:	c020      	movi.n	a2, 0
  903671:	d10f      	retw.n
	...

00903674 <__adf_nbuf_cat>:

void
__adf_nbuf_cat(__adf_nbuf_t dst, __adf_nbuf_t src)
{
  903674:	6c1004        	entry	a1, 32
  903677:	d10f      	retw.n
  903679:	000000        	ill

0090367c <__adf_nbuf_is_cloned>:
 * 
 * @return a_bool_t
 */
a_bool_t
__adf_nbuf_is_cloned(__adf_nbuf_t  buf)
{
  90367c:	6c1004        	entry	a1, 32
    return A_FALSE;
}
  90367f:	c020      	movi.n	a2, 0
  903681:	d10f      	retw.n
	...

00903684 <__adf_nbuf_peek_header>:
 * @brief This will return the header's addr & m_len
 */
void
__adf_nbuf_peek_header(__adf_nbuf_t buf, a_uint8_t   **addr, 
                       a_uint32_t	*len)
{
  903684:	6c1004        	entry	a1, 32
    VDESC *desc = buf->desc_list;
  903687:	8820      	l32i.n	a8, a2, 0
    
    *addr = desc->buf_addr + desc->data_offset;
  903689:	2a8105        	l16ui	a10, a8, 10
  90368c:	8981      	l32i.n	a9, a8, 4
    *len = desc->data_size; 
  90368e:	288106        	l16ui	a8, a8, 12
__adf_nbuf_peek_header(__adf_nbuf_t buf, a_uint8_t   **addr, 
                       a_uint32_t	*len)
{
    VDESC *desc = buf->desc_list;
    
    *addr = desc->buf_addr + desc->data_offset;
  903691:	aa99      	add.n	a9, a9, a10
  903693:	9930      	s32i.n	a9, a3, 0
    *len = desc->data_size; 
  903695:	9840      	s32i.n	a8, a4, 0
  903697:	d10f      	retw.n
  903699:	000000        	ill

0090369c <__adf_nbuf_queue_init>:
 * @brief init the queue
 * @param qhead
 */
void 
__adf_nbuf_queue_init(__adf_nbuf_qhead_t *qhead)
{
  90369c:	6c1004        	entry	a1, 32
    qhead->qlen = 0;
  90369f:	c080      	movi.n	a8, 0
  9036a1:	9822      	s32i.n	a8, a2, 8
    qhead->head = NULL;
  9036a3:	9820      	s32i.n	a8, a2, 0
    qhead->tail = NULL;
  9036a5:	9821      	s32i.n	a8, a2, 4
  9036a7:	d10f      	retw.n
  9036a9:	000000        	ill

009036ac <__adf_nbuf_queue_len>:
 * @return length
 * 
 */
a_uint32_t  
__adf_nbuf_queue_len(__adf_nbuf_qhead_t *qhead)
{
  9036ac:	6c1004        	entry	a1, 32
    return qhead->qlen;
}
  9036af:	8222      	l32i.n	a2, a2, 8
  9036b1:	d10f      	retw.n
	...

009036b4 <__adf_nbuf_queue_first>:
 * 
 * @return (NULL if the Q is empty)
 */
__adf_nbuf_t   
__adf_nbuf_queue_first(__adf_nbuf_queue_t *qhead)
{
  9036b4:	6c1004        	entry	a1, 32
    return qhead->head;
}
  9036b7:	8220      	l32i.n	a2, a2, 0
  9036b9:	d10f      	retw.n
	...

009036bc <__adf_nbuf_queue_next>:
 * 
 * @return (NULL if no packets are there)
 */
__adf_nbuf_t   
__adf_nbuf_queue_next(__adf_nbuf_t  buf)
{
  9036bc:	6c1004        	entry	a1, 32
    return buf->next_buf;
}
  9036bf:	8221      	l32i.n	a2, a2, 4
  9036c1:	d10f      	retw.n
	...

009036c4 <__adf_nbuf_is_queue_empty>:
 * 
 * @return a_bool_t
 */
a_bool_t  
__adf_nbuf_is_queue_empty(__adf_nbuf_qhead_t *qhead)
{
  9036c4:	6c1004        	entry	a1, 32
    return ((qhead->qlen == 0));
  9036c7:	8222      	l32i.n	a2, a2, 8
  9036c9:	c091      	movi.n	a9, 1
  9036cb:	c080      	movi.n	a8, 0
  9036cd:	029838        	moveqz	a8, a9, a2
  9036d0:	d280      	mov.n	a2, a8
}
  9036d2:	d10f      	retw.n

009036d4 <_buf_pool_static_init>:
    pAPIs->_free_buf = _buf_pool_static_free_buf;
    pAPIs->_shutdown = _buf_pool_static_shutdown;
}
 
LOCAL pool_handle_t _buf_pool_static_init(adf_os_handle_t handle)
{
  9036d4:	6c1004        	entry	a1, 32
  9036d7:	c080      	movi.n	a8, 0
#if 1
    int i;
    
    for(i=0; i < POOL_ID_MAX; i++) {
        g_poolCtx.bufQ[i] = NULL;
  9036d9:	1271a7        	l32r	a2, 8dfd78 <_bss_end+0x3d2570>
  9036dc:	db80      	mov.n	a11, a8
LOCAL pool_handle_t _buf_pool_static_init(adf_os_handle_t handle)
{
#if 1
    int i;
    
    for(i=0; i < POOL_ID_MAX; i++) {
  9036de:	290a0a        	movi	a9, 10
  9036e1:	6d9805        	loop	a9, 9036ea <_buf_pool_static_init+0x16>
        g_poolCtx.bufQ[i] = NULL;
  9036e4:	a28a      	add.n	a10, a8, a2
  9036e6:	9ba0      	s32i.n	a11, a10, 0
  9036e8:	b488      	addi.n	a8, a8, 4
    ctx = (BUF_POOL_STATIC_CONTEXT *)adf_os_mem_alloc(sizeof(BUF_POOL_STATIC_CONTEXT));
    ctx->NetHandle = handle;
    
    return ctx; 
#endif    
}      
  9036ea:	d10f      	retw.n

009036ec <_buf_pool_static_shutdown>:
    
LOCAL void _buf_pool_static_shutdown(pool_handle_t handle) 
{
  9036ec:	6c1004        	entry	a1, 32
  9036ef:	d10f      	retw.n
  9036f1:	000000        	ill

009036f4 <_buf_pool_static_create_pool>:
    // SHALL NOT BE USED in FW
}

LOCAL void _buf_pool_static_create_pool(pool_handle_t handle, BUF_POOL_ID poolId, int nItems, int nSize)
{
  9036f4:	6c1006        	entry	a1, 48
        desc->data_size = 0;
        
        buf->buf_length = 0;        
        buf->desc_list = desc;
        
        if ( g_poolCtx.bufQ[poolId] == NULL ) {
  9036f7:	1271a7        	l32r	a2, 8dfd94 <_bss_end+0x3d258c>
  9036fa:	0e3311        	slli	a3, a3, 2
{
    // SHALL NOT BE USED in FW
}

LOCAL void _buf_pool_static_create_pool(pool_handle_t handle, BUF_POOL_ID poolId, int nItems, int nSize)
{
  9036fd:	d940      	mov.n	a9, a4
    VDESC *desc;
    
    //BUF_POOL_STATIC_CONTEXT *ctx = (BUF_POOL_STATIC_CONTEXT *)handle;
    
    for ( i = 0; i < nItems; i++) {
        buf = VBUF_alloc_vbuf();
  9036ff:	16716e        	l32r	a6, 8dfcb8 <_bss_end+0x3d24b0>
    VBUF *buf;
    VDESC *desc;
    
    //BUF_POOL_STATIC_CONTEXT *ctx = (BUF_POOL_STATIC_CONTEXT *)handle;
    
    for ( i = 0; i < nItems; i++) {
  903702:	c040      	movi.n	a4, 0
        desc->data_size = 0;
        
        buf->buf_length = 0;        
        buf->desc_list = desc;
        
        if ( g_poolCtx.bufQ[poolId] == NULL ) {
  903704:	a323      	add.n	a3, a2, a3
    VBUF *buf;
    VDESC *desc;
    
    //BUF_POOL_STATIC_CONTEXT *ctx = (BUF_POOL_STATIC_CONTEXT *)handle;
    
    for ( i = 0; i < nItems; i++) {
  903706:	60003c        	j	903746 <_buf_pool_static_create_pool+0x52>
        buf = VBUF_alloc_vbuf();
  903709:	2a62a6        	l32i	a10, a6, 0x298
  90370c:	9910      	s32i.n	a9, a1, 0
  90370e:	0ba000        	callx8	a10
  903711:	d2a0      	mov.n	a2, a10
        desc = VDESC_alloc_vdesc();
  903713:	2a62ab        	l32i	a10, a6, 0x2ac
  903716:	0ba000        	callx8	a10
#include "Magpie_api.h"

static inline void *	__adf_os_mem_alloc(adf_os_size_t size)
{
//    return (malloc(size,M_DEVBUF,M_DONTWAIT | M_ZERO));
    return A_ALLOCRAM(size);
  903719:	286252        	l32i	a8, a6, 0x148
  90371c:	d7a0      	mov.n	a7, a10
  90371e:	db50      	mov.n	a11, a5
  903720:	c0a0      	movi.n	a10, 0
  903722:	0b8000        	callx8	a8

        desc->buf_addr = (A_UINT8 *)adf_os_mem_alloc(nSize);
        desc->buf_size = nSize;
        desc->data_offset = 0;
  903725:	c080      	movi.n	a8, 0
    
    for ( i = 0; i < nItems; i++) {
        buf = VBUF_alloc_vbuf();
        desc = VDESC_alloc_vdesc();

        desc->buf_addr = (A_UINT8 *)adf_os_mem_alloc(nSize);
  903727:	9a71      	s32i.n	a10, a7, 4
        desc->buf_size = nSize;
  903729:	257504        	s16i	a5, a7, 8
        desc->data_offset = 0;
  90372c:	287505        	s16i	a8, a7, 10
        desc->data_size = 0;
  90372f:	287506        	s16i	a8, a7, 12
        
        buf->buf_length = 0;        
        buf->desc_list = desc;
  903732:	9720      	s32i.n	a7, a2, 0
        
        if ( g_poolCtx.bufQ[poolId] == NULL ) {
  903734:	8730      	l32i.n	a7, a3, 0
        desc->buf_addr = (A_UINT8 *)adf_os_mem_alloc(nSize);
        desc->buf_size = nSize;
        desc->data_offset = 0;
        desc->data_size = 0;
        
        buf->buf_length = 0;        
  903736:	282504        	s16i	a8, a2, 8
        buf->desc_list = desc;
        
        if ( g_poolCtx.bufQ[poolId] == NULL ) {
  903739:	8910      	l32i.n	a9, a1, 0
  90373b:	cc71      	bnez.n	a7, 903740 <_buf_pool_static_create_pool+0x4c>
  90373d:	600001        	j	903742 <_buf_pool_static_create_pool+0x4e>
            g_poolCtx.bufQ[poolId] = buf;
        } else {
            buf->next_buf = g_poolCtx.bufQ[poolId];
  903740:	9721      	s32i.n	a7, a2, 4
            g_poolCtx.bufQ[poolId] = buf;
  903742:	9230      	s32i.n	a2, a3, 0
    VBUF *buf;
    VDESC *desc;
    
    //BUF_POOL_STATIC_CONTEXT *ctx = (BUF_POOL_STATIC_CONTEXT *)handle;
    
    for ( i = 0; i < nItems; i++) {
  903744:	b144      	addi.n	a4, a4, 1
  903746:	7942bf        	blt	a4, a9, 903709 <_buf_pool_static_create_pool+0x15>
        } else {
            buf->next_buf = g_poolCtx.bufQ[poolId];
            g_poolCtx.bufQ[poolId] = buf;
        }
    }
}
  903749:	d10f      	retw.n
	...

0090374c <_buf_pool_static_alloc_buf>:
            
LOCAL adf_nbuf_t  _buf_pool_static_alloc_buf(pool_handle_t handle, BUF_POOL_ID poolId, int reserve)
{
  90374c:	6c1004        	entry	a1, 32
    VBUF *buf;
    
    buf = g_poolCtx.bufQ[poolId];
  90374f:	1271a7        	l32r	a2, 8dfdec <_bss_end+0x3d25e4>
  903752:	0e3311        	slli	a3, a3, 2
  903755:	a323      	add.n	a3, a2, a3
  903757:	8230      	l32i.n	a2, a3, 0
    if ( buf != NULL ) {
  903759:	c921      	beqz.n	a2, 90376e <_buf_pool_static_alloc_buf+0x22>
        g_poolCtx.bufQ[poolId] = buf->next_buf;
  90375b:	8821      	l32i.n	a8, a2, 4
  90375d:	9830      	s32i.n	a8, a3, 0
        
        buf->next_buf = NULL;
  90375f:	c030      	movi.n	a3, 0
        buf->desc_list->data_offset = reserve;
  903761:	8820      	l32i.n	a8, a2, 0
    
    buf = g_poolCtx.bufQ[poolId];
    if ( buf != NULL ) {
        g_poolCtx.bufQ[poolId] = buf->next_buf;
        
        buf->next_buf = NULL;
  903763:	9321      	s32i.n	a3, a2, 4
        buf->desc_list->data_offset = reserve;
  903765:	248505        	s16i	a4, a8, 10
        buf->desc_list->data_size = 0;
  903768:	238506        	s16i	a3, a8, 12
        buf->buf_length = 0;
  90376b:	232504        	s16i	a3, a2, 8
    }
    
    return buf;
}
  90376e:	d10f      	retw.n

00903770 <_buf_pool_static_alloc_buf_align>:

LOCAL adf_nbuf_t  _buf_pool_static_alloc_buf_align(pool_handle_t handle, BUF_POOL_ID poolId, int reserve, int align)
{
  903770:	6c1004        	entry	a1, 32
    return _buf_pool_static_alloc_buf(handle, poolId, reserve);
  903773:	dc40      	mov.n	a12, a4
  903775:	db30      	mov.n	a11, a3
  903777:	da20      	mov.n	a10, a2
  903779:	5bfff4        	call8	90374c <_buf_pool_static_alloc_buf>
}
  90377c:	d2a0      	mov.n	a2, a10
  90377e:	d10f      	retw.n

00903780 <_buf_pool_static_free_buf>:
    
LOCAL void _buf_pool_static_free_buf(pool_handle_t handle, BUF_POOL_ID poolId, adf_nbuf_t buf)
{
  903780:	6c1004        	entry	a1, 32
    if ( g_poolCtx.bufQ[poolId] == NULL ) {
  903783:	1871a7        	l32r	a8, 8dfe20 <_bss_end+0x3d2618>
  903786:	0e3311        	slli	a3, a3, 2
  903789:	a383      	add.n	a3, a8, a3
  90378b:	8830      	l32i.n	a8, a3, 0
  90378d:	cc81      	bnez.n	a8, 903792 <_buf_pool_static_free_buf+0x12>
  90378f:	600001        	j	903794 <_buf_pool_static_free_buf+0x14>
        g_poolCtx.bufQ[poolId] = buf;
    } else {
        buf->next_buf = g_poolCtx.bufQ[poolId];
  903792:	9841      	s32i.n	a8, a4, 4
        g_poolCtx.bufQ[poolId] = buf;
  903794:	9430      	s32i.n	a4, a3, 0
  903796:	d10f      	retw.n

00903798 <buf_pool_module_install>:
LOCAL void _buf_pool_static_shutdown(pool_handle_t handle);      

BUF_POOL_STATIC_CONTEXT g_poolCtx;

void buf_pool_module_install(struct buf_pool_api *pAPIs)
{   
  903798:	6c1004        	entry	a1, 32
    pAPIs->_init = _buf_pool_static_init;
  90379b:	1871a8        	l32r	a8, 8dfe3c <_bss_end+0x3d2634>
  90379e:	9820      	s32i.n	a8, a2, 0
    pAPIs->_create_pool = _buf_pool_static_create_pool;
  9037a0:	1871a9        	l32r	a8, 8dfe44 <_bss_end+0x3d263c>
  9037a3:	9822      	s32i.n	a8, a2, 8
    pAPIs->_alloc_buf = _buf_pool_static_alloc_buf;
  9037a5:	1871aa        	l32r	a8, 8dfe50 <_bss_end+0x3d2648>
  9037a8:	9823      	s32i.n	a8, a2, 12
    pAPIs->_alloc_buf_align = _buf_pool_static_alloc_buf_align;
  9037aa:	1871ab        	l32r	a8, 8dfe58 <_bss_end+0x3d2650>
  9037ad:	9824      	s32i.n	a8, a2, 16
    pAPIs->_free_buf = _buf_pool_static_free_buf;
  9037af:	1871ac        	l32r	a8, 8dfe60 <_bss_end+0x3d2658>
  9037b2:	9825      	s32i.n	a8, a2, 20
    pAPIs->_shutdown = _buf_pool_static_shutdown;
  9037b4:	1871ad        	l32r	a8, 8dfe68 <_bss_end+0x3d2660>
  9037b7:	9821      	s32i.n	a8, a2, 4
  9037b9:	d10f      	retw.n
	...

009037bc <_fw_usbfifo_recv_command>:

typedef void (* USBFIFO_recv_command)(VBUF *cmd);
USBFIFO_recv_command m_origUsbfifoRecvCmd = NULL;

void _fw_usbfifo_recv_command(VBUF *buf)
{
  9037bc:	6c1004        	entry	a1, 32
	uint8_t *cmd_data;
	uint32_t tmp;

	cmd_data = (uint8_t *)(buf->desc_list->buf_addr +
  9037bf:	8920      	l32i.n	a9, a2, 0

typedef void (* USBFIFO_recv_command)(VBUF *cmd);
USBFIFO_recv_command m_origUsbfifoRecvCmd = NULL;

void _fw_usbfifo_recv_command(VBUF *buf)
{
  9037c1:	da20      	mov.n	a10, a2
	uint8_t *cmd_data;
	uint32_t tmp;

	cmd_data = (uint8_t *)(buf->desc_list->buf_addr +
				buf->desc_list->data_offset);
  9037c3:	2b9105        	l16ui	a11, a9, 10
	tmp = *((uint32_t *)cmd_data);
  9037c6:	8891      	l32i.n	a8, a9, 4
  9037c8:	ab88      	add.n	a8, a8, a11
	if (tmp == 0xFFFFFFFF)
  9037ca:	8880      	l32i.n	a8, a8, 0
  9037cc:	698004        	bnei	a8, -1, 9037d4 <_fw_usbfifo_recv_command+0x18>
		_fw_usb_suspend_reboot();
  9037cf:	5803c9        	call8	9046f4 <_fw_usb_suspend_reboot>
  9037d2:	d10f      	retw.n
	else
		m_origUsbfifoRecvCmd(buf);
  9037d4:	1871ae        	l32r	a8, 8dfe8c <_bss_end+0x3d2684>
  9037d7:	8880      	l32i.n	a8, a8, 0
  9037d9:	0b8000        	callx8	a8
  9037dc:	d10f      	retw.n
	...

009037e0 <_fw_usbfifo_init>:
}

void _fw_usbfifo_init(USB_FIFO_CONFIG *pConfig)
{
  9037e0:	6c1004        	entry	a1, 32
	m_origUsbfifoRecvCmd = pConfig->recv_command;
  9037e3:	8921      	l32i.n	a9, a2, 4
  9037e5:	1871ae        	l32r	a8, 8dfea0 <_bss_end+0x3d2698>
  9037e8:	9980      	s32i.n	a9, a8, 0

	usbFifoConf.get_command_buf = pConfig->get_command_buf;
  9037ea:	8920      	l32i.n	a9, a2, 0
  9037ec:	1871af        	l32r	a8, 8dfea8 <_bss_end+0x3d26a0>
  9037ef:	9980      	s32i.n	a9, a8, 0
	usbFifoConf.recv_command    = _fw_usbfifo_recv_command;
  9037f1:	1971b0        	l32r	a9, 8dfeb4 <_bss_end+0x3d26ac>
  9037f4:	9981      	s32i.n	a9, a8, 4
	usbFifoConf.get_event_buf   = pConfig->get_event_buf;
  9037f6:	8922      	l32i.n	a9, a2, 8
	usbFifoConf.send_event_done = pConfig->send_event_done;
  9037f8:	8223      	l32i.n	a2, a2, 12
{
	m_origUsbfifoRecvCmd = pConfig->recv_command;

	usbFifoConf.get_command_buf = pConfig->get_command_buf;
	usbFifoConf.recv_command    = _fw_usbfifo_recv_command;
	usbFifoConf.get_event_buf   = pConfig->get_event_buf;
  9037fa:	9982      	s32i.n	a9, a8, 8
	usbFifoConf.send_event_done = pConfig->send_event_done;
  9037fc:	9283      	s32i.n	a2, a8, 12
  9037fe:	d10f      	retw.n

00903800 <cold_reboot>:
}

void cold_reboot(void)
{
  903800:	6c1004        	entry	a1, 32
	A_PRINTF("Cold reboot initiated.");
  903803:	12716e        	l32r	a2, 8dfdbc <_bss_end+0x3d25b4>
  903806:	1a71b1        	l32r	a10, 8dfecc <_bss_end+0x3d26c4>
  903809:	282212        	l32i	a8, a2, 72
  90380c:	0b8000        	callx8	a8
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90380f:	187172        	l32r	a8, 8dfdd8 <_bss_end+0x3d25d0>
  903812:	c090      	movi.n	a9, 0
#if defined(PROJECT_MAGPIE)
	iowrite32(WATCH_DOG_MAGIC_PATTERN_ADDR, 0);
#elif defined(PROJECT_K2)
	iowrite32(MAGPIE_REG_RST_STATUS_ADDR, 0);
#endif /* #if defined(PROJECT_MAGPIE) */
	A_USB_JUMP_BOOT();
  903814:	22222b        	l32i	a2, a2, 172
  903817:	0c0200        	memw
  90381a:	298600        	s32i	a9, a8, 0
  90381d:	0b2000        	callx8	a2
  903820:	d10f      	retw.n
	...

00903824 <usb_status_in_patch>:

/*
 * support more than 64 bytes command on ep3
 */
void usb_status_in_patch(void)
{
  903824:	6c1004        	entry	a1, 32
	static VBUF *evntbuf = NULL;
	static volatile uint32_t *regaddr;
	static BOOLEAN cmd_is_new = TRUE;
	BOOLEAN cmd_end = FALSE;

	if (cmd_is_new) {
  903827:	1271b2        	l32r	a2, 8dfef0 <_bss_end+0x3d26e8>
  90382a:	282100        	l16ui	a8, a2, 0
  90382d:	648048        	beqz	a8, 903879 <usb_status_in_patch+0x55>
		evntbuf = usbFifoConf.get_event_buf();
  903830:	1871af        	l32r	a8, 8dfeec <_bss_end+0x3d26e4>
  903833:	8a82      	l32i.n	a10, a8, 8
  903835:	0ba000        	callx8	a10
  903838:	1871b3        	l32r	a8, 8dff04 <_bss_end+0x3d26fc>
  90383b:	9a80      	s32i.n	a10, a8, 0
		if (evntbuf != NULL) {
  90383d:	c9af      	beqz.n	a10, 903860 <usb_status_in_patch+0x3c>
			regaddr = (uint32_t *)VBUF_GET_DATA_ADDR(evntbuf);
  90383f:	89a0      	l32i.n	a9, a10, 0
  903841:	2b9105        	l16ui	a11, a9, 10
  903844:	8891      	l32i.n	a8, a9, 4
  903846:	1971b4        	l32r	a9, 8dff18 <_bss_end+0x3d2710>
  903849:	ab88      	add.n	a8, a8, a11
  90384b:	9890      	s32i.n	a8, a9, 0
			buf_len = evntbuf->buf_length;
  90384d:	1871b5        	l32r	a8, 8dff24 <_bss_end+0x3d271c>
  903850:	29a104        	l16ui	a9, a10, 8
  903853:	298500        	s16i	a9, a8, 0
		} else {
			mUSB_STATUS_IN_INT_DISABLE();
			return;
		}

		cmd_is_new = FALSE;
  903856:	c080      	movi.n	a8, 0
  903858:	282500        	s16i	a8, a2, 0
  90385b:	60001a        	j	903879 <usb_status_in_patch+0x55>
  90385e:	000018        	src	a0, a0, a0

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  903861:	71b629        	bbci	a11, 1, 90388e <usb_status_in_patch+0x6a>
		evntbuf = usbFifoConf.get_event_buf();
		if (evntbuf != NULL) {
			regaddr = (uint32_t *)VBUF_GET_DATA_ADDR(evntbuf);
			buf_len = evntbuf->buf_length;
		} else {
			mUSB_STATUS_IN_INT_DISABLE();
  903864:	0ac022        	excw
  903867:	8000      	l32i.n	a0, a0, 0
  903869:	020247        	extui	a2, a2, 0, 8
  90386c:	092202        	or	a2, a2, a9
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  90386f:	0c0200        	memw
  903872:	228400        	s8i	a2, a8, 0
  903875:	d10f      	retw.n
  903877:	00001a        	sll	a0, a0
		}

		cmd_is_new = FALSE;
	}

	if (buf_len > USB_EP3_MAX_PKT_SIZE) {
  90387a:	71b5c4        	bbc	a11, a1, 903842 <usb_status_in_patch+0x1e>
  90387d:	9028      	s32i.n	a0, a2, 32
  90387f:	a100      	add.n	a0, a0, a1
	}
	/* TODO: 64 bytes...
	 * controller supposed will take care of zero-length? */
	else {
		reg_buf_len = buf_len;
		cmd_end = TRUE;
  903881:	c0c1      	movi.n	a12, 1
		}

		cmd_is_new = FALSE;
	}

	if (buf_len > USB_EP3_MAX_PKT_SIZE) {
  903883:	789b09        	bgeu	a9, a8, 903890 <usb_status_in_patch+0x6c>
		reg_buf_len = USB_EP3_MAX_PKT_SIZE;
		buf_len -= USB_EP3_MAX_PKT_SIZE;
  903886:	288cc0        	addi	a8, a8, -64
  903889:	28a500        	s16i	a8, a10, 0
	uint16_t reg_buf_len;
	static uint16_t buf_len;
	static VBUF *evntbuf = NULL;
	static volatile uint32_t *regaddr;
	static BOOLEAN cmd_is_new = TRUE;
	BOOLEAN cmd_end = FALSE;
  90388c:	c0c0      	movi.n	a12, 0

		cmd_is_new = FALSE;
	}

	if (buf_len > USB_EP3_MAX_PKT_SIZE) {
		reg_buf_len = USB_EP3_MAX_PKT_SIZE;
  90388e:	d890      	mov.n	a8, a9
  903890:	1b71b4        	l32r	a11, 8dff60 <_bss_end+0x3d2758>
  903893:	082914        	srli	a9, a8, 2
  903896:	8ab0      	l32i.n	a10, a11, 0
  903898:	0e9911        	slli	a9, a9, 2
  90389b:	a9a9      	add.n	a9, a10, a9
		reg_buf_len = buf_len;
		cmd_end = TRUE;
	}

	/* INT use EP3 */
	for (count = 0; count < (reg_buf_len / 4); count++)
  90389d:	c0d0      	movi.n	a13, 0
  90389f:	1e71b7        	l32r	a14, 8dff7c <_bss_end+0x3d2774>
  9038a2:	c0f1      	movi.n	a15, 1
  9038a4:	60000e        	j	9038b6 <usb_status_in_patch+0x92>
  9038a7:	000c02        	or	a12, a0, a0
	{
		iowrite32_usb(ZM_EP3_DATA_OFFSET, *regaddr);
  9038aa:	008da0        	excw
		regaddr++;
  9038ad:	b4aa      	addi.n	a10, a10, 4
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  9038af:	0c0200        	memw
  9038b2:	9de0      	s32i.n	a13, a14, 0
  9038b4:	ddf0      	mov.n	a13, a15
		reg_buf_len = buf_len;
		cmd_end = TRUE;
	}

	/* INT use EP3 */
	for (count = 0; count < (reg_buf_len / 4); count++)
  9038b6:	7a99ee        	bne	a9, a10, 9038a8 <usb_status_in_patch+0x84>
  9038b9:	c8d0      	beqz.n	a13, 9038bd <usb_status_in_patch+0x99>
  9038bb:	99b0      	s32i.n	a9, a11, 0
	{
		iowrite32_usb(ZM_EP3_DATA_OFFSET, *regaddr);
		regaddr++;
	}

	remainder = reg_buf_len % 4;
  9038bd:	080841        	extui	a8, a8, 0, 2

	if (remainder) {
  9038c0:	cb81      	beqz.n	a8, 9038f5 <usb_status_in_patch+0xd1>
  9038c2:	197195        	l32r	a9, 8dff18 <_bss_end+0x3d2710>
		switch(remainder) {
  9038c5:	688207        	beqi	a8, 2, 9038d0 <usb_status_in_patch+0xac>
  9038c8:	698309        	bnei	a8, 3, 9038d5 <usb_status_in_patch+0xb1>
  9038cb:	c087      	movi.n	a8, 7
  9038cd:	600006        	j	9038d7 <usb_status_in_patch+0xb3>
  9038d0:	c083      	movi.n	a8, 3
  9038d2:	600001        	j	9038d7 <usb_status_in_patch+0xb3>
  9038d5:	c081      	movi.n	a8, 1
  9038d7:	0c0200        	memw
  9038da:	9890      	s32i.n	a8, a9, 0
		case 1:
			iowrite32_usb(ZM_CBUS_FIFO_SIZE_OFFSET, 0x1);
			break;
		}

		iowrite32_usb(ZM_EP3_DATA_OFFSET, *regaddr);
  9038dc:	88b0      	l32i.n	a8, a11, 0
  9038de:	0c0200        	memw
  9038e1:	8980      	l32i.n	a9, a8, 0
  9038e3:	1871b7        	l32r	a8, 8dffc0 <_bss_end+0x3d27b8>
  9038e6:	0c0200        	memw
  9038e9:	9980      	s32i.n	a9, a8, 0
  9038eb:	187195        	l32r	a8, 8dff40 <_bss_end+0x3d2738>
  9038ee:	c09f      	movi.n	a9, 15
  9038f0:	0c0200        	memw
  9038f3:	9980      	s32i.n	a9, a8, 0

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  9038f5:	1971b8        	l32r	a9, 8dffd8 <_bss_end+0x3d27d0>

		/* Restore CBus FIFO size to word size */
		iowrite32_usb(ZM_CBUS_FIFO_SIZE_OFFSET, 0xF);
	}

	mUSB_EP3_XFER_DONE();
  9038f8:	c0a8      	movi.n	a10, 8
  9038fa:	289000        	l8ui	a8, a9, 0
  9038fd:	080847        	extui	a8, a8, 0, 8
  903900:	0a8802        	or	a8, a8, a10
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  903903:	0c0200        	memw
  903906:	289400        	s8i	a8, a9, 0

	if (evntbuf != NULL && cmd_end) {
  903909:	1871b3        	l32r	a8, 8dffd8 <_bss_end+0x3d27d0>
  90390c:	8a80      	l32i.n	a10, a8, 0
  90390e:	c8af      	beqz.n	a10, 903921 <usb_status_in_patch+0xfd>
  903910:	64c00d        	beqz	a12, 903921 <usb_status_in_patch+0xfd>
		usbFifoConf.send_event_done(evntbuf);
  903913:	1871af        	l32r	a8, 8dffd0 <_bss_end+0x3d27c8>
  903916:	288203        	l32i	a8, a8, 12
  903919:	0b8000        	callx8	a8
		cmd_is_new = TRUE;
  90391c:	c081      	movi.n	a8, 1
  90391e:	282500        	s16i	a8, a2, 0
  903921:	d10f      	retw.n
	...

00903924 <usb_reg_out_patch>:

/*
 * support more than 64 bytes command on ep4 
 */
void usb_reg_out_patch(void)
{
  903924:	6c1004        	entry	a1, 32

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  903927:	1271b9        	l32r	a2, 8e000c <_bss_end+0x3d2804>
	static BOOLEAN cmd_is_new = TRUE;

	/* get the size of this transcation */
	usbfifolen = ioread8_usb(ZM_EP4_BYTE_COUNT_LOW_OFFSET);

	if (usbfifolen > USB_EP4_MAX_PKT_SIZE) {
  90392a:	240a40        	movi	a4, 64
  90392d:	222000        	l8ui	a2, a2, 0
  903930:	020247        	extui	a2, a2, 0, 8
	static VBUF *buf;
	BOOLEAN cmd_is_last = FALSE;
	static BOOLEAN cmd_is_new = TRUE;

	/* get the size of this transcation */
	usbfifolen = ioread8_usb(ZM_EP4_BYTE_COUNT_LOW_OFFSET);
  903933:	02034f        	extui	a3, a2, 0, 16

	if (usbfifolen > USB_EP4_MAX_PKT_SIZE) {
  903936:	734b11        	bgeu	a4, a3, 90394b <usb_reg_out_patch+0x27>
		A_PRINTF("EP4 FIFO Bug? Buffer is too big: %x\n", usbfifolen);
  903939:	14716e        	l32r	a4, 8dfef4 <_bss_end+0x3d26ec>
  90393c:	1a71ba        	l32r	a10, 8e0024 <_bss_end+0x3d281c>
  90393f:	244212        	l32i	a4, a4, 72
  903942:	022b02        	or	a11, a2, a2
  903945:	0b4000        	callx8	a4
		cold_reboot();
  903948:	5bffad        	call8	903800 <cold_reboot>
	}

	/* check is command is new */
	if(cmd_is_new) {
  90394b:	1471bb        	l32r	a4, 8e0038 <_bss_end+0x3d2830>
  90394e:	1571bc        	l32r	a5, 8e0040 <_bss_end+0x3d2838>
  903951:	284100        	l16ui	a8, a4, 0
  903954:	ca8d      	beqz.n	a8, 903985 <usb_reg_out_patch+0x61>

		buf = usbFifoConf.get_command_buf();
  903956:	1871af        	l32r	a8, 8e0014 <_bss_end+0x3d280c>
  903959:	8a80      	l32i.n	a10, a8, 0
  90395b:	0ba000        	callx8	a10
		cmd_len = 0;
  90395e:	1971bd        	l32r	a9, 8e0054 <_bss_end+0x3d284c>
  903961:	c080      	movi.n	a8, 0
	}

	/* check is command is new */
	if(cmd_is_new) {

		buf = usbFifoConf.get_command_buf();
  903963:	9a50      	s32i.n	a10, a5, 0
		cmd_len = 0;
  903965:	289500        	s16i	a8, a9, 0

		if(!buf) {
  903968:	ccad      	bnez.n	a10, 903979 <usb_reg_out_patch+0x55>
			A_PRINTF("%s: Filed to get new buffer.\n", __func__);
  90396a:	12716e        	l32r	a2, 8dff24 <_bss_end+0x3d271c>
  90396d:	1b71be        	l32r	a11, 8e0068 <_bss_end+0x3d2860>
  903970:	222212        	l32i	a2, a2, 72
  903973:	1a71bf        	l32r	a10, 8e0070 <_bss_end+0x3d2868>
  903976:	600031        	j	9039ab <usb_reg_out_patch+0x87>
			goto err;
		}

		/* copy free, assignment buffer of the address */
		regaddr = (uint32_t *)buf->desc_list->buf_addr;
  903979:	89a0      	l32i.n	a9, a10, 0

		cmd_is_new = FALSE;
  90397b:	284500        	s16i	a8, a4, 0
			A_PRINTF("%s: Filed to get new buffer.\n", __func__);
			goto err;
		}

		/* copy free, assignment buffer of the address */
		regaddr = (uint32_t *)buf->desc_list->buf_addr;
  90397e:	8a91      	l32i.n	a10, a9, 4
  903980:	1971c0        	l32r	a9, 8e0080 <_bss_end+0x3d2878>
  903983:	9a90      	s32i.n	a10, a9, 0

		cmd_is_new = FALSE;
	}

	/* just in case, suppose should not happen */
	if(!buf)
  903985:	8a50      	l32i.n	a10, a5, 0
  903987:	caa3      	beqz.n	a10, 9039ae <usb_reg_out_patch+0x8a>
	 */
	if(usbfifolen < USB_EP4_MAX_PKT_SIZE)
		cmd_is_last = TRUE;

	/* accumulate the size */
	cmd_len += usbfifolen;
  903989:	1971bd        	l32r	a9, 8e0080 <_bss_end+0x3d2878>
  90398c:	289100        	l16ui	a8, a9, 0
  90398f:	a838      	add.n	a8, a3, a8
  903991:	08084f        	extui	a8, a8, 0, 16
  903994:	289500        	s16i	a8, a9, 0

	if (cmd_len > buf->desc_list->buf_size) {
  903997:	89a0      	l32i.n	a9, a10, 0
  903999:	259104        	l16ui	a5, a9, 8
  90399c:	785b18        	bgeu	a5, a8, 9039b8 <usb_reg_out_patch+0x94>
		A_PRINTF("%s: Data length on EP4 FIFO is bigger as "
  90399f:	12716e        	l32r	a2, 8dff58 <_bss_end+0x3d2750>
  9039a2:	1b71be        	l32r	a11, 8e009c <_bss_end+0x3d2894>
  9039a5:	222212        	l32i	a2, a2, 72
  9039a8:	1a71c1        	l32r	a10, 8e00ac <_bss_end+0x3d28a4>
  9039ab:	0b2000        	callx8	a2
		usbfifolen = (usbfifolen >> 2) + 1;
	else
		usbfifolen = usbfifolen >> 2;

	/* retrieve the data from fifo */
	for(ii = 0; ii < usbfifolen; ii++) {
  9039ae:	c020      	movi.n	a2, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  9039b0:	1471c2        	l32r	a4, 8e00b8 <_bss_end+0x3d28b0>
  9039b3:	600067        	j	903a1e <usb_reg_out_patch+0xfa>
  9039b6:	000003        	xor	a0, a0, a0
		goto err;
	}

	/* round it to alignment */
	if(usbfifolen % 4)
		usbfifolen = (usbfifolen >> 2) + 1;
  9039b9:	2b141c        	s8i	a11, a1, 28
  9039bc:	71c002        	bnone	a12, a1, 9039c2 <usb_reg_out_patch+0x9e>
			 "allocated buffer data! Drop it!\n", __func__);
		goto err;
	}

	/* round it to alignment */
	if(usbfifolen % 4)
  9039bf:	0241b1        	excw
		usbfifolen = (usbfifolen >> 2) + 1;
  9039c2:	b502      	addi.n	a2, a0, 5
  9039c4:	b538      	addi.n	a8, a3, 5
  9039c6:	8bc0      	l32i.n	a11, a12, 0
  9039c8:	0e5211        	slli	a2, a5, 2
  9039cb:	a2b2      	add.n	a2, a11, a2
	else
		usbfifolen = usbfifolen >> 2;

	/* retrieve the data from fifo */
	for(ii = 0; ii < usbfifolen; ii++) {
  9039cd:	c0d0      	movi.n	a13, 0
  9039cf:	1571c2        	l32r	a5, 8e00d8 <_bss_end+0x3d28d0>
  9039d2:	c0e1      	movi.n	a14, 1
  9039d4:	60000e        	j	9039e6 <usb_reg_out_patch+0xc2>
  9039d7:	000c02        	or	a12, a0, a0
  9039da:	008d50        	extui	a13, a0, 24, 1
		/* read fifo data out */
		ep4_data = ioread32_usb(ZM_EP4_DATA_OFFSET);
		*regaddr = ep4_data;
  9039dd:	0c0200        	memw
  9039e0:	9db0      	s32i.n	a13, a11, 0
		regaddr++;
  9039e2:	b4bb      	addi.n	a11, a11, 4
  9039e4:	dde0      	mov.n	a13, a14
		usbfifolen = (usbfifolen >> 2) + 1;
	else
		usbfifolen = usbfifolen >> 2;

	/* retrieve the data from fifo */
	for(ii = 0; ii < usbfifolen; ii++) {
  9039e6:	7b29ee        	bne	a2, a11, 9039d8 <usb_reg_out_patch+0xb4>
  9039e9:	c8d0      	beqz.n	a13, 9039ed <usb_reg_out_patch+0xc9>
  9039eb:	92c0      	s32i.n	a2, a12, 0
		*regaddr = ep4_data;
		regaddr++;
	}

	/* if this is the last command, callback to HTC */
	if (cmd_is_last) {
  9039ed:	c32f      	movi.n	a2, 63
  9039ef:	73232e        	bltu	a2, a3, 903a21 <usb_reg_out_patch+0xfd>
		buf->desc_list->next_desc = NULL;
  9039f2:	c020      	movi.n	a2, 0
  9039f4:	9290      	s32i.n	a2, a9, 0
		buf->desc_list->data_offset = 0;
  9039f6:	229505        	s16i	a2, a9, 10
		buf->desc_list->data_size = cmd_len;
		buf->desc_list->control = 0;
  9039f9:	229507        	s16i	a2, a9, 14

	/* if this is the last command, callback to HTC */
	if (cmd_is_last) {
		buf->desc_list->next_desc = NULL;
		buf->desc_list->data_offset = 0;
		buf->desc_list->data_size = cmd_len;
  9039fc:	289506        	s16i	a8, a9, 12
		buf->desc_list->control = 0;
		buf->next_buf = NULL;
  9039ff:	92a1      	s32i.n	a2, a10, 4
		buf->buf_length = cmd_len;

		usbFifoConf.recv_command(buf);
  903a01:	1271af        	l32r	a2, 8e00c0 <_bss_end+0x3d28b8>
		buf->desc_list->next_desc = NULL;
		buf->desc_list->data_offset = 0;
		buf->desc_list->data_size = cmd_len;
		buf->desc_list->control = 0;
		buf->next_buf = NULL;
		buf->buf_length = cmd_len;
  903a04:	28a504        	s16i	a8, a10, 8

		usbFifoConf.recv_command(buf);
  903a07:	8221      	l32i.n	a2, a2, 4
  903a09:	0b2000        	callx8	a2

		cmd_is_new = TRUE;
  903a0c:	c021      	movi.n	a2, 1
  903a0e:	224500        	s16i	a2, a4, 0
  903a11:	d10f      	retw.n
  903a13:	00b122        	excw
  903a16:	0c0200        	memw
  903a19:	8540      	l32i.n	a5, a4, 0
	goto done;
err:
	/* we might get no command buffer here?
	 * but if we return here, the ep4 fifo will be lock out,
	 * so that we still read them out but just drop it? */
	for(ii = 0; ii < usbfifolen; ii++)
  903a1b:	02024f        	extui	a2, a2, 0, 16
  903a1e:	7323f2        	bltu	a2, a3, 903a14 <usb_reg_out_patch+0xf0>
  903a21:	d10f      	retw.n
	...

00903a24 <vUSBFIFO_EP6Cfg_FS_patch>:
#define FS_C1_I0_A0_EP6_MAP		\
	 (FS_C1_I0_A0_EP6_FIFO_START | (FS_C1_I0_A0_EP6_FIFO_START << 4) | \
	  (MASK_F0 >> (4*FS_C1_I0_A0_EP6_DIRECTION)))

void vUSBFIFO_EP6Cfg_FS_patch(void)
{
  903a24:	6c1004        	entry	a1, 32
#if (FS_C1_I0_A0_EP_NUMBER >= 6)
	int i;

	/* EP0X06 */
	mUsbEPMap(EP6, FS_C1_I0_A0_EP6_MAP);
  903a27:	2b0a6f        	movi	a11, 111
  903a2a:	2a0a06        	movi	a10, 6
  903a2d:	5b808e        	call8	8e3c68 <mUsbEPMap>
	mUsbFIFOMap(FS_C1_I0_A0_EP6_FIFO_START, FS_C1_I0_A0_EP6_FIFO_MAP);
  903a30:	2b0a06        	movi	a11, 6
  903a33:	0bba02        	or	a10, a11, a11
  903a36:	5b8093        	call8	8e3c84 <mUsbFIFOMap>
	mUsbFIFOConfig(FS_C1_I0_A0_EP6_FIFO_START, FS_C1_I0_A0_EP6_FIFO_CONFIG);
  903a39:	2b0a86        	movi	a11, 134
  903a3c:	c0a6      	movi.n	a10, 6
  903a3e:	5b8099        	call8	8e3ca4 <mUsbFIFOConfig>

	for(i = FS_C1_I0_A0_EP6_FIFO_START + 1 ;
            i < FS_C1_I0_A0_EP6_FIFO_START + FS_C1_I0_A0_EP6_FIFO_NO ; i ++)
	{
		mUsbFIFOConfig(i, (FS_C1_I0_A0_EP6_FIFO_CONFIG & (~BIT7)) );
  903a41:	c0b6      	movi.n	a11, 6
  903a43:	c0a7      	movi.n	a10, 7
  903a45:	5b8097        	call8	8e3ca4 <mUsbFIFOConfig>
	}

	mUsbEPMxPtSzHigh(EP6, FS_C1_I0_A0_EP6_DIRECTION,
  903a48:	c4c0      	movi.n	a12, 64
  903a4a:	c0b1      	movi.n	a11, 1
  903a4c:	c0a6      	movi.n	a10, 6
  903a4e:	5b809d        	call8	8e3cc4 <mUsbEPMxPtSzHigh>
			 (FS_C1_I0_A0_EP6_MAX_PACKET & 0x7ff));
	mUsbEPMxPtSzLow(EP6, FS_C1_I0_A0_EP6_DIRECTION,
  903a51:	c4c0      	movi.n	a12, 64
  903a53:	c0b1      	movi.n	a11, 1
  903a55:	c0a6      	movi.n	a10, 6
  903a57:	5b80a5        	call8	8e3cec <mUsbEPMxPtSzLow>
			(FS_C1_I0_A0_EP6_MAX_PACKET & 0x7ff));
	mUsbEPinHighBandSet(EP6, FS_C1_I0_A0_EP6_DIRECTION,
  903a5a:	c4c0      	movi.n	a12, 64
  903a5c:	c0b1      	movi.n	a11, 1
  903a5e:	2a0a06        	movi	a10, 6
  903a61:	5b80ab        	call8	8e3d10 <mUsbEPinHighBandSet>
  903a64:	d10f      	retw.n
	...

00903a68 <vUsbFIFO_EPxCfg_FS_patch>:
			    FS_C1_I0_A0_EP6_MAX_PACKET);
#endif
}

void vUsbFIFO_EPxCfg_FS_patch(void)
{
  903a68:	6c1004        	entry	a1, 32
	switch (u8UsbConfigValue)
  903a6b:	187170        	l32r	a8, 8e002c <_bss_end+0x3d2824>
  903a6e:	288100        	l16ui	a8, a8, 0
  903a71:	698113        	bnei	a8, 1, 903a88 <vUsbFIFO_EPxCfg_FS_patch+0x20>
	{
#if (FS_CONFIGURATION_NUMBER >= 1)
		/* Configuration 0X01 */
        case 0X01:
		switch (u8UsbInterfaceValue)
  903a74:	18716f        	l32r	a8, 8e0030 <_bss_end+0x3d2828>
  903a77:	288100        	l16ui	a8, a8, 0
  903a7a:	cc8a      	bnez.n	a8, 903a88 <vUsbFIFO_EPxCfg_FS_patch+0x20>
		{
#if (FS_C1_INTERFACE_NUMBER >= 1)
			/* Interface 0 */
                case 0:
			switch (u8UsbInterfaceAlternateSetting)
  903a7c:	187171        	l32r	a8, 8e0040 <_bss_end+0x3d2838>
  903a7f:	288100        	l16ui	a8, a8, 0
  903a82:	658002        	bnez	a8, 903a88 <vUsbFIFO_EPxCfg_FS_patch+0x20>
                        case 0:

				/* snapped.... */

				/* patch up this ep6_fs config */
				vUSBFIFO_EP6Cfg_FS_patch();
  903a85:	5bffe7        	call8	903a24 <vUSBFIFO_EP6Cfg_FS_patch>
  903a88:	d10f      	retw.n
	...

00903a8c <bSet_configuration_patch>:
	}
	/* mCHECK_STACK(); */
}

BOOLEAN bSet_configuration_patch(void)
{
  903a8c:	6c1004        	entry	a1, 32
	/* do some defaul configuration */
	bSet_configuration();
  903a8f:	5b7d3b        	call8	8e2f7c <bSet_configuration>

	/* overwrite defaul FIFO configuration for FullSpeed USB */
	if ((mLOW_BYTE(mDEV_REQ_VALUE()) != 0) && !mUsbHighSpeedST())
  903a92:	1271c3        	l32r	a2, 8e01a0 <_bss_end+0x3d2998>
  903a95:	222007        	l8ui	a2, a2, 7
  903a98:	c82a      	beqz.n	a2, 903aa6 <bSet_configuration_patch+0x1a>

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  903a9a:	12718f        	l32r	a2, 8e00d8 <_bss_end+0x3d28d0>
  903a9d:	222000        	l8ui	a2, a2, 0
  903aa0:	792f02        	bbsi	a2, 25, 903aa6 <bSet_configuration_patch+0x1a>
			vUsbFIFO_EPxCfg_FS_patch();
  903aa3:	5bfff1        	call8	903a68 <vUsbFIFO_EPxCfg_FS_patch>

	eUsbCxFinishAction = ACT_DONE;
  903aa6:	1871c4        	l32r	a8, 8e01b8 <_bss_end+0x3d29b0>
  903aa9:	c021      	movi.n	a2, 1
  903aab:	9280      	s32i.n	a2, a8, 0
	return TRUE;
}
  903aad:	d10f      	retw.n
	...

00903ab0 <bStandardCommand_patch>:

extern BOOLEAN bStandardCommand(void);

BOOLEAN bStandardCommand_patch(void)
{
  903ab0:	6c1004        	entry	a1, 32
	if (mDEV_REQ_REQ() == USB_SET_CONFIGURATION) {
  903ab3:	1871c3        	l32r	a8, 8e01c0 <_bss_end+0x3d29b8>
  903ab6:	298102        	l16ui	a9, a8, 4
  903ab9:	280a09        	movi	a8, 9
  903abc:	78992d        	bne	a9, a8, 903aed <bStandardCommand_patch+0x3d>
		A_USB_SET_CONFIG();
  903abf:	18716e        	l32r	a8, 8e0078 <_bss_end+0x3d2870>
  903ac2:	2a8225        	l32i	a10, a8, 148
  903ac5:	0ba000        	callx8	a10

#if ENABLE_SWAP_DATA_MODE
		/* SWAP FUNCTION should be enabled while DMA engine
		 * is not working, the best place to enable it
		 * is before we trigger the DMA */
		MAGPIE_REG_USB_RX0_SWAP_DATA = 0x1;
  903ac8:	1871c5        	l32r	a8, 8e01dc <_bss_end+0x3d29d4>
  903acb:	c0a1      	movi.n	a10, 1
  903acd:	0c0200        	memw
  903ad0:	9a80      	s32i.n	a10, a8, 0
		MAGPIE_REG_USB_TX0_SWAP_DATA = 0x1;
  903ad2:	1871c6        	l32r	a8, 8e01ec <_bss_end+0x3d29e4>
  903ad5:	0c0200        	memw
  903ad8:	9a80      	s32i.n	a10, a8, 0

#if SYSTEM_MODULE_HP_EP5
		MAGPIE_REG_USB_RX1_SWAP_DATA = 0x1;
  903ada:	1871c7        	l32r	a8, 8e01f8 <_bss_end+0x3d29f0>
  903add:	0c0200        	memw
  903ae0:	9a80      	s32i.n	a10, a8, 0
#endif

#if SYSTEM_MODULE_HP_EP6
		MAGPIE_REG_USB_RX2_SWAP_DATA = 0x1;
  903ae2:	1871c8        	l32r	a8, 8e0204 <_bss_end+0x3d29fc>
  903ae5:	0c0200        	memw
  903ae8:	9a80      	s32i.n	a10, a8, 0
#endif

#endif /* ENABLE_SWAP_DATA_MODE */
		return TRUE;
  903aea:	600002        	j	903af0 <bStandardCommand_patch+0x40>
	} else
		return bStandardCommand();
  903aed:	5b7de7        	call8	8e328c <bStandardCommand>
}
  903af0:	d2a0      	mov.n	a2, a10
  903af2:	d10f      	retw.n

00903af4 <bGet_descriptor_patch>:
#define EP3_INT_INTERVAL		19
#define EP4_TRANSFER_TYPE_OFFSET	21
#define EP4_INT_INTERVAL		22

BOOLEAN bGet_descriptor_patch(void)
{
  903af4:	6c1004        	entry	a1, 32
	if (mDEV_REQ_VALUE_HIGH() == 1)
  903af7:	1271c3        	l32r	a2, 8e0204 <_bss_end+0x3d29fc>
  903afa:	282103        	l16ui	a8, a2, 6
  903afd:	088814        	srli	a8, a8, 8
  903b00:	698120        	bnei	a8, 1, 903b24 <bGet_descriptor_patch+0x30>
	{
		uint8_t *p = (uint8_t *)u8UsbDeviceDescriptor;
  903b03:	1471c9        	l32r	a4, 8e0228 <_bss_end+0x3d2a20>

		/* Copy Usb Device Descriptor */
		ath_hal_memcpy(UsbDeviceDescriptorPatch, p,
  903b06:	1371ca        	l32r	a3, 8e0230 <_bss_end+0x3d2a28>
  903b09:	8b40      	l32i.n	a11, a4, 0
  903b0b:	da30      	mov.n	a10, a3
  903b0d:	c1c2      	movi.n	a12, 18
  903b0f:	580035        	call8	903be4 <ath_hal_memcpy>
				sizeof(UsbDeviceDescriptorPatch));

		/* Change bcdDevice. we need it to detect if FW
		 * was uploaded. */
		UsbDeviceDescriptorPatch[BCD_DEVICE_OFFSET] =
  903b12:	c78f      	movi.n	a8, -1
  903b14:	283506        	s16i	a8, a3, 12
			BCD_DEVICE_FW_SIGNATURE;

		pu8DescriptorEX = UsbDeviceDescriptorPatch;
  903b17:	1871cb        	l32r	a8, 8e0244 <_bss_end+0x3d2a3c>
  903b1a:	9380      	s32i.n	a3, a8, 0
		u16TxRxCounter = mTABLE_LEN(u8UsbDeviceDescriptor[0]);
  903b1c:	8340      	l32i.n	a3, a4, 0
  903b1e:	283001        	l8ui	a8, a3, 1
  903b21:	600024        	j	903b49 <bGet_descriptor_patch+0x55>
			u16TxRxCounter = mDEV_REQ_LENGTH();

		A_USB_EP0_TX_DATA();

		return TRUE;
	} else if (mDEV_REQ_VALUE_HIGH() == 2) {
  903b24:	69823e        	bnei	a8, 2, 903b66 <bGet_descriptor_patch+0x72>
		uint8_t *p = (uint8_t *)u8ConfigDescriptorEX;

		/* Copy ConfigDescriptor */
		ath_hal_memcpy(ConfigDescriptorPatch, p,
  903b27:	1471cd        	l32r	a4, 8e025c <_bss_end+0x3d2a54>
  903b2a:	1371ce        	l32r	a3, 8e0264 <_bss_end+0x3d2a5c>
  903b2d:	2b4200        	l32i	a11, a4, 0
  903b30:	2c0a3c        	movi	a12, 60
  903b33:	033a02        	or	a10, a3, a3
  903b36:	58002b        	call8	903be4 <ath_hal_memcpy>
				sizeof(ConfigDescriptorPatch));

		 /* place holder for EPx patches */

		if (mDEV_REQ_VALUE_LOW() == 0) {
  903b39:	242007        	l8ui	a4, a2, 7
			/* configuration no: 0 */
			pu8DescriptorEX = ConfigDescriptorPatch;
			u16TxRxCounter = ConfigDescriptorPatch[1];
		} else
			return FALSE;
  903b3c:	c0a0      	movi.n	a10, 0
		ath_hal_memcpy(ConfigDescriptorPatch, p,
				sizeof(ConfigDescriptorPatch));

		 /* place holder for EPx patches */

		if (mDEV_REQ_VALUE_LOW() == 0) {
  903b3e:	7a4927        	bne	a4, a10, 903b69 <bGet_descriptor_patch+0x75>
			/* configuration no: 0 */
			pu8DescriptorEX = ConfigDescriptorPatch;
  903b41:	1471cb        	l32r	a4, 8e0270 <_bss_end+0x3d2a68>
			u16TxRxCounter = ConfigDescriptorPatch[1];
  903b44:	283101        	l16ui	a8, a3, 2

		 /* place holder for EPx patches */

		if (mDEV_REQ_VALUE_LOW() == 0) {
			/* configuration no: 0 */
			pu8DescriptorEX = ConfigDescriptorPatch;
  903b47:	9340      	s32i.n	a3, a4, 0
			u16TxRxCounter = ConfigDescriptorPatch[1];
  903b49:	1371cc        	l32r	a3, 8e027c <_bss_end+0x3d2a74>
		} else
			return FALSE;

		if (u16TxRxCounter > mDEV_REQ_LENGTH())
  903b4c:	222105        	l16ui	a2, a2, 10
		 /* place holder for EPx patches */

		if (mDEV_REQ_VALUE_LOW() == 0) {
			/* configuration no: 0 */
			pu8DescriptorEX = ConfigDescriptorPatch;
			u16TxRxCounter = ConfigDescriptorPatch[1];
  903b4f:	283500        	s16i	a8, a3, 0
		} else
			return FALSE;

		if (u16TxRxCounter > mDEV_REQ_LENGTH())
  903b52:	782b02        	bgeu	a2, a8, 903b58 <bGet_descriptor_patch+0x64>
			u16TxRxCounter = mDEV_REQ_LENGTH();
  903b55:	223500        	s16i	a2, a3, 0

		A_USB_EP0_TX_DATA();
  903b58:	12716e        	l32r	a2, 8e0110 <_bss_end+0x3d2908>
  903b5b:	222234        	l32i	a2, a2, 208
  903b5e:	0b2000        	callx8	a2
		return TRUE;
  903b61:	c0a1      	movi.n	a10, 1
  903b63:	600002        	j	903b69 <bGet_descriptor_patch+0x75>
	} else
		return bGet_descriptor();
  903b66:	5b7cd7        	call8	8e2ec4 <bGet_descriptor>
}
  903b69:	d2a0      	mov.n	a2, a10
  903b6b:	d10f      	retw.n
  903b6d:	000000        	ill

00903b70 <ath_hal_getuptime>:
#include<ah_internal.h>
#include "ah_osdep.h"

a_uint32_t __ahdecl
ath_hal_getuptime(struct ath_hal *ah)
{
  903b70:	6c1004        	entry	a1, 32
	return MSEC_TO_TICK(msecs);
}
static inline unsigned long
__adf_os_getuptime(void)
{
    return MSEC_TO_TICK(A_MILLISECONDS());;      
  903b73:	18716e        	l32r	a8, 8e012c <_bss_end+0x3d2924>
  903b76:	2a823d        	l32i	a10, a8, 244
  903b79:	0ba000        	callx8	a10
	return adf_os_getuptime();
}
  903b7c:	d2a0      	mov.n	a2, a10
  903b7e:	d10f      	retw.n

00903b80 <_ath_hal_attach_tgt>:

struct ath_hal *
_ath_hal_attach_tgt(a_uint32_t devid, HAL_SOFTC sc,
		    adf_os_device_t dev, a_uint32_t flags, void* s)
{
  903b80:	6c1006        	entry	a1, 48
	HAL_STATUS status;
	struct ath_hal *ah = ath_hal_attach_tgt(devid, sc, dev, flags, &status);
  903b83:	de10      	mov.n	a14, a1
  903b85:	dd50      	mov.n	a13, a5
  903b87:	dc40      	mov.n	a12, a4
  903b89:	db30      	mov.n	a11, a3
  903b8b:	da20      	mov.n	a10, a2
  903b8d:	580501        	call8	904f94 <ath_hal_attach_tgt>
	adf_os_print(" ath_hal = %p \n",ah);
  903b90:	18716e        	l32r	a8, 8e0148 <_bss_end+0x3d2940>
  903b93:	dba0      	mov.n	a11, a10
struct ath_hal *
_ath_hal_attach_tgt(a_uint32_t devid, HAL_SOFTC sc,
		    adf_os_device_t dev, a_uint32_t flags, void* s)
{
	HAL_STATUS status;
	struct ath_hal *ah = ath_hal_attach_tgt(devid, sc, dev, flags, &status);
  903b95:	d2a0      	mov.n	a2, a10
	adf_os_print(" ath_hal = %p \n",ah);
  903b97:	288212        	l32i	a8, a8, 72
  903b9a:	1a71cf        	l32r	a10, 8e02d8 <_bss_end+0x3d2ad0>
  903b9d:	0b8000        	callx8	a8
	*(HAL_STATUS *)s = status;
  903ba0:	8810      	l32i.n	a8, a1, 0
  903ba2:	9860      	s32i.n	a8, a6, 0
	return ah;
}
  903ba4:	d10f      	retw.n
	...

00903ba8 <ath_hal_delay>:
/*
 * Delay n microseconds.
 */
void __ahdecl
ath_hal_delay(a_int32_t n)
{
  903ba8:	6c1004        	entry	a1, 32
}

static inline void
__adf_os_udelay(int usecs)
{
    A_DELAY_USECS(usecs);
  903bab:	18716e        	l32r	a8, 8e0164 <_bss_end+0x3d295c>
  903bae:	da20      	mov.n	a10, a2
  903bb0:	28823a        	l32i	a8, a8, 232
  903bb3:	0b8000        	callx8	a8
  903bb6:	d10f      	retw.n

00903bb8 <ath_hal_malloc>:
/*
 * Allocate/free memory.
 */
void * __ahdecl
ath_hal_malloc(adf_os_size_t size)
{
  903bb8:	6c1004        	entry	a1, 32
  903bbb:	14716e        	l32r	a4, 8e0174 <_bss_end+0x3d296c>
  903bbe:	d320      	mov.n	a3, a2
  903bc0:	224252        	l32i	a2, a4, 0x148
  903bc3:	db30      	mov.n	a11, a3
  903bc5:	c0a0      	movi.n	a10, 0
  903bc7:	0b2000        	callx8	a2
  903bca:	d2a0      	mov.n	a2, a10
	void *p;

	p = adf_os_mem_alloc(size);
	if (p)
  903bcc:	c8a8      	beqz.n	a10, 903bd8 <ath_hal_malloc+0x20>
}
/* zero a memory buffer */
static inline void
__adf_os_mem_zero(void *buf, adf_os_size_t size)
{
    A_MEMZERO(buf,size);
  903bce:	8444      	l32i.n	a4, a4, 16
  903bd0:	dc30      	mov.n	a12, a3
  903bd2:	2b0a00        	movi	a11, 0
  903bd5:	0b4000        	callx8	a4
		adf_os_mem_zero(p, size);

	return p;
}
  903bd8:	d10f      	retw.n
	...

00903bdc <ath_hal_free>:

void __ahdecl
ath_hal_free(void* p)
{
  903bdc:	6c1004        	entry	a1, 32
  903bdf:	d10f      	retw.n
  903be1:	000000        	ill

00903be4 <ath_hal_memcpy>:
	adf_os_mem_free(p);
}

void * __ahdecl
ath_hal_memcpy(void *dst, const void *src, adf_os_size_t n)
{
  903be4:	6c1004        	entry	a1, 32
}

/* move a memory buffer */
static inline void 		__adf_os_mem_copy(void *dst, const void *src, adf_os_size_t size)
{
    A_MEMCPY(dst,src,size);    
  903be7:	18716e        	l32r	a8, 8e01a0 <_bss_end+0x3d2998>
  903bea:	dc40      	mov.n	a12, a4
  903bec:	8885      	l32i.n	a8, a8, 20
  903bee:	db30      	mov.n	a11, a3
  903bf0:	da20      	mov.n	a10, a2
  903bf2:	0b8000        	callx8	a8
	adf_os_mem_copy(dst, src, n);
	return 0;
}
  903bf5:	c020      	movi.n	a2, 0
  903bf7:	d10f      	retw.n
  903bf9:	000000        	ill

00903bfc <wlan_pci_module_init>:
adf_drv_info_t* g_wlan_drv = NULL;
adf_drv_handle_t g_wlan_drv_handle = NULL;
adf_os_drv_intr g_wlan_intr = NULL;

void wlan_pci_module_init(void)
{
  903bfc:	6c1004        	entry	a1, 32
	if (g_pci_init_func != NULL) {
  903bff:	1871d0        	l32r	a8, 8e0340 <_bss_end+0x3d2b38>
  903c02:	8a80      	l32i.n	a10, a8, 0
  903c04:	c8a1      	beqz.n	a10, 903c09 <wlan_pci_module_init+0xd>
		g_pci_init_func();
  903c06:	0ba000        	callx8	a10
  903c09:	d10f      	retw.n
	...

00903c0c <wlan_pci_register_drv>:
	}
}

void wlan_pci_register_drv(adf_drv_info_t *drv)
{
  903c0c:	6c1004        	entry	a1, 32
	g_wlan_drv = drv;
  903c0f:	1871d1        	l32r	a8, 8e0354 <_bss_end+0x3d2b4c>
  903c12:	9280      	s32i.n	a2, a8, 0
  903c14:	d10f      	retw.n
	...

00903c18 <wlan_pci_probe>:

#define ATHEROS_VENDOR_ID 0x168c
#define AR5416_DEVID_PCIE 0x24 	

void wlan_pci_probe(void)
{
  903c18:	6c100a        	entry	a1, 80
	__adf_softc_t           *sc;
	adf_os_resource_t       drv_res = {0};
  903c1b:	c1c8      	movi.n	a12, 24
  903c1d:	2b0a00        	movi	a11, 0
  903c20:	011a02        	or	a10, a1, a1
  903c23:	5b855e        	call8	8e519c <memset>
	adf_os_attach_data_t    drv_data = {{0}};   
  903c26:	c1c0      	movi.n	a12, 16
  903c28:	c0b0      	movi.n	a11, 0
  903c2a:	2a1c18        	addi	a10, a1, 24
  903c2d:	5b855b        	call8	8e519c <memset>
	int vendor_id;
	int device_id;

	A_PRINTF("<wlan_pci_probe>: Attaching the driver\n");
  903c30:	12716e        	l32r	a2, 8e01e8 <_bss_end+0x3d29e0>
  903c33:	1a71d2        	l32r	a10, 8e037c <_bss_end+0x3d2b74>
  903c36:	232212        	l32i	a3, a2, 72
  903c39:	0b3000        	callx8	a3
	device_id = AR5416_DEVID_PCIE;
#else    
	vendor_id = wlan_pci_config_read(0, 2);
	device_id = wlan_pci_config_read(2, 2);
#endif    
	A_PRINTF("<wlan_pci_probe>: Vendor id 0x%x Dev id 0x%x\n", vendor_id, device_id);    
  903c3c:	1371d3        	l32r	a3, 8e0388 <_bss_end+0x3d2b80>
  903c3f:	282212        	l32i	a8, a2, 72
  903c42:	1a71d4        	l32r	a10, 8e0394 <_bss_end+0x3d2b8c>
  903c45:	db30      	mov.n	a11, a3
  903c47:	c2c4      	movi.n	a12, 36
  903c49:	0b8000        	callx8	a8
	}
            
	/**
	 * Allocate the sc & zero down
	 */
	sc = A_ALLOCRAM(sizeof(__adf_softc_t));
  903c4c:	282252        	l32i	a8, a2, 0x148
  903c4f:	c0b4      	movi.n	a11, 4
  903c51:	c0a0      	movi.n	a10, 0
  903c53:	0b8000        	callx8	a8
	if (!sc) {
  903c56:	ccaa      	bnez.n	a10, 903c64 <wlan_pci_probe+0x4c>
		A_PRINTF("Cannot malloc softc\n");
  903c58:	222212        	l32i	a2, a2, 72
  903c5b:	1a71d5        	l32r	a10, 8e03b0 <_bss_end+0x3d2ba8>
  903c5e:	0b2000        	callx8	a2
        
	g_wlan_drv_handle = g_wlan_drv->drv_attach(&drv_res, 1, &drv_data, NULL);
        
	return;
mem_fail:
	return;        
  903c61:	d10f      	retw.n
  903c63:	00c224        	excw
		goto mem_fail;
	}
    
#define AR5416_DEVID_PCIE 0x24 		

	drv_data.pci.device    = AR5416_DEVID_PCIE;
  903c66:	9217      	s32i.n	a2, a1, 28
    
	drv_res.start  = (a_uint32_t) 0;
	drv_res.end    = 0;
	drv_res.type   = ADF_OS_RESOURCE_TYPE_MEM;
        
	g_wlan_drv_handle = g_wlan_drv->drv_attach(&drv_res, 1, &drv_data, NULL);
  903c68:	1271d1        	l32r	a2, 8e03ac <_bss_end+0x3d2ba4>
    
#define AR5416_DEVID_PCIE 0x24 		

	drv_data.pci.device    = AR5416_DEVID_PCIE;
	drv_data.pci.vendor    = 0x168c;
	drv_data.pci.subvendor = 0;
  903c6b:	c0d0      	movi.n	a13, 0
    
	drv_res.start  = (a_uint32_t) 0;
	drv_res.end    = 0;
	drv_res.type   = ADF_OS_RESOURCE_TYPE_MEM;
        
	g_wlan_drv_handle = g_wlan_drv->drv_attach(&drv_res, 1, &drv_data, NULL);
  903c6d:	8220      	l32i.n	a2, a2, 0
	drv_data.pci.device    = AR5416_DEVID_PCIE;
	drv_data.pci.vendor    = 0x168c;
	drv_data.pci.subvendor = 0;
	drv_data.pci.subdevice = 0;
    
	drv_res.start  = (a_uint32_t) 0;
  903c6f:	1871d6        	l32r	a8, 8e03c8 <_bss_end+0x3d2bc0>
  903c72:	1971d6        	l32r	a9, 8e03cc <_bss_end+0x3d2bc4>
	}
    
#define AR5416_DEVID_PCIE 0x24 		

	drv_data.pci.device    = AR5416_DEVID_PCIE;
	drv_data.pci.vendor    = 0x168c;
  903c75:	9316      	s32i.n	a3, a1, 24
	drv_data.pci.subvendor = 0;
  903c77:	9d18      	s32i.n	a13, a1, 32
	drv_data.pci.subdevice = 0;
  903c79:	9d19      	s32i.n	a13, a1, 36
    
	drv_res.start  = (a_uint32_t) 0;
	drv_res.end    = 0;
	drv_res.type   = ADF_OS_RESOURCE_TYPE_MEM;
        
	g_wlan_drv_handle = g_wlan_drv->drv_attach(&drv_res, 1, &drv_data, NULL);
  903c7b:	8220      	l32i.n	a2, a2, 0
	drv_data.pci.device    = AR5416_DEVID_PCIE;
	drv_data.pci.vendor    = 0x168c;
	drv_data.pci.subvendor = 0;
	drv_data.pci.subdevice = 0;
    
	drv_res.start  = (a_uint32_t) 0;
  903c7d:	9810      	s32i.n	a8, a1, 0
  903c7f:	9911      	s32i.n	a9, a1, 4
	drv_res.end    = 0;
  903c81:	9812      	s32i.n	a8, a1, 8
  903c83:	9913      	s32i.n	a9, a1, 12
	drv_res.type   = ADF_OS_RESOURCE_TYPE_MEM;
  903c85:	9d14      	s32i.n	a13, a1, 16
        
	g_wlan_drv_handle = g_wlan_drv->drv_attach(&drv_res, 1, &drv_data, NULL);
  903c87:	2c1c18        	addi	a12, a1, 24
  903c8a:	c0b1      	movi.n	a11, 1
  903c8c:	da10      	mov.n	a10, a1
  903c8e:	0b2000        	callx8	a2
  903c91:	1271d7        	l32r	a2, 8e03f0 <_bss_end+0x3d2be8>
  903c94:	9a20      	s32i.n	a10, a2, 0
  903c96:	d10f      	retw.n

00903c98 <wlan_pci_config_write>:
mem_fail:
	return;        
}

int wlan_pci_config_write(int offset, a_uint32_t val, int width)
{
  903c98:	6c1004        	entry	a1, 32
		ptr[idx + i] = valptr[3-i];
	}            
#endif
    
	return 0;    
}
  903c9b:	c020      	movi.n	a2, 0
  903c9d:	d10f      	retw.n
	...

00903ca0 <wlan_pci_config_read>:

int wlan_pci_config_read(int offset, int width)
{
  903ca0:	6c1004        	entry	a1, 32
		result |= (ptr[ 3 - (idx + i)] << (8*i));
	}            
    
	return result;    
#endif    
}
  903ca3:	c020      	movi.n	a2, 0
  903ca5:	d10f      	retw.n
	...

00903ca8 <wlan_pci_isr>:

void wlan_pci_isr()
{
  903ca8:	6c1004        	entry	a1, 32
	if (g_wlan_intr != NULL && g_wlan_drv_handle != NULL) {
  903cab:	1871d8        	l32r	a8, 8e040c <_bss_end+0x3d2c04>
  903cae:	8880      	l32i.n	a8, a8, 0
  903cb0:	c888      	beqz.n	a8, 903cbc <wlan_pci_isr+0x14>
  903cb2:	1971d7        	l32r	a9, 8e0410 <_bss_end+0x3d2c08>
  903cb5:	8a90      	l32i.n	a10, a9, 0
  903cb7:	c8a1      	beqz.n	a10, 903cbc <wlan_pci_isr+0x14>
		g_wlan_intr(g_wlan_drv_handle);
  903cb9:	0b8000        	callx8	a8
  903cbc:	d10f      	retw.n
	...

00903cc0 <_HTC_Shutdown>:
    
	return pHTC;
}

LOCAL void _HTC_Shutdown(htc_handle_t htcHandle)
{
  903cc0:	6c1004        	entry	a1, 32
  903cc3:	d10f      	retw.n
  903cc5:	000000        	ill

00903cc8 <_HTC_RegisterService>:
    
	adf_os_mem_free(pHTC);
}

LOCAL void _HTC_RegisterService(htc_handle_t htcHandle, HTC_SERVICE *pService)
{
  903cc8:	6c1004        	entry	a1, 32
	HTC_CONTEXT *pHTC = (HTC_CONTEXT *)htcHandle;
    
        /* add it to the list */
	pService->pNext = pHTC->pServiceList;
  903ccb:	282290        	l32i	a8, a2, 0x240
  903cce:	9830      	s32i.n	a8, a3, 0
	pHTC->pServiceList = pService;
  903cd0:	232690        	s32i	a3, a2, 0x240
  903cd3:	d10f      	retw.n
  903cd5:	000000        	ill

00903cd8 <_HTC_GetReservedHeadroom>:
void _HTC_ResumeRecv(HTC_ENDPOINT_ID EndpointID)
{
}

int _HTC_GetReservedHeadroom(htc_handle_t htcHandle)
{
  903cd8:	6c1004        	entry	a1, 32
	HTC_CONTEXT *pHTC = (HTC_CONTEXT *)htcHandle;  
    
	return HTC_HDR_LENGTH + HIF_get_reserved_headroom(pHTC->hifHandle);
  903cdb:	18716e        	l32r	a8, 8e0294 <_bss_end+0x3d2a8c>
  903cde:	2a229a        	l32i	a10, a2, 0x268
  903ce1:	28827f        	l32i	a8, a8, 0x1fc
  903ce4:	0b8000        	callx8	a8
}
  903ce7:	b8a2      	addi.n	a2, a10, 8
  903ce9:	d10f      	retw.n
	...

00903cec <HTCSendDoneHandler>:
		HTCCheckAndSendCreditReport(pHTC, HTC_ANY_ENDPOINT_MASK,NULL,ENDPOINT_MAX);
	}  
}

LOCAL void HTCSendDoneHandler(adf_nbuf_t buf, void *context)
{
  903cec:	6c1004        	entry	a1, 32
 * @return data pointer to typecast into your priv structure
 */
static inline a_uint8_t *
adf_nbuf_get_priv(adf_nbuf_t buf)
{
    return (__adf_nbuf_get_priv(buf));
  903cef:	022a02        	or	a10, a2, a2
  903cf2:	5bfdda        	call8	90345c <__adf_nbuf_get_priv>
	A_UINT8 current_eid;
	HTC_CONTEXT *pHTC = (HTC_CONTEXT *)context;
	HTC_BUF_CONTEXT *ctx;
      
	ctx = (HTC_BUF_CONTEXT *)adf_nbuf_get_priv(buf);
	current_eid = ctx->end_point;
  903cf5:	24a000        	l8ui	a4, a10, 0
 *         or NULL if there is not sufficient data to pull.
 */
static inline a_uint8_t *
adf_nbuf_pull_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_pull_head(buf, size);
  903cf8:	c0b8      	movi.n	a11, 8
  903cfa:	022a02        	or	a10, a2, a2
  903cfd:	5bfdbc        	call8	9033f0 <__adf_nbuf_pull_head>
	/* Walk through the buffers and fixup the ones we used for HTC headers.
	 * The buffer list may contain more than one string of HTC buffers comprising of an
	 * HTC message so we need to check every buffer */            
	adf_nbuf_pull_head(buf, HTC_HDR_LENGTH);
                   
	pHTC->Endpoints[current_eid].pService->
  903d00:	0f4811        	slli	a8, a4, 1
  903d03:	a488      	add.n	a8, a8, a4
  903d05:	0d8811        	slli	a8, a8, 3
  903d08:	a833      	add.n	a3, a3, a8
  903d0a:	8332      	l32i.n	a3, a3, 8
  903d0c:	db20      	mov.n	a11, a2
  903d0e:	8832      	l32i.n	a8, a3, 8
  903d10:	8c36      	l32i.n	a12, a3, 24
  903d12:	044a02        	or	a10, a4, a4
  903d15:	0b8000        	callx8	a8
  903d18:	d10f      	retw.n
	...

00903d1c <HTC_AssembleBuffers>:
	if ((pEndpoint)->ConnectionFlags & HTC_CONNECT_FLAGS_REDUCE_CREDIT_DRIBBLE) { \
		AdjustCreditThreshold((pEndpoint));			\
	}    

LOCAL void HTC_AssembleBuffers(HTC_CONTEXT *pHTC, int Count, int Size)
{
  903d1c:	6c1004        	entry	a1, 32
	BUF_Pool_create_pool(pHTC->PoolHandle, POOL_ID_HTC_CONTROL, Count, Size);       
  903d1f:	18716e        	l32r	a8, 8e02d8 <_bss_end+0x3d2ad0>
  903d22:	2a229b        	l32i	a10, a2, 0x26c
  903d25:	2882a0        	l32i	a8, a8, 0x280
  903d28:	dd40      	mov.n	a13, a4
  903d2a:	dc30      	mov.n	a12, a3
  903d2c:	c0b0      	movi.n	a11, 0
  903d2e:	0b8000        	callx8	a8
  903d31:	d10f      	retw.n
	...

00903d34 <_HTC_Init>:
}

LOCAL htc_handle_t _HTC_Init(HTC_SETUP_COMPLETE_CB SetupComplete,
                             HTC_CONFIG *pConfig)
{
  903d34:	6c1006        	entry	a1, 48
#include "Magpie_api.h"

static inline void *	__adf_os_mem_alloc(adf_os_size_t size)
{
//    return (malloc(size,M_DEVBUF,M_DONTWAIT | M_ZERO));
    return A_ALLOCRAM(size);
  903d37:	14716e        	l32r	a4, 8e02f0 <_bss_end+0x3d2ae8>
  903d3a:	022502        	or	a5, a2, a2
  903d3d:	224252        	l32i	a2, a4, 0x148
  903d40:	2b2a74        	movi	a11, 0x274
  903d43:	c0a0      	movi.n	a10, 0
  903d45:	0b2000        	callx8	a2
}
/* zero a memory buffer */
static inline void
__adf_os_mem_zero(void *buf, adf_os_size_t size)
{
    A_MEMZERO(buf,size);
  903d48:	8844      	l32i.n	a8, a4, 16
  903d4a:	2c2a74        	movi	a12, 0x274
  903d4d:	c0b0      	movi.n	a11, 0
#include "Magpie_api.h"

static inline void *	__adf_os_mem_alloc(adf_os_size_t size)
{
//    return (malloc(size,M_DEVBUF,M_DONTWAIT | M_ZERO));
    return A_ALLOCRAM(size);
  903d4f:	d2a0      	mov.n	a2, a10
}
/* zero a memory buffer */
static inline void
__adf_os_mem_zero(void *buf, adf_os_size_t size)
{
    A_MEMZERO(buf,size);
  903d51:	0b8000        	callx8	a8
    
        pHTC = (HTC_CONTEXT *)adf_os_mem_alloc(sizeof(HTC_CONTEXT));
    
	adf_os_mem_zero(pHTC, sizeof(HTC_CONTEXT));

	pHTC->OSHandle = pConfig->OSHandle;
  903d54:	8832      	l32i.n	a8, a3, 8
	pHTC->PoolHandle = pConfig->PoolHandle;
	pHTC->hifHandle = pConfig->HIFHandle;
  903d56:	8a33      	l32i.n	a10, a3, 12
    
        pHTC = (HTC_CONTEXT *)adf_os_mem_alloc(sizeof(HTC_CONTEXT));
    
	adf_os_mem_zero(pHTC, sizeof(HTC_CONTEXT));

	pHTC->OSHandle = pConfig->OSHandle;
  903d58:	9820      	s32i.n	a8, a2, 0
	pHTC->PoolHandle = pConfig->PoolHandle;
  903d5a:	8834      	l32i.n	a8, a3, 16
	hifCBConfig.send_buf_done = A_INDIR(htc._HTC_SendDoneHandler);
	hifCBConfig.recv_buf = A_INDIR(htc._HTC_MsgRecvHandler);
	hifCBConfig.context = pHTC;
    
	/* initialize hardware layer */
	HIF_register_callback(pConfig->HIFHandle, &hifCBConfig);
  903d5c:	db10      	mov.n	a11, a1
        pHTC = (HTC_CONTEXT *)adf_os_mem_alloc(sizeof(HTC_CONTEXT));
    
	adf_os_mem_zero(pHTC, sizeof(HTC_CONTEXT));

	pHTC->OSHandle = pConfig->OSHandle;
	pHTC->PoolHandle = pConfig->PoolHandle;
  903d5e:	28269b        	s32i	a8, a2, 0x26c
	pHTC->hifHandle = pConfig->HIFHandle;
                        
	hifCBConfig.send_buf_done = A_INDIR(htc._HTC_SendDoneHandler);
  903d61:	28428c        	l32i	a8, a4, 0x230
    
	adf_os_mem_zero(pHTC, sizeof(HTC_CONTEXT));

	pHTC->OSHandle = pConfig->OSHandle;
	pHTC->PoolHandle = pConfig->PoolHandle;
	pHTC->hifHandle = pConfig->HIFHandle;
  903d64:	2a269a        	s32i	a10, a2, 0x268
                        
	hifCBConfig.send_buf_done = A_INDIR(htc._HTC_SendDoneHandler);
  903d67:	9810      	s32i.n	a8, a1, 0
	hifCBConfig.recv_buf = A_INDIR(htc._HTC_MsgRecvHandler);
  903d69:	28428b        	l32i	a8, a4, 0x22c
	hifCBConfig.context = pHTC;
  903d6c:	9212      	s32i.n	a2, a1, 8
	pHTC->OSHandle = pConfig->OSHandle;
	pHTC->PoolHandle = pConfig->PoolHandle;
	pHTC->hifHandle = pConfig->HIFHandle;
                        
	hifCBConfig.send_buf_done = A_INDIR(htc._HTC_SendDoneHandler);
	hifCBConfig.recv_buf = A_INDIR(htc._HTC_MsgRecvHandler);
  903d6e:	9811      	s32i.n	a8, a1, 4
	hifCBConfig.context = pHTC;
    
	/* initialize hardware layer */
	HIF_register_callback(pConfig->HIFHandle, &hifCBConfig);
  903d70:	284277        	l32i	a8, a4, 0x1dc
  903d73:	0b8000        	callx8	a8
        /* see if the host wants us to override the number of ctrl buffers */
	pHTC->NumBuffersForCreditRpts = 0;
    
	if (0 == pHTC->NumBuffersForCreditRpts) {
		/* nothing to override, simply set default */
		pHTC->NumBuffersForCreditRpts = HTC_DEFAULT_NUM_CTRL_BUFFERS; 
  903d76:	c086      	movi.n	a8, 6
  903d78:	282696        	s32i	a8, a2, 0x258
	}    
    
	pHTC->MaxEpPendingCreditRpts = 0;
    
	if (0 == pHTC->MaxEpPendingCreditRpts) {
		pHTC->MaxEpPendingCreditRpts = HTC_DEFAULT_MAX_EP_PENDING_CREDIT_REPORTS;    
  903d7b:	c083      	movi.n	a8, 3
  903d7d:	282699        	s32i	a8, a2, 0x264
	}
	/* calculate the total allocation size based on the number of credit report buffers */
	pHTC->CtrlBufferAllocSize = MIN_CREDIT_BUFFER_ALLOC_SIZE * pHTC->NumBuffersForCreditRpts;
  903d80:	280ad8        	movi	a8, 216
  903d83:	282697        	s32i	a8, a2, 0x25c
	/* we need at least enough buffer space for 1 ctrl message */
	pHTC->CtrlBufferAllocSize = A_MAX(pHTC->CtrlBufferAllocSize,MAX_HTC_SETUP_MSG_SIZE);
    
	/* save the size of each buffer/credit we will receive */
	pHTC->RecvBufferSize = pConfig->CreditSize; //RecvBufferSize;
  903d86:	8830      	l32i.n	a8, a3, 0
	pHTC->TotalCredits = pConfig->CreditNumber;
  903d88:	8331      	l32i.n	a3, a3, 4
	pHTC->CtrlBufferAllocSize = MIN_CREDIT_BUFFER_ALLOC_SIZE * pHTC->NumBuffersForCreditRpts;
	/* we need at least enough buffer space for 1 ctrl message */
	pHTC->CtrlBufferAllocSize = A_MAX(pHTC->CtrlBufferAllocSize,MAX_HTC_SETUP_MSG_SIZE);
    
	/* save the size of each buffer/credit we will receive */
	pHTC->RecvBufferSize = pConfig->CreditSize; //RecvBufferSize;
  903d8a:	282691        	s32i	a8, a2, 0x244
	pHTC->TotalCredits = pConfig->CreditNumber;
  903d8d:	232694        	s32i	a3, a2, 0x250
	pHTC->TotalCreditsAssigned = 0;
  903d90:	c030      	movi.n	a3, 0
  903d92:	232695        	s32i	a3, a2, 0x254
     
	/* setup the pseudo service that handles HTC control messages */
	pHTC->HTCControlService.ProcessRecvMsg = A_INDIR(htc._HTC_ControlSvcProcessMsg);
  903d95:	23428d        	l32i	a3, a4, 0x234
	pHTC->HTCControlService.ProcessSendBufferComplete = A_INDIR(htc._HTC_ControlSvcProcessSendComplete);
	pHTC->HTCControlService.TrailerSpcCheckLimit = HTC_CTRL_BUFFER_CHECK_SIZE;
  903d98:	c18c      	movi.n	a8, 28
	pHTC->RecvBufferSize = pConfig->CreditSize; //RecvBufferSize;
	pHTC->TotalCredits = pConfig->CreditNumber;
	pHTC->TotalCreditsAssigned = 0;
     
	/* setup the pseudo service that handles HTC control messages */
	pHTC->HTCControlService.ProcessRecvMsg = A_INDIR(htc._HTC_ControlSvcProcessMsg);
  903d9a:	23268a        	s32i	a3, a2, 0x228
	pHTC->HTCControlService.ProcessSendBufferComplete = A_INDIR(htc._HTC_ControlSvcProcessSendComplete);
  903d9d:	23428e        	l32i	a3, a4, 0x238
	pHTC->HTCControlService.MaxSvcMsgSize = MAX_HTC_SETUP_MSG_SIZE;
	pHTC->HTCControlService.ServiceCtx = pHTC;
    
	/* automatically register this pseudo service to endpoint 1 */
	pHTC->Endpoints[ENDPOINT0].pService = &pHTC->HTCControlService;
	HIF_get_default_pipe(pHTC->hifHandle, &pHTC->Endpoints[ENDPOINT0].UpLinkPipeID, 
  903da0:	2a229a        	l32i	a10, a2, 0x268
	pHTC->TotalCredits = pConfig->CreditNumber;
	pHTC->TotalCreditsAssigned = 0;
     
	/* setup the pseudo service that handles HTC control messages */
	pHTC->HTCControlService.ProcessRecvMsg = A_INDIR(htc._HTC_ControlSvcProcessMsg);
	pHTC->HTCControlService.ProcessSendBufferComplete = A_INDIR(htc._HTC_ControlSvcProcessSendComplete);
  903da3:	23268b        	s32i	a3, a2, 0x22c
	pHTC->HTCControlService.TrailerSpcCheckLimit = HTC_CTRL_BUFFER_CHECK_SIZE;
  903da6:	232d02        	addmi	a3, a2, 0x200
  903da9:	28351d        	s16i	a8, a3, 58
	pHTC->HTCControlService.MaxSvcMsgSize = MAX_HTC_SETUP_MSG_SIZE;
  903dac:	c480      	movi.n	a8, 64
  903dae:	28351c        	s16i	a8, a3, 56
	pHTC->HTCControlService.ServiceCtx = pHTC;
    
	/* automatically register this pseudo service to endpoint 1 */
	pHTC->Endpoints[ENDPOINT0].pService = &pHTC->HTCControlService;
  903db1:	232a24        	movi	a3, 0x224
  903db4:	032308        	add	a3, a2, a3
  903db7:	9322      	s32i.n	a3, a2, 8
	HIF_get_default_pipe(pHTC->hifHandle, &pHTC->Endpoints[ENDPOINT0].UpLinkPipeID, 
  903db9:	234281        	l32i	a3, a4, 0x204
  903dbc:	2c2c18        	addi	a12, a2, 24
  903dbf:	2b2c19        	addi	a11, a2, 25
	/* setup the pseudo service that handles HTC control messages */
	pHTC->HTCControlService.ProcessRecvMsg = A_INDIR(htc._HTC_ControlSvcProcessMsg);
	pHTC->HTCControlService.ProcessSendBufferComplete = A_INDIR(htc._HTC_ControlSvcProcessSendComplete);
	pHTC->HTCControlService.TrailerSpcCheckLimit = HTC_CTRL_BUFFER_CHECK_SIZE;
	pHTC->HTCControlService.MaxSvcMsgSize = MAX_HTC_SETUP_MSG_SIZE;
	pHTC->HTCControlService.ServiceCtx = pHTC;
  903dc2:	22268f        	s32i	a2, a2, 0x23c
    
	/* automatically register this pseudo service to endpoint 1 */
	pHTC->Endpoints[ENDPOINT0].pService = &pHTC->HTCControlService;
	HIF_get_default_pipe(pHTC->hifHandle, &pHTC->Endpoints[ENDPOINT0].UpLinkPipeID, 
  903dc5:	0b3000        	callx8	a3
			     &pHTC->Endpoints[ENDPOINT0].DownLinkPipeID);
    
	/* Initialize control pipe so we could receive the HTC control packets */
	// @TODO: msg size!
	HIF_config_pipe(pHTC->hifHandle, pHTC->Endpoints[ENDPOINT0].UpLinkPipeID, 1);    
  903dc8:	2b2019        	l8ui	a11, a2, 25
  903dcb:	23427a        	l32i	a3, a4, 0x1e8
  903dce:	2a229a        	l32i	a10, a2, 0x268
  903dd1:	c0c1      	movi.n	a12, 1
  903dd3:	0b3000        	callx8	a3
    
	/* set the first free endpoint */
	pHTC->CurrentEpIndex = ENDPOINT1;
  903dd6:	c031      	movi.n	a3, 1
  903dd8:	232688        	s32i	a3, a2, 0x220
	pHTC->SetupCompleteCb = SetupComplete;
    
        /* setup buffers for just the setup phase, we only need 1 buffer to handle
	 * setup */
	HTC_AssembleBuffers(pHTC, 4, MAX_HTC_SETUP_MSG_SIZE);
  903ddb:	da20      	mov.n	a10, a2
	// @TODO: msg size!
	HIF_config_pipe(pHTC->hifHandle, pHTC->Endpoints[ENDPOINT0].UpLinkPipeID, 1);    
    
	/* set the first free endpoint */
	pHTC->CurrentEpIndex = ENDPOINT1;
	pHTC->SetupCompleteCb = SetupComplete;
  903ddd:	252693        	s32i	a5, a2, 0x24c
    
        /* setup buffers for just the setup phase, we only need 1 buffer to handle
	 * setup */
	HTC_AssembleBuffers(pHTC, 4, MAX_HTC_SETUP_MSG_SIZE);
  903de0:	c4c0      	movi.n	a12, 64
  903de2:	2b0a04        	movi	a11, 4
  903de5:	5bffcd        	call8	903d1c <HTC_AssembleBuffers>
   
	/* start hardware layer so that we can queue buffers */
	HIF_start(pHTC->hifHandle);
  903de8:	2a229a        	l32i	a10, a2, 0x268
  903deb:	234279        	l32i	a3, a4, 0x1e4
  903dee:	0b3000        	callx8	a3
    
	return pHTC;
}
  903df1:	d10f      	retw.n
	...

00903df4 <_HTC_PauseRecv>:
  903df4:	6c1004        	entry	a1, 32
  903df7:	d10f      	retw.n
  903df9:	000000        	ill

00903dfc <_HTC_ResumeRecv>:
void _HTC_PauseRecv(HTC_ENDPOINT_ID EndpointID)
{
}

void _HTC_ResumeRecv(HTC_ENDPOINT_ID EndpointID)
{
  903dfc:	6c1004        	entry	a1, 32
  903dff:	d10f      	retw.n
  903e01:	000000        	ill

00903e04 <htc_module_install>:
    
	return HTC_HDR_LENGTH + HIF_get_reserved_headroom(pHTC->hifHandle);
}

void htc_module_install(struct htc_apis *pAPIs)
{   
  903e04:	6c1004        	entry	a1, 32
	pAPIs->_HTC_Init = _HTC_Init;
  903e07:	1871d9        	l32r	a8, 8e056c <_bss_end+0x3d2d64>
  903e0a:	9820      	s32i.n	a8, a2, 0
	pAPIs->_HTC_ReturnBuffers = _HTC_ReturnBuffers;
  903e0c:	1871da        	l32r	a8, 8e0574 <_bss_end+0x3d2d6c>
  903e0f:	9824      	s32i.n	a8, a2, 16
	pAPIs->_HTC_ReturnBuffersList = _HTC_ReturnBuffersList;
  903e11:	1871db        	l32r	a8, 8e0580 <_bss_end+0x3d2d78>
  903e14:	9825      	s32i.n	a8, a2, 20
	pAPIs->_HTC_Ready = _HTC_Ready;
  903e16:	1871dc        	l32r	a8, 8e0588 <_bss_end+0x3d2d80>
  903e19:	9823      	s32i.n	a8, a2, 12
	pAPIs->_HTC_RegisterService = _HTC_RegisterService;
  903e1b:	1871dd        	l32r	a8, 8e0590 <_bss_end+0x3d2d88>
  903e1e:	9822      	s32i.n	a8, a2, 8
	pAPIs->_HTC_SendMsg = _HTC_SendMsg;   
  903e20:	1871de        	l32r	a8, 8e0598 <_bss_end+0x3d2d90>
  903e23:	9826      	s32i.n	a8, a2, 24
	pAPIs->_HTC_Shutdown = _HTC_Shutdown;
  903e25:	1871df        	l32r	a8, 8e05a4 <_bss_end+0x3d2d9c>
  903e28:	9821      	s32i.n	a8, a2, 4
	pAPIs->_HTC_GetReservedHeadroom = _HTC_GetReservedHeadroom;
  903e2a:	1871e0        	l32r	a8, 8e05ac <_bss_end+0x3d2da4>
  903e2d:	9827      	s32i.n	a8, a2, 28
	pAPIs->_HTC_MsgRecvHandler = HTCMsgRecvHandler;
  903e2f:	1871e1        	l32r	a8, 8e05b4 <_bss_end+0x3d2dac>
  903e32:	9828      	s32i.n	a8, a2, 32
	pAPIs->_HTC_SendDoneHandler = HTCSendDoneHandler;
  903e34:	1871e2        	l32r	a8, 8e05bc <_bss_end+0x3d2db4>
  903e37:	9829      	s32i.n	a8, a2, 36
	pAPIs->_HTC_ControlSvcProcessMsg = HTCControlSvcProcessMsg;
  903e39:	1871e3        	l32r	a8, 8e05c8 <_bss_end+0x3d2dc0>
  903e3c:	982a      	s32i.n	a8, a2, 40
	pAPIs->_HTC_ControlSvcProcessSendComplete = HTCControlSvcProcessSendComplete;
  903e3e:	1871e4        	l32r	a8, 8e05d0 <_bss_end+0x3d2dc8>
  903e41:	982b      	s32i.n	a8, a2, 44
  903e43:	d10f      	retw.n
  903e45:	000000        	ill

00903e48 <HTCFreeMsgBuffer>:
}

/* free message to the free list */
LOCAL void HTCFreeMsgBuffer(HTC_CONTEXT *pHTC, adf_nbuf_t buf) 
{
  903e48:	6c1004        	entry	a1, 32
	BUF_Pool_free_buf(pHTC->PoolHandle, POOL_ID_HTC_CONTROL, buf);      
  903e4b:	18716e        	l32r	a8, 8e0404 <_bss_end+0x3d2bfc>
  903e4e:	2a229b        	l32i	a10, a2, 0x26c
  903e51:	2882a3        	l32i	a8, a8, 0x28c
  903e54:	dc30      	mov.n	a12, a3
  903e56:	2b0a00        	movi	a11, 0
  903e59:	0b8000        	callx8	a8
  903e5c:	d10f      	retw.n
	...

00903e60 <HTCAllocMsgBuffer>:
}

/* HTC control message allocator (also used for empty frames to send trailer options) */
LOCAL adf_nbuf_t HTCAllocMsgBuffer(HTC_CONTEXT *pHTC)
{
  903e60:	6c1004        	entry	a1, 32
	return BUF_Pool_alloc_buf(pHTC->PoolHandle,
  903e63:	18716e        	l32r	a8, 8e041c <_bss_end+0x3d2c14>
	BUF_Pool_free_buf(pHTC->PoolHandle, POOL_ID_HTC_CONTROL, buf);      
}

/* HTC control message allocator (also used for empty frames to send trailer options) */
LOCAL adf_nbuf_t HTCAllocMsgBuffer(HTC_CONTEXT *pHTC)
{
  903e66:	da20      	mov.n	a10, a2
	return BUF_Pool_alloc_buf(pHTC->PoolHandle,
  903e68:	2282a1        	l32i	a2, a8, 0x284
  903e6b:	28828a        	l32i	a8, a8, 0x228
  903e6e:	23a29b        	l32i	a3, a10, 0x26c
  903e71:	0b8000        	callx8	a8
  903e74:	dca0      	mov.n	a12, a10
  903e76:	c0b0      	movi.n	a11, 0
  903e78:	da30      	mov.n	a10, a3
  903e7a:	0b2000        	callx8	a2
				  POOL_ID_HTC_CONTROL,
				  HTC_GetReservedHeadroom(pHTC));   
}
  903e7d:	d2a0      	mov.n	a2, a10
  903e7f:	d10f      	retw.n
  903e81:	000000        	ill

00903e84 <_HTC_Ready>:
	pService->pNext = pHTC->pServiceList;
	pHTC->pServiceList = pService;
}

LOCAL void _HTC_Ready(htc_handle_t htcHandle)
{
  903e84:	6c1004        	entry	a1, 32
	adf_nbuf_t pBuffer;
	HTC_READY_MSG *pReady;
	a_uint8_t *addr;
	HTC_CONTEXT *pHTC = (HTC_CONTEXT *)htcHandle;
    
	pBuffer = HTCAllocMsgBuffer(pHTC);
  903e87:	022a02        	or	a10, a2, a2
  903e8a:	5bfff5        	call8	903e60 <HTCAllocMsgBuffer>
 *         put, or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_put_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_put_tail(buf, size);
  903e8d:	c0b8      	movi.n	a11, 8
  903e8f:	d4a0      	mov.n	a4, a10
  903e91:	5bfdd7        	call8	9035f0 <__adf_nbuf_put_tail>
	/* an optimization... the header length is chosen to
	 * be aligned on a 16 bit bounday, the fields in the message are designed to
	 * be aligned */
	addr = adf_nbuf_put_tail(pBuffer, sizeof(HTC_READY_MSG));       
	pReady = (HTC_READY_MSG *)addr;     
	A_MEMZERO(pReady,sizeof(HTC_READY_MSG));  
  903e94:	15716e        	l32r	a5, 8e044c <_bss_end+0x3d2c44>
  903e97:	c0c8      	movi.n	a12, 8
  903e99:	8854      	l32i.n	a8, a5, 16
  903e9b:	c0b0      	movi.n	a11, 0
  903e9d:	d3a0      	mov.n	a3, a10
  903e9f:	0b8000        	callx8	a8
	pReady->MessageID = adf_os_htons(HTC_MSG_READY_ID);
  903ea2:	c081      	movi.n	a8, 1
  903ea4:	283401        	s8i	a8, a3, 1
	pReady->CreditSize = adf_os_htons((A_UINT16)pHTC->RecvBufferSize);
  903ea7:	282291        	l32i	a8, a2, 0x244
	 * be aligned on a 16 bit bounday, the fields in the message are designed to
	 * be aligned */
	addr = adf_nbuf_put_tail(pBuffer, sizeof(HTC_READY_MSG));       
	pReady = (HTC_READY_MSG *)addr;     
	A_MEMZERO(pReady,sizeof(HTC_READY_MSG));  
	pReady->MessageID = adf_os_htons(HTC_MSG_READY_ID);
  903eaa:	c0b0      	movi.n	a11, 0
	pReady->CreditSize = adf_os_htons((A_UINT16)pHTC->RecvBufferSize);
  903eac:	08084f        	extui	a8, a8, 0, 16
  903eaf:	088914        	srli	a9, a8, 8
  903eb2:	283405        	s8i	a8, a3, 5
	pReady->CreditCount = adf_os_htons((A_UINT16)pHTC->TotalCredits);
  903eb5:	282294        	l32i	a8, a2, 0x250
	 * be aligned */
	addr = adf_nbuf_put_tail(pBuffer, sizeof(HTC_READY_MSG));       
	pReady = (HTC_READY_MSG *)addr;     
	A_MEMZERO(pReady,sizeof(HTC_READY_MSG));  
	pReady->MessageID = adf_os_htons(HTC_MSG_READY_ID);
	pReady->CreditSize = adf_os_htons((A_UINT16)pHTC->RecvBufferSize);
  903eb8:	293404        	s8i	a9, a3, 4
	pReady->CreditCount = adf_os_htons((A_UINT16)pHTC->TotalCredits);
  903ebb:	08084f        	extui	a8, a8, 0, 16
  903ebe:	088914        	srli	a9, a8, 8
  903ec1:	283403        	s8i	a8, a3, 3
	pReady->MaxEndpoints = ENDPOINT_MAX;
  903ec4:	c186      	movi.n	a8, 22
  903ec6:	283406        	s8i	a8, a3, 6
	 * be aligned on a 16 bit bounday, the fields in the message are designed to
	 * be aligned */
	addr = adf_nbuf_put_tail(pBuffer, sizeof(HTC_READY_MSG));       
	pReady = (HTC_READY_MSG *)addr;     
	A_MEMZERO(pReady,sizeof(HTC_READY_MSG));  
	pReady->MessageID = adf_os_htons(HTC_MSG_READY_ID);
  903ec9:	2b3400        	s8i	a11, a3, 0
	pReady->CreditSize = adf_os_htons((A_UINT16)pHTC->RecvBufferSize);
	pReady->CreditCount = adf_os_htons((A_UINT16)pHTC->TotalCredits);
  903ecc:	293402        	s8i	a9, a3, 2
	pReady->MaxEndpoints = ENDPOINT_MAX;
       
	/* send out the message */
	HTC_SendMsg(pHTC, ENDPOINT0, pBuffer);
  903ecf:	235289        	l32i	a3, a5, 0x224
  903ed2:	dc40      	mov.n	a12, a4
  903ed4:	da20      	mov.n	a10, a2
  903ed6:	0b3000        	callx8	a3
  903ed9:	d10f      	retw.n
	...

00903edc <HTCCheckAndSendCreditReport>:
				  HTC_GetReservedHeadroom(pHTC));   
}

LOCAL void HTCCheckAndSendCreditReport(HTC_CONTEXT *pHTC, A_UINT32 EpMask,
				       HTC_ENDPOINT *pEndpoint, HTC_ENDPOINT_ID Eid)
{
  903edc:	6c1004        	entry	a1, 32
	adf_nbuf_t pCredBuffer;
	HTC_BUF_CONTEXT *ctx;    
        
	do {
		/* check if host needs credits */
		if (!(pHTC->EpHostNeedsCreditMap & EpMask)) {
  903edf:	282285        	l32i	a8, a2, 0x214
  903ee2:	78305a        	bnone	a3, a8, 903f40 <HTCCheckAndSendCreditReport+0x64>
			/* host does not need any credits for this set */
			break;    
		}
		/* check if any are pending */
		if (!(pHTC->EpCreditPendingMap & EpMask)) {
  903ee5:	282286        	l32i	a8, a2, 0x218
  903ee8:	783054        	bnone	a3, a8, 903f40 <HTCCheckAndSendCreditReport+0x64>
			/* nothing to send up */
			break;    
		}  
		/* was an endpoint specified? */
		if (pEndpoint != NULL) {
  903eeb:	c945      	beqz.n	a4, 903f04 <HTCCheckAndSendCreditReport+0x28>
			/* see if a threshold is in effect for this endpoint */
			if (pEndpoint->CreditReturnThreshhold != 0) {
  903eed:	234904        	l16si	a3, a4, 8
  903ef0:	c834      	beqz.n	a3, 903ef8 <HTCCheckAndSendCreditReport+0x1c>
				if (pEndpoint->CreditsToReturn < pEndpoint->CreditReturnThreshhold) {
  903ef2:	284900        	l16si	a8, a4, 0
  903ef5:	738247        	blt	a8, a3, 903f40 <HTCCheckAndSendCreditReport+0x64>
					 * back to the host */
					break;
				}
			}
         
			if (pEndpoint->PendingCreditReports >= pHTC->MaxEpPendingCreditRpts) {
  903ef8:	8844      	l32i.n	a8, a4, 16
  903efa:	232299        	l32i	a3, a2, 0x264
  903efd:	738203        	blt	a8, a3, 903f04 <HTCCheckAndSendCreditReport+0x28>
  903f00:	600009        	j	903f0d <HTCCheckAndSendCreditReport+0x31>
  903f03:	00da20        	excw
		}
        
		/* if we get here we have some credits to send up */
                        
		/* allocate a message buffer for the trailer */
		pCredBuffer = HTCAllocMsgBuffer(pHTC);
  903f06:	5bffd6        	call8	903e60 <HTCAllocMsgBuffer>
  903f09:	d3a0      	mov.n	a3, a10
		if (NULL == pCredBuffer) {
  903f0b:	ccae      	bnez.n	a10, 903f1d <HTCCheckAndSendCreditReport+0x41>
			/* no buffers left to send an empty message with trailers, host will just
			 * have to wait until we get our endpoint 0 messages back.. */
			/* mark that we need to send an update as soon as we can get a buffer back */
			pHTC->StateFlags |= HTC_SEND_CREDIT_UPDATE_SOON;
  903f0d:	232292        	l32i	a3, a2, 0x248
  903f10:	c042      	movi.n	a4, 2
  903f12:	043302        	or	a3, a3, a4
  903f15:	232692        	s32i	a3, a2, 0x248
  903f18:	d10f      	retw.n
  903f1a:	000000        	ill
 * @return data pointer to typecast into your priv structure
 */
static inline a_uint8_t *
adf_nbuf_get_priv(adf_nbuf_t buf)
{
    return (__adf_nbuf_get_priv(buf));
  903f1d:	5bfd4f        	call8	90345c <__adf_nbuf_get_priv>
			break;    
		}
        
		ctx = (HTC_BUF_CONTEXT *)adf_nbuf_get_priv(pCredBuffer);
		if (pEndpoint != NULL) {
  903f20:	c84d      	beqz.n	a4, 903f31 <HTCCheckAndSendCreditReport+0x55>
			/* keep track of pending reports */
			pEndpoint->PendingCreditReports++; 
  903f22:	8844      	l32i.n	a8, a4, 16
  903f24:	b188      	addi.n	a8, a8, 1
  903f26:	9844      	s32i.n	a8, a4, 16
			/* save the endpoint in order to decrement the count when the send completes */
			ctx->htc_flags = Eid | HTC_FLAGS_CREDIT_RPT;
  903f28:	240a20        	movi	a4, 32
  903f2b:	045502        	or	a5, a5, a4
  903f2e:	25a401        	s8i	a5, a10, 1
		}   
            
		/* this is an empty message, the HTC_SendMsg will tack on a trailer in the remaining
		 * space, NOTE: no need to flush the cache, the header and trailers are assembled
		 * using uncached addresses */
		HTC_SendMsg(pHTC, ENDPOINT0, pCredBuffer);    
  903f31:	14716e        	l32r	a4, 8e04ec <_bss_end+0x3d2ce4>
  903f34:	dc30      	mov.n	a12, a3
  903f36:	244289        	l32i	a4, a4, 0x224
  903f39:	c0b0      	movi.n	a11, 0
  903f3b:	da20      	mov.n	a10, a2
  903f3d:	0b4000        	callx8	a4
  903f40:	d10f      	retw.n
	...

00903f44 <ReturnBuffers>:
	/* now we need to wait for service connection requests */
}

LOCAL void ReturnBuffers(htc_handle_t htcHandle, HTC_ENDPOINT_ID EndpointID,
			 adf_nbuf_t pBuffers, A_BOOL sendCreditFlag)
{   
  903f44:	6c1004        	entry	a1, 32
 *         or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_push_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_push_head(buf, size);
  903f47:	c0b8      	movi.n	a11, 8
  903f49:	da40      	mov.n	a10, a4
    
	/* supply some head-room again */
	adf_nbuf_push_head(pBuffers, HTC_HDR_LENGTH);
              
	/* enqueue all buffers to the single mailbox */
	HIF_return_recv_buf(pHTC->hifHandle, pHTC->Endpoints[EndpointID].UpLinkPipeID, pBuffers);    
  903f4b:	0f3611        	slli	a6, a3, 1
  903f4e:	5bfd1d        	call8	9033c4 <__adf_nbuf_push_head>
  903f51:	a366      	add.n	a6, a6, a3
  903f53:	18716e        	l32r	a8, 8e050c <_bss_end+0x3d2d04>
  903f56:	0d6611        	slli	a6, a6, 3
  903f59:	a627      	add.n	a7, a2, a6
  903f5b:	28827c        	l32i	a8, a8, 0x1f0
  903f5e:	2b7019        	l8ui	a11, a7, 25
  903f61:	2a229a        	l32i	a10, a2, 0x268
  903f64:	dc40      	mov.n	a12, a4
  903f66:	0b8000        	callx8	a8
     
	if (pHTC->StateFlags & HTC_STATE_SETUP_COMPLETE) {       
  903f69:	242292        	l32i	a4, a2, 0x248
  903f6c:	7f4730        	bbci	a4, 31, 903fa0 <ReturnBuffers+0x5c>
		A_UINT32    epCreditMask = (1 << EndpointID);
		/* we are running normally */
		/* update pending credit counts with the number of buffers that were added */
		pHTC->Endpoints[EndpointID].CreditsToReturn += (A_INT16)nbufs;
  903f6f:	287102        	l16ui	a8, a7, 4
              
	/* enqueue all buffers to the single mailbox */
	HIF_return_recv_buf(pHTC->hifHandle, pHTC->Endpoints[EndpointID].UpLinkPipeID, pBuffers);    
     
	if (pHTC->StateFlags & HTC_STATE_SETUP_COMPLETE) {       
		A_UINT32    epCreditMask = (1 << EndpointID);
  903f72:	c0b1      	movi.n	a11, 1
		/* we are running normally */
		/* update pending credit counts with the number of buffers that were added */
		pHTC->Endpoints[EndpointID].CreditsToReturn += (A_INT16)nbufs;
  903f74:	b188      	addi.n	a8, a8, 1
  903f76:	287502        	s16i	a8, a7, 4
		pHTC->Endpoints[EndpointID].CreditsConsumed -= (A_INT16)nbufs;  
  903f79:	287107        	l16ui	a8, a7, 14
              
	/* enqueue all buffers to the single mailbox */
	HIF_return_recv_buf(pHTC->hifHandle, pHTC->Endpoints[EndpointID].UpLinkPipeID, pBuffers);    
     
	if (pHTC->StateFlags & HTC_STATE_SETUP_COMPLETE) {       
		A_UINT32    epCreditMask = (1 << EndpointID);
  903f7c:	003104        	ssl	a3
  903f7f:	00bb1a        	sll	a11, a11
		/* we are running normally */
		/* update pending credit counts with the number of buffers that were added */
		pHTC->Endpoints[EndpointID].CreditsToReturn += (A_INT16)nbufs;
		pHTC->Endpoints[EndpointID].CreditsConsumed -= (A_INT16)nbufs;  
  903f82:	b088      	addi.n	a8, a8, -1
  903f84:	287507        	s16i	a8, a7, 14
		/* update bit map that this endpoint has non-zero credits */
		pHTC->EpCreditPendingMap |= epCreditMask; 
  903f87:	272286        	l32i	a7, a2, 0x218
  903f8a:	0b7702        	or	a7, a7, a11
  903f8d:	272686        	s32i	a7, a2, 0x218

		if (sendCreditFlag) {
  903f90:	c954      	beqz.n	a5, 903fa8 <ReturnBuffers+0x64>
			HTCCheckAndSendCreditReport(pHTC, epCreditMask,&pHTC->Endpoints[EndpointID],EndpointID);
  903f92:	b46c      	addi.n	a12, a6, 4
  903f94:	dd30      	mov.n	a13, a3
  903f96:	ac2c      	add.n	a12, a2, a12
  903f98:	da20      	mov.n	a10, a2
  903f9a:	5bffd0        	call8	903edc <HTCCheckAndSendCreditReport>
  903f9d:	d10f      	retw.n
  903f9f:	002322        	excw
	} else {
		/* we have not started yet so all return operations are simply adding buffers
		 * to the interface at startup, so we can keep track of how many total 
		 * credits we get */
		/* update global count that will be returned to the host */
		pHTC->TotalCredits += nbufs;
  903fa2:	94b1      	s32i.n	a4, a11, 4
  903fa4:	332326        	excw
  903fa7:	94d1      	s32i.n	a4, a13, 4
  903fa9:	0f0000        	callx12	a0

00903fac <_HTC_ReturnBuffers>:
	HTCCheckAndSendCreditReport(pHTC, (1 << EndpointID),&pHTC->Endpoints[EndpointID],EndpointID);
}

LOCAL void _HTC_ReturnBuffers(htc_handle_t htcHandle, HTC_ENDPOINT_ID EndpointID,
			      adf_nbuf_t pBuffers)
{
  903fac:	6c1004        	entry	a1, 32
	ReturnBuffers(htcHandle, EndpointID, pBuffers, TRUE);
  903faf:	c0d1      	movi.n	a13, 1
  903fb1:	dc40      	mov.n	a12, a4
  903fb3:	db30      	mov.n	a11, a3
  903fb5:	da20      	mov.n	a10, a2
  903fb7:	5bffe3        	call8	903f44 <ReturnBuffers>
  903fba:	d10f      	retw.n

00903fbc <_HTC_ReturnBuffersList>:
}

LOCAL void _HTC_ReturnBuffersList(htc_handle_t htcHandle,
				  HTC_ENDPOINT_ID EndpointID,
				  adf_nbuf_queue_t bufHead)
{
  903fbc:	6c1006        	entry	a1, 48
 * @return first buffer in queue
 */
static inline adf_nbuf_t 
adf_nbuf_queue_first(adf_nbuf_queue_t *head)
{
    return (__adf_nbuf_queue_first(head));
  903fbf:	da10      	mov.n	a10, a1
  903fc1:	9410      	s32i.n	a4, a1, 0
  903fc3:	9511      	s32i.n	a5, a1, 4
  903fc5:	9612      	s32i.n	a6, a1, 8
  903fc7:	5bfdbb        	call8	9036b4 <__adf_nbuf_queue_first>
  903fca:	d4a0      	mov.n	a4, a10
	while (netbuf) {

		tmpNbuf = netbuf;
		netbuf = adf_nbuf_queue_next(netbuf);

		ReturnBuffers(htcHandle, EndpointID, tmpNbuf, FALSE);
  903fcc:	c050      	movi.n	a5, 0
	adf_nbuf_t netbuf, tmpNbuf;

	/* retrieve each nbuf in the queue */
	netbuf = adf_nbuf_queue_first(&bufHead);

	while (netbuf) {
  903fce:	600014        	j	903fe6 <_HTC_ReturnBuffersList+0x2a>
 * @return next buffer/packet
 */
static inline adf_nbuf_t
adf_nbuf_queue_next(adf_nbuf_t buf)
{
    return (__adf_nbuf_queue_next(buf));
  903fd1:	da40      	mov.n	a10, a4
  903fd3:	5bfdba        	call8	9036bc <__adf_nbuf_queue_next>
  903fd6:	d6a0      	mov.n	a6, a10

		tmpNbuf = netbuf;
		netbuf = adf_nbuf_queue_next(netbuf);

		ReturnBuffers(htcHandle, EndpointID, tmpNbuf, FALSE);
  903fd8:	dc40      	mov.n	a12, a4
  903fda:	dd50      	mov.n	a13, a5
  903fdc:	db30      	mov.n	a11, a3
  903fde:	022a02        	or	a10, a2, a2
  903fe1:	5bffd8        	call8	903f44 <ReturnBuffers>
	netbuf = adf_nbuf_queue_first(&bufHead);

	while (netbuf) {

		tmpNbuf = netbuf;
		netbuf = adf_nbuf_queue_next(netbuf);
  903fe4:	d460      	mov.n	a4, a6
	adf_nbuf_t netbuf, tmpNbuf;

	/* retrieve each nbuf in the queue */
	netbuf = adf_nbuf_queue_first(&bufHead);

	while (netbuf) {
  903fe6:	654fe7        	bnez	a4, 903fd1 <_HTC_ReturnBuffersList+0x15>
		netbuf = adf_nbuf_queue_next(netbuf);

		ReturnBuffers(htcHandle, EndpointID, tmpNbuf, FALSE);
	}

	HTCCheckAndSendCreditReport(pHTC, (1 << EndpointID),&pHTC->Endpoints[EndpointID],EndpointID);
  903fe9:	0f3c11        	slli	a12, a3, 1
  903fec:	a3cc      	add.n	a12, a12, a3
  903fee:	0dcc11        	slli	a12, a12, 3
  903ff1:	b4cc      	addi.n	a12, a12, 4
  903ff3:	c0b1      	movi.n	a11, 1
  903ff5:	dd30      	mov.n	a13, a3
  903ff7:	ac2c      	add.n	a12, a2, a12
  903ff9:	003104        	ssl	a3
  903ffc:	00bb1a        	sll	a11, a11
  903fff:	da20      	mov.n	a10, a2
  904001:	5bffb6        	call8	903edc <HTCCheckAndSendCreditReport>
  904004:	d10f      	retw.n
	...

00904008 <HTCControlSvcProcessSendComplete>:
}

/* callback when endpoint 0 send buffers are completed */
LOCAL void HTCControlSvcProcessSendComplete(HTC_ENDPOINT_ID EndpointID,
					    adf_nbuf_t pBuffers, void *arg)
{
  904008:	6c1004        	entry	a1, 32
 * @return data pointer to typecast into your priv structure
 */
static inline a_uint8_t *
adf_nbuf_get_priv(adf_nbuf_t buf)
{
    return (__adf_nbuf_get_priv(buf));
  90400b:	da30      	mov.n	a10, a3
  90400d:	5bfd13        	call8	90345c <__adf_nbuf_get_priv>
	HTC_ENDPOINT_ID creditRptEndpoint;
    
	ctx = (HTC_BUF_CONTEXT *)adf_nbuf_get_priv(pBuffers);       
    
	/* put them back into the pool */
	if ( ctx->htc_flags & HTC_FLAGS_CREDIT_RPT ) {   
  904010:	28a001        	l8ui	a8, a10, 1
  904013:	7a8712        	bbci	a8, 26, 904029 <HTCControlSvcProcessSendComplete+0x21>
		/* extract the endpoint number that requested this credit report */ 
		creditRptEndpoint = ctx->htc_flags & HTC_FLAGS_CRPT_EP_MASK;    
  904016:	080944        	extui	a9, a8, 0, 5
		pHTC->Endpoints[creditRptEndpoint].PendingCreditReports--;  
  904019:	0f9811        	slli	a8, a9, 1
  90401c:	a988      	add.n	a8, a8, a9
  90401e:	0d8811        	slli	a8, a8, 3
  904021:	a848      	add.n	a8, a4, a8
  904023:	8985      	l32i.n	a9, a8, 20
  904025:	b099      	addi.n	a9, a9, -1
  904027:	9985      	s32i.n	a9, a8, 20
	}
    
	HTCFreeMsgBuffer(pHTC, pBuffers);
  904029:	db30      	mov.n	a11, a3
  90402b:	da40      	mov.n	a10, a4
  90402d:	5bff86        	call8	903e48 <HTCFreeMsgBuffer>
   
	if (pHTC->StateFlags & HTC_SEND_CREDIT_UPDATE_SOON) {
  904030:	284292        	l32i	a8, a4, 0x248
  904033:	7e8712        	bbci	a8, 30, 904049 <HTCControlSvcProcessSendComplete+0x41>
		/* this flag is set when the host could not send a credit report
		 * because we ran out of HTC control buffers */
		pHTC->StateFlags &= ~HTC_SEND_CREDIT_UPDATE_SOON;
  904036:	c73d      	movi.n	a3, -3
  904038:	038801        	and	a8, a8, a3
  90403b:	284692        	s32i	a8, a4, 0x248
		/* send out a report if anything is pending */
		HTCCheckAndSendCreditReport(pHTC, HTC_ANY_ENDPOINT_MASK,NULL,ENDPOINT_MAX);
  90403e:	c1d6      	movi.n	a13, 22
  904040:	c0c0      	movi.n	a12, 0
  904042:	c7bf      	movi.n	a11, -1
  904044:	da40      	mov.n	a10, a4
  904046:	5bffa5        	call8	903edc <HTCCheckAndSendCreditReport>
  904049:	d10f      	retw.n
	...

0090404c <HTCProcessConnectMsg>:
	} while (FALSE);      
}
        
/* called in response to the arrival of a service connection message */
LOCAL void HTCProcessConnectMsg(HTC_CONTEXT *pHTC, HTC_CONNECT_SERVICE_MSG *pMsg)
{
  90404c:	6c1008        	entry	a1, 64
	HTC_SERVICE *pService = pHTC->pServiceList;
	A_UINT8 connectStatus = HTC_SERVICE_NOT_FOUND;
	adf_nbuf_t pBuffer;
	HTC_CONNECT_SERVICE_RESPONSE_MSG *pRspMsg;
	int metaDataOutLen = 0;
  90404f:	c070      	movi.n	a7, 0
  904051:	9710      	s32i.n	a7, a1, 0
	A_UINT16 serviceId = adf_os_ntohs(pMsg->ServiceID);
  904053:	283002        	l8ui	a8, a3, 2
    
	pBuffer = HTCAllocMsgBuffer(pHTC);
  904056:	da20      	mov.n	a10, a2
	HTC_SERVICE *pService = pHTC->pServiceList;
	A_UINT8 connectStatus = HTC_SERVICE_NOT_FOUND;
	adf_nbuf_t pBuffer;
	HTC_CONNECT_SERVICE_RESPONSE_MSG *pRspMsg;
	int metaDataOutLen = 0;
	A_UINT16 serviceId = adf_os_ntohs(pMsg->ServiceID);
  904058:	088411        	slli	a4, a8, 8
  90405b:	283003        	l8ui	a8, a3, 3
}
        
/* called in response to the arrival of a service connection message */
LOCAL void HTCProcessConnectMsg(HTC_CONTEXT *pHTC, HTC_CONNECT_SERVICE_MSG *pMsg)
{
	HTC_SERVICE *pService = pHTC->pServiceList;
  90405e:	252290        	l32i	a5, a2, 0x240
	A_UINT8 connectStatus = HTC_SERVICE_NOT_FOUND;
	adf_nbuf_t pBuffer;
	HTC_CONNECT_SERVICE_RESPONSE_MSG *pRspMsg;
	int metaDataOutLen = 0;
	A_UINT16 serviceId = adf_os_ntohs(pMsg->ServiceID);
  904061:	048802        	or	a8, a8, a4
    
	pBuffer = HTCAllocMsgBuffer(pHTC);
  904064:	9814      	s32i.n	a8, a1, 16
  904066:	5bff7e        	call8	903e60 <HTCAllocMsgBuffer>
 *         put, or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_put_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_put_tail(buf, size);
  904069:	c0ba      	movi.n	a11, 10
  90406b:	d6a0      	mov.n	a6, a10
  90406d:	5bfd60        	call8	9035f0 <__adf_nbuf_put_tail>
	/* note : this will be aligned */
	pRspMsg = (HTC_CONNECT_SERVICE_RESPONSE_MSG *)
                adf_nbuf_put_tail(pBuffer, sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
                                 
	A_MEMZERO(pRspMsg,sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
  904070:	19716e        	l32r	a9, 8e0628 <_bss_end+0x3d2e20>
  904073:	c0ca      	movi.n	a12, 10
  904075:	8d94      	l32i.n	a13, a9, 16
  904077:	db70      	mov.n	a11, a7
  904079:	d4a0      	mov.n	a4, a10
  90407b:	0bd000        	callx8	a13
	pRspMsg->MessageID = adf_os_htons(HTC_MSG_CONNECT_SERVICE_RESPONSE_ID);
	/* reflect the service ID for this connect attempt */
	pRspMsg->ServiceID = adf_os_htons(serviceId);
  90407e:	8814      	l32i.n	a8, a1, 16
	/* note : this will be aligned */
	pRspMsg = (HTC_CONNECT_SERVICE_RESPONSE_MSG *)
                adf_nbuf_put_tail(pBuffer, sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
                                 
	A_MEMZERO(pRspMsg,sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
	pRspMsg->MessageID = adf_os_htons(HTC_MSG_CONNECT_SERVICE_RESPONSE_ID);
  904080:	c093      	movi.n	a9, 3
  904082:	294401        	s8i	a9, a4, 1
	/* reflect the service ID for this connect attempt */
	pRspMsg->ServiceID = adf_os_htons(serviceId);
  904085:	088914        	srli	a9, a8, 8
  904088:	294402        	s8i	a9, a4, 2
	/* note : this will be aligned */
	pRspMsg = (HTC_CONNECT_SERVICE_RESPONSE_MSG *)
                adf_nbuf_put_tail(pBuffer, sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
                                 
	A_MEMZERO(pRspMsg,sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
	pRspMsg->MessageID = adf_os_htons(HTC_MSG_CONNECT_SERVICE_RESPONSE_ID);
  90408b:	274400        	s8i	a7, a4, 0
	/* reflect the service ID for this connect attempt */
	pRspMsg->ServiceID = adf_os_htons(serviceId);
  90408e:	284403        	s8i	a8, a4, 3

	while (pService) {
        
		if (pHTC->CurrentEpIndex >= ENDPOINT_MAX) {
  904091:	c195      	movi.n	a9, 21
	A_MEMZERO(pRspMsg,sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
	pRspMsg->MessageID = adf_os_htons(HTC_MSG_CONNECT_SERVICE_RESPONSE_ID);
	/* reflect the service ID for this connect attempt */
	pRspMsg->ServiceID = adf_os_htons(serviceId);

	while (pService) {
  904093:	600077        	j	90410e <HTCProcessConnectMsg+0xc2>
        
		if (pHTC->CurrentEpIndex >= ENDPOINT_MAX) {
  904096:	2b2288        	l32i	a11, a2, 0x220
  904099:	7b9279        	blt	a9, a11, 904116 <HTCProcessConnectMsg+0xca>
			/* no more endpoints */
			connectStatus = HTC_SERVICE_NO_RESOURCES;
			break;    
		}

		if (serviceId == pService->ServiceID) {
  90409c:	2a5108        	l16ui	a10, a5, 16
  90409f:	78a969        	bne	a10, a8, 90410c <HTCProcessConnectMsg+0xc0>
			A_UINT8 *pMetaDataOut;
            
			/* outgoing meta data resides in the space after the response message */
			pMetaDataOut = ((A_UINT8 *)pRspMsg) + sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG);
            
			if (pMsg->ServiceMetaLength != 0) {
  9040a2:	2d3008        	l8ui	a13, a3, 8
				/* the meta data follows the connect service message */
				pMetaDataIN = ((A_UINT8 *)pMsg) + sizeof(HTC_CONNECT_SERVICE_MSG);
  9040a5:	c080      	movi.n	a8, 0
  9040a7:	ba3c      	addi.n	a12, a3, 10
  9040a9:	0d8c38        	moveqz	a12, a8, a13
			}

			/* call the connect callback with the endpoint to use and pointers to meta data */
			connectStatus = pService->ProcessConnect(pService,
  9040ac:	8853      	l32i.n	a8, a5, 12
  9040ae:	df10      	mov.n	a15, a1
  9040b0:	ba4e      	addi.n	a14, a4, 10
  9040b2:	055a02        	or	a10, a5, a5
  9040b5:	0b8000        	callx8	a8
								 pMsg->ServiceMetaLength,
								 pMetaDataOut,
								 &metaDataOutLen);
            
			/* check if the service accepted this connection request */
			if (HTC_SERVICE_SUCCESS == connectStatus) {
  9040b8:	65a05c        	bnez	a10, 904118 <HTCProcessConnectMsg+0xcc>
				/* set the length of the response meta data going back to the host */
				pRspMsg->ServiceMetaLength = (A_UINT8)metaDataOutLen;
  9040bb:	8810      	l32i.n	a8, a1, 0
  9040bd:	284408        	s8i	a8, a4, 8
				/* set the endpoint ID the host will now communicate over */
				pRspMsg->EndpointID = pHTC->CurrentEpIndex;
  9040c0:	292288        	l32i	a9, a2, 0x220
  9040c3:	294405        	s8i	a9, a4, 5
				/* return the maximum message size for this service */
				pRspMsg->MaxMsgSize = adf_os_htons((A_UINT16)pService->MaxSvcMsgSize);
  9040c6:	285014        	l8ui	a8, a5, 20
  9040c9:	284406        	s8i	a8, a4, 6
  9040cc:	285015        	l8ui	a8, a5, 21
  9040cf:	284407        	s8i	a8, a4, 7
  9040d2:	0f9811        	slli	a8, a9, 1
  9040d5:	a988      	add.n	a8, a8, a9
  9040d7:	0d8811        	slli	a8, a8, 3
  9040da:	a828      	add.n	a8, a2, a8
				/* assign this endpoint to this service, this will be used in routing messages */
				pHTC->Endpoints[pHTC->CurrentEpIndex].pService = pService;
  9040dc:	9582      	s32i.n	a5, a8, 8
				/* set connection flags */
				pHTC->Endpoints[pHTC->CurrentEpIndex].ConnectionFlags = pMsg->ConnectionFlags;
  9040de:	2b3004        	l8ui	a11, a3, 4
  9040e1:	08bc11        	slli	a12, a11, 8
  9040e4:	2b3005        	l8ui	a11, a3, 5
  9040e7:	0cbb02        	or	a11, a11, a12
  9040ea:	2b8508        	s16i	a11, a8, 16
                
				pHTC->Endpoints[pHTC->CurrentEpIndex].DownLinkPipeID = pMsg->DownLinkPipeID;
  9040ed:	2b3006        	l8ui	a11, a3, 6
  9040f0:	2b8418        	s8i	a11, a8, 24
				pHTC->Endpoints[pHTC->CurrentEpIndex].UpLinkPipeID = pMsg->UpLinkPipeID;
  9040f3:	233007        	l8ui	a3, a3, 7
  9040f6:	238419        	s8i	a3, a8, 25
                
				/* mark that we are now connected */
				pService->ServiceFlags |= HTC_SERVICE_FLAGS_CONNECTED;
  9040f9:	235109        	l16ui	a3, a5, 18
  9040fc:	c081      	movi.n	a8, 1
  9040fe:	083302        	or	a3, a3, a8
  904101:	235509        	s16i	a3, a5, 18
				/* bump up our index, this EP is now in use */
				pHTC->CurrentEpIndex++;   
  904104:	b193      	addi.n	a3, a9, 1
  904106:	232688        	s32i	a3, a2, 0x220
  904109:	60000b        	j	904118 <HTCProcessConnectMsg+0xcc>
			}

			break;
		}       
        
		pService = pService->pNext;   
  90410c:	8550      	l32i.n	a5, a5, 0
	A_MEMZERO(pRspMsg,sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
	pRspMsg->MessageID = adf_os_htons(HTC_MSG_CONNECT_SERVICE_RESPONSE_ID);
	/* reflect the service ID for this connect attempt */
	pRspMsg->ServiceID = adf_os_htons(serviceId);

	while (pService) {
  90410e:	655f84        	bnez	a5, 904096 <HTCProcessConnectMsg+0x4a>
        
/* called in response to the arrival of a service connection message */
LOCAL void HTCProcessConnectMsg(HTC_CONTEXT *pHTC, HTC_CONNECT_SERVICE_MSG *pMsg)
{
	HTC_SERVICE *pService = pHTC->pServiceList;
	A_UINT8 connectStatus = HTC_SERVICE_NOT_FOUND;
  904111:	c0a1      	movi.n	a10, 1
  904113:	600001        	j	904118 <HTCProcessConnectMsg+0xcc>

	while (pService) {
        
		if (pHTC->CurrentEpIndex >= ENDPOINT_MAX) {
			/* no more endpoints */
			connectStatus = HTC_SERVICE_NO_RESOURCES;
  904116:	c0a3      	movi.n	a10, 3
		}       
        
		pService = pService->pNext;   
	}
                   
	pRspMsg->Status = connectStatus;    
  904118:	2a4404        	s8i	a10, a4, 4
    
	/* send out the response message */
	HTC_SendMsg(pHTC, ENDPOINT0, pBuffer); 
  90411b:	14716e        	l32r	a4, 8e06d4 <_bss_end+0x3d2ecc>
  90411e:	dc60      	mov.n	a12, a6
  904120:	234289        	l32i	a3, a4, 0x224
  904123:	c0b0      	movi.n	a11, 0
  904125:	da20      	mov.n	a10, a2
  904127:	0b3000        	callx8	a3
  90412a:	d10f      	retw.n

0090412c <HTCProcessConfigPipeMsg>:
}

LOCAL void HTCProcessConfigPipeMsg(HTC_CONTEXT *pHTC, HTC_CONFIG_PIPE_MSG *pMsg)
{
  90412c:	6c1004        	entry	a1, 32
	adf_nbuf_t pBuffer;
	HTC_CONFIG_PIPE_RESPONSE_MSG *pRspMsg;
        
	pBuffer = HTCAllocMsgBuffer(pHTC);
  90412f:	022a02        	or	a10, a2, a2
  904132:	5bff4b        	call8	903e60 <HTCAllocMsgBuffer>
  904135:	c0b4      	movi.n	a11, 4
  904137:	d6a0      	mov.n	a6, a10
  904139:	5bfd2d        	call8	9035f0 <__adf_nbuf_put_tail>
       
	/* note : this will be aligned */
	pRspMsg = (HTC_CONFIG_PIPE_RESPONSE_MSG *)
                adf_nbuf_put_tail(pBuffer, sizeof(HTC_CONFIG_PIPE_RESPONSE_MSG));    
              
	A_MEMZERO(pRspMsg,sizeof(HTC_CONFIG_PIPE_RESPONSE_MSG));
  90413c:	15716e        	l32r	a5, 8e06f4 <_bss_end+0x3d2eec>
  90413f:	c0b0      	movi.n	a11, 0
  904141:	8854      	l32i.n	a8, a5, 16
  904143:	c0c4      	movi.n	a12, 4
  904145:	d4a0      	mov.n	a4, a10
  904147:	0b8000        	callx8	a8
    
	pRspMsg->MessageID = adf_os_htons(HTC_MSG_CONFIG_PIPE_RESPONSE_ID);
  90414a:	c080      	movi.n	a8, 0
  90414c:	284400        	s8i	a8, a4, 0
  90414f:	280a06        	movi	a8, 6
  904152:	284401        	s8i	a8, a4, 1
	/* reflect the service ID for this connect attempt */
	pRspMsg->PipeID = pMsg->PipeID;
  904155:	2b3002        	l8ui	a11, a3, 2
  904158:	2b4402        	s8i	a11, a4, 2

	if ( HIF_is_pipe_supported(pHTC->hifHandle, pMsg->PipeID) ) {
  90415b:	28527d        	l32i	a8, a5, 0x1f4
  90415e:	2a229a        	l32i	a10, a2, 0x268
  904161:	0b8000        	callx8	a8
  904164:	c9a4      	beqz.n	a10, 90417c <HTCProcessConfigPipeMsg+0x50>
		pRspMsg->Status = 0;            
  904166:	c080      	movi.n	a8, 0
  904168:	284403        	s8i	a8, a4, 3
	} else {
		pRspMsg->Status = 1; 
		goto config_done;
	}

	if ( (pHTC->TotalCreditsAssigned + pMsg->CreditCount) <= pHTC->TotalCredits ) {
  90416b:	2c3003        	l8ui	a12, a3, 3
  90416e:	282295        	l32i	a8, a2, 0x254
  904171:	292294        	l32i	a9, a2, 0x250
  904174:	a8c8      	add.n	a8, a12, a8
  904176:	78921a        	blt	a9, a8, 904194 <HTCProcessConfigPipeMsg+0x68>
  904179:	600004        	j	904181 <HTCProcessConfigPipeMsg+0x55>
	pRspMsg->PipeID = pMsg->PipeID;

	if ( HIF_is_pipe_supported(pHTC->hifHandle, pMsg->PipeID) ) {
		pRspMsg->Status = 0;            
	} else {
		pRspMsg->Status = 1; 
  90417c:	c031      	movi.n	a3, 1
  90417e:	600014        	j	904196 <HTCProcessConfigPipeMsg+0x6a>
		goto config_done;
	}

	if ( (pHTC->TotalCreditsAssigned + pMsg->CreditCount) <= pHTC->TotalCredits ) {
		pHTC->TotalCreditsAssigned += pMsg->CreditCount;
  904181:	282695        	s32i	a8, a2, 0x254
	} else {
		pRspMsg->Status = 2;
		goto config_done;
	}
    
	HIF_config_pipe(pHTC->hifHandle, pMsg->PipeID, pMsg->CreditCount);
  904184:	24527a        	l32i	a4, a5, 0x1e8
  904187:	2b3002        	l8ui	a11, a3, 2
  90418a:	2a229a        	l32i	a10, a2, 0x268
  90418d:	0b4000        	callx8	a4
  904190:	600005        	j	904199 <HTCProcessConfigPipeMsg+0x6d>
  904193:	00c032        	sext	a0, a12, 7
	}

	if ( (pHTC->TotalCreditsAssigned + pMsg->CreditCount) <= pHTC->TotalCredits ) {
		pHTC->TotalCreditsAssigned += pMsg->CreditCount;
	} else {
		pRspMsg->Status = 2;
  904196:	234403        	s8i	a3, a4, 3
    
	HIF_config_pipe(pHTC->hifHandle, pMsg->PipeID, pMsg->CreditCount);
    
config_done:      
	/* send out the response message */
	HTC_SendMsg(pHTC, ENDPOINT0, pBuffer);             
  904199:	235289        	l32i	a3, a5, 0x224
  90419c:	dc60      	mov.n	a12, a6
  90419e:	c0b0      	movi.n	a11, 0
  9041a0:	da20      	mov.n	a10, a2
  9041a2:	0b3000        	callx8	a3
  9041a5:	d10f      	retw.n
	...

009041a8 <HTCControlSvcProcessMsg>:
}

/* process an incomming control message from the host */
LOCAL void HTCControlSvcProcessMsg(HTC_ENDPOINT_ID EndpointID, adf_nbuf_t hdr_buf,
				   adf_nbuf_t pBuffers, void *arg)
{  
  9041a8:	6c1006        	entry	a1, 48
	a_uint8_t *anbdata;
	a_uint32_t anblen;
	HTC_CONTEXT *pHTC = (HTC_CONTEXT *)arg;
	HTC_UNKNOWN_MSG  *pMsg;
	
	adf_os_assert(hdr_buf == ADF_NBUF_NULL);
  9041ab:	c832      	beqz.n	a3, 9041b1 <HTCControlSvcProcessMsg+0x9>
  9041ad:	63fffc        	j	9041ad <HTCControlSvcProcessMsg+0x5>
  9041b0:	00b41b        	excw
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  9041b3:	dc10      	mov.n	a12, a1
  9041b5:	da40      	mov.n	a10, a4
  9041b7:	5bfd33        	call8	903684 <__adf_nbuf_peek_header>

	/* we assume buffers are aligned such that we can access the message
	 * parameters directly*/
	adf_nbuf_peek_header(pBuffers, &anbdata, &anblen);
	pMsg = (HTC_UNKNOWN_MSG *)anbdata;
  9041ba:	8b11      	l32i.n	a11, a1, 4
    
	/* we cannot handle fragmented messages across buffers */
    
	switch ( adf_os_ntohs(pMsg->MessageID) ) {        
  9041bc:	28b000        	l8ui	a8, a11, 0
  9041bf:	088611        	slli	a6, a8, 8
  9041c2:	28b001        	l8ui	a8, a11, 1
  9041c5:	068802        	or	a8, a8, a6
		break;            
        case HTC_MSG_SETUP_COMPLETE_ID:
                /* the host has indicated that it has completed all
		   setup tasks and we can now let the services take over to
		   run the rest of the application */
		setupComplete = TRUE;  
  9041c8:	c061      	movi.n	a6, 1
	adf_nbuf_peek_header(pBuffers, &anbdata, &anblen);
	pMsg = (HTC_UNKNOWN_MSG *)anbdata;
    
	/* we cannot handle fragmented messages across buffers */
    
	switch ( adf_os_ntohs(pMsg->MessageID) ) {        
  9041ca:	688416        	beqi	a8, 4, 9041e4 <HTCControlSvcProcessMsg+0x3c>
  9041cd:	68850c        	beqi	a8, 5, 9041dd <HTCControlSvcProcessMsg+0x35>
  9041d0:	69820e        	bnei	a8, 2, 9041e2 <HTCControlSvcProcessMsg+0x3a>
        case HTC_MSG_CONNECT_SERVICE_ID:
		HTCProcessConnectMsg(pHTC, (HTC_CONNECT_SERVICE_MSG *)pMsg); 
  9041d3:	da50      	mov.n	a10, a5
  9041d5:	5bff9d        	call8	90404c <HTCProcessConnectMsg>
  9041d8:	600006        	j	9041e2 <HTCControlSvcProcessMsg+0x3a>
  9041db:	0000da        	excw
		break;
        case HTC_MSG_CONFIG_PIPE_ID:
		HTCProcessConfigPipeMsg(pHTC, (HTC_CONFIG_PIPE_MSG *)pMsg); 
  9041de:	505bff        	call0	91b1dc <_etext+0x10189>
  9041e1:	d3d6      	excw

/* process an incomming control message from the host */
LOCAL void HTCControlSvcProcessMsg(HTC_ENDPOINT_ID EndpointID, adf_nbuf_t hdr_buf,
				   adf_nbuf_t pBuffers, void *arg)
{  
	A_BOOL setupComplete = FALSE;
  9041e3:	302852        	excw
		break;
        default:
		;
	}  
        
	if (pHTC->StateFlags & HTC_STATE_SETUP_COMPLETE) {
  9041e6:	9213      	s32i.n	a2, a1, 12
  9041e8:	716e7f        	bbsi	a6, 1, 90426b <AdjustCreditThreshold+0x3b>
  9041eb:	870b      	l32i.n	a7, a0, 44
		/* recycle buffer only if we are fully running */
		HTC_ReturnBuffers(pHTC, ENDPOINT0,pBuffers);
  9041ed:	223287        	l32i	a2, a3, 0x21c
  9041f0:	dc40      	mov.n	a12, a4
  9041f2:	c0b0      	movi.n	a11, 0
  9041f4:	da50      	mov.n	a10, a5
  9041f6:	60001b        	j	904215 <HTCControlSvcProcessMsg+0x6d>
 *         or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_push_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_push_head(buf, size);
  9041f9:	c0b8      	movi.n	a11, 8
  9041fb:	da40      	mov.n	a10, a4
  9041fd:	5bfc71        	call8	9033c4 <__adf_nbuf_push_head>
	} else {
		/* supply some head-room again */
		adf_nbuf_push_head(pBuffers, HTC_HDR_LENGTH);
            
		/* otherwise return the packet back to mbox */
		HIF_return_recv_buf(pHTC->hifHandle, pHTC->Endpoints[EndpointID].UpLinkPipeID, pBuffers);        
  904200:	0f2811        	slli	a8, a2, 1
  904203:	a288      	add.n	a8, a8, a2
  904205:	0d8811        	slli	a8, a8, 3
  904208:	a858      	add.n	a8, a5, a8
  90420a:	22327c        	l32i	a2, a3, 0x1f0
  90420d:	2b8019        	l8ui	a11, a8, 25
  904210:	2a529a        	l32i	a10, a5, 0x268
  904213:	dc40      	mov.n	a12, a4
  904215:	0b2000        	callx8	a2
	}

	if (setupComplete) {        
  904218:	c961      	beqz.n	a6, 90422d <HTCControlSvcProcessMsg+0x85>
		/* mark that setup has completed */
		pHTC->StateFlags |= HTC_STATE_SETUP_COMPLETE; 
  90421a:	225292        	l32i	a2, a5, 0x248
  90421d:	c031      	movi.n	a3, 1
  90421f:	032202        	or	a2, a2, a3
  904222:	225692        	s32i	a2, a5, 0x248
		if (pHTC->SetupCompleteCb != NULL) {
  904225:	225293        	l32i	a2, a5, 0x24c
  904228:	c821      	beqz.n	a2, 90422d <HTCControlSvcProcessMsg+0x85>
			pHTC->SetupCompleteCb();
  90422a:	0b2000        	callx8	a2
  90422d:	d10f      	retw.n
	...

00904230 <AdjustCreditThreshold>:
					  buf, 
					  pHTC->Endpoints[current_eid].pService->ServiceCtx);
}

LOCAL void AdjustCreditThreshold(HTC_ENDPOINT  *pEndpoint)
{
  904230:	6c1004        	entry	a1, 32
	A_INT16 creditsOutstanding = pEndpoint->CreditsToReturn + pEndpoint->CreditsConsumed;
  904233:	292105        	l16ui	a9, a2, 10
  904236:	282100        	l16ui	a8, a2, 0
  904239:	a988      	add.n	a8, a8, a9
        /* set the new threshold based on the number of credits that have been consumed
         * and which have not been returned by the app.
         * Note: it is okay for this threshold to be zero which indicates no threshold 
         * is in use */    
	switch (pEndpoint->ConnectionFlags & HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_MASK) {
  90423b:	292106        	l16ui	a9, a2, 12
					  pHTC->Endpoints[current_eid].pService->ServiceCtx);
}

LOCAL void AdjustCreditThreshold(HTC_ENDPOINT  *pEndpoint)
{
	A_INT16 creditsOutstanding = pEndpoint->CreditsToReturn + pEndpoint->CreditsConsumed;
  90423e:	088832        	sext	a8, a8, 15
        /* set the new threshold based on the number of credits that have been consumed
         * and which have not been returned by the app.
         * Note: it is okay for this threshold to be zero which indicates no threshold 
         * is in use */    
	switch (pEndpoint->ConnectionFlags & HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_MASK) {
  904241:	090941        	extui	a9, a9, 0, 2
  904244:	689110        	beqi	a9, 1, 904258 <AdjustCreditThreshold+0x28>
  904247:	c895      	beqz.n	a9, 904250 <AdjustCreditThreshold+0x20>
  904249:	689213        	beqi	a9, 2, 904260 <AdjustCreditThreshold+0x30>
  90424c:	60001b        	j	90426b <AdjustCreditThreshold+0x3b>
  90424f:	000828        	mull	a8, a0, a0
        case HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_ONE_FOURTH :
		creditsOutstanding >>= 2;
  904252:	126000        	l32r	a2, 8dc254 <_bss_end+0x3cea4c>
		break;                    
  904255:	140000        	l32r	a4, 8c4258 <_bss_end+0x3b6a50>
        case HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_ONE_HALF :
		creditsOutstanding >>= 1;
  904258:	081812        	srai	a8, a8, 1
		break;
  90425b:	60000c        	j	90426b <AdjustCreditThreshold+0x3b>
  90425e:	00000f        	subx8	a0, a0, a0
        case HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_THREE_FOURTHS :  
		creditsOutstanding = (creditsOutstanding * 3) >> 2;                  
  904261:	8911      	l32i.n	a9, a1, 4
  904263:	a898      	add.n	a8, a9, a8
  904265:	082812        	srai	a8, a8, 2
  904268:	088832        	sext	a8, a8, 15
		break;
		/* default case is unity */    
	}
    
	pEndpoint->CreditReturnThreshhold = creditsOutstanding;
  90426b:	282504        	s16i	a8, a2, 8
  90426e:	d10f      	retw.n

00904270 <_HTC_SendMsg>:
	ReturnBuffers(htcHandle, EndpointID, pBuffers, TRUE);
}
 
LOCAL void _HTC_SendMsg(htc_handle_t htcHandle, HTC_ENDPOINT_ID EndpointID,
			adf_nbuf_t pBuffers)
{
  904270:	6c1008        	entry	a1, 64
 * @return data pointer to typecast into your priv structure
 */
static inline a_uint8_t *
adf_nbuf_get_priv(adf_nbuf_t buf)
{
    return (__adf_nbuf_get_priv(buf));
  904273:	044a02        	or	a10, a4, a4
  904276:	5bfc79        	call8	90345c <__adf_nbuf_get_priv>
  904279:	d5a0      	mov.n	a5, a10
 * @return The total length of this buf.
 */
static inline adf_os_size_t
adf_nbuf_len(adf_nbuf_t buf)
{
    return (__adf_nbuf_len(buf));
  90427b:	da40      	mov.n	a10, a4
  90427d:	5bfcf9        	call8	903664 <__adf_nbuf_len>
  904280:	9a10      	s32i.n	a10, a1, 0
 *         or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_push_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_push_head(buf, size);
  904282:	c0b8      	movi.n	a11, 8
  904284:	da40      	mov.n	a10, a4
  904286:	5bfc4f        	call8	9033c4 <__adf_nbuf_push_head>
	 * Note: in HTCSendDoneHandler(), we undo this so that the caller get's it's buffer
	 * back untainted */   
	pHTCHdr = (HTC_FRAME_HDR *)adf_nbuf_push_head(pBuffers, HTC_HDR_LENGTH);
    
	/* flag that this is the header buffer that was modified */
	ctx->htc_flags |= HTC_FLAGS_BUF_HDR;   
  904289:	285001        	l8ui	a8, a5, 1
  90428c:	c490      	movi.n	a9, 64
  90428e:	098802        	or	a8, a8, a9
  904291:	285401        	s8i	a8, a5, 1
	/* mark where this buffer came from */
	ctx->end_point = EndpointID;      
  904294:	030847        	extui	a8, a3, 0, 8
  904297:	285400        	s8i	a8, a5, 0
	/* the header start is ALWAYS aligned since we DMA it directly */

        /* set some fields, the rest of them will be filled below when we check for
	 * trailer space */
	pHTCHdr->Flags = 0;
  90429a:	c050      	movi.n	a5, 0
  90429c:	25a401        	s8i	a5, a10, 1
		HTC_RECORD_HDR    *pRecHdr;
		int               pipeMaxLen;
		A_UINT32          roomForPipeMaxLen;
                          
		/* figure out how much room the last buffer can spare */
		pipeMaxLen = HIF_get_max_msg_len(pHTC->hifHandle,
  90429f:	0f3511        	slli	a5, a3, 1
  9042a2:	a355      	add.n	a5, a5, a3
	/* the header start is ALWAYS aligned since we DMA it directly */

        /* set some fields, the rest of them will be filled below when we check for
	 * trailer space */
	pHTCHdr->Flags = 0;
	pHTCHdr->EndpointID = EndpointID;    
  9042a4:	28a400        	s8i	a8, a10, 0
		HTC_RECORD_HDR    *pRecHdr;
		int               pipeMaxLen;
		A_UINT32          roomForPipeMaxLen;
                          
		/* figure out how much room the last buffer can spare */
		pipeMaxLen = HIF_get_max_msg_len(pHTC->hifHandle,
  9042a7:	0d5511        	slli	a5, a5, 3
  9042aa:	18716e        	l32r	a8, 8e0864 <_bss_end+0x3d305c>
  9042ad:	a525      	add.n	a5, a2, a5
  9042af:	2b5018        	l8ui	a11, a5, 24
  9042b2:	28827e        	l32i	a8, a8, 0x1f8
  9042b5:	d6a0      	mov.n	a6, a10
  9042b7:	2a229a        	l32i	a10, a2, 0x268
  9042ba:	0b8000        	callx8	a8
  9042bd:	d5a0      	mov.n	a5, a10
 * @return amount of head room
 */
static inline a_uint32_t
adf_nbuf_headroom(adf_nbuf_t buf)
{
    return (__adf_nbuf_headroom(buf));
  9042bf:	da40      	mov.n	a10, a4
  9042c1:	5bfcde        	call8	90363c <__adf_nbuf_headroom>
						 pHTC->Endpoints[EndpointID].DownLinkPipeID);
		roomForPipeMaxLen = pipeMaxLen - adf_nbuf_headroom(pBuffers) - adf_nbuf_len(pBuffers);
  9042c4:	0a550c        	sub	a5, a5, a10
 * @return The total length of this buf.
 */
static inline adf_os_size_t
adf_nbuf_len(adf_nbuf_t buf)
{
    return (__adf_nbuf_len(buf));
  9042c7:	da40      	mov.n	a10, a4
  9042c9:	5bfce6        	call8	903664 <__adf_nbuf_len>
  9042cc:	0a550c        	sub	a5, a5, a10
 * @return amount of tail room 
 */
static inline a_uint32_t
adf_nbuf_tailroom(adf_nbuf_t buf)
{
    return (__adf_nbuf_tailroom(buf));
  9042cf:	da40      	mov.n	a10, a4
  9042d1:	5bfcdd        	call8	903648 <__adf_nbuf_tailroom>
		if ( roomForPipeMaxLen < 0 ) {
			roomForPipeMaxLen = 0;
		}
                        
		room = adf_os_min( adf_nbuf_tailroom(pBuffers), roomForPipeMaxLen);
  9042d4:	75ab06        	bgeu	a10, a5, 9042de <_HTC_SendMsg+0x6e>
  9042d7:	da40      	mov.n	a10, a4
  9042d9:	5bfcdb        	call8	903648 <__adf_nbuf_tailroom>
  9042dc:	d5a0      	mov.n	a5, a10
		if (room < (int)(sizeof(HTC_CREDIT_REPORT) + sizeof(HTC_RECORD_HDR))) {
  9042de:	6b5402        	bgei	a5, 4, 9042e4 <_HTC_SendMsg+0x74>
  9042e1:	6000ad        	j	904392 <_HTC_SendMsg+0x122>
		/* note, a record header only has 8 bit fields, so this is safe.
		 * we need an uncached pointer here too */            
		totalReportBytes = 0;
        
		/* get a copy */        
		creditsPendingMap = pHTC->EpCreditPendingMap;   
  9042e4:	272286        	l32i	a7, a2, 0x218
                           
		/* test pending map to see if we can send a report , if any
		 * credits are available, we might as well send them on the 
		 * unused space in the buffer */
		if (creditsPendingMap) { 
  9042e7:	6470a7        	beqz	a7, 904392 <_HTC_SendMsg+0x122>
 *         put, or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_put_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_put_tail(buf, size);
  9042ea:	c0b2      	movi.n	a11, 2
  9042ec:	da40      	mov.n	a10, a4
  9042ee:	5bfcc0        	call8	9035f0 <__adf_nbuf_put_tail>
			pRecHdr = (HTC_RECORD_HDR *)adf_nbuf_put_tail(pBuffers,
							      sizeof(HTC_RECORD_HDR));
            
			/* set the ID, the length will be updated with the number of credit reports we
			 * can fit (see below) */
			pRecHdr->RecordID = HTC_RECORD_CREDITS;
  9042f1:	c091      	movi.n	a9, 1
  9042f3:	29a400        	s8i	a9, a10, 0
			pRecHdr->Length = 0;
  9042f6:	c090      	movi.n	a9, 0
  9042f8:	29a401        	s8i	a9, a10, 1
  9042fb:	dea0      	mov.n	a14, a10
			/* the credit report follows the record header */         
			totalReportBytes += sizeof(HTC_RECORD_HDR);
			room -= sizeof(HTC_RECORD_HDR);
  9042fd:	255cfe        	addi	a5, a5, -2
  904300:	b429      	addi.n	a9, a2, 4
			/* set the ID, the length will be updated with the number of credit reports we
			 * can fit (see below) */
			pRecHdr->RecordID = HTC_RECORD_CREDITS;
			pRecHdr->Length = 0;
			/* the credit report follows the record header */         
			totalReportBytes += sizeof(HTC_RECORD_HDR);
  904302:	c0c2      	movi.n	a12, 2
			room -= sizeof(HTC_RECORD_HDR);
            
			/* walkthrough pending credits map and build the records */
			for (i = 0; 
  904304:	c0d0      	movi.n	a13, 0
  904306:	600069        	j	904373 <_HTC_SendMsg+0x103>
			     (creditsPendingMap != 0) && (room >= (int)sizeof(HTC_CREDIT_REPORT)); 
			     i++) {                
				compareMask = (1 << i);
  904309:	c081      	movi.n	a8, 1
  90430b:	00d104        	ssl	a13
  90430e:	008f1a        	sll	a15, a8
				if (compareMask & creditsPendingMap) {
  904311:	7f7059        	bnone	a7, a15, 90436e <_HTC_SendMsg+0xfe>
  904314:	c0b2      	movi.n	a11, 2
  904316:	da40      	mov.n	a10, a4
  904318:	9915      	s32i.n	a9, a1, 20
  90431a:	9c13      	s32i.n	a12, a1, 12
  90431c:	9d12      	s32i.n	a13, a1, 8
  90431e:	9e14      	s32i.n	a14, a1, 16
  904320:	9f11      	s32i.n	a15, a1, 4
  904322:	5bfcb3        	call8	9035f0 <__adf_nbuf_put_tail>
									    sizeof(HTC_CREDIT_REPORT));
                                    
					/* clear pending mask, we are going to return all these credits */
					creditsPendingMap &= ~(compareMask);
					/* add this record */
					pCreditRpt->EndpointID = i;
  904325:	8d12      	l32i.n	a13, a1, 8
                        
					pCreditRpt = (HTC_CREDIT_REPORT *)adf_nbuf_put_tail(pBuffers,
									    sizeof(HTC_CREDIT_REPORT));
                                    
					/* clear pending mask, we are going to return all these credits */
					creditsPendingMap &= ~(compareMask);
  904327:	8f11      	l32i.n	a15, a1, 4
					/* add this record */
					pCreditRpt->EndpointID = i;
  904329:	2da400        	s8i	a13, a10, 0
					pCreditRpt->Credits = (A_UINT8)pHTC->Endpoints[i].CreditsToReturn;
  90432c:	8915      	l32i.n	a9, a1, 20
                        
					pCreditRpt = (HTC_CREDIT_REPORT *)adf_nbuf_put_tail(pBuffers,
									    sizeof(HTC_CREDIT_REPORT));
                                    
					/* clear pending mask, we are going to return all these credits */
					creditsPendingMap &= ~(compareMask);
  90432e:	c7bf      	movi.n	a11, -1
  904330:	0fbf03        	xor	a15, a11, a15
					/* add this record */
					pCreditRpt->EndpointID = i;
					pCreditRpt->Credits = (A_UINT8)pHTC->Endpoints[i].CreditsToReturn;
  904333:	2b9100        	l16ui	a11, a9, 0
                        
					pCreditRpt = (HTC_CREDIT_REPORT *)adf_nbuf_put_tail(pBuffers,
									    sizeof(HTC_CREDIT_REPORT));
                                    
					/* clear pending mask, we are going to return all these credits */
					creditsPendingMap &= ~(compareMask);
  904336:	0f7701        	and	a7, a7, a15
					/* add this record */
					pCreditRpt->EndpointID = i;
					pCreditRpt->Credits = (A_UINT8)pHTC->Endpoints[i].CreditsToReturn;
  904339:	2ba401        	s8i	a11, a10, 1
					/* remove pending credits, we always send deltas */
					pHTC->Endpoints[i].CreditsToReturn = 0; 
  90433c:	c0a0      	movi.n	a10, 0
  90433e:	2a9500        	s16i	a10, a9, 0
					/* adjust new threshold for this endpoint if needed */
					CHECK_AND_ADJUST_CREDIT_THRESHOLD(&pHTC->Endpoints[i]);
  904341:	2a9106        	l16ui	a10, a9, 12
  904344:	8c13      	l32i.n	a12, a1, 12
  904346:	8e14      	l32i.n	a14, a1, 16
  904348:	7da710        	bbci	a10, 29, 90435c <_HTC_SendMsg+0xec>
  90434b:	da90      	mov.n	a10, a9
  90434d:	9915      	s32i.n	a9, a1, 20
  90434f:	9d12      	s32i.n	a13, a1, 8
  904351:	5bffb7        	call8	904230 <AdjustCreditThreshold>
  904354:	8e14      	l32i.n	a14, a1, 16
  904356:	8d12      	l32i.n	a13, a1, 8
  904358:	8c13      	l32i.n	a12, a1, 12
  90435a:	8915      	l32i.n	a9, a1, 20
					/* update this record length */
					pRecHdr->Length += sizeof(HTC_CREDIT_REPORT);
  90435c:	2ae001        	l8ui	a10, a14, 1
					room -= sizeof(HTC_CREDIT_REPORT);
  90435f:	255cfe        	addi	a5, a5, -2
					/* remove pending credits, we always send deltas */
					pHTC->Endpoints[i].CreditsToReturn = 0; 
					/* adjust new threshold for this endpoint if needed */
					CHECK_AND_ADJUST_CREDIT_THRESHOLD(&pHTC->Endpoints[i]);
					/* update this record length */
					pRecHdr->Length += sizeof(HTC_CREDIT_REPORT);
  904362:	2aac02        	addi	a10, a10, 2
  904365:	2ae401        	s8i	a10, a14, 1
					room -= sizeof(HTC_CREDIT_REPORT);
					totalReportBytes += sizeof(HTC_CREDIT_REPORT);
  904368:	2ccc02        	addi	a12, a12, 2

					if ( room < sizeof(HTC_CREDIT_REPORT) ) {
  90436b:	6e5209        	bltui	a5, 2, 904378 <_HTC_SendMsg+0x108>
			room -= sizeof(HTC_RECORD_HDR);
            
			/* walkthrough pending credits map and build the records */
			for (i = 0; 
			     (creditsPendingMap != 0) && (room >= (int)sizeof(HTC_CREDIT_REPORT)); 
			     i++) {                
  90436e:	b1dd      	addi.n	a13, a13, 1
  904370:	299c18        	addi	a9, a9, 24
			/* the credit report follows the record header */         
			totalReportBytes += sizeof(HTC_RECORD_HDR);
			room -= sizeof(HTC_RECORD_HDR);
            
			/* walkthrough pending credits map and build the records */
			for (i = 0; 
  904373:	c871      	beqz.n	a7, 904378 <_HTC_SendMsg+0x108>
			     (creditsPendingMap != 0) && (room >= (int)sizeof(HTC_CREDIT_REPORT)); 
  904375:	6b5290        	bgei	a5, 2, 904309 <_HTC_SendMsg+0x99>
					}
				}
			}
            
			/* update new pending credits map */       
			pHTC->EpCreditPendingMap = creditsPendingMap;
  904378:	272686        	s32i	a7, a2, 0x218
		}
        
		if (totalReportBytes <= 0) {
  90437b:	6ac113        	blti	a12, 1, 904392 <_HTC_SendMsg+0x122>
		 */
        
		/* set header option bytes */ 
		pHTCHdr->ControlBytes[0] = totalReportBytes;
		/* HTC frame contains a trailer */
		pHTCHdr->Flags |= HTC_FLAGS_RECV_TRAILER;
  90437e:	256001        	l8ui	a5, a6, 1
  904381:	c082      	movi.n	a8, 2
  904383:	085502        	or	a5, a5, a8
  904386:	256401        	s8i	a5, a6, 1
		/* increment total size by the reports we added */
		totsz += totalReportBytes;
  904389:	8510      	l32i.n	a5, a1, 0
		 * The trailer can have at most 1 credit record with up to 32  reports in the record.
		 * The trailer can have at most 1 lookahead record with only 1 lookahead report in the record.
		 */
        
		/* set header option bytes */ 
		pHTCHdr->ControlBytes[0] = totalReportBytes;
  90438b:	2c6404        	s8i	a12, a6, 4
		/* HTC frame contains a trailer */
		pHTCHdr->Flags |= HTC_FLAGS_RECV_TRAILER;
		/* increment total size by the reports we added */
		totsz += totalReportBytes;
  90438e:	ac55      	add.n	a5, a5, a12
  904390:	9510      	s32i.n	a5, a1, 0
          
	if (totsz == 0) {
	}
    
	/* set length for message (this includes any reports that were added above) */
	pHTCHdr->PayloadLen = adf_os_htons(totsz);  
  904392:	8810      	l32i.n	a8, a1, 0
	HIF_send_buffer(pHTC->hifHandle, pHTC->Endpoints[EndpointID].DownLinkPipeID, pBuffers);       
  904394:	2a229a        	l32i	a10, a2, 0x268
          
	if (totsz == 0) {
	}
    
	/* set length for message (this includes any reports that were added above) */
	pHTCHdr->PayloadLen = adf_os_htons(totsz);  
  904397:	08074f        	extui	a7, a8, 0, 16
  90439a:	078514        	srli	a5, a7, 8
  90439d:	256402        	s8i	a5, a6, 2
	HIF_send_buffer(pHTC->hifHandle, pHTC->Endpoints[EndpointID].DownLinkPipeID, pBuffers);       
  9043a0:	0f3511        	slli	a5, a3, 1
  9043a3:	a353      	add.n	a3, a5, a3
  9043a5:	0d3311        	slli	a3, a3, 3
  9043a8:	15716e        	l32r	a5, 8e0960 <_bss_end+0x3d3158>
          
	if (totsz == 0) {
	}
    
	/* set length for message (this includes any reports that were added above) */
	pHTCHdr->PayloadLen = adf_os_htons(totsz);  
  9043ab:	276403        	s8i	a7, a6, 3
	HIF_send_buffer(pHTC->hifHandle, pHTC->Endpoints[EndpointID].DownLinkPipeID, pBuffers);       
  9043ae:	a323      	add.n	a3, a2, a3
  9043b0:	25527b        	l32i	a5, a5, 0x1ec
  9043b3:	2b3018        	l8ui	a11, a3, 24
  9043b6:	044c02        	or	a12, a4, a4
  9043b9:	0b5000        	callx8	a5
  9043bc:	d10f      	retw.n
	...

009043c0 <HTCMsgRecvHandler>:

}
            
/* callback from the mailbox hardware layer when a full message arrives */
LOCAL void HTCMsgRecvHandler(adf_nbuf_t hdr_buf, adf_nbuf_t buffer, void *context)
{
  9043c0:	6c1008        	entry	a1, 64
  9043c3:	9315      	s32i.n	a3, a1, 20
	a_uint32_t anblen;
	HTC_FRAME_HDR *pHTCHdr;
	HTC_CONTEXT *pHTC = (HTC_CONTEXT *)context;
	adf_nbuf_t tmp_nbuf;
                
	if (hdr_buf == ADF_NBUF_NULL) {
  9043c5:	022339        	movnez	a3, a2, a2
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  9043c8:	dc10      	mov.n	a12, a1
  9043ca:	b41b      	addi.n	a11, a1, 4
  9043cc:	da30      	mov.n	a10, a3
  9043ce:	5bfcad        	call8	903684 <__adf_nbuf_peek_header>
	else {
		tmp_nbuf = hdr_buf;
	}
                
	adf_nbuf_peek_header(tmp_nbuf, &anbdata, &anblen);        
	pHTCHdr = (HTC_FRAME_HDR *)anbdata; 
  9043d1:	8511      	l32i.n	a5, a1, 4
	a_uint32_t anblen;
	HTC_FRAME_HDR *pHTCHdr;
	HTC_CONTEXT *pHTC = (HTC_CONTEXT *)context;
	adf_nbuf_t tmp_nbuf;
                
	if (hdr_buf == ADF_NBUF_NULL) {
  9043d3:	d730      	mov.n	a7, a3
	eid = pHTCHdr->EndpointID; 
    
	pEndpoint = &pHTC->Endpoints[eid];
	eidMask = 1 << eid;

	if (pHTCHdr->Flags & HTC_FLAGS_CREDIT_REDISTRIBUTION) {
  9043d5:	265001        	l8ui	a6, a5, 1
  9043d8:	7d6702        	bbci	a6, 29, 9043de <HTCMsgRecvHandler+0x1e>
  9043db:	60009d        	j	90447c <HTCMsgRecvHandler+0xbc>
	adf_nbuf_peek_header(tmp_nbuf, &anbdata, &anblen);        
	pHTCHdr = (HTC_FRAME_HDR *)anbdata; 
      
	totsz = adf_os_ntohs(pHTCHdr->PayloadLen); 
    
	eid = pHTCHdr->EndpointID; 
  9043de:	235000        	l8ui	a3, a5, 0
		 * Byte 0 */
		RedistributeCredit(tmp_nbuf, pHTCHdr->ControlBytes[0]);
		return;
	}

	if (pHTC->StateFlags & HTC_STATE_SETUP_COMPLETE) {
  9043e1:	254292        	l32i	a5, a4, 0x248
  9043e4:	03094f        	extui	a9, a3, 0, 16
  9043e7:	7f5711        	bbci	a5, 31, 9043fc <HTCMsgRecvHandler+0x3c>
  9043ea:	0f9511        	slli	a5, a9, 1
  9043ed:	a955      	add.n	a5, a5, a9
  9043ef:	0d5511        	slli	a5, a5, 3
  9043f2:	a545      	add.n	a5, a4, a5
		/* after setup we keep track of credit consumption to allow us to
		 * adjust thresholds to reduce credit dribbling */  
		pEndpoint->CreditsConsumed ++;
  9043f4:	2a5107        	l16ui	a10, a5, 14
  9043f7:	b1aa      	addi.n	a10, a10, 1
  9043f9:	2a5507        	s16i	a10, a5, 14
      
	totsz = adf_os_ntohs(pHTCHdr->PayloadLen); 
    
	eid = pHTCHdr->EndpointID; 
    
	pEndpoint = &pHTC->Endpoints[eid];
  9043fc:	0f9511        	slli	a5, a9, 1
  9043ff:	a955      	add.n	a5, a5, a9
  904401:	0d5511        	slli	a5, a5, 3
  904404:	b455      	addi.n	a5, a5, 4
	eidMask = 1 << eid;
  904406:	c091      	movi.n	a9, 1
      
	totsz = adf_os_ntohs(pHTCHdr->PayloadLen); 
    
	eid = pHTCHdr->EndpointID; 
    
	pEndpoint = &pHTC->Endpoints[eid];
  904408:	a545      	add.n	a5, a4, a5
  90440a:	9514      	s32i.n	a5, a1, 16
	/* from the design document, we put the endpoint into a "host-needs-credit" state
	 * when we receive a frame with the NEED_CREDIT_UPDATE flag set .
	 * if the host received credits through an opportunistic path, then it can
	 * issue a another frame with this bit cleared, this signals the target to clear
	 * the "host-needs-credit" state */    
	if (pHTCHdr->Flags & HTC_FLAGS_NEED_CREDIT_UPDATE) {
  90440c:	096b01        	and	a11, a6, a9
	totsz = adf_os_ntohs(pHTCHdr->PayloadLen); 
    
	eid = pHTCHdr->EndpointID; 
    
	pEndpoint = &pHTC->Endpoints[eid];
	eidMask = 1 << eid;
  90440f:	003104        	ssl	a3
  904412:	00951a        	sll	a5, a9
  904415:	2a4285        	l32i	a10, a4, 0x214
  904418:	009104        	ssl	a9
  90441b:	00361a        	sll	a6, a3
	/* from the design document, we put the endpoint into a "host-needs-credit" state
	 * when we receive a frame with the NEED_CREDIT_UPDATE flag set .
	 * if the host received credits through an opportunistic path, then it can
	 * issue a another frame with this bit cleared, this signals the target to clear
	 * the "host-needs-credit" state */    
	if (pHTCHdr->Flags & HTC_FLAGS_NEED_CREDIT_UPDATE) {
  90441e:	c9bb      	beqz.n	a11, 90443d <HTCMsgRecvHandler+0x7d>
		/* the host is running low (or is out) of credits on this
		 * endpoint, update mask */
		pHTC->EpHostNeedsCreditMap |= eidMask; 
  904420:	05aa02        	or	a10, a10, a5
  904423:	2a4685        	s32i	a10, a4, 0x214
		/* check and set new threshold since host has reached a low credit situation */
		CHECK_AND_ADJUST_CREDIT_THRESHOLD(pEndpoint);                          
  904426:	a36a      	add.n	a10, a6, a3
  904428:	0daa11        	slli	a10, a10, 3
  90442b:	aa4a      	add.n	a10, a4, a10
  90442d:	2aa108        	l16ui	a10, a10, 16
  904430:	7da71e        	bbci	a10, 29, 904452 <HTCMsgRecvHandler+0x92>
  904433:	8a14      	l32i.n	a10, a1, 16
  904435:	5bff7e        	call8	904230 <AdjustCreditThreshold>
  904438:	600016        	j	904452 <HTCMsgRecvHandler+0x92>
  90443b:	0000c7        	excw
	} else {
		/* clear the flag */
		pHTC->EpHostNeedsCreditMap &= ~(eidMask);       
  90443e:	cf05      	bnez.n	a0, 904477 <HTCMsgRecvHandler+0xb7>
  904440:	cc03      	bnez.n	a0, 904447 <HTCMsgRecvHandler+0x87>
  904442:	0caa01        	and	a10, a10, a12
  904445:	2a4685        	s32i	a10, a4, 0x214
		pEndpoint->CreditReturnThreshhold = 0; 
  904448:	a36a      	add.n	a10, a6, a3
  90444a:	0daa11        	slli	a10, a10, 3
  90444d:	aa4a      	add.n	a10, a4, a10
  90444f:	2ba506        	s16i	a11, a10, 12
	 *        as the result of parsing this message.  In either case, if there are
	 *        pending credits and the host needs them, a credit report will be sent either through 
	 *        the response message trailer or a NULL message through HTC_ReturnBuffers().
	 */       
        
	pEndpoint->pService->ProcessRecvMsg(eid, hdr_buf, buffer, pEndpoint->pService->ServiceCtx);
  904452:	a366      	add.n	a6, a6, a3
  904454:	0d6611        	slli	a6, a6, 3
 *         or NULL if there is not sufficient data to pull.
 */
static inline a_uint8_t *
adf_nbuf_pull_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_pull_head(buf, size);
  904457:	c0b8      	movi.n	a11, 8
  904459:	da70      	mov.n	a10, a7
  90445b:	064608        	add	a6, a4, a6
  90445e:	5bfbe4        	call8	9033f0 <__adf_nbuf_pull_head>
  904461:	8662      	l32i.n	a6, a6, 8
  904463:	8c15      	l32i.n	a12, a1, 20
  904465:	8d66      	l32i.n	a13, a6, 24
  904467:	8761      	l32i.n	a7, a6, 4
  904469:	db20      	mov.n	a11, a2
  90446b:	033a02        	or	a10, a3, a3
  90446e:	0b7000        	callx8	a7

	/* Calls to HTC_ReturnBuffers drives the endpoint credit reporting state machine. 
	 * We do not want to delay credits for too long in the event that the application is 
	 * holding onto buffers for excessive periods of time.  This gives us "some" better
	 * opportunities to send up credits. */
	HTCCheckAndSendCreditReport(pHTC, eidMask, pEndpoint, eid); 
  904471:	8c14      	l32i.n	a12, a1, 16
  904473:	dd30      	mov.n	a13, a3
  904475:	db50      	mov.n	a11, a5
  904477:	da40      	mov.n	a10, a4
  904479:	5bfe98        	call8	903edc <HTCCheckAndSendCreditReport>
  90447c:	d10f      	retw.n
	...

00904480 <RedistributeCredit>:
	pEndpoint->CreditReturnThreshhold = creditsOutstanding;
    
}

LOCAL void RedistributeCredit(adf_nbuf_t buf, int toPipeId)
{
  904480:	6c1004        	entry	a1, 32
  904483:	d10f      	retw.n
  904485:	000000        	ill

00904488 <WMIServiceConnect>:
                                 HTC_ENDPOINT_ID eid, 
                                 A_UINT8 *pDataIn, 
                                 int LengthIn,
                                 A_UINT8 *pDataOut,
                                 int *pLengthOut)
{
  904488:	6c1004        	entry	a1, 32
	WMI_SVC_CONTEXT *pWMI = (WMI_SVC_CONTEXT *)pService->ServiceCtx;
    
        /* save the eid to use */
	pWMI->ControlEp = eid;
  90448b:	8826      	l32i.n	a8, a2, 24
  90448d:	938a      	s32i.n	a3, a8, 40
	return HTC_SERVICE_SUCCESS;
}
  90448f:	c020      	movi.n	a2, 0
  904491:	d10f      	retw.n
	...

00904494 <_WMI_GetPendingEventsCount>:
    
	return pWMI;
}

static int _WMI_GetPendingEventsCount(wmi_handle_t handle)
{
  904494:	6c1004        	entry	a1, 32
	WMI_SVC_CONTEXT *pWMI = (WMI_SVC_CONTEXT *)handle;
	return pWMI->PendingEvents;
}
  904497:	8222      	l32i.n	a2, a2, 8
  904499:	d10f      	retw.n
	...

0090449c <_WMI_GetControlEp>:

static int  _WMI_GetControlEp(wmi_handle_t handle)
{
  90449c:	6c1004        	entry	a1, 32
	WMI_SVC_CONTEXT *pWMI = (WMI_SVC_CONTEXT *)handle;
	return pWMI->ControlEp;
}
  90449f:	822a      	l32i.n	a2, a2, 40
  9044a1:	d10f      	retw.n
	...

009044a4 <_WMI_RegisterDispatchTable>:

static void _WMI_RegisterDispatchTable(wmi_handle_t handle,
				       WMI_DISPATCH_TABLE *pDispatchTable)
{
  9044a4:	6c1004        	entry	a1, 32
	WMI_SVC_CONTEXT *pWMI = (WMI_SVC_CONTEXT *)handle;
    
	if (NULL == pWMI->pDispatchHead) {
  9044a7:	882b      	l32i.n	a8, a2, 44
  9044a9:	cc83      	bnez.n	a8, 9044b0 <_WMI_RegisterDispatchTable+0xc>
		pWMI->pDispatchHead = pDispatchTable;
  9044ab:	932b      	s32i.n	a3, a2, 44
  9044ad:	600003        	j	9044b4 <_WMI_RegisterDispatchTable+0x10>
		pWMI->pDispatchTail = pDispatchTable;        
	} else {
		/* link to the tail */
		pWMI->pDispatchTail->pNext = pDispatchTable;
  9044b0:	882c      	l32i.n	a8, a2, 48
  9044b2:	9380      	s32i.n	a3, a8, 0
		pWMI->pDispatchTail = pDispatchTable;        
  9044b4:	932c      	s32i.n	a3, a2, 48
  9044b6:	d10f      	retw.n

009044b8 <_WMI_Shutdown>:
	
	HTC_SendMsg(pWMI->HtcHandle, pWMI->ControlEp, pEvt);    
}

static void _WMI_Shutdown(wmi_handle_t handle)
{
  9044b8:	6c1004        	entry	a1, 32
  9044bb:	d10f      	retw.n
  9044bd:	000000        	ill

009044c0 <WMIRecvMessageHandler>:

#include "wmi_internal.h"

static void WMIRecvMessageHandler(HTC_ENDPOINT_ID EndPt, adf_nbuf_t hdr_buf,
				  adf_nbuf_t pHTCBuf, void *arg)
{
  9044c0:	6c1006        	entry	a1, 48
	int length;
	a_uint8_t *anbdata;
	a_uint32_t anblen;
	WMI_CMD_HDR *cmdHdr;
            
	adf_os_assert(hdr_buf == ADF_NBUF_NULL);
  9044c3:	c832      	beqz.n	a3, 9044c9 <WMIRecvMessageHandler+0x9>
  9044c5:	63fffc        	j	9044c5 <WMIRecvMessageHandler+0x5>
  9044c8:	00da40        	extui	a10, a0, 13, 1
 * @return The total length of this buf.
 */
static inline adf_os_size_t
adf_nbuf_len(adf_nbuf_t buf)
{
    return (__adf_nbuf_len(buf));
  9044cb:	5bfc66        	call8	903664 <__adf_nbuf_len>
  9044ce:	d3a0      	mov.n	a3, a10

	do {
		length = adf_nbuf_len(pHTCBuf);
		if (length < sizeof(WMI_CMD_HDR)) {
  9044d0:	6ea459        	bltui	a10, 4, 90452d <WMIRecvMessageHandler+0x6d>
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  9044d3:	dc10      	mov.n	a12, a1
  9044d5:	b41b      	addi.n	a11, a1, 4
  9044d7:	da40      	mov.n	a10, a4
  9044d9:	5bfc6a        	call8	903684 <__adf_nbuf_peek_header>
		adf_nbuf_peek_header(pHTCBuf, &anbdata, &anblen);
        
		pCurrentTable = pWMI->pDispatchHead;
		length = length - sizeof(WMI_CMD_HDR);
        
		cmdHdr = (WMI_CMD_HDR *)anbdata;
  9044dc:	8d11      	l32i.n	a13, a1, 4
		}

		adf_nbuf_peek_header(pHTCBuf, &anbdata, &anblen);
        
		pCurrentTable = pWMI->pDispatchHead;
		length = length - sizeof(WMI_CMD_HDR);
  9044de:	2e3cfc        	addi	a14, a3, -4
        
		cmdHdr = (WMI_CMD_HDR *)anbdata;
		cmd = adf_os_ntohs(cmdHdr->commandId);
  9044e1:	2bd000        	l8ui	a11, a13, 0
  9044e4:	23d001        	l8ui	a3, a13, 1
		seq = adf_os_ntohs(cmdHdr->seqNo);
  9044e7:	2cd002        	l8ui	a12, a13, 2
        
		pCurrentTable = pWMI->pDispatchHead;
		length = length - sizeof(WMI_CMD_HDR);
        
		cmdHdr = (WMI_CMD_HDR *)anbdata;
		cmd = adf_os_ntohs(cmdHdr->commandId);
  9044ea:	08bb11        	slli	a11, a11, 8
  9044ed:	0b3b02        	or	a11, a3, a11
		seq = adf_os_ntohs(cmdHdr->seqNo);
  9044f0:	23d003        	l8ui	a3, a13, 3
  9044f3:	08cc11        	slli	a12, a12, 8
			break;    
		}

		adf_nbuf_peek_header(pHTCBuf, &anbdata, &anblen);
        
		pCurrentTable = pWMI->pDispatchHead;
  9044f6:	895b      	l32i.n	a9, a5, 44
		length = length - sizeof(WMI_CMD_HDR);
        
		cmdHdr = (WMI_CMD_HDR *)anbdata;
		cmd = adf_os_ntohs(cmdHdr->commandId);
		seq = adf_os_ntohs(cmdHdr->seqNo);
  9044f8:	0c3c02        	or	a12, a3, a12
        
		pCmdBuffer = anbdata + sizeof(WMI_CMD_HDR); 
  9044fb:	b4dd      	addi.n	a13, a13, 4
		pCmdHandler = NULL;
        
		while (pCurrentTable != NULL) {
  9044fd:	600029        	j	90452a <WMIRecvMessageHandler+0x6a>
            
			pContext = pCurrentTable->pContext;
			pCurrentEntry = pCurrentTable->pTable;
  904500:	8893      	l32i.n	a8, a9, 12
        
			/* scan table entries */
			for (i = 0; i < pCurrentTable->NumberOfEntries; i++, pCurrentEntry++) {
  904502:	8392      	l32i.n	a3, a9, 8
  904504:	c0a0      	movi.n	a10, 0
  904506:	600016        	j	904520 <WMIRecvMessageHandler+0x60>
				if (pCurrentEntry->CmdID == cmd) {
  904509:	2f8102        	l16ui	a15, a8, 4
  90450c:	7bf90c        	bne	a15, a11, 90451c <WMIRecvMessageHandler+0x5c>
					/* found a match */
					pCmdHandler = pCurrentEntry->pCmdHandler;
  90450f:	8f80      	l32i.n	a15, a8, 0
        
					/* optionally check length */
					if ((pCurrentEntry->CheckLength != 0) &&
  904511:	288103        	l16ui	a8, a8, 6
  904514:	c88e      	beqz.n	a8, 904526 <WMIRecvMessageHandler+0x66>
  904516:	78e20e        	blt	a14, a8, 904528 <WMIRecvMessageHandler+0x68>
  904519:	600009        	j	904526 <WMIRecvMessageHandler+0x66>
            
			pContext = pCurrentTable->pContext;
			pCurrentEntry = pCurrentTable->pTable;
        
			/* scan table entries */
			for (i = 0; i < pCurrentTable->NumberOfEntries; i++, pCurrentEntry++) {
  90451c:	b1aa      	addi.n	a10, a10, 1
  90451e:	b888      	addi.n	a8, a8, 8
  904520:	73a2e5        	blt	a10, a3, 904509 <WMIRecvMessageHandler+0x49>
  904523:	600001        	j	904528 <WMIRecvMessageHandler+0x68>
					/* end search */                
					break;    
				}                        
			} 
            
			if (pCmdHandler != NULL) {
  904526:	cdf4      	bnez.n	a15, 90453e <WMIRecvMessageHandler+0x7e>
				/* found a handler */
				break;
			}
                
			/* scan next table */
			pCurrentTable = pCurrentTable->pNext;
  904528:	8990      	l32i.n	a9, a9, 0
		seq = adf_os_ntohs(cmdHdr->seqNo);
        
		pCmdBuffer = anbdata + sizeof(WMI_CMD_HDR); 
		pCmdHandler = NULL;
        
		while (pCurrentTable != NULL) {
  90452a:	659fd2        	bnez	a9, 904500 <WMIRecvMessageHandler+0x40>
        /* Invalidate the buffer (including HTC header). Note : we only need to invalidate up to the portion
	 * that was used (cache invalidate will also round up to the nearest cache line).  
	 * The rest of the buffer should still be coherent.
	 * */

	HTC_ReturnBuffers(pWMI->HtcHandle, EndPt, pHTCBuf);         
  90452d:	13716e        	l32r	a3, 8e0ae8 <_bss_end+0x3d32e0>
  904530:	8a50      	l32i.n	a10, a5, 0
  904532:	233287        	l32i	a3, a3, 0x21c
  904535:	dc40      	mov.n	a12, a4
  904537:	db20      	mov.n	a11, a2
  904539:	0b3000        	callx8	a3
}
  90453c:	d10f      	retw.n
		}
            
		/* if we get here, we have a command handler to dispatch */
                
		/* call dispatch function */
		pCmdHandler(pContext, cmd, seq, pCmdBuffer, length);
  90453e:	8a91      	l32i.n	a10, a9, 4
  904540:	0bf000        	callx8	a15
  904543:	63ffe6        	j	90452d <WMIRecvMessageHandler+0x6d>
	...

00904548 <_WMI_SendCompleteHandler>:
	HTC_ReturnBuffers(pWMI->HtcHandle, EndPt, pHTCBuf);         
}

/* send completion handler when any HTC buffers are returned */
static void _WMI_SendCompleteHandler(HTC_ENDPOINT_ID Endpt, adf_nbuf_t pHTCBuf, void *arg)
{
  904548:	6c1004        	entry	a1, 32
 * @return data pointer to typecast into your priv structure
 */
static inline a_uint8_t *
adf_nbuf_get_priv(adf_nbuf_t buf)
{
    return (__adf_nbuf_get_priv(buf));
  90454b:	da30      	mov.n	a10, a3
  90454d:	5bfbc3        	call8	90345c <__adf_nbuf_get_priv>
	WMI_BUF_CONTEXT *ctx;
	BUF_POOL_ID poolId;
    
	ctx = (WMI_BUF_CONTEXT *)adf_nbuf_get_priv(pHTCBuf);
        
	if ( ctx->EventClass == WMI_EVT_CLASS_CMD_EVENT ) {
  904550:	8ba1      	l32i.n	a11, a10, 4
		poolId = POOL_ID_WMI_SVC_EVENT;
	} else {
		poolId = POOL_ID_WMI_SVC_CMD_REPLY;
  904552:	c091      	movi.n	a9, 1
  904554:	c080      	movi.n	a8, 0
  904556:	0b9838        	moveqz	a8, a9, a11
  904559:	db80      	mov.n	a11, a8
	}
        
	BUF_Pool_free_buf(pWMI->PoolHandle, poolId, pHTCBuf);
  90455b:	18716e        	l32r	a8, 8e0b14 <_bss_end+0x3d330c>
  90455e:	8a41      	l32i.n	a10, a4, 4
  904560:	2882a3        	l32i	a8, a8, 0x28c
  904563:	dc30      	mov.n	a12, a3
  904565:	a9bb      	add.n	a11, a11, a9
  904567:	0b8000        	callx8	a8
  90456a:	d10f      	retw.n

0090456c <_WMI_AllocEvent>:
	}
}

static adf_nbuf_t _WMI_AllocEvent(wmi_handle_t handle, WMI_EVT_CLASS EventClass,
				  int Length)
{     
  90456c:	6c1004        	entry	a1, 32
		poolId = POOL_ID_WMI_SVC_EVENT;
	} else {
		poolId = POOL_ID_WMI_SVC_CMD_REPLY;
	}
    
	buf = BUF_Pool_alloc_buf(pWMI->PoolHandle, 
  90456f:	18716e        	l32r	a8, 8e0b28 <_bss_end+0x3d3320>
	WMI_BUF_CONTEXT *ctx;
    
	if ( EventClass == WMI_EVT_CLASS_CMD_EVENT ) {
		poolId = POOL_ID_WMI_SVC_EVENT;
	} else {
		poolId = POOL_ID_WMI_SVC_CMD_REPLY;
  904572:	c0b0      	movi.n	a11, 0
	}
    
	buf = BUF_Pool_alloc_buf(pWMI->PoolHandle, 
  904574:	2582a1        	l32i	a5, a8, 0x284
  904577:	8a20      	l32i.n	a10, a2, 0
  904579:	28828a        	l32i	a8, a8, 0x228
	WMI_BUF_CONTEXT *ctx;
    
	if ( EventClass == WMI_EVT_CLASS_CMD_EVENT ) {
		poolId = POOL_ID_WMI_SVC_EVENT;
	} else {
		poolId = POOL_ID_WMI_SVC_CMD_REPLY;
  90457c:	c041      	movi.n	a4, 1
  90457e:	03b439        	movnez	a4, a11, a3
	}
    
	buf = BUF_Pool_alloc_buf(pWMI->PoolHandle, 
  904581:	8621      	l32i.n	a6, a2, 4
	WMI_BUF_CONTEXT *ctx;
    
	if ( EventClass == WMI_EVT_CLASS_CMD_EVENT ) {
		poolId = POOL_ID_WMI_SVC_EVENT;
	} else {
		poolId = POOL_ID_WMI_SVC_CMD_REPLY;
  904583:	b144      	addi.n	a4, a4, 1
	}
    
	buf = BUF_Pool_alloc_buf(pWMI->PoolHandle, 
  904585:	0b8000        	callx8	a8
  904588:	b4ac      	addi.n	a12, a10, 4
  90458a:	db40      	mov.n	a11, a4
  90458c:	da60      	mov.n	a10, a6
  90458e:	0b5000        	callx8	a5
  904591:	d2a0      	mov.n	a2, a10
				 poolId, 
				 sizeof(WMI_CMD_HDR) + HTC_GetReservedHeadroom(pWMI->HtcHandle));
     
	if ( buf != NULL ) {
  904593:	c8a3      	beqz.n	a10, 90459a <_WMI_AllocEvent+0x2e>
  904595:	5bfbb1        	call8	90345c <__adf_nbuf_get_priv>
		ctx = (WMI_BUF_CONTEXT *)adf_nbuf_get_priv(buf);
		ctx->EventClass = EventClass;
  904598:	93a1      	s32i.n	a3, a10, 4
	}
	return buf;
}
  90459a:	d10f      	retw.n

0090459c <_WMI_SendEvent>:

static void _WMI_SendEvent(wmi_handle_t handle, adf_nbuf_t pEvt, 
                           A_UINT16 EventId, A_UINT16 SeqNo, int Length)
{
  90459c:	6c1004        	entry	a1, 32
 *         or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_push_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_push_head(buf, size);
  90459f:	2b0a04        	movi	a11, 4
  9045a2:	033a02        	or	a10, a3, a3
  9045a5:	5bfb87        	call8	9033c4 <__adf_nbuf_push_head>
  9045a8:	04044f        	extui	a4, a4, 0, 16
  9045ab:	05054f        	extui	a5, a5, 0, 16
	WMI_SVC_CONTEXT *pWMI = (WMI_SVC_CONTEXT *)handle;
	A_UINT8 *pBuffer;
        
	pBuffer = adf_nbuf_push_head(pEvt, sizeof(WMI_CMD_HDR));
	A_SET_UINT16_FIELD(pBuffer, WMI_CMD_HDR, commandId, adf_os_htons(EventId));        
  9045ae:	24a401        	s8i	a4, a10, 1
  9045b1:	048814        	srli	a8, a4, 8
	A_SET_UINT16_FIELD(pBuffer, WMI_CMD_HDR, seqNo, adf_os_htons(SeqNo));
  9045b4:	058414        	srli	a4, a5, 8
  9045b7:	24a402        	s8i	a4, a10, 2
	
	HTC_SendMsg(pWMI->HtcHandle, pWMI->ControlEp, pEvt);    
  9045ba:	14716e        	l32r	a4, 8e0b74 <_bss_end+0x3d336c>
{
	WMI_SVC_CONTEXT *pWMI = (WMI_SVC_CONTEXT *)handle;
	A_UINT8 *pBuffer;
        
	pBuffer = adf_nbuf_push_head(pEvt, sizeof(WMI_CMD_HDR));
	A_SET_UINT16_FIELD(pBuffer, WMI_CMD_HDR, commandId, adf_os_htons(EventId));        
  9045bd:	28a400        	s8i	a8, a10, 0
	A_SET_UINT16_FIELD(pBuffer, WMI_CMD_HDR, seqNo, adf_os_htons(SeqNo));
  9045c0:	25a403        	s8i	a5, a10, 3
	
	HTC_SendMsg(pWMI->HtcHandle, pWMI->ControlEp, pEvt);    
  9045c3:	244289        	l32i	a4, a4, 0x224
  9045c6:	8b2a      	l32i.n	a11, a2, 40
  9045c8:	8a20      	l32i.n	a10, a2, 0
  9045ca:	033c02        	or	a12, a3, a3
  9045cd:	0b4000        	callx8	a4
  9045d0:	d10f      	retw.n
	...

009045d4 <_WMI_Init>:
}

/**************  public APIS ********************************************/
    
static wmi_handle_t _WMI_Init(WMI_SVC_CONFIG *pWmiConfig)
{
  9045d4:	6c1004        	entry	a1, 32
#include "Magpie_api.h"

static inline void *	__adf_os_mem_alloc(adf_os_size_t size)
{
//    return (malloc(size,M_DEVBUF,M_DONTWAIT | M_ZERO));
    return A_ALLOCRAM(size);
  9045d7:	13716e        	l32r	a3, 8e0b90 <_bss_end+0x3d3388>
  9045da:	d420      	mov.n	a4, a2
  9045dc:	223252        	l32i	a2, a3, 0x148
  9045df:	c3b8      	movi.n	a11, 56
  9045e1:	c0a0      	movi.n	a10, 0
  9045e3:	0b2000        	callx8	a2
  9045e6:	d2a0      	mov.n	a2, a10
	WMI_SVC_CONTEXT *pWMI = NULL;
	int eventSize = WMI_SVC_MAX_BUFFERED_EVENT_SIZE + sizeof(WMI_CMD_HDR) + HTC_HDR_SZ;
    
	pWMI = (WMI_SVC_CONTEXT *)adf_os_mem_alloc(sizeof(WMI_SVC_CONTEXT));
	if (pWMI == NULL) {
  9045e8:	64a055        	beqz	a10, 904641 <_WMI_Init+0x6d>
		return NULL;    
	}
        
	pWMI->pDispatchHead = NULL;
  9045eb:	c080      	movi.n	a8, 0
  9045ed:	98ab      	s32i.n	a8, a10, 44
	pWMI->PoolHandle = pWmiConfig->PoolHandle;
	pWMI->HtcHandle = pWmiConfig->HtcHandle;    
  9045ef:	8840      	l32i.n	a8, a4, 0
	if (pWMI == NULL) {
		return NULL;    
	}
        
	pWMI->pDispatchHead = NULL;
	pWMI->PoolHandle = pWmiConfig->PoolHandle;
  9045f1:	8a41      	l32i.n	a10, a4, 4
	pWMI->HtcHandle = pWmiConfig->HtcHandle;    
                                         
	BUF_Pool_create_pool(pWmiConfig->PoolHandle, POOL_ID_WMI_SVC_CMD_REPLY, 
  9045f3:	8c42      	l32i.n	a12, a4, 8
		return NULL;    
	}
        
	pWMI->pDispatchHead = NULL;
	pWMI->PoolHandle = pWmiConfig->PoolHandle;
	pWMI->HtcHandle = pWmiConfig->HtcHandle;    
  9045f5:	9820      	s32i.n	a8, a2, 0
                                         
	BUF_Pool_create_pool(pWmiConfig->PoolHandle, POOL_ID_WMI_SVC_CMD_REPLY, 
  9045f7:	2832a0        	l32i	a8, a3, 0x280
	if (pWMI == NULL) {
		return NULL;    
	}
        
	pWMI->pDispatchHead = NULL;
	pWMI->PoolHandle = pWmiConfig->PoolHandle;
  9045fa:	9a21      	s32i.n	a10, a2, 4
	pWMI->HtcHandle = pWmiConfig->HtcHandle;    
                                         
	BUF_Pool_create_pool(pWmiConfig->PoolHandle, POOL_ID_WMI_SVC_CMD_REPLY, 
  9045fc:	2d0a70        	movi	a13, 112
  9045ff:	2b0a01        	movi	a11, 1
  904602:	0b8000        	callx8	a8
			     pWmiConfig->MaxCmdReplyEvts, eventSize);
        
	BUF_Pool_create_pool(pWmiConfig->PoolHandle, POOL_ID_WMI_SVC_EVENT, 
  904605:	2832a0        	l32i	a8, a3, 0x280
  904608:	8a41      	l32i.n	a10, a4, 4
  90460a:	8c43      	l32i.n	a12, a4, 12
  90460c:	c0b2      	movi.n	a11, 2
  90460e:	2d0a70        	movi	a13, 112
  904611:	0b8000        	callx8	a8
            
	/* NOTE: since RAM allocation is zero-initialized, there is nothing to do for the 
	 * direct event pool */
     
        /* register the WMI control service */
	pWMI->WMIControlService.ProcessRecvMsg = A_INDIR(wmi_svc_api._WMI_RecvMessageHandler);
  904614:	283298        	l32i	a8, a3, 0x260
         * in size.  Any WMI event that supplies a data buffer must insure that the space in the buffer
         * is at least this size. */
	pWMI->WMIControlService.TrailerSpcCheckLimit = WMI_SVC_MAX_BUFFERED_EVENT_SIZE; 
	pWMI->WMIControlService.ServiceID = WMI_CONTROL_SVC;
	pWMI->WMIControlService.ServiceCtx = pWMI;
	HTC_RegisterService(pWmiConfig->HtcHandle, &pWMI->WMIControlService);
  904617:	8a40      	l32i.n	a10, a4, 0
            
	/* NOTE: since RAM allocation is zero-initialized, there is nothing to do for the 
	 * direct event pool */
     
        /* register the WMI control service */
	pWMI->WMIControlService.ProcessRecvMsg = A_INDIR(wmi_svc_api._WMI_RecvMessageHandler);
  904619:	9824      	s32i.n	a8, a2, 16
	pWMI->WMIControlService.ProcessSendBufferComplete = A_INDIR(wmi_svc_api._WMI_SendCompleteHandler);
  90461b:	283295        	l32i	a8, a3, 0x254
         * in size.  Any WMI event that supplies a data buffer must insure that the space in the buffer
         * is at least this size. */
	pWMI->WMIControlService.TrailerSpcCheckLimit = WMI_SVC_MAX_BUFFERED_EVENT_SIZE; 
	pWMI->WMIControlService.ServiceID = WMI_CONTROL_SVC;
	pWMI->WMIControlService.ServiceCtx = pWMI;
	HTC_RegisterService(pWmiConfig->HtcHandle, &pWMI->WMIControlService);
  90461e:	bc2b      	addi.n	a11, a2, 12
	/* NOTE: since RAM allocation is zero-initialized, there is nothing to do for the 
	 * direct event pool */
     
        /* register the WMI control service */
	pWMI->WMIControlService.ProcessRecvMsg = A_INDIR(wmi_svc_api._WMI_RecvMessageHandler);
	pWMI->WMIControlService.ProcessSendBufferComplete = A_INDIR(wmi_svc_api._WMI_SendCompleteHandler);
  904620:	9825      	s32i.n	a8, a2, 20
	pWMI->WMIControlService.ProcessConnect = A_INDIR(wmi_svc_api._WMI_ServiceConnect);
  904622:	283299        	l32i	a8, a3, 0x264
         * in size.  Any WMI event that supplies a data buffer must insure that the space in the buffer
         * is at least this size. */
	pWMI->WMIControlService.TrailerSpcCheckLimit = WMI_SVC_MAX_BUFFERED_EVENT_SIZE; 
	pWMI->WMIControlService.ServiceID = WMI_CONTROL_SVC;
	pWMI->WMIControlService.ServiceCtx = pWMI;
	HTC_RegisterService(pWmiConfig->HtcHandle, &pWMI->WMIControlService);
  904625:	233285        	l32i	a3, a3, 0x214
	 * direct event pool */
     
        /* register the WMI control service */
	pWMI->WMIControlService.ProcessRecvMsg = A_INDIR(wmi_svc_api._WMI_RecvMessageHandler);
	pWMI->WMIControlService.ProcessSendBufferComplete = A_INDIR(wmi_svc_api._WMI_SendCompleteHandler);
	pWMI->WMIControlService.ProcessConnect = A_INDIR(wmi_svc_api._WMI_ServiceConnect);
  904628:	9826      	s32i.n	a8, a2, 24
	pWMI->WMIControlService.MaxSvcMsgSize = WMI_SVC_MSG_SIZE + sizeof(WMI_CMD_HDR);
  90462a:	286a04        	movi	a8, 0x604
  90462d:	282510        	s16i	a8, a2, 32
        /* all buffers that are sent through the control endpoint are at least WMI_SVC_MAX_BUFFERED_EVENT_SIZE 
         * in size.  Any WMI event that supplies a data buffer must insure that the space in the buffer
         * is at least this size. */
	pWMI->WMIControlService.TrailerSpcCheckLimit = WMI_SVC_MAX_BUFFERED_EVENT_SIZE; 
  904630:	280a64        	movi	a8, 100
  904633:	282511        	s16i	a8, a2, 34
	pWMI->WMIControlService.ServiceID = WMI_CONTROL_SVC;
  904636:	281a00        	movi	a8, 0x100
  904639:	28250e        	s16i	a8, a2, 28
	pWMI->WMIControlService.ServiceCtx = pWMI;
  90463c:	9229      	s32i.n	a2, a2, 36
	HTC_RegisterService(pWmiConfig->HtcHandle, &pWMI->WMIControlService);
  90463e:	0b3000        	callx8	a3
    
	return pWMI;
}
  904641:	d10f      	retw.n
	...

00904644 <WMI_service_module_install>:

	adf_os_mem_free(pWMI);
}

void WMI_service_module_install(WMI_SVC_APIS *pTbl)
{
  904644:	6c1004        	entry	a1, 32
	pTbl->_WMI_Init                     = _WMI_Init;
  904647:	1871e5        	l32r	a8, 8e0ddc <_bss_end+0x3d35d4>
  90464a:	9820      	s32i.n	a8, a2, 0
	pTbl->_WMI_RegisterDispatchTable    = _WMI_RegisterDispatchTable;
  90464c:	1871e6        	l32r	a8, 8e0de4 <_bss_end+0x3d35dc>
  90464f:	9821      	s32i.n	a8, a2, 4
	pTbl->_WMI_AllocEvent               = _WMI_AllocEvent;
  904651:	1871e7        	l32r	a8, 8e0df0 <_bss_end+0x3d35e8>
  904654:	9822      	s32i.n	a8, a2, 8
	pTbl->_WMI_SendEvent                = _WMI_SendEvent;
  904656:	1871e8        	l32r	a8, 8e0df8 <_bss_end+0x3d35f0>
  904659:	9823      	s32i.n	a8, a2, 12
	pTbl->_WMI_SendCompleteHandler      = _WMI_SendCompleteHandler;
  90465b:	1871e9        	l32r	a8, 8e0e00 <_bss_end+0x3d35f8>
  90465e:	9825      	s32i.n	a8, a2, 20
	pTbl->_WMI_GetPendingEventsCount    = _WMI_GetPendingEventsCount;
  904660:	1871ea        	l32r	a8, 8e0e08 <_bss_end+0x3d3600>
  904663:	9824      	s32i.n	a8, a2, 16
	pTbl->_WMI_GetControlEp             = _WMI_GetControlEp;
  904665:	1871eb        	l32r	a8, 8e0e14 <_bss_end+0x3d360c>
  904668:	9826      	s32i.n	a8, a2, 24
	pTbl->_WMI_Shutdown                 = _WMI_Shutdown;
  90466a:	1871ec        	l32r	a8, 8e0e1c <_bss_end+0x3d3614>
  90466d:	9827      	s32i.n	a8, a2, 28
	pTbl->_WMI_RecvMessageHandler       = WMIRecvMessageHandler;
  90466f:	1871ed        	l32r	a8, 8e0e24 <_bss_end+0x3d361c>
  904672:	9828      	s32i.n	a8, a2, 32
	pTbl->_WMI_ServiceConnect           = WMIServiceConnect;
  904674:	1871ee        	l32r	a8, 8e0e2c <_bss_end+0x3d3624>
  904677:	9829      	s32i.n	a8, a2, 36
  904679:	d10f      	retw.n
	...

0090467c <_HIFusb_get_max_msg_len_patch>:

/*
 * -- support more than 64 bytes command on ep4 -- 
 */
int _HIFusb_get_max_msg_len_patch(hif_handle_t handle, int pipe)
{
  90467c:	6c1004        	entry	a1, 32
    switch(pipe) {
  90467f:	233cfd        	addi	a3, a3, -3
        case HIF_USB_PIPE_INTERRUPT:
        case HIF_USB_PIPE_COMMAND:
            return 512;
            
        default:
            return 1600;
  904682:	226a40        	movi	a2, 0x640
/*
 * -- support more than 64 bytes command on ep4 -- 
 */
int _HIFusb_get_max_msg_len_patch(hif_handle_t handle, int pipe)
{
    switch(pipe) {
  904685:	6f3202        	bgeui	a3, 2, 90468b <_HIFusb_get_max_msg_len_patch+0xf>
        case HIF_USB_PIPE_INTERRUPT:
        case HIF_USB_PIPE_COMMAND:
            return 512;
  904688:	222a00        	movi	a2, 0x200
            
        default:
            return 1600;
    }
}
  90468b:	d10f      	retw.n
  90468d:	000000        	ill

00904690 <_HIFusb_isr_handler_patch>:

/*
 * -- move the usb_task to here --
 */
void _HIFusb_isr_handler_patch(hif_handle_t h)
{
  904690:	6c1004        	entry	a1, 32
    A_USB_FW_TASK();
  904693:	18716e        	l32r	a8, 8e0c4c <_bss_end+0x3d3444>
  904696:	28821d        	l32i	a8, a8, 116
  904699:	0b8000        	callx8	a8

    _HIFusb_isr_handler(h);
  90469c:	da20      	mov.n	a10, a2
  90469e:	5b792e        	call8	8e2b58 <_HIFusb_isr_handler>
  9046a1:	d10f      	retw.n
	...

009046a4 <io8_rmw>:
	*(volatile uint32_t *) addr = b;
}

static inline void io8_rmw(volatile uint32_t addr,
			    const uint8_t set, const uint8_t clr)
{
  9046a4:	6c1006        	entry	a1, 48
  9046a7:	0c0200        	memw
  9046aa:	9210      	s32i.n	a2, a1, 0
	uint8_t val;

	val = ioread8(addr);
  9046ac:	0c0200        	memw
  9046af:	8810      	l32i.n	a8, a1, 0

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  9046b1:	298000        	l8ui	a9, a8, 0
			    const uint8_t set, const uint8_t clr)
{
	uint8_t val;

	val = ioread8(addr);
	val &= ~clr;
  9046b4:	c78f      	movi.n	a8, -1
  9046b6:	048403        	xor	a4, a8, a4

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  9046b9:	090947        	extui	a9, a9, 0, 8
			    const uint8_t set, const uint8_t clr)
{
	uint8_t val;

	val = ioread8(addr);
	val &= ~clr;
  9046bc:	094401        	and	a4, a4, a9
	val |= set;
	iowrite8(addr, val);
  9046bf:	0c0200        	memw
  9046c2:	8810      	l32i.n	a8, a1, 0
{
	uint8_t val;

	val = ioread8(addr);
	val &= ~clr;
	val |= set;
  9046c4:	034402        	or	a4, a4, a3
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  9046c7:	0c0200        	memw
  9046ca:	248400        	s8i	a4, a8, 0
  9046cd:	d10f      	retw.n
	...

009046d0 <io32_rmw$constprop$0>:
	val &= ~clr;
	val |= set;
	iowrite8(addr, val);
}

static inline void io32_rmw(volatile uint32_t addr,
  9046d0:	6c1006        	entry	a1, 48
  9046d3:	0c0200        	memw
  9046d6:	9210      	s32i.n	a2, a1, 0
			    const uint32_t set, const uint32_t clr)
{
	uint32_t val;

	val = ioread32(addr);
  9046d8:	0c0200        	memw
  9046db:	8810      	l32i.n	a8, a1, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  9046dd:	0c0200        	memw
  9046e0:	8880      	l32i.n	a8, a8, 0
{
	uint32_t val;

	val = ioread32(addr);
	val &= ~clr;
	val |= set;
  9046e2:	038302        	or	a3, a8, a3
	iowrite32(addr, val);
  9046e5:	0c0200        	memw
  9046e8:	8810      	l32i.n	a8, a1, 0
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  9046ea:	0c0200        	memw
  9046ed:	9380      	s32i.n	a3, a8, 0
  9046ef:	d10f      	retw.n
  9046f1:	000000        	ill

009046f4 <_fw_usb_suspend_reboot>:
#if SYSTEM_MODULE_USB

#define CHECK_SOF_LOOP_CNT    50

void _fw_usb_suspend_reboot()
{
  9046f4:	6c1008        	entry	a1, 64
	volatile uint32_t gpio_in = 0;
  9046f7:	c020      	movi.n	a2, 0
  9046f9:	0c0200        	memw
  9046fc:	9214      	s32i.n	a2, a1, 16
	volatile uint32_t pupd = 0;
  9046fe:	0c0200        	memw
  904701:	9213      	s32i.n	a2, a1, 12
	volatile uint32_t t = 0;
  904703:	0c0200        	memw
  904706:	9212      	s32i.n	a2, a1, 8
	volatile uint32_t sof_no=0,sof_no_new=0;
	/* Set GO_TO_SUSPEND bit to USB main control register */
	io8_clr_usb(ZM_INTR_SOURCE_7_OFFSET, BIT2);
  904708:	1a71ef        	l32r	a10, 8e0ec4 <_bss_end+0x3d36bc>
  90470b:	c0c4      	movi.n	a12, 4
  90470d:	db20      	mov.n	a11, a2
void _fw_usb_suspend_reboot()
{
	volatile uint32_t gpio_in = 0;
	volatile uint32_t pupd = 0;
	volatile uint32_t t = 0;
	volatile uint32_t sof_no=0,sof_no_new=0;
  90470f:	0c0200        	memw
  904712:	9211      	s32i.n	a2, a1, 4
  904714:	0c0200        	memw
  904717:	9210      	s32i.n	a2, a1, 0
	/* Set GO_TO_SUSPEND bit to USB main control register */
	io8_clr_usb(ZM_INTR_SOURCE_7_OFFSET, BIT2);
  904719:	5bffe2        	call8	9046a4 <io8_rmw>
	A_PRINTF("!USB suspend\n\r");
  90471c:	13716e        	l32r	a3, 8e0cd4 <_bss_end+0x3d34cc>
  90471f:	1a71f0        	l32r	a10, 8e0ee0 <_bss_end+0x3d36d8>
  904722:	243212        	l32i	a4, a3, 72
  904725:	0b4000        	callx8	a4
  904728:	18717b        	l32r	a8, 8e0d14 <_bss_end+0x3d350c>
  90472b:	147172        	l32r	a4, 8e0cf4 <_bss_end+0x3d34ec>
  90472e:	0c0200        	memw
  904731:	9840      	s32i.n	a8, a4, 0
#elif defined(PROJECT_K2)
	iowrite32(MAGPIE_REG_RST_STATUS_ADDR, SUS_MAGIC_PATTERN);
#endif /* #if defined(PROJECT_MAGPIE) */

	/* Reset USB FIFO */
	A_USB_RESET_FIFO();
  904733:	243229        	l32i	a4, a3, 164
  904736:	0b4000        	callx8	a4

	/* Turn off power */
	A_USB_POWER_OFF();
  904739:	243228        	l32i	a4, a3, 160
  90473c:	0b4000        	callx8	a4

	DEBUG_SYSTEM_STATE = (DEBUG_SYSTEM_STATE&(~0xffff)) | 0x1000;
  90473f:	14716b        	l32r	a4, 8e0cec <_bss_end+0x3d34e4>
  904742:	1971f1        	l32r	a9, 8e0f08 <_bss_end+0x3d3700>
  904745:	0c0200        	memw
  904748:	8840      	l32i.n	a8, a4, 0
  90474a:	098801        	and	a8, a8, a9
  90474d:	1971f2        	l32r	a9, 8e0f18 <_bss_end+0x3d3710>
  904750:	098802        	or	a8, a8, a9
  904753:	0c0200        	memw
  904756:	9840      	s32i.n	a8, a4, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  904758:	1471f3        	l32r	a4, 8e0f24 <_bss_end+0x3d371c>
  90475b:	0c0200        	memw
  90475e:	8840      	l32i.n	a8, a4, 0
	/* disable SPI */
	spi = ioread32(0x50040);
	iowrite32(0x50040, spi & ~BIT8);
#endif
	/* set all GPIO to input */
	gpio_in = ioread32(0x1000404c);
  904760:	0c0200        	memw
  904763:	9814      	s32i.n	a8, a1, 16
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  904765:	0c0200        	memw
  904768:	9240      	s32i.n	a2, a4, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90476a:	1471f4        	l32r	a4, 8e0f3c <_bss_end+0x3d3734>
  90476d:	0c0200        	memw
  904770:	8840      	l32i.n	a8, a4, 0
	iowrite32(0x1000404c, 0x0);

	/* set PU/PD for all GPIO except two UART pins */
	pupd = ioread32(0x10004088);
  904772:	0c0200        	memw
  904775:	9813      	s32i.n	a8, a1, 12
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  904777:	1871f5        	l32r	a8, 8e0f4c <_bss_end+0x3d3744>
  90477a:	0c0200        	memw
  90477d:	9840      	s32i.n	a8, a4, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90477f:	1471f6        	l32r	a4, 8e0f58 <_bss_end+0x3d3750>
  904782:	0c0200        	memw
  904785:	8440      	l32i.n	a4, a4, 0
	iowrite32(0x10004088, 0xA982AA6A);

	sof_no = ioread32(0x10004);
  904787:	0c0200        	memw
  90478a:	9411      	s32i.n	a4, a1, 4
	for (t = 0; t < CHECK_SOF_LOOP_CNT; t++)
  90478c:	0c0200        	memw
  90478f:	9212      	s32i.n	a2, a1, 8
  904791:	c341      	movi.n	a4, 49
  904793:	60004f        	j	9047e6 <_fw_usb_suspend_reboot+0xf2>
  904796:	000022        	excw
	{
		A_DELAY_USECS(1000);    /* delay 1ms */
  904799:	323a2a        	excw
  90479c:	3ae80b        	excw
  90479f:	200012        	l8ui	a0, a0, 18
  9047a2:	71f60c        	bbci	a15, 1, 9047b2 <_fw_usb_suspend_reboot+0xbe>
  9047a5:	020082        	excw
  9047a8:	200c02        	addi	a0, a0, 2
		sof_no_new = ioread32(0x10004);
  9047ab:	009210        	slli	a2, a9, 32

		if(sof_no_new == sof_no)
  9047ae:	0c0200        	memw
  9047b1:	8810      	l32i.n	a8, a1, 0
  9047b3:	0c0200        	memw
  9047b6:	8211      	l32i.n	a2, a1, 4
  9047b8:	728914        	bne	a8, a2, 9047d0 <_fw_usb_suspend_reboot+0xdc>
	 * Reset "printf" module patch point(RAM to ROM)
	 * when K2 warm start or suspend,
	 * which fixed the error issue cause by redownload
	 * another different firmware.
	 */
	_indir_tbl.cmnos.printf._printf = save_cmnos_printf;
  9047bb:	127174        	l32r	a2, 8e0d8c <_bss_end+0x3d3584>

	/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	 * setting the go suspend here, power down right away!!!
	 */
	if (t != CHECK_SOF_LOOP_CNT)   /* not time out */
  9047be:	0c0200        	memw
  9047c1:	8412      	l32i.n	a4, a1, 8
	 * Reset "printf" module patch point(RAM to ROM)
	 * when K2 warm start or suspend,
	 * which fixed the error issue cause by redownload
	 * another different firmware.
	 */
	_indir_tbl.cmnos.printf._printf = save_cmnos_printf;
  9047c3:	8220      	l32i.n	a2, a2, 0
  9047c5:	223612        	s32i	a2, a3, 72

	/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	 * setting the go suspend here, power down right away!!!
	 */
	if (t != CHECK_SOF_LOOP_CNT)   /* not time out */
  9047c8:	c322      	movi.n	a2, 50
  9047ca:	724923        	bne	a4, a2, 9047f1 <_fw_usb_suspend_reboot+0xfd>
  9047cd:	600028        	j	9047f9 <_fw_usb_suspend_reboot+0x105>
		A_DELAY_USECS(1000);    /* delay 1ms */
		sof_no_new = ioread32(0x10004);

		if(sof_no_new == sof_no)
			break;
		sof_no = sof_no_new;
  9047d0:	0c0200        	memw
  9047d3:	8210      	l32i.n	a2, a1, 0
  9047d5:	0c0200        	memw
  9047d8:	9211      	s32i.n	a2, a1, 4
	/* set PU/PD for all GPIO except two UART pins */
	pupd = ioread32(0x10004088);
	iowrite32(0x10004088, 0xA982AA6A);

	sof_no = ioread32(0x10004);
	for (t = 0; t < CHECK_SOF_LOOP_CNT; t++)
  9047da:	0c0200        	memw
  9047dd:	8212      	l32i.n	a2, a1, 8
  9047df:	b122      	addi.n	a2, a2, 1
  9047e1:	0c0200        	memw
  9047e4:	9212      	s32i.n	a2, a1, 8
  9047e6:	0c0200        	memw
  9047e9:	8212      	l32i.n	a2, a1, 8
  9047eb:	724ba9        	bgeu	a4, a2, 904798 <_fw_usb_suspend_reboot+0xa4>
  9047ee:	63ffc9        	j	9047bb <_fw_usb_suspend_reboot+0xc7>

	/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	 * setting the go suspend here, power down right away!!!
	 */
	if (t != CHECK_SOF_LOOP_CNT)   /* not time out */
		io32_set(0x10000, BIT3);
  9047f1:	1a71f7        	l32r	a10, 8e0fd0 <_bss_end+0x3d37c8>
  9047f4:	c0b8      	movi.n	a11, 8
  9047f6:	5bffb6        	call8	9046d0 <io32_rmw$constprop$0>

	DEBUG_SYSTEM_STATE = (DEBUG_SYSTEM_STATE&(~0xffff)) | 0x1100;
  9047f9:	12716b        	l32r	a2, 8e0da8 <_bss_end+0x3d35a0>
  9047fc:	1471f1        	l32r	a4, 8e0fc0 <_bss_end+0x3d37b8>
  9047ff:	0c0200        	memw
  904802:	8920      	l32i.n	a9, a2, 0
  904804:	1871f8        	l32r	a8, 8e0fe4 <_bss_end+0x3d37dc>
  904807:	049901        	and	a9, a9, a4
  90480a:	089902        	or	a9, a9, a8
  90480d:	0c0200        	memw
  904810:	9920      	s32i.n	a9, a2, 0

	/* restore gpio setting */
	iowrite32(0x10004054, jtag);
	iowrite32(0x50040, spi);
#endif
	iowrite32(0x1000404c, gpio_in);
  904812:	0c0200        	memw
  904815:	8914      	l32i.n	a9, a1, 16
  904817:	1871f3        	l32r	a8, 8e0fe4 <_bss_end+0x3d37dc>
	/* since we still need to touch mac_base address after resuming back,
	 * so that reset mac can't be done in ResetFifo function,
	 * move to here... whole mac control reset.... (bit1)
	 */
	iowrite32(MAGPIE_REG_RST_PWDN_CTRL_ADDR, BIT1);
	io32_set(MAGPIE_REG_RST_PWDN_CTRL_ADDR, BIT0);
  90481a:	c0b1      	movi.n	a11, 1
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90481c:	0c0200        	memw
  90481f:	9980      	s32i.n	a9, a8, 0
	/* restore gpio setting */
	iowrite32(0x10004054, jtag);
	iowrite32(0x50040, spi);
#endif
	iowrite32(0x1000404c, gpio_in);
	iowrite32(0x10004088, pupd);
  904821:	0c0200        	memw
  904824:	8913      	l32i.n	a9, a1, 12
  904826:	1871f4        	l32r	a8, 8e0ff8 <_bss_end+0x3d37f0>
  904829:	0c0200        	memw
  90482c:	9980      	s32i.n	a9, a8, 0

	DEBUG_SYSTEM_STATE = (DEBUG_SYSTEM_STATE&(~0xffff)) | 0x1200;
  90482e:	0c0200        	memw
  904831:	8820      	l32i.n	a8, a2, 0
  904833:	048801        	and	a8, a8, a4
  904836:	1471f9        	l32r	a4, 8e101c <_bss_end+0x3d3814>
  904839:	048802        	or	a8, a8, a4
  90483c:	1471fa        	l32r	a4, 8e1024 <_bss_end+0x3d381c>
  90483f:	0c0200        	memw
  904842:	9820      	s32i.n	a8, a2, 0
  904844:	c082      	movi.n	a8, 2
  904846:	0c0200        	memw
  904849:	9840      	s32i.n	a8, a4, 0
	/* since we still need to touch mac_base address after resuming back,
	 * so that reset mac can't be done in ResetFifo function,
	 * move to here... whole mac control reset.... (bit1)
	 */
	iowrite32(MAGPIE_REG_RST_PWDN_CTRL_ADDR, BIT1);
	io32_set(MAGPIE_REG_RST_PWDN_CTRL_ADDR, BIT0);
  90484b:	da40      	mov.n	a10, a4
  90484d:	5bffa0        	call8	9046d0 <io32_rmw$constprop$0>
  904850:	c080      	movi.n	a8, 0
  904852:	0c0200        	memw
  904855:	9840      	s32i.n	a8, a4, 0
	iowrite32(MAGPIE_REG_RST_PWDN_CTRL_ADDR, 0);
	A_DELAY_USECS(1000);
  904857:	24323a        	l32i	a4, a3, 232
  90485a:	2a3ae8        	movi	a10, 0x3e8
  90485d:	0b4000        	callx8	a4

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  904860:	1471b6        	l32r	a4, 8e0f38 <_bss_end+0x3d3730>

	/* disable ep3 int enable, so that resume back won't
	 * send wdt magic pattern out!!! */
	mUSB_STATUS_IN_INT_DISABLE();
  904863:	290ac0        	movi	a9, 192
  904866:	284000        	l8ui	a8, a4, 0
  904869:	080847        	extui	a8, a8, 0, 8
  90486c:	098802        	or	a8, a8, a9
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  90486f:	0c0200        	memw
  904872:	284400        	s8i	a8, a4, 0

	MAGPIE_REG_USB_RX0_SWAP_DATA = 0x1;
  904875:	1471c5        	l32r	a4, 8e0f8c <_bss_end+0x3d3784>
  904878:	c081      	movi.n	a8, 1
  90487a:	0c0200        	memw
  90487d:	9840      	s32i.n	a8, a4, 0
	MAGPIE_REG_USB_TX0_SWAP_DATA = 0x1;
  90487f:	1471c6        	l32r	a4, 8e0f98 <_bss_end+0x3d3790>
  904882:	0c0200        	memw
  904885:	9840      	s32i.n	a8, a4, 0
	MAGPIE_REG_USB_RX1_SWAP_DATA = 0x1;
  904887:	1471c7        	l32r	a4, 8e0fa4 <_bss_end+0x3d379c>
  90488a:	0c0200        	memw
  90488d:	9840      	s32i.n	a8, a4, 0
	MAGPIE_REG_USB_RX2_SWAP_DATA = 0x1;
  90488f:	1471c8        	l32r	a4, 8e0fb0 <_bss_end+0x3d37a8>
  904892:	0c0200        	memw
  904895:	9840      	s32i.n	a8, a4, 0

	if (((DEBUG_SYSTEM_STATE&~(0x0000ffff))>>16 == 0x5342)) {
  904897:	0c0200        	memw
  90489a:	8220      	l32i.n	a2, a2, 0
  90489c:	14716c        	l32r	a4, 8e0e4c <_bss_end+0x3d3644>
  90489f:	02025f        	extui	a2, a2, 16, 16
  9048a2:	74290a        	bne	a2, a4, 9048b0 <_fw_usb_suspend_reboot+0x1bc>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  9048a5:	1271fb        	l32r	a2, 8e1094 <_bss_end+0x3d388c>
  9048a8:	243a00        	movi	a4, 0x300
  9048ab:	0c0200        	memw
  9048ae:	9420      	s32i.n	a4, a2, 0
		/* UART_SEL and SPI_SEL */
		iowrite32(0x50040, 0x300 | 0 | (1 >> 1) << 12);
	}

	/* Jump to boot code */
	A_USB_JUMP_BOOT();
  9048b0:	22322b        	l32i	a2, a3, 172
  9048b3:	0b2000        	callx8	a2
  9048b6:	d10f      	retw.n

009048b8 <_fw_usb_fw_task>:
 * usb zero length interrupt should not clear by s/w, h/w will handle that
 * complete suspend handle, configure gpio, turn off related function,
 * slow down the pll for stable issue
 */
void _fw_usb_fw_task(void)
{
  9048b8:	6c1004        	entry	a1, 32

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  9048bb:	1271fc        	l32r	a2, 8e10ac <_bss_end+0x3d38a4>
  9048be:	222000        	l8ui	a2, a2, 0
  9048c1:	020247        	extui	a2, a2, 0, 8
	if (usb_interrupt_level1 & BIT5)
	{
		vUsb_Data_In();
	}
#endif
	if (usb_interrupt_level1 & BIT4) {
  9048c4:	7b2711        	bbci	a2, 27, 9048d9 <_fw_usb_fw_task+0x21>
  9048c7:	1371fd        	l32r	a3, 8e10bc <_bss_end+0x3d38b4>
  9048ca:	233000        	l8ui	a3, a3, 0
		usb_interrupt_level2 =
			ioread8_usb(ZM_INTR_SOURCE_4_OFFSET);

		if(usb_interrupt_level2 & BIT6)
  9048cd:	793708        	bbci	a3, 25, 9048d9 <_fw_usb_fw_task+0x21>
			A_USB_REG_OUT(); /* vUsb_Reg_Out() */
  9048d0:	13716e        	l32r	a3, 8e0e88 <_bss_end+0x3d3680>
  9048d3:	233232        	l32i	a3, a3, 200
  9048d6:	0b3000        	callx8	a3
	}

	if (usb_interrupt_level1 & BIT6) {
  9048d9:	c480      	movi.n	a8, 64
  9048db:	782014        	bnone	a2, a8, 9048f3 <_fw_usb_fw_task+0x3b>
  9048de:	1371fe        	l32r	a3, 8e10d8 <_bss_end+0x3d38d0>
  9048e1:	233000        	l8ui	a3, a3, 0
  9048e4:	030347        	extui	a3, a3, 0, 8
		/* zfGenWatchDogEvent(); ?? */
		usb_interrupt_level2 =
			ioread8_usb(ZM_INTR_SOURCE_6_OFFSET);
		if(usb_interrupt_level2 & BIT6)
  9048e7:	783008        	bnone	a3, a8, 9048f3 <_fw_usb_fw_task+0x3b>
			A_USB_STATUS_IN(); /* vUsb_Status_In() */
  9048ea:	13716e        	l32r	a3, 8e0ea4 <_bss_end+0x3d369c>
  9048ed:	233233        	l32i	a3, a3, 204
  9048f0:	0b3000        	callx8	a3
	}

	if (usb_interrupt_level1 & BIT0) {
  9048f3:	7f2f02        	bbsi	a2, 31, 9048f9 <_fw_usb_fw_task+0x41>
  9048f6:	60008e        	j	904988 <_fw_usb_fw_task+0xd0>
  9048f9:	1a71ff        	l32r	a10, 8e10f8 <_bss_end+0x3d38f0>
  9048fc:	28a000        	l8ui	a8, a10, 0
			ioread8_usb(ZM_INTR_SOURCE_0_OFFSET);

		/* refer to FUSB200, p 48, offset:21H, bit7 description,
		 * should clear the command abort interrupt first!?
		 */
		if (usb_interrupt_level2 & BIT7) {
  9048ff:	080347        	extui	a3, a8, 0, 8
  904902:	788713        	bbci	a8, 24, 904919 <_fw_usb_fw_task+0x61>
			/* Handle command abort */
			io8_clr_usb(ZM_INTR_SOURCE_0_OFFSET, BIT7);
  904905:	2c0a80        	movi	a12, 128
  904908:	c0b0      	movi.n	a11, 0
  90490a:	5bff66        	call8	9046a4 <io8_rmw>
			A_PRINTF("![SOURCE_0] bit7 on\n\r");
  90490d:	18716e        	l32r	a8, 8e0ec8 <_bss_end+0x3d36c0>
  904910:	1a7200        	l32r	a10, 8e1110 <_bss_end+0x3d3908>
  904913:	288212        	l32i	a8, a8, 72
  904916:	0b8000        	callx8	a8
		}

		if (usb_interrupt_level2 & BIT1)
  904919:	7e3708        	bbci	a3, 30, 904925 <_fw_usb_fw_task+0x6d>
			A_USB_EP0_TX(); /* USB EP0 tx interrupt */
  90491c:	18716e        	l32r	a8, 8e0ed4 <_bss_end+0x3d36cc>
  90491f:	288220        	l32i	a8, a8, 128
  904922:	0b8000        	callx8	a8

		if (usb_interrupt_level2 & BIT2)
  904925:	7d3708        	bbci	a3, 29, 904931 <_fw_usb_fw_task+0x79>
			A_USB_EP0_RX(); /* USB EP0 rx interrupt */
  904928:	18716e        	l32r	a8, 8e0ee0 <_bss_end+0x3d36d8>
  90492b:	288221        	l32i	a8, a8, 132
  90492e:	0b8000        	callx8	a8

		if (usb_interrupt_level2 & BIT0) {
  904931:	7f3708        	bbci	a3, 31, 90493d <_fw_usb_fw_task+0x85>
			A_USB_EP0_SETUP();
  904934:	18716e        	l32r	a8, 8e0eec <_bss_end+0x3d36e4>
  904937:	28821f        	l32i	a8, a8, 124
  90493a:	0b8000        	callx8	a8
			/* vWriteUSBFakeData() */
		}

		if (usb_interrupt_level2 & BIT3) {
  90493d:	7c3713        	bbci	a3, 28, 904954 <_fw_usb_fw_task+0x9c>
			/* vUsb_ep0end */
			eUsbCxCommand = CMD_VOID;
  904940:	187201        	l32r	a8, 8e1144 <_bss_end+0x3d393c>
  904943:	c090      	movi.n	a9, 0
  904945:	298600        	s32i	a9, a8, 0
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  904948:	187202        	l32r	a8, 8e1150 <_bss_end+0x3d3948>
  90494b:	290a01        	movi	a9, 1
  90494e:	0c0200        	memw
  904951:	298400        	s8i	a9, a8, 0
			iowrite8_usb(ZM_CX_CONFIG_STATUS_OFFSET, 0x01);
		}

		/* EP0 fail */
	        if (usb_interrupt_level2 & BIT4)
  904954:	7b370a        	bbci	a3, 27, 904962 <_fw_usb_fw_task+0xaa>
  904957:	137202        	l32r	a3, 8e1160 <_bss_end+0x3d3958>
  90495a:	c084      	movi.n	a8, 4
  90495c:	0c0200        	memw
  90495f:	283400        	s8i	a8, a3, 0
			iowrite8_usb(ZM_CX_CONFIG_STATUS_OFFSET, 0x04);

		if (eUsbCxFinishAction == ACT_STALL) {
  904962:	1871c4        	l32r	a8, 8e1074 <_bss_end+0x3d386c>
  904965:	8380      	l32i.n	a3, a8, 0
  904967:	69320d        	bnei	a3, 2, 904978 <_fw_usb_fw_task+0xc0>
  90496a:	137202        	l32r	a3, 8e1174 <_bss_end+0x3d396c>
  90496d:	c094      	movi.n	a9, 4
  90496f:	0c0200        	memw
  904972:	293400        	s8i	a9, a3, 0
  904975:	60000b        	j	904984 <_fw_usb_fw_task+0xcc>
			/* set CX_STL to stall Endpoint0 &
			 * will also clear FIFO0 */
			iowrite8_usb(ZM_CX_CONFIG_STATUS_OFFSET, 0x04);
		} else if (eUsbCxFinishAction == ACT_DONE) {
  904978:	693108        	bnei	a3, 1, 904984 <_fw_usb_fw_task+0xcc>
  90497b:	197202        	l32r	a9, 8e1184 <_bss_end+0x3d397c>
  90497e:	0c0200        	memw
  904981:	239400        	s8i	a3, a9, 0
			/* set CX_DONE to indicate the transmistion
			 * of control frame */
			iowrite8_usb(ZM_CX_CONFIG_STATUS_OFFSET, 0x01);
		}
		eUsbCxFinishAction = ACT_IDLE;
  904984:	c030      	movi.n	a3, 0
  904986:	9380      	s32i.n	a3, a8, 0
	}

	if (usb_interrupt_level1 & BIT7) {
  904988:	002232        	sext	a2, a2, 7
  90498b:	672045        	bgez	a2, 9049d4 <_fw_usb_fw_task+0x11c>

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  90498e:	1a71ef        	l32r	a10, 8e114c <_bss_end+0x3d3944>
  904991:	22a000        	l8ui	a2, a10, 0
  904994:	020247        	extui	a2, a2, 0, 8

	if (usb_interrupt_level2 & BIT6)
		vUsb_Data_In0Byte();
#endif

		if (usb_interrupt_level2 & BIT1) {
  904997:	7e271a        	bbci	a2, 30, 9049b5 <_fw_usb_fw_task+0xfd>
			io8_clr_usb(ZM_INTR_SOURCE_7_OFFSET, BIT1);
  90499a:	c0c2      	movi.n	a12, 2
  90499c:	c0b0      	movi.n	a11, 0
  90499e:	5bff41        	call8	9046a4 <io8_rmw>
			UsbChirpFinish = FALSE;
  9049a1:	137203        	l32r	a3, 8e11b0 <_bss_end+0x3d39a8>
  9049a4:	c080      	movi.n	a8, 0
  9049a6:	283500        	s16i	a8, a3, 0
			A_PRINTF("!USB reset\n\r");
  9049a9:	13716e        	l32r	a3, 8e0f64 <_bss_end+0x3d375c>
  9049ac:	1a7204        	l32r	a10, 8e11bc <_bss_end+0x3d39b4>
  9049af:	233212        	l32i	a3, a3, 72
  9049b2:	0b3000        	callx8	a3
		}
		if (usb_interrupt_level2 & BIT2) {
  9049b5:	7d2702        	bbci	a2, 29, 9049bb <_fw_usb_fw_task+0x103>
			/* TBD: the suspend resume code should put here,
			 * Ryan, 07/18
			 * issue, jump back to rom code and what peripherals
			 * should we reset here? */
			_fw_usb_suspend_reboot();
  9049b8:	5bff4e        	call8	9046f4 <_fw_usb_suspend_reboot>
		}
		if (usb_interrupt_level2 & BIT3) {
  9049bb:	7c2715        	bbci	a2, 28, 9049d4 <_fw_usb_fw_task+0x11c>
			io8_clr_usb(ZM_INTR_SOURCE_7_OFFSET, BIT3);
  9049be:	1a71ef        	l32r	a10, 8e117c <_bss_end+0x3d3974>
  9049c1:	c0c8      	movi.n	a12, 8
  9049c3:	c0b0      	movi.n	a11, 0
  9049c5:	5bff37        	call8	9046a4 <io8_rmw>
			A_PRINTF("!USB resume\n\r");
  9049c8:	12716e        	l32r	a2, 8e0f80 <_bss_end+0x3d3778>
  9049cb:	1a7205        	l32r	a10, 8e11e0 <_bss_end+0x3d39d8>
  9049ce:	222212        	l32i	a2, a2, 72
  9049d1:	0b2000        	callx8	a2
  9049d4:	d10f      	retw.n
	...

009049d8 <_fw_usb_reset_fifo>:
	}
}


void _fw_usb_reset_fifo(void)
{
  9049d8:	6c1004        	entry	a1, 32
	io8_set(0x100ae, 0x10);
  9049db:	1a7206        	l32r	a10, 8e11f4 <_bss_end+0x3d39ec>
  9049de:	c0c0      	movi.n	a12, 0
  9049e0:	c1b0      	movi.n	a11, 16
  9049e2:	5bff30        	call8	9046a4 <io8_rmw>
	io8_set(0x100af, 0x10);
  9049e5:	1a7207        	l32r	a10, 8e1204 <_bss_end+0x3d39fc>
  9049e8:	c0c0      	movi.n	a12, 0
  9049ea:	2b0a10        	movi	a11, 16
  9049ed:	5bff2d        	call8	9046a4 <io8_rmw>
  9049f0:	1271b6        	l32r	a2, 8e10c8 <_bss_end+0x3d38c0>

	/* disable ep3 int enable, so that resume back won't
	 * send wdt magic pattern out!!!
	 */
	mUSB_STATUS_IN_INT_DISABLE();
  9049f3:	230ac0        	movi	a3, 192
  9049f6:	282000        	l8ui	a8, a2, 0
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  9049f9:	c040      	movi.n	a4, 0

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  9049fb:	080847        	extui	a8, a8, 0, 8
  9049fe:	038802        	or	a8, a8, a3
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  904a01:	0c0200        	memw
  904a04:	282400        	s8i	a8, a2, 0
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  904a07:	13717b        	l32r	a3, 8e0ff4 <_bss_end+0x3d37ec>
  904a0a:	127172        	l32r	a2, 8e0fd4 <_bss_end+0x3d37cc>
  904a0d:	c084      	movi.n	a8, 4
  904a0f:	0c0200        	memw
  904a12:	9320      	s32i.n	a3, a2, 0
  904a14:	137208        	l32r	a3, 8e1234 <_bss_end+0x3d3a2c>
  904a17:	1271fa        	l32r	a2, 8e1200 <_bss_end+0x3d39f8>
  904a1a:	0c0200        	memw
  904a1d:	9430      	s32i.n	a4, a3, 0
  904a1f:	0c0200        	memw
  904a22:	9820      	s32i.n	a8, a2, 0
	 */
	iowrite32_usb(ZM_SOC_USB_DMA_RESET_OFFSET, 0x0);

	/* reset both usb(bit2)/wlan(bit1) dma */
	iowrite32(MAGPIE_REG_RST_PWDN_CTRL_ADDR, BIT2);
	io32_set(MAGPIE_REG_RST_PWDN_CTRL_ADDR, BIT0);
  904a24:	2b0a01        	movi	a11, 1
  904a27:	022a02        	or	a10, a2, a2
  904a2a:	5bff29        	call8	9046d0 <io32_rmw$constprop$0>
  904a2d:	0c0200        	memw
  904a30:	9420      	s32i.n	a4, a2, 0
  904a32:	c021      	movi.n	a2, 1
  904a34:	0c0200        	memw
  904a37:	9230      	s32i.n	a2, a3, 0

	//*reg_data = 0x00000000;

	//while (*reg_data)   ;

	A_PRINTF("\n change clock to 22 and go to suspend now!");
  904a39:	12716e        	l32r	a2, 8e0ff4 <_bss_end+0x3d37ec>
  904a3c:	1a7209        	l32r	a10, 8e1260 <_bss_end+0x3d3a58>
  904a3f:	232212        	l32i	a3, a2, 72
  904a42:	242a00        	movi	a4, 0x200
  904a45:	0b3000        	callx8	a3
  904a48:	1371fb        	l32r	a3, 8e1234 <_bss_end+0x3d3a2c>

	/* UART_SEL */
	iowrite32(0x50040, 0x200 | 0 | (1 >> 1) << 12);
	A_UART_HWINIT((22*1000*1000), 19200);
  904a4b:	22221a        	l32i	a2, a2, 104
  904a4e:	1b720a        	l32r	a11, 8e1278 <_bss_end+0x3d3a70>
  904a51:	1a720b        	l32r	a10, 8e1280 <_bss_end+0x3d3a78>
  904a54:	0c0200        	memw
  904a57:	9430      	s32i.n	a4, a3, 0
  904a59:	0b2000        	callx8	a2
  904a5c:	d10f      	retw.n
	...

00904a60 <cmnos_clock_init_patch>:
extern a_uint32_t cticks;

// clock change 
//
void cmnos_clock_init_patch(a_uint32_t refclk)
{
  904a60:	6c1004        	entry	a1, 32
    ref_clk = refclk;
  904a63:	18720c        	l32r	a8, 8e1294 <_bss_end+0x3d3a8c>
  904a66:	9280      	s32i.n	a2, a8, 0
  904a68:	d10f      	retw.n
	...

00904a6c <cmnos_refclk_speed_get_patch>:
}

// retrieve current clock setting
// 
a_uint32_t cmnos_refclk_speed_get_patch(void)
{
  904a6c:	6c1004        	entry	a1, 32
    return ref_clk;
}
  904a6f:	18720c        	l32r	a8, 8e12a0 <_bss_end+0x3d3a98>
  904a72:	8280      	l32i.n	a2, a8, 0
  904a74:	d10f      	retw.n
	...

00904a78 <cmnos_delay_us_patch>:


// software emulate delay function
//
void cmnos_delay_us_patch(int us)
{
  904a78:	6c1004        	entry	a1, 32
    a_uint32_t start_time = NOW();
  904a7b:	5b808c        	call8	8e4cac <xthal_get_ccount>
    unsigned int num_ticks = us*ref_clk; // system_freq == number of ticks per 1us
  904a7e:	18720c        	l32r	a8, 8e12b0 <_bss_end+0x3d3aa8>

// software emulate delay function
//
void cmnos_delay_us_patch(int us)
{
    a_uint32_t start_time = NOW();
  904a81:	d3a0      	mov.n	a3, a10
    unsigned int num_ticks = us*ref_clk; // system_freq == number of ticks per 1us
  904a83:	288200        	l32i	a8, a8, 0
  904a86:	082228        	mull	a2, a2, a8
    
    while ( (NOW() - start_time) < num_ticks) {
  904a89:	5b8088        	call8	8e4cac <xthal_get_ccount>
  904a8c:	03aa0c        	sub	a10, a10, a3
  904a8f:	72a3f6        	bltu	a10, a2, 904a89 <cmnos_delay_us_patch+0x11>
        /* busy spin */
        ;
    }
}
  904a92:	d10f      	retw.n

00904a94 <cmnos_tick_patch>:


// software emulate microsecond ticks
//
void cmnos_tick_patch(void)
{
  904a94:	6c1004        	entry	a1, 32
    static a_uint32_t last_tick = 0;
    a_uint32_t current_tick = NOW();
  904a97:	5b8085        	call8	8e4cac <xthal_get_ccount>
    a_uint32_t delta_tick;

    delta_tick = (A_UINT32 ) (current_tick - last_tick)/(ref_clk<<10);
  904a9a:	18720c        	l32r	a8, 8e12cc <_bss_end+0x3d3ac4>
  904a9d:	12720d        	l32r	a2, 8e12d4 <_bss_end+0x3d3acc>
// software emulate microsecond ticks
//
void cmnos_tick_patch(void)
{
    static a_uint32_t last_tick = 0;
    a_uint32_t current_tick = NOW();
  904aa0:	d3a0      	mov.n	a3, a10
    a_uint32_t delta_tick;

    delta_tick = (A_UINT32 ) (current_tick - last_tick)/(ref_clk<<10);
  904aa2:	8b80      	l32i.n	a11, a8, 0
  904aa4:	2a2200        	l32i	a10, a2, 0
  904aa7:	06bb11        	slli	a11, a11, 10
  904aaa:	0a3a0c        	sub	a10, a3, a10
  904aad:	5b80bc        	call8	8e4da0 <__udivsi3>

    if( delta_tick > 0 )
  904ab0:	c8a0      	beqz.n	a10, 904ab4 <cmnos_tick_patch+0x20>
        last_tick = current_tick;
  904ab2:	9320      	s32i.n	a3, a2, 0

    cticks += delta_tick;
  904ab4:	19720e        	l32r	a9, 8e12ec <_bss_end+0x3d3ae4>
  904ab7:	8890      	l32i.n	a8, a9, 0
  904ab9:	aa8a      	add.n	a10, a8, a10
  904abb:	9a90      	s32i.n	a10, a9, 0
  904abd:	d10f      	retw.n
	...

00904ac0 <cmnos_milliseconds_patch>:
}

// get current sysmem up time in milliseconds based
// 
a_uint32_t cmnos_milliseconds_patch(void)
{
  904ac0:	6c1004        	entry	a1, 32
    cmnos_tick_patch();
  904ac3:	5bfff4        	call8	904a94 <cmnos_tick_patch>
    
    return (cticks);
}
  904ac6:	18720e        	l32r	a8, 8e1300 <_bss_end+0x3d3af8>
  904ac9:	8280      	l32i.n	a2, a8, 0
  904acb:	d10f      	retw.n
  904acd:	000000        	ill

00904ad0 <_cvt>:
LOCAL void
(*_putc)(char c) = cmnos_write_char;

LOCAL int
_cvt(unsigned long val, char *buf, long radix, char *digits)
{
  904ad0:	6c100e        	entry	a1, 112
    char temp[80];
    char *cp = temp;
    int length = 0;

    if (val == 0) {
  904ad3:	cc2d      	bnez.n	a2, 904ae4 <_cvt+0x14>
        /* Special case */
        *cp++ = '0';
  904ad5:	c320      	movi.n	a2, 48
  904ad7:	221400        	s8i	a2, a1, 0
  904ada:	b116      	addi.n	a6, a1, 1
  904adc:	d830      	mov.n	a8, a3
  904ade:	d260      	mov.n	a2, a6
  904ae0:	60002e        	j	904b12 <_cvt+0x42>
  904ae3:	00d710        	slli	a7, a13, 32
    } else {
        while (val) {
            *cp++ = digits[val % radix];
  904ae6:	db40      	mov.n	a11, a4
  904ae8:	da20      	mov.n	a10, a2
  904aea:	5b80c1        	call8	8e4df0 <__umodsi3>
  904aed:	aa5a      	add.n	a10, a5, a10
  904aef:	28a000        	l8ui	a8, a10, 0
            val /= radix;
  904af2:	db40      	mov.n	a11, a4
    if (val == 0) {
        /* Special case */
        *cp++ = '0';
    } else {
        while (val) {
            *cp++ = digits[val % radix];
  904af4:	287400        	s8i	a8, a7, 0
            val /= radix;
  904af7:	da20      	mov.n	a10, a2
    if (val == 0) {
        /* Special case */
        *cp++ = '0';
    } else {
        while (val) {
            *cp++ = digits[val % radix];
  904af9:	b176      	addi.n	a6, a7, 1
            val /= radix;
  904afb:	5b80a9        	call8	8e4da0 <__udivsi3>
  904afe:	d2a0      	mov.n	a2, a10
    if (val == 0) {
        /* Special case */
        *cp++ = '0';
    } else {
        while (val) {
            *cp++ = digits[val % radix];
  904b00:	d760      	mov.n	a7, a6

    if (val == 0) {
        /* Special case */
        *cp++ = '0';
    } else {
        while (val) {
  904b02:	65afe0        	bnez	a10, 904ae6 <_cvt+0x16>
  904b05:	63ffd3        	j	904adc <_cvt+0xc>
            *cp++ = digits[val % radix];
            val /= radix;
        }
    }
    while (cp != temp) {
        *buf++ = *--cp;
  904b08:	b022      	addi.n	a2, a2, -1
  904b0a:	242000        	l8ui	a4, a2, 0
  904b0d:	248400        	s8i	a4, a8, 0
  904b10:	b188      	addi.n	a8, a8, 1
        while (val) {
            *cp++ = digits[val % radix];
            val /= radix;
        }
    }
    while (cp != temp) {
  904b12:	7219f2        	bne	a1, a2, 904b08 <_cvt+0x38>
  904b15:	01620c        	sub	a2, a6, a1
        *buf++ = *--cp;
        length++;
    }
    *buf = '\0';
  904b18:	a233      	add.n	a3, a3, a2
  904b1a:	c040      	movi.n	a4, 0
  904b1c:	243400        	s8i	a4, a3, 0
    return (length);
}
  904b1f:	d10f      	retw.n
  904b21:	000000        	ill

00904b24 <cmnos_write_char>:

#include <stdarg.h>

LOCAL void
cmnos_write_char(char c)
{
  904b24:	6c1004        	entry	a1, 32
  904b27:	020247        	extui	a2, a2, 0, 8
    if (c == '\n') {
  904b2a:	69290e        	bnei	a2, 10, 904b3c <cmnos_write_char+0x18>
        A_PUTC('\r');
  904b2d:	13716e        	l32r	a3, 8e10e8 <_bss_end+0x3d38e0>
  904b30:	c0ad      	movi.n	a10, 13
  904b32:	283214        	l32i	a8, a3, 80
  904b35:	0b8000        	callx8	a8
  904b38:	600008        	j	904b44 <cmnos_write_char+0x20>
  904b3b:	00c03d        	excw
        A_PUTC('\n');
    } else if (c == '\r') {
  904b3e:	73210a        	beq	a2, a3, 904b4c <cmnos_write_char+0x28>
    } else {
      A_PUTC(c);
  904b41:	13716e        	l32r	a3, 8e10fc <_bss_end+0x3d38f4>
  904b44:	233214        	l32i	a3, a3, 80
  904b47:	da20      	mov.n	a10, a2
  904b49:	0b3000        	callx8	a3
  904b4c:	d10f      	retw.n
	...

00904b50 <fw_cmnos_printf>:
    return (res);
}

int
fw_cmnos_printf(const char *fmt, ...)
{
  904b50:	6c1012        	entry	a1, 144
    va_list ap;
    int ret;

    va_start(ap, fmt);
  904b53:	951f      	s32i.n	a5, a1, 60
    return (res);
}

int
fw_cmnos_printf(const char *fmt, ...)
{
  904b55:	d520      	mov.n	a5, a2
    va_list ap;
    int ret;

    va_start(ap, fmt);
  904b57:	221c30        	addi	a2, a1, 48
  904b5a:	931d      	s32i.n	a3, a1, 52
  904b5c:	941e      	s32i.n	a4, a1, 56
  904b5e:	9219      	s32i.n	a2, a1, 36
    char buf[sizeof(long)*8];
    char c, sign, *cp=buf;
    int left_prec, right_prec, zero_fill, pad, pad_on_right,
        i, islong, islonglong;
    long val = 0;
    int res = 0, length = 0;
  904b60:	c040      	movi.n	a4, 0
fw_cmnos_printf(const char *fmt, ...)
{
    va_list ap;
    int ret;

    va_start(ap, fmt);
  904b62:	c024      	movi.n	a2, 4
  904b64:	231c70        	addi	a3, a1, 112
  904b67:	261610        	s32i	a6, a1, 64
  904b6a:	921a      	s32i.n	a2, a1, 40
  904b6c:	221614        	s32i	a2, a1, 80
  904b6f:	271611        	s32i	a7, a1, 68
  904b72:	9318      	s32i.n	a3, a1, 32
    char buf[sizeof(long)*8];
    char c, sign, *cp=buf;
    int left_prec, right_prec, zero_fill, pad, pad_on_right,
        i, islong, islonglong;
    long val = 0;
    int res = 0, length = 0;
  904b74:	d240      	mov.n	a2, a4
{
    char buf[sizeof(long)*8];
    char c, sign, *cp=buf;
    int left_prec, right_prec, zero_fill, pad, pad_on_right,
        i, islong, islonglong;
    long val = 0;
  904b76:	241615        	s32i	a4, a1, 84

LOCAL
int cmnos_vprintf(void (*putc)(char c), const char *fmt, va_list ap)
{
    char buf[sizeof(long)*8];
    char c, sign, *cp=buf;
  904b79:	d610      	mov.n	a6, a1
  904b7b:	60039e        	j	904f1d <fw_cmnos_printf+0x3cd>
        i, islong, islonglong;
    long val = 0;
    int res = 0, length = 0;

    while ((c = *fmt++) != '\0') {
        if (c == '%') {
  904b7e:	c285      	movi.n	a8, 37
  904b80:	78a102        	beq	a10, a8, 904b86 <fw_cmnos_printf+0x36>
  904b83:	60038f        	j	904f16 <fw_cmnos_printf+0x3c6>
            c = *fmt++;
  904b86:	285001        	l8ui	a8, a5, 1
            left_prec = right_prec = pad_on_right = islong = islonglong = 0;
            if (c == '-') {
  904b89:	c23d      	movi.n	a3, 45
  904b8b:	738109        	beq	a8, a3, 904b98 <fw_cmnos_printf+0x48>
    int res = 0, length = 0;

    while ((c = *fmt++) != '\0') {
        if (c == '%') {
            c = *fmt++;
            left_prec = right_prec = pad_on_right = islong = islonglong = 0;
  904b8e:	c090      	movi.n	a9, 0
    long val = 0;
    int res = 0, length = 0;

    while ((c = *fmt++) != '\0') {
        if (c == '%') {
            c = *fmt++;
  904b90:	b257      	addi.n	a7, a5, 2
            left_prec = right_prec = pad_on_right = islong = islonglong = 0;
  904b92:	291617        	s32i	a9, a1, 92
  904b95:	600009        	j	904ba2 <fw_cmnos_printf+0x52>
            if (c == '-') {
                c = *fmt++;
                pad_on_right++;
  904b98:	c031      	movi.n	a3, 1
    while ((c = *fmt++) != '\0') {
        if (c == '%') {
            c = *fmt++;
            left_prec = right_prec = pad_on_right = islong = islonglong = 0;
            if (c == '-') {
                c = *fmt++;
  904b9a:	285002        	l8ui	a8, a5, 2
  904b9d:	b357      	addi.n	a7, a5, 3
                pad_on_right++;
  904b9f:	231617        	s32i	a3, a1, 92
            }
            if (c == '0') {
                zero_fill = TRUE;
                c = *fmt++;
            } else {
                zero_fill = FALSE;
  904ba2:	c050      	movi.n	a5, 0
            left_prec = right_prec = pad_on_right = islong = islonglong = 0;
            if (c == '-') {
                c = *fmt++;
                pad_on_right++;
            }
            if (c == '0') {
  904ba4:	c330      	movi.n	a3, 48
                zero_fill = TRUE;
                c = *fmt++;
            } else {
                zero_fill = FALSE;
  904ba6:	251616        	s32i	a5, a1, 88
            left_prec = right_prec = pad_on_right = islong = islonglong = 0;
            if (c == '-') {
                c = *fmt++;
                pad_on_right++;
            }
            if (c == '0') {
  904ba9:	738909        	bne	a8, a3, 904bb6 <fw_cmnos_printf+0x66>
                zero_fill = TRUE;
  904bac:	c091      	movi.n	a9, 1
                c = *fmt++;
  904bae:	287000        	l8ui	a8, a7, 0
            if (c == '-') {
                c = *fmt++;
                pad_on_right++;
            }
            if (c == '0') {
                zero_fill = TRUE;
  904bb1:	291616        	s32i	a9, a1, 88
                c = *fmt++;
  904bb4:	b177      	addi.n	a7, a7, 1
            if (c == '-') {
                c = *fmt++;
                pad_on_right++;
            }
            if (c == '0') {
                zero_fill = TRUE;
  904bb6:	c030      	movi.n	a3, 0
                c = *fmt++;
            } else {
                zero_fill = FALSE;
            }
            while (is_digit(c)) {
  904bb8:	c0b9      	movi.n	a11, 9
  904bba:	60000e        	j	904bcc <fw_cmnos_printf+0x7c>
                left_prec = (left_prec * 10) + (c - '0');
  904bbd:	0e3511        	slli	a5, a3, 2
  904bc0:	a353      	add.n	a3, a5, a3
  904bc2:	0f3311        	slli	a3, a3, 1
                c = *fmt++;
  904bc5:	287000        	l8ui	a8, a7, 0
                c = *fmt++;
            } else {
                zero_fill = FALSE;
            }
            while (is_digit(c)) {
                left_prec = (left_prec * 10) + (c - '0');
  904bc8:	a393      	add.n	a3, a9, a3
  904bca:	b177      	addi.n	a7, a7, 1
                zero_fill = TRUE;
                c = *fmt++;
            } else {
                zero_fill = FALSE;
            }
            while (is_digit(c)) {
  904bcc:	298cd0        	addi	a9, a8, -48
  904bcf:	090a47        	extui	a10, a9, 0, 8
  904bd2:	d570      	mov.n	a5, a7
  904bd4:	7abbe5        	bgeu	a11, a10, 904bbd <fw_cmnos_printf+0x6d>
                left_prec = (left_prec * 10) + (c - '0');
                c = *fmt++;
            }
            if (c == '.') {
  904bd7:	c29e      	movi.n	a9, 46
  904bd9:	798923        	bne	a8, a9, 904c00 <fw_cmnos_printf+0xb0>
                c = *fmt++;
                zero_fill++;
  904bdc:	251216        	l32i	a5, a1, 88
            while (is_digit(c)) {
                left_prec = (left_prec * 10) + (c - '0');
                c = *fmt++;
            }
            if (c == '.') {
                c = *fmt++;
  904bdf:	287000        	l8ui	a8, a7, 0
                zero_fill++;
  904be2:	b155      	addi.n	a5, a5, 1
  904be4:	251616        	s32i	a5, a1, 88
            while (is_digit(c)) {
                left_prec = (left_prec * 10) + (c - '0');
                c = *fmt++;
            }
            if (c == '.') {
                c = *fmt++;
  904be7:	b177      	addi.n	a7, a7, 1
                zero_fill++;
                while (is_digit(c)) {
  904be9:	c0a9      	movi.n	a10, 9
  904beb:	600006        	j	904bf5 <fw_cmnos_printf+0xa5>
  904bee:	000028        	mull	a0, a0, a0
                    right_prec = (right_prec * 10) + (c - '0');
                    c = *fmt++;
  904bf1:	7000b1        	bnone	a0, a0, 904ba6 <fw_cmnos_printf+0x56>
  904bf4:	77298c        	bne	a2, a7, 904b84 <fw_cmnos_printf+0x34>
                c = *fmt++;
            }
            if (c == '.') {
                c = *fmt++;
                zero_fill++;
                while (is_digit(c)) {
  904bf7:	d009      	excw
  904bf9:	0947d5        	excw
  904bfc:	7079ab        	bne	a7, a0, 904bab <fw_cmnos_printf+0x5b>
  904bff:	ef          	.byte 0xef
                }
            } else {
                right_prec = left_prec;
            }
            sign = '\0';
            if (c == 'l') {
  904c00:	290a6c        	movi	a9, 108
  904c03:	270a62        	movi	a7, 98
  904c06:	798102        	beq	a8, a9, 904c0c <fw_cmnos_printf+0xbc>
  904c09:	600323        	j	904f30 <fw_cmnos_printf+0x3e0>
                // 'long' qualifier
                c = *fmt++;
  904c0c:	285000        	l8ui	a8, a5, 0
		islong = 1;
                if (c == 'l') {
  904c0f:	798105        	beq	a8, a9, 904c18 <fw_cmnos_printf+0xc8>
                right_prec = left_prec;
            }
            sign = '\0';
            if (c == 'l') {
                // 'long' qualifier
                c = *fmt++;
  904c12:	b155      	addi.n	a5, a5, 1
  904c14:	600318        	j	904f30 <fw_cmnos_printf+0x3e0>
  904c17:	002850        	extui	a8, a0, 18, 1
		islong = 1;
                if (c == 'l') {
                    // long long qualifier
                    c = *fmt++;
  904c1a:	01b259        	extui	a2, a1, 27, 10
                    islonglong = 1;
                }
            }
            // Fetch value [numeric descriptors only]
            switch (c) {
  904c1d:	778137        	beq	a8, a7, 904c58 <fw_cmnos_printf+0x108>
  904c20:	787318        	bltu	a7, a8, 904c3c <fw_cmnos_printf+0xec>
  904c23:	c454      	movi.n	a5, 68
  904c25:	75812f        	beq	a8, a5, 904c58 <fw_cmnos_printf+0x108>
  904c28:	785304        	bltu	a5, a8, 904c30 <fw_cmnos_printf+0xe0>
  904c2b:	c452      	movi.n	a5, 66
  904c2d:	600024        	j	904c55 <fw_cmnos_printf+0x105>
  904c30:	c555      	movi.n	a5, 85
  904c32:	758122        	beq	a8, a5, 904c58 <fw_cmnos_printf+0x108>
  904c35:	c558      	movi.n	a5, 88
  904c37:	60001a        	j	904c55 <fw_cmnos_printf+0x105>
  904c3a:	000025        	excw
  904c3d:	0a7075        	excw
  904c40:	8115      	l32i.n	a1, a1, 20
  904c42:	785306        	bltu	a5, a8, 904c4c <fw_cmnos_printf+0xfc>
  904c45:	250a64        	movi	a5, 100
  904c48:	600009        	j	904c55 <fw_cmnos_printf+0x105>
  904c4b:	00250a        	addx4	a5, a2, a0
  904c4e:	757581        	bbc	a7, a5, 904bd3 <fw_cmnos_printf+0x83>
  904c51:	05250a        	addx4	a5, a2, a5
  904c54:	787589        	bbc	a7, a8, 904be1 <fw_cmnos_printf+0x91>
  904c57:	6d2512        	excw
            case 'u':
            case 'U':
            case 'b':
            case 'B':
                if (islonglong) {
                    val = va_arg(ap, long);
  904c5a:	14c1a8        	l32r	a4, 8f52fc <memset+0x10160>
  904c5d:	b457      	addi.n	a7, a5, 4
  904c5f:	251c30        	addi	a5, a1, 48
  904c62:	77aa0a        	bge	a10, a7, 904c70 <fw_cmnos_printf+0x120>
  904c65:	251214        	l32i	a5, a1, 80
  904c68:	75a201        	blt	a10, a5, 904c6d <fw_cmnos_printf+0x11d>
  904c6b:	c274      	movi.n	a7, 36
  904c6d:	251c70        	addi	a5, a1, 112
  904c70:	a755      	add.n	a5, a5, a7
  904c72:	255cfc        	addi	a5, a5, -4
  904c75:	8550      	l32i.n	a5, a5, 0
  904c77:	271614        	s32i	a7, a1, 80
  904c7a:	251615        	s32i	a5, a1, 84
  904c7d:	d590      	mov.n	a5, a9
  904c7f:	600026        	j	904ca9 <fw_cmnos_printf+0x159>
  904c82:	00002a        	muluh	a0, a0, a0
	        } else if (islong) {
                    val = (long)va_arg(ap, long);
		} else{
                    val = (long)va_arg(ap, int);
  904c85:	121427        	l32r	a2, 8c9d24 <_bss_end+0x3bc51c>
  904c88:	1c30b4        	l32r	a12, 8d0f58 <_bss_end+0x3c3750>
  904c8b:	a9c1      	add.n	a1, a12, a9
  904c8d:	a879      	add.n	a9, a7, a8
  904c8f:	aa0a      	add.n	a10, a0, a10
  904c91:	2b1214        	l32i	a11, a1, 80
  904c94:	7ba201        	blt	a10, a11, 904c99 <fw_cmnos_printf+0x149>
  904c97:	c294      	movi.n	a9, 36
  904c99:	271c70        	addi	a7, a1, 112
  904c9c:	a977      	add.n	a7, a7, a9
  904c9e:	277cfc        	addi	a7, a7, -4
  904ca1:	8c70      	l32i.n	a12, a7, 0
  904ca3:	291614        	s32i	a9, a1, 80
  904ca6:	2c1615        	s32i	a12, a1, 84
                }
                if ((c == 'd') || (c == 'D')) {
  904ca9:	27fadf        	movi	a7, -33
  904cac:	078701        	and	a7, a8, a7
  904caf:	277cbc        	addi	a7, a7, -68
                    if (val < 0) {
  904cb2:	cd72      	bnez.n	a7, 904cc8 <fw_cmnos_printf+0x178>
  904cb4:	291215        	l32i	a9, a1, 84
  904cb7:	67900d        	bgez	a9, 904cc8 <fw_cmnos_printf+0x178>
                        sign = '-';
                        val = -val;
  904cba:	090906        	neg	a9, a9
  904cbd:	291615        	s32i	a9, a1, 84
		} else{
                    val = (long)va_arg(ap, int);
                }
                if ((c == 'd') || (c == 'D')) {
                    if (val < 0) {
                        sign = '-';
  904cc0:	c27d      	movi.n	a7, 45
  904cc2:	600004        	j	904cca <fw_cmnos_printf+0x17a>
  904cc5:	00d590        	l32e	a0, a13, -44
                    c = *fmt++;
                }
            } else {
                right_prec = left_prec;
            }
            sign = '\0';
  904cc8:	c070      	movi.n	a7, 0
                break;
            default:
                break;
            }
            // Process output
            switch (c) {
  904cca:	c598      	movi.n	a9, 88
  904ccc:	798902        	bne	a8, a9, 904cd2 <fw_cmnos_printf+0x182>
  904ccf:	600081        	j	904d54 <fw_cmnos_printf+0x204>
  904cd2:	78932f        	bltu	a9, a8, 904d05 <fw_cmnos_printf+0x1b5>
  904cd5:	c493      	movi.n	a9, 67
  904cd7:	798902        	bne	a8, a9, 904cdd <fw_cmnos_printf+0x18d>
  904cda:	60010f        	j	904ded <fw_cmnos_printf+0x29d>
  904cdd:	789309        	bltu	a9, a8, 904cea <fw_cmnos_printf+0x19a>
  904ce0:	c2a5      	movi.n	a10, 37
  904ce2:	c492      	movi.n	a9, 66
  904ce4:	7a8938        	bne	a8, a10, 904d20 <fw_cmnos_printf+0x1d0>
  904ce7:	60015d        	j	904e48 <fw_cmnos_printf+0x2f8>
  904cea:	c593      	movi.n	a9, 83
  904cec:	798902        	bne	a8, a9, 904cf2 <fw_cmnos_printf+0x1a2>
  904cef:	6000b5        	j	904da8 <fw_cmnos_printf+0x258>
  904cf2:	c595      	movi.n	a9, 85
  904cf4:	79815c        	beq	a8, a9, 904d54 <fw_cmnos_printf+0x204>
  904cf7:	c494      	movi.n	a9, 68
  904cf9:	798102        	beq	a8, a9, 904cff <fw_cmnos_printf+0x1af>
  904cfc:	600150        	j	904e50 <fw_cmnos_printf+0x300>
  904cff:	600051        	j	904d54 <fw_cmnos_printf+0x204>
  904d02:	000000        	ill
  904d05:	290a70        	movi	a9, 112
  904d08:	798132        	beq	a8, a9, 904d3e <fw_cmnos_printf+0x1ee>
  904d0b:	78931a        	bltu	a9, a8, 904d29 <fw_cmnos_printf+0x1d9>
  904d0e:	290a63        	movi	a9, 99
  904d11:	798902        	bne	a8, a9, 904d17 <fw_cmnos_printf+0x1c7>
  904d14:	6000d5        	j	904ded <fw_cmnos_printf+0x29d>
  904d17:	290a64        	movi	a9, 100
  904d1a:	798136        	beq	a8, a9, 904d54 <fw_cmnos_printf+0x204>
  904d1d:	290a62        	movi	a9, 98
  904d20:	798902        	bne	a8, a9, 904d26 <fw_cmnos_printf+0x1d6>
  904d23:	6000ef        	j	904e16 <fw_cmnos_printf+0x2c6>
  904d26:	600126        	j	904e50 <fw_cmnos_printf+0x300>
  904d29:	290a75        	movi	a9, 117
  904d2c:	798124        	beq	a8, a9, 904d54 <fw_cmnos_printf+0x204>
  904d2f:	290a78        	movi	a9, 120
  904d32:	79811e        	beq	a8, a9, 904d54 <fw_cmnos_printf+0x204>
  904d35:	290a73        	movi	a9, 115
  904d38:	79816c        	beq	a8, a9, 904da8 <fw_cmnos_printf+0x258>
  904d3b:	600111        	j	904e50 <fw_cmnos_printf+0x300>
            case 'p':  // Pointer
                (*putc)('0');
  904d3e:	c3a0      	movi.n	a10, 48
  904d40:	5bff78        	call8	904b24 <cmnos_write_char>
                (*putc)('x');
                zero_fill = TRUE;
  904d43:	230a01        	movi	a3, 1
            }
            // Process output
            switch (c) {
            case 'p':  // Pointer
                (*putc)('0');
                (*putc)('x');
  904d46:	2a0a78        	movi	a10, 120
  904d49:	5bff76        	call8	904b24 <cmnos_write_char>
                zero_fill = TRUE;
  904d4c:	231616        	s32i	a3, a1, 88
                left_prec = sizeof(unsigned long)*2;
  904d4f:	c038      	movi.n	a3, 8
  904d51:	600040        	j	904d95 <fw_cmnos_printf+0x245>
            case 'D':
            case 'u':
            case 'U':
            case 'x':
            case 'X':
                switch (c) {
  904d54:	260a64        	movi	a6, 100
  904d57:	768132        	beq	a8, a6, 904d8d <fw_cmnos_printf+0x23d>
  904d5a:	786317        	bltu	a6, a8, 904d75 <fw_cmnos_printf+0x225>
  904d5d:	c565      	movi.n	a6, 85
  904d5f:	76812a        	beq	a8, a6, 904d8d <fw_cmnos_printf+0x23d>
  904d62:	c568      	movi.n	a6, 88
                case 'p':
                case 'x':
                    length = _cvt(val, buf, 16, "0123456789abcdef");
                    break;
                case 'X':
                    length = _cvt(val, buf, 16, "0123456789ABCDEF");
  904d64:	1d7212        	l32r	a13, 8e15ac <athos_indirection_table_install+0x64>
            case 'D':
            case 'u':
            case 'U':
            case 'x':
            case 'X':
                switch (c) {
  904d67:	76812d        	beq	a8, a6, 904d98 <fw_cmnos_printf+0x248>
  904d6a:	c464      	movi.n	a6, 68
  904d6c:	768102        	beq	a8, a6, 904d72 <fw_cmnos_printf+0x222>
  904d6f:	6000f5        	j	904e68 <fw_cmnos_printf+0x318>
  904d72:	600017        	j	904d8d <fw_cmnos_printf+0x23d>
  904d75:	260a75        	movi	a6, 117
  904d78:	768111        	beq	a8, a6, 904d8d <fw_cmnos_printf+0x23d>
  904d7b:	260a78        	movi	a6, 120
  904d7e:	768113        	beq	a8, a6, 904d95 <fw_cmnos_printf+0x245>
  904d81:	260a70        	movi	a6, 112
  904d84:	768102        	beq	a8, a6, 904d8a <fw_cmnos_printf+0x23a>
  904d87:	6000dd        	j	904e68 <fw_cmnos_printf+0x318>
  904d8a:	600007        	j	904d95 <fw_cmnos_printf+0x245>
                case 'd':
                case 'D':
                case 'u':
                case 'U':
                    length = _cvt(val, buf, 10, "0123456789");
  904d8d:	1d7210        	l32r	a13, 8e15d0 <athos_indirection_table_install+0x88>
  904d90:	c0ca      	movi.n	a12, 10
  904d92:	600004        	j	904d9a <fw_cmnos_printf+0x24a>
                    break;
                case 'p':
                case 'x':
                    length = _cvt(val, buf, 16, "0123456789abcdef");
  904d95:	1d7211        	l32r	a13, 8e15dc <athos_indirection_table_install+0x94>
  904d98:	c1c0      	movi.n	a12, 16
  904d9a:	2a1215        	l32i	a10, a1, 84
  904d9d:	db10      	mov.n	a11, a1
  904d9f:	5bff4c        	call8	904ad0 <_cvt>
  904da2:	d4a0      	mov.n	a4, a10
  904da4:	6000c0        	j	904e68 <fw_cmnos_printf+0x318>
  904da7:	002412        	srai	a4, a0, 2
                }
                cp = buf;
                break;
            case 's':
            case 'S':
                cp = va_arg(ap, char *);
  904daa:	14b446        	l32r	a4, 8f1ec4 <memset+0xcd28>
  904dad:	240a18        	movi	a4, 24
  904db0:	764a11        	bge	a4, a6, 904dc5 <fw_cmnos_printf+0x275>
  904db3:	281214        	l32i	a8, a1, 80
  904db6:	784202        	blt	a4, a8, 904dbc <fw_cmnos_printf+0x26c>
  904db9:	260a24        	movi	a6, 36
  904dbc:	261614        	s32i	a6, a1, 80
  904dbf:	241c70        	addi	a4, a1, 112
  904dc2:	600005        	j	904dcb <fw_cmnos_printf+0x27b>
  904dc5:	261614        	s32i	a6, a1, 80
  904dc8:	241c30        	addi	a4, a1, 48
  904dcb:	a644      	add.n	a4, a4, a6
  904dcd:	244cfc        	addi	a4, a4, -4
  904dd0:	264200        	l32i	a6, a4, 0
                if (cp == NULL)  {
                    cp = "<null>";
  904dd3:	14720f        	l32r	a4, 8e1610 <athos_indirection_table_install+0xc8>
  904dd6:	064638        	moveqz	a6, a4, a6
  904dd9:	066802        	or	a8, a6, a6
  904ddc:	06840c        	sub	a4, a8, a6
  904ddf:	b188      	addi.n	a8, a8, 1
                }
                length = 0;
                while (cp[length] != '\0') length++;
  904de1:	b089      	addi.n	a9, a8, -1
  904de3:	299000        	l8ui	a9, a9, 0
  904de6:	659ff2        	bnez	a9, 904ddc <fw_cmnos_printf+0x28c>
  904de9:	60007d        	j	904e6a <fw_cmnos_printf+0x31a>
  904dec:	002912        	srai	a9, a0, 2
                break;
            case 'c':
            case 'C':
                c = va_arg(ap, int /*char*/);
  904def:	14c188        	l32r	a4, 8f5410 <memset+0x10274>
  904df2:	b497      	addi.n	a7, a9, 4
  904df4:	231c30        	addi	a3, a1, 48
  904df7:	778a08        	bge	a8, a7, 904e03 <fw_cmnos_printf+0x2b3>
  904dfa:	798202        	blt	a8, a9, 904e00 <fw_cmnos_printf+0x2b0>
  904dfd:	270a24        	movi	a7, 36
  904e00:	231c70        	addi	a3, a1, 112
  904e03:	a733      	add.n	a3, a3, a7
  904e05:	233cfc        	addi	a3, a3, -4
                (*putc)(c);
  904e08:	2a3003        	l8ui	a10, a3, 3
                res++;
  904e0b:	b122      	addi.n	a2, a2, 1
                while (cp[length] != '\0') length++;
                break;
            case 'c':
            case 'C':
                c = va_arg(ap, int /*char*/);
                (*putc)(c);
  904e0d:	5bff45        	call8	904b24 <cmnos_write_char>
                res++;
  904e10:	271614        	s32i	a7, a1, 80
  904e13:	600106        	j	904f1d <fw_cmnos_printf+0x3cd>
                continue;
            case 'b':
            case 'B':
                length = left_prec;
                if (left_prec == 0) {
  904e16:	c240      	movi.n	a4, 32
  904e18:	033439        	movnez	a4, a3, a3
                    else if (islong)
                        length = sizeof(long)*8;
                    else
                        length = sizeof(int)*8;
                }
                for (i = 0;  i < length-1;  i++) {
  904e1b:	c060      	movi.n	a6, 0
  904e1d:	b049      	addi.n	a9, a4, -1
                    buf[i] = ((val & ((long)1<<i)) ? '1' : '.');
  904e1f:	c2ae      	movi.n	a10, 46
  904e21:	c3b1      	movi.n	a11, 49
  904e23:	60001b        	j	904e42 <fw_cmnos_printf+0x2f2>
  904e26:	00002c        	excw
  904e29:	121500        	l32r	a2, 8ca22c <_bss_end+0x3bca24>
  904e2c:	60040c        	j	90523c <ar5416ProcRxDescFast_20+0x4c>
  904e2f:	081b08        	add	a11, a1, a8
  904e32:	0840dc        	excw
  904e35:	b008      	addi.n	a8, a0, -1
  904e37:	ac38      	add.n	a8, a3, a12
  904e39:	d8c0      	mov.n	a8, a12
  904e3b:	a61c      	add.n	a12, a1, a6
  904e3d:	28c400        	s8i	a8, a12, 0
                    else if (islong)
                        length = sizeof(long)*8;
                    else
                        length = sizeof(int)*8;
                }
                for (i = 0;  i < length-1;  i++) {
  904e40:	b166      	addi.n	a6, a6, 1
  904e42:	7962e2        	blt	a6, a9, 904e28 <fw_cmnos_printf+0x2d8>
  904e45:	60001f        	j	904e68 <fw_cmnos_printf+0x318>
                    buf[i] = ((val & ((long)1<<i)) ? '1' : '.');
                }
                cp = buf;
                break;
            case '%':
                (*putc)('%');
  904e48:	c2a5      	movi.n	a10, 37
  904e4a:	5bff36        	call8	904b24 <cmnos_write_char>
  904e4d:	600019        	j	904e6a <fw_cmnos_printf+0x31a>
                break;
            default:
                (*putc)('%');
  904e50:	c2a5      	movi.n	a10, 37
  904e52:	281619        	s32i	a8, a1, 100
  904e55:	5bff33        	call8	904b24 <cmnos_write_char>
                (*putc)(c);
  904e58:	281219        	l32i	a8, a1, 100
                res += 2;
  904e5b:	222c02        	addi	a2, a2, 2
            case '%':
                (*putc)('%');
                break;
            default:
                (*putc)('%');
                (*putc)(c);
  904e5e:	088a02        	or	a10, a8, a8
  904e61:	5bff30        	call8	904b24 <cmnos_write_char>
  904e64:	600002        	j	904e6a <fw_cmnos_printf+0x31a>
  904e67:	00d610        	slli	a6, a13, 32
                res += 2;
            }
            pad = left_prec - length;
  904e6a:	04330c        	sub	a3, a3, a4
            if (sign != '\0') {
  904e6d:	c87b      	beqz.n	a7, 904e7c <fw_cmnos_printf+0x32c>
                pad--;
            }
            if (zero_fill) {
  904e6f:	281216        	l32i	a8, a1, 88
                (*putc)(c);
                res += 2;
            }
            pad = left_prec - length;
            if (sign != '\0') {
                pad--;
  904e72:	b033      	addi.n	a3, a3, -1
            }
            if (zero_fill) {
  904e74:	648108        	beqz	a8, 904f80 <fw_cmnos_printf+0x430>
  904e77:	60000a        	j	904e85 <fw_cmnos_printf+0x335>
  904e7a:	000029        	excw
  904e7d:	121665        	l32r	a2, 8ca814 <_bss_end+0x3bd00c>
  904e80:	90a2      	s32i.n	a0, a10, 8
  904e82:	600105        	j	904f8b <fw_cmnos_printf+0x43b>
                c = '0';
                if (sign != '\0') {
                    (*putc)(sign);
  904e85:	da70      	mov.n	a10, a7
  904e87:	5bff27        	call8	904b24 <cmnos_write_char>
                    res++;
  904e8a:	b122      	addi.n	a2, a2, 1
  904e8c:	600095        	j	904f25 <fw_cmnos_printf+0x3d5>
  904e8f:	002712        	srai	a7, a0, 2
                    sign = '\0';
                }
            } else {
                c = ' ';
            }
            if (!pad_on_right) {
  904e92:	17c380        	l32r	a7, 8f5c94 <memset+0x10af8>
  904e95:	600001        	j	904e9a <fw_cmnos_printf+0x34a>
  904e98:	c280      	movi.n	a8, 32
  904e9a:	d930      	mov.n	a9, a3
  904e9c:	600014        	j	904eb4 <fw_cmnos_printf+0x364>
  904e9f:	0000da        	excw
                while (pad-- > 0) {
                    (*putc)(c);
  904ea2:	8028      	l32i.n	a0, a2, 32
  904ea4:	161929        	l32r	a6, 8cb348 <_bss_end+0x3bdb40>
  904ea7:	16185b        	l32r	a6, 8cb014 <_bss_end+0x3bd80c>
  904eaa:	ff          	.byte 0xff
  904eab:	1e2912        	l32r	a14, 8cf2f4 <_bss_end+0x3c1aec>
  904eae:	182812        	l32r	a8, 8ceef8 <_bss_end+0x3c16f0>
  904eb1:	19b099        	l32r	a9, 8f1118 <memset+0xbf7c>
                }
            } else {
                c = ' ';
            }
            if (!pad_on_right) {
                while (pad-- > 0) {
  904eb4:	6b91e9        	bgei	a9, 1, 904ea1 <fw_cmnos_printf+0x351>
  904eb7:	c080      	movi.n	a8, 0
  904eb9:	083835        	max	a8, a3, a8
  904ebc:	b033      	addi.n	a3, a3, -1
  904ebe:	a822      	add.n	a2, a2, a8
  904ec0:	08330c        	sub	a3, a3, a8
                    (*putc)(c);
                    res++;
                }
            }
            if (sign != '\0') {
  904ec3:	c875      	beqz.n	a7, 904ecc <fw_cmnos_printf+0x37c>
                (*putc)(sign);
  904ec5:	da70      	mov.n	a10, a7
  904ec7:	5bff17        	call8	904b24 <cmnos_write_char>
                res++;
  904eca:	b122      	addi.n	a2, a2, 1
  904ecc:	d760      	mov.n	a7, a6
  904ece:	600007        	j	904ed9 <fw_cmnos_printf+0x389>
            }
            while (length-- > 0) {
                c = *cp++;
                (*putc)(c);
  904ed1:	2a7000        	l8ui	a10, a7, 0
  904ed4:	b177      	addi.n	a7, a7, 1
  904ed6:	5bff13        	call8	904b24 <cmnos_write_char>
  904ed9:	07480c        	sub	a8, a4, a7
  904edc:	a868      	add.n	a8, a6, a8
            }
            if (sign != '\0') {
                (*putc)(sign);
                res++;
            }
            while (length-- > 0) {
  904ede:	6b81ef        	bgei	a8, 1, 904ed1 <fw_cmnos_printf+0x381>
  904ee1:	c070      	movi.n	a7, 0
                c = *cp++;
                (*putc)(c);
                res++;
            }
            if (pad_on_right) {
  904ee3:	281217        	l32i	a8, a1, 92
  904ee6:	074735        	max	a7, a4, a7
  904ee9:	b044      	addi.n	a4, a4, -1
  904eeb:	a766      	add.n	a6, a6, a7
  904eed:	a722      	add.n	a2, a2, a7
  904eef:	07440c        	sub	a4, a4, a7
  904ef2:	ca87      	beqz.n	a8, 904f1d <fw_cmnos_printf+0x3cd>
  904ef4:	d730      	mov.n	a7, a3
                while (pad-- > 0) {
                    (*putc)(' ');
  904ef6:	c280      	movi.n	a8, 32
  904ef8:	60000d        	j	904f09 <fw_cmnos_printf+0x3b9>
  904efb:	00da80        	excw
  904efe:	281619        	s32i	a8, a1, 100
  904f01:	5bff08        	call8	904b24 <cmnos_write_char>
  904f04:	281219        	l32i	a8, a1, 100
  904f07:	b077      	addi.n	a7, a7, -1
                c = *cp++;
                (*putc)(c);
                res++;
            }
            if (pad_on_right) {
                while (pad-- > 0) {
  904f09:	6b71ef        	bgei	a7, 1, 904efc <fw_cmnos_printf+0x3ac>
  904f0c:	c070      	movi.n	a7, 0
  904f0e:	073335        	max	a3, a3, a7
  904f11:	a322      	add.n	a2, a2, a3
  904f13:	600006        	j	904f1d <fw_cmnos_printf+0x3cd>
    int left_prec, right_prec, zero_fill, pad, pad_on_right,
        i, islong, islonglong;
    long val = 0;
    int res = 0, length = 0;

    while ((c = *fmt++) != '\0') {
  904f16:	b155      	addi.n	a5, a5, 1
                    (*putc)(' ');
                    res++;
                }
            }
        } else {
            (*putc)(c);
  904f18:	5bff02        	call8	904b24 <cmnos_write_char>
            res++;
  904f1b:	b122      	addi.n	a2, a2, 1
    int left_prec, right_prec, zero_fill, pad, pad_on_right,
        i, islong, islonglong;
    long val = 0;
    int res = 0, length = 0;

    while ((c = *fmt++) != '\0') {
  904f1d:	2a5000        	l8ui	a10, a5, 0
  904f20:	65ac5a        	bnez	a10, 904b7e <fw_cmnos_printf+0x2e>
  904f23:	d10f      	retw.n
                    sign = '\0';
                }
            } else {
                c = ' ';
            }
            if (!pad_on_right) {
  904f25:	291217        	l32i	a9, a1, 92
  904f28:	649f64        	beqz	a9, 904e90 <fw_cmnos_printf+0x340>
  904f2b:	63ff9d        	j	904ecc <fw_cmnos_printf+0x37c>
  904f2e:	000077        	excw
                    c = *fmt++;
                    islonglong = 1;
                }
            }
            // Fetch value [numeric descriptors only]
            switch (c) {
  904f31:	8902      	l32i.n	a9, a0, 8
  904f33:	63fd4d        	j	904c84 <fw_cmnos_printf+0x134>
  904f36:	78731e        	bltu	a7, a8, 904f58 <fw_cmnos_printf+0x408>
  904f39:	c474      	movi.n	a7, 68
  904f3b:	778902        	bne	a8, a7, 904f41 <fw_cmnos_printf+0x3f1>
  904f3e:	63fd42        	j	904c84 <fw_cmnos_printf+0x134>
  904f41:	787304        	bltu	a7, a8, 904f49 <fw_cmnos_printf+0x3f9>
  904f44:	c472      	movi.n	a7, 66
  904f46:	60002c        	j	904f76 <fw_cmnos_printf+0x426>
  904f49:	c575      	movi.n	a7, 85
  904f4b:	778902        	bne	a8, a7, 904f51 <fw_cmnos_printf+0x401>
  904f4e:	63fd32        	j	904c84 <fw_cmnos_printf+0x134>
  904f51:	c578      	movi.n	a7, 88
  904f53:	60001f        	j	904f76 <fw_cmnos_printf+0x426>
  904f56:	000027        	excw
  904f59:	0a7077        	excw
  904f5c:	8902      	l32i.n	a9, a0, 8
  904f5e:	63fd22        	j	904c84 <fw_cmnos_printf+0x134>
  904f61:	787305        	bltu	a7, a8, 904f6a <fw_cmnos_printf+0x41a>
  904f64:	270a64        	movi	a7, 100
  904f67:	60000b        	j	904f76 <fw_cmnos_printf+0x426>
  904f6a:	270a75        	movi	a7, 117
  904f6d:	778902        	bne	a8, a7, 904f73 <fw_cmnos_printf+0x423>
  904f70:	63fd10        	j	904c84 <fw_cmnos_printf+0x134>
  904f73:	270a78        	movi	a7, 120
  904f76:	778102        	beq	a8, a7, 904f7c <fw_cmnos_printf+0x42c>
  904f79:	63fd4b        	j	904cc8 <fw_cmnos_printf+0x178>
  904f7c:	63fd04        	j	904c84 <fw_cmnos_printf+0x134>
  904f7f:	002912        	srai	a9, a0, 2
                    sign = '\0';
                }
            } else {
                c = ' ';
            }
            if (!pad_on_right) {
  904f82:	17c280        	l32r	a7, 8f5984 <memset+0x107e8>
  904f85:	649f11        	beqz	a9, 904e9a <fw_cmnos_printf+0x34a>
  904f88:	63ff39        	j	904ec5 <fw_cmnos_printf+0x375>
  904f8b:	281217        	l32i	a8, a1, 92
  904f8e:	658f3a        	bnez	a8, 904ecc <fw_cmnos_printf+0x37c>
  904f91:	63ff03        	j	904e98 <fw_cmnos_printf+0x348>

00904f94 <ath_hal_attach_tgt>:

struct ath_hal*
ath_hal_attach_tgt(a_uint32_t devid,HAL_SOFTC sc,
		   adf_os_device_t dev,
		   a_uint32_t flags, HAL_STATUS *error)
{
  904f94:	6c1004        	entry	a1, 32
	struct ath_hal *ah = AH_NULL;

	ah = ar5416Attach(sc, dev, error);
  904f97:	dc60      	mov.n	a12, a6
  904f99:	db40      	mov.n	a11, a4
  904f9b:	da30      	mov.n	a10, a3
  904f9d:	5804c4        	call8	9062b0 <ar5416Attach>

	return ah;
}
  904fa0:	d2a0      	mov.n	a2, a10
  904fa2:	d10f      	retw.n

00904fa4 <ath_hal_getcapability>:

HAL_STATUS
ath_hal_getcapability(struct ath_hal *ah, HAL_CAPABILITY_TYPE type)
{
  904fa4:	6c1004        	entry	a1, 32
	const HAL_CAPABILITIES *pCap = &AH_PRIVATE(ah)->ah_caps;
	switch (type) {
  904fa7:	683111        	beqi	a3, 1, 904fbc <ath_hal_getcapability+0x18>
  904faa:	c93e      	beqz.n	a3, 904fcc <ath_hal_getcapability+0x28>
	case HAL_CAP_BSSIDMASK:
		return pCap->halBssIdMaskSupport ? HAL_OK : HAL_ENOTSUPP;
	case HAL_CAP_VEOL:
		return pCap->halVEOLSupport ? HAL_OK : HAL_ENOTSUPP;
	default:
		return HAL_EINVAL;
  904fac:	223cfe        	addi	a2, a3, -2
  904faf:	c081      	movi.n	a8, 1
  904fb1:	c030      	movi.n	a3, 0
  904fb3:	028338        	moveqz	a3, a8, a2
  904fb6:	bc32      	addi.n	a2, a3, 12
  904fb8:	d10f      	retw.n
  904fba:	000013        	srai	a0, a0, 16
	const HAL_CAPABILITIES *pCap = &AH_PRIVATE(ah)->ah_caps;
	switch (type) {
	case HAL_CAP_TSF_ADJUST:
		return HAL_ENOTSUPP;
	case HAL_CAP_BSSIDMASK:
		return pCap->halBssIdMaskSupport ? HAL_OK : HAL_ENOTSUPP;
  904fbd:	721322        	bltu	a1, a2, 904fe3 <ath_hal_computetxtime+0x7>
  904fc0:	222b03        	l32ai	a2, a2, 12
  904fc3:	2201c0        	l16ui	a2, a0, 0x180
  904fc6:	306000        	excw
  904fc9:	070000        	callx4	a0
	case HAL_CAP_VEOL:
		return pCap->halVEOLSupport ? HAL_OK : HAL_ENOTSUPP;
  904fcc:	22222b        	l32i	a2, a2, 172
  904fcf:	02f240        	extui	a2, a2, 15, 1
	const HAL_CAPABILITIES *pCap = &AH_PRIVATE(ah)->ah_caps;
	switch (type) {
	case HAL_CAP_TSF_ADJUST:
		return HAL_ENOTSUPP;
	case HAL_CAP_BSSIDMASK:
		return pCap->halBssIdMaskSupport ? HAL_OK : HAL_ENOTSUPP;
  904fd2:	c08d      	movi.n	a8, 13
  904fd4:	028338        	moveqz	a3, a8, a2
  904fd7:	d230      	mov.n	a2, a3
	case HAL_CAP_VEOL:
		return pCap->halVEOLSupport ? HAL_OK : HAL_ENOTSUPP;
	default:
		return HAL_EINVAL;
	}
}
  904fd9:	d10f      	retw.n
	...

00904fdc <ath_hal_computetxtime>:

a_uint16_t
ath_hal_computetxtime(struct ath_hal *ah,
		      const HAL_RATE_TABLE *rates, a_uint32_t frameLen, a_uint16_t rateix,
		      HAL_BOOL shortPreamble)
{
  904fdc:	6c1004        	entry	a1, 32
  904fdf:	05054f        	extui	a5, a5, 0, 16
  904fe2:	0c5511        	slli	a5, a5, 4
  904fe5:	a533      	add.n	a3, a3, a5
	a_uint32_t bitsPerSymbol, numBits, numSymbols, phyTime, txTime;
	a_uint32_t kbps;

	kbps = rates->info[rateix].rateKbps;
  904fe7:	8b3b      	l32i.n	a11, a3, 44

	/*
	 * index can be invalid duting dynamic Turbo transitions.
	 */
	if(kbps == 0) return 0;
  904fe9:	c020      	movi.n	a2, 0
  904feb:	72b15a        	beq	a11, a2, 905049 <ath_hal_computetxtime+0x6d>
	switch (rates->info[rateix].phy) {
  904fee:	253029        	l8ui	a5, a3, 41
  904ff1:	725107        	beq	a5, a2, 904ffc <ath_hal_computetxtime+0x20>
  904ff4:	68522d        	beqi	a5, 2, 905025 <ath_hal_computetxtime+0x49>
  904ff7:	60004b        	j	905046 <ath_hal_computetxtime+0x6a>
  904ffa:	000025        	excw

	case IEEE80211_T_CCK:
		phyTime = CCK_PREAMBLE_BITS + CCK_PLCP_BITS;
  904ffd:	0ac0c8        	excw
		if (shortPreamble && rates->info[rateix].shortPreamble)
  905000:	672330        	bgez	a2, 905334 <ar5416ProcRxDescFast_20+0x144>
  905003:	31220a        	excw
			phyTime >>= 1;
  905006:	600325        	j	90532f <ar5416ProcRxDescFast_20+0x13f>
  905009:	390d42        	excw
		numBits = frameLen << 3;
  90500c:	11084a        	l32r	a1, 8c7134 <_bss_end+0x3b992c>
		txTime = phyTime + ((numBits * 1000)/kbps);
  90500f:	1102aa        	l32r	a1, 8c5ab8 <_bss_end+0x3b82b0>
  905012:	0c0eaa        	excw
  905015:	11a2aa        	l32r	a1, 8edac0 <memset+0x8924>
  905018:	0daa11        	slli	a10, a10, 3
  90501b:	5b7f61        	call8	8e4da0 <__udivsi3>
		/* TODO: make sure the same value of txTime can use in all device */
		if (ath_hal_getcapability(ah, HAL_CAP_HT) != HAL_OK)
			txTime = txTime + CCK_SIFS_TIME;
  90501e:	baa2      	addi.n	a2, a10, 10
  905020:	a522      	add.n	a2, a2, a5
  905022:	600020        	j	905046 <ath_hal_computetxtime+0x6a>
		break;
	case IEEE80211_T_OFDM:
		/* full rate channel */
		bitsPerSymbol   = (kbps * OFDM_SYMBOL_TIME) / 1000;
  905025:	0eb211        	slli	a2, a11, 2
  905028:	1b7214        	l32r	a11, 8e1878 <athos_indirection_table_install+0x330>
		HALASSERT(bitsPerSymbol != 0);

		numBits = OFDM_PLCP_BITS + (frameLen << 3);
  90502b:	0d4411        	slli	a4, a4, 3
		if (ath_hal_getcapability(ah, HAL_CAP_HT) != HAL_OK)
			txTime = txTime + CCK_SIFS_TIME;
		break;
	case IEEE80211_T_OFDM:
		/* full rate channel */
		bitsPerSymbol   = (kbps * OFDM_SYMBOL_TIME) / 1000;
  90502e:	0b222a        	muluh	a2, a2, a11
		HALASSERT(bitsPerSymbol != 0);

		numBits = OFDM_PLCP_BITS + (frameLen << 3);
		numSymbols = asf_howmany(numBits, bitsPerSymbol);
  905031:	2a4c15        	addi	a10, a4, 21
		if (ath_hal_getcapability(ah, HAL_CAP_HT) != HAL_OK)
			txTime = txTime + CCK_SIFS_TIME;
		break;
	case IEEE80211_T_OFDM:
		/* full rate channel */
		bitsPerSymbol   = (kbps * OFDM_SYMBOL_TIME) / 1000;
  905034:	026214        	srli	a2, a2, 6
		HALASSERT(bitsPerSymbol != 0);

		numBits = OFDM_PLCP_BITS + (frameLen << 3);
		numSymbols = asf_howmany(numBits, bitsPerSymbol);
  905037:	022b02        	or	a11, a2, a2
  90503a:	02aa08        	add	a10, a10, a2
  90503d:	5b7f58        	call8	8e4da0 <__udivsi3>
		txTime = OFDM_PREAMBLE_TIME + (numSymbols * OFDM_SYMBOL_TIME);
  905040:	0ea211        	slli	a2, a10, 2
		/* TODO: make sure the same value of txTime can use in all device */
		if (ath_hal_getcapability(ah, HAL_CAP_HT) != HAL_OK)
			txTime = txTime + OFDM_SIFS_TIME;
  905043:	222c24        	addi	a2, a2, 36
		break;
	default:
		txTime = 0;
		break;
	}
	return txTime;
  905046:	02024f        	extui	a2, a2, 0, 16
}
  905049:	d10f      	retw.n
	...

0090504c <ath_hal_wait>:

#endif

HAL_BOOL
ath_hal_wait(struct ath_hal *ah, a_uint32_t reg, a_uint32_t mask, a_uint32_t val)
{
  90504c:	6c1004        	entry	a1, 32
				return AH_TRUE;
			OS_DELAY(10);
		}
	} else {
		for (i = 0; i < AH_TIMEOUT_11G; i++) {
			if ((ioread32_mac(reg) & mask) == val)
  90504f:	187215        	l32r	a8, 8e18a4 <athos_indirection_table_install+0x35c>

#endif

HAL_BOOL
ath_hal_wait(struct ath_hal *ah, a_uint32_t reg, a_uint32_t mask, a_uint32_t val)
{
  905052:	223ae8        	movi	a2, 0x3e8
				return AH_TRUE;
			OS_DELAY(10);
		}
	} else {
		for (i = 0; i < AH_TIMEOUT_11G; i++) {
			if ((ioread32_mac(reg) & mask) == val)
  905055:	083308        	add	a3, a3, a8
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  905058:	0c0200        	memw
  90505b:	8830      	l32i.n	a8, a3, 0
  90505d:	084801        	and	a8, a4, a8
  905060:	78510d        	beq	a5, a8, 905071 <ath_hal_wait+0x25>
				return AH_TRUE;
			OS_DELAY(10);
  905063:	2a0a0a        	movi	a10, 10
  905066:	222cff        	addi	a2, a2, -1
  905069:	5bfacf        	call8	903ba8 <ath_hal_delay>
			if ((ioread32_mac(reg) & mask) == val)
				return AH_TRUE;
			OS_DELAY(10);
		}
	} else {
		for (i = 0; i < AH_TIMEOUT_11G; i++) {
  90506c:	652fe8        	bnez	a2, 905058 <ath_hal_wait+0xc>
  90506f:	d10f      	retw.n
			if ((ioread32_mac(reg) & mask) == val)
				return AH_TRUE;
  905071:	c021      	movi.n	a2, 1
	}
	return AH_FALSE;

#undef AH_TIMEOUT_11N
#undef AH_TIMEOUT_11G
}
  905073:	d10f      	retw.n
  905075:	000000        	ill

00905078 <ar5416IsInterruptPending>:
/**********************/
/* Interrupt Handling */
/**********************/

HAL_BOOL ar5416IsInterruptPending(struct ath_hal *ah)
{
  905078:	6c1004        	entry	a1, 32
  90507b:	127216        	l32r	a2, 8e18d4 <athos_indirection_table_install+0x38c>
  90507e:	0c0200        	memw
  905081:	8820      	l32i.n	a8, a2, 0
		ioread32_mac(AR_INTR_ASYNC_CAUSE);
	/*
	 * Some platforms trigger our ISR before applying power to
	 * the card, so make sure.
	 */
	return ((host_isr != AR_INTR_SPURIOUS) && (host_isr & AR_INTR_MAC_IRQ));
  905083:	c020      	movi.n	a2, 0
  905085:	081940        	extui	a9, a8, 1, 1
  905088:	b188      	addi.n	a8, a8, 1
  90508a:	089239        	movnez	a2, a9, a8
}
  90508d:	d10f      	retw.n
	...

00905090 <ar5416SetInterrupts>:
	return AH_TRUE;
}

HAL_INT
ar5416SetInterrupts(struct ath_hal *ah, HAL_INT ints)
{
  905090:	6c1004        	entry	a1, 32
	struct ath_hal_5416 *ahp = AH5416(ah);
	a_uint32_t omask = ahp->ah_maskReg;
  905093:	2b2235        	l32i	a11, a2, 212
	a_uint32_t mask;

	if (omask & HAL_INT_GLOBAL) {
  905096:	67b00e        	bgez	a11, 9050a8 <ar5416SetInterrupts+0x18>
  905099:	187217        	l32r	a8, 8e18f8 <athos_indirection_table_install+0x3b0>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90509c:	c090      	movi.n	a9, 0
  90509e:	0c0200        	memw
  9050a1:	9980      	s32i.n	a9, a8, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  9050a3:	0c0200        	memw
  9050a6:	8880      	l32i.n	a8, a8, 0
		iowrite32_mac(AR_IER, AR_IER_DISABLE);
		(void) ioread32_mac(AR_IER);
	}

	mask = ints & HAL_INT_COMMON;
  9050a8:	187218        	l32r	a8, 8e1908 <athos_indirection_table_install+0x3c0>
#else
		mask |= AR_IMR_TXOK;
		mask |= AR_IMR_TXDESC;
#endif
		mask |= AR_IMR_TXERR;
		mask |= AR_IMR_TXEOL;
  9050ab:	295ac0        	movi	a9, 0x5c0
	if (omask & HAL_INT_GLOBAL) {
		iowrite32_mac(AR_IER, AR_IER_DISABLE);
		(void) ioread32_mac(AR_IER);
	}

	mask = ints & HAL_INT_COMMON;
  9050ae:	083801        	and	a8, a3, a8
	if (ints & HAL_INT_TX) {
  9050b1:	036a40        	extui	a10, a3, 6, 1
#else
		mask |= AR_IMR_TXOK;
		mask |= AR_IMR_TXDESC;
#endif
		mask |= AR_IMR_TXERR;
		mask |= AR_IMR_TXEOL;
  9050b4:	098902        	or	a9, a8, a9
  9050b7:	0a9839        	movnez	a8, a9, a10
	if (ints & HAL_INT_RX) {
		mask |= AR_IMR_RXERR;
#ifdef AR5416_INT_MITIGATION
		mask |=  AR_IMR_RXMINTR | AR_IMR_RXINTM;
#else
		mask |= AR_IMR_RXOK | AR_IMR_RXDESC;
  9050ba:	c097      	movi.n	a9, 7
  9050bc:	098902        	or	a9, a8, a9
		mask |= AR_IMR_TXDESC;
#endif
		mask |= AR_IMR_TXERR;
		mask |= AR_IMR_TXEOL;
	}
	if (ints & HAL_INT_RX) {
  9050bf:	030a40        	extui	a10, a3, 0, 1
		mask |= AR_IMR_RXERR;
#ifdef AR5416_INT_MITIGATION
		mask |=  AR_IMR_RXMINTR | AR_IMR_RXINTM;
#else
		mask |= AR_IMR_RXOK | AR_IMR_RXDESC;
  9050c2:	0a9839        	movnez	a8, a9, a10
#endif
	}

	if (ints & (HAL_INT_GTT | HAL_INT_CST)) {
  9050c5:	197219        	l32r	a9, 8e192c <athos_indirection_table_install+0x3e4>
  9050c8:	793005        	bnone	a3, a9, 9050d1 <ar5416SetInterrupts+0x41>
		mask |= AR_IMR_BCNMISC;
  9050cb:	19721a        	l32r	a9, 8e1934 <athos_indirection_table_install+0x3ec>
  9050ce:	098802        	or	a8, a8, a9
  9050d1:	19721b        	l32r	a9, 8e1940 <athos_indirection_table_install+0x3f8>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  9050d4:	0c0200        	memw
  9050d7:	9890      	s32i.n	a8, a9, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  9050d9:	0c0200        	memw
  9050dc:	8890      	l32i.n	a8, a9, 0
	}

	iowrite32_mac(AR_IMR, mask);
	(void) ioread32_mac(AR_IMR);
	ahp->ah_maskReg = ints;
  9050de:	232635        	s32i	a3, a2, 212

	/* Re-enable interrupts if they were enabled before. */
	if (ints & HAL_INT_GLOBAL) {
  9050e1:	67300f        	bgez	a3, 9050f4 <ar5416SetInterrupts+0x64>
  9050e4:	137217        	l32r	a3, 8e1940 <athos_indirection_table_install+0x3f8>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  9050e7:	c021      	movi.n	a2, 1
  9050e9:	0c0200        	memw
  9050ec:	9230      	s32i.n	a2, a3, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  9050ee:	0c0200        	memw
  9050f1:	223200        	l32i	a2, a3, 0
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  9050f4:	12721c        	l32r	a2, 8e1964 <athos_indirection_table_install+0x41c>
  9050f7:	c032      	movi.n	a3, 2
  9050f9:	0c0200        	memw
  9050fc:	9320      	s32i.n	a3, a2, 0
  9050fe:	12721d        	l32r	a2, 8e1974 <athos_indirection_table_install+0x42c>
  905101:	0c0200        	memw
  905104:	9320      	s32i.n	a3, a2, 0
  905106:	12721e        	l32r	a2, 8e1980 <athos_indirection_table_install+0x438>
  905109:	13721f        	l32r	a3, 8e1988 <athos_indirection_table_install+0x440>
  90510c:	0c0200        	memw
  90510f:	9320      	s32i.n	a3, a2, 0
	iowrite32_mac(AR_INTR_ASYNC_ENABLE, AR_INTR_MAC_IRQ);
	iowrite32_mac(AR_INTR_ASYNC_MASK, AR_INTR_MAC_IRQ);
	iowrite32_mac(AR_INTR_SYNC_ENABLE, AR_INTR_SYNC_ALL);

	return omask;
}
  905111:	d2b0      	mov.n	a2, a11
  905113:	d10f      	retw.n
  905115:	000000        	ill

00905118 <ar5416GetTsf64>:
/****************/

#define ATH9K_HTC_MAX_TSF_READ 3

u_int64_t ar5416GetTsf64(struct ath_hal *ah)
{
  905118:	6c1004        	entry	a1, 32
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90511b:	187220        	l32r	a8, 8e199c <athos_indirection_table_install+0x454>
  90511e:	1b7221        	l32r	a11, 8e19a4 <athos_indirection_table_install+0x45c>
  905121:	0c0200        	memw
  905124:	8a80      	l32i.n	a10, a8, 0
  905126:	c093      	movi.n	a9, 3
  905128:	0c0200        	memw
  90512b:	83b0      	l32i.n	a3, a11, 0
  90512d:	0c0200        	memw
  905130:	8280      	l32i.n	a2, a8, 0

	tsf_upper1 = ioread32_mac(AR_TSF_U32);
	for (i = 0; i < ATH9K_HTC_MAX_TSF_READ; i++) {
		tsf_lower = ioread32_mac(AR_TSF_L32);
		tsf_upper2 = ioread32_mac(AR_TSF_U32);
		if (tsf_upper2 == tsf_upper1)
  905132:	7a2106        	beq	a2, a10, 90513c <ar5416GetTsf64+0x24>
  905135:	b099      	addi.n	a9, a9, -1
  905137:	da20      	mov.n	a10, a2
{
	a_uint32_t tsf_lower, tsf_upper1, tsf_upper2;
	a_int32_t i;

	tsf_upper1 = ioread32_mac(AR_TSF_U32);
	for (i = 0; i < ATH9K_HTC_MAX_TSF_READ; i++) {
  905139:	659feb        	bnez	a9, 905128 <ar5416GetTsf64+0x10>
			break;
		tsf_upper1 = tsf_upper2;
	}

	return (((u_int64_t)tsf_upper2 << 32) | tsf_lower);
}
  90513c:	d10f      	retw.n
	...

00905140 <ar5416SetRxDP>:

/******/
/* RX */
/******/
void ar5416SetRxDP(struct ath_hal *ah, a_uint32_t rxdp)
{
  905140:	6c1004        	entry	a1, 32
  905143:	187222        	l32r	a8, 8e19cc <athos_indirection_table_install+0x484>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  905146:	0c0200        	memw
  905149:	9380      	s32i.n	a3, a8, 0
  90514b:	d10f      	retw.n
  90514d:	000000        	ill

00905150 <ar5416EnableReceive>:
			     & ~AR_RXCFG_ZLFDMA);
	}
}

void ar5416EnableReceive(struct ath_hal *ah)
{
  905150:	6c1004        	entry	a1, 32
  905153:	187223        	l32r	a8, 8e19e0 <athos_indirection_table_install+0x498>
  905156:	c094      	movi.n	a9, 4
  905158:	0c0200        	memw
  90515b:	9980      	s32i.n	a9, a8, 0
  90515d:	d10f      	retw.n
	...

00905160 <ar5416StopPcuReceive>:
	iowrite32_mac(AR_CR, AR_CR_RXE);
}

void ar5416StopPcuReceive(struct ath_hal *ah)
{
  905160:	6c1004        	entry	a1, 32
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  905163:	197224        	l32r	a9, 8e19f4 <athos_indirection_table_install+0x4ac>
	OS_REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_RX_DIS);
  905166:	c2a0      	movi.n	a10, 32
  905168:	0c0200        	memw
  90516b:	8890      	l32i.n	a8, a9, 0
  90516d:	0a8802        	or	a8, a8, a10
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  905170:	0c0200        	memw
  905173:	9890      	s32i.n	a8, a9, 0
  905175:	d10f      	retw.n
	...

00905178 <ar5416SetupRxDesc_20>:
}

HAL_BOOL ar5416SetupRxDesc_20(struct ath_rx_desc *ds,
			      a_uint32_t size, a_uint32_t flags)
{
  905178:	6c1004        	entry	a1, 32
	struct ar5416_desc *ads = AR5416DESC(ds);

	HALASSERT((size &~ AR_BufLen) == 0);

	ads->ds_ctl1 = size & AR_BufLen;
  90517b:	03084b        	extui	a8, a3, 0, 12
	if (flags & HAL_RXDESC_INTREQ)
  90517e:	7a4f16        	bbsi	a4, 26, 905198 <ar5416SetupRxDesc_20+0x20>
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	HALASSERT((size &~ AR_BufLen) == 0);

	ads->ds_ctl1 = size & AR_BufLen;
  905181:	088957        	extui	a9, a8, 24, 8
  905184:	29240c        	s8i	a9, a2, 12
  905187:	088814        	srli	a8, a8, 8
  90518a:	c090      	movi.n	a9, 0
  90518c:	29240d        	s8i	a9, a2, 13
  90518f:	28240e        	s8i	a8, a2, 14
  905192:	23240f        	s8i	a3, a2, 15
  905195:	60001a        	j	9051b3 <ar5416SetupRxDesc_20+0x3b>
	if (flags & HAL_RXDESC_INTREQ)
		ads->ds_ctl1 |= AR_RxIntrReq;
  905198:	137225        	l32r	a3, 8e1a2c <athos_indirection_table_install+0x4e4>
  90519b:	038802        	or	a8, a8, a3
  90519e:	088357        	extui	a3, a8, 24, 8
  9051a1:	23240c        	s8i	a3, a2, 12
  9051a4:	080357        	extui	a3, a8, 16, 8
  9051a7:	23240d        	s8i	a3, a2, 13
  9051aa:	088347        	extui	a3, a8, 8, 8
  9051ad:	23240e        	s8i	a3, a2, 14
  9051b0:	28240f        	s8i	a8, a2, 15

	/* this should be enough */
	ads->ds_rxstatus8 &= ~AR_RxDone;
  9051b3:	292030        	l8ui	a9, a2, 48
  9051b6:	c73e      	movi.n	a3, -2
  9051b8:	089810        	slli	a8, a9, 24
  9051bb:	292031        	l8ui	a9, a2, 49
  9051be:	009911        	slli	a9, a9, 16
  9051c1:	089902        	or	a9, a9, a8
  9051c4:	282032        	l8ui	a8, a2, 50
  9051c7:	088811        	slli	a8, a8, 8
  9051ca:	098902        	or	a9, a8, a9
  9051cd:	282033        	l8ui	a8, a2, 51
  9051d0:	098802        	or	a8, a8, a9
  9051d3:	038801        	and	a8, a8, a3
  9051d6:	088357        	extui	a3, a8, 24, 8
  9051d9:	232430        	s8i	a3, a2, 48
  9051dc:	080357        	extui	a3, a8, 16, 8
  9051df:	232431        	s8i	a3, a2, 49
  9051e2:	088347        	extui	a3, a8, 8, 8
  9051e5:	232432        	s8i	a3, a2, 50
  9051e8:	282433        	s8i	a8, a2, 51

	return AH_TRUE;
}
  9051eb:	c021      	movi.n	a2, 1
  9051ed:	d10f      	retw.n
	...

009051f0 <ar5416ProcRxDescFast_20>:

HAL_STATUS ar5416ProcRxDescFast_20(struct ath_hal *ah, struct ath_rx_desc *ds,
				   a_uint32_t pa, struct ath_desc *nds,
				   struct ath_rx_status *rx_stats)
{
  9051f0:	6c1004        	entry	a1, 32
	struct ar5416_desc ads;
	struct ar5416_desc *adsp = AR5416DESC(ds);
	struct ar5416_desc *ands = AR5416DESC(nds);

	if ((adsp->ds_rxstatus8 & AR_RxDone) == 0)
  9051f3:	223030        	l8ui	a2, a3, 48
  9051f6:	082810        	slli	a8, a2, 24
  9051f9:	223031        	l8ui	a2, a3, 49
  9051fc:	002211        	slli	a2, a2, 16
  9051ff:	082202        	or	a2, a2, a8
  905202:	283032        	l8ui	a8, a3, 50
  905205:	088811        	slli	a8, a8, 8
  905208:	028202        	or	a2, a8, a2
  90520b:	283033        	l8ui	a8, a3, 51
  90520e:	028802        	or	a8, a8, a2
		return HAL_EINPROGRESS;
  905211:	c02f      	movi.n	a2, 15
{
	struct ar5416_desc ads;
	struct ar5416_desc *adsp = AR5416DESC(ds);
	struct ar5416_desc *ands = AR5416DESC(nds);

	if ((adsp->ds_rxstatus8 & AR_RxDone) == 0)
  905213:	7f8f02        	bbsi	a8, 31, 905219 <ar5416ProcRxDescFast_20+0x29>
  905216:	6001b0        	j	9053ca <ar5416ProcRxDescFast_20+0x1da>
	/*
	 * Given the use of a self-linked tail be very sure that the hw is
	 * done with this descriptor; the hw may have done this descriptor
	 * once and picked it up again...make sure the hw has moved on.
	 */
	if ((ands->ds_rxstatus8 & AR_RxDone) == 0
  905219:	255033        	l8ui	a5, a5, 51
  90521c:	7f5f0d        	bbsi	a5, 31, 90522d <ar5416ProcRxDescFast_20+0x3d>
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90521f:	157222        	l32r	a5, 8e1aa8 <athos_indirection_table_install+0x560>
  905222:	0c0200        	memw
  905225:	8550      	l32i.n	a5, a5, 0
	    && ioread32_mac(AR_RXDP) == pa)
  905227:	754902        	bne	a4, a5, 90522d <ar5416ProcRxDescFast_20+0x3d>
  90522a:	60019c        	j	9053ca <ar5416ProcRxDescFast_20+0x1da>
	 * Next we fill in all values in a caller passed stack variable.
	 * This reduces the number of uncached accesses.
	 * Do this copy here, after the check so that when the checks fail, we
	 * dont end up copying the entire stats uselessly.
	 */
	ads.u.rx = adsp->u.rx;
  90522d:	223010        	l8ui	a2, a3, 16
  905230:	293018        	l8ui	a9, a3, 24
  905233:	082a10        	slli	a10, a2, 24
  905236:	223011        	l8ui	a2, a3, 17
  905239:	089910        	slli	a9, a9, 24
  90523c:	002211        	slli	a2, a2, 16
  90523f:	0a2202        	or	a2, a2, a10
  905242:	2a3012        	l8ui	a10, a3, 18
  905245:	2b301c        	l8ui	a11, a3, 28
  905248:	08aa11        	slli	a10, a10, 8
  90524b:	02a202        	or	a2, a10, a2
  90524e:	2a3013        	l8ui	a10, a3, 19
  905251:	08bb10        	slli	a11, a11, 24
  905254:	02aa02        	or	a10, a10, a2
  905257:	223014        	l8ui	a2, a3, 20
  90525a:	2c3020        	l8ui	a12, a3, 32
  90525d:	082e10        	slli	a14, a2, 24
  905260:	223015        	l8ui	a2, a3, 21
  905263:	08cc10        	slli	a12, a12, 24
  905266:	002211        	slli	a2, a2, 16
  905269:	0e2202        	or	a2, a2, a14
  90526c:	2e3016        	l8ui	a14, a3, 22
  90526f:	2d3024        	l8ui	a13, a3, 36
  905272:	08ee11        	slli	a14, a14, 8
  905275:	02e202        	or	a2, a14, a2
  905278:	2e3017        	l8ui	a14, a3, 23
  90527b:	08dd10        	slli	a13, a13, 24
  90527e:	02ee02        	or	a14, a14, a2
  905281:	223019        	l8ui	a2, a3, 25
  905284:	24301b        	l8ui	a4, a3, 27
  905287:	002211        	slli	a2, a2, 16
  90528a:	092902        	or	a9, a2, a9
  90528d:	22301a        	l8ui	a2, a3, 26
  905290:	2f3028        	l8ui	a15, a3, 40
  905293:	082211        	slli	a2, a2, 8
  905296:	092202        	or	a2, a2, a9
  905299:	29301d        	l8ui	a9, a3, 29
  90529c:	024202        	or	a2, a4, a2
  90529f:	009911        	slli	a9, a9, 16
  9052a2:	0b9b02        	or	a11, a9, a11
  9052a5:	29301e        	l8ui	a9, a3, 30
  9052a8:	24301f        	l8ui	a4, a3, 31
  9052ab:	089911        	slli	a9, a9, 8
  9052ae:	0b9902        	or	a9, a9, a11
  9052b1:	2b3021        	l8ui	a11, a3, 33
  9052b4:	08ff10        	slli	a15, a15, 24
  9052b7:	00bb11        	slli	a11, a11, 16
  9052ba:	0cbc02        	or	a12, a11, a12
  9052bd:	2b3022        	l8ui	a11, a3, 34
  9052c0:	094902        	or	a9, a4, a9
  9052c3:	08bb11        	slli	a11, a11, 8
  9052c6:	0cbb02        	or	a11, a11, a12
  9052c9:	2c3025        	l8ui	a12, a3, 37
  9052cc:	243023        	l8ui	a4, a3, 35
  9052cf:	00cc11        	slli	a12, a12, 16
  9052d2:	0dcd02        	or	a13, a12, a13
  9052d5:	2c3026        	l8ui	a12, a3, 38
  9052d8:	0b4b02        	or	a11, a4, a11
  9052db:	08cc11        	slli	a12, a12, 8
  9052de:	0dcc02        	or	a12, a12, a13
  9052e1:	2d3029        	l8ui	a13, a3, 41
  9052e4:	243027        	l8ui	a4, a3, 39
  9052e7:	00dd11        	slli	a13, a13, 16
  9052ea:	0fdf02        	or	a15, a13, a15
  9052ed:	2d302a        	l8ui	a13, a3, 42
  9052f0:	23302b        	l8ui	a3, a3, 43
  9052f3:	08dd11        	slli	a13, a13, 8
  9052f6:	0fdd02        	or	a13, a13, a15
  9052f9:	0d3d02        	or	a13, a3, a13

	rx_stats->rs_status = 0;
  9052fc:	c030      	movi.n	a3, 0
  9052fe:	23640a        	s8i	a3, a6, 10
	rx_stats->rs_flags = 0;
  905301:	23641a        	s8i	a3, a6, 26

	rx_stats->rs_datalen = ads.ds_rxstatus1 & AR_DataLen;
  905304:	0e034b        	extui	a3, a14, 0, 12
	rx_stats->rs_tstamp =  ads.AR_RcvTimestamp;
  905307:	9261      	s32i.n	a2, a6, 4
	ads.u.rx = adsp->u.rx;

	rx_stats->rs_status = 0;
	rx_stats->rs_flags = 0;

	rx_stats->rs_datalen = ads.ds_rxstatus1 & AR_DataLen;
  905309:	236504        	s16i	a3, a6, 8
	rx_stats->rs_tstamp =  ads.AR_RcvTimestamp;
  90530c:	c020      	movi.n	a2, 0
  90530e:	9260      	s32i.n	a2, a6, 0

	/* XXX what about KeyCacheMiss? */
	rx_stats->rs_rssi_combined = 
		MS(ads.ds_rxstatus4, AR_RxRSSICombined);
  905310:	0b8257        	extui	a2, a11, 24, 8

	rx_stats->rs_datalen = ads.ds_rxstatus1 & AR_DataLen;
	rx_stats->rs_tstamp =  ads.AR_RcvTimestamp;

	/* XXX what about KeyCacheMiss? */
	rx_stats->rs_rssi_combined = 
  905313:	22640c        	s8i	a2, a6, 12
		MS(ads.ds_rxstatus4, AR_RxRSSICombined);
	rx_stats->rs_rssi_ctl0 = MS(ads.ds_rxstatus0, AR_RxRSSIAnt00);
	rx_stats->rs_rssi_ctl1 = MS(ads.ds_rxstatus0, AR_RxRSSIAnt01);
  905316:	0a8214        	srli	a2, a10, 8
  905319:	22640e        	s8i	a2, a6, 14
	rx_stats->rs_rssi_ctl2 = MS(ads.ds_rxstatus0, AR_RxRSSIAnt02);
  90531c:	0a025f        	extui	a2, a10, 16, 16
  90531f:	22640f        	s8i	a2, a6, 15
	rx_stats->rs_rssi_ext0 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt10);
	rx_stats->rs_rssi_ext1 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt11);
  905322:	0b8214        	srli	a2, a11, 8
  905325:	226411        	s8i	a2, a6, 17
	rx_stats->rs_rssi_ext2 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt12);
  905328:	0b025f        	extui	a2, a11, 16, 16
  90532b:	226412        	s8i	a2, a6, 18
	rx_stats->rs_tstamp =  ads.AR_RcvTimestamp;

	/* XXX what about KeyCacheMiss? */
	rx_stats->rs_rssi_combined = 
		MS(ads.ds_rxstatus4, AR_RxRSSICombined);
	rx_stats->rs_rssi_ctl0 = MS(ads.ds_rxstatus0, AR_RxRSSIAnt00);
  90532e:	2a640d        	s8i	a10, a6, 13
	rx_stats->rs_rssi_ctl1 = MS(ads.ds_rxstatus0, AR_RxRSSIAnt01);
	rx_stats->rs_rssi_ctl2 = MS(ads.ds_rxstatus0, AR_RxRSSIAnt02);
	rx_stats->rs_rssi_ext0 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt10);
  905331:	2b6410        	s8i	a11, a6, 16
	 * Next we fill in all values in a caller passed stack variable.
	 * This reduces the number of uncached accesses.
	 * Do this copy here, after the check so that when the checks fail, we
	 * dont end up copying the entire stats uselessly.
	 */
	ads.u.rx = adsp->u.rx;
  905334:	0c4c02        	or	a12, a4, a12
	rx_stats->rs_rssi_ctl2 = MS(ads.ds_rxstatus0, AR_RxRSSIAnt02);
	rx_stats->rs_rssi_ext0 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt10);
	rx_stats->rs_rssi_ext1 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt11);
	rx_stats->rs_rssi_ext2 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt12);
	if (ads.ds_rxstatus8 & AR_RxKeyIdxValid)
		rx_stats->rs_keyix = MS(ads.ds_rxstatus8, AR_KeyIdx);
  905337:	089246        	extui	a2, a8, 9, 7
	rx_stats->rs_rssi_ctl1 = MS(ads.ds_rxstatus0, AR_RxRSSIAnt01);
	rx_stats->rs_rssi_ctl2 = MS(ads.ds_rxstatus0, AR_RxRSSIAnt02);
	rx_stats->rs_rssi_ext0 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt10);
	rx_stats->rs_rssi_ext1 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt11);
	rx_stats->rs_rssi_ext2 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt12);
	if (ads.ds_rxstatus8 & AR_RxKeyIdxValid)
  90533a:	778f02        	bbsi	a8, 23, 905340 <ar5416ProcRxDescFast_20+0x150>
		rx_stats->rs_keyix = MS(ads.ds_rxstatus8, AR_KeyIdx);
	else
		rx_stats->rs_keyix = HAL_RXKEYIX_INVALID;
  90533d:	22faff        	movi	a2, -1
  905340:	226413        	s8i	a2, a6, 19
	/* NB: caller expected to do rate table mapping */
	rx_stats->rs_rate = RXSTATUS_RATE(ah, (&ads));
	rx_stats->rs_more = (ads.ds_rxstatus1 & AR_RxMore) ? 1 : 0;

	rx_stats->rs_isaggr = (ads.ds_rxstatus8 & AR_RxAggr) ? 1 : 0;
  905343:	081250        	extui	a2, a8, 17, 1
	rx_stats->rs_moreaggr = (ads.ds_rxstatus8 & AR_RxMoreAggr) ? 1 : 0;
	rx_stats->rs_flags  |= (ads.ds_rxstatus3 & AR_GI) ? HAL_RX_GI : 0;
  905346:	090340        	extui	a3, a9, 0, 1
	if (ads.ds_rxstatus8 & AR_RxKeyIdxValid)
		rx_stats->rs_keyix = MS(ads.ds_rxstatus8, AR_KeyIdx);
	else
		rx_stats->rs_keyix = HAL_RXKEYIX_INVALID;
	/* NB: caller expected to do rate table mapping */
	rx_stats->rs_rate = RXSTATUS_RATE(ah, (&ads));
  905349:	0a8a57        	extui	a10, a10, 24, 8
	rx_stats->rs_more = (ads.ds_rxstatus1 & AR_RxMore) ? 1 : 0;
  90534c:	0ece40        	extui	a14, a14, 12, 1

	rx_stats->rs_isaggr = (ads.ds_rxstatus8 & AR_RxAggr) ? 1 : 0;
  90534f:	226417        	s8i	a2, a6, 23
	rx_stats->rs_moreaggr = (ads.ds_rxstatus8 & AR_RxMoreAggr) ? 1 : 0;
	rx_stats->rs_flags  |= (ads.ds_rxstatus3 & AR_GI) ? HAL_RX_GI : 0;
	rx_stats->rs_flags  |= (ads.ds_rxstatus3 & AR_2040) ? HAL_RX_2040 : 0;
  905352:	091940        	extui	a9, a9, 1, 1
	/* NB: caller expected to do rate table mapping */
	rx_stats->rs_rate = RXSTATUS_RATE(ah, (&ads));
	rx_stats->rs_more = (ads.ds_rxstatus1 & AR_RxMore) ? 1 : 0;

	rx_stats->rs_isaggr = (ads.ds_rxstatus8 & AR_RxAggr) ? 1 : 0;
	rx_stats->rs_moreaggr = (ads.ds_rxstatus8 & AR_RxMoreAggr) ? 1 : 0;
  905355:	080250        	extui	a2, a8, 16, 1
	rx_stats->rs_flags  |= (ads.ds_rxstatus3 & AR_GI) ? HAL_RX_GI : 0;
  905358:	0e3311        	slli	a3, a3, 2
	rx_stats->rs_flags  |= (ads.ds_rxstatus3 & AR_2040) ? HAL_RX_2040 : 0;
  90535b:	0d9911        	slli	a9, a9, 3
	if (ads.ds_rxstatus8 & AR_RxKeyIdxValid)
		rx_stats->rs_keyix = MS(ads.ds_rxstatus8, AR_KeyIdx);
	else
		rx_stats->rs_keyix = HAL_RXKEYIX_INVALID;
	/* NB: caller expected to do rate table mapping */
	rx_stats->rs_rate = RXSTATUS_RATE(ah, (&ads));
  90535e:	2a6414        	s8i	a10, a6, 20
	rx_stats->rs_more = (ads.ds_rxstatus1 & AR_RxMore) ? 1 : 0;
  905361:	2e6416        	s8i	a14, a6, 22

	rx_stats->rs_isaggr = (ads.ds_rxstatus8 & AR_RxAggr) ? 1 : 0;
	rx_stats->rs_moreaggr = (ads.ds_rxstatus8 & AR_RxMoreAggr) ? 1 : 0;
  905364:	226418        	s8i	a2, a6, 24
	rx_stats->rs_flags  |= (ads.ds_rxstatus3 & AR_GI) ? HAL_RX_GI : 0;
	rx_stats->rs_flags  |= (ads.ds_rxstatus3 & AR_2040) ? HAL_RX_2040 : 0;
  905367:	093302        	or	a3, a3, a9

	if (ads.ds_rxstatus8 & AR_PreDelimCRCErr)
  90536a:	798f04        	bbsi	a8, 25, 905372 <ar5416ProcRxDescFast_20+0x182>
  90536d:	600006        	j	905377 <ar5416ProcRxDescFast_20+0x187>
  905370:	0000c1        	excw
		rx_stats->rs_flags |= HAL_RX_DELIM_CRC_PRE;
  905373:	200233        	l32i	a0, a0, 204
  905376:	022364        	excw
  905379:	1a7d86        	l32r	a10, 8e4994 <vdesc_module_install+0x858>
	if (ads.ds_rxstatus8 & AR_PostDelimCRCErr)
  90537c:	0a2260        	excw
		rx_stats->rs_flags |= HAL_RX_DELIM_CRC_POST;
  90537f:	1ac230        	l32r	a10, 8f5c40 <memset+0x10aa4>
  905382:	032202        	or	a2, a2, a3
  905385:	22641a        	s8i	a2, a6, 26
	if (ads.ds_rxstatus8 & AR_DecryptBusyErr)
  905388:	71860a        	bbci	a8, 1, 905396 <ar5416ProcRxDescFast_20+0x1a6>
		rx_stats->rs_flags |= HAL_RX_DECRYPT_BUSY;
  90538b:	22601a        	l8ui	a2, a6, 26
  90538e:	c430      	movi.n	a3, 64
  905390:	032202        	or	a2, a2, a3
  905393:	22641a        	s8i	a2, a6, 26

	if ((ads.ds_rxstatus8 & AR_RxFrameOK) == 0) {
  905396:	c032      	movi.n	a3, 2
  905398:	738826        	bany	a8, a3, 9053c2 <ar5416ProcRxDescFast_20+0x1d2>
		 * when a CRC error is detected, but these are specious.
		 * Consequently we filter them out here so we don't
		 * confuse and/or complicate drivers.
		 */
		if (ads.ds_rxstatus8 & AR_CRCErr)
			rx_stats->rs_status |= HAL_RXERR_CRC;
  90539b:	c021      	movi.n	a2, 1
		 * indicates however that you can also get Michael errors
		 * when a CRC error is detected, but these are specious.
		 * Consequently we filter them out here so we don't
		 * confuse and/or complicate drivers.
		 */
		if (ads.ds_rxstatus8 & AR_CRCErr)
  90539d:	7d8f1e        	bbsi	a8, 29, 9053bf <ar5416ProcRxDescFast_20+0x1cf>
			rx_stats->rs_status |= HAL_RXERR_CRC;
		else if (ads.ds_rxstatus8 & AR_PHYErr) {
  9053a0:	c120      	movi.n	a2, 16
  9053a2:	72800b        	bnone	a8, a2, 9053b1 <ar5416ProcRxDescFast_20+0x1c1>
			a_uint32_t phyerr;

			rx_stats->rs_status |= HAL_RXERR_PHY;
			phyerr = MS(ads.ds_rxstatus8, AR_PHYErrCode);
  9053a5:	088814        	srli	a8, a8, 8
		if (ads.ds_rxstatus8 & AR_CRCErr)
			rx_stats->rs_status |= HAL_RXERR_CRC;
		else if (ads.ds_rxstatus8 & AR_PHYErr) {
			a_uint32_t phyerr;

			rx_stats->rs_status |= HAL_RXERR_PHY;
  9053a8:	23640a        	s8i	a3, a6, 10
			phyerr = MS(ads.ds_rxstatus8, AR_PHYErrCode);
			rx_stats->rs_phyerr = phyerr;
  9053ab:	28640b        	s8i	a8, a6, 11
  9053ae:	600010        	j	9053c2 <ar5416ProcRxDescFast_20+0x1d2>
		} else if (ads.ds_rxstatus8 & AR_DecryptCRCErr)
  9053b1:	c038      	movi.n	a3, 8
  9053b3:	738005        	bnone	a8, a3, 9053bc <ar5416ProcRxDescFast_20+0x1cc>
			rx_stats->rs_status |= HAL_RXERR_DECRYPT;
  9053b6:	23640a        	s8i	a3, a6, 10
  9053b9:	600005        	j	9053c2 <ar5416ProcRxDescFast_20+0x1d2>
		else if (ads.ds_rxstatus8 & AR_MichaelErr)
  9053bc:	7a8702        	bbci	a8, 26, 9053c2 <ar5416ProcRxDescFast_20+0x1d2>
			rx_stats->rs_status |= HAL_RXERR_MIC;
  9053bf:	22640a        	s8i	a2, a6, 10
	}
	rx_stats->evm0=ads.AR_RxEVM0;
  9053c2:	9b67      	s32i.n	a11, a6, 28
	rx_stats->evm1=ads.AR_RxEVM1;
  9053c4:	9c68      	s32i.n	a12, a6, 32
	rx_stats->evm2=ads.AR_RxEVM2;
  9053c6:	9d69      	s32i.n	a13, a6, 36

	return HAL_OK;
  9053c8:	c020      	movi.n	a2, 0
}
  9053ca:	d10f      	retw.n

009053cc <ar5416UpdateTxTrigLevel>:
/******/
/* TX */
/******/

HAL_BOOL ar5416UpdateTxTrigLevel(struct ath_hal *ah, HAL_BOOL bIncTrigLevel)
{
  9053cc:	6c1004        	entry	a1, 32
        HAL_INT omask;

        /*
         * Disable interrupts while futzing with the fifo level.
         */
        omask = ar5416SetInterrupts(ah, ahp->ah_maskReg &~ HAL_INT_GLOBAL);
  9053cf:	147226        	l32r	a4, 8e1c68 <athos_indirection_table_install+0x720>
  9053d2:	2b2235        	l32i	a11, a2, 212
  9053d5:	da20      	mov.n	a10, a2
  9053d7:	04bb01        	and	a11, a11, a4
  9053da:	5bff2d        	call8	905090 <ar5416SetInterrupts>
  9053dd:	147227        	l32r	a4, 8e1c7c <athos_indirection_table_install+0x734>
  9053e0:	0c0200        	memw
  9053e3:	8940      	l32i.n	a9, a4, 0

	txcfg = ioread32_mac(AR_TXCFG);
        curLevel = MS(txcfg, AR_FTRIG);
  9053e5:	094445        	extui	a4, a9, 4, 6
        newLevel = curLevel;

        if (bIncTrigLevel)  {
  9053e8:	c83a      	beqz.n	a3, 9053f6 <ar5416UpdateTxTrigLevel+0x2a>
		if (curLevel < MAX_TX_FIFO_THRESHOLD)
  9053ea:	c38f      	movi.n	a8, 63
  9053ec:	d340      	mov.n	a3, a4
  9053ee:	784128        	beq	a4, a8, 90541a <ar5416UpdateTxTrigLevel+0x4e>
			newLevel ++;
  9053f1:	b143      	addi.n	a3, a4, 1
  9053f3:	600006        	j	9053fd <ar5416UpdateTxTrigLevel+0x31>
  9053f6:	d340      	mov.n	a3, a4
        } else if (curLevel > MIN_TX_FIFO_THRESHOLD)
  9053f8:	6e421e        	bltui	a4, 2, 90541a <ar5416UpdateTxTrigLevel+0x4e>
                newLevel--;
  9053fb:	b043      	addi.n	a3, a4, -1
        if (newLevel != curLevel)
  9053fd:	743119        	beq	a3, a4, 90541a <ar5416UpdateTxTrigLevel+0x4e>
		iowrite32_mac(AR_TXCFG,
  905400:	2b3af0        	movi	a11, 0x3f0
  905403:	0c3811        	slli	a8, a3, 4
  905406:	0b8801        	and	a8, a8, a11
  905409:	2bca0f        	movi	a11, 0xfffffc0f
  90540c:	0b9901        	and	a9, a9, a11
  90540f:	098802        	or	a8, a8, a9
  905412:	197227        	l32r	a9, 8e1cb0 <athos_indirection_table_install+0x768>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  905415:	0c0200        	memw
  905418:	9890      	s32i.n	a8, a9, 0
			     (txcfg & ~AR_FTRIG) | SM(newLevel, AR_FTRIG));

        /* re-enable chip interrupts */
        ar5416SetInterrupts(ah, omask);
  90541a:	dba0      	mov.n	a11, a10
  90541c:	da20      	mov.n	a10, a2

        return (newLevel != curLevel);
  90541e:	03440c        	sub	a4, a4, a3
        if (newLevel != curLevel)
		iowrite32_mac(AR_TXCFG,
			     (txcfg & ~AR_FTRIG) | SM(newLevel, AR_FTRIG));

        /* re-enable chip interrupts */
        ar5416SetInterrupts(ah, omask);
  905421:	5bff1b        	call8	905090 <ar5416SetInterrupts>

        return (newLevel != curLevel);
  905424:	c031      	movi.n	a3, 1
  905426:	c020      	movi.n	a2, 0
  905428:	043239        	movnez	a2, a3, a4
}
  90542b:	d10f      	retw.n
  90542d:	000000        	ill

00905430 <ar5416SetTxDP>:

HAL_BOOL ar5416SetTxDP(struct ath_hal *ah, a_uint32_t q, a_uint32_t txdp)
{
  905430:	6c1004        	entry	a1, 32
         * Make sure that TXE is deasserted before setting the TXDP.  If TXE
         * is still asserted, setting TXDP will have no effect.
         */
	HALASSERT((ioread32_mac(AR_Q_TXE) & (1 << q)) == 0);

	iowrite32_mac(AR_QTXDP(q), txdp);
  905433:	187228        	l32r	a8, 8e1cd4 <athos_indirection_table_install+0x78c>
  905436:	0e3311        	slli	a3, a3, 2
  905439:	a833      	add.n	a3, a3, a8
  90543b:	0c0200        	memw
  90543e:	9430      	s32i.n	a4, a3, 0

        return AH_TRUE;
}
  905440:	c021      	movi.n	a2, 1
  905442:	d10f      	retw.n

00905444 <ar5416StartTxDma>:

HAL_BOOL ar5416StartTxDma(struct ath_hal *ah, a_uint32_t q)
{
  905444:	6c1004        	entry	a1, 32
        HALASSERT(AH5416(ah)->ah_txq[q].tqi_type != HAL_TX_QUEUE_INACTIVE);

        /* Check to be sure we're not enabling a q that has its TXD bit set. */
	HALASSERT((ioread32_mac(AR_Q_TXD) & (1 << q)) == 0);

	iowrite32_mac(AR_Q_TXE, 1 << q);
  905447:	c021      	movi.n	a2, 1
  905449:	187229        	l32r	a8, 8e1cf0 <athos_indirection_table_install+0x7a8>
  90544c:	003104        	ssl	a3
  90544f:	00231a        	sll	a3, a2
  905452:	0c0200        	memw
  905455:	9380      	s32i.n	a3, a8, 0

        return AH_TRUE;
}
  905457:	d10f      	retw.n
  905459:	000000        	ill

0090545c <ar5416NumTxPending>:

a_uint32_t ar5416NumTxPending(struct ath_hal *ah, a_uint32_t q)
{
  90545c:	6c1004        	entry	a1, 32
        a_uint32_t npend;

        HALASSERT(q < AH_PRIVATE(ah)->ah_caps.halTotalQueues);
        HALASSERT(AH5416(ah)->ah_txq[q].tqi_type != HAL_TX_QUEUE_INACTIVE);

	npend = ioread32_mac(AR_QSTS(q))
  90545f:	18722a        	l32r	a8, 8e1d08 <athos_indirection_table_install+0x7c0>
  905462:	0e3211        	slli	a2, a3, 2
  905465:	a822      	add.n	a2, a2, a8
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  905467:	0c0200        	memw
  90546a:	8220      	l32i.n	a2, a2, 0
  90546c:	020241        	extui	a2, a2, 0, 2
		& AR_Q_STS_PEND_FR_CNT;
        if (npend == 0) {
  90546f:	cd25      	bnez.n	a2, 905488 <ar5416NumTxPending+0x2c>
  905471:	187229        	l32r	a8, 8e1d18 <athos_indirection_table_install+0x7d0>
  905474:	0c0200        	memw
  905477:	8980      	l32i.n	a9, a8, 0
                /*
                 * Pending frame count (PFC) can momentarily go to zero
                 * while TXE remains asserted.  In other words a PFC of
                 * zero is not sufficient to say that the queue has stopped.
                 */
		if (ioread32_mac(AR_Q_TXE) & (1 << q))
  905479:	280a01        	movi	a8, 1
  90547c:	003104        	ssl	a3
  90547f:	00831a        	sll	a3, a8
  905482:	093301        	and	a3, a3, a9
  905485:	038239        	movnez	a2, a8, a3
			iowrite32_mac(AR_Q_RDYTIMESHDN, 1 << q);
                }
        }
#endif
        return npend;
}
  905488:	d10f      	retw.n
	...

0090548c <ar5416SetupTxDesc_20>:
			      a_uint32_t txRate0, a_uint32_t txTries0,
			      a_uint32_t keyIx,
			      a_uint32_t flags,
			      a_uint32_t rtsctsRate,
			      a_uint32_t rtsctsDuration)
{
  90548c:	6c1004        	entry	a1, 32

        struct ar5416_desc *ads = AR5416DESC(ds);

        (void) hdrLen;

        ads->ds_txstatus9 &= ~AR_TxDone;
  90548f:	29205c        	l8ui	a9, a2, 92
			      a_uint32_t txRate0, a_uint32_t txTries0,
			      a_uint32_t keyIx,
			      a_uint32_t flags,
			      a_uint32_t rtsctsRate,
			      a_uint32_t rtsctsDuration)
{
  905492:	d820      	mov.n	a8, a2

        struct ar5416_desc *ads = AR5416DESC(ds);

        (void) hdrLen;

        ads->ds_txstatus9 &= ~AR_TxDone;
  905494:	089210        	slli	a2, a9, 24
  905497:	29805d        	l8ui	a9, a8, 93
			      a_uint32_t txRate0, a_uint32_t txTries0,
			      a_uint32_t keyIx,
			      a_uint32_t flags,
			      a_uint32_t rtsctsRate,
			      a_uint32_t rtsctsDuration)
{
  90549a:	8a1a      	l32i.n	a10, a1, 40

        struct ar5416_desc *ads = AR5416DESC(ds);

        (void) hdrLen;

        ads->ds_txstatus9 &= ~AR_TxDone;
  90549c:	009911        	slli	a9, a9, 16
  90549f:	029902        	or	a9, a9, a2
  9054a2:	22805e        	l8ui	a2, a8, 94
        HALASSERT((flags & RTSCTS) != RTSCTS);

        if (txPower > 63)
		txPower=63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
  9054a5:	03034b        	extui	a3, a3, 0, 12

        struct ar5416_desc *ads = AR5416DESC(ds);

        (void) hdrLen;

        ads->ds_txstatus9 &= ~AR_TxDone;
  9054a8:	082211        	slli	a2, a2, 8
  9054ab:	092902        	or	a9, a2, a9
  9054ae:	22805f        	l8ui	a2, a8, 95
		txPower=63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
		| (txPower << AR_XmitPower_S)
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
  9054b1:	1c722b        	l32r	a12, 8e1d60 <athos_indirection_table_install+0x818>

        struct ar5416_desc *ads = AR5416DESC(ds);

        (void) hdrLen;

        ads->ds_txstatus9 &= ~AR_TxDone;
  9054b4:	092202        	or	a2, a2, a9
  9054b7:	c79e      	movi.n	a9, -2
  9054b9:	092201        	and	a2, a2, a9
  9054bc:	028957        	extui	a9, a2, 24, 8
  9054bf:	29845c        	s8i	a9, a8, 92
  9054c2:	020957        	extui	a9, a2, 16, 8
  9054c5:	29845d        	s8i	a9, a8, 93
  9054c8:	028947        	extui	a9, a2, 8, 8
  9054cb:	29845e        	s8i	a9, a8, 94

        if (txPower > 63)
		txPower=63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
		| (txPower << AR_XmitPower_S)
  9054ce:	c39f      	movi.n	a9, 63
  9054d0:	096936        	minu	a9, a6, a9
  9054d3:	009911        	slli	a9, a9, 16
  9054d6:	039302        	or	a3, a9, a3

        struct ar5416_desc *ads = AR5416DESC(ds);

        (void) hdrLen;

        ads->ds_txstatus9 &= ~AR_TxDone;
  9054d9:	22845f        	s8i	a2, a8, 95
        if (txPower > 63)
		txPower=63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
		| (txPower << AR_XmitPower_S)
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
  9054dc:	c290      	movi.n	a9, 32
  9054de:	12721a        	l32r	a2, 8e1d48 <athos_indirection_table_install+0x800>
  9054e1:	09a901        	and	a9, a10, a9
  9054e4:	092939        	movnez	a9, a2, a9
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
  9054e7:	c0e0      	movi.n	a14, 0
        if (txPower > 63)
		txPower=63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
		| (txPower << AR_XmitPower_S)
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
  9054e9:	039902        	or	a9, a9, a3
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
  9054ec:	d2c0      	mov.n	a2, a12
  9054ee:	0a0340        	extui	a3, a10, 0, 1
  9054f1:	03e238        	moveqz	a2, a14, a3
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0);
  9054f4:	c1f0      	movi.n	a15, 16
		txPower=63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
		| (txPower << AR_XmitPower_S)
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
  9054f6:	092902        	or	a9, a2, a9
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0);
  9054f9:	12722c        	l32r	a2, 8e1dac <athos_indirection_table_install+0x864>
  9054fc:	0fa301        	and	a3, a10, a15
  9054ff:	032339        	movnez	a3, a2, a3
  905502:	093902        	or	a9, a3, a9
        HALASSERT((flags & RTSCTS) != RTSCTS);

        if (txPower > 63)
		txPower=63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
  905505:	098257        	extui	a2, a9, 24, 8
  905508:	228408        	s8i	a2, a8, 8
  90550b:	090257        	extui	a2, a9, 16, 8
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0);

        ads->ds_ctl1 = (type << AR_FrameType_S)
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0);
  90550e:	c032      	movi.n	a3, 2
        HALASSERT((flags & RTSCTS) != RTSCTS);

        if (txPower > 63)
		txPower=63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
  905510:	228409        	s8i	a2, a8, 9
  905513:	098247        	extui	a2, a9, 8, 8
  905516:	22840a        	s8i	a2, a8, 10
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0);

        ads->ds_ctl1 = (type << AR_FrameType_S)
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0);
  905519:	03a201        	and	a2, a10, a3
		| (txPower << AR_XmitPower_S)
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0);

        ads->ds_ctl1 = (type << AR_FrameType_S)
  90551c:	0c5510        	slli	a5, a5, 20
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0);
  90551f:	02ec38        	moveqz	a12, a14, a2
  905522:	05c202        	or	a2, a12, a5
		| (txPower << AR_XmitPower_S)
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0);

        ads->ds_ctl1 = (type << AR_FrameType_S)
  905525:	028557        	extui	a5, a2, 24, 8
  905528:	25840c        	s8i	a5, a8, 12
  90552b:	020557        	extui	a5, a2, 16, 8
  90552e:	25840d        	s8i	a5, a8, 13
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0);
        ads->ds_ctl2 = SM(txTries0, AR_XmitDataTries0);
  905531:	8c18      	l32i.n	a12, a1, 32
		| (txPower << AR_XmitPower_S)
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0);

        ads->ds_ctl1 = (type << AR_FrameType_S)
  905533:	028547        	extui	a5, a2, 8, 8
  905536:	25840e        	s8i	a5, a8, 14
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0);
        ads->ds_ctl2 = SM(txTries0, AR_XmitDataTries0);
  905539:	15722f        	l32r	a5, 8e1df8 <athos_indirection_table_install+0x8b0>
  90553c:	00f104        	ssl	a15
  90553f:	00cc1a        	sll	a12, a12
  905542:	05cc01        	and	a12, a12, a5
  905545:	0c8557        	extui	a5, a12, 24, 8
  905548:	258410        	s8i	a5, a8, 16
  90554b:	0c0557        	extui	a5, a12, 16, 8
  90554e:	258411        	s8i	a5, a8, 17
        ads->ds_ctl3 = (txRate0 << AR_XmitRate0_S);
  905551:	078557        	extui	a5, a7, 24, 8
  905554:	258414        	s8i	a5, a8, 20
  905557:	070557        	extui	a5, a7, 16, 8
  90555a:	258415        	s8i	a5, a8, 21
  90555d:	078547        	extui	a5, a7, 8, 8
        HALASSERT((flags & RTSCTS) != RTSCTS);

        if (txPower > 63)
		txPower=63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
  905560:	29840b        	s8i	a9, a8, 11
		| (txPower << AR_XmitPower_S)
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0);

        ads->ds_ctl1 = (type << AR_FrameType_S)
  905563:	22840f        	s8i	a2, a8, 15
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0);
        ads->ds_ctl2 = SM(txTries0, AR_XmitDataTries0);
  905566:	2e8412        	s8i	a14, a8, 18
  905569:	2e8413        	s8i	a14, a8, 19
        ads->ds_ctl3 = (txRate0 << AR_XmitRate0_S);
  90556c:	258416        	s8i	a5, a8, 22
  90556f:	278417        	s8i	a7, a8, 23
			      a_uint32_t txRate0, a_uint32_t txTries0,
			      a_uint32_t keyIx,
			      a_uint32_t flags,
			      a_uint32_t rtsctsRate,
			      a_uint32_t rtsctsDuration)
{
  905572:	8d19      	l32i.n	a13, a1, 36
  905574:	2b120b        	l32i	a11, a1, 44
        ads->ds_ctl1 = (type << AR_FrameType_S)
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0);
        ads->ds_ctl2 = SM(txTries0, AR_XmitDataTries0);
        ads->ds_ctl3 = (txRate0 << AR_XmitRate0_S);

        ads->ds_ctl7 = SM(AR5416_LEGACY_CHAINMASK, AR_ChainSel0) 
  905577:	2e8424        	s8i	a14, a8, 36
  90557a:	238425        	s8i	a3, a8, 37
  90557d:	23fa84        	movi	a3, -124
  905580:	238427        	s8i	a3, a8, 39
  905583:	2f8426        	s8i	a15, a8, 38
		| SM(AR5416_LEGACY_CHAINMASK, AR_ChainSel1)
		| SM(AR5416_LEGACY_CHAINMASK, AR_ChainSel2) 
		| SM(AR5416_LEGACY_CHAINMASK, AR_ChainSel3);

        if (keyIx != HAL_TXKEYIX_INVALID) {
  905586:	230aff        	movi	a3, 255
  905589:	73d13b        	beq	a13, a3, 9055c8 <ar5416SetupTxDesc_20+0x13c>
                /* XXX validate key index */
                ads->ds_ctl1 |= SM(keyIx, AR_DestIdx);
  90558c:	137230        	l32r	a3, 8e1e4c <athos_indirection_table_install+0x904>
  90558f:	03d511        	slli	a5, a13, 13
  905592:	035501        	and	a5, a5, a3
  905595:	025502        	or	a5, a5, a2
  905598:	058257        	extui	a2, a5, 24, 8
  90559b:	22840c        	s8i	a2, a8, 12
  90559e:	050257        	extui	a2, a5, 16, 8
  9055a1:	22840d        	s8i	a2, a8, 13
  9055a4:	058247        	extui	a2, a5, 8, 8
  9055a7:	22840e        	s8i	a2, a8, 14
                ads->ds_ctl0 |= AR_DestIdxValid;
  9055aa:	127231        	l32r	a2, 8e1e70 <athos_indirection_table_install+0x928>
		| SM(AR5416_LEGACY_CHAINMASK, AR_ChainSel2) 
		| SM(AR5416_LEGACY_CHAINMASK, AR_ChainSel3);

        if (keyIx != HAL_TXKEYIX_INVALID) {
                /* XXX validate key index */
                ads->ds_ctl1 |= SM(keyIx, AR_DestIdx);
  9055ad:	25840f        	s8i	a5, a8, 15
                ads->ds_ctl0 |= AR_DestIdxValid;
  9055b0:	029902        	or	a9, a9, a2
  9055b3:	098257        	extui	a2, a9, 24, 8
  9055b6:	228408        	s8i	a2, a8, 8
  9055b9:	090257        	extui	a2, a9, 16, 8
  9055bc:	228409        	s8i	a2, a8, 9
  9055bf:	098247        	extui	a2, a9, 8, 8
  9055c2:	22840a        	s8i	a2, a8, 10
  9055c5:	29840b        	s8i	a9, a8, 11
        }

        if (flags & RTSCTS) {
  9055c8:	c03c      	movi.n	a3, 12
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
                ads->ds_ctl2 |= SM(rtsctsDuration, AR_BurstDur);
                ads->ds_ctl3 |= (rtsctsRate << AR_RTSCTSRate_S);
        }
        return AH_TRUE;
  9055ca:	c021      	movi.n	a2, 1
                /* XXX validate key index */
                ads->ds_ctl1 |= SM(keyIx, AR_DestIdx);
                ads->ds_ctl0 |= AR_DestIdxValid;
        }

        if (flags & RTSCTS) {
  9055cc:	73a802        	bany	a10, a3, 9055d2 <ar5416SetupTxDesc_20+0x146>
  9055cf:	60009d        	j	905670 <ar5416SetupTxDesc_20+0x1e4>
                if (!isValidTxRate(rtsctsRate)) {
  9055d2:	137232        	l32r	a3, 8e1e9c <athos_indirection_table_install+0x954>
  9055d5:	00b004        	ssr	a11
  9055d8:	03031b        	sra	a3, a3
  9055db:	023301        	and	a3, a3, a2
  9055de:	64308c        	beqz	a3, 90566e <ar5416SetupTxDesc_20+0x1e2>
                        return AH_FALSE;
                }
                /* XXX validate rtsctsDuration */
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
  9055e1:	298008        	l8ui	a9, a8, 8
  9055e4:	238009        	l8ui	a3, a8, 9
  9055e7:	089910        	slli	a9, a9, 24
  9055ea:	003311        	slli	a3, a3, 16
  9055ed:	093902        	or	a9, a3, a9
  9055f0:	23800a        	l8ui	a3, a8, 10
  9055f3:	1d722d        	l32r	a13, 8e1ea8 <athos_indirection_table_install+0x960>
  9055f6:	083311        	slli	a3, a3, 8
  9055f9:	093302        	or	a3, a3, a9
  9055fc:	29800b        	l8ui	a9, a8, 11
  9055ff:	c050      	movi.n	a5, 0
  905601:	039302        	or	a3, a9, a3
  905604:	c098      	movi.n	a9, 8
  905606:	09a901        	and	a9, a10, a9
  905609:	095d38        	moveqz	a13, a5, a9
  90560c:	d9d0      	mov.n	a9, a13
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
  90560e:	c0d4      	movi.n	a13, 4
  905610:	0daa01        	and	a10, a10, a13
  905613:	1d722e        	l32r	a13, 8e1ecc <athos_indirection_table_install+0x984>
        if (flags & RTSCTS) {
                if (!isValidTxRate(rtsctsRate)) {
                        return AH_FALSE;
                }
                /* XXX validate rtsctsDuration */
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
  905616:	039902        	or	a9, a9, a3
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
  905619:	0a5d38        	moveqz	a13, a5, a10
        if (flags & RTSCTS) {
                if (!isValidTxRate(rtsctsRate)) {
                        return AH_FALSE;
                }
                /* XXX validate rtsctsDuration */
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
  90561c:	0d9902        	or	a9, a9, a13
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
                ads->ds_ctl2 |= SM(rtsctsDuration, AR_BurstDur);
  90561f:	851c      	l32i.n	a5, a1, 48
        if (flags & RTSCTS) {
                if (!isValidTxRate(rtsctsRate)) {
                        return AH_FALSE;
                }
                /* XXX validate rtsctsDuration */
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
  905621:	098357        	extui	a3, a9, 24, 8
  905624:	238408        	s8i	a3, a8, 8
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
                ads->ds_ctl2 |= SM(rtsctsDuration, AR_BurstDur);
  905627:	05054e        	extui	a5, a5, 0, 15
        if (flags & RTSCTS) {
                if (!isValidTxRate(rtsctsRate)) {
                        return AH_FALSE;
                }
                /* XXX validate rtsctsDuration */
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
  90562a:	090357        	extui	a3, a9, 16, 8
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
                ads->ds_ctl2 |= SM(rtsctsDuration, AR_BurstDur);
  90562d:	0c5c02        	or	a12, a5, a12
        if (flags & RTSCTS) {
                if (!isValidTxRate(rtsctsRate)) {
                        return AH_FALSE;
                }
                /* XXX validate rtsctsDuration */
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
  905630:	238409        	s8i	a3, a8, 9
  905633:	098347        	extui	a3, a9, 8, 8
  905636:	23840a        	s8i	a3, a8, 10
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
                ads->ds_ctl2 |= SM(rtsctsDuration, AR_BurstDur);
  905639:	0c8357        	extui	a3, a12, 24, 8
  90563c:	238410        	s8i	a3, a8, 16
                ads->ds_ctl3 |= (rtsctsRate << AR_RTSCTSRate_S);
  90563f:	0cbb10        	slli	a11, a11, 20
                        return AH_FALSE;
                }
                /* XXX validate rtsctsDuration */
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
                ads->ds_ctl2 |= SM(rtsctsDuration, AR_BurstDur);
  905642:	0c0357        	extui	a3, a12, 16, 8
                ads->ds_ctl3 |= (rtsctsRate << AR_RTSCTSRate_S);
  905645:	07b702        	or	a7, a11, a7
                        return AH_FALSE;
                }
                /* XXX validate rtsctsDuration */
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
                ads->ds_ctl2 |= SM(rtsctsDuration, AR_BurstDur);
  905648:	238411        	s8i	a3, a8, 17
  90564b:	0c8346        	extui	a3, a12, 8, 7
  90564e:	238412        	s8i	a3, a8, 18
                ads->ds_ctl3 |= (rtsctsRate << AR_RTSCTSRate_S);
  905651:	078357        	extui	a3, a7, 24, 8
  905654:	238414        	s8i	a3, a8, 20
  905657:	070357        	extui	a3, a7, 16, 8
  90565a:	238415        	s8i	a3, a8, 21
  90565d:	078347        	extui	a3, a7, 8, 8
        if (flags & RTSCTS) {
                if (!isValidTxRate(rtsctsRate)) {
                        return AH_FALSE;
                }
                /* XXX validate rtsctsDuration */
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
  905660:	29840b        	s8i	a9, a8, 11
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
                ads->ds_ctl2 |= SM(rtsctsDuration, AR_BurstDur);
  905663:	2c8413        	s8i	a12, a8, 19
                ads->ds_ctl3 |= (rtsctsRate << AR_RTSCTSRate_S);
  905666:	238416        	s8i	a3, a8, 22
  905669:	278417        	s8i	a7, a8, 23
  90566c:	d10f      	retw.n
                ads->ds_ctl0 |= AR_DestIdxValid;
        }

        if (flags & RTSCTS) {
                if (!isValidTxRate(rtsctsRate)) {
                        return AH_FALSE;
  90566e:	d230      	mov.n	a2, a3
                ads->ds_ctl3 |= (rtsctsRate << AR_RTSCTSRate_S);
        }
        return AH_TRUE;

#undef RTSCTS
}
  905670:	d10f      	retw.n
	...

00905674 <ar5416FillTxDesc_20>:

HAL_BOOL ar5416FillTxDesc_20(struct ath_tx_desc *ds,
			     a_uint32_t segLen, HAL_BOOL firstSeg, HAL_BOOL lastSeg,
			     const struct ath_tx_desc *ds0)
{
  905674:	6c1004        	entry	a1, 32
        struct ar5416_desc *ads = AR5416DESC(ds);

        HALASSERT((segLen &~ AR_BufLen) == 0);

        if (firstSeg) {
  905677:	644045        	beqz	a4, 9056c0 <ar5416FillTxDesc_20+0x4c>
                /*
                 * First descriptor, don't clobber xmit control data
                 * setup by ar5416SetupTxDesc.
                 */
                ads->ds_ctl1 |= segLen | (lastSeg ? 0 : AR_TxMore);
  90567a:	24200c        	l8ui	a4, a2, 12
  90567d:	c060      	movi.n	a6, 0
  90567f:	084810        	slli	a8, a4, 24
  905682:	24200d        	l8ui	a4, a2, 13
  905685:	004411        	slli	a4, a4, 16
  905688:	084402        	or	a4, a4, a8
  90568b:	28200e        	l8ui	a8, a2, 14
  90568e:	088811        	slli	a8, a8, 8
  905691:	048402        	or	a4, a8, a4
  905694:	28200f        	l8ui	a8, a2, 15
  905697:	048802        	or	a8, a8, a4
  90569a:	1471f2        	l32r	a4, 8e1e64 <athos_indirection_table_install+0x91c>
  90569d:	038302        	or	a3, a8, a3
  9056a0:	054638        	moveqz	a6, a4, a5
  9056a3:	063302        	or	a3, a3, a6
  9056a6:	038457        	extui	a4, a3, 24, 8
  9056a9:	24240c        	s8i	a4, a2, 12
  9056ac:	030457        	extui	a4, a3, 16, 8
  9056af:	24240d        	s8i	a4, a2, 13
  9056b2:	038447        	extui	a4, a3, 8, 8
  9056b5:	d560      	mov.n	a5, a6
  9056b7:	24240e        	s8i	a4, a2, 14
  9056ba:	23240f        	s8i	a3, a2, 15
  9056bd:	6000cb        	j	90578c <ar5416FillTxDesc_20+0x118>
        } else if (lastSeg) {
  9056c0:	645089        	beqz	a5, 90574d <ar5416FillTxDesc_20+0xd9>
                /*
                 * Last descriptor in a multi-descriptor frame,
                 * copy the multi-rate transmit parameters from
                 * the first frame for processing on completion.
                 */
                ads->ds_ctl0 = 0;
  9056c3:	242408        	s8i	a4, a2, 8
  9056c6:	242409        	s8i	a4, a2, 9
  9056c9:	24240a        	s8i	a4, a2, 10
  9056cc:	24240b        	s8i	a4, a2, 11
                ads->ds_ctl1 = segLen;
  9056cf:	038457        	extui	a4, a3, 24, 8
  9056d2:	24240c        	s8i	a4, a2, 12
  9056d5:	030457        	extui	a4, a3, 16, 8
  9056d8:	24240d        	s8i	a4, a2, 13
  9056db:	038447        	extui	a4, a3, 8, 8
  9056de:	24240e        	s8i	a4, a2, 14
  9056e1:	23240f        	s8i	a3, a2, 15
                ads->ds_ctl2 = AR5416DESC_CONST(ds0)->ds_ctl2;
  9056e4:	256010        	l8ui	a5, a6, 16
  9056e7:	085310        	slli	a3, a5, 24
  9056ea:	256011        	l8ui	a5, a6, 17
  9056ed:	005511        	slli	a5, a5, 16
  9056f0:	035502        	or	a5, a5, a3
  9056f3:	236012        	l8ui	a3, a6, 18
  9056f6:	083311        	slli	a3, a3, 8
  9056f9:	053502        	or	a5, a3, a5
  9056fc:	236013        	l8ui	a3, a6, 19
  9056ff:	053302        	or	a3, a3, a5
  905702:	038457        	extui	a4, a3, 24, 8
  905705:	242410        	s8i	a4, a2, 16
  905708:	030457        	extui	a4, a3, 16, 8
  90570b:	242411        	s8i	a4, a2, 17
  90570e:	038447        	extui	a4, a3, 8, 8
  905711:	242412        	s8i	a4, a2, 18
  905714:	232413        	s8i	a3, a2, 19
                ads->ds_ctl3 = AR5416DESC_CONST(ds0)->ds_ctl3;
  905717:	256014        	l8ui	a5, a6, 20
  90571a:	085310        	slli	a3, a5, 24
  90571d:	256015        	l8ui	a5, a6, 21
  905720:	005511        	slli	a5, a5, 16
  905723:	035502        	or	a5, a5, a3
  905726:	236016        	l8ui	a3, a6, 22
  905729:	083311        	slli	a3, a3, 8
  90572c:	053502        	or	a5, a3, a5
  90572f:	236017        	l8ui	a3, a6, 23
  905732:	053302        	or	a3, a3, a5
  905735:	038457        	extui	a4, a3, 24, 8
  905738:	242414        	s8i	a4, a2, 20
  90573b:	030457        	extui	a4, a3, 16, 8
  90573e:	242415        	s8i	a4, a2, 21
  905741:	038447        	extui	a4, a3, 8, 8
  905744:	242416        	s8i	a4, a2, 22
  905747:	232417        	s8i	a3, a2, 23
  90574a:	60003e        	j	90578c <ar5416FillTxDesc_20+0x118>
        } else {
                /*
                 * Intermediate descriptor in a multi-descriptor frame.
                 */
                ads->ds_ctl0 = 0;
                ads->ds_ctl1 = segLen | AR_TxMore;
  90574d:	1471f2        	l32r	a4, 8e1f18 <athos_indirection_table_install+0x9d0>
                ads->ds_ctl3 = AR5416DESC_CONST(ds0)->ds_ctl3;
        } else {
                /*
                 * Intermediate descriptor in a multi-descriptor frame.
                 */
                ads->ds_ctl0 = 0;
  905750:	252408        	s8i	a5, a2, 8
                ads->ds_ctl1 = segLen | AR_TxMore;
  905753:	043302        	or	a3, a3, a4
  905756:	038457        	extui	a4, a3, 24, 8
  905759:	24240c        	s8i	a4, a2, 12
  90575c:	030457        	extui	a4, a3, 16, 8
  90575f:	24240d        	s8i	a4, a2, 13
  905762:	038447        	extui	a4, a3, 8, 8
                ads->ds_ctl3 = AR5416DESC_CONST(ds0)->ds_ctl3;
        } else {
                /*
                 * Intermediate descriptor in a multi-descriptor frame.
                 */
                ads->ds_ctl0 = 0;
  905765:	252409        	s8i	a5, a2, 9
  905768:	25240a        	s8i	a5, a2, 10
  90576b:	25240b        	s8i	a5, a2, 11
                ads->ds_ctl1 = segLen | AR_TxMore;
  90576e:	24240e        	s8i	a4, a2, 14
  905771:	23240f        	s8i	a3, a2, 15
                ads->ds_ctl2 = 0;
  905774:	252410        	s8i	a5, a2, 16
  905777:	252411        	s8i	a5, a2, 17
  90577a:	252412        	s8i	a5, a2, 18
  90577d:	252413        	s8i	a5, a2, 19
                ads->ds_ctl3 = 0;
  905780:	252414        	s8i	a5, a2, 20
  905783:	252415        	s8i	a5, a2, 21
  905786:	252416        	s8i	a5, a2, 22
  905789:	252417        	s8i	a5, a2, 23
        }
        ads->ds_txstatus0 = ads->ds_txstatus1 = 0;
  90578c:	c030      	movi.n	a3, 0
  90578e:	23243c        	s8i	a3, a2, 60
  905791:	23243d        	s8i	a3, a2, 61
  905794:	23243e        	s8i	a3, a2, 62
  905797:	23243f        	s8i	a3, a2, 63
  90579a:	232438        	s8i	a3, a2, 56
  90579d:	232439        	s8i	a3, a2, 57
  9057a0:	23243a        	s8i	a3, a2, 58
  9057a3:	23243b        	s8i	a3, a2, 59

        return AH_TRUE;
}
  9057a6:	c021      	movi.n	a2, 1
  9057a8:	d10f      	retw.n
	...

009057ac <ar5416FillKeyTxDesc_20>:

HAL_BOOL ar5416FillKeyTxDesc_20(struct ath_tx_desc *ds,
				HAL_KEY_TYPE keyType)
{
  9057ac:	6c1004        	entry	a1, 32
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl6 = SM(keyType, AR_EncrType);
  9057af:	187233        	l32r	a8, 8e207c <athos_indirection_table_install+0xb34>
  9057b2:	063310        	slli	a3, a3, 26
  9057b5:	083301        	and	a3, a3, a8
  9057b8:	038357        	extui	a3, a3, 24, 8
  9057bb:	232420        	s8i	a3, a2, 32
  9057be:	c030      	movi.n	a3, 0
  9057c0:	232421        	s8i	a3, a2, 33
  9057c3:	232422        	s8i	a3, a2, 34
  9057c6:	232423        	s8i	a3, a2, 35
	return AH_TRUE;
}
  9057c9:	c021      	movi.n	a2, 1
  9057cb:	d10f      	retw.n
  9057cd:	000000        	ill

009057d0 <ar5416ProcTxDesc_20>:

HAL_STATUS ar5416ProcTxDesc_20(struct ath_hal *ah, struct ath_tx_desc *gds)
{
  9057d0:	6c1004        	entry	a1, 32
        struct ar5416_desc *ads = AR5416DESC(gds);
        struct ath_tx_desc *ds = (struct ath_tx_desc *)gds;
        
        if ((ads->ds_txstatus9 & AR_TxDone) == 0)
  9057d3:	28305c        	l8ui	a8, a3, 92
  9057d6:	088910        	slli	a9, a8, 24
  9057d9:	28305d        	l8ui	a8, a3, 93
  9057dc:	008811        	slli	a8, a8, 16
  9057df:	098802        	or	a8, a8, a9
  9057e2:	29305e        	l8ui	a9, a3, 94
  9057e5:	089911        	slli	a9, a9, 8
  9057e8:	089802        	or	a8, a9, a8
  9057eb:	29305f        	l8ui	a9, a3, 95
  9057ee:	089902        	or	a9, a9, a8
                return HAL_EINPROGRESS;
  9057f1:	c08f      	movi.n	a8, 15
HAL_STATUS ar5416ProcTxDesc_20(struct ath_hal *ah, struct ath_tx_desc *gds)
{
        struct ar5416_desc *ads = AR5416DESC(gds);
        struct ath_tx_desc *ds = (struct ath_tx_desc *)gds;
        
        if ((ads->ds_txstatus9 & AR_TxDone) == 0)
  9057f3:	7f9f02        	bbsi	a9, 31, 9057f9 <ar5416ProcTxDesc_20+0x29>
  9057f6:	60027a        	j	905a74 <ar5416ProcTxDesc_20+0x2a4>
                return HAL_EINPROGRESS;

        ads->ds_txstatus9 &= ~AR_TxDone;
  9057f9:	c78e      	movi.n	a8, -2
  9057fb:	089801        	and	a8, a9, a8
  9057fe:	088a57        	extui	a10, a8, 24, 8
  905801:	2a345c        	s8i	a10, a3, 92
  905804:	080a57        	extui	a10, a8, 16, 8
  905807:	2a345d        	s8i	a10, a3, 93
  90580a:	28345f        	s8i	a8, a3, 95
  90580d:	088a47        	extui	a10, a8, 8, 8

        /* Update software copies of the HW status */
        ds->ds_txstat.ts_seqnum = MS(ads->ds_txstatus9, AR_SeqNum);
  905810:	08184b        	extui	a8, a8, 1, 12
        struct ath_tx_desc *ds = (struct ath_tx_desc *)gds;
        
        if ((ads->ds_txstatus9 & AR_TxDone) == 0)
                return HAL_EINPROGRESS;

        ads->ds_txstatus9 &= ~AR_TxDone;
  905813:	2a345e        	s8i	a10, a3, 94

        /* Update software copies of the HW status */
        ds->ds_txstat.ts_seqnum = MS(ads->ds_txstatus9, AR_SeqNum);
  905816:	088a14        	srli	a10, a8, 8
  905819:	2a3464        	s8i	a10, a3, 100
        ds->ds_txstat.ts_tstamp = ads->AR_SendTimestamp;
  90581c:	2a3040        	l8ui	a10, a3, 64
                return HAL_EINPROGRESS;

        ads->ds_txstatus9 &= ~AR_TxDone;

        /* Update software copies of the HW status */
        ds->ds_txstat.ts_seqnum = MS(ads->ds_txstatus9, AR_SeqNum);
  90581f:	283465        	s8i	a8, a3, 101
        ds->ds_txstat.ts_tstamp = ads->AR_SendTimestamp;
  905822:	08a810        	slli	a8, a10, 24
  905825:	2a3041        	l8ui	a10, a3, 65
        struct ath_tx_desc *ds = (struct ath_tx_desc *)gds;
        
        if ((ads->ds_txstatus9 & AR_TxDone) == 0)
                return HAL_EINPROGRESS;

        ads->ds_txstatus9 &= ~AR_TxDone;
  905828:	c0b0      	movi.n	a11, 0

        /* Update software copies of the HW status */
        ds->ds_txstat.ts_seqnum = MS(ads->ds_txstatus9, AR_SeqNum);
        ds->ds_txstat.ts_tstamp = ads->AR_SendTimestamp;
  90582a:	00aa11        	slli	a10, a10, 16
  90582d:	08aa02        	or	a10, a10, a8
  905830:	283042        	l8ui	a8, a3, 66
        ds->ds_txstat.ts_status = 0;
  905833:	2b3466        	s8i	a11, a3, 102

        ads->ds_txstatus9 &= ~AR_TxDone;

        /* Update software copies of the HW status */
        ds->ds_txstat.ts_seqnum = MS(ads->ds_txstatus9, AR_SeqNum);
        ds->ds_txstat.ts_tstamp = ads->AR_SendTimestamp;
  905836:	088811        	slli	a8, a8, 8
  905839:	0a8a02        	or	a10, a8, a10
  90583c:	283043        	l8ui	a8, a3, 67
        ds->ds_txstat.ts_status = 0;
        ds->ds_txstat.ts_flags  = 0;
  90583f:	2b3467        	s8i	a11, a3, 103

        ads->ds_txstatus9 &= ~AR_TxDone;

        /* Update software copies of the HW status */
        ds->ds_txstat.ts_seqnum = MS(ads->ds_txstatus9, AR_SeqNum);
        ds->ds_txstat.ts_tstamp = ads->AR_SendTimestamp;
  905842:	0a8802        	or	a8, a8, a10
  905845:	088a57        	extui	a10, a8, 24, 8
  905848:	2a3460        	s8i	a10, a3, 96
  90584b:	080a57        	extui	a10, a8, 16, 8
  90584e:	2a3461        	s8i	a10, a3, 97
  905851:	088a47        	extui	a10, a8, 8, 8
  905854:	2a3462        	s8i	a10, a3, 98
  905857:	283463        	s8i	a8, a3, 99
        ds->ds_txstat.ts_status = 0;
        ds->ds_txstat.ts_flags  = 0;

        if (ads->ds_txstatus1 & AR_ExcessiveRetries)
  90585a:	2a303c        	l8ui	a10, a3, 60
  90585d:	28303d        	l8ui	a8, a3, 61
  905860:	08aa10        	slli	a10, a10, 24
  905863:	008811        	slli	a8, a8, 16
  905866:	0a8a02        	or	a10, a8, a10
  905869:	28303e        	l8ui	a8, a3, 62
  90586c:	088811        	slli	a8, a8, 8
  90586f:	0a8802        	or	a8, a8, a10
  905872:	2a303f        	l8ui	a10, a3, 63
  905875:	08a802        	or	a8, a10, a8
  905878:	7e8704        	bbci	a8, 30, 905880 <ar5416ProcTxDesc_20+0xb0>
                ds->ds_txstat.ts_status |= HAL_TXERR_XRETRY;
  90587b:	c0a1      	movi.n	a10, 1
  90587d:	2a3466        	s8i	a10, a3, 102
        if (ads->ds_txstatus1 & AR_Filtered)
  905880:	7c870a        	bbci	a8, 28, 90588e <ar5416ProcTxDesc_20+0xbe>
                ds->ds_txstat.ts_status |= HAL_TXERR_FILT;
  905883:	2a3066        	l8ui	a10, a3, 102
  905886:	c0b2      	movi.n	a11, 2
  905888:	0baa02        	or	a10, a10, a11
  90588b:	2a3466        	s8i	a10, a3, 102
        if (ads->ds_txstatus1 & AR_FIFOUnderrun)
  90588e:	c0a4      	movi.n	a10, 4
  905890:	7a8008        	bnone	a8, a10, 90589c <ar5416ProcTxDesc_20+0xcc>
                ds->ds_txstat.ts_status |= HAL_TXERR_FIFO;
  905893:	2b3066        	l8ui	a11, a3, 102
  905896:	0baa02        	or	a10, a10, a11
  905899:	2a3466        	s8i	a10, a3, 102
        if (ads->ds_txstatus9 & AR_TxOpExceeded)
  90589c:	7e960a        	bbci	a9, 14, 9058aa <ar5416ProcTxDesc_20+0xda>
		ds->ds_txstat.ts_status |= HAL_TXERR_XTXOP;
  90589f:	293066        	l8ui	a9, a3, 102
  9058a2:	c0a8      	movi.n	a10, 8
  9058a4:	0a9902        	or	a9, a9, a10
  9058a7:	293466        	s8i	a9, a3, 102
        if (ads->ds_txstatus1 & AR_TxTimerExpired)
  9058aa:	7c860a        	bbci	a8, 12, 9058b8 <ar5416ProcTxDesc_20+0xe8>
		ds->ds_txstat.ts_status |= HAL_TXERR_TIMER_EXPIRED;
  9058ad:	293066        	l8ui	a9, a3, 102
  9058b0:	c1a0      	movi.n	a10, 16
  9058b2:	0a9902        	or	a9, a9, a10
  9058b5:	293466        	s8i	a9, a3, 102

        if (ads->ds_txstatus1 & AR_DescCfgErr)
  9058b8:	7d8604        	bbci	a8, 13, 9058c0 <ar5416ProcTxDesc_20+0xf0>
		ds->ds_txstat.ts_flags |= HAL_TX_DESC_CFG_ERR;
  9058bb:	c094      	movi.n	a9, 4
  9058bd:	293467        	s8i	a9, a3, 103
        if (ads->ds_txstatus1 & AR_TxDataUnderrun) {
  9058c0:	7e8611        	bbci	a8, 14, 9058d5 <ar5416ProcTxDesc_20+0x105>
		ds->ds_txstat.ts_flags |= HAL_TX_DATA_UNDERRUN;
  9058c3:	283067        	l8ui	a8, a3, 103
  9058c6:	c098      	movi.n	a9, 8
  9058c8:	098802        	or	a8, a8, a9
  9058cb:	283467        	s8i	a8, a3, 103
		ar5416UpdateTxTrigLevel(ah, AH_TRUE);
  9058ce:	c0b1      	movi.n	a11, 1
  9058d0:	da20      	mov.n	a10, a2
  9058d2:	5bfebe        	call8	9053cc <ar5416UpdateTxTrigLevel>
	}
        if (ads->ds_txstatus1 & AR_TxDelimUnderrun) {
  9058d5:	28303d        	l8ui	a8, a3, 61
  9058d8:	7f8711        	bbci	a8, 31, 9058ed <ar5416ProcTxDesc_20+0x11d>
		ds->ds_txstat.ts_flags |= HAL_TX_DELIM_UNDERRUN;
  9058db:	283067        	l8ui	a8, a3, 103
  9058de:	c190      	movi.n	a9, 16
  9058e0:	098802        	or	a8, a8, a9
  9058e3:	283467        	s8i	a8, a3, 103
		ar5416UpdateTxTrigLevel(ah, AH_TRUE);
  9058e6:	c0b1      	movi.n	a11, 1
  9058e8:	da20      	mov.n	a10, a2
  9058ea:	5bfeb8        	call8	9053cc <ar5416UpdateTxTrigLevel>
	}
        if (ads->ds_txstatus0 & AR_TxBaStatus) {
  9058ed:	293038        	l8ui	a9, a3, 56
  9058f0:	283039        	l8ui	a8, a3, 57
  9058f3:	089910        	slli	a9, a9, 24
  9058f6:	008811        	slli	a8, a8, 16
  9058f9:	098902        	or	a9, a8, a9
  9058fc:	28303a        	l8ui	a8, a3, 58
  9058ff:	22303b        	l8ui	a2, a3, 59
  905902:	088811        	slli	a8, a8, 8
  905905:	098802        	or	a8, a8, a9
  905908:	082802        	or	a8, a2, a8
  90590b:	718671        	bbci	a8, 1, 905980 <ar5416ProcTxDesc_20+0x1b0>
		ds->ds_txstat.ts_flags |= HAL_TX_BA;
  90590e:	223067        	l8ui	a2, a3, 103
		ds->ds_txstat.ba_low = ads->AR_BaBitmapLow;
  905911:	2a3044        	l8ui	a10, a3, 68
        if (ads->ds_txstatus1 & AR_TxDelimUnderrun) {
		ds->ds_txstat.ts_flags |= HAL_TX_DELIM_UNDERRUN;
		ar5416UpdateTxTrigLevel(ah, AH_TRUE);
	}
        if (ads->ds_txstatus0 & AR_TxBaStatus) {
		ds->ds_txstat.ts_flags |= HAL_TX_BA;
  905914:	290a01        	movi	a9, 1
  905917:	092202        	or	a2, a2, a9
		ds->ds_txstat.ba_low = ads->AR_BaBitmapLow;
  90591a:	08a910        	slli	a9, a10, 24
  90591d:	2a3045        	l8ui	a10, a3, 69
        if (ads->ds_txstatus1 & AR_TxDelimUnderrun) {
		ds->ds_txstat.ts_flags |= HAL_TX_DELIM_UNDERRUN;
		ar5416UpdateTxTrigLevel(ah, AH_TRUE);
	}
        if (ads->ds_txstatus0 & AR_TxBaStatus) {
		ds->ds_txstat.ts_flags |= HAL_TX_BA;
  905920:	223467        	s8i	a2, a3, 103
		ds->ds_txstat.ba_low = ads->AR_BaBitmapLow;
  905923:	00aa11        	slli	a10, a10, 16
  905926:	09aa02        	or	a10, a10, a9
  905929:	293046        	l8ui	a9, a3, 70
  90592c:	089911        	slli	a9, a9, 8
  90592f:	0a9a02        	or	a10, a9, a10
  905932:	293047        	l8ui	a9, a3, 71
  905935:	0a9902        	or	a9, a9, a10
  905938:	098257        	extui	a2, a9, 24, 8
		ds->ds_txstat.ba_high = ads->AR_BaBitmapHigh;
  90593b:	2a3048        	l8ui	a10, a3, 72
		ds->ds_txstat.ts_flags |= HAL_TX_DELIM_UNDERRUN;
		ar5416UpdateTxTrigLevel(ah, AH_TRUE);
	}
        if (ads->ds_txstatus0 & AR_TxBaStatus) {
		ds->ds_txstat.ts_flags |= HAL_TX_BA;
		ds->ds_txstat.ba_low = ads->AR_BaBitmapLow;
  90593e:	223474        	s8i	a2, a3, 116
  905941:	090257        	extui	a2, a9, 16, 8
  905944:	223475        	s8i	a2, a3, 117
  905947:	293477        	s8i	a9, a3, 119
  90594a:	098247        	extui	a2, a9, 8, 8
		ds->ds_txstat.ba_high = ads->AR_BaBitmapHigh;
  90594d:	08a910        	slli	a9, a10, 24
  905950:	2a3049        	l8ui	a10, a3, 73
		ds->ds_txstat.ts_flags |= HAL_TX_DELIM_UNDERRUN;
		ar5416UpdateTxTrigLevel(ah, AH_TRUE);
	}
        if (ads->ds_txstatus0 & AR_TxBaStatus) {
		ds->ds_txstat.ts_flags |= HAL_TX_BA;
		ds->ds_txstat.ba_low = ads->AR_BaBitmapLow;
  905953:	223476        	s8i	a2, a3, 118
		ds->ds_txstat.ba_high = ads->AR_BaBitmapHigh;
  905956:	00aa11        	slli	a10, a10, 16
  905959:	09aa02        	or	a10, a10, a9
  90595c:	29304a        	l8ui	a9, a3, 74
  90595f:	089911        	slli	a9, a9, 8
  905962:	0a9a02        	or	a10, a9, a10
  905965:	29304b        	l8ui	a9, a3, 75
  905968:	0a9902        	or	a9, a9, a10
  90596b:	098257        	extui	a2, a9, 24, 8
  90596e:	223478        	s8i	a2, a3, 120
  905971:	090257        	extui	a2, a9, 16, 8
  905974:	223479        	s8i	a2, a3, 121
  905977:	098247        	extui	a2, a9, 8, 8
  90597a:	22347a        	s8i	a2, a3, 122
  90597d:	29347b        	s8i	a9, a3, 123
         * Extract the transmit rate used and mark the rate as
         * ``alternate'' if it wasn't the series 0 rate.
         */
        ds->ds_txstat.ts_rate = MS(ads->ds_txstatus9, AR_FinalTxIdx);
        ds->ds_txstat.ts_rssi_combined = 
		MS(ads->ds_txstatus5, AR_TxRSSICombined);
  905980:	2a304c        	l8ui	a10, a3, 76

        /*
         * Extract the transmit rate used and mark the rate as
         * ``alternate'' if it wasn't the series 0 rate.
         */
        ds->ds_txstat.ts_rate = MS(ads->ds_txstatus9, AR_FinalTxIdx);
  905983:	22305d        	l8ui	a2, a3, 93
        ds->ds_txstat.ts_rssi_combined = 
		MS(ads->ds_txstatus5, AR_TxRSSICombined);
  905986:	08a910        	slli	a9, a10, 24
  905989:	2a304d        	l8ui	a10, a3, 77

        /*
         * Extract the transmit rate used and mark the rate as
         * ``alternate'' if it wasn't the series 0 rate.
         */
        ds->ds_txstat.ts_rate = MS(ads->ds_txstatus9, AR_FinalTxIdx);
  90598c:	025241        	extui	a2, a2, 5, 2
        ds->ds_txstat.ts_rssi_combined = 
		MS(ads->ds_txstatus5, AR_TxRSSICombined);
  90598f:	00aa11        	slli	a10, a10, 16
  905992:	09aa02        	or	a10, a10, a9
  905995:	29304e        	l8ui	a9, a3, 78

        /*
         * Extract the transmit rate used and mark the rate as
         * ``alternate'' if it wasn't the series 0 rate.
         */
        ds->ds_txstat.ts_rate = MS(ads->ds_txstatus9, AR_FinalTxIdx);
  905998:	223468        	s8i	a2, a3, 104
        ds->ds_txstat.ts_rssi_combined = 
		MS(ads->ds_txstatus5, AR_TxRSSICombined);
  90599b:	089911        	slli	a9, a9, 8
  90599e:	0a9a02        	or	a10, a9, a10
  9059a1:	29304f        	l8ui	a9, a3, 79
        ds->ds_txstat.ts_rssi_ctl0 = MS(ads->ds_txstatus0, AR_TxRSSIAnt00);
        ds->ds_txstat.ts_rssi_ctl1 = MS(ads->ds_txstatus0, AR_TxRSSIAnt01);
  9059a4:	088214        	srli	a2, a8, 8
         * Extract the transmit rate used and mark the rate as
         * ``alternate'' if it wasn't the series 0 rate.
         */
        ds->ds_txstat.ts_rate = MS(ads->ds_txstatus9, AR_FinalTxIdx);
        ds->ds_txstat.ts_rssi_combined = 
		MS(ads->ds_txstatus5, AR_TxRSSICombined);
  9059a7:	0a9902        	or	a9, a9, a10
        ds->ds_txstat.ts_rssi_ctl0 = MS(ads->ds_txstatus0, AR_TxRSSIAnt00);
  9059aa:	28346a        	s8i	a8, a3, 106
        ds->ds_txstat.ts_rssi_ctl1 = MS(ads->ds_txstatus0, AR_TxRSSIAnt01);
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
  9059ad:	08085f        	extui	a8, a8, 16, 16
         * Extract the transmit rate used and mark the rate as
         * ``alternate'' if it wasn't the series 0 rate.
         */
        ds->ds_txstat.ts_rate = MS(ads->ds_txstatus9, AR_FinalTxIdx);
        ds->ds_txstat.ts_rssi_combined = 
		MS(ads->ds_txstatus5, AR_TxRSSICombined);
  9059b0:	098a57        	extui	a10, a9, 24, 8
        ds->ds_txstat.ts_rssi_ctl0 = MS(ads->ds_txstatus0, AR_TxRSSIAnt00);
        ds->ds_txstat.ts_rssi_ctl1 = MS(ads->ds_txstatus0, AR_TxRSSIAnt01);
  9059b3:	22346b        	s8i	a2, a3, 107
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
  9059b6:	28346c        	s8i	a8, a3, 108
        ds->ds_txstat.ts_rssi_ext0 = MS(ads->ds_txstatus5, AR_TxRSSIAnt10);
        ds->ds_txstat.ts_rssi_ext1 = MS(ads->ds_txstatus5, AR_TxRSSIAnt11);
  9059b9:	098214        	srli	a2, a9, 8
        ds->ds_txstat.ts_rssi_ext2 = MS(ads->ds_txstatus5, AR_TxRSSIAnt12);
  9059bc:	09085f        	extui	a8, a9, 16, 16
        ds->ds_txstat.ts_rssi_combined = 
		MS(ads->ds_txstatus5, AR_TxRSSICombined);
        ds->ds_txstat.ts_rssi_ctl0 = MS(ads->ds_txstatus0, AR_TxRSSIAnt00);
        ds->ds_txstat.ts_rssi_ctl1 = MS(ads->ds_txstatus0, AR_TxRSSIAnt01);
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
        ds->ds_txstat.ts_rssi_ext0 = MS(ads->ds_txstatus5, AR_TxRSSIAnt10);
  9059bf:	29346d        	s8i	a9, a3, 109
        ds->ds_txstat.ts_rssi_ext1 = MS(ads->ds_txstatus5, AR_TxRSSIAnt11);
        ds->ds_txstat.ts_rssi_ext2 = MS(ads->ds_txstatus5, AR_TxRSSIAnt12);
        ds->ds_txstat.evm0 = ads->AR_TxEVM0;
  9059c2:	29347f        	s8i	a9, a3, 127
        ds->ds_txstat.evm1 = ads->AR_TxEVM1;
  9059c5:	293050        	l8ui	a9, a3, 80
        ds->ds_txstat.ts_rssi_ctl0 = MS(ads->ds_txstatus0, AR_TxRSSIAnt00);
        ds->ds_txstat.ts_rssi_ctl1 = MS(ads->ds_txstatus0, AR_TxRSSIAnt01);
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
        ds->ds_txstat.ts_rssi_ext0 = MS(ads->ds_txstatus5, AR_TxRSSIAnt10);
        ds->ds_txstat.ts_rssi_ext1 = MS(ads->ds_txstatus5, AR_TxRSSIAnt11);
        ds->ds_txstat.ts_rssi_ext2 = MS(ads->ds_txstatus5, AR_TxRSSIAnt12);
  9059c8:	28346f        	s8i	a8, a3, 111
        ds->ds_txstat.evm0 = ads->AR_TxEVM0;
  9059cb:	28347d        	s8i	a8, a3, 125
        ds->ds_txstat.evm1 = ads->AR_TxEVM1;
  9059ce:	089810        	slli	a8, a9, 24
  9059d1:	293051        	l8ui	a9, a3, 81
		MS(ads->ds_txstatus5, AR_TxRSSICombined);
        ds->ds_txstat.ts_rssi_ctl0 = MS(ads->ds_txstatus0, AR_TxRSSIAnt00);
        ds->ds_txstat.ts_rssi_ctl1 = MS(ads->ds_txstatus0, AR_TxRSSIAnt01);
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
        ds->ds_txstat.ts_rssi_ext0 = MS(ads->ds_txstatus5, AR_TxRSSIAnt10);
        ds->ds_txstat.ts_rssi_ext1 = MS(ads->ds_txstatus5, AR_TxRSSIAnt11);
  9059d4:	22346e        	s8i	a2, a3, 110
        ds->ds_txstat.ts_rssi_ext2 = MS(ads->ds_txstatus5, AR_TxRSSIAnt12);
        ds->ds_txstat.evm0 = ads->AR_TxEVM0;
        ds->ds_txstat.evm1 = ads->AR_TxEVM1;
  9059d7:	009911        	slli	a9, a9, 16
  9059da:	089902        	or	a9, a9, a8
  9059dd:	283052        	l8ui	a8, a3, 82
        ds->ds_txstat.ts_rssi_ctl1 = MS(ads->ds_txstatus0, AR_TxRSSIAnt01);
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
        ds->ds_txstat.ts_rssi_ext0 = MS(ads->ds_txstatus5, AR_TxRSSIAnt10);
        ds->ds_txstat.ts_rssi_ext1 = MS(ads->ds_txstatus5, AR_TxRSSIAnt11);
        ds->ds_txstat.ts_rssi_ext2 = MS(ads->ds_txstatus5, AR_TxRSSIAnt12);
        ds->ds_txstat.evm0 = ads->AR_TxEVM0;
  9059e0:	22347e        	s8i	a2, a3, 126
        ds->ds_txstat.evm1 = ads->AR_TxEVM1;
  9059e3:	088811        	slli	a8, a8, 8
  9059e6:	098902        	or	a9, a8, a9
  9059e9:	283053        	l8ui	a8, a3, 83
        /*
         * Extract the transmit rate used and mark the rate as
         * ``alternate'' if it wasn't the series 0 rate.
         */
        ds->ds_txstat.ts_rate = MS(ads->ds_txstatus9, AR_FinalTxIdx);
        ds->ds_txstat.ts_rssi_combined = 
  9059ec:	2a3469        	s8i	a10, a3, 105
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
        ds->ds_txstat.ts_rssi_ext0 = MS(ads->ds_txstatus5, AR_TxRSSIAnt10);
        ds->ds_txstat.ts_rssi_ext1 = MS(ads->ds_txstatus5, AR_TxRSSIAnt11);
        ds->ds_txstat.ts_rssi_ext2 = MS(ads->ds_txstatus5, AR_TxRSSIAnt12);
        ds->ds_txstat.evm0 = ads->AR_TxEVM0;
        ds->ds_txstat.evm1 = ads->AR_TxEVM1;
  9059ef:	098802        	or	a8, a8, a9
  9059f2:	088257        	extui	a2, a8, 24, 8
        ds->ds_txstat.evm2 = ads->AR_TxEVM2;
  9059f5:	293054        	l8ui	a9, a3, 84
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
        ds->ds_txstat.ts_rssi_ext0 = MS(ads->ds_txstatus5, AR_TxRSSIAnt10);
        ds->ds_txstat.ts_rssi_ext1 = MS(ads->ds_txstatus5, AR_TxRSSIAnt11);
        ds->ds_txstat.ts_rssi_ext2 = MS(ads->ds_txstatus5, AR_TxRSSIAnt12);
        ds->ds_txstat.evm0 = ads->AR_TxEVM0;
        ds->ds_txstat.evm1 = ads->AR_TxEVM1;
  9059f8:	223480        	s8i	a2, a3, 128
  9059fb:	080257        	extui	a2, a8, 16, 8
  9059fe:	223481        	s8i	a2, a3, 129
  905a01:	283483        	s8i	a8, a3, 131
  905a04:	088247        	extui	a2, a8, 8, 8
        ds->ds_txstat.evm2 = ads->AR_TxEVM2;
  905a07:	089810        	slli	a8, a9, 24
  905a0a:	293055        	l8ui	a9, a3, 85
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
        ds->ds_txstat.ts_rssi_ext0 = MS(ads->ds_txstatus5, AR_TxRSSIAnt10);
        ds->ds_txstat.ts_rssi_ext1 = MS(ads->ds_txstatus5, AR_TxRSSIAnt11);
        ds->ds_txstat.ts_rssi_ext2 = MS(ads->ds_txstatus5, AR_TxRSSIAnt12);
        ds->ds_txstat.evm0 = ads->AR_TxEVM0;
        ds->ds_txstat.evm1 = ads->AR_TxEVM1;
  905a0d:	223482        	s8i	a2, a3, 130
        ds->ds_txstat.evm2 = ads->AR_TxEVM2;
  905a10:	009911        	slli	a9, a9, 16
  905a13:	089902        	or	a9, a9, a8
  905a16:	283056        	l8ui	a8, a3, 86
        ds->ds_txstat.ts_rssi_ctl1 = MS(ads->ds_txstatus0, AR_TxRSSIAnt01);
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
        ds->ds_txstat.ts_rssi_ext0 = MS(ads->ds_txstatus5, AR_TxRSSIAnt10);
        ds->ds_txstat.ts_rssi_ext1 = MS(ads->ds_txstatus5, AR_TxRSSIAnt11);
        ds->ds_txstat.ts_rssi_ext2 = MS(ads->ds_txstatus5, AR_TxRSSIAnt12);
        ds->ds_txstat.evm0 = ads->AR_TxEVM0;
  905a19:	2a347c        	s8i	a10, a3, 124
        ds->ds_txstat.evm1 = ads->AR_TxEVM1;
        ds->ds_txstat.evm2 = ads->AR_TxEVM2;
  905a1c:	088811        	slli	a8, a8, 8
  905a1f:	098902        	or	a9, a8, a9
  905a22:	283057        	l8ui	a8, a3, 87
  905a25:	098802        	or	a8, a8, a9
  905a28:	088257        	extui	a2, a8, 24, 8
  905a2b:	223484        	s8i	a2, a3, 132
  905a2e:	080257        	extui	a2, a8, 16, 8
  905a31:	223485        	s8i	a2, a3, 133
  905a34:	088247        	extui	a2, a8, 8, 8
  905a37:	223486        	s8i	a2, a3, 134
  905a3a:	283487        	s8i	a8, a3, 135
        ds->ds_txstat.ts_shortretry = MS(ads->ds_txstatus1, AR_RTSFailCnt);
  905a3d:	29303c        	l8ui	a9, a3, 60
  905a40:	089810        	slli	a8, a9, 24
  905a43:	29303d        	l8ui	a9, a3, 61
  905a46:	009911        	slli	a9, a9, 16
  905a49:	089902        	or	a9, a9, a8
  905a4c:	28303e        	l8ui	a8, a3, 62
  905a4f:	088811        	slli	a8, a8, 8
  905a52:	098902        	or	a9, a8, a9
  905a55:	28303f        	l8ui	a8, a3, 63
  905a58:	098802        	or	a8, a8, a9
  905a5b:	084243        	extui	a2, a8, 4, 4
  905a5e:	223470        	s8i	a2, a3, 112
        ds->ds_txstat.ts_longretry = MS(ads->ds_txstatus1, AR_DataFailCnt);
  905a61:	088243        	extui	a2, a8, 8, 4
  905a64:	223471        	s8i	a2, a3, 113
        ds->ds_txstat.ts_virtcol = MS(ads->ds_txstatus1, AR_VirtRetryCnt);
  905a67:	08c843        	extui	a8, a8, 12, 4
        ds->ds_txstat.ts_antenna = 0;		/* ignored for owl */
  905a6a:	c020      	movi.n	a2, 0
        ds->ds_txstat.evm0 = ads->AR_TxEVM0;
        ds->ds_txstat.evm1 = ads->AR_TxEVM1;
        ds->ds_txstat.evm2 = ads->AR_TxEVM2;
        ds->ds_txstat.ts_shortretry = MS(ads->ds_txstatus1, AR_RTSFailCnt);
        ds->ds_txstat.ts_longretry = MS(ads->ds_txstatus1, AR_DataFailCnt);
        ds->ds_txstat.ts_virtcol = MS(ads->ds_txstatus1, AR_VirtRetryCnt);
  905a6c:	283472        	s8i	a8, a3, 114
        ds->ds_txstat.ts_antenna = 0;		/* ignored for owl */
  905a6f:	223473        	s8i	a2, a3, 115

        return HAL_OK;
  905a72:	c080      	movi.n	a8, 0
}
  905a74:	d280      	mov.n	a2, a8
  905a76:	d10f      	retw.n

00905a78 <ar5416Set11nTxDesc_20>:

void ar5416Set11nTxDesc_20(struct ath_tx_desc *ds,
			   a_uint32_t pktLen, HAL_PKT_TYPE type, a_uint32_t txPower,
			   a_uint32_t keyIx, HAL_KEY_TYPE keyType,
			   a_uint32_t flags)
{
  905a78:	6c1004        	entry	a1, 32
  905a7b:	8818      	l32i.n	a8, a1, 32
  905a7d:	c39f      	movi.n	a9, 63
  905a7f:	095536        	minu	a5, a5, a9

	if (txPower > 63)
                txPower = 63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
		| (flags & HAL_TXDESC_VMF ? AR_VirtMoreFrag : 0)
  905a82:	2a1a00        	movi	a10, 0x100
        HALASSERT(isValidKeyType(keyType));

	if (txPower > 63)
                txPower = 63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
  905a85:	03094b        	extui	a9, a3, 0, 12
		| (flags & HAL_TXDESC_VMF ? AR_VirtMoreFrag : 0)
  905a88:	1371f2        	l32r	a3, 8e2250 <athos_indirection_table_install+0xd08>
  905a8b:	0a8a01        	and	a10, a8, a10
  905a8e:	0a3a39        	movnez	a10, a3, a10
		| SM(txPower, AR_XmitPower)
  905a91:	137235        	l32r	a3, 8e2368 <athos_indirection_table_install+0xe20>
  905a94:	005511        	slli	a5, a5, 16
  905a97:	035301        	and	a3, a5, a3
  905a9a:	093302        	or	a3, a3, a9
		| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0)
  905a9d:	15722e        	l32r	a5, 8e2358 <athos_indirection_table_install+0xe10>
  905aa0:	c094      	movi.n	a9, 4
  905aa2:	098901        	and	a9, a8, a9
  905aa5:	095939        	movnez	a9, a5, a9
	if (txPower > 63)
                txPower = 63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
		| (flags & HAL_TXDESC_VMF ? AR_VirtMoreFrag : 0)
		| SM(txPower, AR_XmitPower)
  905aa8:	0a3302        	or	a3, a3, a10
		| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0)
  905aab:	039302        	or	a3, a9, a3
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
  905aae:	15721a        	l32r	a5, 8e2318 <athos_indirection_table_install+0xdd0>
  905ab1:	c290      	movi.n	a9, 32
  905ab3:	098901        	and	a9, a8, a9
  905ab6:	095939        	movnez	a9, a5, a9
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
  905ab9:	1a722b        	l32r	a10, 8e2368 <athos_indirection_table_install+0xe20>

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
		| (flags & HAL_TXDESC_VMF ? AR_VirtMoreFrag : 0)
		| SM(txPower, AR_XmitPower)
		| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0)
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
  905abc:	039902        	or	a9, a9, a3
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
  905abf:	080540        	extui	a5, a8, 0, 1
  905ac2:	c030      	movi.n	a3, 0
  905ac4:	053a38        	moveqz	a10, a3, a5
  905ac7:	09a502        	or	a5, a10, a9
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0)
  905aca:	1a722c        	l32r	a10, 8e237c <athos_indirection_table_install+0xe34>
  905acd:	290a10        	movi	a9, 16
  905ad0:	098901        	and	a9, a8, a9
  905ad3:	09a939        	movnez	a9, a10, a9
		| (keyIx != HAL_TXKEYIX_INVALID ? AR_DestIdxValid : 0)
  905ad6:	1b7231        	l32r	a11, 8e239c <athos_indirection_table_install+0xe54>
  905ad9:	2a0aff        	movi	a10, 255
		| (flags & HAL_TXDESC_VMF ? AR_VirtMoreFrag : 0)
		| SM(txPower, AR_XmitPower)
		| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0)
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0)
  905adc:	059902        	or	a9, a9, a5
		| (keyIx != HAL_TXKEYIX_INVALID ? AR_DestIdxValid : 0)
  905adf:	0a650c        	sub	a5, a6, a10
  905ae2:	053b38        	moveqz	a11, a3, a5
  905ae5:	09b502        	or	a5, a11, a9
		| (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0);
  905ae8:	290a08        	movi	a9, 8
  905aeb:	1b722d        	l32r	a11, 8e23a0 <athos_indirection_table_install+0xe58>
  905aee:	098901        	and	a9, a8, a9
  905af1:	09b939        	movnez	a9, a11, a9
  905af4:	059902        	or	a9, a9, a5
        HALASSERT(isValidKeyType(keyType));

	if (txPower > 63)
                txPower = 63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
  905af7:	098557        	extui	a5, a9, 24, 8
  905afa:	252408        	s8i	a5, a2, 8
  905afd:	090557        	extui	a5, a9, 16, 8
  905b00:	252409        	s8i	a5, a2, 9
  905b03:	098547        	extui	a5, a9, 8, 8
  905b06:	25240a        	s8i	a5, a2, 10
  905b09:	29240b        	s8i	a9, a2, 11
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0)
		| (keyIx != HAL_TXKEYIX_INVALID ? AR_DestIdxValid : 0)
		| (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0);

        ads->ds_ctl1 = (keyIx != HAL_TXKEYIX_INVALID ? SM(keyIx, AR_DestIdx) : 0)
  905b0c:	7a6108        	beq	a6, a10, 905b18 <ar5416Set11nTxDesc_20+0xa0>
  905b0f:	137230        	l32r	a3, 8e23d0 <athos_indirection_table_install+0xe88>
  905b12:	036611        	slli	a6, a6, 13
  905b15:	036301        	and	a3, a6, a3
		| SM(type, AR_FrameType)
  905b18:	167236        	l32r	a6, 8e23f0 <athos_indirection_table_install+0xea8>
  905b1b:	0c4410        	slli	a4, a4, 20
  905b1e:	064401        	and	a4, a4, a6
  905b21:	034402        	or	a4, a4, a3
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0)
  905b24:	15722b        	l32r	a5, 8e23d0 <athos_indirection_table_install+0xe88>
  905b27:	c032      	movi.n	a3, 2
  905b29:	038301        	and	a3, a8, a3
  905b2c:	035339        	movnez	a3, a5, a3
  905b2f:	043402        	or	a4, a3, a4
		| (flags & HAL_TXDESC_EXT_ONLY ? AR_ExtOnly : 0)
  905b32:	157234        	l32r	a5, 8e2404 <athos_indirection_table_install+0xebc>
  905b35:	c430      	movi.n	a3, 64
  905b37:	038301        	and	a3, a8, a3
  905b3a:	035339        	movnez	a3, a5, a3
  905b3d:	043302        	or	a3, a3, a4
		| (flags & HAL_TXDESC_EXT_AND_CTL ? AR_ExtAndCtl : 0);
  905b40:	240a80        	movi	a4, 128
  905b43:	048801        	and	a8, a8, a4
  905b46:	147215        	l32r	a4, 8e239c <athos_indirection_table_install+0xe54>

        ads->ds_ctl6 = SM(keyType, AR_EncrType);
  905b49:	067710        	slli	a7, a7, 26

        ads->ds_ctl1 = (keyIx != HAL_TXKEYIX_INVALID ? SM(keyIx, AR_DestIdx) : 0)
		| SM(type, AR_FrameType)
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0)
		| (flags & HAL_TXDESC_EXT_ONLY ? AR_ExtOnly : 0)
		| (flags & HAL_TXDESC_EXT_AND_CTL ? AR_ExtAndCtl : 0);
  905b4c:	084839        	movnez	a8, a4, a8
  905b4f:	038802        	or	a8, a8, a3
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0)
		| (keyIx != HAL_TXKEYIX_INVALID ? AR_DestIdxValid : 0)
		| (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0);

        ads->ds_ctl1 = (keyIx != HAL_TXKEYIX_INVALID ? SM(keyIx, AR_DestIdx) : 0)
  905b52:	088357        	extui	a3, a8, 24, 8
  905b55:	23240c        	s8i	a3, a2, 12
  905b58:	080357        	extui	a3, a8, 16, 8
  905b5b:	23240d        	s8i	a3, a2, 13
  905b5e:	088347        	extui	a3, a8, 8, 8
  905b61:	23240e        	s8i	a3, a2, 14
		| SM(type, AR_FrameType)
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0)
		| (flags & HAL_TXDESC_EXT_ONLY ? AR_ExtOnly : 0)
		| (flags & HAL_TXDESC_EXT_AND_CTL ? AR_ExtAndCtl : 0);

        ads->ds_ctl6 = SM(keyType, AR_EncrType);
  905b64:	137233        	l32r	a3, 8e2430 <athos_indirection_table_install+0xee8>
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0)
		| (keyIx != HAL_TXKEYIX_INVALID ? AR_DestIdxValid : 0)
		| (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0);

        ads->ds_ctl1 = (keyIx != HAL_TXKEYIX_INVALID ? SM(keyIx, AR_DestIdx) : 0)
  905b67:	28240f        	s8i	a8, a2, 15
		| SM(type, AR_FrameType)
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0)
		| (flags & HAL_TXDESC_EXT_ONLY ? AR_ExtOnly : 0)
		| (flags & HAL_TXDESC_EXT_AND_CTL ? AR_ExtAndCtl : 0);

        ads->ds_ctl6 = SM(keyType, AR_EncrType);
  905b6a:	037701        	and	a7, a7, a3
  905b6d:	078757        	extui	a7, a7, 24, 8
  905b70:	c030      	movi.n	a3, 0
  905b72:	272420        	s8i	a7, a2, 32
  905b75:	232421        	s8i	a3, a2, 33
  905b78:	232422        	s8i	a3, a2, 34
  905b7b:	232423        	s8i	a3, a2, 35
  905b7e:	d10f      	retw.n

00905b80 <ar5416Set11nRateScenario_20>:

void ar5416Set11nRateScenario_20(struct ath_tx_desc *ds,
				 a_uint32_t durUpdateEn, a_uint32_t rtsctsRate,
				 HAL_11N_RATE_SERIES series[], a_uint32_t nseries,
				 a_uint32_t flags)
{
  905b80:	6c1006        	entry	a1, 48
  905b83:	9412      	s32i.n	a4, a1, 8
	(void)nseries;

	/*
	* Rate control settings override
	*/
	ds_ctl0 = ads->ds_ctl0;
  905b85:	242008        	l8ui	a4, a2, 8

	if (flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA)) {
  905b88:	c08c      	movi.n	a8, 12
	(void)nseries;

	/*
	* Rate control settings override
	*/
	ds_ctl0 = ads->ds_ctl0;
  905b8a:	084610        	slli	a6, a4, 24
  905b8d:	242009        	l8ui	a4, a2, 9
  905b90:	004411        	slli	a4, a4, 16
  905b93:	064402        	or	a4, a4, a6
  905b96:	26200a        	l8ui	a6, a2, 10
  905b99:	086611        	slli	a6, a6, 8
  905b9c:	046402        	or	a4, a6, a4
  905b9f:	26200b        	l8ui	a6, a2, 11
  905ba2:	046602        	or	a6, a6, a4
			ds_ctl0 |= AR_CTSEnable;
		}
	} else {
		/* this line is only difference between merlin and k2
		 * Current one is for merlin */
		ds_ctl0 = (ds_ctl0 & ~(AR_RTSEnable | AR_CTSEnable));
  905ba5:	14723a        	l32r	a4, 8e2490 <athos_indirection_table_install+0xf48>
  905ba8:	046401        	and	a4, a6, a4
	/*
	* Rate control settings override
	*/
	ds_ctl0 = ads->ds_ctl0;

	if (flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA)) {
  905bab:	78701a        	bnone	a7, a8, 905bc9 <ar5416Set11nRateScenario_20+0x49>
		if (flags & HAL_TXDESC_RTSENA) {
  905bae:	7d770b        	bbci	a7, 29, 905bbd <ar5416Set11nRateScenario_20+0x3d>
			ds_ctl0 &= ~AR_CTSEnable;
  905bb1:	147226        	l32r	a4, 8e244c <athos_indirection_table_install+0xf04>
  905bb4:	046601        	and	a6, a6, a4
			ds_ctl0 |= AR_RTSEnable;
  905bb7:	14722e        	l32r	a4, 8e2470 <athos_indirection_table_install+0xf28>
  905bba:	600008        	j	905bc6 <ar5416Set11nRateScenario_20+0x46>
		} else {
			ds_ctl0 &= ~AR_RTSEnable;
  905bbd:	147239        	l32r	a4, 8e24a4 <athos_indirection_table_install+0xf5c>
  905bc0:	046601        	and	a6, a6, a4
			ds_ctl0 |= AR_CTSEnable;
  905bc3:	14722d        	l32r	a4, 8e2478 <athos_indirection_table_install+0xf30>
  905bc6:	046402        	or	a4, a6, a4
		/* this line is only difference between merlin and k2
		 * Current one is for merlin */
		ds_ctl0 = (ds_ctl0 & ~(AR_RTSEnable | AR_CTSEnable));
	}

	ads->ds_ctl0 = ds_ctl0;
  905bc9:	048657        	extui	a6, a4, 24, 8
  905bcc:	262408        	s8i	a6, a2, 8
  905bcf:	040657        	extui	a6, a4, 16, 8
  905bd2:	262409        	s8i	a6, a2, 9
  905bd5:	24240b        	s8i	a4, a2, 11
  905bd8:	048647        	extui	a6, a4, 8, 8

	ads->ds_ctl2 = set11nTries(series, 0)
  905bdb:	8450      	l32i.n	a4, a5, 0
		/* this line is only difference between merlin and k2
		 * Current one is for merlin */
		ds_ctl0 = (ds_ctl0 & ~(AR_RTSEnable | AR_CTSEnable));
	}

	ads->ds_ctl0 = ds_ctl0;
  905bdd:	26240a        	s8i	a6, a2, 10

	ads->ds_ctl2 = set11nTries(series, 0)
  905be0:	16722f        	l32r	a6, 8e249c <athos_indirection_table_install+0xf54>
  905be3:	004411        	slli	a4, a4, 16
  905be6:	064401        	and	a4, a4, a6
				   | set11nTries(series, 1)
  905be9:	8655      	l32i.n	a6, a5, 20
  905beb:	177236        	l32r	a7, 8e24c4 <athos_indirection_table_install+0xf7c>
  905bee:	0c6610        	slli	a6, a6, 20
  905bf1:	076601        	and	a6, a6, a7
  905bf4:	064402        	or	a4, a4, a6
				   | set11nTries(series, 2)
				   | set11nTries(series, 3)
  905bf7:	865f      	l32i.n	a6, a5, 60

	ads->ds_ctl0 = ds_ctl0;

	ads->ds_ctl2 = set11nTries(series, 0)
				   | set11nTries(series, 1)
				   | set11nTries(series, 2)
  905bf9:	17723b        	l32r	a7, 8e24e8 <athos_indirection_table_install+0xfa0>
				   | set11nTries(series, 3)
  905bfc:	046610        	slli	a6, a6, 28
  905bff:	064402        	or	a4, a4, a6

	ads->ds_ctl0 = ds_ctl0;

	ads->ds_ctl2 = set11nTries(series, 0)
				   | set11nTries(series, 1)
				   | set11nTries(series, 2)
  905c02:	865a      	l32i.n	a6, a5, 40
	ads->ds_ctl3 = set11nRate(series, 0)
				   | set11nRate(series, 1)
				   | set11nRate(series, 2)
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
  905c04:	c0c0      	movi.n	a12, 0

	ads->ds_ctl0 = ds_ctl0;

	ads->ds_ctl2 = set11nTries(series, 0)
				   | set11nTries(series, 1)
				   | set11nTries(series, 2)
  905c06:	086610        	slli	a6, a6, 24
  905c09:	076601        	and	a6, a6, a7
				   | set11nTries(series, 3)
				   | (durUpdateEn ? AR_DurUpdateEn : 0);
  905c0c:	177237        	l32r	a7, 8e24e8 <athos_indirection_table_install+0xfa0>
	ads->ds_ctl0 = ds_ctl0;

	ads->ds_ctl2 = set11nTries(series, 0)
				   | set11nTries(series, 1)
				   | set11nTries(series, 2)
				   | set11nTries(series, 3)
  905c0f:	064402        	or	a4, a4, a6
				   | (durUpdateEn ? AR_DurUpdateEn : 0);
  905c12:	037339        	movnez	a3, a7, a3
  905c15:	043302        	or	a3, a3, a4
		ds_ctl0 = (ds_ctl0 & ~(AR_RTSEnable | AR_CTSEnable));
	}

	ads->ds_ctl0 = ds_ctl0;

	ads->ds_ctl2 = set11nTries(series, 0)
  905c18:	038457        	extui	a4, a3, 24, 8
  905c1b:	242410        	s8i	a4, a2, 16
  905c1e:	030457        	extui	a4, a3, 16, 8
  905c21:	242411        	s8i	a4, a2, 17
  905c24:	038447        	extui	a4, a3, 8, 8
  905c27:	242412        	s8i	a4, a2, 18
  905c2a:	232413        	s8i	a3, a2, 19
				   | (durUpdateEn ? AR_DurUpdateEn : 0);

	ads->ds_ctl3 = set11nRate(series, 0)
				   | set11nRate(series, 1)
				   | set11nRate(series, 2)
				   | set11nRate(series, 3);
  905c2d:	245210        	l32i	a4, a5, 64
				   | set11nTries(series, 1)
				   | set11nTries(series, 2)
				   | set11nTries(series, 3)
				   | (durUpdateEn ? AR_DurUpdateEn : 0);

	ads->ds_ctl3 = set11nRate(series, 0)
  905c30:	235007        	l8ui	a3, a5, 7
				   | set11nRate(series, 1)
				   | set11nRate(series, 2)
				   | set11nRate(series, 3);
  905c33:	084410        	slli	a4, a4, 24
  905c36:	043302        	or	a3, a3, a4
				   | set11nTries(series, 2)
				   | set11nTries(series, 3)
				   | (durUpdateEn ? AR_DurUpdateEn : 0);

	ads->ds_ctl3 = set11nRate(series, 0)
				   | set11nRate(series, 1)
  905c39:	8456      	l32i.n	a4, a5, 24
				   | set11nRate(series, 2)
  905c3b:	16723c        	l32r	a6, 8e252c <athos_indirection_table_install+0xfe4>
				   | set11nTries(series, 2)
				   | set11nTries(series, 3)
				   | (durUpdateEn ? AR_DurUpdateEn : 0);

	ads->ds_ctl3 = set11nRate(series, 0)
				   | set11nRate(series, 1)
  905c3e:	084411        	slli	a4, a4, 8
  905c41:	04044f        	extui	a4, a4, 0, 16
				   | set11nRate(series, 2)
				   | set11nRate(series, 3);
  905c44:	043302        	or	a3, a3, a4
				   | set11nTries(series, 3)
				   | (durUpdateEn ? AR_DurUpdateEn : 0);

	ads->ds_ctl3 = set11nRate(series, 0)
				   | set11nRate(series, 1)
				   | set11nRate(series, 2)
  905c47:	845b      	l32i.n	a4, a5, 44
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
				   | set11nPktDurRTSCTS(series, 1);
  905c49:	1b723d        	l32r	a11, 8e2540 <athos_indirection_table_install+0xff8>
				   | set11nTries(series, 3)
				   | (durUpdateEn ? AR_DurUpdateEn : 0);

	ads->ds_ctl3 = set11nRate(series, 0)
				   | set11nRate(series, 1)
				   | set11nRate(series, 2)
  905c4c:	004411        	slli	a4, a4, 16
  905c4f:	064401        	and	a4, a4, a6
				   | set11nRate(series, 3);
  905c52:	043302        	or	a3, a3, a4
				   | set11nTries(series, 1)
				   | set11nTries(series, 2)
				   | set11nTries(series, 3)
				   | (durUpdateEn ? AR_DurUpdateEn : 0);

	ads->ds_ctl3 = set11nRate(series, 0)
  905c55:	038457        	extui	a4, a3, 24, 8
  905c58:	242414        	s8i	a4, a2, 20
  905c5b:	030457        	extui	a4, a3, 16, 8
  905c5e:	242415        	s8i	a4, a2, 21
  905c61:	038447        	extui	a4, a3, 8, 8
  905c64:	242416        	s8i	a4, a2, 22
  905c67:	232417        	s8i	a3, a2, 23
				   | set11nRate(series, 1)
				   | set11nRate(series, 2)
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
  905c6a:	8354      	l32i.n	a3, a5, 16
  905c6c:	8652      	l32i.n	a6, a5, 8
  905c6e:	030440        	extui	a4, a3, 0, 1
  905c71:	06084e        	extui	a8, a6, 0, 15
  905c74:	d670      	mov.n	a6, a7
  905c76:	04c638        	moveqz	a6, a12, a4
  905c79:	d460      	mov.n	a4, a6
				   | set11nPktDurRTSCTS(series, 1);
  905c7b:	8657      	l32i.n	a6, a5, 28
  905c7d:	8a59      	l32i.n	a10, a5, 36
  905c7f:	006611        	slli	a6, a6, 16
  905c82:	0b6601        	and	a6, a6, a11
  905c85:	19722d        	l32r	a9, 8e253c <athos_indirection_table_install+0xff4>
  905c88:	086602        	or	a6, a6, a8
  905c8b:	0a0840        	extui	a8, a10, 0, 1
  905c8e:	08c938        	moveqz	a9, a12, a8
  905c91:	064402        	or	a4, a4, a6
  905c94:	094402        	or	a4, a4, a9
	ads->ds_ctl3 = set11nRate(series, 0)
				   | set11nRate(series, 1)
				   | set11nRate(series, 2)
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
  905c97:	048657        	extui	a6, a4, 24, 8
  905c9a:	262418        	s8i	a6, a2, 24
  905c9d:	040657        	extui	a6, a4, 16, 8
  905ca0:	262419        	s8i	a6, a2, 25
  905ca3:	048647        	extui	a6, a4, 8, 8
  905ca6:	26241a        	s8i	a6, a2, 26
  905ca9:	24241b        	s8i	a4, a2, 27
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
  905cac:	885c      	l32i.n	a8, a5, 48
  905cae:	895e      	l32i.n	a9, a5, 56
  905cb0:	08044e        	extui	a4, a8, 0, 15
				   | set11nPktDurRTSCTS(series, 3);
  905cb3:	285211        	l32i	a8, a5, 68
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
  905cb6:	090640        	extui	a6, a9, 0, 1
				   | set11nPktDurRTSCTS(series, 3);
  905cb9:	008811        	slli	a8, a8, 16
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
  905cbc:	dd70      	mov.n	a13, a7
				   | set11nPktDurRTSCTS(series, 3);
  905cbe:	0b8801        	and	a8, a8, a11
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
  905cc1:	06cd38        	moveqz	a13, a12, a6
  905cc4:	048802        	or	a8, a8, a4
				   | set11nPktDurRTSCTS(series, 3);
  905cc7:	245213        	l32i	a4, a5, 76
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
  905cca:	d6d0      	mov.n	a6, a13
				   | set11nPktDurRTSCTS(series, 3);
  905ccc:	1d722d        	l32r	a13, 8e2580 <athos_indirection_table_install+0x1038>
  905ccf:	040b40        	extui	a11, a4, 0, 1
  905cd2:	0bcd38        	moveqz	a13, a12, a11
  905cd5:	086602        	or	a6, a6, a8
  905cd8:	0d6602        	or	a6, a6, a13
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
  905cdb:	068857        	extui	a8, a6, 24, 8
  905cde:	28241c        	s8i	a8, a2, 28
  905ce1:	060857        	extui	a8, a6, 16, 8
  905ce4:	28241d        	s8i	a8, a2, 29
  905ce7:	26241f        	s8i	a6, a2, 31
  905cea:	068847        	extui	a8, a6, 8, 8
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
  905ced:	032640        	extui	a6, a3, 2, 1
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
  905cf0:	28241e        	s8i	a8, a2, 30
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
  905cf3:	0f6611        	slli	a6, a6, 1
  905cf6:	031840        	extui	a8, a3, 1, 1
  905cf9:	086602        	or	a6, a6, a8
  905cfc:	1d7215        	l32r	a13, 8e2550 <athos_indirection_table_install+0x1008>
  905cff:	c088      	movi.n	a8, 8
  905d01:	083301        	and	a3, a3, a8
  905d04:	03cd38        	moveqz	a13, a12, a3
  905d07:	06d602        	or	a6, a13, a6
  905d0a:	9610      	s32i.n	a6, a1, 0
  905d0c:	8653      	l32i.n	a6, a5, 12
				   | set11nRateFlags(series, 1)
  905d0e:	c0c2      	movi.n	a12, 2
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
  905d10:	c13c      	movi.n	a3, 28
  905d12:	0e6611        	slli	a6, a6, 2
  905d15:	036601        	and	a6, a6, a3
				   | set11nRateFlags(series, 1)
  905d18:	c0b4      	movi.n	a11, 4
  905d1a:	0ca301        	and	a3, a10, a12
  905d1d:	c2d0      	movi.n	a13, 32
  905d1f:	0baf01        	and	a15, a10, a11
  905d22:	03d339        	movnez	a3, a13, a3
  905d25:	c4d0      	movi.n	a13, 64
  905d27:	0fdf39        	movnez	a15, a13, a15
  905d2a:	1d722c        	l32r	a13, 8e25dc <athos_indirection_table_install+0x1094>
  905d2d:	08aa01        	and	a10, a10, a8
  905d30:	0ada39        	movnez	a10, a13, a10
  905d33:	8d58      	l32i.n	a13, a5, 32
  905d35:	2e3a80        	movi	a14, 0x380
  905d38:	09dd11        	slli	a13, a13, 7
  905d3b:	0edd01        	and	a13, a13, a14
  905d3e:	06dd02        	or	a13, a13, a6
				   | set11nRateFlags(series, 2)
  905d41:	0c9e01        	and	a14, a9, a12
  905d44:	264a00        	movi	a6, 0x400
  905d47:	0e6e39        	movnez	a14, a6, a14
  905d4a:	167238        	l32r	a6, 8e262c <athos_indirection_table_install+0x10e4>
  905d4d:	9d11      	s32i.n	a13, a1, 4
  905d4f:	0b9d01        	and	a13, a9, a11
  905d52:	0d6d39        	movnez	a13, a6, a13
  905d55:	167231        	l32r	a6, 8e261c <athos_indirection_table_install+0x10d4>
  905d58:	089901        	and	a9, a9, a8
  905d5b:	096939        	movnez	a9, a6, a9
  905d5e:	865d      	l32i.n	a6, a5, 52
  905d60:	1b723e        	l32r	a11, 8e2658 <athos_indirection_table_install+0x1110>
  905d63:	046611        	slli	a6, a6, 12
  905d66:	0b6601        	and	a6, a6, a11
				   | set11nRateFlags(series, 3)
  905d69:	0c4c01        	and	a12, a4, a12
	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
				   | set11nRateFlags(series, 1)
				   | set11nRateFlags(series, 2)
  905d6c:	9613      	s32i.n	a6, a1, 12
				   | set11nRateFlags(series, 3)
  905d6e:	0c7c39        	movnez	a12, a7, a12
  905d71:	c064      	movi.n	a6, 4
  905d73:	1771f7        	l32r	a7, 8e2550 <athos_indirection_table_install+0x1008>
  905d76:	064b01        	and	a11, a4, a6
  905d79:	084801        	and	a8, a4, a8
				   | SM(rtsctsRate, AR_RTSCTSRate);
  905d7c:	8612      	l32i.n	a6, a1, 8
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
				   | set11nRateFlags(series, 1)
				   | set11nRateFlags(series, 2)
				   | set11nRateFlags(series, 3)
  905d7e:	14722d        	l32r	a4, 8e2634 <athos_indirection_table_install+0x10ec>
  905d81:	0b7b39        	movnez	a11, a7, a11
				   | SM(rtsctsRate, AR_RTSCTSRate);
  905d84:	17723f        	l32r	a7, 8e2680 <athos_indirection_table_install+0x1138>
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
				   | set11nRateFlags(series, 1)
				   | set11nRateFlags(series, 2)
				   | set11nRateFlags(series, 3)
  905d87:	084839        	movnez	a8, a4, a8
				   | SM(rtsctsRate, AR_RTSCTSRate);
  905d8a:	0c6410        	slli	a4, a6, 20
  905d8d:	8611      	l32i.n	a6, a1, 4
  905d8f:	074401        	and	a4, a4, a7
  905d92:	064402        	or	a4, a4, a6
  905d95:	8613      	l32i.n	a6, a1, 12
  905d97:	064702        	or	a7, a4, a6
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
				   | set11nRateFlags(series, 1)
				   | set11nRateFlags(series, 2)
				   | set11nRateFlags(series, 3)
  905d9a:	245212        	l32i	a4, a5, 72
  905d9d:	157240        	l32r	a5, 8e26a0 <athos_indirection_table_install+0x1158>
  905da0:	0f4410        	slli	a4, a4, 17
  905da3:	054401        	and	a4, a4, a5
				   | SM(rtsctsRate, AR_RTSCTSRate);
  905da6:	047602        	or	a6, a7, a4
  905da9:	8410      	l32i.n	a4, a1, 0
  905dab:	046602        	or	a6, a6, a4
  905dae:	036302        	or	a3, a6, a3
  905db1:	0f3f02        	or	a15, a3, a15
  905db4:	0afa02        	or	a10, a15, a10
  905db7:	0eae02        	or	a14, a10, a14
  905dba:	0ded02        	or	a13, a14, a13
  905dbd:	09d902        	or	a9, a13, a9
  905dc0:	0c9c02        	or	a12, a9, a12
  905dc3:	0bcb02        	or	a11, a12, a11
  905dc6:	08b802        	or	a8, a11, a8
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
  905dc9:	088357        	extui	a3, a8, 24, 8
  905dcc:	232424        	s8i	a3, a2, 36
  905dcf:	080357        	extui	a3, a8, 16, 8
  905dd2:	232425        	s8i	a3, a2, 37
  905dd5:	088347        	extui	a3, a8, 8, 8
  905dd8:	232426        	s8i	a3, a2, 38
  905ddb:	282427        	s8i	a8, a2, 39
  905dde:	d10f      	retw.n

00905de0 <ar5416Set11nAggrFirst_20>:
				   | SM(rtsctsRate, AR_RTSCTSRate);
}

void ar5416Set11nAggrFirst_20(struct ath_tx_desc *ds, a_uint32_t aggrLen,
			      a_uint32_t numDelims)
{
  905de0:	6c1004        	entry	a1, 32
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);
  905de3:	29200c        	l8ui	a9, a2, 12

	ads->ds_ctl6 &= ~(AR_AggrLen | AR_PadDelim);
	ads->ds_ctl6 |= SM(aggrLen, AR_AggrLen) |
		SM(numDelims, AR_PadDelim);
  905de6:	0e4410        	slli	a4, a4, 18
void ar5416Set11nAggrFirst_20(struct ath_tx_desc *ds, a_uint32_t aggrLen,
			      a_uint32_t numDelims)
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);
  905de9:	089810        	slli	a8, a9, 24
  905dec:	29200d        	l8ui	a9, a2, 13

	ads->ds_ctl6 &= ~(AR_AggrLen | AR_PadDelim);
	ads->ds_ctl6 |= SM(aggrLen, AR_AggrLen) |
  905def:	03034f        	extui	a3, a3, 0, 16
void ar5416Set11nAggrFirst_20(struct ath_tx_desc *ds, a_uint32_t aggrLen,
			      a_uint32_t numDelims)
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);
  905df2:	009911        	slli	a9, a9, 16
  905df5:	089902        	or	a9, a9, a8
  905df8:	28200e        	l8ui	a8, a2, 14
  905dfb:	088811        	slli	a8, a8, 8
  905dfe:	098902        	or	a9, a8, a9
  905e01:	28200f        	l8ui	a8, a2, 15
  905e04:	098802        	or	a8, a8, a9
  905e07:	197241        	l32r	a9, 8e270c <athos_indirection_table_install+0x11c4>
  905e0a:	098802        	or	a8, a8, a9
  905e0d:	088957        	extui	a9, a8, 24, 8
  905e10:	29240c        	s8i	a9, a2, 12
  905e13:	080957        	extui	a9, a8, 16, 8
  905e16:	29240d        	s8i	a9, a2, 13
  905e19:	28240f        	s8i	a8, a2, 15
  905e1c:	088947        	extui	a9, a8, 8, 8

	ads->ds_ctl6 &= ~(AR_AggrLen | AR_PadDelim);
	ads->ds_ctl6 |= SM(aggrLen, AR_AggrLen) |
		SM(numDelims, AR_PadDelim);
  905e1f:	187242        	l32r	a8, 8e2728 <athos_indirection_table_install+0x11e0>
void ar5416Set11nAggrFirst_20(struct ath_tx_desc *ds, a_uint32_t aggrLen,
			      a_uint32_t numDelims)
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);
  905e22:	29240e        	s8i	a9, a2, 14

	ads->ds_ctl6 &= ~(AR_AggrLen | AR_PadDelim);
	ads->ds_ctl6 |= SM(aggrLen, AR_AggrLen) |
		SM(numDelims, AR_PadDelim);
  905e25:	084401        	and	a4, a4, a8
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);

	ads->ds_ctl6 &= ~(AR_AggrLen | AR_PadDelim);
  905e28:	282020        	l8ui	a8, a2, 32
	ads->ds_ctl6 |= SM(aggrLen, AR_AggrLen) |
  905e2b:	034402        	or	a4, a4, a3
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);

	ads->ds_ctl6 &= ~(AR_AggrLen | AR_PadDelim);
  905e2e:	088310        	slli	a3, a8, 24
  905e31:	282021        	l8ui	a8, a2, 33
  905e34:	008811        	slli	a8, a8, 16
  905e37:	038802        	or	a8, a8, a3
  905e3a:	232022        	l8ui	a3, a2, 34
  905e3d:	083311        	slli	a3, a3, 8
  905e40:	083802        	or	a8, a3, a8
  905e43:	232023        	l8ui	a3, a2, 35
  905e46:	083302        	or	a3, a3, a8
  905e49:	187243        	l32r	a8, 8e2758 <athos_indirection_table_install+0x1210>
  905e4c:	083301        	and	a3, a3, a8
	ads->ds_ctl6 |= SM(aggrLen, AR_AggrLen) |
  905e4f:	034302        	or	a3, a4, a3
  905e52:	038457        	extui	a4, a3, 24, 8
  905e55:	242420        	s8i	a4, a2, 32
  905e58:	030457        	extui	a4, a3, 16, 8
  905e5b:	242421        	s8i	a4, a2, 33
  905e5e:	038447        	extui	a4, a3, 8, 8
  905e61:	242422        	s8i	a4, a2, 34
  905e64:	232423        	s8i	a3, a2, 35
  905e67:	d10f      	retw.n
  905e69:	000000        	ill

00905e6c <ar5416Set11nAggrMiddle_20>:
		SM(numDelims, AR_PadDelim);
}

void ar5416Set11nAggrMiddle_20(struct ath_tx_desc *ds, a_uint32_t numDelims)
{
  905e6c:	6c1004        	entry	a1, 32
	struct ar5416_desc *ads = AR5416DESC(ds);
	a_uint32_t ctl6;

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);
  905e6f:	29200c        	l8ui	a9, a2, 12
	 * We use a stack variable to manipulate ctl6 to reduce uncached 
	 * read modify, modfiy, write.
	 */
	ctl6 = ads->ds_ctl6;
	ctl6 &= ~AR_PadDelim;
	ctl6 |= SM(numDelims, AR_PadDelim);
  905e72:	0e3310        	slli	a3, a3, 18
void ar5416Set11nAggrMiddle_20(struct ath_tx_desc *ds, a_uint32_t numDelims)
{
	struct ar5416_desc *ads = AR5416DESC(ds);
	a_uint32_t ctl6;

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);
  905e75:	089810        	slli	a8, a9, 24
  905e78:	29200d        	l8ui	a9, a2, 13
  905e7b:	009911        	slli	a9, a9, 16
  905e7e:	089902        	or	a9, a9, a8
  905e81:	28200e        	l8ui	a8, a2, 14
  905e84:	088811        	slli	a8, a8, 8
  905e87:	098902        	or	a9, a8, a9
  905e8a:	28200f        	l8ui	a8, a2, 15
  905e8d:	098802        	or	a8, a8, a9
  905e90:	197241        	l32r	a9, 8e2794 <athos_indirection_table_install+0x124c>
  905e93:	098802        	or	a8, a8, a9
  905e96:	088957        	extui	a9, a8, 24, 8
  905e99:	29240c        	s8i	a9, a2, 12
  905e9c:	080957        	extui	a9, a8, 16, 8
  905e9f:	29240d        	s8i	a9, a2, 13
  905ea2:	088947        	extui	a9, a8, 8, 8
  905ea5:	29240e        	s8i	a9, a2, 14

	/*
	 * We use a stack variable to manipulate ctl6 to reduce uncached 
	 * read modify, modfiy, write.
	 */
	ctl6 = ads->ds_ctl6;
  905ea8:	292020        	l8ui	a9, a2, 32
void ar5416Set11nAggrMiddle_20(struct ath_tx_desc *ds, a_uint32_t numDelims)
{
	struct ar5416_desc *ads = AR5416DESC(ds);
	a_uint32_t ctl6;

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);
  905eab:	28240f        	s8i	a8, a2, 15

	/*
	 * We use a stack variable to manipulate ctl6 to reduce uncached 
	 * read modify, modfiy, write.
	 */
	ctl6 = ads->ds_ctl6;
  905eae:	089810        	slli	a8, a9, 24
  905eb1:	292021        	l8ui	a9, a2, 33
  905eb4:	009911        	slli	a9, a9, 16
  905eb7:	089902        	or	a9, a9, a8
  905eba:	282022        	l8ui	a8, a2, 34
  905ebd:	088811        	slli	a8, a8, 8
  905ec0:	098902        	or	a9, a8, a9
  905ec3:	282023        	l8ui	a8, a2, 35
  905ec6:	098802        	or	a8, a8, a9
	ctl6 &= ~AR_PadDelim;
  905ec9:	197244        	l32r	a9, 8e27dc <athos_indirection_table_install+0x1294>
  905ecc:	098801        	and	a8, a8, a9
	ctl6 |= SM(numDelims, AR_PadDelim);
  905ecf:	197242        	l32r	a9, 8e27d8 <athos_indirection_table_install+0x1290>
  905ed2:	093301        	and	a3, a3, a9
  905ed5:	083302        	or	a3, a3, a8
	ads->ds_ctl6 = ctl6;
  905ed8:	038857        	extui	a8, a3, 24, 8
  905edb:	282420        	s8i	a8, a2, 32
  905ede:	030857        	extui	a8, a3, 16, 8
  905ee1:	282421        	s8i	a8, a2, 33
  905ee4:	038847        	extui	a8, a3, 8, 8
  905ee7:	282422        	s8i	a8, a2, 34
  905eea:	232423        	s8i	a3, a2, 35
  905eed:	d10f      	retw.n
	...

00905ef0 <ar5416Set11nAggrLast_20>:
}

void ar5416Set11nAggrLast_20(struct ath_tx_desc *ds)
{
  905ef0:	6c1004        	entry	a1, 32
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= AR_IsAggr;
  905ef3:	29200c        	l8ui	a9, a2, 12
  905ef6:	089810        	slli	a8, a9, 24
  905ef9:	29200d        	l8ui	a9, a2, 13
  905efc:	009911        	slli	a9, a9, 16
  905eff:	089902        	or	a9, a9, a8
  905f02:	28200e        	l8ui	a8, a2, 14
  905f05:	088811        	slli	a8, a8, 8
  905f08:	098902        	or	a9, a8, a9
  905f0b:	28200f        	l8ui	a8, a2, 15
  905f0e:	098802        	or	a8, a8, a9
	ads->ds_ctl1 &= ~AR_MoreAggr;
  905f11:	197245        	l32r	a9, 8e2828 <athos_indirection_table_install+0x12e0>
  905f14:	098801        	and	a8, a8, a9
  905f17:	197231        	l32r	a9, 8e27dc <athos_indirection_table_install+0x1294>
  905f1a:	098802        	or	a8, a8, a9
  905f1d:	088957        	extui	a9, a8, 24, 8
  905f20:	29240c        	s8i	a9, a2, 12
  905f23:	080957        	extui	a9, a8, 16, 8
  905f26:	29240d        	s8i	a9, a2, 13
  905f29:	088947        	extui	a9, a8, 8, 8
  905f2c:	29240e        	s8i	a9, a2, 14
  905f2f:	28240f        	s8i	a8, a2, 15
	ads->ds_ctl6 &= ~AR_PadDelim;
  905f32:	292020        	l8ui	a9, a2, 32
  905f35:	282021        	l8ui	a8, a2, 33
  905f38:	089910        	slli	a9, a9, 24
  905f3b:	008811        	slli	a8, a8, 16
  905f3e:	098902        	or	a9, a8, a9
  905f41:	282022        	l8ui	a8, a2, 34
  905f44:	088811        	slli	a8, a8, 8
  905f47:	098802        	or	a8, a8, a9
  905f4a:	292023        	l8ui	a9, a2, 35
  905f4d:	089902        	or	a9, a9, a8
  905f50:	187244        	l32r	a8, 8e2860 <athos_indirection_table_install+0x1318>
  905f53:	292423        	s8i	a9, a2, 35
  905f56:	089801        	and	a8, a9, a8
  905f59:	088a57        	extui	a10, a8, 24, 8
  905f5c:	2a2420        	s8i	a10, a2, 32
  905f5f:	080a57        	extui	a10, a8, 16, 8
  905f62:	088847        	extui	a8, a8, 8, 8
  905f65:	2a2421        	s8i	a10, a2, 33
  905f68:	282422        	s8i	a8, a2, 34
  905f6b:	d10f      	retw.n
  905f6d:	000000        	ill

00905f70 <ar5416Clr11nAggr_20>:
}

void ar5416Clr11nAggr_20(struct ath_tx_desc *ds)
{
  905f70:	6c1004        	entry	a1, 32
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 &= (~AR_IsAggr & ~AR_MoreAggr);
  905f73:	29200c        	l8ui	a9, a2, 12
  905f76:	28200d        	l8ui	a8, a2, 13
  905f79:	089910        	slli	a9, a9, 24
  905f7c:	008811        	slli	a8, a8, 16
  905f7f:	098902        	or	a9, a8, a9
  905f82:	28200e        	l8ui	a8, a2, 14
  905f85:	088811        	slli	a8, a8, 8
  905f88:	098802        	or	a8, a8, a9
  905f8b:	29200f        	l8ui	a9, a2, 15
  905f8e:	089902        	or	a9, a9, a8
  905f91:	187246        	l32r	a8, 8e28ac <athos_indirection_table_install+0x1364>
  905f94:	29240f        	s8i	a9, a2, 15
  905f97:	089801        	and	a8, a9, a8
  905f9a:	088a57        	extui	a10, a8, 24, 8
  905f9d:	2a240c        	s8i	a10, a2, 12
  905fa0:	080a57        	extui	a10, a8, 16, 8
  905fa3:	088847        	extui	a8, a8, 8, 8
  905fa6:	2a240d        	s8i	a10, a2, 13
  905fa9:	28240e        	s8i	a8, a2, 14
  905fac:	d10f      	retw.n
	...

00905fb0 <ar5416Set11nBurstDuration_20>:
}

void ar5416Set11nBurstDuration_20(struct ath_tx_desc *ds,
				  a_uint32_t burstDuration)
{
  905fb0:	6c1004        	entry	a1, 32
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl2 &= ~AR_BurstDur;
  905fb3:	292010        	l8ui	a9, a2, 16
	ads->ds_ctl2 |= SM(burstDuration, AR_BurstDur);
  905fb6:	03034e        	extui	a3, a3, 0, 15
void ar5416Set11nBurstDuration_20(struct ath_tx_desc *ds,
				  a_uint32_t burstDuration)
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl2 &= ~AR_BurstDur;
  905fb9:	089810        	slli	a8, a9, 24
  905fbc:	292011        	l8ui	a9, a2, 17
  905fbf:	009911        	slli	a9, a9, 16
  905fc2:	089902        	or	a9, a9, a8
  905fc5:	282012        	l8ui	a8, a2, 18
  905fc8:	088811        	slli	a8, a8, 8
  905fcb:	098902        	or	a9, a8, a9
  905fce:	282013        	l8ui	a8, a2, 19
  905fd1:	098802        	or	a8, a8, a9
  905fd4:	197247        	l32r	a9, 8e28f0 <athos_indirection_table_install+0x13a8>
  905fd7:	098801        	and	a8, a8, a9
	ads->ds_ctl2 |= SM(burstDuration, AR_BurstDur);
  905fda:	038302        	or	a3, a8, a3
  905fdd:	038857        	extui	a8, a3, 24, 8
  905fe0:	282410        	s8i	a8, a2, 16
  905fe3:	030857        	extui	a8, a3, 16, 8
  905fe6:	282411        	s8i	a8, a2, 17
  905fe9:	038847        	extui	a8, a3, 8, 8
  905fec:	282412        	s8i	a8, a2, 18
  905fef:	232413        	s8i	a3, a2, 19
  905ff2:	d10f      	retw.n

00905ff4 <ar5416Set11nVirtualMoreFrag_20>:
}

void ar5416Set11nVirtualMoreFrag_20(struct ath_tx_desc *ds,
				    a_uint32_t vmf)
{
  905ff4:	6c1004        	entry	a1, 32
  905ff7:	2b2008        	l8ui	a11, a2, 8
  905ffa:	2a2009        	l8ui	a10, a2, 9
  905ffd:	29200a        	l8ui	a9, a2, 10
  906000:	2c200b        	l8ui	a12, a2, 11
	struct ar5416_desc *ads = AR5416DESC(ds);

	if (vmf) {
  906003:	ca3d      	beqz.n	a3, 906034 <ar5416Set11nVirtualMoreFrag_20+0x40>
		ads->ds_ctl0 |= AR_VirtMoreFrag;
  906005:	08b810        	slli	a8, a11, 24
  906008:	00aa11        	slli	a10, a10, 16
  90600b:	08aa02        	or	a10, a10, a8
  90600e:	089811        	slli	a8, a9, 8
  906011:	0a8802        	or	a8, a8, a10
  906014:	1971f2        	l32r	a9, 8e27dc <athos_indirection_table_install+0x1294>
  906017:	08c802        	or	a8, a12, a8
  90601a:	098802        	or	a8, a8, a9
  90601d:	088957        	extui	a9, a8, 24, 8
  906020:	292408        	s8i	a9, a2, 8
  906023:	080957        	extui	a9, a8, 16, 8
  906026:	292409        	s8i	a9, a2, 9
  906029:	088947        	extui	a9, a8, 8, 8
  90602c:	29240a        	s8i	a9, a2, 10
  90602f:	28240b        	s8i	a8, a2, 11
  906032:	d10f      	retw.n
	} else {
		ads->ds_ctl0 &= ~AR_VirtMoreFrag;
  906034:	08bb10        	slli	a11, a11, 24
  906037:	00aa11        	slli	a10, a10, 16
  90603a:	0baa02        	or	a10, a10, a11
  90603d:	089911        	slli	a9, a9, 8
  906040:	0a9902        	or	a9, a9, a10
  906043:	1a7248        	l32r	a10, 8e2964 <athos_indirection_table_install+0x141c>
  906046:	09c902        	or	a9, a12, a9
  906049:	0a9a01        	and	a10, a9, a10
  90604c:	0a8857        	extui	a8, a10, 24, 8
  90604f:	282408        	s8i	a8, a2, 8
  906052:	0a0857        	extui	a8, a10, 16, 8
  906055:	0a8a47        	extui	a10, a10, 8, 8
  906058:	282409        	s8i	a8, a2, 9
  90605b:	2a240a        	s8i	a10, a2, 10
  90605e:	29240b        	s8i	a9, a2, 11
  906061:	d10f      	retw.n
	...

00906064 <ar5416Detach>:
		.ah_setInterrupts        = ar5416SetInterrupts,
	},
};

void ar5416Detach(struct ath_hal *ah)
{
  906064:	6c1004        	entry	a1, 32
	HALASSERT(ah != AH_NULL);
	ath_hal_free(ah);
  906067:	da20      	mov.n	a10, a2
  906069:	5bf6dc        	call8	903bdc <ath_hal_free>
  90606c:	d10f      	retw.n
	...

00906070 <ar5416StopDmaReceive>:
	iowrite32_mac(AR_RXDP, rxdp);
	HALASSERT(ioread32_mac(AR_RXDP) == rxdp);
}

HAL_BOOL ar5416StopDmaReceive(struct ath_hal *ah)
{
  906070:	6c1004        	entry	a1, 32
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  906073:	187223        	l32r	a8, 8e2900 <athos_indirection_table_install+0x13b8>
  906076:	c290      	movi.n	a9, 32
  906078:	0c0200        	memw
  90607b:	9980      	s32i.n	a9, a8, 0
	iowrite32_mac(AR_CR, AR_CR_RXD); /* Set receive disable bit */
	if (!ath_hal_wait(ah, AR_CR, AR_CR_RXE, 0)) {
  90607d:	c0d0      	movi.n	a13, 0
  90607f:	c0c4      	movi.n	a12, 4
  906081:	c0b8      	movi.n	a11, 8
  906083:	da20      	mov.n	a10, a2
  906085:	5bfbf1        	call8	90504c <ath_hal_wait>
  906088:	c081      	movi.n	a8, 1
  90608a:	c020      	movi.n	a2, 0
  90608c:	0a8239        	movnez	a2, a8, a10
		return AH_FALSE;
	} else {
		return AH_TRUE;
	}
}
  90608f:	d10f      	retw.n
  906091:	000000        	ill

00906094 <ar5416AbortTxDma>:
#endif
        return npend;
}

HAL_BOOL ar5416AbortTxDma(struct ath_hal *ah)
{
  906094:	6c1004        	entry	a1, 32
  906097:	137249        	l32r	a3, 8e29bc <athos_indirection_table_install+0x1474>
  90609a:	243aff        	movi	a4, 0x3ff
  90609d:	0c0200        	memw
  9060a0:	9430      	s32i.n	a4, a3, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  9060a2:	14724a        	l32r	a4, 8e29cc <athos_indirection_table_install+0x1484>
	iowrite32_mac(AR_Q_TXD, AR_Q_TXD_M);

	/*
	 * set tx abort bits
	 */
	OS_REG_SET_BIT(ah, AR_PCU_MISC, (AR_PCU_FORCE_QUIET_COLL | AR_PCU_CLEAR_VMF));
  9060a5:	15724b        	l32r	a5, 8e29d4 <athos_indirection_table_install+0x148c>
  9060a8:	0c0200        	memw
  9060ab:	8340      	l32i.n	a3, a4, 0
  9060ad:	053302        	or	a3, a3, a5
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  9060b0:	0c0200        	memw
  9060b3:	9340      	s32i.n	a3, a4, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  9060b5:	147224        	l32r	a4, 8e2948 <athos_indirection_table_install+0x1400>
	OS_REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_FORCE_CH_IDLE_HIGH);
  9060b8:	15722e        	l32r	a5, 8e2970 <athos_indirection_table_install+0x1428>
  9060bb:	0c0200        	memw
  9060be:	8340      	l32i.n	a3, a4, 0
  9060c0:	053302        	or	a3, a3, a5
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  9060c3:	0c0200        	memw
  9060c6:	9340      	s32i.n	a3, a4, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  9060c8:	14724c        	l32r	a4, 8e29f8 <athos_indirection_table_install+0x14b0>
	OS_REG_SET_BIT(ah, AR_D_GBL_IFS_MISC, AR_D_GBL_IFS_MISC_IGNORE_BACKOFF);
  9060cb:	157215        	l32r	a5, 8e2920 <athos_indirection_table_install+0x13d8>
  9060ce:	0c0200        	memw
  9060d1:	8340      	l32i.n	a3, a4, 0
  9060d3:	053302        	or	a3, a3, a5
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  9060d6:	0c0200        	memw
  9060d9:	9340      	s32i.n	a3, a4, 0
	for (q = 0; q < AR_NUM_QCU; q++) {
		for (i = 0; i < AR5416_ABORT_LOOPS; i++) {
			if (!ar5416NumTxPending(ah, q))
				break;

			OS_DELAY(AR5416_ABORT_WAIT);
  9060db:	c055      	movi.n	a5, 5
	OS_REG_SET_BIT(ah, AR_D_GBL_IFS_MISC, AR_D_GBL_IFS_MISC_IGNORE_BACKOFF);

	/*
	 * wait on all tx queues
	 */
	for (q = 0; q < AR_NUM_QCU; q++) {
  9060dd:	c040      	movi.n	a4, 0
  9060df:	600019        	j	9060fc <ar5416AbortTxDma+0x68>
		for (i = 0; i < AR5416_ABORT_LOOPS; i++) {
			if (!ar5416NumTxPending(ah, q))
  9060e2:	db40      	mov.n	a11, a4
  9060e4:	da20      	mov.n	a10, a2
  9060e6:	5bfcdd        	call8	90545c <ar5416NumTxPending>
  9060e9:	64a05b        	beqz	a10, 906148 <ar5416AbortTxDma+0xb4>
				break;

			OS_DELAY(AR5416_ABORT_WAIT);
  9060ec:	da50      	mov.n	a10, a5
  9060ee:	233cff        	addi	a3, a3, -1
  9060f1:	5bf6ad        	call8	903ba8 <ath_hal_delay>

	/*
	 * wait on all tx queues
	 */
	for (q = 0; q < AR_NUM_QCU; q++) {
		for (i = 0; i < AR5416_ABORT_LOOPS; i++) {
  9060f4:	653fea        	bnez	a3, 9060e2 <ar5416AbortTxDma+0x4e>
				break;

			OS_DELAY(AR5416_ABORT_WAIT);
		}
		if (i == AR5416_ABORT_LOOPS) {
			return AH_FALSE;
  9060f7:	d230      	mov.n	a2, a3
  9060f9:	d10f      	retw.n
  9060fb:	00233a        	movltz	a3, a2, a0
#endif
        return npend;
}

HAL_BOOL ar5416AbortTxDma(struct ath_hal *ah)
{
  9060fe:	e8          	.byte 0xe8
  9060ff:	63ffdf        	j	9060e2 <ar5416AbortTxDma+0x4e>
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  906102:	13724a        	l32r	a3, 8e2a2c <athos_indirection_table_install+0x14e4>
	}

	/*
	 * clear tx abort bits
	 */
	OS_REG_CLR_BIT(ah, AR_PCU_MISC, (AR_PCU_FORCE_QUIET_COLL | AR_PCU_CLEAR_VMF));
  906105:	14724d        	l32r	a4, 8e2a3c <athos_indirection_table_install+0x14f4>
  906108:	0c0200        	memw
  90610b:	8230      	l32i.n	a2, a3, 0
  90610d:	042201        	and	a2, a2, a4
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  906110:	0c0200        	memw
  906113:	9230      	s32i.n	a2, a3, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  906115:	137224        	l32r	a3, 8e29a8 <athos_indirection_table_install+0x1460>
	OS_REG_CLR_BIT(ah, AR_DIAG_SW, AR_DIAG_FORCE_CH_IDLE_HIGH);
  906118:	147239        	l32r	a4, 8e29fc <athos_indirection_table_install+0x14b4>
  90611b:	0c0200        	memw
  90611e:	8230      	l32i.n	a2, a3, 0
  906120:	042201        	and	a2, a2, a4
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  906123:	0c0200        	memw
  906126:	9230      	s32i.n	a2, a3, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  906128:	13724c        	l32r	a3, 8e2a58 <athos_indirection_table_install+0x1510>
	OS_REG_CLR_BIT(ah, AR_D_GBL_IFS_MISC, AR_D_GBL_IFS_MISC_IGNORE_BACKOFF);
  90612b:	14724e        	l32r	a4, 8e2a64 <athos_indirection_table_install+0x151c>
  90612e:	0c0200        	memw
  906131:	8230      	l32i.n	a2, a3, 0
  906133:	042201        	and	a2, a2, a4
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  906136:	0c0200        	memw
  906139:	9230      	s32i.n	a2, a3, 0
  90613b:	127249        	l32r	a2, 8e2a60 <athos_indirection_table_install+0x1518>
  90613e:	0c0200        	memw
  906141:	9a20      	s32i.n	a10, a2, 0
	/*
	 * clear txd
	 */
	iowrite32_mac(AR_Q_TXD, 0);

	return AH_TRUE;
  906143:	c021      	movi.n	a2, 1
  906145:	d10f      	retw.n
  906147:	00b144        	extui	a1, a0, 11, 5
	OS_REG_SET_BIT(ah, AR_D_GBL_IFS_MISC, AR_D_GBL_IFS_MISC_IGNORE_BACKOFF);

	/*
	 * wait on all tx queues
	 */
	for (q = 0; q < AR_NUM_QCU; q++) {
  90614a:	6949ae        	bnei	a4, 10, 9060fc <ar5416AbortTxDma+0x68>
  90614d:	63ffb1        	j	906102 <ar5416AbortTxDma+0x6e>

00906150 <ar5416StopTxDma>:

	return AH_TRUE;
}

HAL_BOOL ar5416StopTxDma(struct ath_hal*ah, a_uint32_t q)
{
  906150:	6c1004        	entry	a1, 32
  906153:	157249        	l32r	a5, 8e2a78 <athos_indirection_table_install+0x1530>
	
        HALASSERT(q < AH_PRIVATE(ah)->ah_caps.halTotalQueues);

        HALASSERT(AH5416(ah)->ah_txq[q].tqi_type != HAL_TX_QUEUE_INACTIVE);

	iowrite32_mac(AR_Q_TXD, 1 << q);
  906156:	c041      	movi.n	a4, 1
  906158:	003104        	ssl	a3
  90615b:	00441a        	sll	a4, a4
  90615e:	0c0200        	memw
  906161:	9450      	s32i.n	a4, a5, 0
        for (i = 1000; i != 0; i--) {
  906163:	243ae8        	movi	a4, 0x3e8
                if (ar5416NumTxPending(ah, q) == 0)
                        break;
                OS_DELAY(100);        /* XXX get actual value */
  906166:	250a64        	movi	a5, 100

        HALASSERT(AH5416(ah)->ah_txq[q].tqi_type != HAL_TX_QUEUE_INACTIVE);

	iowrite32_mac(AR_Q_TXD, 1 << q);
        for (i = 1000; i != 0; i--) {
                if (ar5416NumTxPending(ah, q) == 0)
  906169:	db30      	mov.n	a11, a3
  90616b:	da20      	mov.n	a10, a2
  90616d:	5bfcbb        	call8	90545c <ar5416NumTxPending>
  906170:	c8a8      	beqz.n	a10, 90617c <ar5416StopTxDma+0x2c>
                        break;
                OS_DELAY(100);        /* XXX get actual value */
  906172:	da50      	mov.n	a10, a5
        HALASSERT(q < AH_PRIVATE(ah)->ah_caps.halTotalQueues);

        HALASSERT(AH5416(ah)->ah_txq[q].tqi_type != HAL_TX_QUEUE_INACTIVE);

	iowrite32_mac(AR_Q_TXD, 1 << q);
        for (i = 1000; i != 0; i--) {
  906174:	b044      	addi.n	a4, a4, -1
                if (ar5416NumTxPending(ah, q) == 0)
                        break;
                OS_DELAY(100);        /* XXX get actual value */
  906176:	5bf68c        	call8	903ba8 <ath_hal_delay>
        HALASSERT(q < AH_PRIVATE(ah)->ah_caps.halTotalQueues);

        HALASSERT(AH5416(ah)->ah_txq[q].tqi_type != HAL_TX_QUEUE_INACTIVE);

	iowrite32_mac(AR_Q_TXD, 1 << q);
        for (i = 1000; i != 0; i--) {
  906179:	654fec        	bnez	a4, 906169 <ar5416StopTxDma+0x19>
  90617c:	137249        	l32r	a3, 8e2aa0 <athos_indirection_table_install+0x1558>
  90617f:	c020      	movi.n	a2, 0
  906181:	0c0200        	memw
  906184:	9230      	s32i.n	a2, a3, 0
                        break;
                OS_DELAY(100);        /* XXX get actual value */
        }

	iowrite32_mac(AR_Q_TXD, 0);
        return (i != 0);
  906186:	c031      	movi.n	a3, 1
  906188:	043239        	movnez	a2, a3, a4
}
  90618b:	d10f      	retw.n
  90618d:	000000        	ill

00906190 <ar5416GetPendingInterrupts>:
	 */
	return ((host_isr != AR_INTR_SPURIOUS) && (host_isr & AR_INTR_MAC_IRQ));
}

HAL_BOOL ar5416GetPendingInterrupts(struct ath_hal *ah, HAL_INT *masked)
{
  906190:	6c1004        	entry	a1, 32
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  906193:	187216        	l32r	a8, 8e29ec <athos_indirection_table_install+0x14a4>
  906196:	0c0200        	memw
  906199:	8880      	l32i.n	a8, a8, 0
	a_uint32_t isr;
#ifndef AR9100
	HAL_BOOL fatal_int = AH_FALSE;
	a_uint32_t sync_cause;

	if (ioread32_mac(AR_INTR_ASYNC_CAUSE)
  90619b:	7e870d        	bbci	a8, 30, 9061ac <ar5416GetPendingInterrupts+0x1c>
  90619e:	18724f        	l32r	a8, 8e2adc <athos_indirection_table_install+0x1594>
  9061a1:	0c0200        	memw
  9061a4:	8880      	l32i.n	a8, a8, 0
			& AR_INTR_MAC_IRQ) {
		if ((ioread32_mac(AR_RTC_STATUS)
				& AR_RTC_STATUS_M) != AR_RTC_STATUS_ON) {
  9061a6:	080843        	extui	a8, a8, 0, 4
	HAL_BOOL fatal_int = AH_FALSE;
	a_uint32_t sync_cause;

	if (ioread32_mac(AR_INTR_ASYNC_CAUSE)
			& AR_INTR_MAC_IRQ) {
		if ((ioread32_mac(AR_RTC_STATUS)
  9061a9:	688208        	beqi	a8, 2, 9061b5 <ar5416GetPendingInterrupts+0x25>
				& AR_RTC_STATUS_M) != AR_RTC_STATUS_ON) {
			*masked = 0;
  9061ac:	c020      	movi.n	a2, 0
  9061ae:	9230      	s32i.n	a2, a3, 0
			return AH_FALSE;
  9061b0:	d10f      	retw.n
  9061b2:	000000        	ill
  9061b5:	187250        	l32r	a8, 8e2af8 <athos_indirection_table_install+0x15b0>
  9061b8:	0c0200        	memw
  9061bb:	8980      	l32i.n	a9, a8, 0
		*masked = 0;
		return AH_FALSE;
	}
#endif
	isr = ioread32_mac(AR_ISR_RAC);
	if (isr == 0xffffffff) {
  9061bd:	6890eb        	beqi	a9, -1, 9061ac <ar5416GetPendingInterrupts+0x1c>
		*masked = 0;
		return AH_FALSE;
	}

	*masked = isr & HAL_INT_COMMON;
  9061c0:	187218        	l32r	a8, 8e2a20 <athos_indirection_table_install+0x14d8>
	if (isr & (AR_ISR_TXMINTR | AR_ISR_TXINTM)) {
		*masked |= HAL_INT_TX;
	}
#endif

	if (isr & AR_ISR_BCNMISC) {
  9061c3:	1b721a        	l32r	a11, 8e2a2c <athos_indirection_table_install+0x14e4>
	if (isr == 0xffffffff) {
		*masked = 0;
		return AH_FALSE;
	}

	*masked = isr & HAL_INT_COMMON;
  9061c6:	089801        	and	a8, a9, a8
  9061c9:	9830      	s32i.n	a8, a3, 0
	if (isr & (AR_ISR_TXMINTR | AR_ISR_TXINTM)) {
		*masked |= HAL_INT_TX;
	}
#endif

	if (isr & AR_ISR_BCNMISC) {
  9061cb:	7b901f        	bnone	a9, a11, 9061ee <ar5416GetPendingInterrupts+0x5e>
  9061ce:	1a7251        	l32r	a10, 8e2b14 <athos_indirection_table_install+0x15cc>
  9061d1:	0c0200        	memw
  9061d4:	8aa0      	l32i.n	a10, a10, 0
		a_uint32_t s2_s;

		s2_s = ioread32_mac(AR_ISR_S2_S);

		if (s2_s & AR_ISR_S2_GTT) {
  9061d6:	7ba007        	bnone	a10, a11, 9061e1 <ar5416GetPendingInterrupts+0x51>
			*masked |= HAL_INT_GTT;
  9061d9:	1b722c        	l32r	a11, 8e2a8c <athos_indirection_table_install+0x1544>
  9061dc:	0b8802        	or	a8, a8, a11
  9061df:	9830      	s32i.n	a8, a3, 0
		}

		if (s2_s & AR_ISR_S2_CST) {
  9061e1:	79a609        	bbci	a10, 9, 9061ee <ar5416GetPendingInterrupts+0x5e>
			*masked |= HAL_INT_CST;
  9061e4:	8830      	l32i.n	a8, a3, 0
  9061e6:	1a7252        	l32r	a10, 8e2b30 <athos_indirection_table_install+0x15e8>
  9061e9:	0a8802        	or	a8, a8, a10
  9061ec:	9830      	s32i.n	a8, a3, 0
		}
	}

	if (isr & (AR_ISR_RXOK | AR_ISR_RXERR))
  9061ee:	c085      	movi.n	a8, 5
  9061f0:	789008        	bnone	a9, a8, 9061fc <ar5416GetPendingInterrupts+0x6c>
		*masked |= HAL_INT_RX;
  9061f3:	8830      	l32i.n	a8, a3, 0
  9061f5:	c0a1      	movi.n	a10, 1
  9061f7:	0a8802        	or	a8, a8, a10
  9061fa:	9830      	s32i.n	a8, a3, 0
	if (isr & (AR_ISR_TXOK | AR_ISR_TXDESC | AR_ISR_TXERR | AR_ISR_TXEOL)) {
  9061fc:	285ac0        	movi	a8, 0x5c0
  9061ff:	789035        	bnone	a9, a8, 906238 <ar5416GetPendingInterrupts+0xa8>
		struct ath_hal_5416 *ahp = AH5416(ah);
		a_uint32_t           s0_s, s1_s;

		*masked |= HAL_INT_TX;
  906202:	8830      	l32i.n	a8, a3, 0
  906204:	c490      	movi.n	a9, 64
  906206:	098802        	or	a8, a8, a9
  906209:	283600        	s32i	a8, a3, 0
  90620c:	137253        	l32r	a3, 8e2b58 <_HIFusb_isr_handler>
  90620f:	0c0200        	memw
  906212:	8930      	l32i.n	a9, a3, 0
  906214:	137254        	l32r	a3, 8e2b64 <_HIFusb_isr_handler+0xc>
  906217:	0c0200        	memw
  90621a:	283200        	l32i	a8, a3, 0
		s0_s = ioread32_mac(AR_ISR_S0_S);
		s1_s = ioread32_mac(AR_ISR_S1_S);
		ahp->ah_intrTxqs |= MS(s0_s, AR_ISR_S0_QCU_TXOK);
		ahp->ah_intrTxqs |= MS(s0_s, AR_ISR_S0_QCU_TXDESC);
		ahp->ah_intrTxqs |= MS(s1_s, AR_ISR_S1_QCU_TXERR);
		ahp->ah_intrTxqs |= MS(s1_s, AR_ISR_S1_QCU_TXEOL);
  90621d:	089302        	or	a3, a9, a8

		*masked |= HAL_INT_TX;
		s0_s = ioread32_mac(AR_ISR_S0_S);
		s1_s = ioread32_mac(AR_ISR_S1_S);
		ahp->ah_intrTxqs |= MS(s0_s, AR_ISR_S0_QCU_TXOK);
		ahp->ah_intrTxqs |= MS(s0_s, AR_ISR_S0_QCU_TXDESC);
  906220:	09095f        	extui	a9, a9, 16, 16
		ahp->ah_intrTxqs |= MS(s1_s, AR_ISR_S1_QCU_TXERR);
		ahp->ah_intrTxqs |= MS(s1_s, AR_ISR_S1_QCU_TXEOL);
  906223:	08085f        	extui	a8, a8, 16, 16
  906226:	093302        	or	a3, a3, a9
  906229:	083302        	or	a3, a3, a8
  90622c:	282238        	l32i	a8, a2, 224
  90622f:	030349        	extui	a3, a3, 0, 10
  906232:	038302        	or	a3, a8, a3
  906235:	232638        	s32i	a3, a2, 224
  906238:	137255        	l32r	a3, 8e2b8c <_HIFusb_isr_handler+0x34>
	if (AH_TRUE == fatal_int) {
		iowrite32_mac(AR_INTR_SYNC_CAUSE_CLR, sync_cause);
		(void) ioread32_mac(AR_INTR_SYNC_CAUSE_CLR);
	}
#endif
	return AH_TRUE;
  90623b:	c021      	movi.n	a2, 1
  90623d:	0c0200        	memw
  906240:	8830      	l32i.n	a8, a3, 0

#ifndef AR9100
	sync_cause = ioread32_mac(AR_INTR_SYNC_CAUSE);
	fatal_int = ((sync_cause != AR_INTR_SPURIOUS) &&
		     (sync_cause & (AR_INTR_SYNC_HOST1_FATAL
		      | AR_INTR_SYNC_HOST1_PERR))) ? AH_TRUE : AH_FALSE;
  906242:	68800f        	beqi	a8, -1, 906255 <ar5416GetPendingInterrupts+0xc5>
	}

#ifndef AR9100
	sync_cause = ioread32_mac(AR_INTR_SYNC_CAUSE);
	fatal_int = ((sync_cause != AR_INTR_SPURIOUS) &&
		     (sync_cause & (AR_INTR_SYNC_HOST1_FATAL
  906245:	290a60        	movi	a9, 96
		      | AR_INTR_SYNC_HOST1_PERR))) ? AH_TRUE : AH_FALSE;
  906248:	798009        	bnone	a8, a9, 906255 <ar5416GetPendingInterrupts+0xc5>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90624b:	0c0200        	memw
  90624e:	9830      	s32i.n	a8, a3, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  906250:	0c0200        	memw
  906253:	8330      	l32i.n	a3, a3, 0
		iowrite32_mac(AR_INTR_SYNC_CAUSE_CLR, sync_cause);
		(void) ioread32_mac(AR_INTR_SYNC_CAUSE_CLR);
	}
#endif
	return AH_TRUE;
}
  906255:	d10f      	retw.n
	...

00906258 <ar5416SetRxFilter>:
		return AH_TRUE;
	}
}

void ar5416SetRxFilter(struct ath_hal *ah, a_uint32_t bits)
{
  906258:	6c1004        	entry	a1, 32
	a_uint32_t phybits;
    
	iowrite32_mac(AR_RX_FILTER, (bits & 0xff) | AR_RX_COMPR_BAR);
  90625b:	294a00        	movi	a9, 0x400
  90625e:	030847        	extui	a8, a3, 0, 8
  906261:	098802        	or	a8, a8, a9
  906264:	197256        	l32r	a9, 8e2bbc <_HIFusb_isr_handler+0x64>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  906267:	0c0200        	memw
  90626a:	9890      	s32i.n	a8, a9, 0
	phybits = 0;
	if (bits & HAL_RX_FILTER_PHYRADAR)
  90626c:	282a00        	movi	a8, 0x200
  90626f:	083801        	and	a8, a3, a8
		phybits |= AR_PHY_ERR_RADAR;
  906272:	c290      	movi.n	a9, 32
  906274:	089839        	movnez	a8, a9, a8
	if (bits & HAL_RX_FILTER_PHYERR)
  906277:	773705        	bbci	a3, 23, 906280 <ar5416SetRxFilter+0x28>
		phybits |= AR_PHY_ERR_OFDM_TIMING | AR_PHY_ERR_CCK_TIMING;
  90627a:	137257        	l32r	a3, 8e2bd8 <hif_module_install+0x4>
  90627d:	038802        	or	a8, a8, a3
  906280:	137258        	l32r	a3, 8e2be0 <hif_module_install+0xc>
  906283:	197259        	l32r	a9, 8e2be8 <hif_module_install+0x14>
  906286:	0c0200        	memw
  906289:	9830      	s32i.n	a8, a3, 0
	iowrite32_mac(AR_PHY_ERR, phybits);
	if (phybits) {
  90628b:	c88d      	beqz.n	a8, 90629c <ar5416SetRxFilter+0x44>
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90628d:	0c0200        	memw
  906290:	8890      	l32i.n	a8, a9, 0
		iowrite32_mac(AR_RXCFG,
  906292:	c130      	movi.n	a3, 16
  906294:	038802        	or	a8, a8, a3
  906297:	60000b        	j	9062a6 <ar5416SetRxFilter+0x4e>
  90629a:	00000c        	sub	a0, a0, a0
  90629d:	020088        	excw
  9062a0:	90c6      	s32i.n	a0, a12, 24
			     ioread32_mac(AR_RXCFG)
			     | AR_RXCFG_ZLFDMA);
	} else {
		iowrite32_mac(AR_RXCFG,
  9062a2:	3f0388        	excw
  9062a5:	010c02        	or	a12, a0, a1
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  9062a8:	009890        	l32e	a0, a9, -32
  9062ab:	d10f      	retw.n
  9062ad:	000000        	ill

009062b0 <ar5416Attach>:
	ath_hal_free(ah);
}

struct ath_hal *
ar5416Attach(HAL_SOFTC sc, adf_os_device_t dev, HAL_STATUS *status)
{
  9062b0:	6c1004        	entry	a1, 32
	struct ath_hal_5416 *ahp;
	struct ath_hal *ah;

	ahp = ath_hal_malloc(sizeof (struct ath_hal_5416));
  9062b3:	2a1a30        	movi	a10, 0x130
  9062b6:	5bf640        	call8	903bb8 <ath_hal_malloc>
	ath_hal_free(ah);
}

struct ath_hal *
ar5416Attach(HAL_SOFTC sc, adf_os_device_t dev, HAL_STATUS *status)
{
  9062b9:	d520      	mov.n	a5, a2
	struct ath_hal_5416 *ahp;
	struct ath_hal *ah;

	ahp = ath_hal_malloc(sizeof (struct ath_hal_5416));
  9062bb:	d2a0      	mov.n	a2, a10
	if (ahp == AH_NULL) {
  9062bd:	cca4      	bnez.n	a10, 9062c5 <ar5416Attach+0x15>
		*status = HAL_ENOMEM;
  9062bf:	c032      	movi.n	a3, 2
  9062c1:	9340      	s32i.n	a3, a4, 0
		return AH_NULL;
  9062c3:	d10f      	retw.n
	}
	ah = &ahp->ah_priv.h;

	OS_MEMCPY(&ahp->ah_priv, &ar5416hal_10, sizeof(struct ath_hal_private));
  9062c5:	1b725a        	l32r	a11, 8e2c30 <hif_module_install+0x5c>
  9062c8:	2c0ad0        	movi	a12, 208
  9062cb:	5bf646        	call8	903be4 <ath_hal_memcpy>

	ah->ah_dev = dev;
	ah->ah_sc = sc;

	ah->ah_set11nTxDesc        = ar5416Set11nTxDesc_20;
  9062ce:	18725b        	l32r	a8, 8e2c3c <hif_module_install+0x68>
	}
	ah = &ahp->ah_priv.h;

	OS_MEMCPY(&ahp->ah_priv, &ar5416hal_10, sizeof(struct ath_hal_private));

	ah->ah_dev = dev;
  9062d1:	9322      	s32i.n	a3, a2, 8
	ah->ah_sc = sc;

	ah->ah_set11nTxDesc        = ar5416Set11nTxDesc_20;
  9062d3:	982f      	s32i.n	a8, a2, 60
	ah->ah_set11nRateScenario  = ar5416Set11nRateScenario_20;
  9062d5:	18725c        	l32r	a8, 8e2c48 <hif_module_install+0x74>
	ah = &ahp->ah_priv.h;

	OS_MEMCPY(&ahp->ah_priv, &ar5416hal_10, sizeof(struct ath_hal_private));

	ah->ah_dev = dev;
	ah->ah_sc = sc;
  9062d8:	9521      	s32i.n	a5, a2, 4

	ah->ah_set11nTxDesc        = ar5416Set11nTxDesc_20;
	ah->ah_set11nRateScenario  = ar5416Set11nRateScenario_20;
  9062da:	282610        	s32i	a8, a2, 64
	ah->ah_set11nAggrFirst     = ar5416Set11nAggrFirst_20;
  9062dd:	18725d        	l32r	a8, 8e2c54 <hif_module_install+0x80>
  9062e0:	282611        	s32i	a8, a2, 68
	ah->ah_set11nAggrMiddle    = ar5416Set11nAggrMiddle_20;
  9062e3:	18725e        	l32r	a8, 8e2c5c <hif_module_install+0x88>
  9062e6:	282612        	s32i	a8, a2, 72
	ah->ah_set11nAggrLast      = ar5416Set11nAggrLast_20;
  9062e9:	18725f        	l32r	a8, 8e2c68 <hif_module_install+0x94>
  9062ec:	282613        	s32i	a8, a2, 76
	ah->ah_clr11nAggr          = ar5416Clr11nAggr_20;
  9062ef:	187260        	l32r	a8, 8e2c70 <hif_module_install+0x9c>
  9062f2:	282614        	s32i	a8, a2, 80
	ah->ah_set11nBurstDuration = ar5416Set11nBurstDuration_20;
  9062f5:	187261        	l32r	a8, 8e2c7c <hif_module_install+0xa8>
  9062f8:	282615        	s32i	a8, a2, 84
	ah->ah_setupRxDesc         = ar5416SetupRxDesc_20;
  9062fb:	187262        	l32r	a8, 8e2c84 <hif_module_install+0xb0>
  9062fe:	282620        	s32i	a8, a2, 128
	ah->ah_procRxDescFast      = ar5416ProcRxDescFast_20;
  906301:	187263        	l32r	a8, 8e2c90 <hif_module_install+0xbc>
  906304:	282622        	s32i	a8, a2, 136
	ah->ah_setupTxDesc         = ar5416SetupTxDesc_20;
  906307:	187264        	l32r	a8, 8e2c98 <hif_module_install+0xc4>
  90630a:	282617        	s32i	a8, a2, 92
	ah->ah_fillTxDesc          = ar5416FillTxDesc_20;
  90630d:	187265        	l32r	a8, 8e2ca4 <hif_module_install+0xd0>
  906310:	282618        	s32i	a8, a2, 96
	ah->ah_fillKeyTxDesc       = ar5416FillKeyTxDesc_20;
  906313:	187266        	l32r	a8, 8e2cac <hif_module_install+0xd8>
  906316:	282619        	s32i	a8, a2, 100
	ah->ah_procTxDesc          = ar5416ProcTxDesc_20;
  906319:	187267        	l32r	a8, 8e2cb8 <hif_module_install+0xe4>
  90631c:	28261a        	s32i	a8, a2, 104
	ah->ah_set11nVirtualMoreFrag = ar5416Set11nVirtualMoreFrag_20;
  90631f:	187268        	l32r	a8, 8e2cc0 <hif_module_install+0xec>
  906322:	282616        	s32i	a8, a2, 88

	return ah;
}
  906325:	d10f      	retw.n
	...

00906328 <ar5416GetRateTable>:
#undef	HT
#undef	HT_HGI

const HAL_RATE_TABLE *
ar5416GetRateTable(struct ath_hal *ah, a_uint32_t mode)
{
  906328:	6c1004        	entry	a1, 32
	case HAL_MODE_11NA:
		rt = &ar5416_11na_table;
		break;
#endif
	default:
		return AH_NULL;
  90632b:	127269        	l32r	a2, 8e2cd0 <hif_module_install+0xfc>
  90632e:	233dc0        	addmi	a3, a3, 0xffffc000
  906331:	c080      	movi.n	a8, 0
  906333:	038239        	movnez	a2, a8, a3
	}

	return rt;
}
  906336:	d10f      	retw.n

00906338 <ath_pci_suspend>:
	adf_os_free_intr(sc->sc_dev);
}

static void
ath_pci_suspend(adf_drv_handle_t hdl, adf_os_pm_t pm)
{
  906338:	6c1004        	entry	a1, 32
  90633b:	d10f      	retw.n
  90633d:	000000        	ill

00906340 <ath_pci_resume>:
}

static void
ath_pci_resume(adf_drv_handle_t hdl)
{
  906340:	6c1004        	entry	a1, 32
  906343:	d10f      	retw.n
  906345:	000000        	ill

00906348 <ath_pci_remove>:
	return NULL;
}

static void
ath_pci_remove(adf_drv_handle_t hdl)
{
  906348:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = hdl;

	ath_detach((struct ath_softc_tgt *)hdl);
  90634b:	da20      	mov.n	a10, a2
  90634d:	5807c2        	call8	908258 <ath_detach>
}

static inline void
adf_os_free_intr(adf_os_device_t osdev)
{
    __adf_os_free_intr(osdev);
  906350:	2a2246        	l32i	a10, a2, 0x118
  906353:	58002b        	call8	906400 <__adf_os_free_intr>
  906356:	d10f      	retw.n

00906358 <init_ath_pci>:

static adf_drv_info_t ath_drv_info = adf_os_pci_set_drv_info(ath_pci_tgt,&ath_pci_id_table[0], ath_pci_probe, ath_pci_remove, ath_pci_suspend, ath_pci_resume);

a_int32_t
init_ath_pci(void)
{
  906358:	6c1004        	entry	a1, 32
 * @return status of operation
 */
static inline a_status_t 
adf_net_register_drv(adf_drv_info_t *drv)
{
    return(__adf_net_register_drv(drv));
  90635b:	1a726a        	l32r	a10, 8e2d04 <hif_module_install+0x130>
  90635e:	58130b        	call8	90af8c <__adf_net_register_drv>
	return adf_net_register_drv( &ath_drv_info );
}
  906361:	d2a0      	mov.n	a2, a10
  906363:	d10f      	retw.n
  906365:	000000        	ill

00906368 <ath_pci_probe>:
a_int32_t init_ath_pci(void);

static adf_drv_handle_t
ath_pci_probe(adf_os_resource_t *res,a_int32_t count, adf_os_attach_data_t *data,
	      adf_os_device_t osdev)
{
  906368:	6c1004        	entry	a1, 32
}

static inline int 
__adf_os_pci_config_write8(adf_os_device_t osdev, int offset, a_uint8_t val)
{
    wlan_pci_config_write(offset, val, 1);
  90636b:	c0c1      	movi.n	a12, 1
  90636d:	2b0a20        	movi	a11, 32
  906370:	2a0a0c        	movi	a10, 12
  906373:	5bf649        	call8	903c98 <wlan_pci_config_write>
  906376:	c0c1      	movi.n	a12, 1
  906378:	2b0aa8        	movi	a11, 168
  90637b:	c0ad      	movi.n	a10, 13
  90637d:	5bf646        	call8	903c98 <wlan_pci_config_write>
  906380:	16716e        	l32r	a6, 8e2938 <athos_indirection_table_install+0x13f0>
  906383:	13726b        	l32r	a3, 8e2d30 <hif_module_install+0x15c>
  906386:	226252        	l32i	a2, a6, 0x148
  906389:	db30      	mov.n	a11, a3
  90638b:	c0a0      	movi.n	a10, 0
  90638d:	0b2000        	callx8	a2
  906390:	d2a0      	mov.n	a2, a10
	adf_os_pci_config_write8(osdev, ATH_PCI_CACHE_LINE_SIZE, csz);
	adf_os_pci_config_write8(osdev, ATH_PCI_LATENCY_TIMER, 0xa8);

	sc = adf_os_mem_alloc(sizeof(struct ath_pci_softc));

	if (sc == NULL) {
  906392:	ccaa      	bnez.n	a10, 9063a0 <ath_pci_probe+0x38>
		adf_os_print("ath_pci: no memory for device state\n");
  906394:	236212        	l32i	a3, a6, 72
  906397:	1a726c        	l32r	a10, 8e2d48 <hif_module_install+0x174>
  90639a:	0b3000        	callx8	a3
		goto bad2;
  90639d:	d10f      	retw.n
  90639f:	008864        	excw

/* set a memory buffer */
static inline void
__adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
{
	A_MEMSET(buf, b, size);
  9063a2:	dc30      	mov.n	a12, a3
  9063a4:	c0b0      	movi.n	a11, 0
  9063a6:	0b8000        	callx8	a8

	/*
	 * Mark the device as detached to avoid processing
	 * interrupts until setup is complete.
	 */
	sc->aps_sc.sc_invalid = 1;
  9063a9:	232d01        	addmi	a3, a2, 0x100
  9063ac:	283024        	l8ui	a8, a3, 36
  9063af:	29fa80        	movi	a9, -128
  9063b2:	098802        	or	a8, a8, a9
  9063b5:	283424        	s8i	a8, a3, 36

	adf_os_print("ath_pci_probe %x\n",id->device);
  9063b8:	2b4201        	l32i	a11, a4, 4
  9063bb:	266212        	l32i	a6, a6, 72
  9063be:	1a726d        	l32r	a10, 8e2d74 <hif_module_install+0x1a0>
  9063c1:	0b6000        	callx8	a6

	if (ath_tgt_attach(id->device, &sc->aps_sc, osdev) != 0)
  9063c4:	8a41      	l32i.n	a10, a4, 4
  9063c6:	dc50      	mov.n	a12, a5
  9063c8:	db20      	mov.n	a11, a2
  9063ca:	580694        	call8	907e1c <ath_tgt_attach>
  9063cd:	cda1      	bnez.n	a10, 9063e2 <ath_pci_probe+0x7a>
		goto bad3;

	/* ready to process interrupts */
	sc->aps_sc.sc_invalid = 0;
  9063cf:	263024        	l8ui	a6, a3, 36
#include <adf_os_irq_pvt.h>

static inline int
adf_os_setup_intr(adf_os_device_t  osdev, adf_os_drv_intr fn)
{
    return __adf_os_setup_intr(osdev, fn);
  9063d2:	1b726e        	l32r	a11, 8e2d8c <hif_module_install+0x1b8>
  9063d5:	060646        	extui	a6, a6, 0, 7
  9063d8:	263424        	s8i	a6, a3, 36
  9063db:	da50      	mov.n	a10, a5
  9063dd:	580005        	call8	9063f4 <__adf_os_setup_intr>
  9063e0:	d10f      	retw.n
	adf_os_setup_intr(osdev, ath_intr);
	return (adf_drv_handle_t)sc;
bad3:
bad2:
	return NULL;
  9063e2:	c020      	movi.n	a2, 0
}
  9063e4:	d10f      	retw.n
	...

009063e8 <exit_ath_pci>:
	return adf_net_register_drv( &ath_drv_info );
}

void
exit_ath_pci(void)
{
  9063e8:	6c1004        	entry	a1, 32
 * @see adf_net_register_drv()
 */
static inline void
adf_net_unregister_drv(a_uint8_t *drv_name)
{
    __adf_net_unregister_drv(drv_name);
  9063eb:	1a726f        	l32r	a10, 8e2da8 <hif_module_install+0x1d4>
  9063ee:	5812ea        	call8	90af98 <__adf_net_unregister_drv>
  9063f1:	d10f      	retw.n
	...

009063f4 <__adf_os_setup_intr>:
 * @return int
 */

int
__adf_os_setup_intr(__adf_os_device_t  osdev, adf_os_drv_intr fn)
{
  9063f4:	6c1004        	entry	a1, 32
    g_wlan_intr = fn;
  9063f7:	1871d8        	l32r	a8, 8e2b58 <_HIFusb_isr_handler>
    
    return 0;    
}
  9063fa:	c020      	movi.n	a2, 0
 */

int
__adf_os_setup_intr(__adf_os_device_t  osdev, adf_os_drv_intr fn)
{
    g_wlan_intr = fn;
  9063fc:	9380      	s32i.n	a3, a8, 0
    
    return 0;    
}
  9063fe:	d10f      	retw.n

00906400 <__adf_os_free_intr>:
 * @param[in] dev
 * @param[in] sc
 */
void
__adf_os_free_intr(__adf_os_device_t osdev)
{
  906400:	6c1004        	entry	a1, 32
    g_wlan_intr = NULL;  
  906403:	1871d8        	l32r	a8, 8e2b64 <_HIFusb_isr_handler+0xc>
  906406:	c090      	movi.n	a9, 0
  906408:	9980      	s32i.n	a9, a8, 0
  90640a:	d10f      	retw.n

0090640c <__adf_os_mem_alloc>:

#include "cmnos_api.h"
#include "Magpie_api.h"

static inline void *	__adf_os_mem_alloc(adf_os_size_t size)
{
  90640c:	6c1004        	entry	a1, 32
//    return (malloc(size,M_DEVBUF,M_DONTWAIT | M_ZERO));
    return A_ALLOCRAM(size);
  90640f:	18716e        	l32r	a8, 8e29c8 <athos_indirection_table_install+0x1480>
  906412:	db20      	mov.n	a11, a2
  906414:	288252        	l32i	a8, a8, 0x148
  906417:	c0a0      	movi.n	a10, 0
  906419:	0b8000        	callx8	a8
}
  90641c:	d2a0      	mov.n	a2, a10
  90641e:	d10f      	retw.n

00906420 <__adf_os_mem_copy>:
    //free(buf,M_DEVBUF);
}

/* move a memory buffer */
static inline void 		__adf_os_mem_copy(void *dst, const void *src, adf_os_size_t size)
{
  906420:	6c1004        	entry	a1, 32
    A_MEMCPY(dst,src,size);    
  906423:	18716e        	l32r	a8, 8e29dc <athos_indirection_table_install+0x1494>
  906426:	dc40      	mov.n	a12, a4
  906428:	8885      	l32i.n	a8, a8, 20
  90642a:	db30      	mov.n	a11, a3
  90642c:	da20      	mov.n	a10, a2
  90642e:	0b8000        	callx8	a8
  906431:	d10f      	retw.n
	...

00906434 <__adf_os_mem_set>:
}

/* set a memory buffer */
static inline void
__adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
{
  906434:	6c1004        	entry	a1, 32
	A_MEMSET(buf, b, size);
  906437:	18716e        	l32r	a8, 8e29f0 <athos_indirection_table_install+0x14a8>
  90643a:	dc40      	mov.n	a12, a4
  90643c:	8884      	l32i.n	a8, a8, 16
  90643e:	db30      	mov.n	a11, a3
  906440:	da20      	mov.n	a10, a2
  906442:	0b8000        	callx8	a8
  906445:	d10f      	retw.n
	...

00906448 <tgt_HTCRecv_uapsdhandler>:
	ath_tgt_send_beacon(sc, hdr_buf, buf, EndPt);
}

static void tgt_HTCRecv_uapsdhandler(HTC_ENDPOINT_ID EndPt, adf_nbuf_t hdr_buf,
				     adf_nbuf_t buf, void *ServiceCtx)
{
  906448:	6c1004        	entry	a1, 32
  90644b:	d10f      	retw.n
  90644d:	000000        	ill

00906450 <dispatch_magpie_sys_cmds>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void dispatch_magpie_sys_cmds(void *pContext, A_UINT16 Command,
				     A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
  906450:	6c1004        	entry	a1, 32
  906453:	63fffc        	j	906453 <dispatch_magpie_sys_cmds+0x3>
	...

00906458 <htc_setup_comp>:
/*****************/
/* Init / Deinit */
/*****************/

static void htc_setup_comp(void)
{
  906458:	6c1004        	entry	a1, 32
  90645b:	d10f      	retw.n
  90645d:	000000        	ill

00906460 <tgt_ServiceConnect>:
				  HTC_ENDPOINT_ID eid,
				  A_UINT8 *pDataIn,
				  a_int32_t LengthIn,
				  A_UINT8 *pDataOut,
				  a_int32_t *pLengthOut)
{
  906460:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)pService->ServiceCtx;

	switch(pService->ServiceID) {
  906463:	292108        	l16ui	a9, a2, 16
				  A_UINT8 *pDataIn,
				  a_int32_t LengthIn,
				  A_UINT8 *pDataOut,
				  a_int32_t *pLengthOut)
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)pService->ServiceCtx;
  906466:	8826      	l32i.n	a8, a2, 24

	switch(pService->ServiceID) {
  906468:	299dff        	addmi	a9, a9, 0xffffff00
  90646b:	09094f        	extui	a9, a9, 0, 16
  90646e:	c028      	movi.n	a2, 8
  906470:	792344        	bltu	a2, a9, 9064b8 <tgt_ServiceConnect+0x58>
  906473:	1a7270        	l32r	a10, 8e2e34 <hif_module_install+0x260>
  906476:	0e9911        	slli	a9, a9, 2
  906479:	a9a9      	add.n	a9, a10, a9
  90647b:	8290      	l32i.n	a2, a9, 0
  90647d:	0a2000        	jx	a2
	case WMI_CONTROL_SVC:
		sc->wmi_command_ep= eid;
  906480:	23863c        	s32i	a3, a8, 240
		break;
  906483:	600034        	j	9064bb <tgt_ServiceConnect+0x5b>
	case WMI_BEACON_SVC:
		sc->beacon_ep= eid;
  906486:	23863d        	s32i	a3, a8, 244
		break;
  906489:	60002e        	j	9064bb <tgt_ServiceConnect+0x5b>
	case WMI_CAB_SVC:
		sc->cab_ep= eid;
  90648c:	23863e        	s32i	a3, a8, 248
		break;
  90648f:	600028        	j	9064bb <tgt_ServiceConnect+0x5b>
	case WMI_UAPSD_SVC:
		sc->uapsd_ep= eid;
  906492:	23863f        	s32i	a3, a8, 252
		break;
  906495:	600022        	j	9064bb <tgt_ServiceConnect+0x5b>
	case WMI_MGMT_SVC:
		sc->mgmt_ep= eid;
  906498:	238640        	s32i	a3, a8, 0x100
		break;
  90649b:	60001c        	j	9064bb <tgt_ServiceConnect+0x5b>
  90649e:	000023        	excw
	case WMI_DATA_VO_SVC:
		sc->data_VO_ep = eid;
  9064a1:	8641      	l32i.n	a6, a4, 4
		break;
  9064a3:	600014        	j	9064bb <tgt_ServiceConnect+0x5b>
	case WMI_DATA_VI_SVC:
		sc->data_VI_ep = eid;
  9064a6:	238642        	s32i	a3, a8, 0x108
		break;
  9064a9:	60000e        	j	9064bb <tgt_ServiceConnect+0x5b>
	case WMI_DATA_BE_SVC:
		sc->data_BE_ep = eid;
  9064ac:	238643        	s32i	a3, a8, 0x10c
		break;
  9064af:	600008        	j	9064bb <tgt_ServiceConnect+0x5b>
	case WMI_DATA_BK_SVC:
		sc->data_BK_ep = eid;
  9064b2:	238644        	s32i	a3, a8, 0x110
		break;
  9064b5:	600002        	j	9064bb <tgt_ServiceConnect+0x5b>
  9064b8:	63fffc        	j	9064b8 <tgt_ServiceConnect+0x58>
	default:
		adf_os_assert(0);
	}

	return HTC_SERVICE_SUCCESS;
}
  9064bb:	c020      	movi.n	a2, 0
  9064bd:	d10f      	retw.n
	...

009064c0 <tgt_reg_service>:

static void tgt_reg_service(struct ath_softc_tgt *sc, HTC_SERVICE *svc,
			    int svcId, HTC_SERVICE_ProcessRecvMsg recvMsg)
{
  9064c0:	6c1004        	entry	a1, 32
	svc->ProcessRecvMsg = recvMsg;
	svc->ProcessSendBufferComplete = tgt_HTCSendCompleteHandler;
  9064c3:	187271        	l32r	a8, 8e2e88 <hif_module_install+0x2b4>
	svc->ProcessConnect = tgt_ServiceConnect;
	svc->MaxSvcMsgSize = 1600;
	svc->TrailerSpcCheckLimit = 0;
	svc->ServiceID = svcId;
	svc->ServiceCtx = sc;
	HTC_RegisterService(sc->tgt_htc_handle, svc);
  9064c6:	8a22      	l32i.n	a10, a2, 8

static void tgt_reg_service(struct ath_softc_tgt *sc, HTC_SERVICE *svc,
			    int svcId, HTC_SERVICE_ProcessRecvMsg recvMsg)
{
	svc->ProcessRecvMsg = recvMsg;
	svc->ProcessSendBufferComplete = tgt_HTCSendCompleteHandler;
  9064c8:	9832      	s32i.n	a8, a3, 8
	svc->ProcessConnect = tgt_ServiceConnect;
  9064ca:	187272        	l32r	a8, 8e2e94 <hif_module_install+0x2c0>
	return HTC_SERVICE_SUCCESS;
}

static void tgt_reg_service(struct ath_softc_tgt *sc, HTC_SERVICE *svc,
			    int svcId, HTC_SERVICE_ProcessRecvMsg recvMsg)
{
  9064cd:	db30      	mov.n	a11, a3
	svc->ProcessRecvMsg = recvMsg;
	svc->ProcessSendBufferComplete = tgt_HTCSendCompleteHandler;
	svc->ProcessConnect = tgt_ServiceConnect;
  9064cf:	9833      	s32i.n	a8, a3, 12
	svc->MaxSvcMsgSize = 1600;
  9064d1:	286a40        	movi	a8, 0x640
  9064d4:	28350a        	s16i	a8, a3, 20
	svc->TrailerSpcCheckLimit = 0;
  9064d7:	c080      	movi.n	a8, 0
  9064d9:	28350b        	s16i	a8, a3, 22
	svc->ServiceID = svcId;
	svc->ServiceCtx = sc;
	HTC_RegisterService(sc->tgt_htc_handle, svc);
  9064dc:	18716e        	l32r	a8, 8e2a94 <athos_indirection_table_install+0x154c>
}

static void tgt_reg_service(struct ath_softc_tgt *sc, HTC_SERVICE *svc,
			    int svcId, HTC_SERVICE_ProcessRecvMsg recvMsg)
{
	svc->ProcessRecvMsg = recvMsg;
  9064df:	9531      	s32i.n	a5, a3, 4
	svc->ProcessConnect = tgt_ServiceConnect;
	svc->MaxSvcMsgSize = 1600;
	svc->TrailerSpcCheckLimit = 0;
	svc->ServiceID = svcId;
	svc->ServiceCtx = sc;
	HTC_RegisterService(sc->tgt_htc_handle, svc);
  9064e1:	288285        	l32i	a8, a8, 0x214
	svc->ProcessRecvMsg = recvMsg;
	svc->ProcessSendBufferComplete = tgt_HTCSendCompleteHandler;
	svc->ProcessConnect = tgt_ServiceConnect;
	svc->MaxSvcMsgSize = 1600;
	svc->TrailerSpcCheckLimit = 0;
	svc->ServiceID = svcId;
  9064e4:	243508        	s16i	a4, a3, 16
	svc->ServiceCtx = sc;
  9064e7:	9236      	s32i.n	a2, a3, 24
	HTC_RegisterService(sc->tgt_htc_handle, svc);
  9064e9:	0b8000        	callx8	a8
  9064ec:	d10f      	retw.n
	...

009064f0 <tgt_HTCRecv_mgmthandler>:
{
}

static void tgt_HTCRecv_mgmthandler(HTC_ENDPOINT_ID EndPt, adf_nbuf_t hdr_buf,
				    adf_nbuf_t buf, void *ServiceCtx)
{
  9064f0:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)ServiceCtx;

	ath_tgt_send_mgt(sc,hdr_buf,buf,EndPt);
  9064f3:	dd20      	mov.n	a13, a2
  9064f5:	dc40      	mov.n	a12, a4
  9064f7:	db30      	mov.n	a11, a3
  9064f9:	da50      	mov.n	a10, a5
  9064fb:	580e64        	call8	909e8c <ath_tgt_send_mgt>
  9064fe:	d10f      	retw.n

00906500 <ath_descdma_cleanup>:
}

static void ath_descdma_cleanup(struct ath_softc_tgt *sc,
				struct ath_descdma *dd,
				ath_bufhead *head, a_int32_t dir)
{
  906500:	6c1006        	entry	a1, 48
	struct ath_buf *bf;
	struct ieee80211_node_target *ni;

	asf_tailq_foreach(bf, head, bf_list) {
  906503:	8740      	l32i.n	a7, a4, 0
  906505:	600079        	j	906582 <ath_descdma_cleanup+0x82>
		if (adf_nbuf_queue_len(&bf->bf_skbhead) != 0) {
  906508:	267c14        	addi	a6, a7, 20
 * @return length of the queue
 */
static inline a_uint32_t
adf_nbuf_queue_len(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_len(head);
  90650b:	da60      	mov.n	a10, a6
  90650d:	5bf467        	call8	9036ac <__adf_nbuf_queue_len>
  906510:	d9a0      	mov.n	a9, a10
  906512:	cba8      	beqz.n	a10, 90654e <ath_descdma_cleanup+0x4e>
static inline void
adf_nbuf_unmap(adf_os_device_t      osdev, 
               adf_os_dma_map_t     bmap, 
               adf_os_dma_dir_t     dir)
{
    __adf_nbuf_unmap(osdev, bmap, dir);
  906514:	2b7200        	l32i	a11, a7, 0
  906517:	2a2246        	l32i	a10, a2, 0x118
  90651a:	055c02        	or	a12, a5, a5
  90651d:	5bf3ee        	call8	9034d8 <__adf_nbuf_unmap>
  906520:	60001d        	j	906541 <ath_descdma_cleanup+0x41>
			adf_nbuf_unmap(sc->sc_dev, bf->bf_dmamap, dir);
			while(adf_nbuf_queue_len(&bf->bf_skbhead) != 0) {
				ath_free_rx_skb(sc,
  906523:	18716e        	l32r	a8, 8e2adc <athos_indirection_table_install+0x1594>
  906526:	8d20      	l32i.n	a13, a2, 0
  906528:	2982a3        	l32i	a9, a8, 0x28c
 * @return The head buf in the buf queue.
 */
static inline adf_nbuf_t
adf_nbuf_queue_remove(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_remove(head);
  90652b:	da60      	mov.n	a10, a6
  90652d:	9911      	s32i.n	a9, a1, 4
  90652f:	9d10      	s32i.n	a13, a1, 0
  906531:	5bf3d5        	call8	903488 <__adf_nbuf_queue_remove>
  906534:	8d10      	l32i.n	a13, a1, 0
  906536:	8911      	l32i.n	a9, a1, 4
  906538:	dca0      	mov.n	a12, a10
  90653a:	c0b3      	movi.n	a11, 3
  90653c:	dad0      	mov.n	a10, a13
  90653e:	0b9000        	callx8	a9
 * @return length of the queue
 */
static inline a_uint32_t
adf_nbuf_queue_len(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_len(head);
  906541:	da60      	mov.n	a10, a6
  906543:	5bf45a        	call8	9036ac <__adf_nbuf_queue_len>
	struct ieee80211_node_target *ni;

	asf_tailq_foreach(bf, head, bf_list) {
		if (adf_nbuf_queue_len(&bf->bf_skbhead) != 0) {
			adf_nbuf_unmap(sc->sc_dev, bf->bf_dmamap, dir);
			while(adf_nbuf_queue_len(&bf->bf_skbhead) != 0) {
  906546:	65afd9        	bnez	a10, 906523 <ath_descdma_cleanup+0x23>
				ath_free_rx_skb(sc,
					adf_nbuf_queue_remove(&bf->bf_skbhead));
			}
			bf->bf_skb = NULL;
  906549:	9a78      	s32i.n	a10, a7, 32
  90654b:	600025        	j	906574 <ath_descdma_cleanup+0x74>
		} else if (bf->bf_skb != NULL) {
  90654e:	8678      	l32i.n	a6, a7, 32
  906550:	ca60      	beqz.n	a6, 906574 <ath_descdma_cleanup+0x74>
static inline void
adf_nbuf_unmap(adf_os_device_t      osdev, 
               adf_os_dma_map_t     bmap, 
               adf_os_dma_dir_t     dir)
{
    __adf_nbuf_unmap(osdev, bmap, dir);
  906552:	2b7200        	l32i	a11, a7, 0
  906555:	2a2246        	l32i	a10, a2, 0x118
  906558:	055c02        	or	a12, a5, a5
  90655b:	291601        	s32i	a9, a1, 4
  90655e:	5bf3de        	call8	9034d8 <__adf_nbuf_unmap>
			adf_nbuf_unmap(sc->sc_dev,bf->bf_dmamap, dir);
			ath_free_rx_skb(sc, bf->bf_skb);
  906561:	18716e        	l32r	a8, 8e2b1c <athos_indirection_table_install+0x15d4>
  906564:	8c78      	l32i.n	a12, a7, 32
  906566:	8a20      	l32i.n	a10, a2, 0
  906568:	2682a3        	l32i	a6, a8, 0x28c
  90656b:	c0b3      	movi.n	a11, 3
  90656d:	0b6000        	callx8	a6
			bf->bf_skb = NULL;
  906570:	8911      	l32i.n	a9, a1, 4
  906572:	9978      	s32i.n	a9, a7, 32
 * @param[in] dmap
 */
static inline void
adf_nbuf_dmamap_destroy(adf_os_device_t osdev, adf_os_dma_map_t dmap)
{
    __adf_nbuf_dmamap_destroy(osdev, dmap);
  906574:	8b70      	l32i.n	a11, a7, 0
  906576:	2a2246        	l32i	a10, a2, 0x118
		}

		adf_nbuf_dmamap_destroy(sc->sc_dev, bf->bf_dmamap);

		ni = bf->bf_node;
		bf->bf_node = NULL;
  906579:	c060      	movi.n	a6, 0
  90657b:	5bf3da        	call8	9034e4 <__adf_nbuf_dmamap_destroy>
  90657e:	9674      	s32i.n	a6, a7, 16
				ath_bufhead *head, a_int32_t dir)
{
	struct ath_buf *bf;
	struct ieee80211_node_target *ni;

	asf_tailq_foreach(bf, head, bf_list) {
  906580:	8779      	l32i.n	a7, a7, 36
  906582:	657f82        	bnez	a7, 906508 <ath_descdma_cleanup+0x8>
	}

	adf_os_dmamem_free(sc->sc_dev, dd->dd_desc_len,
			   1, dd->dd_desc, dd->dd_desc_dmamap);

	asf_tailq_init(head);
  906585:	9740      	s32i.n	a7, a4, 0
  906587:	9441      	s32i.n	a4, a4, 4
 * @param[in] size  buffer size
 */
static inline void
adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
{
    __adf_os_mem_set(buf, b, size);
  906589:	c1c8      	movi.n	a12, 24
  90658b:	db70      	mov.n	a11, a7
  90658d:	da30      	mov.n	a10, a3
  90658f:	5bffa9        	call8	906434 <__adf_os_mem_set>
  906592:	d10f      	retw.n

00906594 <__adf_os_init_bh$isra$5>:
									  void 				*arg)
{
	__adf_os_init_defer(work, func, arg);
}

static inline void	__adf_os_init_bh(adf_os_handle_t  hdl,
  906594:	6c1004        	entry	a1, 32
									 __adf_os_bh_t		*bh,
									 adf_os_defer_fn_t	func,
									 void				*arg)
{
	//__adf_os_init_defer(bh, func, arg);
	A_TASKLET_INIT_TASK(func, arg, bh);
  906597:	18716e        	l32r	a8, 8e2b50 <athos_indirection_table_install+0x1608>
  90659a:	dc20      	mov.n	a12, a2
  90659c:	28826a        	l32i	a8, a8, 0x1a8
  90659f:	db40      	mov.n	a11, a4
  9065a1:	da30      	mov.n	a10, a3
  9065a3:	0b8000        	callx8	a8
  9065a6:	d10f      	retw.n

009065a8 <__adf_os_sched_bh$isra$6>:
                                         __adf_os_work_t  * work)
{
    //taskqueue_drain(taskqueue_thread, &work->tsk);
}

static inline void __adf_os_sched_bh(adf_os_handle_t  hdl, 
  9065a8:	6c1004        	entry	a1, 32
                                       __adf_os_bh_t  * bh)
{
    A_TASKLET_SCHEDULE(bh);
  9065ab:	18716e        	l32r	a8, 8e2b64 <_HIFusb_isr_handler+0xc>
  9065ae:	da20      	mov.n	a10, a2
  9065b0:	28826c        	l32i	a8, a8, 0x1b0
  9065b3:	0b8000        	callx8	a8
  9065b6:	d10f      	retw.n

009065b8 <ath_tgt_rx_tasklet>:

	return 0;
}

static void ath_tgt_rx_tasklet(TQUEUE_ARG data)
{
  9065b8:	6c1006        	entry	a1, 48
	struct ath_softc_tgt *sc  = (struct ath_softc_tgt *)data;
	struct ath_rx_buf *bf = NULL;
	struct ath_hal *ah = sc->sc_ah;
  9065bb:	252d05        	addmi	a5, a2, 0x500
  9065be:	835b      	l32i.n	a3, a5, 44
			continue;
		}

		asf_tailq_remove(&sc->sc_rxbuf, bf, bf_list);

		bf->bf_skb = NULL;
  9065c0:	c040      	movi.n	a4, 0

static void ath_tgt_rx_tasklet(TQUEUE_ARG data)
{
	struct ath_softc_tgt *sc  = (struct ath_softc_tgt *)data;
	struct ath_rx_buf *bf = NULL;
	struct ath_hal *ah = sc->sc_ah;
  9065c2:	231600        	s32i	a3, a1, 0
	struct rx_frame_header *rxhdr;
	struct ath_rx_status *rxstats;
	adf_nbuf_t skb = ADF_NBUF_NULL;

	do {
		bf = asf_tailq_first(&sc->sc_rxbuf);
  9065c5:	2322d5        	l32i	a3, a2, 0x354
		if (bf == NULL) {
  9065c8:	64308c        	beqz	a3, 906658 <ath_tgt_rx_tasklet+0xa0>
			break;
		}

		if (!(bf->bf_status & ATH_BUFSTATUS_DONE)) {
  9065cb:	863f      	l32i.n	a6, a3, 60
  9065cd:	7f6f02        	bbsi	a6, 31, 9065d3 <ath_tgt_rx_tasklet+0x1b>
  9065d0:	600084        	j	906658 <ath_tgt_rx_tasklet+0xa0>
			break;
		}

		skb = bf->bf_skb;
  9065d3:	8d38      	l32i.n	a13, a3, 32
		if (skb == NULL) {
  9065d5:	64dfef        	beqz	a13, 9065c8 <ath_tgt_rx_tasklet+0x10>
			continue;
		}

		asf_tailq_remove(&sc->sc_rxbuf, bf, bf_list);
  9065d8:	8639      	l32i.n	a6, a3, 36
  9065da:	873a      	l32i.n	a7, a3, 40
  9065dc:	c864      	beqz.n	a6, 9065e4 <ath_tgt_rx_tasklet+0x2c>
  9065de:	976a      	s32i.n	a7, a6, 40
  9065e0:	600003        	j	9065e7 <ath_tgt_rx_tasklet+0x2f>
  9065e3:	002726        	excw
  9065e6:	d687      	excw
  9065e8:	3adad0        	excw
  9065eb:	9670      	s32i.n	a6, a7, 0

		bf->bf_skb = NULL;
  9065ed:	9438      	s32i.n	a4, a3, 32
 *         or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_push_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_push_head(buf, size);
  9065ef:	2b0a28        	movi	a11, 40
  9065f2:	2d1601        	s32i	a13, a1, 4
  9065f5:	5bf373        	call8	9033c4 <__adf_nbuf_push_head>
 * @param[in] size    buffer size
 */
static inline void
adf_os_mem_copy(void *dst, const void *src, adf_os_size_t size)
{
    __adf_os_mem_copy(dst, src, size);
  9065f8:	c2c8      	movi.n	a12, 40
  9065fa:	2b3c40        	addi	a11, a3, 64
  9065fd:	d7a0      	mov.n	a7, a10
  9065ff:	5bff88        	call8	906420 <__adf_os_mem_copy>
  906602:	8a5b      	l32i.n	a10, a5, 44
						     sizeof(struct rx_frame_header));
		rxstats = (struct ath_rx_status *)(&rxhdr->rx_stats[0]);
		adf_os_mem_copy(rxstats, &(bf->bf_rx_status),
				sizeof(struct ath_rx_status));

		rxstats->rs_tstamp = ath_extend_tsf(sc, (u_int32_t)rxstats->rs_tstamp);
  906604:	8671      	l32i.n	a6, a7, 4
	struct ath_hal *ah = sc->sc_ah;
	u_int64_t tsf;
	u_int32_t tsf_low;
	a_int64_t tsf_delta;  /* signed int64 */

	tsf = ah->ah_getTsf64(ah);
  906606:	28a21e        	l32i	a8, a10, 120
  906609:	0b8000        	callx8	a8
	tsf_low = tsf & 0xffffffffUL;

	tsf_delta = (a_int32_t)((rstamp - tsf_low) & 0xffffffffUL);
  90660c:	0b680c        	sub	a8, a6, a11

	return (tsf + (u_int64_t)tsf_delta);
  90660f:	ab8b      	add.n	a11, a8, a11
  906611:	08fc13        	srai	a12, a8, 31
  906614:	c061      	movi.n	a6, 1
  906616:	8d11      	l32i.n	a13, a1, 4
  906618:	78b301        	bltu	a11, a8, 90661d <ath_tgt_rx_tasklet+0x65>
  90661b:	d640      	mov.n	a6, a4
  90661d:	aaca      	add.n	a10, a12, a10
  90661f:	aa66      	add.n	a6, a6, a10
						     sizeof(struct rx_frame_header));
		rxstats = (struct ath_rx_status *)(&rxhdr->rx_stats[0]);
		adf_os_mem_copy(rxstats, &(bf->bf_rx_status),
				sizeof(struct ath_rx_status));

		rxstats->rs_tstamp = ath_extend_tsf(sc, (u_int32_t)rxstats->rs_tstamp);
  906621:	9670      	s32i.n	a6, a7, 0

		HTC_SendMsg(sc->tgt_htc_handle, RX_ENDPOINT_ID, skb);
  906623:	16716e        	l32r	a6, 8e2bdc <hif_module_install+0x8>
  906626:	8a22      	l32i.n	a10, a2, 8
  906628:	266289        	l32i	a6, a6, 0x224
						     sizeof(struct rx_frame_header));
		rxstats = (struct ath_rx_status *)(&rxhdr->rx_stats[0]);
		adf_os_mem_copy(rxstats, &(bf->bf_rx_status),
				sizeof(struct ath_rx_status));

		rxstats->rs_tstamp = ath_extend_tsf(sc, (u_int32_t)rxstats->rs_tstamp);
  90662b:	9b71      	s32i.n	a11, a7, 4

		HTC_SendMsg(sc->tgt_htc_handle, RX_ENDPOINT_ID, skb);
  90662d:	dcd0      	mov.n	a12, a13
  90662f:	c0b3      	movi.n	a11, 3
  906631:	0b6000        	callx8	a6
		sc->sc_rx_stats.ast_rx_send++;
  906634:	26227d        	l32i	a6, a2, 0x1f4

		bf->bf_status &= ~ATH_BUFSTATUS_DONE;
  906637:	c77e      	movi.n	a7, -2
				sizeof(struct ath_rx_status));

		rxstats->rs_tstamp = ath_extend_tsf(sc, (u_int32_t)rxstats->rs_tstamp);

		HTC_SendMsg(sc->tgt_htc_handle, RX_ENDPOINT_ID, skb);
		sc->sc_rx_stats.ast_rx_send++;
  906639:	b166      	addi.n	a6, a6, 1
  90663b:	26267d        	s32i	a6, a2, 0x1f4

		bf->bf_status &= ~ATH_BUFSTATUS_DONE;
  90663e:	863f      	l32i.n	a6, a3, 60
		asf_tailq_insert_tail(&sc->sc_rxbuf, bf, bf_list);
  906640:	9439      	s32i.n	a4, a3, 36
		rxstats->rs_tstamp = ath_extend_tsf(sc, (u_int32_t)rxstats->rs_tstamp);

		HTC_SendMsg(sc->tgt_htc_handle, RX_ENDPOINT_ID, skb);
		sc->sc_rx_stats.ast_rx_send++;

		bf->bf_status &= ~ATH_BUFSTATUS_DONE;
  906642:	076601        	and	a6, a6, a7
  906645:	963f      	s32i.n	a6, a3, 60
		asf_tailq_insert_tail(&sc->sc_rxbuf, bf, bf_list);
  906647:	2622d6        	l32i	a6, a2, 0x358
  90664a:	963a      	s32i.n	a6, a3, 40
  90664c:	9360      	s32i.n	a3, a6, 0
  90664e:	233c24        	addi	a3, a3, 36
  906651:	2326d6        	s32i	a3, a2, 0x358
  906654:	63ff6d        	j	9065c5 <ath_tgt_rx_tasklet+0xd>
  906657:	002322        	excw

	} while(1);

	sc->sc_imask |= HAL_INT_RX;
  90665a:	c4c0      	movi.n	a12, 64
  90665c:	b103      	addi.n	a3, a0, 1
  90665e:	bb02      	addi.n	a2, a0, 11
	ah->ah_setInterrupts(ah, sc->sc_imask);
  906660:	8310      	l32i.n	a3, a1, 0
		bf->bf_status &= ~ATH_BUFSTATUS_DONE;
		asf_tailq_insert_tail(&sc->sc_rxbuf, bf, bf_list);

	} while(1);

	sc->sc_imask |= HAL_INT_RX;
  906662:	2b26c4        	s32i	a11, a2, 0x310
	ah->ah_setInterrupts(ah, sc->sc_imask);
  906665:	223228        	l32i	a2, a3, 160
  906668:	da30      	mov.n	a10, a3
  90666a:	0b2000        	callx8	a2
  90666d:	d10f      	retw.n
	...

00906670 <ath_hal_reg_write_filter$isra$13>:
#endif
		reset_pll = 1;
	}
}

static void ath_hal_reg_write_filter(struct ath_hal *ah,
  906670:	6c1004        	entry	a1, 32
			a_uint32_t reg, a_uint32_t val)
{
	if(reg > 0xffff) {
  906673:	187273        	l32r	a8, 8e3040 <bSet_configuration+0xc4>
  906676:	728b32        	bgeu	a8, a2, 9066ac <ath_hal_reg_write_filter$isra$13+0x3c>
  906679:	0c0200        	memw
  90667c:	9320      	s32i.n	a3, a2, 0
		iowrite32(reg, val);
#if defined(PROJECT_K2)
		if(reg == 0x50040) {
  90667e:	1371fb        	l32r	a3, 8e2e6c <hif_module_install+0x298>
  906681:	732977        	bne	a2, a3, 9066fc <ath_hal_reg_write_filter$isra$13+0x8c>
			static uint8_t flg=0;

			if(flg == 0) {
  906684:	127274        	l32r	a2, 8e3054 <bSet_configuration+0xd8>
  906687:	232000        	l8ui	a3, a2, 0
  90668a:	65306e        	bnez	a3, 9066fc <ath_hal_reg_write_filter$isra$13+0x8c>
				/* reinit clock and uart.
				 * TODO: Independent on what host will
				 * here set. We do our own decision. Why? */
				A_CLOCK_INIT(117);
  90668d:	13716e        	l32r	a3, 8e2c48 <hif_module_install+0x74>
  906690:	2a0a75        	movi	a10, 117
  906693:	283237        	l32i	a8, a3, 220
  906696:	0b8000        	callx8	a8
				A_UART_HWINIT(117*1000*1000, 19200);
  906699:	1b720a        	l32r	a11, 8e2ec4 <bGet_descriptor>
  90669c:	23321a        	l32i	a3, a3, 104
  90669f:	1a7275        	l32r	a10, 8e3074 <bSet_configuration+0xf8>
  9066a2:	0b3000        	callx8	a3
				flg = 1;
  9066a5:	c031      	movi.n	a3, 1
  9066a7:	232400        	s8i	a3, a2, 0
  9066aa:	d10f      	retw.n
			}
		}
#endif
	} else {
		if(reg == 0x7014)
  9066ac:	187276        	l32r	a8, 8e3084 <bSet_configuration+0x108>
  9066af:	78293e        	bne	a2, a8, 9066f1 <ath_hal_reg_write_filter$isra$13+0x81>

static void ath_pll_reset_ones(struct ath_hal *ah)
{
	static uint8_t reset_pll = 0;

	if(reset_pll == 0) {
  9066b2:	1a7277        	l32r	a10, 8e3090 <bSet_configuration+0x114>
  9066b5:	28a000        	l8ui	a8, a10, 0
  9066b8:	cf85      	bnez.n	a8, 9066f1 <ath_hal_reg_write_filter$isra$13+0x81>
  9066ba:	1b71fa        	l32r	a11, 8e2ea4 <hif_module_install+0x2d0>
#if defined(PROJECT_K2)
		/* here we write to core register */
		iowrite32(MAGPIE_REG_RST_PWDN_CTRL_ADDR, 0x0);
		/* and here to mac register */
		iowrite32_mac(0x786c,
  9066bd:	1c7279        	l32r	a12, 8e30a4 <bSet_configuration+0x128>
  9066c0:	0c0200        	memw
  9066c3:	98b0      	s32i.n	a8, a11, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  9066c5:	187278        	l32r	a8, 8e30a8 <bSet_configuration+0x12c>
  9066c8:	0c0200        	memw
  9066cb:	8980      	l32i.n	a9, a8, 0
  9066cd:	0c9902        	or	a9, a9, a12
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  9066d0:	0c0200        	memw
  9066d3:	9980      	s32i.n	a9, a8, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  9066d5:	0c0200        	memw
  9066d8:	8980      	l32i.n	a9, a8, 0
			 ioread32_mac(0x786c) | 0x6000000);
		iowrite32_mac(0x786c,
  9066da:	1c727a        	l32r	a12, 8e30c4 <bSet_configuration+0x148>
  9066dd:	0c9901        	and	a9, a9, a12
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  9066e0:	0c0200        	memw
  9066e3:	9980      	s32i.n	a9, a8, 0
  9066e5:	c280      	movi.n	a8, 32
  9066e7:	0c0200        	memw
  9066ea:	98b0      	s32i.n	a8, a11, 0
		iowrite32_mac(0x7890,
			 ioread32_mac(0x7890) | 0x1800000);
		iowrite32_mac(0x7890,
			 ioread32_mac(0x7890) & (~0x1800000));
#endif
		reset_pll = 1;
  9066ec:	c081      	movi.n	a8, 1
  9066ee:	28a400        	s8i	a8, a10, 0
#endif
	} else {
		if(reg == 0x7014)
			ath_pll_reset_ones(ah);

		iowrite32_mac(reg, val);
  9066f1:	187215        	l32r	a8, 8e2f48 <bGet_descriptor+0x84>
  9066f4:	a822      	add.n	a2, a2, a8
  9066f6:	0c0200        	memw
  9066f9:	232600        	s32i	a3, a2, 0
  9066fc:	d10f      	retw.n
	...

00906700 <ath_reg_read_filter>:

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static a_int32_t ath_reg_read_filter(struct ath_hal *ah, a_int32_t addr)
{
  906700:	6c1004        	entry	a1, 32
	if ((addr & 0xffffe000) == 0x2000) {
  906703:	18727b        	l32r	a8, 8e30f0 <bSet_configuration+0x174>
  906706:	197225        	l32r	a9, 8e2f9c <bSet_configuration+0x20>
  906709:	083801        	and	a8, a3, a8
  90670c:	798935        	bne	a8, a9, 906745 <ath_reg_read_filter+0x45>
		/* SEEPROM registers */
		ioread32_mac(addr);
  90670f:	187215        	l32r	a8, 8e2f64 <bGet_descriptor+0xa0>
		if (!ath_hal_wait(ah, 0x407c, 0x00030000, 0))
  906712:	1c727c        	l32r	a12, 8e3104 <bSet_configuration+0x188>

static a_int32_t ath_reg_read_filter(struct ath_hal *ah, a_int32_t addr)
{
	if ((addr & 0xffffe000) == 0x2000) {
		/* SEEPROM registers */
		ioread32_mac(addr);
  906715:	a838      	add.n	a8, a3, a8
		if (!ath_hal_wait(ah, 0x407c, 0x00030000, 0))
  906717:	1b727d        	l32r	a11, 8e310c <bSet_configuration+0x190>
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90671a:	0c0200        	memw
  90671d:	8880      	l32i.n	a8, a8, 0
  90671f:	2d0a00        	movi	a13, 0
  906722:	022a02        	or	a10, a2, a2
  906725:	5bfa49        	call8	90504c <ath_hal_wait>
  906728:	ccac      	bnez.n	a10, 906738 <ath_reg_read_filter+0x38>
			adf_os_print("SEEPROM Read fail: 0x%08x\n", addr);
  90672a:	12716e        	l32r	a2, 8e2ce4 <hif_module_install+0x110>
  90672d:	1a727e        	l32r	a10, 8e3128 <bSet_configuration+0x1ac>
  906730:	222212        	l32i	a2, a2, 72
  906733:	db30      	mov.n	a11, a3
  906735:	0b2000        	callx8	a2
  906738:	12727f        	l32r	a2, 8e3134 <bSet_configuration+0x1b8>
  90673b:	0c0200        	memw
  90673e:	8220      	l32i.n	a2, a2, 0

		return ioread32_mac(0x407c) & 0x0000ffff;
  906740:	02024f        	extui	a2, a2, 0, 16
  906743:	d10f      	retw.n
	} else if (addr > 0xffff)
  906745:	127273        	l32r	a2, 8e3114 <bSet_configuration+0x198>
  906748:	732a02        	bge	a2, a3, 90674e <ath_reg_read_filter+0x4e>
  90674b:	600004        	j	906753 <ath_reg_read_filter+0x53>
		/* SoC registers */
		return ioread32(addr);
	else
		/* MAC registers */
		return ioread32_mac(addr);
  90674e:	127215        	l32r	a2, 8e2fa4 <bSet_configuration+0x28>
  906751:	a233      	add.n	a3, a3, a2
  906753:	0c0200        	memw
  906756:	8230      	l32i.n	a2, a3, 0
}
  906758:	d10f      	retw.n
	...

0090675c <ath_desc_free>:

#undef DS2PHYS
}

static void ath_desc_free(struct ath_softc_tgt *sc)
{
  90675c:	6c1004        	entry	a1, 32
	asf_tailq_insert_tail(&sc->sc_txbuf, sc->sc_txbuf_held, bf_list);
  90675f:	2822dc        	l32i	a8, a2, 0x370
  906762:	2922f1        	l32i	a9, a2, 0x3c4
  906765:	c0d0      	movi.n	a13, 0
  906767:	9d89      	s32i.n	a13, a8, 36
  906769:	998a      	s32i.n	a9, a8, 40
  90676b:	9890      	s32i.n	a8, a9, 0
  90676d:	2822dc        	l32i	a8, a2, 0x370

	sc->sc_txbuf_held = NULL;
  906770:	2d26dc        	s32i	a13, a2, 0x370
#undef DS2PHYS
}

static void ath_desc_free(struct ath_softc_tgt *sc)
{
	asf_tailq_insert_tail(&sc->sc_txbuf, sc->sc_txbuf_held, bf_list);
  906773:	288c24        	addi	a8, a8, 36
  906776:	2826f1        	s32i	a8, a2, 0x3c4

	sc->sc_txbuf_held = NULL;

	if (sc->sc_txdma.dd_desc_len != 0)
  906779:	2822e7        	l32i	a8, a2, 0x39c
  90677c:	7d8110        	beq	a8, a13, 906790 <ath_desc_free+0x34>
		ath_descdma_cleanup(sc, &sc->sc_txdma, (ath_bufhead *)&sc->sc_txbuf,
  90677f:	2c3ac0        	movi	a12, 0x3c0
  906782:	2b3a8c        	movi	a11, 0x38c
  906785:	ac2c      	add.n	a12, a2, a12
  906787:	0b2b08        	add	a11, a2, a11
  90678a:	022a02        	or	a10, a2, a2
  90678d:	5bff5c        	call8	906500 <ath_descdma_cleanup>
				    ADF_OS_DMA_TO_DEVICE);
	if (sc->sc_rxdma.dd_desc_len != 0)
  906790:	2822e1        	l32i	a8, a2, 0x384
  906793:	c88f      	beqz.n	a8, 9067a6 <ath_desc_free+0x4a>
		ath_descdma_cleanup(sc, &sc->sc_rxdma, (ath_bufhead *)&sc->sc_rxbuf,
  906795:	2c3a54        	movi	a12, 0x354
  906798:	2b3a74        	movi	a11, 0x374
  90679b:	c0d1      	movi.n	a13, 1
  90679d:	ac2c      	add.n	a12, a2, a12
  90679f:	ab2b      	add.n	a11, a2, a11
  9067a1:	da20      	mov.n	a10, a2
  9067a3:	5bff57        	call8	906500 <ath_descdma_cleanup>
  9067a6:	d10f      	retw.n

009067a8 <ath_descdma_setup$isra$21$constprop$26>:

/***********************/
/* Descriptor Handling */
/***********************/

static a_int32_t ath_descdma_setup(struct ath_softc_tgt *sc,
  9067a8:	6c1006        	entry	a1, 48
	struct ath_buf *bf;
	a_int32_t i, bsize, error;
	a_uint8_t *bf_addr;
	a_uint8_t *ds_addr;

	dd->dd_name = name;
  9067ab:	9530      	s32i.n	a5, a3, 0
	dd->dd_desc_len = descSize * nbuf * ndesc;
  9067ad:	851c      	l32i.n	a5, a1, 48
adf_os_dmamem_alloc(adf_os_device_t     osdev, 
                    adf_os_size_t       size, 
                    a_bool_t            coherent, 
                    adf_os_dma_map_t   *dmap)
{
    return __adf_os_dmamem_alloc(osdev, size, coherent, dmap);
  9067af:	8a20      	l32i.n	a10, a2, 0
  9067b1:	056b28        	mull	a11, a6, a5
  9067b4:	b83d      	addi.n	a13, a3, 8
  9067b6:	9b34      	s32i.n	a11, a3, 16
  9067b8:	c0c1      	movi.n	a12, 1
  9067ba:	5806b1        	call8	908280 <__adf_os_dmamem_alloc>
 * @return the (bus) address
 */
static inline adf_os_dma_addr_t
adf_os_dmamem_map2addr(adf_os_dma_map_t dmap)
{
    return(__adf_os_dmamem_map2addr(dmap));
  9067bd:	8532      	l32i.n	a5, a3, 8

	dd->dd_desc = adf_os_dmamem_alloc(sc->sc_dev,
  9067bf:	9a31      	s32i.n	a10, a3, 4
				  dd->dd_desc_len, 1, &dd->dd_desc_dmamap);
	dd->dd_desc_paddr = adf_os_dmamem_map2addr(dd->dd_desc_dmamap);
  9067c1:	8551      	l32i.n	a5, a5, 4
  9067c3:	9533      	s32i.n	a5, a3, 12
adf_os_dmamem_alloc(adf_os_device_t     osdev, 
                    adf_os_size_t       size, 
                    a_bool_t            coherent, 
                    adf_os_dma_map_t   *dmap)
{
    return __adf_os_dmamem_alloc(osdev, size, coherent, dmap);
  9067c5:	d8a0      	mov.n	a8, a10
	if (dd->dd_desc == NULL) {
  9067c7:	64a06d        	beqz	a10, 906838 <ath_descdma_setup$isra$21$constprop$26+0x90>
		error = -ENOMEM;
		goto fail;
	}
	ds = dd->dd_desc;

	bsize = bfSize * nbuf;
  9067ca:	076c28        	mull	a12, a6, a7
 * @return Buffer pointer or NULL if there's not enough memory.
 */
static inline void *
adf_os_mem_alloc(adf_os_size_t size)
{
    return __adf_os_mem_alloc(size);
  9067cd:	9812      	s32i.n	a8, a1, 8
  9067cf:	dac0      	mov.n	a10, a12
  9067d1:	9c10      	s32i.n	a12, a1, 0
  9067d3:	5bff0e        	call8	90640c <__adf_os_mem_alloc>
  9067d6:	d5a0      	mov.n	a5, a10
	bf = adf_os_mem_alloc(bsize);
	if (bf == NULL) {
  9067d8:	8c10      	l32i.n	a12, a1, 0
  9067da:	64a05a        	beqz	a10, 906838 <ath_descdma_setup$isra$21$constprop$26+0x90>
 * @param[in] size  buffer size
 */
static inline void
adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
{
    __adf_os_mem_set(buf, b, size);
  9067dd:	c0b0      	movi.n	a11, 0
  9067df:	5bff15        	call8	906434 <__adf_os_mem_set>
	dd->dd_bufptr = bf;

	bf_addr = (a_uint8_t *)bf;
	ds_addr = (a_uint8_t *)ds;

	asf_tailq_init(head);
  9067e2:	c090      	movi.n	a9, 0
	if (bf == NULL) {
		error = -ENOMEM;
		goto fail2;
	}
	adf_os_mem_set(bf, 0, bsize);
	dd->dd_bufptr = bf;
  9067e4:	9535      	s32i.n	a5, a3, 20

	bf_addr = (a_uint8_t *)bf;
	ds_addr = (a_uint8_t *)ds;

	asf_tailq_init(head);
  9067e6:	9940      	s32i.n	a9, a4, 0
  9067e8:	9441      	s32i.n	a4, a4, 4
  9067ea:	8812      	l32i.n	a8, a1, 8
  9067ec:	600041        	j	906831 <ath_descdma_setup$isra$21$constprop$26+0x89>
  9067ef:	00008a        	excw
 */
static inline a_status_t
adf_nbuf_dmamap_create(adf_os_device_t osdev,
                       adf_os_dma_map_t *dmap)
{
    return (__adf_nbuf_dmamap_create(osdev, dmap));
  9067f2:	20db50        	l32ai	a0, a13, 0x140
  9067f5:	9812      	s32i.n	a8, a1, 8
  9067f7:	9911      	s32i.n	a9, a1, 4
  9067f9:	5bf32d        	call8	9034b0 <__adf_nbuf_dmamap_create>
  9067fc:	dba0      	mov.n	a11, a10

	for (i = 0; i < nbuf; i++) {
		a_int32_t j;

		if (adf_nbuf_dmamap_create( sc->sc_dev, &bf->bf_dmamap) != A_STATUS_OK) {
  9067fe:	8812      	l32i.n	a8, a1, 8
  906800:	8911      	l32i.n	a9, a1, 4
  906802:	cfa2      	bnez.n	a10, 906838 <ath_descdma_setup$isra$21$constprop$26+0x90>
			goto fail2;
		}

		bf->bf_desc = bf->bf_descarr = bf->bf_lastds = ds;
  906804:	985c      	s32i.n	a8, a5, 48
  906806:	985e      	s32i.n	a8, a5, 56
  906808:	985d      	s32i.n	a8, a5, 52
 * @param[in] head  buf queue head
 */
static inline void
adf_nbuf_queue_init(adf_nbuf_queue_t *head)
{
    __adf_nbuf_queue_init(head);
  90680a:	2a5c14        	addi	a10, a5, 20
  90680d:	9812      	s32i.n	a8, a1, 8
  90680f:	9911      	s32i.n	a9, a1, 4
  906811:	9b10      	s32i.n	a11, a1, 0
  906813:	5bf3a2        	call8	90369c <__adf_nbuf_queue_init>
			ATH_BUF_SET_DESC_PHY_ADDR_WITH_IDX(bf, j, (ds_addr + (j*descSize)));

		ATH_BUF_SET_DESC_PHY_ADDR(bf, ATH_BUF_GET_DESC_PHY_ADDR_WITH_IDX(bf, 0));

		adf_nbuf_queue_init(&bf->bf_skbhead);
		asf_tailq_insert_tail(head, bf, bf_list);
  906816:	8a41      	l32i.n	a10, a4, 4
  906818:	8b10      	l32i.n	a11, a1, 0
  90681a:	9a5a      	s32i.n	a10, a5, 40
  90681c:	9b59      	s32i.n	a11, a5, 36
  90681e:	95a0      	s32i.n	a5, a10, 0
  906820:	2a5c24        	addi	a10, a5, 36
  906823:	9a41      	s32i.n	a10, a4, 4
	bf_addr = (a_uint8_t *)bf;
	ds_addr = (a_uint8_t *)ds;

	asf_tailq_init(head);

	for (i = 0; i < nbuf; i++) {
  906825:	8911      	l32i.n	a9, a1, 4
		asf_tailq_insert_tail(head, bf, bf_list);

		bf_addr += bfSize;
		ds_addr += (ndesc * descSize);
		bf = (struct ath_buf *)bf_addr;
		ds = (struct ath_desc *)ds_addr;
  906827:	8812      	l32i.n	a8, a1, 8
  906829:	8a1c      	l32i.n	a10, a1, 48
	bf_addr = (a_uint8_t *)bf;
	ds_addr = (a_uint8_t *)ds;

	asf_tailq_init(head);

	for (i = 0; i < nbuf; i++) {
  90682b:	b199      	addi.n	a9, a9, 1
		asf_tailq_insert_tail(head, bf, bf_list);

		bf_addr += bfSize;
		ds_addr += (ndesc * descSize);
		bf = (struct ath_buf *)bf_addr;
		ds = (struct ath_desc *)ds_addr;
  90682d:	aa88      	add.n	a8, a8, a10
		adf_nbuf_queue_init(&bf->bf_skbhead);
		asf_tailq_insert_tail(head, bf, bf_list);

		bf_addr += bfSize;
		ds_addr += (ndesc * descSize);
		bf = (struct ath_buf *)bf_addr;
  90682f:	a755      	add.n	a5, a5, a7
	bf_addr = (a_uint8_t *)bf;
	ds_addr = (a_uint8_t *)ds;

	asf_tailq_init(head);

	for (i = 0; i < nbuf; i++) {
  906831:	7692bc        	blt	a9, a6, 9067f1 <ath_descdma_setup$isra$21$constprop$26+0x49>
  906834:	60000c        	j	906844 <ath_descdma_setup$isra$21$constprop$26+0x9c>
  906837:	00c1c8        	excw
  90683a:	c0b0      	movi.n	a11, 0
  90683c:	da30      	mov.n	a10, a3
  90683e:	5bfefd        	call8	906434 <__adf_os_mem_set>
  906841:	63fffc        	j	906841 <ath_descdma_setup$isra$21$constprop$26+0x99>
	adf_os_mem_set(dd, 0, sizeof(*dd));
	adf_os_assert(0);
	return error;

#undef DS2PHYS
}
  906844:	c020      	movi.n	a2, 0
  906846:	d10f      	retw.n

00906848 <tgt_HTCRecvMessageHandler>:
}

static void tgt_HTCRecvMessageHandler(HTC_ENDPOINT_ID EndPt,
				      adf_nbuf_t hdr_buf, adf_nbuf_t buf,
				      void *ServiceCtx)
{
  906848:	6c1006        	entry	a1, 48
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  90684b:	dc10      	mov.n	a12, a1
  90684d:	b41b      	addi.n	a11, a1, 4
	a_uint32_t len;
	ath_data_hdr_t *dh;
	struct ath_node_target *an;
	struct ath_atx_tid *tid;

	if (!hdr_buf) {
  90684f:	cc3d      	bnez.n	a3, 906860 <tgt_HTCRecvMessageHandler+0x18>
  906851:	da40      	mov.n	a10, a4
  906853:	5bf38c        	call8	903684 <__adf_nbuf_peek_header>
 *         or NULL if there is not sufficient data to pull.
 */
static inline a_uint8_t *
adf_nbuf_pull_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_pull_head(buf, size);
  906856:	c0bc      	movi.n	a11, 12
  906858:	da40      	mov.n	a10, a4
  90685a:	5bf2e5        	call8	9033f0 <__adf_nbuf_pull_head>
  90685d:	600004        	j	906865 <tgt_HTCRecvMessageHandler+0x1d>
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  906860:	da30      	mov.n	a10, a3
  906862:	5bf388        	call8	903684 <__adf_nbuf_peek_header>
		adf_nbuf_pull_head(buf, sizeof(ath_data_hdr_t));
	} else {
		adf_nbuf_peek_header(hdr_buf, &data, &len);
	}

	adf_os_assert(len >= sizeof(ath_data_hdr_t));
  906865:	8310      	l32i.n	a3, a1, 0
  906867:	c06b      	movi.n	a6, 11
  906869:	736303        	bltu	a6, a3, 906870 <tgt_HTCRecvMessageHandler+0x28>
  90686c:	63fffc        	j	90686c <tgt_HTCRecvMessageHandler+0x24>
  90686f:	002952        	extui	a9, a0, 18, 3
	dh = (ath_data_hdr_t *)data;

	an = &sc->sc_sta[dh->ni_index];
	tid = ATH_AN_2_TID(an, dh->tidno);

	sc->sc_tx_stats.tx_tgt++;
  906872:	5b8311        	call8	8e74b8 <memset+0x231c>
  906875:	b199      	addi.n	a9, a9, 1
	}

	adf_os_assert(len >= sizeof(ath_data_hdr_t));
	dh = (ath_data_hdr_t *)data;

	an = &sc->sc_sta[dh->ni_index];
  906877:	263001        	l8ui	a6, a3, 1
	tid = ATH_AN_2_TID(an, dh->tidno);
  90687a:	273003        	l8ui	a7, a3, 3

	sc->sc_tx_stats.tx_tgt++;

	bf = ath_tgt_tx_prepare(sc, buf, dh);
  90687d:	db40      	mov.n	a11, a4
	dh = (ath_data_hdr_t *)data;

	an = &sc->sc_sta[dh->ni_index];
	tid = ATH_AN_2_TID(an, dh->tidno);

	sc->sc_tx_stats.tx_tgt++;
  90687f:	29565b        	s32i	a9, a5, 0x16c

	bf = ath_tgt_tx_prepare(sc, buf, dh);
  906882:	dc30      	mov.n	a12, a3
  906884:	da50      	mov.n	a10, a5
  906886:	580cc8        	call8	909ba8 <ath_tgt_tx_prepare>
  906889:	dba0      	mov.n	a11, a10
	if (!bf) {
  90688b:	cda1      	bnez.n	a10, 9068a0 <tgt_HTCRecvMessageHandler+0x58>
		ath_free_tx_skb(sc->tgt_htc_handle,EndPt,buf);
  90688d:	13716e        	l32r	a3, 8e2e48 <hif_module_install+0x274>
  906890:	8a52      	l32i.n	a10, a5, 8
  906892:	233287        	l32i	a3, a3, 0x21c
  906895:	dc40      	mov.n	a12, a4
  906897:	db20      	mov.n	a11, a2
  906899:	0b3000        	callx8	a3
  90689c:	d10f      	retw.n
  90689e:	000022        	excw
		return;
	}

	bf->bf_endpt = EndPt;
  9068a1:	a623      	add.n	a3, a2, a6
	bf->bf_cookie = dh->cookie;
  9068a3:	22300a        	l8ui	a2, a3, 10

	if (tid->flag & TID_AGGR_ENABLED)
  9068a6:	0c7811        	slli	a8, a7, 4
		ath_free_tx_skb(sc->tgt_htc_handle,EndPt,buf);
		return;
	}

	bf->bf_endpt = EndPt;
	bf->bf_cookie = dh->cookie;
  9068a9:	22a492        	s8i	a2, a10, 146

	if (tid->flag & TID_AGGR_ENABLED)
  9068ac:	07820c        	sub	a2, a8, a7
  9068af:	0a6811        	slli	a8, a6, 6
  9068b2:	a688      	add.n	a8, a8, a6
  9068b4:	0f8811        	slli	a8, a8, 1
  9068b7:	a688      	add.n	a8, a8, a6
  9068b9:	a288      	add.n	a8, a8, a2
  9068bb:	0e8811        	slli	a8, a8, 2
  9068be:	225a92        	movi	a2, 0x592
  9068c1:	a858      	add.n	a8, a5, a8
  9068c3:	a288      	add.n	a8, a8, a2
  9068c5:	228000        	l8ui	a2, a8, 0
		ath_tgt_handle_aggr(sc, bf);
  9068c8:	da50      	mov.n	a10, a5
	}

	bf->bf_endpt = EndPt;
	bf->bf_cookie = dh->cookie;

	if (tid->flag & TID_AGGR_ENABLED)
  9068ca:	7e2707        	bbci	a2, 30, 9068d5 <tgt_HTCRecvMessageHandler+0x8d>
		ath_tgt_handle_aggr(sc, bf);
  9068cd:	580e83        	call8	90a2dc <ath_tgt_handle_aggr>
  9068d0:	d10f      	retw.n
  9068d2:	000000        	ill
	else
		ath_tgt_handle_normal(sc, bf);
  9068d5:	580e61        	call8	90a25c <ath_tgt_handle_normal>
  9068d8:	d10f      	retw.n
	...

009068dc <tgt_HTCRecv_cabhandler>:
}

static void tgt_HTCRecv_cabhandler(HTC_ENDPOINT_ID EndPt, adf_nbuf_t hdr_buf,
				   adf_nbuf_t buf, void *ServiceCtx)
{
  9068dc:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)ServiceCtx;
	struct ath_hal *ah = sc->sc_ah;
  9068df:	285d05        	addmi	a8, a5, 0x500
  9068e2:	8a8b      	l32i.n	a10, a8, 44
	a_uint64_t tsf;
	a_uint32_t tmp;

#ifdef ATH_ENABLE_CABQ
	tsf = ah->ah_getTsf64(ah);
  9068e4:	28a21e        	l32i	a8, a10, 120
  9068e7:	0b8000        	callx8	a8
	tmp = tsf - sc->sc_swba_tsf;
  9068ea:	285d16        	addmi	a8, a5, 0x1600
  9068ed:	888d      	l32i.n	a8, a8, 52
  9068ef:	08bb0c        	sub	a11, a11, a8

	if ( tmp > ATH_CABQ_HANDLING_THRESHOLD ) {
  9068f2:	187280        	l32r	a8, 8e32f4 <bStandardCommand+0x68>
  9068f5:	7b8b11        	bgeu	a8, a11, 90690a <tgt_HTCRecv_cabhandler+0x2e>
		HTC_ReturnBuffers(sc->tgt_htc_handle, EndPt, buf);
  9068f8:	13716e        	l32r	a3, 8e2eb0 <hif_module_install+0x2dc>
  9068fb:	8a52      	l32i.n	a10, a5, 8
  9068fd:	233287        	l32i	a3, a3, 0x21c
  906900:	dc40      	mov.n	a12, a4
  906902:	022b02        	or	a11, a2, a2
  906905:	0b3000        	callx8	a3
  906908:	d10f      	retw.n
		return;
	}

	tgt_HTCRecvMessageHandler(EndPt, hdr_buf, buf, ServiceCtx);
  90690a:	dd50      	mov.n	a13, a5
  90690c:	dc40      	mov.n	a12, a4
  90690e:	db30      	mov.n	a11, a3
  906910:	da20      	mov.n	a10, a2
  906912:	5bffcd        	call8	906848 <tgt_HTCRecvMessageHandler>
  906915:	d10f      	retw.n
	...

00906918 <ath_rxdesc_init>:
				       RX_HEADER_SPACE, align);
	return skb;
}

static a_int32_t ath_rxdesc_init(struct ath_softc_tgt *sc, struct ath_rx_desc *ds)
{
  906918:	6c1006        	entry	a1, 48
	struct ath_hal *ah = sc->sc_ah;
  90691b:	242d05        	addmi	a4, a2, 0x500
  90691e:	854b      	l32i.n	a5, a4, 44
	struct ath_rx_desc *ds_held;
	a_uint8_t *anbdata;
	a_uint32_t anblen;

	if (!sc->sc_rxdesc_held) {
  906920:	2422db        	l32i	a4, a2, 0x36c
		sc->sc_rxdesc_held = ds;
  906923:	2326db        	s32i	a3, a2, 0x36c
	struct ath_hal *ah = sc->sc_ah;
	struct ath_rx_desc *ds_held;
	a_uint8_t *anbdata;
	a_uint32_t anblen;

	if (!sc->sc_rxdesc_held) {
  906926:	cc43      	bnez.n	a4, 90692d <ath_rxdesc_init+0x15>
  906928:	600180        	j	906aac <ath_rxdesc_init+0x194>
  90692b:	000028        	mull	a0, a0, a0

	ds_held = sc->sc_rxdesc_held;
	sc->sc_rxdesc_held = ds;
	ds = ds_held;

	if (ds->ds_nbuf == ADF_NBUF_NULL) {
  90692e:	403423        	excw
  906931:	403508        	excw
  906934:	8810      	l32i.n	a8, a1, 0
  906936:	003311        	slli	a3, a3, 16
  906939:	083802        	or	a8, a3, a8
  90693c:	234036        	l8ui	a3, a4, 54
  90693f:	264037        	l8ui	a6, a4, 55
  906942:	083311        	slli	a3, a3, 8
  906945:	083302        	or	a3, a3, a8
  906948:	036302        	or	a3, a6, a3
  90694b:	6530b9        	bnez	a3, 906a08 <ath_rxdesc_init+0xf0>
static adf_nbuf_t ath_alloc_skb_align(struct ath_softc_tgt *sc,
				      a_uint32_t size, a_uint32_t align)
{
	adf_nbuf_t skb;

	skb = BUF_Pool_alloc_buf_align(sc->pool_handle, POOL_ID_WLAN_RX_BUF,
  90694e:	13716e        	l32r	a3, 8e2f08 <bGet_descriptor+0x44>
  906951:	2d2196        	l16ui	a13, a2, 0x12c
  906954:	2332a2        	l32i	a3, a3, 0x288
  906957:	8a20      	l32i.n	a10, a2, 0
  906959:	c3c0      	movi.n	a12, 48
  90695b:	c0b3      	movi.n	a11, 3
  90695d:	0b3000        	callx8	a3
	ds_held = sc->sc_rxdesc_held;
	sc->sc_rxdesc_held = ds;
	ds = ds_held;

	if (ds->ds_nbuf == ADF_NBUF_NULL) {
		ds->ds_nbuf = ath_alloc_skb_align(sc, sc->sc_rxbufsize, sc->sc_cachelsz);
  906960:	0a8357        	extui	a3, a10, 24, 8
  906963:	234434        	s8i	a3, a4, 52
  906966:	0a0357        	extui	a3, a10, 16, 8
  906969:	234435        	s8i	a3, a4, 53
  90696c:	0a8347        	extui	a3, a10, 8, 8
  90696f:	234436        	s8i	a3, a4, 54
  906972:	2a4437        	s8i	a10, a4, 55
		if (ds->ds_nbuf == ADF_NBUF_NULL) {
  906975:	cda0      	bnez.n	a10, 906989 <ath_rxdesc_init+0x71>
			sc->sc_rxdesc_held = ds;
			sc->sc_rx_stats.ast_rx_nobuf++;
  906977:	23227c        	l32i	a3, a2, 0x1f0
	ds = ds_held;

	if (ds->ds_nbuf == ADF_NBUF_NULL) {
		ds->ds_nbuf = ath_alloc_skb_align(sc, sc->sc_rxbufsize, sc->sc_cachelsz);
		if (ds->ds_nbuf == ADF_NBUF_NULL) {
			sc->sc_rxdesc_held = ds;
  90697a:	2426db        	s32i	a4, a2, 0x36c
			sc->sc_rx_stats.ast_rx_nobuf++;
  90697d:	b133      	addi.n	a3, a3, 1
  90697f:	23267c        	s32i	a3, a2, 0x1f0
			return ENOMEM;
  906982:	c72f      	movi.n	a2, -1
  906984:	d10f      	retw.n
  906986:	000000        	ill
		}
		adf_nbuf_map(sc->sc_dev, ds->ds_dmap, ds->ds_nbuf, ADF_OS_DMA_FROM_DEVICE);
  906989:	234038        	l8ui	a3, a4, 56
  90698c:	2b4039        	l8ui	a11, a4, 57
  90698f:	083310        	slli	a3, a3, 24
  906992:	00bb11        	slli	a11, a11, 16
  906995:	03bb02        	or	a11, a11, a3
  906998:	23403a        	l8ui	a3, a4, 58
adf_nbuf_map(adf_os_device_t        osdev, 
             adf_os_dma_map_t       bmap, 
             adf_nbuf_t             buf, 
             adf_os_dma_dir_t       dir)
{
    return __adf_nbuf_map(osdev, bmap, buf, dir);
  90699b:	dca0      	mov.n	a12, a10
  90699d:	083311        	slli	a3, a3, 8
  9069a0:	0b3302        	or	a3, a3, a11
  9069a3:	2b403b        	l8ui	a11, a4, 59
  9069a6:	2a2246        	l32i	a10, a2, 0x118
  9069a9:	03bb02        	or	a11, a11, a3
  9069ac:	c0d1      	movi.n	a13, 1
  9069ae:	5bf2c7        	call8	9034cc <__adf_nbuf_map>
		adf_nbuf_dmamap_info(ds->ds_dmap, &ds->ds_dmap_info);
  9069b1:	2a4039        	l8ui	a10, a4, 57
  9069b4:	234038        	l8ui	a3, a4, 56
  9069b7:	00aa11        	slli	a10, a10, 16
  9069ba:	083310        	slli	a3, a3, 24
  9069bd:	03aa02        	or	a10, a10, a3
  9069c0:	23403a        	l8ui	a3, a4, 58
 * @param[out] sg   map info
 */
static inline void
adf_nbuf_dmamap_info(adf_os_dma_map_t bmap, adf_os_dmamap_info_t *sg)
{
    __adf_nbuf_dmamap_info(bmap, sg);
  9069c3:	2b4c3c        	addi	a11, a4, 60
  9069c6:	083311        	slli	a3, a3, 8
  9069c9:	0a3302        	or	a3, a3, a10
  9069cc:	2a403b        	l8ui	a10, a4, 59
  9069cf:	03aa02        	or	a10, a10, a3
  9069d2:	5bf2c6        	call8	9034ec <__adf_nbuf_dmamap_info>
		ds->ds_data = ds->ds_dmap_info.dma_segs[0].paddr;
  9069d5:	234040        	l8ui	a3, a4, 64
  9069d8:	083810        	slli	a8, a3, 24
  9069db:	234041        	l8ui	a3, a4, 65
  9069de:	003311        	slli	a3, a3, 16
  9069e1:	083302        	or	a3, a3, a8
  9069e4:	284042        	l8ui	a8, a4, 66
  9069e7:	088811        	slli	a8, a8, 8
  9069ea:	038302        	or	a3, a8, a3
  9069ed:	284043        	l8ui	a8, a4, 67
  9069f0:	038802        	or	a8, a8, a3
  9069f3:	088357        	extui	a3, a8, 24, 8
  9069f6:	234404        	s8i	a3, a4, 4
  9069f9:	080357        	extui	a3, a8, 16, 8
  9069fc:	234405        	s8i	a3, a4, 5
  9069ff:	088347        	extui	a3, a8, 8, 8
  906a02:	234406        	s8i	a3, a4, 6
  906a05:	284407        	s8i	a8, a4, 7
	}

	ds->ds_link = 0;
	adf_nbuf_peek_header(ds->ds_nbuf, &anbdata, &anblen);
  906a08:	284034        	l8ui	a8, a4, 52
  906a0b:	2a4035        	l8ui	a10, a4, 53
  906a0e:	088810        	slli	a8, a8, 24
  906a11:	00aa11        	slli	a10, a10, 16
  906a14:	08aa02        	or	a10, a10, a8
  906a17:	284036        	l8ui	a8, a4, 54
		adf_nbuf_map(sc->sc_dev, ds->ds_dmap, ds->ds_nbuf, ADF_OS_DMA_FROM_DEVICE);
		adf_nbuf_dmamap_info(ds->ds_dmap, &ds->ds_dmap_info);
		ds->ds_data = ds->ds_dmap_info.dma_segs[0].paddr;
	}

	ds->ds_link = 0;
  906a1a:	c030      	movi.n	a3, 0
	adf_nbuf_peek_header(ds->ds_nbuf, &anbdata, &anblen);
  906a1c:	088811        	slli	a8, a8, 8
  906a1f:	0a8802        	or	a8, a8, a10
  906a22:	2a4037        	l8ui	a10, a4, 55
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  906a25:	dc10      	mov.n	a12, a1
  906a27:	2b1c04        	addi	a11, a1, 4
  906a2a:	08aa02        	or	a10, a10, a8
		adf_nbuf_map(sc->sc_dev, ds->ds_dmap, ds->ds_nbuf, ADF_OS_DMA_FROM_DEVICE);
		adf_nbuf_dmamap_info(ds->ds_dmap, &ds->ds_dmap_info);
		ds->ds_data = ds->ds_dmap_info.dma_segs[0].paddr;
	}

	ds->ds_link = 0;
  906a2d:	234400        	s8i	a3, a4, 0
  906a30:	234401        	s8i	a3, a4, 1
  906a33:	234402        	s8i	a3, a4, 2
  906a36:	234403        	s8i	a3, a4, 3
  906a39:	5bf312        	call8	903684 <__adf_nbuf_peek_header>
	adf_nbuf_peek_header(ds->ds_nbuf, &anbdata, &anblen);

	ah->ah_setupRxDesc(ds, adf_nbuf_tailroom(ds->ds_nbuf), 0);
  906a3c:	284034        	l8ui	a8, a4, 52
  906a3f:	2a4035        	l8ui	a10, a4, 53
  906a42:	088810        	slli	a8, a8, 24
  906a45:	00aa11        	slli	a10, a10, 16
  906a48:	08aa02        	or	a10, a10, a8
  906a4b:	284036        	l8ui	a8, a4, 54
  906a4e:	265220        	l32i	a6, a5, 128
  906a51:	088811        	slli	a8, a8, 8
  906a54:	0a8802        	or	a8, a8, a10
  906a57:	2a4037        	l8ui	a10, a4, 55
 * @return amount of tail room 
 */
static inline a_uint32_t
adf_nbuf_tailroom(adf_nbuf_t buf)
{
    return (__adf_nbuf_tailroom(buf));
  906a5a:	08aa02        	or	a10, a10, a8
  906a5d:	5bf2fa        	call8	903648 <__adf_nbuf_tailroom>
  906a60:	dba0      	mov.n	a11, a10
  906a62:	dc30      	mov.n	a12, a3
  906a64:	da40      	mov.n	a10, a4
  906a66:	0b6000        	callx8	a6
  906a69:	2b4048        	l8ui	a11, a4, 72
  906a6c:	294049        	l8ui	a9, a4, 73
  906a6f:	28404a        	l8ui	a8, a4, 74

	if (sc->sc_rxlink == NULL) {
  906a72:	2322ef        	l32i	a3, a2, 0x3bc
		ah->ah_setRxDP(ah, ds->ds_daddr);
  906a75:	08bb10        	slli	a11, a11, 24
  906a78:	009911        	slli	a9, a9, 16
  906a7b:	2a404b        	l8ui	a10, a4, 75
  906a7e:	0b9902        	or	a9, a9, a11
  906a81:	088811        	slli	a8, a8, 8
	ds->ds_link = 0;
	adf_nbuf_peek_header(ds->ds_nbuf, &anbdata, &anblen);

	ah->ah_setupRxDesc(ds, adf_nbuf_tailroom(ds->ds_nbuf), 0);

	if (sc->sc_rxlink == NULL) {
  906a84:	cd31      	bnez.n	a3, 906a99 <ath_rxdesc_init+0x181>
		ah->ah_setRxDP(ah, ds->ds_daddr);
  906a86:	098b02        	or	a11, a8, a9
  906a89:	23521f        	l32i	a3, a5, 124
  906a8c:	0bab02        	or	a11, a10, a11
  906a8f:	da50      	mov.n	a10, a5
  906a91:	0b3000        	callx8	a3
  906a94:	600009        	j	906aa1 <ath_rxdesc_init+0x189>
  906a97:	000009        	addx2	a0, a0, a0
	}
	else {
		*sc->sc_rxlink = ds->ds_daddr;
  906a9a:	8802      	l32i.n	a8, a0, 8
  906a9c:	08a802        	or	a8, a10, a8
  906a9f:	9830      	s32i.n	a8, a3, 0
	}
	sc->sc_rxlink = &ds->ds_link;
  906aa1:	2426ef        	s32i	a4, a2, 0x3bc
	ah->ah_enableReceive(ah);
  906aa4:	225225        	l32i	a2, a5, 148
  906aa7:	da50      	mov.n	a10, a5
  906aa9:	0b2000        	callx8	a2

	return 0;
  906aac:	c020      	movi.n	a2, 0
}
  906aae:	d10f      	retw.n

00906ab0 <tgt_HTCSendCompleteHandler>:
		asf_tailq_insert_tail(&sc->sc_rxdesc, ds_tmp, ds_list);
	}
}

static void tgt_HTCSendCompleteHandler(HTC_ENDPOINT_ID Endpt, adf_nbuf_t buf, void *ServiceCtx)
{
  906ab0:	6c1006        	entry	a1, 48
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)ServiceCtx;

	if (Endpt == RX_ENDPOINT_ID) {
  906ab3:	682302        	beqi	a2, 3, 906ab9 <tgt_HTCSendCompleteHandler+0x9>
  906ab6:	600100        	j	906bba <tgt_HTCSendCompleteHandler+0x10a>
		sc->sc_rx_stats.ast_rx_done++;
  906ab9:	22427e        	l32i	a2, a4, 0x1f8
}

static inline void
adf_nbuf_split_to_frag(adf_nbuf_t buf, adf_nbuf_queue_t *qhead)
{
    return __adf_nbuf_split_to_frag(buf, qhead);
  906abc:	da30      	mov.n	a10, a3
  906abe:	b122      	addi.n	a2, a2, 1
  906ac0:	22467e        	s32i	a2, a4, 0x1f8
  906ac3:	db10      	mov.n	a11, a1
  906ac5:	5bf2b2        	call8	903590 <__adf_nbuf_split_to_frag>
	struct ath_rx_desc *ds;
	adf_nbuf_t buf_tmp;
	adf_nbuf_queue_t nbuf_head;

	adf_nbuf_split_to_frag(buf, &nbuf_head);
	ds = asf_tailq_first(&sc->sc_rxdesc_idle);
  906ac8:	2242d7        	l32i	a2, a4, 0x35c

		if (buf_tmp == NULL) {
			break;
		}

		BUF_Pool_free_buf(sc->pool_handle, POOL_ID_WLAN_RX_BUF, buf_tmp);
  906acb:	13716e        	l32r	a3, 8e3084 <bSet_configuration+0x108>
  906ace:	6000e5        	j	906bb7 <tgt_HTCSendCompleteHandler+0x107>
 * @return The head buf in the buf queue.
 */
static inline adf_nbuf_t
adf_nbuf_queue_remove(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_remove(head);
  906ad1:	da10      	mov.n	a10, a1
  906ad3:	5bf26d        	call8	903488 <__adf_nbuf_queue_remove>

	while (ds) {
		struct ath_rx_desc *ds_tmp;
		buf_tmp = adf_nbuf_queue_remove(&nbuf_head);

		if (buf_tmp == NULL) {
  906ad6:	64a0e0        	beqz	a10, 906bba <tgt_HTCSendCompleteHandler+0x10a>
			break;
		}

		BUF_Pool_free_buf(sc->pool_handle, POOL_ID_WLAN_RX_BUF, buf_tmp);
  906ad9:	dca0      	mov.n	a12, a10
  906adb:	2532a3        	l32i	a5, a3, 0x28c
  906ade:	8a40      	l32i.n	a10, a4, 0
  906ae0:	c0b3      	movi.n	a11, 3
  906ae2:	0b5000        	callx8	a5

		ds_tmp = ds;
		ds = asf_tailq_next(ds, ds_list);
  906ae5:	28204c        	l8ui	a8, a2, 76
  906ae8:	25204d        	l8ui	a5, a2, 77
  906aeb:	088810        	slli	a8, a8, 24
  906aee:	005511        	slli	a5, a5, 16
  906af1:	085802        	or	a8, a5, a8
  906af4:	25204e        	l8ui	a5, a2, 78

		ath_rxdesc_init(sc, ds_tmp);
  906af7:	022b02        	or	a11, a2, a2
		}

		BUF_Pool_free_buf(sc->pool_handle, POOL_ID_WLAN_RX_BUF, buf_tmp);

		ds_tmp = ds;
		ds = asf_tailq_next(ds, ds_list);
  906afa:	085511        	slli	a5, a5, 8
  906afd:	085502        	or	a5, a5, a8
  906b00:	28204f        	l8ui	a8, a2, 79

		ath_rxdesc_init(sc, ds_tmp);
  906b03:	044a02        	or	a10, a4, a4
		}

		BUF_Pool_free_buf(sc->pool_handle, POOL_ID_WLAN_RX_BUF, buf_tmp);

		ds_tmp = ds;
		ds = asf_tailq_next(ds, ds_list);
  906b06:	058502        	or	a5, a8, a5

		ath_rxdesc_init(sc, ds_tmp);
  906b09:	5bff83        	call8	906918 <ath_rxdesc_init>

		asf_tailq_remove(&sc->sc_rxdesc_idle, ds_tmp, ds_list);
  906b0c:	28204c        	l8ui	a8, a2, 76
  906b0f:	2c2050        	l8ui	a12, a2, 80
  906b12:	088a10        	slli	a10, a8, 24
  906b15:	28204d        	l8ui	a8, a2, 77
  906b18:	292052        	l8ui	a9, a2, 82
  906b1b:	008811        	slli	a8, a8, 16
  906b1e:	0a8802        	or	a8, a8, a10
  906b21:	2a204e        	l8ui	a10, a2, 78
  906b24:	08cc10        	slli	a12, a12, 24
  906b27:	08aa11        	slli	a10, a10, 8
  906b2a:	08a802        	or	a8, a10, a8
  906b2d:	2a204f        	l8ui	a10, a2, 79
  906b30:	2b2053        	l8ui	a11, a2, 83
  906b33:	08aa02        	or	a10, a10, a8
  906b36:	282051        	l8ui	a8, a2, 81
  906b39:	089911        	slli	a9, a9, 8
  906b3c:	008811        	slli	a8, a8, 16
  906b3f:	0c8802        	or	a8, a8, a12
  906b42:	089802        	or	a8, a9, a8
  906b45:	08b802        	or	a8, a11, a8
  906b48:	c9a8      	beqz.n	a10, 906b64 <tgt_HTCSendCompleteHandler+0xb4>
  906b4a:	088957        	extui	a9, a8, 24, 8
  906b4d:	29a450        	s8i	a9, a10, 80
  906b50:	080957        	extui	a9, a8, 16, 8
  906b53:	29a451        	s8i	a9, a10, 81
  906b56:	088947        	extui	a9, a8, 8, 8
  906b59:	29a452        	s8i	a9, a10, 82
  906b5c:	28a453        	s8i	a8, a10, 83
  906b5f:	600004        	j	906b67 <tgt_HTCSendCompleteHandler+0xb7>
  906b62:	000028        	mull	a0, a0, a0
  906b65:	46d829        	excw
  906b68:	205028        	l8ui	a0, a5, 40
  906b6b:	205108        	l16ui	a0, a5, 16
  906b6e:	9910      	s32i.n	a9, a1, 0
  906b70:	008811        	slli	a8, a8, 16
  906b73:	098902        	or	a9, a8, a9
  906b76:	282052        	l8ui	a8, a2, 82
  906b79:	088811        	slli	a8, a8, 8
  906b7c:	098802        	or	a8, a8, a9
  906b7f:	292053        	l8ui	a9, a2, 83
  906b82:	089802        	or	a8, a9, a8
  906b85:	9a80      	s32i.n	a10, a8, 0
		asf_tailq_insert_tail(&sc->sc_rxdesc, ds_tmp, ds_list);
  906b87:	c080      	movi.n	a8, 0
  906b89:	28244c        	s8i	a8, a2, 76
  906b8c:	28244d        	s8i	a8, a2, 77
  906b8f:	28244e        	s8i	a8, a2, 78
  906b92:	28244f        	s8i	a8, a2, 79
  906b95:	2842da        	l32i	a8, a4, 0x368
  906b98:	088957        	extui	a9, a8, 24, 8
  906b9b:	292450        	s8i	a9, a2, 80
  906b9e:	080957        	extui	a9, a8, 16, 8
  906ba1:	292451        	s8i	a9, a2, 81
  906ba4:	088947        	extui	a9, a8, 8, 8
  906ba7:	292452        	s8i	a9, a2, 82
  906baa:	282453        	s8i	a8, a2, 83
  906bad:	9280      	s32i.n	a2, a8, 0
  906baf:	222c4c        	addi	a2, a2, 76
  906bb2:	2246da        	s32i	a2, a4, 0x368
		}

		BUF_Pool_free_buf(sc->pool_handle, POOL_ID_WLAN_RX_BUF, buf_tmp);

		ds_tmp = ds;
		ds = asf_tailq_next(ds, ds_list);
  906bb5:	d250      	mov.n	a2, a5
	adf_nbuf_queue_t nbuf_head;

	adf_nbuf_split_to_frag(buf, &nbuf_head);
	ds = asf_tailq_first(&sc->sc_rxdesc_idle);

	while (ds) {
  906bb7:	652f16        	bnez	a2, 906ad1 <tgt_HTCSendCompleteHandler+0x21>
  906bba:	d10f      	retw.n

00906bbc <wmi_event>:

}

void wmi_event(wmi_handle_t handle, WMI_EVENT_ID evt_id,
	       void *buffer, a_int32_t Length)
{
  906bbc:	6c1004        	entry	a1, 32
	adf_nbuf_t netbuf = ADF_NBUF_NULL;
	a_uint8_t *pData;

	netbuf = WMI_AllocEvent(handle, WMI_EVT_CLASS_CMD_EVENT,
  906bbf:	16716e        	l32r	a6, 8e3178 <bSet_configuration+0x1fc>
  906bc2:	b45c      	addi.n	a12, a5, 4
  906bc4:	276292        	l32i	a7, a6, 0x248
  906bc7:	c0b0      	movi.n	a11, 0
  906bc9:	da20      	mov.n	a10, a2
  906bcb:	0b7000        	callx8	a7
  906bce:	d7a0      	mov.n	a7, a10
				sizeof(WMI_CMD_HDR) + Length);

	if (netbuf == ADF_NBUF_NULL) {
  906bd0:	65a00a        	bnez	a10, 906bde <wmi_event+0x22>
		adf_os_print("Buf null\n");
  906bd3:	226212        	l32i	a2, a6, 72
  906bd6:	1a7281        	l32r	a10, 8e35dc <bStandardCommand+0x350>
  906bd9:	0b2000        	callx8	a2
  906bdc:	d10f      	retw.n
		return;
	}

	if (buffer != NULL && Length != 0 && Length < WMI_SVC_MAX_BUFFERED_EVENT_SIZE) {
  906bde:	c090      	movi.n	a9, 0
  906be0:	c081      	movi.n	a8, 1
  906be2:	099a02        	or	a10, a9, a9
  906be5:	2b0a63        	movi	a11, 99
  906be8:	058a39        	movnez	a10, a8, a5
  906beb:	75ba02        	bge	a11, a5, 906bf1 <wmi_event+0x35>
  906bee:	099802        	or	a8, a9, a9
  906bf1:	78a00f        	bnone	a10, a8, 906c04 <wmi_event+0x48>
  906bf4:	c84c      	beqz.n	a4, 906c04 <wmi_event+0x48>
 *         put, or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_put_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_put_tail(buf, size);
  906bf6:	db50      	mov.n	a11, a5
  906bf8:	da70      	mov.n	a10, a7
  906bfa:	5bf27d        	call8	9035f0 <__adf_nbuf_put_tail>
 * @param[in] size    buffer size
 */
static inline void
adf_os_mem_copy(void *dst, const void *src, adf_os_size_t size)
{
    __adf_os_mem_copy(dst, src, size);
  906bfd:	dc50      	mov.n	a12, a5
  906bff:	db40      	mov.n	a11, a4
  906c01:	5bfe07        	call8	906420 <__adf_os_mem_copy>
		pData = adf_nbuf_put_tail(netbuf, Length);
		adf_os_mem_copy(pData, buffer, Length);
	}

	WMI_SendEvent(handle, netbuf, evt_id, 0, Length);
  906c04:	246293        	l32i	a4, a6, 0x24c
  906c07:	de50      	mov.n	a14, a5
  906c09:	c0d0      	movi.n	a13, 0
  906c0b:	030c4f        	extui	a12, a3, 0, 16
  906c0e:	db70      	mov.n	a11, a7
  906c10:	da20      	mov.n	a10, a2
  906c12:	0b4000        	callx8	a4
  906c15:	d10f      	retw.n
	...

00906c18 <ath_intr>:
/**********************/
/* Interrupt Handling */
/**********************/

adf_os_irq_resp_t ath_intr(adf_drv_handle_t hdl)
{
  906c18:	6c100a        	entry	a1, 80
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)hdl;
	struct ath_hal *ah = sc->sc_ah;
	HAL_INT status;

	if (sc->sc_invalid)
  906c1b:	232249        	l32i	a3, a2, 0x124
  906c1e:	673006        	bgez	a3, 906c28 <ath_intr+0x10>
		return ADF_OS_IRQ_NONE;
  906c21:	c030      	movi.n	a3, 0
  906c23:	600621        	j	907248 <ath_intr+0x630>
  906c26:	000025        	excw
/**********************/

adf_os_irq_resp_t ath_intr(adf_drv_handle_t hdl)
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)hdl;
	struct ath_hal *ah = sc->sc_ah;
  906c29:	2d0584        	s16i	a13, a0, 0x108
  906c2c:	5b2342        	call8	8cf938 <_bss_end+0x3c2130>
	HAL_INT status;

	if (sc->sc_invalid)
		return ADF_OS_IRQ_NONE;

	if (!ah->ah_isInterruptPending(ah))
  906c2f:	26da40        	movi	a6, 0xfffffd40
  906c32:	0b3000        	callx8	a3
  906c35:	64afe8        	beqz	a10, 906c21 <ath_intr+0x9>
		return ADF_OS_IRQ_NONE;

	ah->ah_getPendingInterrupts(ah, &status);
  906c38:	234227        	l32i	a3, a4, 156
  906c3b:	bc1b      	addi.n	a11, a1, 12
  906c3d:	da40      	mov.n	a10, a4
  906c3f:	0b3000        	callx8	a3

	status &= sc->sc_imask;
  906c42:	8613      	l32i.n	a6, a1, 12
  906c44:	2322c4        	l32i	a3, a2, 0x310
  906c47:	063301        	and	a3, a3, a6
  906c4a:	9313      	s32i.n	a3, a1, 12

	if (status & HAL_INT_FATAL) {
  906c4c:	713619        	bbci	a3, 1, 906c69 <ath_intr+0x51>
		ah->ah_setInterrupts(ah, 0);
  906c4f:	234228        	l32i	a3, a4, 160
  906c52:	c0b0      	movi.n	a11, 0
  906c54:	da40      	mov.n	a10, a4
  906c56:	0b3000        	callx8	a3
 * @param[in] bh    bottom instance
 */
static inline void 
adf_os_sched_bh(adf_os_handle_t hdl, adf_os_bh_t *bh)
{
    __adf_os_sched_bh(hdl, bh);
  906c59:	2a3a44        	movi	a10, 0x344
  906c5c:	aa2a      	add.n	a10, a2, a10
  906c5e:	5bfe52        	call8	9065a8 <__adf_os_sched_bh$isra$6>

		if (status & HAL_INT_CST)
			sc->sc_int_stats.ast_cst++;
	}

	return ADF_OS_IRQ_HANDLED;
  906c61:	c031      	movi.n	a3, 1
  906c63:	6005e1        	j	907248 <ath_intr+0x630>
  906c66:	000000        	ill

	if (status & HAL_INT_FATAL) {
		ah->ah_setInterrupts(ah, 0);
		ATH_SCHEDULE_TQUEUE(sc->sc_dev, &sc->sc_fataltq);
	} else {
		if (status & HAL_INT_SWBA) {
  906c69:	7f3643        	bbci	a3, 15, 906cb0 <ath_intr+0x98>
			WMI_SWBA_EVENT swbaEvt;
			struct ath_txq *txq = ATH_TXQ(sc, 8);

			swbaEvt.tsf = ah->ah_getTsf64(ah);
  906c6c:	23421e        	l32i	a3, a4, 120
  906c6f:	da40      	mov.n	a10, a4
  906c71:	0b3000        	callx8	a3
			swbaEvt.beaconPendingCount = ah->ah_numTxPending(ah, sc->sc_bhalq);
  906c74:	232d01        	addmi	a3, a2, 0x100
	} else {
		if (status & HAL_INT_SWBA) {
			WMI_SWBA_EVENT swbaEvt;
			struct ath_txq *txq = ATH_TXQ(sc, 8);

			swbaEvt.tsf = ah->ah_getTsf64(ah);
  906c77:	9b11      	s32i.n	a11, a1, 4
			swbaEvt.beaconPendingCount = ah->ah_numTxPending(ah, sc->sc_bhalq);
  906c79:	864b      	l32i.n	a6, a4, 44
  906c7b:	2b301c        	l8ui	a11, a3, 28
	} else {
		if (status & HAL_INT_SWBA) {
			WMI_SWBA_EVENT swbaEvt;
			struct ath_txq *txq = ATH_TXQ(sc, 8);

			swbaEvt.tsf = ah->ah_getTsf64(ah);
  906c7e:	9a10      	s32i.n	a10, a1, 0
			swbaEvt.beaconPendingCount = ah->ah_numTxPending(ah, sc->sc_bhalq);
  906c80:	da40      	mov.n	a10, a4
  906c82:	0b6000        	callx8	a6
  906c85:	2a1408        	s8i	a10, a1, 8
			sc->sc_swba_tsf = ah->ah_getTsf64(ah);
  906c88:	23421e        	l32i	a3, a4, 120
  906c8b:	044a02        	or	a10, a4, a4
  906c8e:	0b3000        	callx8	a3
  906c91:	232d16        	addmi	a3, a2, 0x1600
  906c94:	9a3c      	s32i.n	a10, a3, 48
  906c96:	9b3d      	s32i.n	a11, a3, 52

			wmi_event(sc->tgt_wmi_handle,
  906c98:	8a23      	l32i.n	a10, a2, 12
  906c9a:	1b7282        	l32r	a11, 8e36a4 <bStandardCommand+0x418>
  906c9d:	dc10      	mov.n	a12, a1
  906c9f:	c0d9      	movi.n	a13, 9
  906ca1:	5bffc6        	call8	906bbc <wmi_event>
	ah->ah_stopTxDma(ah, txq->axq_qnum);
}

static void owltgt_txq_drain(struct ath_softc_tgt *sc, struct ath_txq *txq)
{
	owltgt_tx_processq(sc, txq, OWL_TXQ_STOPPED);
  906ca4:	2b4acc        	movi	a11, 0x4cc
  906ca7:	c0c1      	movi.n	a12, 1
  906ca9:	ab2b      	add.n	a11, a2, a11
  906cab:	da20      	mov.n	a10, a2
  906cad:	580ec2        	call8	90a7b8 <owltgt_tx_processq>
				  sizeof(WMI_SWBA_EVENT));

			ath_tx_draintxq(sc, txq);
		}

		if (status & HAL_INT_RXORN)
  906cb0:	8313      	l32i.n	a3, a1, 12
  906cb2:	7a3707        	bbci	a3, 26, 906cbd <ath_intr+0xa5>
			sc->sc_int_stats.ast_rxorn++;
  906cb5:	26224d        	l32i	a6, a2, 0x134
  906cb8:	b166      	addi.n	a6, a6, 1
  906cba:	26264d        	s32i	a6, a2, 0x134

		if (status & HAL_INT_RXEOL)
  906cbd:	7b3708        	bbci	a3, 27, 906cc9 <ath_intr+0xb1>
			sc->sc_int_stats.ast_rxeol++;
  906cc0:	26224e        	l32i	a6, a2, 0x138
  906cc3:	266c01        	addi	a6, a6, 1
  906cc6:	26264e        	s32i	a6, a2, 0x138

		if (status & (HAL_INT_RX | HAL_INT_RXEOL | HAL_INT_RXORN)) {
  906cc9:	c361      	movi.n	a6, 49
  906ccb:	763802        	bany	a3, a6, 906cd1 <ath_intr+0xb9>
  906cce:	600530        	j	907202 <ath_intr+0x5ea>
			if (status & HAL_INT_RX)
  906cd1:	7f3707        	bbci	a3, 31, 906cdc <ath_intr+0xc4>
				sc->sc_int_stats.ast_rx++;
  906cd4:	23224c        	l32i	a3, a2, 0x130
  906cd7:	b133      	addi.n	a3, a3, 1
  906cd9:	23264c        	s32i	a3, a2, 0x130
	}
}

static void ath_uapsd_processtriggers(struct ath_softc_tgt *sc)
{
	struct ath_hal *ah = sc->sc_ah;
  906cdc:	855b      	l32i.n	a5, a5, 44

#define	PA2DESC(_sc, _pa)						\
	((struct ath_desc *)((caddr_t)(_sc)->sc_rxdma.dd_desc +		\
			     ((_pa) - (_sc)->sc_rxdma.dd_desc_paddr)))

	tsf = ah->ah_getTsf64(ah);
  906cde:	23521e        	l32i	a3, a5, 120
  906ce1:	da50      	mov.n	a10, a5
	}
}

static void ath_uapsd_processtriggers(struct ath_softc_tgt *sc)
{
	struct ath_hal *ah = sc->sc_ah;
  906ce3:	9515      	s32i.n	a5, a1, 20

#define	PA2DESC(_sc, _pa)						\
	((struct ath_desc *)((caddr_t)(_sc)->sc_rxdma.dd_desc +		\
			     ((_pa) - (_sc)->sc_rxdma.dd_desc_paddr)))

	tsf = ah->ah_getTsf64(ah);
  906ce5:	0b3000        	callx8	a3
	bf = asf_tailq_first(&sc->sc_rxbuf);
  906ce8:	2522d5        	l32i	a5, a2, 0x354

	ds = asf_tailq_first(&sc->sc_rxdesc);
  906ceb:	2322d9        	l32i	a3, a2, 0x364
  906cee:	6004d7        	j	9071c9 <ath_intr+0x5b1>
	ds_head = ds;

	while(ds) {
		++cnt;

		if (cnt == ath_numrxbufs - 1) {
  906cf1:	197283        	l32r	a9, 8e3700 <bStandardCommand+0x474>

	ds = asf_tailq_first(&sc->sc_rxdesc);
	ds_head = ds;

	while(ds) {
		++cnt;
  906cf4:	b177      	addi.n	a7, a7, 1

		if (cnt == ath_numrxbufs - 1) {
  906cf6:	8a90      	l32i.n	a10, a9, 0
  906cf8:	b0aa      	addi.n	a10, a10, -1
  906cfa:	7a7102        	beq	a7, a10, 906d00 <ath_intr+0xe8>
  906cfd:	6001f7        	j	906ef8 <ath_intr+0x2e0>
			adf_os_print("VERY LONG PACKET!!!!!\n");
  906d00:	18716e        	l32r	a8, 8e32b8 <bStandardCommand+0x2c>
  906d03:	1a7284        	l32r	a10, 8e3714 <bStandardCommand+0x488>
  906d06:	258212        	l32i	a5, a8, 72
  906d09:	0b5000        	callx8	a5
					adf_os_print("ds_tmp is NULL\n");
					adf_os_assert(0);
				}

				BUF_Pool_free_buf(sc->pool_handle, POOL_ID_WLAN_RX_BUF, ds_rmv->ds_nbuf);
				ds_rmv->ds_nbuf = ADF_NBUF_NULL;
  906d0c:	c0d0      	movi.n	a13, 0
  906d0e:	6001e0        	j	906ef2 <ath_intr+0x2da>
			adf_os_print("VERY LONG PACKET!!!!!\n");
			ds_tail = ds;
			ds_tmp = ds_head;
			while (ds_tmp) {
				struct ath_rx_desc *ds_rmv;
				adf_nbuf_unmap(sc->sc_dev, ds_tmp->ds_dmap, ADF_OS_DMA_FROM_DEVICE);
  906d11:	253038        	l8ui	a5, a3, 56
  906d14:	2b3039        	l8ui	a11, a3, 57
  906d17:	085510        	slli	a5, a5, 24
  906d1a:	00bb11        	slli	a11, a11, 16
  906d1d:	05bb02        	or	a11, a11, a5
  906d20:	25303a        	l8ui	a5, a3, 58
static inline void
adf_nbuf_unmap(adf_os_device_t      osdev, 
               adf_os_dma_map_t     bmap, 
               adf_os_dma_dir_t     dir)
{
    __adf_nbuf_unmap(osdev, bmap, dir);
  906d23:	2a2246        	l32i	a10, a2, 0x118
  906d26:	085511        	slli	a5, a5, 8
  906d29:	0b5502        	or	a5, a5, a11
  906d2c:	2b303b        	l8ui	a11, a3, 59
  906d2f:	c0c1      	movi.n	a12, 1
  906d31:	05bb02        	or	a11, a11, a5
  906d34:	9d18      	s32i.n	a13, a1, 32
  906d36:	5bf1e8        	call8	9034d8 <__adf_nbuf_unmap>
				ds_rmv = ds_tmp;
				ds_tmp = asf_tailq_next(ds_tmp, ds_list);
  906d39:	27304c        	l8ui	a7, a3, 76
  906d3c:	25304d        	l8ui	a5, a3, 77
  906d3f:	087710        	slli	a7, a7, 24
  906d42:	005511        	slli	a5, a5, 16
  906d45:	075702        	or	a7, a5, a7
  906d48:	25304e        	l8ui	a5, a3, 78

				if (ds_tmp == NULL) {
  906d4b:	8d18      	l32i.n	a13, a1, 32
			ds_tmp = ds_head;
			while (ds_tmp) {
				struct ath_rx_desc *ds_rmv;
				adf_nbuf_unmap(sc->sc_dev, ds_tmp->ds_dmap, ADF_OS_DMA_FROM_DEVICE);
				ds_rmv = ds_tmp;
				ds_tmp = asf_tailq_next(ds_tmp, ds_list);
  906d4d:	085511        	slli	a5, a5, 8
  906d50:	075502        	or	a5, a5, a7
  906d53:	27304f        	l8ui	a7, a3, 79
  906d56:	057502        	or	a5, a7, a5
  906d59:	9514      	s32i.n	a5, a1, 16

				if (ds_tmp == NULL) {
  906d5b:	cc5d      	bnez.n	a5, 906d6c <ath_intr+0x154>
					adf_os_print("ds_tmp is NULL\n");
  906d5d:	19716e        	l32r	a9, 8e3318 <bStandardCommand+0x8c>
  906d60:	1a7285        	l32r	a10, 8e3774 <bStandardCommand+0x4e8>
  906d63:	229212        	l32i	a2, a9, 72
  906d66:	0b2000        	callx8	a2
  906d69:	63fffc        	j	906d69 <ath_intr+0x151>
					adf_os_assert(0);
				}

				BUF_Pool_free_buf(sc->pool_handle, POOL_ID_WLAN_RX_BUF, ds_rmv->ds_nbuf);
  906d6c:	253034        	l8ui	a5, a3, 52
  906d6f:	2c3035        	l8ui	a12, a3, 53
  906d72:	085510        	slli	a5, a5, 24
  906d75:	00cc11        	slli	a12, a12, 16
  906d78:	05cc02        	or	a12, a12, a5
  906d7b:	253036        	l8ui	a5, a3, 54
  906d7e:	18716e        	l32r	a8, 8e3338 <bStandardCommand+0xac>
  906d81:	085511        	slli	a5, a5, 8
  906d84:	0c5502        	or	a5, a5, a12
  906d87:	2c3037        	l8ui	a12, a3, 55
  906d8a:	2782a3        	l32i	a7, a8, 0x28c
  906d8d:	8a20      	l32i.n	a10, a2, 0
  906d8f:	05cc02        	or	a12, a12, a5
  906d92:	c0b3      	movi.n	a11, 3
  906d94:	9d18      	s32i.n	a13, a1, 32
  906d96:	0b7000        	callx8	a7
				ds_rmv->ds_nbuf = ADF_NBUF_NULL;
  906d99:	8d18      	l32i.n	a13, a1, 32

				if (ath_rxdesc_init(sc, ds_rmv) == 0) {
  906d9b:	db30      	mov.n	a11, a3
					adf_os_print("ds_tmp is NULL\n");
					adf_os_assert(0);
				}

				BUF_Pool_free_buf(sc->pool_handle, POOL_ID_WLAN_RX_BUF, ds_rmv->ds_nbuf);
				ds_rmv->ds_nbuf = ADF_NBUF_NULL;
  906d9d:	2d3434        	s8i	a13, a3, 52
  906da0:	2d3435        	s8i	a13, a3, 53
  906da3:	2d3436        	s8i	a13, a3, 54
  906da6:	2d3437        	s8i	a13, a3, 55

				if (ath_rxdesc_init(sc, ds_rmv) == 0) {
  906da9:	da20      	mov.n	a10, a2
  906dab:	9d18      	s32i.n	a13, a1, 32
  906dad:	5bfeda        	call8	906918 <ath_rxdesc_init>
  906db0:	2f304c        	l8ui	a15, a3, 76
  906db3:	2c304d        	l8ui	a12, a3, 77
  906db6:	27304e        	l8ui	a7, a3, 78
  906db9:	2b3050        	l8ui	a11, a3, 80
  906dbc:	293051        	l8ui	a9, a3, 81
  906dbf:	253052        	l8ui	a5, a3, 82
					asf_tailq_remove(&sc->sc_rxdesc, ds_rmv, ds_list);
  906dc2:	08ff10        	slli	a15, a15, 24
  906dc5:	00cc11        	slli	a12, a12, 16
  906dc8:	28304f        	l8ui	a8, a3, 79
  906dcb:	0fcf02        	or	a15, a12, a15
  906dce:	087711        	slli	a7, a7, 8
  906dd1:	08bb10        	slli	a11, a11, 24
  906dd4:	009911        	slli	a9, a9, 16
  906dd7:	0f7f02        	or	a15, a7, a15
  906dda:	0b9902        	or	a9, a9, a11
  906ddd:	085511        	slli	a5, a5, 8
  906de0:	2e3053        	l8ui	a14, a3, 83
				}

				BUF_Pool_free_buf(sc->pool_handle, POOL_ID_WLAN_RX_BUF, ds_rmv->ds_nbuf);
				ds_rmv->ds_nbuf = ADF_NBUF_NULL;

				if (ath_rxdesc_init(sc, ds_rmv) == 0) {
  906de3:	8d18      	l32i.n	a13, a1, 32
					asf_tailq_remove(&sc->sc_rxdesc, ds_rmv, ds_list);
  906de5:	0f8f02        	or	a15, a8, a15
  906de8:	095502        	or	a5, a5, a9
				}

				BUF_Pool_free_buf(sc->pool_handle, POOL_ID_WLAN_RX_BUF, ds_rmv->ds_nbuf);
				ds_rmv->ds_nbuf = ADF_NBUF_NULL;

				if (ath_rxdesc_init(sc, ds_rmv) == 0) {
  906deb:	65a06f        	bnez	a10, 906e5e <ath_intr+0x246>
					asf_tailq_remove(&sc->sc_rxdesc, ds_rmv, ds_list);
  906dee:	05ee02        	or	a14, a14, a5
  906df1:	c9f7      	beqz.n	a15, 906e0c <ath_intr+0x1f4>
  906df3:	0e8557        	extui	a5, a14, 24, 8
  906df6:	25f450        	s8i	a5, a15, 80
  906df9:	0e0557        	extui	a5, a14, 16, 8
  906dfc:	25f451        	s8i	a5, a15, 81
  906dff:	0e8547        	extui	a5, a14, 8, 8
  906e02:	25f452        	s8i	a5, a15, 82
  906e05:	2ef453        	s8i	a14, a15, 83
  906e08:	600003        	j	906e0f <ath_intr+0x1f7>
  906e0b:	002e26        	excw
  906e0e:	da27      	excw
  906e10:	305025        	excw
  906e13:	305108        	excw
  906e16:	771000        	bnone	a1, a7, 906e1a <ath_intr+0x202>
  906e19:	551107        	call4	94b238 <_etext+0x401e5>
  906e1c:	570225        	call4	8c76b4 <_bss_end+0x3b9eac>
  906e1f:	305208        	excw
  906e22:	551107        	call4	94b240 <_etext+0x401ed>
  906e25:	550227        	call4	9476c4 <_etext+0x3c671>
  906e28:	305305        	excw
  906e2b:	75029f        	blt	a0, a5, 906dce <ath_intr+0x1b6>
  906e2e:	502522        	call0	9102b8 <_etext+0x5265>
					asf_tailq_insert_tail(&sc->sc_rxdesc, ds_rmv, ds_list);
  906e31:	da2d      	excw
  906e33:	344c05        	excw
  906e36:	8757      	l32i.n	a7, a5, 28
  906e38:	273450        	s8i	a7, a3, 80
  906e3b:	050757        	extui	a7, a5, 16, 8
  906e3e:	273451        	s8i	a7, a3, 81
  906e41:	058747        	extui	a7, a5, 8, 8
  906e44:	253453        	s8i	a5, a3, 83
  906e47:	2d344d        	s8i	a13, a3, 77
  906e4a:	2d344e        	s8i	a13, a3, 78
  906e4d:	2d344f        	s8i	a13, a3, 79
  906e50:	273452        	s8i	a7, a3, 82
  906e53:	9350      	s32i.n	a3, a5, 0
  906e55:	253c4c        	addi	a5, a3, 76
  906e58:	2526da        	s32i	a5, a2, 0x368
  906e5b:	60006f        	j	906ece <ath_intr+0x2b6>
				}
				else {
					asf_tailq_remove(&sc->sc_rxdesc, ds_rmv, ds_list);
  906e5e:	c9fa      	beqz.n	a15, 906e7c <ath_intr+0x264>
  906e60:	05ee02        	or	a14, a14, a5
  906e63:	0e8557        	extui	a5, a14, 24, 8
  906e66:	25f450        	s8i	a5, a15, 80
  906e69:	0e0557        	extui	a5, a14, 16, 8
  906e6c:	25f451        	s8i	a5, a15, 81
  906e6f:	0e8547        	extui	a5, a14, 8, 8
  906e72:	25f452        	s8i	a5, a15, 82
  906e75:	2ef453        	s8i	a14, a15, 83
  906e78:	600006        	j	906e82 <ath_intr+0x26a>
  906e7b:	0005e5        	excw
  906e7e:	022526        	excw
  906e81:	da27      	excw
  906e83:	305025        	excw
  906e86:	305108        	excw
  906e89:	771000        	bnone	a1, a7, 906e8d <ath_intr+0x275>
  906e8c:	551107        	call4	94b2ac <_etext+0x40259>
  906e8f:	570225        	call4	8c7724 <_bss_end+0x3b9f1c>
  906e92:	305208        	excw
  906e95:	551107        	call4	94b2b4 <_etext+0x40261>
  906e98:	550227        	call4	947738 <_etext+0x3c6e5>
  906e9b:	305305        	excw
  906e9e:	75029f        	blt	a0, a5, 906e41 <ath_intr+0x229>
  906ea1:	502522        	call0	91032c <_etext+0x52d9>
					asf_tailq_insert_tail(&sc->sc_rxdesc_idle, ds_rmv, ds_list);
  906ea4:	d82d      	excw
  906ea6:	344c05        	excw
  906ea9:	8757      	l32i.n	a7, a5, 28
  906eab:	273450        	s8i	a7, a3, 80
  906eae:	050757        	extui	a7, a5, 16, 8
  906eb1:	273451        	s8i	a7, a3, 81
  906eb4:	058747        	extui	a7, a5, 8, 8
  906eb7:	253453        	s8i	a5, a3, 83
  906eba:	2d344d        	s8i	a13, a3, 77
  906ebd:	2d344e        	s8i	a13, a3, 78
  906ec0:	2d344f        	s8i	a13, a3, 79
  906ec3:	273452        	s8i	a7, a3, 82
  906ec6:	9350      	s32i.n	a3, a5, 0
  906ec8:	253c4c        	addi	a5, a3, 76
  906ecb:	2526d8        	s32i	a5, a2, 0x360
				}

				if (ds_rmv == ds_tail) {
  906ece:	76391e        	bne	a3, a6, 906ef0 <ath_intr+0x2d8>
			if (status & HAL_INT_RX)
				sc->sc_int_stats.ast_rx++;

			ath_uapsd_processtriggers(sc);

			sc->sc_imask &= ~HAL_INT_RX;
  906ed1:	2322c4        	l32i	a3, a2, 0x310
  906ed4:	c7be      	movi.n	a11, -2
  906ed6:	03bb01        	and	a11, a11, a3
			ah->ah_setInterrupts(ah, sc->sc_imask);
  906ed9:	234228        	l32i	a3, a4, 160
			if (status & HAL_INT_RX)
				sc->sc_int_stats.ast_rx++;

			ath_uapsd_processtriggers(sc);

			sc->sc_imask &= ~HAL_INT_RX;
  906edc:	2b26c4        	s32i	a11, a2, 0x310
			ah->ah_setInterrupts(ah, sc->sc_imask);
  906edf:	da40      	mov.n	a10, a4
  906ee1:	0b3000        	callx8	a3
  906ee4:	2a3a14        	movi	a10, 0x314
  906ee7:	aa2a      	add.n	a10, a2, a10
  906ee9:	5bfdaf        	call8	9065a8 <__adf_os_sched_bh$isra$6>
  906eec:	600312        	j	907202 <ath_intr+0x5ea>
  906eef:	008314        	srli	a3, a0, 8

		if (cnt == ath_numrxbufs - 1) {
			adf_os_print("VERY LONG PACKET!!!!!\n");
			ds_tail = ds;
			ds_tmp = ds_head;
			while (ds_tmp) {
  906ef2:	653e1b        	bnez	a3, 906d11 <ath_intr+0xf9>
  906ef5:	63ffd8        	j	906ed1 <ath_intr+0x2b9>
				}
			}
			break;
		}

		if (ds->ds_link == 0) {
  906ef8:	2d6000        	l8ui	a13, a6, 0
  906efb:	2b6001        	l8ui	a11, a6, 1
  906efe:	08dd10        	slli	a13, a13, 24
  906f01:	00bb11        	slli	a11, a11, 16
  906f04:	0dbb02        	or	a11, a11, a13
  906f07:	2d6002        	l8ui	a13, a6, 2
  906f0a:	08dd11        	slli	a13, a13, 8
  906f0d:	0bdd02        	or	a13, a13, a11
  906f10:	2b6003        	l8ui	a11, a6, 3
  906f13:	0dbb02        	or	a11, a11, a13
  906f16:	64bfb7        	beqz	a11, 906ed1 <ath_intr+0x2b9>
			break;
		}

		if (bf->bf_status & ATH_BUFSTATUS_DONE) {
  906f19:	8a5f      	l32i.n	a10, a5, 60
  906f1b:	7fa702        	bbci	a10, 31, 906f21 <ath_intr+0x309>
  906f1e:	6002d8        	j	9071fa <ath_intr+0x5e2>
			continue;
		}

		retval = ah->ah_procRxDescFast(ah, ds, ds->ds_daddr,
						PA2DESC(sc, ds->ds_link), &bf->bf_rx_status);
  906f21:	2a22de        	l32i	a10, a2, 0x378
  906f24:	2d22e0        	l32i	a13, a2, 0x380

		if (bf->bf_status & ATH_BUFSTATUS_DONE) {
			continue;
		}

		retval = ah->ah_procRxDescFast(ah, ds, ds->ds_daddr,
  906f27:	2c6049        	l8ui	a12, a6, 73
						PA2DESC(sc, ds->ds_link), &bf->bf_rx_status);
  906f2a:	0dad0c        	sub	a13, a10, a13

		if (bf->bf_status & ATH_BUFSTATUS_DONE) {
			continue;
		}

		retval = ah->ah_procRxDescFast(ah, ds, ds->ds_daddr,
  906f2d:	2a6048        	l8ui	a10, a6, 72
  906f30:	00cc11        	slli	a12, a12, 16
  906f33:	08aa10        	slli	a10, a10, 24
  906f36:	0acc02        	or	a12, a12, a10
  906f39:	2a604a        	l8ui	a10, a6, 74
  906f3c:	8915      	l32i.n	a9, a1, 20
  906f3e:	08aa11        	slli	a10, a10, 8
  906f41:	0caa02        	or	a10, a10, a12
  906f44:	2c604b        	l8ui	a12, a6, 75
  906f47:	2f9222        	l32i	a15, a9, 136
  906f4a:	abdd      	add.n	a13, a13, a11
  906f4c:	0acc02        	or	a12, a12, a10
  906f4f:	db60      	mov.n	a11, a6
  906f51:	2e5c40        	addi	a14, a5, 64
  906f54:	da90      	mov.n	a10, a9
  906f56:	0bf000        	callx8	a15
						PA2DESC(sc, ds->ds_link), &bf->bf_rx_status);
		if (HAL_EINPROGRESS == retval) {
  906f59:	c0bf      	movi.n	a11, 15
  906f5b:	7ba902        	bne	a10, a11, 906f61 <ath_intr+0x349>
  906f5e:	63ff6f        	j	906ed1 <ath_intr+0x2b9>
			break;
		}

		if (adf_nbuf_len(ds->ds_nbuf) == 0) {
  906f61:	2b6034        	l8ui	a11, a6, 52
  906f64:	2a6035        	l8ui	a10, a6, 53
  906f67:	08bb10        	slli	a11, a11, 24
  906f6a:	00aa11        	slli	a10, a10, 16
  906f6d:	0bab02        	or	a11, a10, a11
  906f70:	2a6036        	l8ui	a10, a6, 54
  906f73:	08aa11        	slli	a10, a10, 8
  906f76:	0baa02        	or	a10, a10, a11
  906f79:	2b6037        	l8ui	a11, a6, 55
 * @return The total length of this buf.
 */
static inline adf_os_size_t
adf_nbuf_len(adf_nbuf_t buf)
{
    return (__adf_nbuf_len(buf));
  906f7c:	0aba02        	or	a10, a11, a10
  906f7f:	5bf1b9        	call8	903664 <__adf_nbuf_len>
  906f82:	cea2      	bnez.n	a10, 906fa8 <ath_intr+0x390>
			adf_nbuf_put_tail(ds->ds_nbuf, bf->bf_rx_status.rs_datalen);
  906f84:	2b6034        	l8ui	a11, a6, 52
  906f87:	2a6035        	l8ui	a10, a6, 53
  906f8a:	08bb10        	slli	a11, a11, 24
  906f8d:	00aa11        	slli	a10, a10, 16
  906f90:	0bab02        	or	a11, a10, a11
  906f93:	2a6036        	l8ui	a10, a6, 54
  906f96:	2c6037        	l8ui	a12, a6, 55
  906f99:	08aa11        	slli	a10, a10, 8
  906f9c:	0baa02        	or	a10, a10, a11
 *         put, or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_put_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_put_tail(buf, size);
  906f9f:	2b5124        	l16ui	a11, a5, 72
  906fa2:	0aca02        	or	a10, a12, a10
  906fa5:	5bf192        	call8	9035f0 <__adf_nbuf_put_tail>
		}

		frame_len += bf->bf_rx_status.rs_datalen;
  906fa8:	8914      	l32i.n	a9, a1, 16
  906faa:	2a5124        	l16ui	a10, a5, 72

		if (bf->bf_rx_status.rs_more == 0) {
  906fad:	2d5056        	l8ui	a13, a5, 86

		if (adf_nbuf_len(ds->ds_nbuf) == 0) {
			adf_nbuf_put_tail(ds->ds_nbuf, bf->bf_rx_status.rs_datalen);
		}

		frame_len += bf->bf_rx_status.rs_datalen;
  906fb0:	aa98      	add.n	a8, a9, a10
  906fb2:	08084f        	extui	a8, a8, 0, 16
  906fb5:	9814      	s32i.n	a8, a1, 16

		if (bf->bf_rx_status.rs_more == 0) {
  906fb7:	65d221        	bnez	a13, 9071dc <ath_intr+0x5c4>
 * @param[in] head  buf queue head
 */
static inline void
adf_nbuf_queue_init(adf_nbuf_queue_t *head)
{
    __adf_nbuf_queue_init(head);
  906fba:	da10      	mov.n	a10, a1
  906fbc:	9d18      	s32i.n	a13, a1, 32
  906fbe:	5bf1b7        	call8	90369c <__adf_nbuf_queue_init>
			adf_nbuf_queue_init(&nbuf_head);

			cnt = 0;

			ds_tail = ds;
			ds = asf_tailq_next(ds, ds_list);
  906fc1:	2a604c        	l8ui	a10, a6, 76
  906fc4:	27604d        	l8ui	a7, a6, 77
  906fc7:	08aa10        	slli	a10, a10, 24
  906fca:	007711        	slli	a7, a7, 16
  906fcd:	0a7a02        	or	a10, a7, a10
  906fd0:	27604e        	l8ui	a7, a6, 78
			while (ds_tmp) {
				struct ath_rx_desc *ds_rmv;

				adf_nbuf_unmap(sc->sc_dev, ds_tmp->ds_dmap, ADF_OS_DMA_FROM_DEVICE);
				adf_nbuf_queue_add(&nbuf_head, ds_tmp->ds_nbuf);
				ds_tmp->ds_nbuf = ADF_NBUF_NULL;
  906fd3:	8d18      	l32i.n	a13, a1, 32
			adf_nbuf_queue_init(&nbuf_head);

			cnt = 0;

			ds_tail = ds;
			ds = asf_tailq_next(ds, ds_list);
  906fd5:	087711        	slli	a7, a7, 8
  906fd8:	0a7702        	or	a7, a7, a10
  906fdb:	2a604f        	l8ui	a10, a6, 79
  906fde:	07aa02        	or	a10, a10, a7
  906fe1:	9a16      	s32i.n	a10, a1, 24
  906fe3:	6001ef        	j	9071d6 <ath_intr+0x5be>
			ds_head = asf_tailq_next(ds_tail, ds_list);

			while (ds_tmp) {
				struct ath_rx_desc *ds_rmv;

				adf_nbuf_unmap(sc->sc_dev, ds_tmp->ds_dmap, ADF_OS_DMA_FROM_DEVICE);
  906fe6:	273038        	l8ui	a7, a3, 56
  906fe9:	2b3039        	l8ui	a11, a3, 57
  906fec:	087710        	slli	a7, a7, 24
  906fef:	00bb11        	slli	a11, a11, 16
  906ff2:	07bb02        	or	a11, a11, a7
  906ff5:	27303a        	l8ui	a7, a3, 58
static inline void
adf_nbuf_unmap(adf_os_device_t      osdev, 
               adf_os_dma_map_t     bmap, 
               adf_os_dma_dir_t     dir)
{
    __adf_nbuf_unmap(osdev, bmap, dir);
  906ff8:	2a2246        	l32i	a10, a2, 0x118
  906ffb:	087711        	slli	a7, a7, 8
  906ffe:	0b7702        	or	a7, a7, a11
  907001:	2b303b        	l8ui	a11, a3, 59
  907004:	2c0a01        	movi	a12, 1
  907007:	07bb02        	or	a11, a11, a7
  90700a:	2d1608        	s32i	a13, a1, 32
  90700d:	5bf132        	call8	9034d8 <__adf_nbuf_unmap>
				adf_nbuf_queue_add(&nbuf_head, ds_tmp->ds_nbuf);
  907010:	2b3035        	l8ui	a11, a3, 53
  907013:	273034        	l8ui	a7, a3, 52
  907016:	00bb11        	slli	a11, a11, 16
  907019:	087710        	slli	a7, a7, 24
  90701c:	07bb02        	or	a11, a11, a7
  90701f:	273036        	l8ui	a7, a3, 54
 * @param[in] buf   buf
 */
static inline void
adf_nbuf_queue_add(adf_nbuf_queue_t *head, adf_nbuf_t buf)
{
    __adf_nbuf_queue_add(head, buf);
  907022:	011a02        	or	a10, a1, a1
  907025:	087711        	slli	a7, a7, 8
  907028:	0b7702        	or	a7, a7, a11
  90702b:	2b3037        	l8ui	a11, a3, 55
  90702e:	07bb02        	or	a11, a11, a7
  907031:	5bf10d        	call8	903468 <__adf_nbuf_queue_add>
				ds_tmp->ds_nbuf = ADF_NBUF_NULL;

				ds_rmv = ds_tmp;
				ds_tmp = asf_tailq_next(ds_tmp, ds_list);
  907034:	2a304c        	l8ui	a10, a3, 76
  907037:	27304d        	l8ui	a7, a3, 77
  90703a:	08aa10        	slli	a10, a10, 24
  90703d:	007711        	slli	a7, a7, 16
  907040:	0a7a02        	or	a10, a7, a10
  907043:	27304e        	l8ui	a7, a3, 78
			while (ds_tmp) {
				struct ath_rx_desc *ds_rmv;

				adf_nbuf_unmap(sc->sc_dev, ds_tmp->ds_dmap, ADF_OS_DMA_FROM_DEVICE);
				adf_nbuf_queue_add(&nbuf_head, ds_tmp->ds_nbuf);
				ds_tmp->ds_nbuf = ADF_NBUF_NULL;
  907046:	8d18      	l32i.n	a13, a1, 32

				ds_rmv = ds_tmp;
				ds_tmp = asf_tailq_next(ds_tmp, ds_list);
  907048:	087711        	slli	a7, a7, 8
  90704b:	0a7702        	or	a7, a7, a10
  90704e:	2a304f        	l8ui	a10, a3, 79
			while (ds_tmp) {
				struct ath_rx_desc *ds_rmv;

				adf_nbuf_unmap(sc->sc_dev, ds_tmp->ds_dmap, ADF_OS_DMA_FROM_DEVICE);
				adf_nbuf_queue_add(&nbuf_head, ds_tmp->ds_nbuf);
				ds_tmp->ds_nbuf = ADF_NBUF_NULL;
  907051:	2d3434        	s8i	a13, a3, 52
  907054:	2d3435        	s8i	a13, a3, 53
  907057:	2d3436        	s8i	a13, a3, 54
  90705a:	2d3437        	s8i	a13, a3, 55

				ds_rmv = ds_tmp;
				ds_tmp = asf_tailq_next(ds_tmp, ds_list);
  90705d:	07a802        	or	a8, a10, a7
				if (ds_tmp == NULL) {
  907060:	cc81      	bnez.n	a8, 907065 <ath_intr+0x44d>
  907062:	63fffc        	j	907062 <ath_intr+0x44a>
					adf_os_assert(0);
				}

				if (ath_rxdesc_init(sc, ds_rmv) == 0) {
  907065:	db30      	mov.n	a11, a3
  907067:	da20      	mov.n	a10, a2
  907069:	9817      	s32i.n	a8, a1, 28
  90706b:	9d18      	s32i.n	a13, a1, 32
  90706d:	5bfe2a        	call8	906918 <ath_rxdesc_init>
  907070:	2f304c        	l8ui	a15, a3, 76
  907073:	2e304d        	l8ui	a14, a3, 77
  907076:	27304e        	l8ui	a7, a3, 78
					asf_tailq_remove(&sc->sc_rxdesc, ds_rmv, ds_list);
  907079:	00ee11        	slli	a14, a14, 16
  90707c:	08ff10        	slli	a15, a15, 24
  90707f:	0fef02        	or	a15, a14, a15
  907082:	2c3050        	l8ui	a12, a3, 80
  907085:	2b3051        	l8ui	a11, a3, 81
  907088:	087711        	slli	a7, a7, 8
  90708b:	2e304f        	l8ui	a14, a3, 79
  90708e:	0f7f02        	or	a15, a7, a15
				ds_tmp = asf_tailq_next(ds_tmp, ds_list);
				if (ds_tmp == NULL) {
					adf_os_assert(0);
				}

				if (ath_rxdesc_init(sc, ds_rmv) == 0) {
  907091:	8817      	l32i.n	a8, a1, 28
  907093:	8d18      	l32i.n	a13, a1, 32
					asf_tailq_remove(&sc->sc_rxdesc, ds_rmv, ds_list);
  907095:	0fef02        	or	a15, a14, a15
  907098:	08cc10        	slli	a12, a12, 24
  90709b:	00bb11        	slli	a11, a11, 16
				ds_tmp = asf_tailq_next(ds_tmp, ds_list);
				if (ds_tmp == NULL) {
					adf_os_assert(0);
				}

				if (ath_rxdesc_init(sc, ds_rmv) == 0) {
  90709e:	65a07e        	bnez	a10, 907120 <ath_intr+0x508>
					asf_tailq_remove(&sc->sc_rxdesc, ds_rmv, ds_list);
  9070a1:	0cbc02        	or	a12, a11, a12
  9070a4:	2b3052        	l8ui	a11, a3, 82
  9070a7:	08bb11        	slli	a11, a11, 8
  9070aa:	0cbb02        	or	a11, a11, a12
  9070ad:	2c3053        	l8ui	a12, a3, 83
  9070b0:	0bcb02        	or	a11, a12, a11
  9070b3:	c9f6      	beqz.n	a15, 9070cd <ath_intr+0x4b5>
  9070b5:	0b8757        	extui	a7, a11, 24, 8
  9070b8:	27f450        	s8i	a7, a15, 80
  9070bb:	0b0757        	extui	a7, a11, 16, 8
  9070be:	27f451        	s8i	a7, a15, 81
  9070c1:	0b8747        	extui	a7, a11, 8, 8
  9070c4:	27f452        	s8i	a7, a15, 82
  9070c7:	2bf453        	s8i	a11, a15, 83
  9070ca:	600002        	j	9070d0 <ath_intr+0x4b8>
  9070cd:	2b26da        	s32i	a11, a2, 0x368
  9070d0:	2a3050        	l8ui	a10, a3, 80
  9070d3:	273051        	l8ui	a7, a3, 81
  9070d6:	08ab10        	slli	a11, a10, 24
  9070d9:	007711        	slli	a7, a7, 16
  9070dc:	0b7a02        	or	a10, a7, a11
  9070df:	273052        	l8ui	a7, a3, 82
  9070e2:	087711        	slli	a7, a7, 8
  9070e5:	0a7702        	or	a7, a7, a10
  9070e8:	2a3053        	l8ui	a10, a3, 83
  9070eb:	07a702        	or	a7, a10, a7
  9070ee:	9f70      	s32i.n	a15, a7, 0
					asf_tailq_insert_tail(&sc->sc_rxdesc, ds_rmv, ds_list);
  9070f0:	2722da        	l32i	a7, a2, 0x368
  9070f3:	2d344c        	s8i	a13, a3, 76
  9070f6:	078a57        	extui	a10, a7, 24, 8
  9070f9:	2a3450        	s8i	a10, a3, 80
  9070fc:	070a57        	extui	a10, a7, 16, 8
  9070ff:	2a3451        	s8i	a10, a3, 81
  907102:	078a47        	extui	a10, a7, 8, 8
  907105:	273453        	s8i	a7, a3, 83
  907108:	2d344d        	s8i	a13, a3, 77
  90710b:	2d344e        	s8i	a13, a3, 78
  90710e:	2d344f        	s8i	a13, a3, 79
  907111:	2a3452        	s8i	a10, a3, 82
  907114:	9370      	s32i.n	a3, a7, 0
  907116:	273c4c        	addi	a7, a3, 76
  907119:	2726da        	s32i	a7, a2, 0x368
  90711c:	60008d        	j	9071ad <ath_intr+0x595>
  90711f:	00caf8        	excw
				}  else {
					asf_tailq_remove(&sc->sc_rxdesc, ds_rmv, ds_list);
  907122:	0cbc02        	or	a12, a11, a12
  907125:	2b3052        	l8ui	a11, a3, 82
  907128:	08bb11        	slli	a11, a11, 8
  90712b:	0cbb02        	or	a11, a11, a12
  90712e:	2c3053        	l8ui	a12, a3, 83
  907131:	0bcb02        	or	a11, a12, a11
  907134:	0b8757        	extui	a7, a11, 24, 8
  907137:	27f450        	s8i	a7, a15, 80
  90713a:	0b0757        	extui	a7, a11, 16, 8
  90713d:	27f451        	s8i	a7, a15, 81
  907140:	0b8747        	extui	a7, a11, 8, 8
  907143:	27f452        	s8i	a7, a15, 82
  907146:	2bf453        	s8i	a11, a15, 83
  907149:	600014        	j	907161 <ath_intr+0x549>
  90714c:	0cbb02        	or	a11, a11, a12
  90714f:	2c3052        	l8ui	a12, a3, 82
  907152:	08cc11        	slli	a12, a12, 8
  907155:	0bcb02        	or	a11, a12, a11
  907158:	2c3053        	l8ui	a12, a3, 83
  90715b:	0bcb02        	or	a11, a12, a11
  90715e:	2b26da        	s32i	a11, a2, 0x368
  907161:	2a3050        	l8ui	a10, a3, 80
  907164:	273051        	l8ui	a7, a3, 81
  907167:	08ab10        	slli	a11, a10, 24
  90716a:	007711        	slli	a7, a7, 16
  90716d:	0b7a02        	or	a10, a7, a11
  907170:	273052        	l8ui	a7, a3, 82
  907173:	087711        	slli	a7, a7, 8
  907176:	0a7702        	or	a7, a7, a10
  907179:	2a3053        	l8ui	a10, a3, 83
  90717c:	07a702        	or	a7, a10, a7
  90717f:	9f70      	s32i.n	a15, a7, 0
					asf_tailq_insert_tail(&sc->sc_rxdesc_idle, ds_rmv, ds_list);
  907181:	2722d8        	l32i	a7, a2, 0x360
  907184:	2d344c        	s8i	a13, a3, 76
  907187:	078a57        	extui	a10, a7, 24, 8
  90718a:	2a3450        	s8i	a10, a3, 80
  90718d:	070a57        	extui	a10, a7, 16, 8
  907190:	2a3451        	s8i	a10, a3, 81
  907193:	078a47        	extui	a10, a7, 8, 8
  907196:	273453        	s8i	a7, a3, 83
  907199:	2d344d        	s8i	a13, a3, 77
  90719c:	2d344e        	s8i	a13, a3, 78
  90719f:	2d344f        	s8i	a13, a3, 79
  9071a2:	2a3452        	s8i	a10, a3, 82
  9071a5:	9370      	s32i.n	a3, a7, 0
  9071a7:	273c4c        	addi	a7, a3, 76
  9071aa:	2726d8        	s32i	a7, a2, 0x360
				}

				if (ds_rmv == ds_tail) {
  9071ad:	736923        	bne	a6, a3, 9071d4 <ath_intr+0x5bc>
					break;
				}
			}


			bf->bf_rx_status.rs_datalen = frame_len;
  9071b0:	8314      	l32i.n	a3, a1, 16
}

static inline adf_nbuf_t
adf_nbuf_create_frm_frag(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_create_frm_frag(head);
  9071b2:	da10      	mov.n	a10, a1
  9071b4:	235524        	s16i	a3, a5, 72
  9071b7:	5bf0dc        	call8	903528 <__adf_nbuf_create_frm_frag>
			frame_len = 0;

			bf->bf_skb = adf_nbuf_create_frm_frag(&nbuf_head);

			bf->bf_status |= ATH_BUFSTATUS_DONE;
  9071ba:	865f      	l32i.n	a6, a5, 60
  9071bc:	c031      	movi.n	a3, 1
  9071be:	036302        	or	a3, a6, a3
  9071c1:	935f      	s32i.n	a3, a5, 60


			bf->bf_rx_status.rs_datalen = frame_len;
			frame_len = 0;

			bf->bf_skb = adf_nbuf_create_frm_frag(&nbuf_head);
  9071c3:	9a58      	s32i.n	a10, a5, 32

			ds_tail = ds;
			ds = asf_tailq_next(ds, ds_list);

			ds_tmp = ds_head;
			ds_head = asf_tailq_next(ds_tail, ds_list);
  9071c5:	8316      	l32i.n	a3, a1, 24

			bf->bf_skb = adf_nbuf_create_frm_frag(&nbuf_head);

			bf->bf_status |= ATH_BUFSTATUS_DONE;

			bf = (struct ath_rx_buf *)asf_tailq_next(bf, bf_list);
  9071c7:	8559      	l32i.n	a5, a5, 36
				}
			}


			bf->bf_rx_status.rs_datalen = frame_len;
			frame_len = 0;
  9071c9:	c080      	movi.n	a8, 0
			adf_nbuf_queue_init(&nbuf_head);

			cnt = 0;

			ds_tail = ds;
			ds = asf_tailq_next(ds, ds_list);
  9071cb:	d630      	mov.n	a6, a3
				}
			}


			bf->bf_rx_status.rs_datalen = frame_len;
			frame_len = 0;
  9071cd:	9814      	s32i.n	a8, a1, 16

		if (bf->bf_rx_status.rs_more == 0) {
			adf_nbuf_queue_t nbuf_head;
			adf_nbuf_queue_init(&nbuf_head);

			cnt = 0;
  9071cf:	d780      	mov.n	a7, a8
  9071d1:	600025        	j	9071fa <ath_intr+0x5e2>
				}  else {
					asf_tailq_remove(&sc->sc_rxdesc, ds_rmv, ds_list);
					asf_tailq_insert_tail(&sc->sc_rxdesc_idle, ds_rmv, ds_list);
				}

				if (ds_rmv == ds_tail) {
  9071d4:	d380      	mov.n	a3, a8
			ds = asf_tailq_next(ds, ds_list);

			ds_tmp = ds_head;
			ds_head = asf_tailq_next(ds_tail, ds_list);

			while (ds_tmp) {
  9071d6:	653e0c        	bnez	a3, 906fe6 <ath_intr+0x3ce>
  9071d9:	63ffd3        	j	9071b0 <ath_intr+0x598>
			bf->bf_status |= ATH_BUFSTATUS_DONE;

			bf = (struct ath_rx_buf *)asf_tailq_next(bf, bf_list);
		}
		else {
			ds = asf_tailq_next(ds, ds_list);
  9071dc:	2b604c        	l8ui	a11, a6, 76
  9071df:	2a604d        	l8ui	a10, a6, 77
  9071e2:	08bb10        	slli	a11, a11, 24
  9071e5:	00aa11        	slli	a10, a10, 16
  9071e8:	0bab02        	or	a11, a10, a11
  9071eb:	2a604e        	l8ui	a10, a6, 78
  9071ee:	28604f        	l8ui	a8, a6, 79
  9071f1:	08aa11        	slli	a10, a10, 8
  9071f4:	0baa02        	or	a10, a10, a11
  9071f7:	0a8602        	or	a6, a8, a10
	bf = asf_tailq_first(&sc->sc_rxbuf);

	ds = asf_tailq_first(&sc->sc_rxdesc);
	ds_head = ds;

	while(ds) {
  9071fa:	656af3        	bnez	a6, 906cf1 <ath_intr+0xd9>
  9071fd:	63fcd0        	j	906ed1 <ath_intr+0x2b9>
  907200:	000083        	excw
			ah->ah_setInterrupts(ah, sc->sc_imask);

			ATH_SCHEDULE_TQUEUE(sc->sc_dev, &sc->sc_rxtq);
		}

		if (status & HAL_INT_TXURN) {
  907203:	137437        	l32r	a3, 8e42e0 <vdesc_module_install+0x1a4>
  907206:	102322        	l32r	a0, 8cfe90 <_bss_end+0x3c2688>
			sc->sc_int_stats.ast_txurn++;
  907209:	4fc0b1        	excw
  90720c:	b133      	addi.n	a3, a3, 1
  90720e:	23264f        	s32i	a3, a2, 0x13c
			ah->ah_updateTxTrigLevel(ah, AH_TRUE);
  907211:	8347      	l32i.n	a3, a4, 28
  907213:	da40      	mov.n	a10, a4
  907215:	0b3000        	callx8	a3
  907218:	2a5a1c        	movi	a10, 0x51c
  90721b:	aa2a      	add.n	a10, a2, a10
  90721d:	5bfce2        	call8	9065a8 <__adf_os_sched_bh$isra$6>
		}

		ATH_SCHEDULE_TQUEUE(sc->sc_dev, &sc->sc_txtq);

		if (status & HAL_INT_BMISS) {
  907220:	8313      	l32i.n	a3, a1, 12
  907222:	7d3607        	bbci	a3, 13, 90722d <ath_intr+0x615>
  907225:	2a3a24        	movi	a10, 0x324
  907228:	aa2a      	add.n	a10, a2, a10
  90722a:	5bfcdf        	call8	9065a8 <__adf_os_sched_bh$isra$6>
			ATH_SCHEDULE_TQUEUE(sc->sc_dev, &sc->sc_bmisstq);
		}

		if (status & HAL_INT_GTT)
  90722d:	8413      	l32i.n	a4, a1, 12
  90722f:	724607        	bbci	a4, 2, 90723a <ath_intr+0x622>
			sc->sc_int_stats.ast_txto++;
  907232:	232250        	l32i	a3, a2, 0x140
  907235:	b133      	addi.n	a3, a3, 1
  907237:	232650        	s32i	a3, a2, 0x140

		if (status & HAL_INT_CST)
			sc->sc_int_stats.ast_cst++;
	}

	return ADF_OS_IRQ_HANDLED;
  90723a:	c031      	movi.n	a3, 1
		}

		if (status & HAL_INT_GTT)
			sc->sc_int_stats.ast_txto++;

		if (status & HAL_INT_CST)
  90723c:	764608        	bbci	a4, 6, 907248 <ath_intr+0x630>
			sc->sc_int_stats.ast_cst++;
  90723f:	242251        	l32i	a4, a2, 0x144
  907242:	034408        	add	a4, a4, a3
  907245:	242651        	s32i	a4, a2, 0x144
	}

	return ADF_OS_IRQ_HANDLED;
}
  907248:	d230      	mov.n	a2, a3
  90724a:	d10f      	retw.n

0090724c <ath_fatal_tasklet>:

static void ath_fatal_tasklet(TQUEUE_ARG data )
{
  90724c:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)data;

	wmi_event(sc->tgt_wmi_handle, WMI_FATAL_EVENTID, NULL, 0);
  90724f:	c0d0      	movi.n	a13, 0
  907251:	1b7286        	l32r	a11, 8e3c6c <mUsbEPMap+0x4>
  907254:	8a23      	l32i.n	a10, a2, 12
  907256:	0ddc02        	or	a12, a13, a13
  907259:	5bfe58        	call8	906bbc <wmi_event>
  90725c:	d10f      	retw.n
	...

00907260 <ath_bmiss_tasklet>:
}

static void ath_bmiss_tasklet(TQUEUE_ARG data)
{
  907260:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)data;

	wmi_event(sc->tgt_wmi_handle, WMI_BMISS_EVENTID, NULL, 0);
  907263:	c0d0      	movi.n	a13, 0
  907265:	1b7287        	l32r	a11, 8e3c84 <mUsbFIFOMap>
  907268:	8a23      	l32i.n	a10, a2, 12
  90726a:	0ddc02        	or	a12, a13, a13
  90726d:	5bfe53        	call8	906bbc <wmi_event>
  907270:	d10f      	retw.n
	...

00907274 <wmi_cmd_rsp>:
	WMI_SendEvent(handle, netbuf, evt_id, 0, Length);
}

void wmi_cmd_rsp(void *pContext, WMI_COMMAND_ID cmd_id, A_UINT16 SeqNo,
		 void *buffer, a_int32_t Length)
{
  907274:	6c1006        	entry	a1, 48
	adf_nbuf_t netbuf = ADF_NBUF_NULL;
	A_UINT8 *pData;

	netbuf = WMI_AllocEvent(pContext, WMI_EVT_CLASS_CMD_REPLY,
  907277:	17716e        	l32r	a7, 8e3830 <bStandardCommand+0x5a4>
  90727a:	b46c      	addi.n	a12, a6, 4
  90727c:	287292        	l32i	a8, a7, 0x248
  90727f:	2b0a01        	movi	a11, 1
  907282:	022a02        	or	a10, a2, a2
  907285:	0b8000        	callx8	a8
	WMI_SendEvent(handle, netbuf, evt_id, 0, Length);
}

void wmi_cmd_rsp(void *pContext, WMI_COMMAND_ID cmd_id, A_UINT16 SeqNo,
		 void *buffer, a_int32_t Length)
{
  907288:	04044f        	extui	a4, a4, 0, 16
	adf_nbuf_t netbuf = ADF_NBUF_NULL;
	A_UINT8 *pData;

	netbuf = WMI_AllocEvent(pContext, WMI_EVT_CLASS_CMD_REPLY,
  90728b:	d8a0      	mov.n	a8, a10
				sizeof(WMI_CMD_HDR) + Length);

	if (netbuf == ADF_NBUF_NULL) {
  90728d:	cca1      	bnez.n	a10, 907292 <wmi_cmd_rsp+0x1e>
  90728f:	63fffc        	j	90728f <wmi_cmd_rsp+0x1b>
		adf_os_assert(0);
		return;
	}

	if (Length != 0 && buffer != NULL) {
  907292:	c962      	beqz.n	a6, 9072a8 <wmi_cmd_rsp+0x34>
  907294:	c950      	beqz.n	a5, 9072a8 <wmi_cmd_rsp+0x34>
 *         put, or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_put_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_put_tail(buf, size);
  907296:	db60      	mov.n	a11, a6
  907298:	9a10      	s32i.n	a10, a1, 0
  90729a:	5bf0d5        	call8	9035f0 <__adf_nbuf_put_tail>
  90729d:	066c02        	or	a12, a6, a6
  9072a0:	055b02        	or	a11, a5, a5
  9072a3:	5bfc5f        	call8	906420 <__adf_os_mem_copy>
  9072a6:	8810      	l32i.n	a8, a1, 0
		pData = (A_UINT8 *)adf_nbuf_put_tail(netbuf, Length);
		adf_os_mem_copy(pData, buffer, Length);
	}

	WMI_SendEvent(pContext, netbuf, cmd_id, SeqNo, Length);
  9072a8:	257293        	l32i	a5, a7, 0x24c
  9072ab:	de60      	mov.n	a14, a6
  9072ad:	dd40      	mov.n	a13, a4
  9072af:	030c4f        	extui	a12, a3, 0, 16
  9072b2:	db80      	mov.n	a11, a8
  9072b4:	da20      	mov.n	a10, a2
  9072b6:	0b5000        	callx8	a5
  9072b9:	d10f      	retw.n
	...

009072bc <ath_hal_reg_rmw_tgt>:
}

static void ath_hal_reg_rmw_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data,
				a_int32_t datalen)
{
  9072bc:	6c1006        	entry	a1, 48
  9072bf:	03084f        	extui	a8, a3, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  9072c2:	232d05        	addmi	a3, a2, 0x500
  9072c5:	8c3b      	l32i.n	a12, a3, 44
}

static void ath_hal_reg_rmw_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data,
				a_int32_t datalen)
{
  9072c7:	04044f        	extui	a4, a4, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
	struct register_rmw *buf = (struct register_rmw *)data;
	int i;

	for (i = 0; i < datalen;
  9072ca:	d750      	mov.n	a7, a5
	     i += sizeof(struct register_rmw)) {
		a_uint32_t val;
		buf = (struct register_rmw *)(data + i);

		val = ath_reg_read_filter(ah, buf->reg);
		val &= ~buf->clr;
  9072cc:	c73f      	movi.n	a3, -1
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
	struct register_rmw *buf = (struct register_rmw *)data;
	int i;

	for (i = 0; i < datalen;
  9072ce:	600023        	j	9072f5 <ath_hal_reg_rmw_tgt+0x39>
  9072d1:	008b70        	excw
	     i += sizeof(struct register_rmw)) {
		a_uint32_t val;
		buf = (struct register_rmw *)(data + i);

		val = ath_reg_read_filter(ah, buf->reg);
  9072d4:	dac0      	mov.n	a10, a12
  9072d6:	9811      	s32i.n	a8, a1, 4
  9072d8:	9c10      	s32i.n	a12, a1, 0
  9072da:	5bfd09        	call8	906700 <ath_reg_read_filter>
		val &= ~buf->clr;
  9072dd:	8b72      	l32i.n	a11, a7, 8
  9072df:	0b3b03        	xor	a11, a3, a11
  9072e2:	0aba01        	and	a10, a11, a10
		val |= buf->set;
  9072e5:	8b71      	l32i.n	a11, a7, 4
		ath_hal_reg_write_filter(ah, buf->reg, val);
  9072e7:	0bab02        	or	a11, a10, a11
  9072ea:	8a70      	l32i.n	a10, a7, 0
  9072ec:	bc77      	addi.n	a7, a7, 12
  9072ee:	5bfce0        	call8	906670 <ath_hal_reg_write_filter$isra$13>
  9072f1:	8c10      	l32i.n	a12, a1, 0
  9072f3:	8811      	l32i.n	a8, a1, 4
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
	struct register_rmw *buf = (struct register_rmw *)data;
	int i;

	for (i = 0; i < datalen;
  9072f5:	05790c        	sub	a9, a7, a5
  9072f8:	7692d6        	blt	a9, a6, 9072d2 <ath_hal_reg_rmw_tgt+0x16>
		val = ath_reg_read_filter(ah, buf->reg);
		val &= ~buf->clr;
		val |= buf->set;
		ath_hal_reg_write_filter(ah, buf->reg, val);
	}
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  9072fb:	c0e0      	movi.n	a14, 0
  9072fd:	8a23      	l32i.n	a10, a2, 12
  9072ff:	dde0      	mov.n	a13, a14
  907301:	dc40      	mov.n	a12, a4
  907303:	db80      	mov.n	a11, a8
  907305:	5bffdb        	call8	907274 <wmi_cmd_rsp>
  907308:	d10f      	retw.n
	...

0090730c <ath_rc_mask_tgt>:
	adf_os_assert(0);
}

static void ath_rc_mask_tgt(void *Context, A_UINT16 Command,
			    A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
  90730c:	6c1004        	entry	a1, 32
	int idx, band, i;

	idx = wmi_data->vap_index;
	band = wmi_data->band;

	sc->sc_vap[idx].av_rate_mask[band] = adf_os_ntohl(wmi_data->mask);
  90730f:	2a5002        	l8ui	a10, a5, 2
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_rate_mask_cmd *wmi_data = (struct wmi_rc_rate_mask_cmd *)buffer;
	int idx, band, i;

	idx = wmi_data->vap_index;
  907312:	2f5000        	l8ui	a15, a5, 0
	band = wmi_data->band;

	sc->sc_vap[idx].av_rate_mask[band] = adf_os_ntohl(wmi_data->mask);
  907315:	08ae10        	slli	a14, a10, 24
  907318:	2a5003        	l8ui	a10, a5, 3
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_rate_mask_cmd *wmi_data = (struct wmi_rc_rate_mask_cmd *)buffer;
	int idx, band, i;

	idx = wmi_data->vap_index;
	band = wmi_data->band;
  90731b:	2d5001        	l8ui	a13, a5, 1

	sc->sc_vap[idx].av_rate_mask[band] = adf_os_ntohl(wmi_data->mask);
  90731e:	00aa11        	slli	a10, a10, 16
  907321:	0eaa02        	or	a10, a10, a14
  907324:	2e5004        	l8ui	a14, a5, 4
  907327:	0cf811        	slli	a8, a15, 4
  90732a:	08ee11        	slli	a14, a14, 8
  90732d:	0aea02        	or	a10, a14, a10
  907330:	2e5005        	l8ui	a14, a5, 5
  907333:	af89      	add.n	a9, a8, a15
  907335:	0aee02        	or	a14, a14, a10
	adf_os_assert(0);
}

static void ath_rc_mask_tgt(void *Context, A_UINT16 Command,
			    A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
  907338:	030b4f        	extui	a11, a3, 0, 16
	int idx, band, i;

	idx = wmi_data->vap_index;
	band = wmi_data->band;

	sc->sc_vap[idx].av_rate_mask[band] = adf_os_ntohl(wmi_data->mask);
  90733b:	ad9a      	add.n	a10, a9, a13
  90733d:	235a70        	movi	a3, 0x570
  907340:	a3aa      	add.n	a10, a10, a3
  907342:	0eaa11        	slli	a10, a10, 2
  907345:	aa2a      	add.n	a10, a2, a10
  907347:	9ea4      	s32i.n	a14, a10, 16
	adf_os_assert(0);
}

static void ath_rc_mask_tgt(void *Context, A_UINT16 Command,
			    A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
  907349:	040c4f        	extui	a12, a4, 0, 16
	idx = wmi_data->vap_index;
	band = wmi_data->band;

	sc->sc_vap[idx].av_rate_mask[band] = adf_os_ntohl(wmi_data->mask);

	if (sc->sc_vap[idx].av_rate_mask[band]) {
  90734c:	caec      	beqz.n	a14, 90737c <ath_rc_mask_tgt+0x70>
  90734e:	c050      	movi.n	a5, 0
		for (i = 0; i < RATE_TABLE_SIZE; i++) {
			if ((1 << i) & sc->sc_vap[idx].av_rate_mask[band]) {
  907350:	c0a1      	movi.n	a10, 1
  907352:	290a20        	movi	a9, 32
  907355:	6d981e        	loop	a9, 907377 <ath_rc_mask_tgt+0x6b>
  907358:	005104        	ssl	a5
  90735b:	00a31a        	sll	a3, a10
  90735e:	7e3013        	bnone	a3, a14, 907375 <ath_rc_mask_tgt+0x69>
				sc->sc_vap[idx].av_minrateidx[band] = i;
  907361:	af89      	add.n	a9, a8, a15
  907363:	0e9911        	slli	a9, a9, 2
  907366:	a929      	add.n	a9, a2, a9
  907368:	187288        	l32r	a8, 8e3d88 <mUsbEPinHighBandSet+0x78>
  90736b:	ad99      	add.n	a9, a9, a13
  90736d:	a899      	add.n	a9, a9, a8
  90736f:	259400        	s8i	a5, a9, 0
				break;
  907372:	600015        	j	90738b <ath_rc_mask_tgt+0x7f>
	band = wmi_data->band;

	sc->sc_vap[idx].av_rate_mask[band] = adf_os_ntohl(wmi_data->mask);

	if (sc->sc_vap[idx].av_rate_mask[band]) {
		for (i = 0; i < RATE_TABLE_SIZE; i++) {
  907375:	b155      	addi.n	a5, a5, 1
  907377:	600010        	j	90738b <ath_rc_mask_tgt+0x7f>
  90737a:	00000e        	subx4	a0, a0, a0
				sc->sc_vap[idx].av_minrateidx[band] = i;
				break;
			}
		}
	} else {
		sc->sc_vap[idx].av_minrateidx[band] = 0;
  90737d:	9911      	s32i.n	a9, a1, 4
  90737f:	a929      	add.n	a9, a2, a9
  907381:	157288        	l32r	a5, 8e3da4 <mUsbEPinHighBandSet+0x94>
  907384:	ad99      	add.n	a9, a9, a13
  907386:	a599      	add.n	a9, a9, a5
  907388:	2e9400        	s8i	a14, a9, 0
	}

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  90738b:	c0e0      	movi.n	a14, 0
  90738d:	8a23      	l32i.n	a10, a2, 12
  90738f:	dde0      	mov.n	a13, a14
  907391:	5bffb8        	call8	907274 <wmi_cmd_rsp>
  907394:	d10f      	retw.n
	...

00907398 <ath_rx_stats_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
}

static void ath_rx_stats_tgt(void *Context,A_UINT16 Command, A_UINT16 SeqNo,
			     A_UINT8 *data, a_int32_t datalen)
{
  907398:	6c1006        	entry	a1, 48
		a_uint32_t   ast_rx_done;
	};

	struct fusion_stats stats;

	stats.ast_rx_nobuf = sc->sc_rx_stats.ast_rx_nobuf;
  90739b:	28227c        	l32i	a8, a2, 0x1f0
	stats.ast_rx_send = sc->sc_rx_stats.ast_rx_send;
	stats.ast_rx_done = sc->sc_rx_stats.ast_rx_done;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  90739e:	8a23      	l32i.n	a10, a2, 12
		a_uint32_t   ast_rx_done;
	};

	struct fusion_stats stats;

	stats.ast_rx_nobuf = sc->sc_rx_stats.ast_rx_nobuf;
  9073a0:	9810      	s32i.n	a8, a1, 0
	stats.ast_rx_send = sc->sc_rx_stats.ast_rx_send;
  9073a2:	28227d        	l32i	a8, a2, 0x1f4
	stats.ast_rx_done = sc->sc_rx_stats.ast_rx_done;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  9073a5:	c0ec      	movi.n	a14, 12
	};

	struct fusion_stats stats;

	stats.ast_rx_nobuf = sc->sc_rx_stats.ast_rx_nobuf;
	stats.ast_rx_send = sc->sc_rx_stats.ast_rx_send;
  9073a7:	9811      	s32i.n	a8, a1, 4
	stats.ast_rx_done = sc->sc_rx_stats.ast_rx_done;
  9073a9:	28227e        	l32i	a8, a2, 0x1f8

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  9073ac:	dd10      	mov.n	a13, a1
  9073ae:	040c4f        	extui	a12, a4, 0, 16
  9073b1:	030b4f        	extui	a11, a3, 0, 16

	struct fusion_stats stats;

	stats.ast_rx_nobuf = sc->sc_rx_stats.ast_rx_nobuf;
	stats.ast_rx_send = sc->sc_rx_stats.ast_rx_send;
	stats.ast_rx_done = sc->sc_rx_stats.ast_rx_done;
  9073b4:	9812      	s32i.n	a8, a1, 8

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  9073b6:	5bffaf        	call8	907274 <wmi_cmd_rsp>
  9073b9:	d10f      	retw.n
	...

009073bc <ath_tx_stats_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
}

static void ath_tx_stats_tgt(void *Context,A_UINT16 Command, A_UINT16 SeqNo,
			     A_UINT8 *data, a_int32_t datalen)
{
  9073bc:	6c100a        	entry	a1, 80
		a_uint32_t   tx_nobufs;
	};

	struct fusion_stats stats;

	stats.ast_tx_xretries = sc->sc_tx_stats.ast_tx_xretries;
  9073bf:	282252        	l32i	a8, a2, 0x148
	stats.ast_tx_longretry = sc->sc_tx_stats.ast_tx_longretry;
	stats.tx_qnull = sc->sc_tx_stats.tx_qnull;
	stats.tx_noskbs = sc->sc_tx_stats.tx_noskbs;
	stats.tx_nobufs = sc->sc_tx_stats.tx_nobufs;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  9073c2:	8a23      	l32i.n	a10, a2, 12
		a_uint32_t   tx_nobufs;
	};

	struct fusion_stats stats;

	stats.ast_tx_xretries = sc->sc_tx_stats.ast_tx_xretries;
  9073c4:	9810      	s32i.n	a8, a1, 0
	stats.ast_tx_fifoerr = sc->sc_tx_stats.ast_tx_fifoerr;
  9073c6:	282253        	l32i	a8, a2, 0x14c
	stats.ast_tx_longretry = sc->sc_tx_stats.ast_tx_longretry;
	stats.tx_qnull = sc->sc_tx_stats.tx_qnull;
	stats.tx_noskbs = sc->sc_tx_stats.tx_noskbs;
	stats.tx_nobufs = sc->sc_tx_stats.tx_nobufs;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  9073c9:	c2e4      	movi.n	a14, 36
	};

	struct fusion_stats stats;

	stats.ast_tx_xretries = sc->sc_tx_stats.ast_tx_xretries;
	stats.ast_tx_fifoerr = sc->sc_tx_stats.ast_tx_fifoerr;
  9073cb:	9811      	s32i.n	a8, a1, 4
	stats.ast_tx_filtered = sc->sc_tx_stats.ast_tx_filtered;
  9073cd:	282254        	l32i	a8, a2, 0x150
	stats.ast_tx_longretry = sc->sc_tx_stats.ast_tx_longretry;
	stats.tx_qnull = sc->sc_tx_stats.tx_qnull;
	stats.tx_noskbs = sc->sc_tx_stats.tx_noskbs;
	stats.tx_nobufs = sc->sc_tx_stats.tx_nobufs;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  9073d0:	dd10      	mov.n	a13, a1

	struct fusion_stats stats;

	stats.ast_tx_xretries = sc->sc_tx_stats.ast_tx_xretries;
	stats.ast_tx_fifoerr = sc->sc_tx_stats.ast_tx_fifoerr;
	stats.ast_tx_filtered = sc->sc_tx_stats.ast_tx_filtered;
  9073d2:	9812      	s32i.n	a8, a1, 8
	stats.ast_tx_timer_exp = sc->sc_tx_stats.ast_tx_timer_exp;
  9073d4:	282255        	l32i	a8, a2, 0x154
	stats.ast_tx_longretry = sc->sc_tx_stats.ast_tx_longretry;
	stats.tx_qnull = sc->sc_tx_stats.tx_qnull;
	stats.tx_noskbs = sc->sc_tx_stats.tx_noskbs;
	stats.tx_nobufs = sc->sc_tx_stats.tx_nobufs;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  9073d7:	040c4f        	extui	a12, a4, 0, 16
	struct fusion_stats stats;

	stats.ast_tx_xretries = sc->sc_tx_stats.ast_tx_xretries;
	stats.ast_tx_fifoerr = sc->sc_tx_stats.ast_tx_fifoerr;
	stats.ast_tx_filtered = sc->sc_tx_stats.ast_tx_filtered;
	stats.ast_tx_timer_exp = sc->sc_tx_stats.ast_tx_timer_exp;
  9073da:	9813      	s32i.n	a8, a1, 12
	stats.ast_tx_shortretry = sc->sc_tx_stats.ast_tx_shortretry;
  9073dc:	282256        	l32i	a8, a2, 0x158
	stats.ast_tx_longretry = sc->sc_tx_stats.ast_tx_longretry;
	stats.tx_qnull = sc->sc_tx_stats.tx_qnull;
	stats.tx_noskbs = sc->sc_tx_stats.tx_noskbs;
	stats.tx_nobufs = sc->sc_tx_stats.tx_nobufs;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  9073df:	030b4f        	extui	a11, a3, 0, 16

	stats.ast_tx_xretries = sc->sc_tx_stats.ast_tx_xretries;
	stats.ast_tx_fifoerr = sc->sc_tx_stats.ast_tx_fifoerr;
	stats.ast_tx_filtered = sc->sc_tx_stats.ast_tx_filtered;
	stats.ast_tx_timer_exp = sc->sc_tx_stats.ast_tx_timer_exp;
	stats.ast_tx_shortretry = sc->sc_tx_stats.ast_tx_shortretry;
  9073e2:	9814      	s32i.n	a8, a1, 16
	stats.ast_tx_longretry = sc->sc_tx_stats.ast_tx_longretry;
  9073e4:	282257        	l32i	a8, a2, 0x15c
  9073e7:	9815      	s32i.n	a8, a1, 20
	stats.tx_qnull = sc->sc_tx_stats.tx_qnull;
  9073e9:	28225c        	l32i	a8, a2, 0x170
  9073ec:	9816      	s32i.n	a8, a1, 24
	stats.tx_noskbs = sc->sc_tx_stats.tx_noskbs;
  9073ee:	282276        	l32i	a8, a2, 0x1d8
  9073f1:	9817      	s32i.n	a8, a1, 28
	stats.tx_nobufs = sc->sc_tx_stats.tx_nobufs;
  9073f3:	282277        	l32i	a8, a2, 0x1dc
  9073f6:	281608        	s32i	a8, a1, 32

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  9073f9:	5bff9e        	call8	907274 <wmi_cmd_rsp>
  9073fc:	d10f      	retw.n
	...

00907400 <ath_int_stats_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_int_stats_tgt(void *Context,A_UINT16 Command, A_UINT16 SeqNo,
			      A_UINT8 *data, a_int32_t datalen)
{
  907400:	6c1008        	entry	a1, 64
		a_uint32_t ast_cst;
	};

	struct fusion_stats stats;

	stats.ast_rx = sc->sc_int_stats.ast_rx;
  907403:	28224c        	l32i	a8, a2, 0x130
	stats.ast_rxeol = sc->sc_int_stats.ast_rxeol;
	stats.ast_txurn = sc->sc_int_stats.ast_txurn;
	stats.ast_txto = sc->sc_int_stats.ast_txto;
	stats.ast_cst = sc->sc_int_stats.ast_cst;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  907406:	8a23      	l32i.n	a10, a2, 12
		a_uint32_t ast_cst;
	};

	struct fusion_stats stats;

	stats.ast_rx = sc->sc_int_stats.ast_rx;
  907408:	9810      	s32i.n	a8, a1, 0
	stats.ast_rxorn = sc->sc_int_stats.ast_rxorn;
  90740a:	28224d        	l32i	a8, a2, 0x134
	stats.ast_rxeol = sc->sc_int_stats.ast_rxeol;
	stats.ast_txurn = sc->sc_int_stats.ast_txurn;
	stats.ast_txto = sc->sc_int_stats.ast_txto;
	stats.ast_cst = sc->sc_int_stats.ast_cst;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  90740d:	c1e8      	movi.n	a14, 24
	};

	struct fusion_stats stats;

	stats.ast_rx = sc->sc_int_stats.ast_rx;
	stats.ast_rxorn = sc->sc_int_stats.ast_rxorn;
  90740f:	9811      	s32i.n	a8, a1, 4
	stats.ast_rxeol = sc->sc_int_stats.ast_rxeol;
  907411:	28224e        	l32i	a8, a2, 0x138
	stats.ast_txurn = sc->sc_int_stats.ast_txurn;
	stats.ast_txto = sc->sc_int_stats.ast_txto;
	stats.ast_cst = sc->sc_int_stats.ast_cst;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  907414:	dd10      	mov.n	a13, a1

	struct fusion_stats stats;

	stats.ast_rx = sc->sc_int_stats.ast_rx;
	stats.ast_rxorn = sc->sc_int_stats.ast_rxorn;
	stats.ast_rxeol = sc->sc_int_stats.ast_rxeol;
  907416:	9812      	s32i.n	a8, a1, 8
	stats.ast_txurn = sc->sc_int_stats.ast_txurn;
  907418:	28224f        	l32i	a8, a2, 0x13c
	stats.ast_txto = sc->sc_int_stats.ast_txto;
	stats.ast_cst = sc->sc_int_stats.ast_cst;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  90741b:	040c4f        	extui	a12, a4, 0, 16
	struct fusion_stats stats;

	stats.ast_rx = sc->sc_int_stats.ast_rx;
	stats.ast_rxorn = sc->sc_int_stats.ast_rxorn;
	stats.ast_rxeol = sc->sc_int_stats.ast_rxeol;
	stats.ast_txurn = sc->sc_int_stats.ast_txurn;
  90741e:	9813      	s32i.n	a8, a1, 12
	stats.ast_txto = sc->sc_int_stats.ast_txto;
  907420:	282250        	l32i	a8, a2, 0x140
	stats.ast_cst = sc->sc_int_stats.ast_cst;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  907423:	030b4f        	extui	a11, a3, 0, 16

	stats.ast_rx = sc->sc_int_stats.ast_rx;
	stats.ast_rxorn = sc->sc_int_stats.ast_rxorn;
	stats.ast_rxeol = sc->sc_int_stats.ast_rxeol;
	stats.ast_txurn = sc->sc_int_stats.ast_txurn;
	stats.ast_txto = sc->sc_int_stats.ast_txto;
  907426:	9814      	s32i.n	a8, a1, 16
	stats.ast_cst = sc->sc_int_stats.ast_cst;
  907428:	282251        	l32i	a8, a2, 0x144
  90742b:	9815      	s32i.n	a8, a1, 20

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  90742d:	5bff91        	call8	907274 <wmi_cmd_rsp>
  907430:	d10f      	retw.n
	...

00907434 <ath_node_update_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_node_update_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907434:	6c1004        	entry	a1, 32
	a_uint8_t vap_index;
	a_uint8_t node_index;

	node = (struct ieee80211_node_target *)data;

	node_index = node->ni_nodeindex;
  907437:	26500c        	l8ui	a6, a5, 12

	node->ni_htcap = adf_os_ntohs(node->ni_htcap);
	node->ni_flags = adf_os_ntohs(node->ni_flags);
	node->ni_maxampdu = adf_os_ntohs(node->ni_maxampdu);

	adf_os_mem_copy(&(sc->sc_sta[node_index].ni), node,
  90743a:	2a5a38        	movi	a10, 0x538
  90743d:	0a6811        	slli	a8, a6, 6
  907440:	a688      	add.n	a8, a8, a6
  907442:	0f8811        	slli	a8, a8, 1
  907445:	a688      	add.n	a8, a8, a6
  907447:	0e8611        	slli	a6, a8, 2
  90744a:	aa6a      	add.n	a10, a6, a10
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_node_update_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  90744c:	db50      	mov.n	a11, a5
  90744e:	aa2a      	add.n	a10, a2, a10
  907450:	c1c6      	movi.n	a12, 22
  907452:	5bfbf3        	call8	906420 <__adf_os_mem_copy>

	adf_os_mem_copy(&(sc->sc_sta[node_index].ni), node,
			NODE_TARGET_SIZE);

	vap_index = sc->sc_sta[node_index].ni.ni_vapindex;
	sc->sc_sta[node_index].ni.ni_vap = &(sc->sc_vap[vap_index].av_vap);
  907455:	a628      	add.n	a8, a2, a6
	node->ni_maxampdu = adf_os_ntohs(node->ni_maxampdu);

	adf_os_mem_copy(&(sc->sc_sta[node_index].ni), node,
			NODE_TARGET_SIZE);

	vap_index = sc->sc_sta[node_index].ni.ni_vapindex;
  907457:	265a45        	movi	a6, 0x545
  90745a:	a686      	add.n	a6, a8, a6
	sc->sc_sta[node_index].ni.ni_vap = &(sc->sc_vap[vap_index].av_vap);
  90745c:	2a6000        	l8ui	a10, a6, 0
  90745f:	295a58        	movi	a9, 0x558
  907462:	0ca611        	slli	a6, a10, 4
  907465:	aa66      	add.n	a6, a6, a10
  907467:	1a7289        	l32r	a10, 8e3e8c <mUsbEPinHighBandSet+0x17c>
  90746a:	0e6611        	slli	a6, a6, 2
  90746d:	aa66      	add.n	a6, a6, a10
  90746f:	a989      	add.n	a9, a8, a9
  907471:	a626      	add.n	a6, a2, a6
  907473:	9690      	s32i.n	a6, a9, 0

	sc->sc_sta[node_index].ni.ni_txseqmgmt = 0;
  907475:	265a50        	movi	a6, 0x550
  907478:	a686      	add.n	a6, a8, a6
  90747a:	c090      	movi.n	a9, 0
  90747c:	296500        	s16i	a9, a6, 0
	sc->sc_sta[node_index].ni.ni_iv16 = 0;
  90747f:	265a52        	movi	a6, 0x552
  907482:	a686      	add.n	a6, a8, a6
  907484:	296500        	s16i	a9, a6, 0
	sc->sc_sta[node_index].ni.ni_iv32 = 0;
  907487:	265a54        	movi	a6, 0x554
  90748a:	c0d0      	movi.n	a13, 0
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_node_update_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  90748c:	03034f        	extui	a3, a3, 0, 16
  90748f:	04044f        	extui	a4, a4, 0, 16
	vap_index = sc->sc_sta[node_index].ni.ni_vapindex;
	sc->sc_sta[node_index].ni.ni_vap = &(sc->sc_vap[vap_index].av_vap);

	sc->sc_sta[node_index].ni.ni_txseqmgmt = 0;
	sc->sc_sta[node_index].ni.ni_iv16 = 0;
	sc->sc_sta[node_index].ni.ni_iv32 = 0;
  907492:	a688      	add.n	a8, a8, a6

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  907494:	8a23      	l32i.n	a10, a2, 12
	vap_index = sc->sc_sta[node_index].ni.ni_vapindex;
	sc->sc_sta[node_index].ni.ni_vap = &(sc->sc_vap[vap_index].av_vap);

	sc->sc_sta[node_index].ni.ni_txseqmgmt = 0;
	sc->sc_sta[node_index].ni.ni_iv16 = 0;
	sc->sc_sta[node_index].ni.ni_iv32 = 0;
  907496:	9d80      	s32i.n	a13, a8, 0

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  907498:	ded0      	mov.n	a14, a13
  90749a:	dc40      	mov.n	a12, a4
  90749c:	db30      	mov.n	a11, a3
  90749e:	5bff75        	call8	907274 <wmi_cmd_rsp>
  9074a1:	d10f      	retw.n
	...

009074a4 <ath_detach_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_detach_tgt(void *Context, A_UINT16 Command, A_UINT16 SeqNo,
				 A_UINT8 *data, a_int32_t datalen)
{
  9074a4:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  9074a7:	252d05        	addmi	a5, a2, 0x500
  9074aa:	855b      	l32i.n	a5, a5, 44

	ath_desc_free(sc);
  9074ac:	022a02        	or	a10, a2, a2
  9074af:	5bfcab        	call8	90675c <ath_desc_free>
	ah->ah_detach(ah);
  9074b2:	8856      	l32i.n	a8, a5, 24
  9074b4:	da50      	mov.n	a10, a5
  9074b6:	0b8000        	callx8	a8
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_detach_tgt(void *Context, A_UINT16 Command, A_UINT16 SeqNo,
				 A_UINT8 *data, a_int32_t datalen)
{
  9074b9:	03034f        	extui	a3, a3, 0, 16
  9074bc:	04044f        	extui	a4, a4, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;

	ath_desc_free(sc);
	ah->ah_detach(ah);
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  9074bf:	c0e0      	movi.n	a14, 0
  9074c1:	8a23      	l32i.n	a10, a2, 12
  9074c3:	dde0      	mov.n	a13, a14
  9074c5:	dc40      	mov.n	a12, a4
  9074c7:	db30      	mov.n	a11, a3
  9074c9:	5bff6a        	call8	907274 <wmi_cmd_rsp>
  9074cc:	d10f      	retw.n
	...

009074d0 <ath_enable_aggr_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &ver, sizeof(ver));
}

static void ath_enable_aggr_tgt(void *Context,A_UINT16 Command, A_UINT16 SeqNo,
				A_UINT8 *data, a_int32_t datalen)
{
  9074d0:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_aggr_info *aggr = (struct ath_aggr_info *)data;
	a_uint8_t nodeindex = aggr->nodeindex;
  9074d3:	2d5000        	l8ui	a13, a5, 0
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &ver, sizeof(ver));
}

static void ath_enable_aggr_tgt(void *Context,A_UINT16 Command, A_UINT16 SeqNo,
				A_UINT8 *data, a_int32_t datalen)
{
  9074d6:	03034f        	extui	a3, a3, 0, 16
  9074d9:	04044f        	extui	a4, a4, 0, 16
	a_uint8_t nodeindex = aggr->nodeindex;
	a_uint8_t tidno = aggr->tidno;
	struct ath_node_target *an = NULL ;
	struct ath_atx_tid  *tid = NULL;

	if (nodeindex >= TARGET_NODE_MAX) {
  9074dc:	6ed802        	bltui	a13, 8, 9074e2 <ath_enable_aggr_tgt+0x12>
  9074df:	600089        	j	90756c <ath_enable_aggr_tgt+0x9c>
		goto done;
	}

	an = &sc->sc_sta[nodeindex];
	if (!an->an_valid) {
  9074e2:	0ad811        	slli	a8, a13, 6
  9074e5:	ad88      	add.n	a8, a8, a13
  9074e7:	0f8811        	slli	a8, a8, 1
  9074ea:	ad88      	add.n	a8, a8, a13
  9074ec:	0e8b11        	slli	a11, a8, 2
  9074ef:	ab28      	add.n	a8, a2, a11
  9074f1:	297a3c        	movi	a9, 0x73c
  9074f4:	a988      	add.n	a8, a8, a9
  9074f6:	288000        	l8ui	a8, a8, 0
  9074f9:	64806f        	beqz	a8, 90756c <ath_enable_aggr_tgt+0x9c>
				A_UINT8 *data, a_int32_t datalen)
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_aggr_info *aggr = (struct ath_aggr_info *)data;
	a_uint8_t nodeindex = aggr->nodeindex;
	a_uint8_t tidno = aggr->tidno;
  9074fc:	2c5001        	l8ui	a12, a5, 1
	an = &sc->sc_sta[nodeindex];
	if (!an->an_valid) {
		goto done;
	}

	if (tidno >= WME_NUM_TID) {
  9074ff:	6ec811        	bltui	a12, 8, 907514 <ath_enable_aggr_tgt+0x44>
		adf_os_print("[%s] enable_aggr with invalid tid %d(node = %d)\n",
  907502:	15716e        	l32r	a5, 8e3abc <bStandardCommand+0x830>
  907505:	1b728a        	l32r	a11, 8e3f30 <mUsbEPinHighBandSet+0x220>
  907508:	255212        	l32i	a5, a5, 72
  90750b:	1a728b        	l32r	a10, 8e3f38 <mUsbEPinHighBandSet+0x228>
  90750e:	0b5000        	callx8	a5
			     __FUNCTION__, tidno, nodeindex);
		goto done;
  907511:	600057        	j	90756c <ath_enable_aggr_tgt+0x9c>
  907514:	0cc811        	slli	a8, a12, 4
	}

	tid = ATH_AN_2_TID(an, tidno);

	if (aggr->aggr_enable) {
		tid->flag |= TID_AGGR_ENABLED;
  907517:	0c880c        	sub	a8, a8, a12
  90751a:	0e8811        	slli	a8, a8, 2
		goto done;
	}

	tid = ATH_AN_2_TID(an, tidno);

	if (aggr->aggr_enable) {
  90751d:	255002        	l8ui	a5, a5, 2
		tid->flag |= TID_AGGR_ENABLED;
  907520:	ab88      	add.n	a8, a8, a11
  907522:	a828      	add.n	a8, a2, a8
		goto done;
	}

	tid = ATH_AN_2_TID(an, tidno);

	if (aggr->aggr_enable) {
  907524:	c951      	beqz.n	a5, 907539 <ath_enable_aggr_tgt+0x69>
		tid->flag |= TID_AGGR_ENABLED;
  907526:	255a92        	movi	a5, 0x592
  907529:	a588      	add.n	a8, a8, a5
  90752b:	298000        	l8ui	a9, a8, 0
  90752e:	c052      	movi.n	a5, 2
  907530:	059902        	or	a9, a9, a5
  907533:	298400        	s8i	a9, a8, 0
  907536:	600032        	j	90756c <ath_enable_aggr_tgt+0x9c>
	} else if ( tid->flag & TID_AGGR_ENABLED ) {
  907539:	255a92        	movi	a5, 0x592
  90753c:	a588      	add.n	a8, a8, a5
  90753e:	298000        	l8ui	a9, a8, 0
  907541:	7e9727        	bbci	a9, 30, 90756c <ath_enable_aggr_tgt+0x9c>
		tid->flag &= ~TID_AGGR_ENABLED;
  907544:	c75d      	movi.n	a5, -3
  907546:	059901        	and	a9, a9, a5
  907549:	298400        	s8i	a9, a8, 0
		adf_os_print("[%s] enable_aggr with invalid tid %d(node = %d)\n",
			     __FUNCTION__, tidno, nodeindex);
		goto done;
	}

	tid = ATH_AN_2_TID(an, tidno);
  90754c:	0cc911        	slli	a9, a12, 4
  90754f:	0c9c0c        	sub	a12, a9, a12
  907552:	0ecc11        	slli	a12, a12, 2
  907555:	abcc      	add.n	a12, a12, a11
  907557:	255a5c        	movi	a5, 0x55c

	if (nodeindex >= TARGET_NODE_MAX) {
		goto done;
	}

	an = &sc->sc_sta[nodeindex];
  90755a:	285a38        	movi	a8, 0x538
		adf_os_print("[%s] enable_aggr with invalid tid %d(node = %d)\n",
			     __FUNCTION__, tidno, nodeindex);
		goto done;
	}

	tid = ATH_AN_2_TID(an, tidno);
  90755d:	a5cc      	add.n	a12, a12, a5

	if (nodeindex >= TARGET_NODE_MAX) {
		goto done;
	}

	an = &sc->sc_sta[nodeindex];
  90755f:	a8bb      	add.n	a11, a11, a8

	if (aggr->aggr_enable) {
		tid->flag |= TID_AGGR_ENABLED;
	} else if ( tid->flag & TID_AGGR_ENABLED ) {
		tid->flag &= ~TID_AGGR_ENABLED;
		ath_tgt_tx_cleanup(sc, an, tid, 1);
  907561:	c0d1      	movi.n	a13, 1
  907563:	ac2c      	add.n	a12, a2, a12
  907565:	ab2b      	add.n	a11, a2, a11
  907567:	da20      	mov.n	a10, a2
  907569:	580e0a        	call8	90ad94 <ath_tgt_tx_cleanup>
	}
done:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  90756c:	c0e0      	movi.n	a14, 0
  90756e:	8a23      	l32i.n	a10, a2, 12
  907570:	dde0      	mov.n	a13, a14
  907572:	dc40      	mov.n	a12, a4
  907574:	db30      	mov.n	a11, a3
  907576:	5bff3f        	call8	907274 <wmi_cmd_rsp>
  907579:	d10f      	retw.n
	...

0090757c <ath_ic_update_tgt>:
}

static void ath_ic_update_tgt(void *Context,A_UINT16 Command, A_UINT16 SeqNo,
			      A_UINT8 *data, a_int32_t datalen)
{
  90757c:	6c1004        	entry	a1, 32
  90757f:	1a728c        	l32r	a10, 8e3fb0 <mUsbEPinHighBandSet+0x2a0>
  907582:	db50      	mov.n	a11, a5
  907584:	0a2a08        	add	a10, a2, a10
  907587:	c0c8      	movi.n	a12, 8
  907589:	5bfba5        	call8	906420 <__adf_os_mem_copy>
	struct ieee80211com_target *ic = (struct ieee80211com_target * )data;
	struct ieee80211com_target *ictgt = &sc->sc_ic ;

	adf_os_mem_copy(ictgt, ic, sizeof(struct  ieee80211com_target));

	ictgt->ic_ampdu_limit         = adf_os_ntohl(ic->ic_ampdu_limit);
  90758c:	8850      	l32i.n	a8, a5, 0
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_ic_update_tgt(void *Context,A_UINT16 Command, A_UINT16 SeqNo,
			      A_UINT8 *data, a_int32_t datalen)
{
  90758e:	03034f        	extui	a3, a3, 0, 16
  907591:	04044f        	extui	a4, a4, 0, 16
	struct ieee80211com_target *ic = (struct ieee80211com_target * )data;
	struct ieee80211com_target *ictgt = &sc->sc_ic ;

	adf_os_mem_copy(ictgt, ic, sizeof(struct  ieee80211com_target));

	ictgt->ic_ampdu_limit         = adf_os_ntohl(ic->ic_ampdu_limit);
  907594:	252d16        	addmi	a5, a2, 0x1600

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  907597:	c0e0      	movi.n	a14, 0
  907599:	8a23      	l32i.n	a10, a2, 12
	struct ieee80211com_target *ic = (struct ieee80211com_target * )data;
	struct ieee80211com_target *ictgt = &sc->sc_ic ;

	adf_os_mem_copy(ictgt, ic, sizeof(struct  ieee80211com_target));

	ictgt->ic_ampdu_limit         = adf_os_ntohl(ic->ic_ampdu_limit);
  90759b:	9858      	s32i.n	a8, a5, 32

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  90759d:	dde0      	mov.n	a13, a14
  90759f:	dc40      	mov.n	a12, a4
  9075a1:	db30      	mov.n	a11, a3
  9075a3:	5bff34        	call8	907274 <wmi_cmd_rsp>
  9075a6:	d10f      	retw.n

009075a8 <handle_rc_rate_update_cmd>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void handle_rc_rate_update_cmd(void *Context, A_UINT16 Command,
				      A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
  9075a8:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_rate_update_cmd *wmi_data = (struct wmi_rc_rate_update_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);

	ath_rate_node_update(sc, &sc->sc_sta[wmi_data->node_index],
  9075ab:	295000        	l8ui	a9, a5, 0
				      A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_rate_update_cmd *wmi_data = (struct wmi_rc_rate_update_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);
  9075ae:	285004        	l8ui	a8, a5, 4
  9075b1:	2d5005        	l8ui	a13, a5, 5
  9075b4:	088810        	slli	a8, a8, 24

	ath_rate_node_update(sc, &sc->sc_sta[wmi_data->node_index],
  9075b7:	0a9b11        	slli	a11, a9, 6
				      A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_rate_update_cmd *wmi_data = (struct wmi_rc_rate_update_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);
  9075ba:	00dd11        	slli	a13, a13, 16
  9075bd:	08dd02        	or	a13, a13, a8

	ath_rate_node_update(sc, &sc->sc_sta[wmi_data->node_index],
  9075c0:	a9bb      	add.n	a11, a11, a9
				      A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_rate_update_cmd *wmi_data = (struct wmi_rc_rate_update_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);
  9075c2:	285006        	l8ui	a8, a5, 6

	ath_rate_node_update(sc, &sc->sc_sta[wmi_data->node_index],
  9075c5:	0fbb11        	slli	a11, a11, 1
  9075c8:	a9bb      	add.n	a11, a11, a9
				      A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_rate_update_cmd *wmi_data = (struct wmi_rc_rate_update_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);
  9075ca:	088811        	slli	a8, a8, 8
  9075cd:	0d8802        	or	a8, a8, a13

	ath_rate_node_update(sc, &sc->sc_sta[wmi_data->node_index],
  9075d0:	295a38        	movi	a9, 0x538
				      A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_rate_update_cmd *wmi_data = (struct wmi_rc_rate_update_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);
  9075d3:	2d5007        	l8ui	a13, a5, 7

	ath_rate_node_update(sc, &sc->sc_sta[wmi_data->node_index],
  9075d6:	0ebb11        	slli	a11, a11, 2
  9075d9:	a9bb      	add.n	a11, a11, a9
  9075db:	2c5001        	l8ui	a12, a5, 1
  9075de:	b85e      	addi.n	a14, a5, 8
  9075e0:	08dd02        	or	a13, a13, a8
  9075e3:	0b2b08        	add	a11, a2, a11
  9075e6:	022a02        	or	a10, a2, a2
  9075e9:	58062d        	call8	908ea0 <ath_rate_node_update>
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void handle_rc_rate_update_cmd(void *Context, A_UINT16 Command,
				      A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
  9075ec:	03034f        	extui	a3, a3, 0, 16
  9075ef:	04044f        	extui	a4, a4, 0, 16
	ath_rate_node_update(sc, &sc->sc_sta[wmi_data->node_index],
			     wmi_data->isNew,
			     capflag,
			     &wmi_data->rs);

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  9075f2:	c0e0      	movi.n	a14, 0
  9075f4:	8a23      	l32i.n	a10, a2, 12
  9075f6:	dde0      	mov.n	a13, a14
  9075f8:	dc40      	mov.n	a12, a4
  9075fa:	033b02        	or	a11, a3, a3
  9075fd:	5bff1d        	call8	907274 <wmi_cmd_rsp>
  907600:	d10f      	retw.n
	...

00907604 <handle_rc_state_change_cmd>:
}

static void handle_rc_state_change_cmd(void *Context, A_UINT16 Command,
				       A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)

{
  907604:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_state_change_cmd *wmi_data = (struct wmi_rc_state_change_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);
  907607:	285004        	l8ui	a8, a5, 4
  90760a:	2d5005        	l8ui	a13, a5, 5

	ath_rate_newstate(sc, &sc->sc_vap[wmi_data->vap_index].av_vap,
  90760d:	295000        	l8ui	a9, a5, 0

{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_state_change_cmd *wmi_data = (struct wmi_rc_state_change_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);
  907610:	088810        	slli	a8, a8, 24
  907613:	00dd11        	slli	a13, a13, 16
  907616:	08dd02        	or	a13, a13, a8
  907619:	285006        	l8ui	a8, a5, 6

	ath_rate_newstate(sc, &sc->sc_vap[wmi_data->vap_index].av_vap,
  90761c:	0c9b11        	slli	a11, a9, 4
  90761f:	a9bb      	add.n	a11, a11, a9

{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_state_change_cmd *wmi_data = (struct wmi_rc_state_change_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);
  907621:	088811        	slli	a8, a8, 8

	ath_rate_newstate(sc, &sc->sc_vap[wmi_data->vap_index].av_vap,
  907624:	197289        	l32r	a9, 8e4048 <mUsbEPinHighBandSet+0x338>

{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_state_change_cmd *wmi_data = (struct wmi_rc_state_change_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);
  907627:	0d8802        	or	a8, a8, a13

	ath_rate_newstate(sc, &sc->sc_vap[wmi_data->vap_index].av_vap,
  90762a:	0ebb11        	slli	a11, a11, 2

{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_state_change_cmd *wmi_data = (struct wmi_rc_state_change_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);
  90762d:	2d5007        	l8ui	a13, a5, 7

	ath_rate_newstate(sc, &sc->sc_vap[wmi_data->vap_index].av_vap,
  907630:	a9bb      	add.n	a11, a11, a9
  907632:	2c5001        	l8ui	a12, a5, 1
  907635:	b85e      	addi.n	a14, a5, 8
  907637:	08dd02        	or	a13, a13, a8
  90763a:	ab2b      	add.n	a11, a2, a11
  90763c:	da20      	mov.n	a10, a2
  90763e:	58061d        	call8	908eb4 <ath_rate_newstate>
}

static void handle_rc_state_change_cmd(void *Context, A_UINT16 Command,
				       A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)

{
  907641:	03034f        	extui	a3, a3, 0, 16
  907644:	04044f        	extui	a4, a4, 0, 16
	ath_rate_newstate(sc, &sc->sc_vap[wmi_data->vap_index].av_vap,
			  wmi_data->vap_state,
			  capflag,
			  &wmi_data->rs);

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  907647:	c0e0      	movi.n	a14, 0
  907649:	8a23      	l32i.n	a10, a2, 12
  90764b:	dde0      	mov.n	a13, a14
  90764d:	dc40      	mov.n	a12, a4
  90764f:	db30      	mov.n	a11, a3
  907651:	5bff08        	call8	907274 <wmi_cmd_rsp>
  907654:	d10f      	retw.n
	...

00907658 <ath_hal_reg_write_tgt>:
	}
}

static void ath_hal_reg_write_tgt(void *Context, A_UINT16 Command,
				  A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907658:	6c1004        	entry	a1, 32
  90765b:	03034f        	extui	a3, a3, 0, 16
  90765e:	04044f        	extui	a4, a4, 0, 16
	struct registerWrite {
		a_uint32_t reg;
		a_uint32_t val;
	}*t;

	for (i = 0; i < datalen; i += sizeof(struct registerWrite)) {
  907661:	d750      	mov.n	a7, a5
  907663:	600009        	j	907670 <ath_hal_reg_write_tgt+0x18>
		t = (struct registerWrite *)(data+i);

		ath_hal_reg_write_filter(ah, t->reg, t->val);
  907666:	8b71      	l32i.n	a11, a7, 4
  907668:	8a70      	l32i.n	a10, a7, 0
  90766a:	277c08        	addi	a7, a7, 8
  90766d:	5bfc00        	call8	906670 <ath_hal_reg_write_filter$isra$13>
	struct registerWrite {
		a_uint32_t reg;
		a_uint32_t val;
	}*t;

	for (i = 0; i < datalen; i += sizeof(struct registerWrite)) {
  907670:	05780c        	sub	a8, a7, a5
  907673:	7682ef        	blt	a8, a6, 907666 <ath_hal_reg_write_tgt+0xe>
		t = (struct registerWrite *)(data+i);

		ath_hal_reg_write_filter(ah, t->reg, t->val);
	}

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  907676:	c0e0      	movi.n	a14, 0
  907678:	8a23      	l32i.n	a10, a2, 12
  90767a:	dde0      	mov.n	a13, a14
  90767c:	dc40      	mov.n	a12, a4
  90767e:	033b02        	or	a11, a3, a3
  907681:	5bfefc        	call8	907274 <wmi_cmd_rsp>
  907684:	d10f      	retw.n
	...

00907688 <ath_hal_reg_read_tgt>:
		return ioread32_mac(addr);
}

static void ath_hal_reg_read_tgt(void *Context, A_UINT16 Command,
				 A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907688:	6c1016        	entry	a1, 176
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  90768b:	272d05        	addmi	a7, a2, 0x500
  90768e:	897b      	l32i.n	a9, a7, 44
		return ioread32_mac(addr);
}

static void ath_hal_reg_read_tgt(void *Context, A_UINT16 Command,
				 A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907690:	03034f        	extui	a3, a3, 0, 16
  907693:	04044f        	extui	a4, a4, 0, 16
	struct ath_hal *ah = sc->sc_ah;
	a_uint32_t addr;
	a_uint32_t val[32];
	int i;

	for (i = 0; i < datalen; i += sizeof(a_int32_t)) {
  907696:	c070      	movi.n	a7, 0
  907698:	60001c        	j	9076b8 <ath_hal_reg_read_tgt+0x30>
  90769b:	0000a7        	excw
		addr = *(a_uint32_t *)(data + i);
  90769e:	588b80        	call8	92a4a0 <_etext+0x1f44d>
		addr = adf_os_ntohl(addr);

		val[i/sizeof(a_int32_t)] =
			adf_os_ntohl(ath_reg_read_filter(ah, addr));
  9076a1:	da90      	mov.n	a10, a9
  9076a3:	291620        	s32i	a9, a1, 128
  9076a6:	5bfc16        	call8	906700 <ath_reg_read_filter>

	for (i = 0; i < datalen; i += sizeof(a_int32_t)) {
		addr = *(a_uint32_t *)(data + i);
		addr = adf_os_ntohl(addr);

		val[i/sizeof(a_int32_t)] =
  9076a9:	072814        	srli	a8, a7, 2
  9076ac:	0e8811        	slli	a8, a8, 2
  9076af:	a818      	add.n	a8, a1, a8
	struct ath_hal *ah = sc->sc_ah;
	a_uint32_t addr;
	a_uint32_t val[32];
	int i;

	for (i = 0; i < datalen; i += sizeof(a_int32_t)) {
  9076b1:	291220        	l32i	a9, a1, 128
		addr = *(a_uint32_t *)(data + i);
		addr = adf_os_ntohl(addr);

		val[i/sizeof(a_int32_t)] =
  9076b4:	9a80      	s32i.n	a10, a8, 0
	struct ath_hal *ah = sc->sc_ah;
	a_uint32_t addr;
	a_uint32_t val[32];
	int i;

	for (i = 0; i < datalen; i += sizeof(a_int32_t)) {
  9076b6:	b477      	addi.n	a7, a7, 4
  9076b8:	7672e1        	blt	a7, a6, 90769d <ath_hal_reg_read_tgt+0x15>

		val[i/sizeof(a_int32_t)] =
			adf_os_ntohl(ath_reg_read_filter(ah, addr));
	}

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &val[0], datalen);
  9076bb:	8a23      	l32i.n	a10, a2, 12
  9076bd:	de60      	mov.n	a14, a6
  9076bf:	dd10      	mov.n	a13, a1
  9076c1:	dc40      	mov.n	a12, a4
  9076c3:	db30      	mov.n	a11, a3
  9076c5:	5bfeeb        	call8	907274 <wmi_cmd_rsp>
  9076c8:	d10f      	retw.n
	...

009076cc <ath_vap_create_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_vap_create_tgt(void *Context, A_UINT16 Command, A_UINT16 SeqNo,
			       A_UINT8 *data, a_int32_t datalen)
{
  9076cc:	6c1004        	entry	a1, 32
	vap = (struct ieee80211vap_target *)data;

	vap->iv_rtsthreshold    = adf_os_ntohs(vap->iv_rtsthreshold);
	vap->iv_opmode          = adf_os_ntohl(vap->iv_opmode);

	vap_index = vap->iv_vapindex;
  9076cf:	285000        	l8ui	a8, a5, 0

	adf_os_assert(sc->sc_vap[vap_index].av_valid == 0);
  9076d2:	17728d        	l32r	a7, 8e4108 <vbuf_module_install+0x7c>
  9076d5:	0c8611        	slli	a6, a8, 4
  9076d8:	a866      	add.n	a6, a6, a8
  9076da:	0e6611        	slli	a6, a6, 2
  9076dd:	a626      	add.n	a6, a2, a6
  9076df:	a767      	add.n	a7, a6, a7
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_vap_create_tgt(void *Context, A_UINT16 Command, A_UINT16 SeqNo,
			       A_UINT8 *data, a_int32_t datalen)
{
  9076e1:	db50      	mov.n	a11, a5
	vap->iv_rtsthreshold    = adf_os_ntohs(vap->iv_rtsthreshold);
	vap->iv_opmode          = adf_os_ntohl(vap->iv_opmode);

	vap_index = vap->iv_vapindex;

	adf_os_assert(sc->sc_vap[vap_index].av_valid == 0);
  9076e3:	257000        	l8ui	a5, a7, 0
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_vap_create_tgt(void *Context, A_UINT16 Command, A_UINT16 SeqNo,
			       A_UINT8 *data, a_int32_t datalen)
{
  9076e6:	03034f        	extui	a3, a3, 0, 16
	vap->iv_rtsthreshold    = adf_os_ntohs(vap->iv_rtsthreshold);
	vap->iv_opmode          = adf_os_ntohl(vap->iv_opmode);

	vap_index = vap->iv_vapindex;

	adf_os_assert(sc->sc_vap[vap_index].av_valid == 0);
  9076e9:	005532        	sext	a5, a5, 7
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_vap_create_tgt(void *Context, A_UINT16 Command, A_UINT16 SeqNo,
			       A_UINT8 *data, a_int32_t datalen)
{
  9076ec:	04044f        	extui	a4, a4, 0, 16
	vap->iv_rtsthreshold    = adf_os_ntohs(vap->iv_rtsthreshold);
	vap->iv_opmode          = adf_os_ntohl(vap->iv_opmode);

	vap_index = vap->iv_vapindex;

	adf_os_assert(sc->sc_vap[vap_index].av_valid == 0);
  9076ef:	c851      	beqz.n	a5, 9076f4 <ath_vap_create_tgt+0x28>
  9076f1:	63fffc        	j	9076f1 <ath_vap_create_tgt+0x25>

	adf_os_mem_copy(&(sc->sc_vap[vap_index].av_vap), vap,
  9076f4:	0c8a11        	slli	a10, a8, 4
  9076f7:	a8aa      	add.n	a10, a10, a8
  9076f9:	187289        	l32r	a8, 8e4120 <vbuf_module_install+0x94>
  9076fc:	0eaa11        	slli	a10, a10, 2
  9076ff:	a8aa      	add.n	a10, a10, a8
  907701:	aa2a      	add.n	a10, a2, a10
  907703:	c0cc      	movi.n	a12, 12
  907705:	5bfb46        	call8	906420 <__adf_os_mem_copy>
			VAP_TARGET_SIZE);

	sc->sc_vap[vap_index].av_bcbuf = asf_tailq_first(&(sc->sc_bbuf));
  907708:	18728e        	l32r	a8, 8e4140 <vdesc_module_install+0x4>
	sc->sc_vap[vap_index].av_valid = 1;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  90770b:	de50      	mov.n	a14, a5
	adf_os_assert(sc->sc_vap[vap_index].av_valid == 0);

	adf_os_mem_copy(&(sc->sc_vap[vap_index].av_vap), vap,
			VAP_TARGET_SIZE);

	sc->sc_vap[vap_index].av_bcbuf = asf_tailq_first(&(sc->sc_bbuf));
  90770d:	a866      	add.n	a6, a6, a8
  90770f:	282d16        	addmi	a8, a2, 0x1600
  907712:	888a      	l32i.n	a8, a8, 40
	sc->sc_vap[vap_index].av_valid = 1;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  907714:	dd50      	mov.n	a13, a5
	adf_os_assert(sc->sc_vap[vap_index].av_valid == 0);

	adf_os_mem_copy(&(sc->sc_vap[vap_index].av_vap), vap,
			VAP_TARGET_SIZE);

	sc->sc_vap[vap_index].av_bcbuf = asf_tailq_first(&(sc->sc_bbuf));
  907716:	9860      	s32i.n	a8, a6, 0
	sc->sc_vap[vap_index].av_valid = 1;
  907718:	c061      	movi.n	a6, 1
  90771a:	267400        	s8i	a6, a7, 0

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  90771d:	8a23      	l32i.n	a10, a2, 12
  90771f:	dc40      	mov.n	a12, a4
  907721:	db30      	mov.n	a11, a3
  907723:	5bfed4        	call8	907274 <wmi_cmd_rsp>
  907726:	d10f      	retw.n

00907728 <ath_vap_delete_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_vap_delete_tgt(void *Context, A_UINT16 Command,
			       A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907728:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	a_uint8_t vap_index;

	vap_index = *(a_uint8_t *)data;
  90772b:	2d5000        	l8ui	a13, a5, 0

	sc->sc_vap[vap_index].av_valid = 0;
  90772e:	19728d        	l32r	a9, 8e4164 <vdesc_module_install+0x28>
  907731:	0cd811        	slli	a8, a13, 4
  907734:	ad88      	add.n	a8, a8, a13
  907736:	0e8811        	slli	a8, a8, 2
  907739:	a828      	add.n	a8, a2, a8
  90773b:	a989      	add.n	a9, a8, a9
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_vap_delete_tgt(void *Context, A_UINT16 Command,
			       A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  90773d:	030b4f        	extui	a11, a3, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	a_uint8_t vap_index;

	vap_index = *(a_uint8_t *)data;

	sc->sc_vap[vap_index].av_valid = 0;
  907740:	c030      	movi.n	a3, 0
  907742:	239400        	s8i	a3, a9, 0
	sc->sc_vap[vap_index].av_bcbuf = NULL;
  907745:	13728e        	l32r	a3, 8e4180 <vdesc_module_install+0x44>
  907748:	c090      	movi.n	a9, 0
  90774a:	a388      	add.n	a8, a8, a3
  90774c:	9980      	s32i.n	a9, a8, 0
  90774e:	285a45        	movi	a8, 0x545
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_vap_delete_tgt(void *Context, A_UINT16 Command,
			       A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907751:	040c4f        	extui	a12, a4, 0, 16
  907754:	a828      	add.n	a8, a2, a8
{
	a_int32_t i;

	for (i = 0; i < TARGET_NODE_MAX; i++) {
		if(sc->sc_sta[i].ni.ni_vapindex == vap_index)
			sc->sc_sta[i].an_valid = 0;
  907756:	2f1af7        	movi	a15, 0x1f7
  907759:	2e2a0c        	movi	a14, 0x20c
  90775c:	c0a8      	movi.n	a10, 8
  90775e:	6da80c        	loop	a10, 90776e <ath_vap_delete_tgt+0x46>
static void ath_node_vdelete_tgt(struct ath_softc_tgt *sc, a_uint8_t vap_index)
{
	a_int32_t i;

	for (i = 0; i < TARGET_NODE_MAX; i++) {
		if(sc->sc_sta[i].ni.ni_vapindex == vap_index)
  907761:	238000        	l8ui	a3, a8, 0
  907764:	7d3904        	bne	a3, a13, 90776c <ath_vap_delete_tgt+0x44>
			sc->sc_sta[i].an_valid = 0;
  907767:	af83      	add.n	a3, a8, a15
  907769:	293400        	s8i	a9, a3, 0
  90776c:	ae88      	add.n	a8, a8, a14
	vap_index = *(a_uint8_t *)data;

	sc->sc_vap[vap_index].av_valid = 0;
	sc->sc_vap[vap_index].av_bcbuf = NULL;
	ath_node_vdelete_tgt(sc, vap_index);
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  90776e:	c0e0      	movi.n	a14, 0
  907770:	8a23      	l32i.n	a10, a2, 12
  907772:	0eed02        	or	a13, a14, a14
  907775:	5bfebf        	call8	907274 <wmi_cmd_rsp>
  907778:	d10f      	retw.n
	...

0090777c <ath_node_cleanup_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_node_cleanup_tgt(void *Context, A_UINT16 Command,
				 A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  90777c:	6c1004        	entry	a1, 32
	a_uint8_t node_index;
	a_uint8_t *nodedata;

	nodedata = (a_uint8_t *)data;
	node_index = *nodedata;
	sc->sc_sta[node_index].an_valid = 0;
  90777f:	295000        	l8ui	a9, a5, 0

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  907782:	c0e0      	movi.n	a14, 0
	a_uint8_t node_index;
	a_uint8_t *nodedata;

	nodedata = (a_uint8_t *)data;
	node_index = *nodedata;
	sc->sc_sta[node_index].an_valid = 0;
  907784:	0a9811        	slli	a8, a9, 6
  907787:	a988      	add.n	a8, a8, a9
  907789:	0f8811        	slli	a8, a8, 1
  90778c:	a988      	add.n	a8, a8, a9
  90778e:	0e8811        	slli	a8, a8, 2
  907791:	a828      	add.n	a8, a2, a8
  907793:	297a3c        	movi	a9, 0x73c
  907796:	a988      	add.n	a8, a8, a9
  907798:	c090      	movi.n	a9, 0
  90779a:	298400        	s8i	a9, a8, 0

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  90779d:	8a23      	l32i.n	a10, a2, 12
  90779f:	dde0      	mov.n	a13, a14
  9077a1:	040c4f        	extui	a12, a4, 0, 16
  9077a4:	030b4f        	extui	a11, a3, 0, 16
  9077a7:	5bfeb3        	call8	907274 <wmi_cmd_rsp>
  9077aa:	d10f      	retw.n

009077ac <ath_node_create_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_node_create_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  9077ac:	6c1006        	entry	a1, 48
  9077af:	db50      	mov.n	a11, a5
	a_uint8_t vap_index;
	a_uint8_t node_index;

	node = (struct ieee80211_node_target *)data;

	node_index = node->ni_nodeindex;
  9077b1:	25500c        	l8ui	a5, a5, 12

	node->ni_htcap = adf_os_ntohs(node->ni_htcap);
	node->ni_flags = adf_os_ntohs(node->ni_flags);
	node->ni_maxampdu = adf_os_ntohs(node->ni_maxampdu);

	adf_os_mem_copy(&(sc->sc_sta[node_index].ni), node,
  9077b4:	275a38        	movi	a7, 0x538
  9077b7:	0a5611        	slli	a6, a5, 6
  9077ba:	a569      	add.n	a9, a6, a5
  9077bc:	0f9911        	slli	a9, a9, 1
  9077bf:	a599      	add.n	a9, a9, a5
  9077c1:	0e9911        	slli	a9, a9, 2
  9077c4:	a797      	add.n	a7, a9, a7
  9077c6:	a727      	add.n	a7, a2, a7
  9077c8:	c1c6      	movi.n	a12, 22
  9077ca:	da70      	mov.n	a10, a7
  9077cc:	9910      	s32i.n	a9, a1, 0
  9077ce:	5bfb14        	call8	906420 <__adf_os_mem_copy>
			NODE_TARGET_SIZE);

    	vap_index = sc->sc_sta[node_index].ni.ni_vapindex;
  9077d1:	8910      	l32i.n	a9, a1, 0
  9077d3:	285a45        	movi	a8, 0x545
  9077d6:	a929      	add.n	a9, a2, a9
  9077d8:	a898      	add.n	a8, a9, a8
  9077da:	2a8000        	l8ui	a10, a8, 0
	sc->sc_sta[node_index].ni.ni_vap = &(sc->sc_vap[vap_index].av_vap);
  9077dd:	1c7289        	l32r	a12, 8e4204 <vdesc_module_install+0xc8>
  9077e0:	0ca811        	slli	a8, a10, 4
  9077e3:	aa88      	add.n	a8, a8, a10
  9077e5:	0e8811        	slli	a8, a8, 2
  9077e8:	2b5a58        	movi	a11, 0x558
  9077eb:	ac88      	add.n	a8, a8, a12
  9077ed:	ab9b      	add.n	a11, a9, a11
  9077ef:	a828      	add.n	a8, a2, a8
  9077f1:	98b0      	s32i.n	a8, a11, 0
	if(sc->sc_sta[node_index].ni.ni_is_vapnode == 1)
  9077f3:	285a46        	movi	a8, 0x546
  9077f6:	a899      	add.n	a9, a9, a8
  9077f8:	289000        	l8ui	a8, a9, 0
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_node_create_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  9077fb:	03034f        	extui	a3, a3, 0, 16
  9077fe:	04044f        	extui	a4, a4, 0, 16
	adf_os_mem_copy(&(sc->sc_sta[node_index].ni), node,
			NODE_TARGET_SIZE);

    	vap_index = sc->sc_sta[node_index].ni.ni_vapindex;
	sc->sc_sta[node_index].ni.ni_vap = &(sc->sc_vap[vap_index].av_vap);
	if(sc->sc_sta[node_index].ni.ni_is_vapnode == 1)
  907801:	698111        	bnei	a8, 1, 907816 <ath_node_create_tgt+0x6a>
		sc->sc_vap[vap_index].av_vap.iv_nodeindex = node_index;
  907804:	0ca911        	slli	a9, a10, 4
  907807:	aa99      	add.n	a9, a9, a10
  907809:	0e9911        	slli	a9, a9, 2
  90780c:	18728f        	l32r	a8, 8e4248 <vdesc_module_install+0x10c>
  90780f:	a929      	add.n	a9, a2, a9
  907811:	a899      	add.n	a9, a9, a8
  907813:	259400        	s8i	a5, a9, 0

	sc->sc_sta[node_index].an_valid = 1;
  907816:	a568      	add.n	a8, a6, a5
  907818:	0f8811        	slli	a8, a8, 1
  90781b:	a588      	add.n	a8, a8, a5
  90781d:	0e8811        	slli	a8, a8, 2
  907820:	a828      	add.n	a8, a2, a8
  907822:	257a3c        	movi	a5, 0x73c
  907825:	a585      	add.n	a5, a8, a5
  907827:	c061      	movi.n	a6, 1
  907829:	265400        	s8i	a6, a5, 0
	sc->sc_sta[node_index].ni.ni_txseqmgmt = 0;
  90782c:	255a50        	movi	a5, 0x550
  90782f:	a585      	add.n	a5, a8, a5
  907831:	c060      	movi.n	a6, 0
  907833:	265500        	s16i	a6, a5, 0
	sc->sc_sta[node_index].ni.ni_iv16 = 0;
  907836:	255a52        	movi	a5, 0x552
  907839:	a585      	add.n	a5, a8, a5
  90783b:	265500        	s16i	a6, a5, 0
	sc->sc_sta[node_index].ni.ni_iv32 = 0;
  90783e:	255a54        	movi	a5, 0x554
  907841:	a588      	add.n	a8, a8, a5
  907843:	c050      	movi.n	a5, 0

	owl_tgt_node_init(&sc->sc_sta[node_index]);
  907845:	da70      	mov.n	a10, a7
		sc->sc_vap[vap_index].av_vap.iv_nodeindex = node_index;

	sc->sc_sta[node_index].an_valid = 1;
	sc->sc_sta[node_index].ni.ni_txseqmgmt = 0;
	sc->sc_sta[node_index].ni.ni_iv16 = 0;
	sc->sc_sta[node_index].ni.ni_iv32 = 0;
  907847:	9580      	s32i.n	a5, a8, 0

	owl_tgt_node_init(&sc->sc_sta[node_index]);
  907849:	5807d3        	call8	909798 <owl_tgt_node_init>

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  90784c:	8a23      	l32i.n	a10, a2, 12
  90784e:	de50      	mov.n	a14, a5
  907850:	dd50      	mov.n	a13, a5
  907852:	dc40      	mov.n	a12, a4
  907854:	db30      	mov.n	a11, a3
  907856:	5bfe87        	call8	907274 <wmi_cmd_rsp>
  907859:	d10f      	retw.n
	...

0090785c <ath_setcurmode_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_setcurmode_tgt(void *Context, A_UINT16 Command,
			       A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  90785c:	6c1004        	entry	a1, 32
			   enum ieee80211_phymode mode)
{
	const HAL_RATE_TABLE *rt;
	a_int32_t i;

	adf_os_mem_set(sc->sc_rixmap, 0xff, sizeof(sc->sc_rixmap));
  90785f:	262a08        	movi	a6, 0x208
	a_uint16_t mode;

	mode= *((a_uint16_t *)data);
	mode = adf_os_ntohs(mode);

	ath_setcurmode(sc, mode);
  907862:	255100        	l16ui	a5, a5, 0
 * @param[in] size  buffer size
 */
static inline void
adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
{
    __adf_os_mem_set(buf, b, size);
  907865:	2c1a00        	movi	a12, 0x100
  907868:	2b0aff        	movi	a11, 255
  90786b:	a62a      	add.n	a10, a2, a6
  90786d:	5bfaf1        	call8	906434 <__adf_os_mem_set>
	const HAL_RATE_TABLE *rt;
	a_int32_t i;

	adf_os_mem_set(sc->sc_rixmap, 0xff, sizeof(sc->sc_rixmap));

	rt = sc->sc_rates[mode];
  907870:	285c7c        	addi	a8, a5, 124
  907873:	0e8811        	slli	a8, a8, 2
  907876:	a828      	add.n	a8, a2, a8
  907878:	8983      	l32i.n	a9, a8, 12
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_setcurmode_tgt(void *Context, A_UINT16 Command,
			       A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  90787a:	03034f        	extui	a3, a3, 0, 16
  90787d:	04044f        	extui	a4, a4, 0, 16
	a_int32_t i;

	adf_os_mem_set(sc->sc_rixmap, 0xff, sizeof(sc->sc_rixmap));

	rt = sc->sc_rates[mode];
	adf_os_assert(rt != NULL);
  907880:	c898      	beqz.n	a9, 90788c <ath_setcurmode_tgt+0x30>

	for (i = 0; i < rt->rateCount; i++) {
  907882:	8c90      	l32i.n	a12, a9, 0
  907884:	2b9c30        	addi	a11, a9, 48
  907887:	c0a0      	movi.n	a10, 0
  907889:	600012        	j	90789f <ath_setcurmode_tgt+0x43>
  90788c:	63fffc        	j	90788c <ath_setcurmode_tgt+0x30>
  90788f:	0028b0        	excw
		sc->sc_rixmap[rt->info[i].rateCode] = i;
  907892:	002bbc        	excw
  907895:	10a828        	l32r	a0, 8f1938 <memset+0xc79c>
  907898:	a688      	add.n	a8, a8, a6
  90789a:	2a8400        	s8i	a10, a8, 0
	adf_os_mem_set(sc->sc_rixmap, 0xff, sizeof(sc->sc_rixmap));

	rt = sc->sc_rates[mode];
	adf_os_assert(rt != NULL);

	for (i = 0; i < rt->rateCount; i++) {
  90789d:	b1aa      	addi.n	a10, a10, 1
  90789f:	7ca2ed        	blt	a10, a12, 907890 <ath_setcurmode_tgt+0x34>
		sc->sc_rixmap[rt->info[i].rateCode] = i;
	}

	sc->sc_currates = rt;
	sc->sc_curmode = mode;
  9078a2:	2526c2        	s32i	a5, a2, 0x308
	sc->sc_protrix = ((mode == IEEE80211_MODE_11NG) ? 3 : 0);
  9078a5:	c0d0      	movi.n	a13, 0
  9078a7:	b055      	addi.n	a5, a5, -1
  9078a9:	c063      	movi.n	a6, 3
  9078ab:	05d639        	movnez	a6, a13, a5
  9078ae:	d560      	mov.n	a5, a6

	for (i = 0; i < rt->rateCount; i++) {
		sc->sc_rixmap[rt->info[i].rateCode] = i;
	}

	sc->sc_currates = rt;
  9078b0:	292681        	s32i	a9, a2, 0x204
	sc->sc_curmode = mode;
	sc->sc_protrix = ((mode == IEEE80211_MODE_11NG) ? 3 : 0);
  9078b3:	262d03        	addmi	a6, a2, 0x300
  9078b6:	25640c        	s8i	a5, a6, 12
	mode= *((a_uint16_t *)data);
	mode = adf_os_ntohs(mode);

	ath_setcurmode(sc, mode);

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  9078b9:	8a23      	l32i.n	a10, a2, 12
  9078bb:	ded0      	mov.n	a14, a13
  9078bd:	dc40      	mov.n	a12, a4
  9078bf:	db30      	mov.n	a11, a3
  9078c1:	5bfe6c        	call8	907274 <wmi_cmd_rsp>
  9078c4:	d10f      	retw.n
	...

009078c8 <ath_flushrecv_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo,NULL, 0);
}

static void ath_flushrecv_tgt(void *Context, A_UINT16 Command,
			      A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  9078c8:	6c1004        	entry	a1, 32
  9078cb:	03034f        	extui	a3, a3, 0, 16
  9078ce:	04044f        	extui	a4, a4, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_rx_buf *bf;

	asf_tailq_foreach(bf, &sc->sc_rxbuf, bf_list)
  9078d1:	2522d5        	l32i	a5, a2, 0x354
  9078d4:	60002e        	j	907906 <ath_flushrecv_tgt+0x3e>
  9078d7:	000000        	ill
		if (bf->bf_skb != NULL) {
  9078da:	8658      	l32i.n	a6, a5, 32
  9078dc:	ca64      	beqz.n	a6, 907904 <ath_flushrecv_tgt+0x3c>
static inline void
adf_nbuf_unmap(adf_os_device_t      osdev, 
               adf_os_dma_map_t     bmap, 
               adf_os_dma_dir_t     dir)
{
    __adf_nbuf_unmap(osdev, bmap, dir);
  9078de:	8b50      	l32i.n	a11, a5, 0
  9078e0:	2a2246        	l32i	a10, a2, 0x118
  9078e3:	c0c1      	movi.n	a12, 1
  9078e5:	5beefc        	call8	9034d8 <__adf_nbuf_unmap>
			adf_nbuf_unmap(sc->sc_dev, bf->bf_dmamap,
				       ADF_OS_DMA_FROM_DEVICE);
			ath_free_rx_skb(sc, adf_nbuf_queue_remove(&bf->bf_skbhead));
  9078e8:	18716e        	l32r	a8, 8e3ea0 <mUsbEPinHighBandSet+0x190>
  9078eb:	8720      	l32i.n	a7, a2, 0
 * @return The head buf in the buf queue.
 */
static inline adf_nbuf_t
adf_nbuf_queue_remove(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_remove(head);
  9078ed:	2a5c14        	addi	a10, a5, 20
  9078f0:	2682a3        	l32i	a6, a8, 0x28c
  9078f3:	5beee5        	call8	903488 <__adf_nbuf_queue_remove>
  9078f6:	dca0      	mov.n	a12, a10
  9078f8:	2b0a03        	movi	a11, 3
  9078fb:	da70      	mov.n	a10, a7
  9078fd:	0b6000        	callx8	a6
			bf->bf_skb = NULL;
  907900:	c080      	movi.n	a8, 0
  907902:	9858      	s32i.n	a8, a5, 32
			      A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_rx_buf *bf;

	asf_tailq_foreach(bf, &sc->sc_rxbuf, bf_list)
  907904:	8559      	l32i.n	a5, a5, 36
  907906:	655fd0        	bnez	a5, 9078da <ath_flushrecv_tgt+0x12>
				       ADF_OS_DMA_FROM_DEVICE);
			ath_free_rx_skb(sc, adf_nbuf_queue_remove(&bf->bf_skbhead));
			bf->bf_skb = NULL;
		}

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  907909:	8a23      	l32i.n	a10, a2, 12
  90790b:	de50      	mov.n	a14, a5
  90790d:	dd50      	mov.n	a13, a5
  90790f:	dc40      	mov.n	a12, a4
  907911:	db30      	mov.n	a11, a3
  907913:	5bfe58        	call8	907274 <wmi_cmd_rsp>
  907916:	d10f      	retw.n

00907918 <ath_stoprecv_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_stoprecv_tgt(void *Context, A_UINT16 Command,
			     A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907918:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  90791b:	252d05        	addmi	a5, a2, 0x500
  90791e:	855b      	l32i.n	a5, a5, 44
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_stoprecv_tgt(void *Context, A_UINT16 Command,
			     A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907920:	03034f        	extui	a3, a3, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;

	ah->ah_stopPcuReceive(ah);
  907923:	285224        	l32i	a8, a5, 144
  907926:	055a02        	or	a10, a5, a5
  907929:	0b8000        	callx8	a8
	ah->ah_setRxFilter(ah, 0);
  90792c:	8859      	l32i.n	a8, a5, 36
  90792e:	c0b0      	movi.n	a11, 0
  907930:	da50      	mov.n	a10, a5
  907932:	0b8000        	callx8	a8
	ah->ah_stopDmaReceive(ah);
  907935:	285223        	l32i	a8, a5, 140
  907938:	da50      	mov.n	a10, a5
  90793a:	0b8000        	callx8	a8

	sc->sc_rxlink = NULL;
  90793d:	c0d0      	movi.n	a13, 0
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_stoprecv_tgt(void *Context, A_UINT16 Command,
			     A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  90793f:	04044f        	extui	a4, a4, 0, 16
	ah->ah_stopPcuReceive(ah);
	ah->ah_setRxFilter(ah, 0);
	ah->ah_stopDmaReceive(ah);

	sc->sc_rxlink = NULL;
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  907942:	8a23      	l32i.n	a10, a2, 12

	ah->ah_stopPcuReceive(ah);
	ah->ah_setRxFilter(ah, 0);
	ah->ah_stopDmaReceive(ah);

	sc->sc_rxlink = NULL;
  907944:	2d26ef        	s32i	a13, a2, 0x3bc
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  907947:	ded0      	mov.n	a14, a13
  907949:	dc40      	mov.n	a12, a4
  90794b:	db30      	mov.n	a11, a3
  90794d:	5bfe49        	call8	907274 <wmi_cmd_rsp>
  907950:	d10f      	retw.n
	...

00907954 <ath_startrecv_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_startrecv_tgt(void *Context, A_UINT16 Command,
			      A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907954:	6c1004        	entry	a1, 32
#undef PA2DESC
}

static a_int32_t ath_startrecv(struct ath_softc_tgt *sc)
{
	struct ath_hal *ah = sc->sc_ah;
  907957:	252d05        	addmi	a5, a2, 0x500
  90795a:	865b      	l32i.n	a6, a5, 44
	struct ath_rx_desc *ds;

	sc->sc_rxbufsize = 1024+512+128;
  90795c:	256a80        	movi	a5, 0x680
  90795f:	25264a        	s32i	a5, a2, 0x128
	sc->sc_rxlink = NULL;
  907962:	c050      	movi.n	a5, 0
  907964:	2526ef        	s32i	a5, a2, 0x3bc

	sc->sc_rxdesc_held = NULL;
  907967:	2526db        	s32i	a5, a2, 0x36c
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_startrecv_tgt(void *Context, A_UINT16 Command,
			      A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  90796a:	03034f        	extui	a3, a3, 0, 16
  90796d:	04044f        	extui	a4, a4, 0, 16
	sc->sc_rxbufsize = 1024+512+128;
	sc->sc_rxlink = NULL;

	sc->sc_rxdesc_held = NULL;

	asf_tailq_foreach(ds, &sc->sc_rxdesc, ds_list) {
  907970:	2522d9        	l32i	a5, a2, 0x364
  907973:	600027        	j	90799e <ath_startrecv_tgt+0x4a>
		a_int32_t error = ath_rxdesc_init(sc, ds);
  907976:	db50      	mov.n	a11, a5
  907978:	da20      	mov.n	a10, a2
  90797a:	5bfbe7        	call8	906918 <ath_rxdesc_init>
		if (error != 0) {
  90797d:	65a049        	bnez	a10, 9079ca <ath_startrecv_tgt+0x76>
	sc->sc_rxbufsize = 1024+512+128;
	sc->sc_rxlink = NULL;

	sc->sc_rxdesc_held = NULL;

	asf_tailq_foreach(ds, &sc->sc_rxdesc, ds_list) {
  907980:	29504c        	l8ui	a9, a5, 76
  907983:	28504d        	l8ui	a8, a5, 77
  907986:	089910        	slli	a9, a9, 24
  907989:	008811        	slli	a8, a8, 16
  90798c:	098902        	or	a9, a8, a9
  90798f:	28504e        	l8ui	a8, a5, 78
  907992:	25504f        	l8ui	a5, a5, 79
  907995:	088811        	slli	a8, a8, 8
  907998:	098802        	or	a8, a8, a9
  90799b:	085502        	or	a5, a5, a8
  90799e:	655fd4        	bnez	a5, 907976 <ath_startrecv_tgt+0x22>
			return error;
		}
	}

	ds = asf_tailq_first(&sc->sc_rxdesc);
	ah->ah_setRxDP(ah, ds->ds_daddr);
  9079a1:	2822d9        	l32i	a8, a2, 0x364
  9079a4:	da60      	mov.n	a10, a6
  9079a6:	258048        	l8ui	a5, a8, 72
  9079a9:	2b8049        	l8ui	a11, a8, 73
  9079ac:	085510        	slli	a5, a5, 24
  9079af:	00bb11        	slli	a11, a11, 16
  9079b2:	05bb02        	or	a11, a11, a5
  9079b5:	25804a        	l8ui	a5, a8, 74
  9079b8:	085511        	slli	a5, a5, 8
  9079bb:	0b5502        	or	a5, a5, a11
  9079be:	2b804b        	l8ui	a11, a8, 75
  9079c1:	28621f        	l32i	a8, a6, 124
  9079c4:	05bb02        	or	a11, a11, a5
  9079c7:	0b8000        	callx8	a8
{

	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;

	ath_startrecv(sc);
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  9079ca:	c0e0      	movi.n	a14, 0
  9079cc:	8a23      	l32i.n	a10, a2, 12
  9079ce:	dde0      	mov.n	a13, a14
  9079d0:	dc40      	mov.n	a12, a4
  9079d2:	033b02        	or	a11, a3, a3
  9079d5:	5bfe27        	call8	907274 <wmi_cmd_rsp>
  9079d8:	d10f      	retw.n
	...

009079dc <ath_draintxq_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_draintxq_tgt(void *Context, A_UINT16 Command,
			     A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  9079dc:	6c1006        	entry	a1, 48
  9079df:	04044f        	extui	a4, a4, 0, 16
	a_uint16_t i;
	struct ath_txq *txq = NULL;
	struct ath_atx_tid *tid = NULL;

	ath_tx_status_clear(sc);
	sc->sc_tx_draining = 1;
  9079e2:	252d01        	addmi	a5, a2, 0x100
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_draintxq_tgt(void *Context, A_UINT16 Command,
			     A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  9079e5:	03034f        	extui	a3, a3, 0, 16
  9079e8:	9411      	s32i.n	a4, a1, 4
	struct ath_hal *ah = sc->sc_ah;
	a_uint16_t i;
	struct ath_txq *txq = NULL;
	struct ath_atx_tid *tid = NULL;

	ath_tx_status_clear(sc);
  9079ea:	022a02        	or	a10, a2, a2
	owltgt_txq_drain(sc, txq);
}

static void ath_draintxq(struct ath_softc_tgt *sc, HAL_BOOL drain_softq)
{
	struct ath_hal *ah = sc->sc_ah;
  9079ed:	242d05        	addmi	a4, a2, 0x500
  9079f0:	27420b        	l32i	a7, a4, 44
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_draintxq_tgt(void *Context, A_UINT16 Command,
			     A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  9079f3:	9310      	s32i.n	a3, a1, 0
	struct ath_hal *ah = sc->sc_ah;
	a_uint16_t i;
	struct ath_txq *txq = NULL;
	struct ath_atx_tid *tid = NULL;

	ath_tx_status_clear(sc);
  9079f5:	580779        	call8	9097dc <ath_tx_status_clear>
	sc->sc_tx_draining = 1;
  9079f8:	265024        	l8ui	a6, a5, 36
  9079fb:	c480      	movi.n	a8, 64
  9079fd:	086602        	or	a6, a6, a8
  907a00:	265424        	s8i	a6, a5, 36

	ah->ah_stopTxDma(ah, sc->sc_bhalq);
  907a03:	867d      	l32i.n	a6, a7, 52
  907a05:	2b501c        	l8ui	a11, a5, 28
  907a08:	da70      	mov.n	a10, a7
  907a0a:	0b6000        	callx8	a6
  907a0d:	283acc        	movi	a8, 0x3cc
  907a10:	a823      	add.n	a3, a2, a8
  907a12:	d930      	mov.n	a9, a3
  907a14:	c070      	movi.n	a7, 0

	for (i = 0; i < HAL_NUM_TX_QUEUES; i++)
		if (ATH_TXQ_SETUP(sc, i))
  907a16:	262d03        	addmi	a6, a2, 0x300
  907a19:	2a60c8        	l8ui	a10, a6, 200
  907a1c:	007004        	ssr	a7
  907a1f:	0a0a1b        	sra	a10, a10
  907a22:	7fa70c        	bbci	a10, 31, 907a32 <ath_draintxq_tgt+0x56>
  907a25:	8a4b      	l32i.n	a10, a4, 44

static void ath_tx_stopdma(struct ath_softc_tgt *sc, struct ath_txq *txq)
{
	struct ath_hal *ah = sc->sc_ah;

	ah->ah_stopTxDma(ah, txq->axq_qnum);
  907a27:	8b90      	l32i.n	a11, a9, 0
  907a29:	8dad      	l32i.n	a13, a10, 52
  907a2b:	9912      	s32i.n	a9, a1, 8
  907a2d:	0bd000        	callx8	a13
  907a30:	8912      	l32i.n	a9, a1, 8
  907a32:	b177      	addi.n	a7, a7, 1
  907a34:	299c20        	addi	a9, a9, 32
	ath_tx_status_clear(sc);
	sc->sc_tx_draining = 1;

	ah->ah_stopTxDma(ah, sc->sc_bhalq);

	for (i = 0; i < HAL_NUM_TX_QUEUES; i++)
  907a37:	6979de        	bnei	a7, 10, 907a19 <ath_draintxq_tgt+0x3d>
  907a3a:	270a00        	movi	a7, 0
			txq = ATH_TXQ(sc,i);
			while (!asf_tailq_empty(&txq->axq_tidq)){
				TAILQ_DEQ(&txq->axq_tidq, tid, tid_qelem);
				if(tid == NULL)
					break;
				tid->sched = AH_FALSE;
  907a3d:	077402        	or	a4, a7, a7
	for (i = 0; i < HAL_NUM_TX_QUEUES; i++)
		if (ATH_TXQ_SETUP(sc, i))
			ath_tx_stopdma(sc, ATH_TXQ(sc, i));

	for (i = 0; i < HAL_NUM_TX_QUEUES; i++)
		if (ATH_TXQ_SETUP(sc, i)) {
  907a40:	2a60c8        	l8ui	a10, a6, 200
  907a43:	007004        	ssr	a7
  907a46:	0a0a1b        	sra	a10, a10
  907a49:	7faf0b        	bbsi	a10, 31, 907a58 <ath_draintxq_tgt+0x7c>
  907a4c:	b177      	addi.n	a7, a7, 1
  907a4e:	233c20        	addi	a3, a3, 32

	for (i = 0; i < HAL_NUM_TX_QUEUES; i++)
		if (ATH_TXQ_SETUP(sc, i))
			ath_tx_stopdma(sc, ATH_TXQ(sc, i));

	for (i = 0; i < HAL_NUM_TX_QUEUES; i++)
  907a51:	6979eb        	bnei	a7, 10, 907a40 <ath_draintxq_tgt+0x64>
  907a54:	60002e        	j	907a86 <ath_draintxq_tgt+0xaa>
  907a57:	00c0c1        	excw
		if (ATH_TXQ_SETUP(sc, i)) {
			owltgt_tx_processq(sc, ATH_TXQ(sc,i), OWL_TXQ_STOPPED);
  907a5a:	db30      	mov.n	a11, a3
  907a5c:	da20      	mov.n	a10, a2
  907a5e:	580b56        	call8	90a7b8 <owltgt_tx_processq>
  907a61:	600019        	j	907a7e <ath_draintxq_tgt+0xa2>

			txq = ATH_TXQ(sc,i);
			while (!asf_tailq_empty(&txq->axq_tidq)){
				TAILQ_DEQ(&txq->axq_tidq, tid, tid_qelem);
  907a64:	8ab9      	l32i.n	a10, a11, 36
  907a66:	8cba      	l32i.n	a12, a11, 40
  907a68:	c8a4      	beqz.n	a10, 907a70 <ath_draintxq_tgt+0x94>
  907a6a:	9caa      	s32i.n	a12, a10, 40
  907a6c:	600002        	j	907a72 <ath_draintxq_tgt+0x96>
  907a6f:	009c37        	maxu	a12, a9, a0
  907a72:	8cba      	l32i.n	a12, a11, 40
  907a74:	9ac0      	s32i.n	a10, a12, 0
				if(tid == NULL)
					break;
				tid->sched = AH_FALSE;
  907a76:	24b435        	s8i	a4, a11, 53
				ath_tgt_tid_drain(sc,tid);
  907a79:	da20      	mov.n	a10, a2
  907a7b:	58083f        	call8	909b78 <ath_tgt_tid_drain>
	for (i = 0; i < HAL_NUM_TX_QUEUES; i++)
		if (ATH_TXQ_SETUP(sc, i)) {
			owltgt_tx_processq(sc, ATH_TXQ(sc,i), OWL_TXQ_STOPPED);

			txq = ATH_TXQ(sc,i);
			while (!asf_tailq_empty(&txq->axq_tidq)){
  907a7e:	8b36      	l32i.n	a11, a3, 24
  907a80:	65bfe0        	bnez	a11, 907a64 <ath_draintxq_tgt+0x88>
  907a83:	63ffc5        	j	907a4c <ath_draintxq_tgt+0x70>
				tid->sched = AH_FALSE;
				ath_tgt_tid_drain(sc,tid);
			}
		}

	sc->sc_tx_draining = 0;
  907a86:	265024        	l8ui	a6, a5, 36
  907a89:	27fabf        	movi	a7, -65
  907a8c:	076601        	and	a6, a6, a7
  907a8f:	265424        	s8i	a6, a5, 36
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	HAL_BOOL b = (HAL_BOOL) *(a_int32_t *)data;

	ath_draintxq(Context, b);
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  907a92:	c0e0      	movi.n	a14, 0
  907a94:	8c11      	l32i.n	a12, a1, 4
  907a96:	8b10      	l32i.n	a11, a1, 0
  907a98:	8a23      	l32i.n	a10, a2, 12
  907a9a:	0eed02        	or	a13, a14, a14
  907a9d:	5bfdf5        	call8	907274 <wmi_cmd_rsp>
  907aa0:	d10f      	retw.n
	...

00907aa4 <ath_tx_draintxq_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_tx_draintxq_tgt(void *Context, A_UINT16 Command, A_UINT16 SeqNo,
				A_UINT8 *data, a_int32_t datalen)
{
  907aa4:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	a_uint32_t q = *(a_uint32_t *)data;
	struct ath_txq *txq = NULL;

	q = adf_os_ntohl(q);
	txq = ATH_TXQ(sc, q);
  907aa7:	8b50      	l32i.n	a11, a5, 0
	ah->ah_stopTxDma(ah, txq->axq_qnum);
}

static void owltgt_txq_drain(struct ath_softc_tgt *sc, struct ath_txq *txq)
{
	owltgt_tx_processq(sc, txq, OWL_TXQ_STOPPED);
  907aa9:	da20      	mov.n	a10, a2
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	a_uint32_t q = *(a_uint32_t *)data;
	struct ath_txq *txq = NULL;

	q = adf_os_ntohl(q);
	txq = ATH_TXQ(sc, q);
  907aab:	2bbc1e        	addi	a11, a11, 30
  907aae:	0bbb11        	slli	a11, a11, 5
  907ab1:	bcbb      	addi.n	a11, a11, 12
	ah->ah_stopTxDma(ah, txq->axq_qnum);
}

static void owltgt_txq_drain(struct ath_softc_tgt *sc, struct ath_txq *txq)
{
	owltgt_tx_processq(sc, txq, OWL_TXQ_STOPPED);
  907ab3:	0b2b08        	add	a11, a2, a11
  907ab6:	2c0a01        	movi	a12, 1
  907ab9:	580b3f        	call8	90a7b8 <owltgt_tx_processq>
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_tx_draintxq_tgt(void *Context, A_UINT16 Command, A_UINT16 SeqNo,
				A_UINT8 *data, a_int32_t datalen)
{
  907abc:	03034f        	extui	a3, a3, 0, 16
  907abf:	04044f        	extui	a4, a4, 0, 16

	q = adf_os_ntohl(q);
	txq = ATH_TXQ(sc, q);

	ath_tx_draintxq(sc, txq);
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  907ac2:	c0e0      	movi.n	a14, 0
  907ac4:	8a23      	l32i.n	a10, a2, 12
  907ac6:	dde0      	mov.n	a13, a14
  907ac8:	dc40      	mov.n	a12, a4
  907aca:	033b02        	or	a11, a3, a3
  907acd:	5bfde9        	call8	907274 <wmi_cmd_rsp>
  907ad0:	d10f      	retw.n
	...

00907ad4 <ath_aborttx_dma_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_aborttx_dma_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907ad4:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  907ad7:	282d05        	addmi	a8, a2, 0x500
  907ada:	8a8b      	l32i.n	a10, a8, 44
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_aborttx_dma_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907adc:	03034f        	extui	a3, a3, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;

	ah->ah_abortTxDma(sc->sc_ah);
  907adf:	28a20e        	l32i	a8, a10, 56
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_aborttx_dma_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907ae2:	04044f        	extui	a4, a4, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;

	ah->ah_abortTxDma(sc->sc_ah);
  907ae5:	0b8000        	callx8	a8
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  907ae8:	c0e0      	movi.n	a14, 0
  907aea:	8a23      	l32i.n	a10, a2, 12
  907aec:	dde0      	mov.n	a13, a14
  907aee:	dc40      	mov.n	a12, a4
  907af0:	db30      	mov.n	a11, a3
  907af2:	5bfde0        	call8	907274 <wmi_cmd_rsp>
  907af5:	d10f      	retw.n
	...

00907af8 <ath_stop_tx_dma_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_stop_tx_dma_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907af8:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  907afb:	282d05        	addmi	a8, a2, 0x500
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_stop_tx_dma_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907afe:	03034f        	extui	a3, a3, 0, 16
  907b01:	04044f        	extui	a4, a4, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  907b04:	8a8b      	l32i.n	a10, a8, 44
	a_uint32_t q;

	if (data)
  907b06:	c850      	beqz.n	a5, 907b0a <ath_stop_tx_dma_tgt+0x12>
		q = *(a_uint32_t *)data;
  907b08:	8b50      	l32i.n	a11, a5, 0

	q = adf_os_ntohl(q);
	ah->ah_stopTxDma(ah, q);
  907b0a:	85ad      	l32i.n	a5, a10, 52
  907b0c:	0b5000        	callx8	a5
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  907b0f:	c0e0      	movi.n	a14, 0
  907b11:	8a23      	l32i.n	a10, a2, 12
  907b13:	dde0      	mov.n	a13, a14
  907b15:	dc40      	mov.n	a12, a4
  907b17:	db30      	mov.n	a11, a3
  907b19:	5bfdd6        	call8	907274 <wmi_cmd_rsp>
  907b1c:	d10f      	retw.n
	...

00907b20 <ath_aborttxq_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_aborttxq_tgt(void *Context, A_UINT16 Command,
			     A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907b20:	6c1004        	entry	a1, 32
  907b23:	253acc        	movi	a5, 0x3cc
  907b26:	03034f        	extui	a3, a3, 0, 16
  907b29:	04044f        	extui	a4, a4, 0, 16
  907b2c:	a525      	add.n	a5, a2, a5
  907b2e:	260a00        	movi	a6, 0

	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	a_uint16_t i;

	for (i = 0; i < HAL_NUM_TX_QUEUES; i++) {
		if (ATH_TXQ_SETUP(sc, i))
  907b31:	272d03        	addmi	a7, a2, 0x300
  907b34:	2870c8        	l8ui	a8, a7, 200
  907b37:	006004        	ssr	a6
  907b3a:	08081b        	sra	a8, a8
  907b3d:	7f8708        	bbci	a8, 31, 907b49 <ath_aborttxq_tgt+0x29>
	ah->ah_stopTxDma(ah, txq->axq_qnum);
}

static void owltgt_txq_drain(struct ath_softc_tgt *sc, struct ath_txq *txq)
{
	owltgt_tx_processq(sc, txq, OWL_TXQ_STOPPED);
  907b40:	c0c1      	movi.n	a12, 1
  907b42:	db50      	mov.n	a11, a5
  907b44:	da20      	mov.n	a10, a2
  907b46:	580b1c        	call8	90a7b8 <owltgt_tx_processq>
  907b49:	b166      	addi.n	a6, a6, 1
  907b4b:	255c20        	addi	a5, a5, 32
{

	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	a_uint16_t i;

	for (i = 0; i < HAL_NUM_TX_QUEUES; i++) {
  907b4e:	6969e2        	bnei	a6, 10, 907b34 <ath_aborttxq_tgt+0x14>
		if (ATH_TXQ_SETUP(sc, i))
			ath_tx_draintxq(sc, ATH_TXQ(sc,i));
	}

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  907b51:	c0e0      	movi.n	a14, 0
  907b53:	8a23      	l32i.n	a10, a2, 12
  907b55:	dde0      	mov.n	a13, a14
  907b57:	dc40      	mov.n	a12, a4
  907b59:	db30      	mov.n	a11, a3
  907b5b:	5bfdc6        	call8	907274 <wmi_cmd_rsp>
  907b5e:	d10f      	retw.n

00907b60 <ath_init_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo,NULL, 0);
}

static void ath_init_tgt(void *Context, A_UINT16 Command,
			 A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907b60:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  907b63:	252d05        	addmi	a5, a2, 0x500
  907b66:	25520b        	l32i	a5, a5, 44

	sc->sc_imask = HAL_INT_RX | HAL_INT_TX
		| HAL_INT_RXEOL | HAL_INT_RXORN
		| HAL_INT_FATAL | HAL_INT_GLOBAL;

	sc->sc_imask |= HAL_INT_GTT;
  907b69:	187290        	l32r	a8, 8e45ac <vdesc_module_install+0x470>

	if (ath_hal_getcapability(ah, HAL_CAP_HT))
  907b6c:	2b0a05        	movi	a11, 5

	sc->sc_imask = HAL_INT_RX | HAL_INT_TX
		| HAL_INT_RXEOL | HAL_INT_RXORN
		| HAL_INT_FATAL | HAL_INT_GLOBAL;

	sc->sc_imask |= HAL_INT_GTT;
  907b6f:	2826c4        	s32i	a8, a2, 0x310

	if (ath_hal_getcapability(ah, HAL_CAP_HT))
  907b72:	055a02        	or	a10, a5, a5
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo,NULL, 0);
}

static void ath_init_tgt(void *Context, A_UINT16 Command,
			 A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907b75:	03034f        	extui	a3, a3, 0, 16
  907b78:	04044f        	extui	a4, a4, 0, 16
		| HAL_INT_RXEOL | HAL_INT_RXORN
		| HAL_INT_FATAL | HAL_INT_GLOBAL;

	sc->sc_imask |= HAL_INT_GTT;

	if (ath_hal_getcapability(ah, HAL_CAP_HT))
  907b7b:	5bf50a        	call8	904fa4 <ath_hal_getcapability>
  907b7e:	c8aa      	beqz.n	a10, 907b8c <ath_init_tgt+0x2c>
		sc->sc_imask |= HAL_INT_CST;
  907b80:	2822c4        	l32i	a8, a2, 0x310
  907b83:	197252        	l32r	a9, 8e44cc <vdesc_module_install+0x390>
  907b86:	098802        	or	a8, a8, a9
  907b89:	2826c4        	s32i	a8, a2, 0x310
  907b8c:	1b726e        	l32r	a11, 8e4544 <vdesc_module_install+0x408>
  907b8f:	2a2246        	l32i	a10, a2, 0x118
  907b92:	5bfa18        	call8	9063f4 <__adf_os_setup_intr>

	adf_os_setup_intr(sc->sc_dev, ath_intr);
	ah->ah_setInterrupts(ah, sc->sc_imask);
  907b95:	2b22c4        	l32i	a11, a2, 0x310
  907b98:	285228        	l32i	a8, a5, 160
  907b9b:	da50      	mov.n	a10, a5
  907b9d:	0b8000        	callx8	a8

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  907ba0:	c0e0      	movi.n	a14, 0
  907ba2:	8a23      	l32i.n	a10, a2, 12
  907ba4:	dde0      	mov.n	a13, a14
  907ba6:	dc40      	mov.n	a12, a4
  907ba8:	db30      	mov.n	a11, a3
  907baa:	5bfdb2        	call8	907274 <wmi_cmd_rsp>
  907bad:	d10f      	retw.n
	...

00907bb0 <ath_enable_intr_tgt>:
/* WMI Commands */
/****************/

static void ath_enable_intr_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907bb0:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  907bb3:	282d05        	addmi	a8, a2, 0x500
/* WMI Commands */
/****************/

static void ath_enable_intr_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907bb6:	03034f        	extui	a3, a3, 0, 16
  907bb9:	04044f        	extui	a4, a4, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  907bbc:	8a8b      	l32i.n	a10, a8, 44
	a_uint32_t intr;

	if (data)
  907bbe:	645002        	beqz	a5, 907bc4 <ath_enable_intr_tgt+0x14>
		intr = (*(a_uint32_t *)data);
  907bc1:	2b5200        	l32i	a11, a5, 0

	intr = adf_os_ntohl(intr);

	if (intr & HAL_INT_SWBA) {
  907bc4:	1971f7        	l32r	a9, 8e43a0 <vdesc_module_install+0x264>
  907bc7:	2822c4        	l32i	a8, a2, 0x310
  907bca:	79b006        	bnone	a11, a9, 907bd4 <ath_enable_intr_tgt+0x24>
		sc->sc_imask |= HAL_INT_SWBA;
  907bcd:	098802        	or	a8, a8, a9
  907bd0:	600006        	j	907bda <ath_enable_intr_tgt+0x2a>
  907bd3:	001572        	excw
	} else {
		sc->sc_imask &= ~HAL_INT_SWBA;
  907bd6:	9105      	s32i.n	a1, a0, 20
  907bd8:	8801      	l32i.n	a8, a0, 4
	}

	if (intr & HAL_INT_BMISS) {
  907bda:	197292        	l32r	a9, 8e4624 <vdesc_module_install+0x4e8>
	intr = adf_os_ntohl(intr);

	if (intr & HAL_INT_SWBA) {
		sc->sc_imask |= HAL_INT_SWBA;
	} else {
		sc->sc_imask &= ~HAL_INT_SWBA;
  907bdd:	2826c4        	s32i	a8, a2, 0x310
	}

	if (intr & HAL_INT_BMISS) {
  907be0:	79b008        	bnone	a11, a9, 907bec <ath_enable_intr_tgt+0x3c>
		sc->sc_imask |= HAL_INT_BMISS;
  907be3:	2822c4        	l32i	a8, a2, 0x310
  907be6:	098802        	or	a8, a8, a9
  907be9:	2826c4        	s32i	a8, a2, 0x310
	}

	ah->ah_setInterrupts(ah, sc->sc_imask);
  907bec:	2b22c4        	l32i	a11, a2, 0x310
  907bef:	25a228        	l32i	a5, a10, 160
  907bf2:	0b5000        	callx8	a5
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo,NULL, 0);
  907bf5:	c0e0      	movi.n	a14, 0
  907bf7:	8a23      	l32i.n	a10, a2, 12
  907bf9:	dde0      	mov.n	a13, a14
  907bfb:	dc40      	mov.n	a12, a4
  907bfd:	db30      	mov.n	a11, a3
  907bff:	5bfd9d        	call8	907274 <wmi_cmd_rsp>
  907c02:	d10f      	retw.n

00907c04 <ath_disable_intr_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_disable_intr_tgt(void *Context, A_UINT16 Command,
				 A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907c04:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  907c07:	282d05        	addmi	a8, a2, 0x500
  907c0a:	8a8b      	l32i.n	a10, a8, 44

	ah->ah_setInterrupts(ah, 0);
  907c0c:	2b0a00        	movi	a11, 0
  907c0f:	28a228        	l32i	a8, a10, 160
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_disable_intr_tgt(void *Context, A_UINT16 Command,
				 A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907c12:	03034f        	extui	a3, a3, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;

	ah->ah_setInterrupts(ah, 0);
  907c15:	0b8000        	callx8	a8
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_disable_intr_tgt(void *Context, A_UINT16 Command,
				 A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907c18:	04044f        	extui	a4, a4, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;

	ah->ah_setInterrupts(ah, 0);
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo,NULL, 0);
  907c1b:	c0e0      	movi.n	a14, 0
  907c1d:	8a23      	l32i.n	a10, a2, 12
  907c1f:	dde0      	mov.n	a13, a14
  907c21:	dc40      	mov.n	a12, a4
  907c23:	db30      	mov.n	a11, a3
  907c25:	5bfd93        	call8	907274 <wmi_cmd_rsp>
  907c28:	d10f      	retw.n
	...

00907c2c <ath_get_tgt_version>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
}

static void ath_get_tgt_version(void *Context,A_UINT16 Command, A_UINT16 SeqNo,
				A_UINT8 *data, a_int32_t datalen)
{
  907c2c:	6c1006        	entry	a1, 48
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_fw_version ver;

	ver.major = ATH_VERSION_MAJOR;
  907c2f:	c081      	movi.n	a8, 1
	ver.minor = ATH_VERSION_MINOR;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &ver, sizeof(ver));
  907c31:	8a23      	l32i.n	a10, a2, 12
				A_UINT8 *data, a_int32_t datalen)
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_fw_version ver;

	ver.major = ATH_VERSION_MAJOR;
  907c33:	281500        	s16i	a8, a1, 0
	ver.minor = ATH_VERSION_MINOR;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &ver, sizeof(ver));
  907c36:	c0e4      	movi.n	a14, 4
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_fw_version ver;

	ver.major = ATH_VERSION_MAJOR;
	ver.minor = ATH_VERSION_MINOR;
  907c38:	c084      	movi.n	a8, 4

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &ver, sizeof(ver));
  907c3a:	dd10      	mov.n	a13, a1
  907c3c:	040c4f        	extui	a12, a4, 0, 16
  907c3f:	030b4f        	extui	a11, a3, 0, 16
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_fw_version ver;

	ver.major = ATH_VERSION_MAJOR;
	ver.minor = ATH_VERSION_MINOR;
  907c42:	281501        	s16i	a8, a1, 2

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &ver, sizeof(ver));
  907c45:	5bfd8b        	call8	907274 <wmi_cmd_rsp>
  907c48:	d10f      	retw.n
	...

00907c4c <handle_echo_command>:
	adf_os_mem_free(sc);
}

static void handle_echo_command(void *pContext, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
  907c4c:	6c1004        	entry	a1, 32
	wmi_cmd_rsp(pContext, WMI_ECHO_CMDID, SeqNo, buffer, Length);
  907c4f:	de60      	mov.n	a14, a6
  907c51:	dd50      	mov.n	a13, a5
  907c53:	040c4f        	extui	a12, a4, 0, 16
  907c56:	c0b1      	movi.n	a11, 1
  907c58:	da20      	mov.n	a10, a2
  907c5a:	5bfd86        	call8	907274 <wmi_cmd_rsp>
  907c5d:	d10f      	retw.n
	...

00907c60 <ath_get_minrateidx>:
			sc->sc_sta[i].an_valid = 0;
	}
}

a_uint8_t ath_get_minrateidx(struct ath_softc_tgt *sc, struct ath_vap_target *avp)
{
  907c60:	6c1004        	entry	a1, 32
	if (sc->sc_curmode == IEEE80211_MODE_11NG)
  907c63:	2822c2        	l32i	a8, a2, 0x308
  907c66:	698104        	bnei	a8, 1, 907c6e <ath_get_minrateidx+0xe>
		return avp->av_minrateidx[0];
  907c69:	223040        	l8ui	a2, a3, 64
  907c6c:	d10f      	retw.n
	else if (sc->sc_curmode == IEEE80211_MODE_11NA)
		return avp->av_minrateidx[1];

	return 0;
  907c6e:	c020      	movi.n	a2, 0

a_uint8_t ath_get_minrateidx(struct ath_softc_tgt *sc, struct ath_vap_target *avp)
{
	if (sc->sc_curmode == IEEE80211_MODE_11NG)
		return avp->av_minrateidx[0];
	else if (sc->sc_curmode == IEEE80211_MODE_11NA)
  907c70:	728902        	bne	a8, a2, 907c76 <ath_get_minrateidx+0x16>
		return avp->av_minrateidx[1];
  907c73:	223041        	l8ui	a2, a3, 65

	return 0;
}
  907c76:	d10f      	retw.n

00907c78 <tgt_HTCRecv_beaconhandler>:
#undef N
}

static void tgt_HTCRecv_beaconhandler(HTC_ENDPOINT_ID EndPt, adf_nbuf_t hdr_buf,
				      adf_nbuf_t buf, void *ServiceCtx)
{
  907c78:	6c1018        	entry	a1, 192
}

static void ath_tgt_send_beacon(struct ath_softc_tgt *sc, adf_nbuf_t bc_hdr,
				adf_nbuf_t nbuf, HTC_ENDPOINT_ID EndPt)
{
	struct ath_hal *ah = sc->sc_ah;
  907c7b:	265d05        	addmi	a6, a5, 0x500
  907c7e:	866b      	l32i.n	a6, a6, 44
	ath_beacon_hdr_t *bhdr;
	struct ieee80211vap_target  *vap;
	a_uint32_t anblen;
	struct ieee80211_frame *wh;

	if (!bc_hdr) {
  907c80:	cd30      	bnez.n	a3, 907c94 <tgt_HTCRecv_beaconhandler+0x1c>
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  907c82:	2c1c70        	addi	a12, a1, 112
  907c85:	2b1c74        	addi	a11, a1, 116
  907c88:	da40      	mov.n	a10, a4
  907c8a:	5bee7e        	call8	903684 <__adf_nbuf_peek_header>
		adf_nbuf_peek_header(nbuf, &anbdata, &anblen);
		bhdr = (ath_beacon_hdr_t *)anbdata;
  907c8d:	27121d        	l32i	a7, a1, 116
  907c90:	60000e        	j	907ca2 <tgt_HTCRecv_beaconhandler+0x2a>
  907c93:	001871        	excw
	} else {
		adf_os_print("found bc_hdr! 0x%x\n", bc_hdr);
  907c96:	6e1a72        	bltui	a1, 12, 907d0c <tgt_HTCRecv_beaconhandler+0x94>
  907c99:	9328      	s32i.n	a3, a2, 32
  907c9b:	8212      	l32i.n	a2, a1, 8
  907c9d:	db30      	mov.n	a11, a3
  907c9f:	0b8000        	callx8	a8
	}

	vap_index = bhdr->vap_index;
  907ca2:	277000        	l8ui	a7, a7, 0
	adf_os_assert(vap_index < TARGET_VAP_MAX);
  907ca5:	6e7203        	bltui	a7, 2, 907cac <tgt_HTCRecv_beaconhandler+0x34>
  907ca8:	63fffc        	j	907ca8 <tgt_HTCRecv_beaconhandler+0x30>
  907cab:	00c0b4        	excw
 *         or NULL if there is not sufficient data to pull.
 */
static inline a_uint8_t *
adf_nbuf_pull_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_pull_head(buf, size);
  907cae:	da40      	mov.n	a10, a4
	vap = &sc->sc_vap[vap_index].av_vap;

	wh = (struct ieee80211_frame *)adf_nbuf_pull_head(nbuf,
						  sizeof(ath_beacon_hdr_t));

	bf = sc->sc_vap[vap_index].av_bcbuf;
  907cb0:	0c7311        	slli	a3, a7, 4
  907cb3:	5bedcf        	call8	9033f0 <__adf_nbuf_pull_head>
  907cb6:	a733      	add.n	a3, a3, a7
  907cb8:	0e3311        	slli	a3, a3, 2
  907cbb:	18728e        	l32r	a8, 8e46f4 <vdesc_module_install+0x5b8>
  907cbe:	a353      	add.n	a3, a5, a3
  907cc0:	a833      	add.n	a3, a3, a8
  907cc2:	8330      	l32i.n	a3, a3, 0
	adf_os_assert(bf);
  907cc4:	cc31      	bnez.n	a3, 907cc9 <tgt_HTCRecv_beaconhandler+0x51>
  907cc6:	63fffc        	j	907cc6 <tgt_HTCRecv_beaconhandler+0x4e>
	bf->bf_endpt = EndPt;
  907cc9:	223623        	s32i	a2, a3, 140

	if (bf->bf_skb) {
  907ccc:	8238      	l32i.n	a2, a3, 32
  907cce:	c92f      	beqz.n	a2, 907cf1 <tgt_HTCRecv_beaconhandler+0x79>
static inline void
adf_nbuf_unmap(adf_os_device_t      osdev, 
               adf_os_dma_map_t     bmap, 
               adf_os_dma_dir_t     dir)
{
    __adf_nbuf_unmap(osdev, bmap, dir);
  907cd0:	8b30      	l32i.n	a11, a3, 0
  907cd2:	2a5246        	l32i	a10, a5, 0x118
  907cd5:	c0c0      	movi.n	a12, 0
  907cd7:	5bee00        	call8	9034d8 <__adf_nbuf_unmap>
 *         or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_push_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_push_head(buf, size);
  907cda:	8a38      	l32i.n	a10, a3, 32
  907cdc:	c0b4      	movi.n	a11, 4
  907cde:	5bedb9        	call8	9033c4 <__adf_nbuf_push_head>
		adf_nbuf_unmap(sc->sc_dev, bf->bf_dmamap, ADF_OS_DMA_TO_DEVICE);
		adf_nbuf_push_head(bf->bf_skb, sizeof(ath_beacon_hdr_t));
		ath_free_tx_skb(sc->tgt_htc_handle, bf->bf_endpt, bf->bf_skb);
  907ce1:	12716e        	l32r	a2, 8e429c <vdesc_module_install+0x160>
  907ce4:	8c38      	l32i.n	a12, a3, 32
  907ce6:	222287        	l32i	a2, a2, 0x21c
  907ce9:	2b3223        	l32i	a11, a3, 140
  907cec:	8a52      	l32i.n	a10, a5, 8
  907cee:	0b2000        	callx8	a2
adf_nbuf_map(adf_os_device_t        osdev, 
             adf_os_dma_map_t       bmap, 
             adf_nbuf_t             buf, 
             adf_os_dma_dir_t       dir)
{
    return __adf_nbuf_map(osdev, bmap, buf, dir);
  907cf1:	2a5246        	l32i	a10, a5, 0x118
  907cf4:	8b30      	l32i.n	a11, a3, 0
  907cf6:	c0d0      	movi.n	a13, 0
  907cf8:	044c02        	or	a12, a4, a4
	}

	bf->bf_skb = nbuf;
  907cfb:	243608        	s32i	a4, a3, 32
  907cfe:	5bedf3        	call8	9034cc <__adf_nbuf_map>
 * @param[out] sg   map info
 */
static inline void
adf_nbuf_dmamap_info(adf_os_dma_map_t bmap, adf_os_dmamap_info_t *sg)
{
    __adf_nbuf_dmamap_info(bmap, sg);
  907d01:	8a30      	l32i.n	a10, a3, 0
  907d03:	2b3c04        	addi	a11, a3, 4
  907d06:	5bedf9        	call8	9034ec <__adf_nbuf_dmamap_info>
 */
static void ath_beacon_setup(struct ath_softc_tgt *sc,
			     struct ath_tx_buf *bf,
			     struct ath_vap_target *avp)
{
	adf_nbuf_t skb = bf->bf_skb;
  907d09:	8238      	l32i.n	a2, a3, 32
	struct ath_hal *ah = sc->sc_ah;
	struct ath_tx_desc *ds;
	a_int32_t flags;
	const HAL_RATE_TABLE *rt;
	a_uint8_t rix, rate;
	HAL_11N_RATE_SERIES series[4] = {{ 0 }};
  907d0b:	c5c0      	movi.n	a12, 80
 */
static void ath_beacon_setup(struct ath_softc_tgt *sc,
			     struct ath_tx_buf *bf,
			     struct ath_vap_target *avp)
{
	adf_nbuf_t skb = bf->bf_skb;
  907d0d:	221620        	s32i	a2, a1, 128
	struct ath_hal *ah = sc->sc_ah;
  907d10:	225d05        	addmi	a2, a5, 0x500
  907d13:	822b      	l32i.n	a2, a2, 44
	struct ath_tx_desc *ds;
	a_int32_t flags;
	const HAL_RATE_TABLE *rt;
	a_uint8_t rix, rate;
	HAL_11N_RATE_SERIES series[4] = {{ 0 }};
  907d15:	2b0a00        	movi	a11, 0
  907d18:	2a1c20        	addi	a10, a1, 32
static void ath_beacon_setup(struct ath_softc_tgt *sc,
			     struct ath_tx_buf *bf,
			     struct ath_vap_target *avp)
{
	adf_nbuf_t skb = bf->bf_skb;
	struct ath_hal *ah = sc->sc_ah;
  907d1b:	221626        	s32i	a2, a1, 152
	struct ath_tx_desc *ds;
	a_int32_t flags;
	const HAL_RATE_TABLE *rt;
	a_uint8_t rix, rate;
	HAL_11N_RATE_SERIES series[4] = {{ 0 }};
  907d1e:	5b751f        	call8	8e519c <memset>

	flags = HAL_TXDESC_NOACK;

	ds = bf->bf_desc;
	ds->ds_link = 0;
	ds->ds_data = bf->bf_dmamap_info.dma_segs[0].paddr;
  907d21:	2a3008        	l8ui	a10, a3, 8
	a_uint8_t rix, rate;
	HAL_11N_RATE_SERIES series[4] = {{ 0 }};

	flags = HAL_TXDESC_NOACK;

	ds = bf->bf_desc;
  907d24:	823c      	l32i.n	a2, a3, 48
	bf->bf_skb = nbuf;

	adf_nbuf_map(sc->sc_dev, bf->bf_dmamap, nbuf, ADF_OS_DMA_TO_DEVICE);
	adf_nbuf_dmamap_info(bf->bf_dmamap,&bf->bf_dmamap_info);

	ath_beacon_setup(sc, bf, &sc->sc_vap[vap_index]);
  907d26:	0c7b11        	slli	a11, a7, 4

	flags = HAL_TXDESC_NOACK;

	ds = bf->bf_desc;
	ds->ds_link = 0;
	ds->ds_data = bf->bf_dmamap_info.dma_segs[0].paddr;
  907d29:	2a2404        	s8i	a10, a2, 4
  907d2c:	2a3009        	l8ui	a10, a3, 9
	bf->bf_skb = nbuf;

	adf_nbuf_map(sc->sc_dev, bf->bf_dmamap, nbuf, ADF_OS_DMA_TO_DEVICE);
	adf_nbuf_dmamap_info(bf->bf_dmamap,&bf->bf_dmamap_info);

	ath_beacon_setup(sc, bf, &sc->sc_vap[vap_index]);
  907d2f:	197289        	l32r	a9, 8e4754 <vdesc_module_install+0x618>

	flags = HAL_TXDESC_NOACK;

	ds = bf->bf_desc;
	ds->ds_link = 0;
	ds->ds_data = bf->bf_dmamap_info.dma_segs[0].paddr;
  907d32:	2a2405        	s8i	a10, a2, 5
  907d35:	2a300a        	l8ui	a10, a3, 10
	bf->bf_skb = nbuf;

	adf_nbuf_map(sc->sc_dev, bf->bf_dmamap, nbuf, ADF_OS_DMA_TO_DEVICE);
	adf_nbuf_dmamap_info(bf->bf_dmamap,&bf->bf_dmamap_info);

	ath_beacon_setup(sc, bf, &sc->sc_vap[vap_index]);
  907d38:	a7bb      	add.n	a11, a11, a7

	flags = HAL_TXDESC_NOACK;

	ds = bf->bf_desc;
	ds->ds_link = 0;
	ds->ds_data = bf->bf_dmamap_info.dma_segs[0].paddr;
  907d3a:	2a2406        	s8i	a10, a2, 6
	bf->bf_skb = nbuf;

	adf_nbuf_map(sc->sc_dev, bf->bf_dmamap, nbuf, ADF_OS_DMA_TO_DEVICE);
	adf_nbuf_dmamap_info(bf->bf_dmamap,&bf->bf_dmamap_info);

	ath_beacon_setup(sc, bf, &sc->sc_vap[vap_index]);
  907d3d:	0ebb11        	slli	a11, a11, 2

	flags = HAL_TXDESC_NOACK;

	ds = bf->bf_desc;
	ds->ds_link = 0;
	ds->ds_data = bf->bf_dmamap_info.dma_segs[0].paddr;
  907d40:	2a300b        	l8ui	a10, a3, 11
	HAL_11N_RATE_SERIES series[4] = {{ 0 }};

	flags = HAL_TXDESC_NOACK;

	ds = bf->bf_desc;
	ds->ds_link = 0;
  907d43:	c080      	movi.n	a8, 0
	bf->bf_skb = nbuf;

	adf_nbuf_map(sc->sc_dev, bf->bf_dmamap, nbuf, ADF_OS_DMA_TO_DEVICE);
	adf_nbuf_dmamap_info(bf->bf_dmamap,&bf->bf_dmamap_info);

	ath_beacon_setup(sc, bf, &sc->sc_vap[vap_index]);
  907d45:	a9bb      	add.n	a11, a11, a9
	HAL_11N_RATE_SERIES series[4] = {{ 0 }};

	flags = HAL_TXDESC_NOACK;

	ds = bf->bf_desc;
	ds->ds_link = 0;
  907d47:	282400        	s8i	a8, a2, 0
  907d4a:	282401        	s8i	a8, a2, 1
  907d4d:	282402        	s8i	a8, a2, 2
  907d50:	282403        	s8i	a8, a2, 3
	ds->ds_data = bf->bf_dmamap_info.dma_segs[0].paddr;
  907d53:	2a2407        	s8i	a10, a2, 7

	rix = ath_get_minrateidx(sc, avp);
  907d56:	ab5b      	add.n	a11, a5, a11
  907d58:	055a02        	or	a10, a5, a5
  907d5b:	281625        	s32i	a8, a1, 148
  907d5e:	5bffc0        	call8	907c60 <ath_get_minrateidx>
	rt  = sc->sc_currates;
	rate = rt->info[rix].rateCode;
  907d61:	295281        	l32i	a9, a5, 0x204
  907d64:	b2aa      	addi.n	a10, a10, 2
  907d66:	0caa11        	slli	a10, a10, 4
  907d69:	aa99      	add.n	a9, a9, a10

	ah->ah_setupTxDesc(ds
  907d6b:	241226        	l32i	a4, a1, 152
 * @return The total length of this buf.
 */
static inline adf_os_size_t
adf_nbuf_len(adf_nbuf_t buf)
{
    return (__adf_nbuf_len(buf));
  907d6e:	2a1220        	l32i	a10, a1, 128
	ds->ds_link = 0;
	ds->ds_data = bf->bf_dmamap_info.dma_segs[0].paddr;

	rix = ath_get_minrateidx(sc, avp);
	rt  = sc->sc_currates;
	rate = rt->info[rix].rateCode;
  907d71:	279010        	l8ui	a7, a9, 16

	ah->ah_setupTxDesc(ds
  907d74:	244217        	l32i	a4, a4, 92
  907d77:	5bee3b        	call8	903664 <__adf_nbuf_len>
  907d7a:	c092      	movi.n	a9, 2
  907d7c:	281225        	l32i	a8, a1, 148
  907d7f:	9912      	s32i.n	a9, a1, 8
  907d81:	290aff        	movi	a9, 255
  907d84:	9911      	s32i.n	a9, a1, 4
  907d86:	c091      	movi.n	a9, 1
  907d88:	9814      	s32i.n	a8, a1, 16
  907d8a:	9813      	s32i.n	a8, a1, 12
  907d8c:	9910      	s32i.n	a9, a1, 0
  907d8e:	b4ab      	addi.n	a11, a10, 4
  907d90:	291624        	s32i	a9, a1, 144
  907d93:	df70      	mov.n	a15, a7
  907d95:	c3ef      	movi.n	a14, 63
  907d97:	c0d3      	movi.n	a13, 3
  907d99:	c1c8      	movi.n	a12, 24
  907d9b:	022a02        	or	a10, a2, a2
  907d9e:	0b4000        	callx8	a4
			    , HAL_TXKEYIX_INVALID
			    , flags
			    , 0
			    , 0);

	ah->ah_fillTxDesc(ds
  907da1:	241226        	l32i	a4, a1, 152
  907da4:	2a1220        	l32i	a10, a1, 128
  907da7:	2f4218        	l32i	a15, a4, 96
  907daa:	2f1623        	s32i	a15, a1, 140
  907dad:	5bee2d        	call8	903664 <__adf_nbuf_len>
  907db0:	291224        	l32i	a9, a1, 144
  907db3:	2f1223        	l32i	a15, a1, 140
			   , asf_roundup(adf_nbuf_len(skb), 4)
  907db6:	b3aa      	addi.n	a10, a10, 3
			    , HAL_TXKEYIX_INVALID
			    , flags
			    , 0
			    , 0);

	ah->ah_fillTxDesc(ds
  907db8:	c7bc      	movi.n	a11, -4
  907dba:	de20      	mov.n	a14, a2
  907dbc:	dd90      	mov.n	a13, a9
  907dbe:	dc90      	mov.n	a12, a9
  907dc0:	0bab01        	and	a11, a10, a11
  907dc3:	da20      	mov.n	a10, a2
  907dc5:	0bf000        	callx8	a15
			   , asf_roundup(adf_nbuf_len(skb), 4)
			   , AH_TRUE
			   , AH_TRUE
			   , ds);

	series[0].Tries = 1;
  907dc8:	291224        	l32i	a9, a1, 144
	series[0].Rate = rate;
  907dcb:	9719      	s32i.n	a7, a1, 36
			   , asf_roundup(adf_nbuf_len(skb), 4)
			   , AH_TRUE
			   , AH_TRUE
			   , ds);

	series[0].Tries = 1;
  907dcd:	9918      	s32i.n	a9, a1, 32
	series[0].Rate = rate;
	series[0].ChSel = sc->sc_ic.ic_tx_chainmask;
  907dcf:	275d16        	addmi	a7, a5, 0x1600
	series[0].RateFlags = 0;
	ah->ah_set11nRateScenario(ds, 0, 0, series, 4, 0);
  907dd2:	291226        	l32i	a9, a1, 152
			   , ds);

	series[0].Tries = 1;
	series[0].Rate = rate;
	series[0].ChSel = sc->sc_ic.ic_tx_chainmask;
	series[0].RateFlags = 0;
  907dd5:	281225        	l32i	a8, a1, 148
			   , AH_TRUE
			   , ds);

	series[0].Tries = 1;
	series[0].Rate = rate;
	series[0].ChSel = sc->sc_ic.ic_tx_chainmask;
  907dd8:	277026        	l8ui	a7, a7, 38
	series[0].RateFlags = 0;
	ah->ah_set11nRateScenario(ds, 0, 0, series, 4, 0);
  907ddb:	249210        	l32i	a4, a9, 64
  907dde:	dc80      	mov.n	a12, a8
  907de0:	db80      	mov.n	a11, a8
			   , ds);

	series[0].Tries = 1;
	series[0].Rate = rate;
	series[0].ChSel = sc->sc_ic.ic_tx_chainmask;
	series[0].RateFlags = 0;
  907de2:	981c      	s32i.n	a8, a1, 48
	ah->ah_set11nRateScenario(ds, 0, 0, series, 4, 0);
  907de4:	df80      	mov.n	a15, a8
  907de6:	2e0a04        	movi	a14, 4
  907de9:	2d1c20        	addi	a13, a1, 32
  907dec:	da20      	mov.n	a10, a2
			   , AH_TRUE
			   , ds);

	series[0].Tries = 1;
	series[0].Rate = rate;
	series[0].ChSel = sc->sc_ic.ic_tx_chainmask;
  907dee:	27160b        	s32i	a7, a1, 44
	series[0].RateFlags = 0;
	ah->ah_set11nRateScenario(ds, 0, 0, series, 4, 0);
  907df1:	0b4000        	callx8	a4

	adf_nbuf_map(sc->sc_dev, bf->bf_dmamap, nbuf, ADF_OS_DMA_TO_DEVICE);
	adf_nbuf_dmamap_info(bf->bf_dmamap,&bf->bf_dmamap_info);

	ath_beacon_setup(sc, bf, &sc->sc_vap[vap_index]);
	ah->ah_stopTxDma(ah, sc->sc_bhalq);
  907df4:	255d01        	addmi	a5, a5, 0x100
  907df7:	826d      	l32i.n	a2, a6, 52
  907df9:	2b501c        	l8ui	a11, a5, 28
  907dfc:	da60      	mov.n	a10, a6
  907dfe:	0b2000        	callx8	a2
	ah->ah_setTxDP(ah, sc->sc_bhalq, ATH_BUF_GET_DESC_PHY_ADDR(bf));
  907e01:	2b501c        	l8ui	a11, a5, 28
  907e04:	826a      	l32i.n	a2, a6, 40
  907e06:	8c3c      	l32i.n	a12, a3, 48
  907e08:	da60      	mov.n	a10, a6
  907e0a:	0b2000        	callx8	a2
	ah->ah_startTxDma(ah, sc->sc_bhalq);
  907e0d:	2b501c        	l8ui	a11, a5, 28
  907e10:	826c      	l32i.n	a2, a6, 48
  907e12:	066a02        	or	a10, a6, a6
  907e15:	0b2000        	callx8	a2
  907e18:	d10f      	retw.n
	...

00907e1c <ath_tgt_attach>:
	/* Start HTC messages exchange */
	HTC_Ready(sc->tgt_htc_handle);
}

a_int32_t ath_tgt_attach(a_uint32_t devid, struct ath_softc_tgt *sc, adf_os_device_t osdev)
{
  907e1c:	6c1010        	entry	a1, 128
 * @return int
 */
static inline int 
__adf_os_pci_config_read8(adf_os_device_t osdev, int offset, a_uint8_t *val)
{
    (*val) = wlan_pci_config_read(offset, 1);
  907e1f:	2b0a01        	movi	a11, 1
  907e22:	2a0a0c        	movi	a10, 12
  907e25:	5bef9e        	call8	903ca0 <wlan_pci_config_read>
  907e28:	0a0a47        	extui	a10, a10, 0, 8
	a_uint8_t csz;

	adf_os_pci_config_read8(osdev, ATH_PCI_CACHE_LINE_SIZE, &csz);

	if (csz == 0)
		csz = 16;
  907e2b:	c160      	movi.n	a6, 16
  907e2d:	0a6a38        	moveqz	a10, a6, a10
	sc->sc_cachelsz = csz << 2;
  907e30:	0eaa11        	slli	a10, a10, 2
  907e33:	2a3596        	s16i	a10, a3, 0x12c
 */
static inline void 
adf_os_init_bh(adf_os_handle_t  hdl, adf_os_bh_t  *bh,
               adf_os_defer_fn_t  func,void  *arg)
{
    __adf_os_init_bh(hdl, bh, func, arg);
  907e36:	1b7294        	l32r	a11, 8e4888 <vdesc_module_install+0x74c>
  907e39:	2a3a14        	movi	a10, 0x314

	sc->sc_dev = osdev;
  907e3c:	243646        	s32i	a4, a3, 0x118
	sc->sc_hdl = osdev;
  907e3f:	243645        	s32i	a4, a3, 0x114
  907e42:	dc30      	mov.n	a12, a3
  907e44:	aa3a      	add.n	a10, a3, a10
  907e46:	5bf9d3        	call8	906594 <__adf_os_init_bh$isra$5>
  907e49:	1b7295        	l32r	a11, 8e48a0 <vdesc_module_install+0x764>
  907e4c:	2a5a1c        	movi	a10, 0x51c
  907e4f:	033c02        	or	a12, a3, a3
  907e52:	0a3a08        	add	a10, a3, a10
  907e55:	5bf9cf        	call8	906594 <__adf_os_init_bh$isra$5>
  907e58:	1b7296        	l32r	a11, 8e48b0 <vdesc_module_install+0x774>
  907e5b:	2a3a24        	movi	a10, 0x324
  907e5e:	dc30      	mov.n	a12, a3
  907e60:	aa3a      	add.n	a10, a3, a10
  907e62:	5bf9cc        	call8	906594 <__adf_os_init_bh$isra$5>
  907e65:	1b7297        	l32r	a11, 8e48c4 <vdesc_module_install+0x788>
  907e68:	2a3a44        	movi	a10, 0x344
  907e6b:	033c02        	or	a12, a3, a3
  907e6e:	0a3a08        	add	a10, a3, a10
  907e71:	5bf9c8        	call8	906594 <__adf_os_init_bh$isra$5>
	ATH_INIT_TQUEUE(sc->sc_dev, &sc->sc_txtq, owl_tgt_tx_tasklet, sc);
	ATH_INIT_TQUEUE(sc->sc_dev, &sc->sc_bmisstq, ath_bmiss_tasklet, sc);
	ATH_INIT_TQUEUE(sc->sc_dev, &sc->sc_fataltq, ath_fatal_tasklet, sc);

	flags |= AH_USE_EEPROM;
	ah = _ath_hal_attach_tgt(devid, sc, sc->sc_dev, flags, &status);
  907e74:	2c3246        	l32i	a12, a3, 0x118
  907e77:	2e1c34        	addi	a14, a1, 52
  907e7a:	2d0a01        	movi	a13, 1
  907e7d:	033b02        	or	a11, a3, a3
  907e80:	022a02        	or	a10, a2, a2
  907e83:	5bef3f        	call8	903b80 <_ath_hal_attach_tgt>
  907e86:	d4a0      	mov.n	a4, a10
	if (ah == NULL) {
  907e88:	64a3c4        	beqz	a10, 908250 <ath_tgt_attach+0x434>
	HTC_CONFIG htc_conf;
	WMI_SVC_CONFIG wmiConfig;
	WMI_DISPATCH_TABLE *Magpie_Sys_Commands_Tbl;

	/* Init dynamic buf pool */
	sc->pool_handle = BUF_Pool_init(sc->sc_hdl);
  907e8b:	15716e        	l32r	a5, 8e4444 <vdesc_module_install+0x308>
	ah = _ath_hal_attach_tgt(devid, sc, sc->sc_dev, flags, &status);
	if (ah == NULL) {
		error = ENXIO;
		goto bad;
	}
	sc->sc_ah = ah;
  907e8e:	223d05        	addmi	a2, a3, 0x500
	HTC_CONFIG htc_conf;
	WMI_SVC_CONFIG wmiConfig;
	WMI_DISPATCH_TABLE *Magpie_Sys_Commands_Tbl;

	/* Init dynamic buf pool */
	sc->pool_handle = BUF_Pool_init(sc->sc_hdl);
  907e91:	27529e        	l32i	a7, a5, 0x278
	ah = _ath_hal_attach_tgt(devid, sc, sc->sc_dev, flags, &status);
	if (ah == NULL) {
		error = ENXIO;
		goto bad;
	}
	sc->sc_ah = ah;
  907e94:	9a2b      	s32i.n	a10, a2, 44
	HTC_CONFIG htc_conf;
	WMI_SVC_CONFIG wmiConfig;
	WMI_DISPATCH_TABLE *Magpie_Sys_Commands_Tbl;

	/* Init dynamic buf pool */
	sc->pool_handle = BUF_Pool_init(sc->sc_hdl);
  907e96:	2a3245        	l32i	a10, a3, 0x114
  907e99:	0b7000        	callx8	a7

	/* Init target-side HIF */
	sc->tgt_hif_handle = HIF_init(0);
  907e9c:	275275        	l32i	a7, a5, 0x1d4
	HTC_CONFIG htc_conf;
	WMI_SVC_CONFIG wmiConfig;
	WMI_DISPATCH_TABLE *Magpie_Sys_Commands_Tbl;

	/* Init dynamic buf pool */
	sc->pool_handle = BUF_Pool_init(sc->sc_hdl);
  907e9f:	2a3600        	s32i	a10, a3, 0

	/* Init target-side HIF */
	sc->tgt_hif_handle = HIF_init(0);
  907ea2:	2a0a00        	movi	a10, 0
  907ea5:	0b7000        	callx8	a7

	/* Init target-side HTC */
	htc_conf.HIFHandle = sc->tgt_hif_handle;
	htc_conf.CreditSize = 320;
  907ea8:	271a40        	movi	a7, 0x140
  907eab:	9714      	s32i.n	a7, a1, 16
	htc_conf.CreditNumber = ATH_TXBUF;
  907ead:	c271      	movi.n	a7, 33
  907eaf:	9715      	s32i.n	a7, a1, 20
	htc_conf.OSHandle = sc->sc_hdl;
  907eb1:	273245        	l32i	a7, a3, 0x114

	/* Init dynamic buf pool */
	sc->pool_handle = BUF_Pool_init(sc->sc_hdl);

	/* Init target-side HIF */
	sc->tgt_hif_handle = HIF_init(0);
  907eb4:	9a31      	s32i.n	a10, a3, 4

	/* Init target-side HTC */
	htc_conf.HIFHandle = sc->tgt_hif_handle;
	htc_conf.CreditSize = 320;
	htc_conf.CreditNumber = ATH_TXBUF;
	htc_conf.OSHandle = sc->sc_hdl;
  907eb6:	9716      	s32i.n	a7, a1, 24
	htc_conf.PoolHandle = sc->pool_handle;
  907eb8:	8730      	l32i.n	a7, a3, 0

	/* Init target-side HIF */
	sc->tgt_hif_handle = HIF_init(0);

	/* Init target-side HTC */
	htc_conf.HIFHandle = sc->tgt_hif_handle;
  907eba:	9a17      	s32i.n	a10, a1, 28
	htc_conf.CreditSize = 320;
	htc_conf.CreditNumber = ATH_TXBUF;
	htc_conf.OSHandle = sc->sc_hdl;
	htc_conf.PoolHandle = sc->pool_handle;
  907ebc:	9718      	s32i.n	a7, a1, 32
	sc->tgt_htc_handle = HTC_init(htc_setup_comp, &htc_conf);
  907ebe:	1a7298        	l32r	a10, 8e4920 <vdesc_module_install+0x7e4>
  907ec1:	275283        	l32i	a7, a5, 0x20c
  907ec4:	a61b      	add.n	a11, a1, a6
  907ec6:	0b7000        	callx8	a7
#if defined(PROJECT_MAGPIE)
	init_htc_handle = sc->tgt_htc_handle;
#endif

	tgt_reg_service(sc, &sc->htc_beacon_service, WMI_BEACON_SVC, tgt_HTCRecv_beaconhandler);
  907ec9:	1d7299        	l32r	a13, 8e4930 <vdesc_module_install+0x7f4>
  907ecc:	a63b      	add.n	a11, a3, a6
	htc_conf.HIFHandle = sc->tgt_hif_handle;
	htc_conf.CreditSize = 320;
	htc_conf.CreditNumber = ATH_TXBUF;
	htc_conf.OSHandle = sc->sc_hdl;
	htc_conf.PoolHandle = sc->pool_handle;
	sc->tgt_htc_handle = HTC_init(htc_setup_comp, &htc_conf);
  907ece:	9a32      	s32i.n	a10, a3, 8
#if defined(PROJECT_MAGPIE)
	init_htc_handle = sc->tgt_htc_handle;
#endif

	tgt_reg_service(sc, &sc->htc_beacon_service, WMI_BEACON_SVC, tgt_HTCRecv_beaconhandler);
  907ed0:	2c1a01        	movi	a12, 0x101
  907ed3:	033a02        	or	a10, a3, a3
  907ed6:	5bf97a        	call8	9064c0 <tgt_reg_service>
	tgt_reg_service(sc, &sc->htc_cab_service, WMI_CAB_SVC, tgt_HTCRecv_cabhandler);
  907ed9:	1d729a        	l32r	a13, 8e4944 <vdesc_module_install+0x808>
  907edc:	2c1a02        	movi	a12, 0x102
  907edf:	2b3c2c        	addi	a11, a3, 44
  907ee2:	033a02        	or	a10, a3, a3
  907ee5:	5bf976        	call8	9064c0 <tgt_reg_service>
	tgt_reg_service(sc, &sc->htc_uapsd_service, WMI_UAPSD_SVC, tgt_HTCRecv_uapsdhandler);
  907ee8:	1d729b        	l32r	a13, 8e4954 <vdesc_module_install+0x818>
  907eeb:	2c1a03        	movi	a12, 0x103
  907eee:	2b3c48        	addi	a11, a3, 72
  907ef1:	da30      	mov.n	a10, a3
  907ef3:	5bf973        	call8	9064c0 <tgt_reg_service>
	tgt_reg_service(sc, &sc->htc_mgmt_service, WMI_MGMT_SVC, tgt_HTCRecv_mgmthandler);
  907ef6:	1d729c        	l32r	a13, 8e4968 <vdesc_module_install+0x82c>
  907ef9:	2c1a04        	movi	a12, 0x104
  907efc:	2b3c64        	addi	a11, a3, 100
  907eff:	da30      	mov.n	a10, a3
  907f01:	5bf96f        	call8	9064c0 <tgt_reg_service>
	tgt_reg_service(sc, &sc->htc_data_BE_service, WMI_DATA_BE_SVC, tgt_HTCRecvMessageHandler);
  907f04:	17729d        	l32r	a7, 8e4978 <vdesc_module_install+0x83c>
  907f07:	2b0ab8        	movi	a11, 184
  907f0a:	077d02        	or	a13, a7, a7
  907f0d:	2c1a07        	movi	a12, 0x107
  907f10:	0b3b08        	add	a11, a3, a11
  907f13:	033a02        	or	a10, a3, a3
  907f16:	5bf96a        	call8	9064c0 <tgt_reg_service>
	tgt_reg_service(sc, &sc->htc_data_BK_service, WMI_DATA_BK_SVC, tgt_HTCRecvMessageHandler);
  907f19:	2b0ad4        	movi	a11, 212
  907f1c:	dd70      	mov.n	a13, a7
  907f1e:	2c1a08        	movi	a12, 0x108
  907f21:	ab3b      	add.n	a11, a3, a11
  907f23:	033a02        	or	a10, a3, a3
  907f26:	5bf966        	call8	9064c0 <tgt_reg_service>
	tgt_reg_service(sc, &sc->htc_data_VI_service, WMI_DATA_VI_SVC, tgt_HTCRecvMessageHandler);
  907f29:	2b0a9c        	movi	a11, 156
  907f2c:	dd70      	mov.n	a13, a7
  907f2e:	2c1a06        	movi	a12, 0x106
  907f31:	ab3b      	add.n	a11, a3, a11
  907f33:	033a02        	or	a10, a3, a3
  907f36:	5bf962        	call8	9064c0 <tgt_reg_service>
	tgt_reg_service(sc, &sc->htc_data_VO_service, WMI_DATA_VO_SVC, tgt_HTCRecvMessageHandler);
  907f39:	2b0a80        	movi	a11, 128
  907f3c:	dd70      	mov.n	a13, a7
  907f3e:	2c1a05        	movi	a12, 0x105
  907f41:	ab3b      	add.n	a11, a3, a11
  907f43:	da30      	mov.n	a10, a3
  907f45:	5bf95e        	call8	9064c0 <tgt_reg_service>
 * @return Buffer pointer or NULL if there's not enough memory.
 */
static inline void *
adf_os_mem_alloc(adf_os_size_t size)
{
    return __adf_os_mem_alloc(size);
  907f48:	da60      	mov.n	a10, a6
  907f4a:	5bf930        	call8	90640c <__adf_os_mem_alloc>
}
/* zero a memory buffer */
static inline void
__adf_os_mem_zero(void *buf, adf_os_size_t size)
{
    A_MEMZERO(buf,size);
  907f4d:	8854      	l32i.n	a8, a5, 16
  907f4f:	dc60      	mov.n	a12, a6
  907f51:	c0b0      	movi.n	a11, 0
  907f53:	d7a0      	mov.n	a7, a10
  907f55:	0b8000        	callx8	a8

	/* Init target-side WMI */
	Magpie_Sys_Commands_Tbl = (WMI_DISPATCH_TABLE *)adf_os_mem_alloc(sizeof(WMI_DISPATCH_TABLE));
	adf_os_mem_zero(Magpie_Sys_Commands_Tbl, sizeof(WMI_DISPATCH_TABLE));
	Magpie_Sys_Commands_Tbl->NumberOfEntries = WMI_DISPATCH_ENTRY_COUNT(Magpie_Sys_DispatchEntries);
  907f58:	c280      	movi.n	a8, 32
  907f5a:	9872      	s32i.n	a8, a7, 8
	Magpie_Sys_Commands_Tbl->pTable = Magpie_Sys_DispatchEntries;
  907f5c:	18729e        	l32r	a8, 8e49d4 <vdesc_module_install+0x898>
  907f5f:	dc60      	mov.n	a12, a6
  907f61:	9873      	s32i.n	a8, a7, 12
  907f63:	8854      	l32i.n	a8, a5, 16
  907f65:	c0b0      	movi.n	a11, 0
  907f67:	2a1c24        	addi	a10, a1, 36
  907f6a:	0b8000        	callx8	a8

	adf_os_mem_zero(&wmiConfig, sizeof(WMI_SVC_CONFIG));
	wmiConfig.HtcHandle = sc->tgt_htc_handle;
  907f6d:	8632      	l32i.n	a6, a3, 8
	wmiConfig.PoolHandle = sc->pool_handle;
	wmiConfig.MaxCmdReplyEvts = ATH_WMI_MAX_CMD_REPLY;
	wmiConfig.MaxEventEvts = ATH_WMI_MAX_EVENTS;

	sc->tgt_wmi_handle = WMI_Init(&wmiConfig);
  907f6f:	2a1c24        	addi	a10, a1, 36
	adf_os_mem_zero(Magpie_Sys_Commands_Tbl, sizeof(WMI_DISPATCH_TABLE));
	Magpie_Sys_Commands_Tbl->NumberOfEntries = WMI_DISPATCH_ENTRY_COUNT(Magpie_Sys_DispatchEntries);
	Magpie_Sys_Commands_Tbl->pTable = Magpie_Sys_DispatchEntries;

	adf_os_mem_zero(&wmiConfig, sizeof(WMI_SVC_CONFIG));
	wmiConfig.HtcHandle = sc->tgt_htc_handle;
  907f72:	9619      	s32i.n	a6, a1, 36
	wmiConfig.PoolHandle = sc->pool_handle;
  907f74:	8630      	l32i.n	a6, a3, 0
  907f76:	961a      	s32i.n	a6, a1, 40
	wmiConfig.MaxCmdReplyEvts = ATH_WMI_MAX_CMD_REPLY;
  907f78:	c062      	movi.n	a6, 2
  907f7a:	961b      	s32i.n	a6, a1, 44
	wmiConfig.MaxEventEvts = ATH_WMI_MAX_EVENTS;
  907f7c:	c068      	movi.n	a6, 8
  907f7e:	961c      	s32i.n	a6, a1, 48

	sc->tgt_wmi_handle = WMI_Init(&wmiConfig);
  907f80:	265290        	l32i	a6, a5, 0x240
  907f83:	0b6000        	callx8	a6
  907f86:	9a33      	s32i.n	a10, a3, 12
	Magpie_Sys_Commands_Tbl->pContext = sc;
	WMI_RegisterDispatchTable(sc->tgt_wmi_handle, Magpie_Sys_Commands_Tbl);
  907f88:	265291        	l32i	a6, a5, 0x244
  907f8b:	db70      	mov.n	a11, a7
	wmiConfig.PoolHandle = sc->pool_handle;
	wmiConfig.MaxCmdReplyEvts = ATH_WMI_MAX_CMD_REPLY;
	wmiConfig.MaxEventEvts = ATH_WMI_MAX_EVENTS;

	sc->tgt_wmi_handle = WMI_Init(&wmiConfig);
	Magpie_Sys_Commands_Tbl->pContext = sc;
  907f8d:	9371      	s32i.n	a3, a7, 4
	WMI_RegisterDispatchTable(sc->tgt_wmi_handle, Magpie_Sys_Commands_Tbl);
  907f8f:	0b6000        	callx8	a6

	HTC_NotifyTargetInserted(sc->tgt_htc_handle);

	/* Start HTC messages exchange */
	HTC_Ready(sc->tgt_htc_handle);
  907f92:	8a32      	l32i.n	a10, a3, 8
  907f94:	255286        	l32i	a5, a5, 0x218
	}
	sc->sc_ah = ah;

	tgt_hif_htc_wmi_init(sc);

	sc->sc_bhalq = HAL_NUM_TX_QUEUES - 1;
  907f97:	c069      	movi.n	a6, 9
	WMI_RegisterDispatchTable(sc->tgt_wmi_handle, Magpie_Sys_Commands_Tbl);

	HTC_NotifyTargetInserted(sc->tgt_htc_handle);

	/* Start HTC messages exchange */
	HTC_Ready(sc->tgt_htc_handle);
  907f99:	0b5000        	callx8	a5
	}
	sc->sc_ah = ah;

	tgt_hif_htc_wmi_init(sc);

	sc->sc_bhalq = HAL_NUM_TX_QUEUES - 1;
  907f9c:	253d01        	addmi	a5, a3, 0x100
  907f9f:	26541c        	s8i	a6, a5, 28
	return (tsf + (u_int64_t)tsf_delta);
}

static a_int32_t ath_rate_setup(struct ath_softc_tgt *sc, a_uint32_t mode)
{
	struct ath_hal *ah = sc->sc_ah;
  907fa2:	8a2b      	l32i.n	a10, a2, 44
	const HAL_RATE_TABLE *rt;

	switch (mode) {
	case IEEE80211_MODE_11NA:
		sc->sc_rates[mode] = ah->ah_getRateTable(ah, HAL_MODE_11NA);
  907fa4:	1b7237        	l32r	a11, 8e4880 <vdesc_module_install+0x744>
  907fa7:	85a5      	l32i.n	a5, a10, 20
  907fa9:	0b5000        	callx8	a5
  907fac:	2a367f        	s32i	a10, a3, 0x1fc
	return (tsf + (u_int64_t)tsf_delta);
}

static a_int32_t ath_rate_setup(struct ath_softc_tgt *sc, a_uint32_t mode)
{
	struct ath_hal *ah = sc->sc_ah;
  907faf:	8a2b      	l32i.n	a10, a2, 44
	switch (mode) {
	case IEEE80211_MODE_11NA:
		sc->sc_rates[mode] = ah->ah_getRateTable(ah, HAL_MODE_11NA);
		break;
	case IEEE80211_MODE_11NG:
		sc->sc_rates[mode] = ah->ah_getRateTable(ah, HAL_MODE_11NG);
  907fb1:	1b7213        	l32r	a11, 8e4800 <vdesc_module_install+0x6c4>
  907fb4:	85a5      	l32i.n	a5, a10, 20
  907fb6:	0b5000        	callx8	a5
  907fb9:	2a3680        	s32i	a10, a3, 0x200
	sc->sc_bhalq = HAL_NUM_TX_QUEUES - 1;

	ath_rate_setup(sc, IEEE80211_MODE_11NA);
	ath_rate_setup(sc, IEEE80211_MODE_11NG);

	sc->sc_rc = ath_rate_attach(sc);
  907fbc:	da30      	mov.n	a10, a3
  907fbe:	58038d        	call8	908df4 <ath_rate_attach>
  907fc1:	2a3648        	s32i	a10, a3, 0x120
	if (sc->sc_rc == NULL) {
  907fc4:	64a279        	beqz	a10, 908241 <ath_tgt_attach+0x425>
  907fc7:	16729f        	l32r	a6, 8e4a44 <vdesc_module_install+0x908>
  907fca:	257a40        	movi	a5, 0x740
  907fcd:	a535      	add.n	a5, a3, a5
  907fcf:	063608        	add	a6, a3, a6
  907fd2:	272a0c        	movi	a7, 0x20c
		error = EIO;
		goto bad2;
	}

	for (i=0; i < TARGET_NODE_MAX; i++) {
		sc->sc_sta[i].an_rcnode = adf_os_mem_alloc(sc->sc_rc->arc_space);
  907fd5:	283248        	l32i	a8, a3, 0x120
  907fd8:	8a80      	l32i.n	a10, a8, 0
  907fda:	5bf90c        	call8	90640c <__adf_os_mem_alloc>
  907fdd:	9a50      	s32i.n	a10, a5, 0
  907fdf:	a755      	add.n	a5, a5, a7
	if (sc->sc_rc == NULL) {
		error = EIO;
		goto bad2;
	}

	for (i=0; i < TARGET_NODE_MAX; i++) {
  907fe1:	7659f0        	bne	a5, a6, 907fd5 <ath_tgt_attach+0x1b9>
	((_dd)->dd_desc_paddr + ((caddr_t)(_ds) - (caddr_t)(_dd)->dd_desc))

	a_int32_t error;
	struct ath_tx_buf *bf;

	if(ath_numrxbufs == -1)
  907fe4:	157283        	l32r	a5, 8e49f0 <vdesc_module_install+0x8b4>
  907fe7:	8650      	l32i.n	a6, a5, 0
  907fe9:	696003        	bnei	a6, -1, 907ff0 <ath_tgt_attach+0x1d4>
		ath_numrxbufs = ATH_RXBUF;
  907fec:	c06b      	movi.n	a6, 11
  907fee:	9650      	s32i.n	a6, a5, 0

	if (ath_numrxdescs == -1)
  907ff0:	1872a0        	l32r	a8, 8e4a70 <vdesc_module_install+0x934>
  907ff3:	8580      	l32i.n	a5, a8, 0
  907ff5:	695003        	bnei	a5, -1, 907ffc <ath_tgt_attach+0x1e0>
		ath_numrxdescs = ATH_RXDESC;
  907ff8:	c05b      	movi.n	a5, 11
  907ffa:	9580      	s32i.n	a5, a8, 0

	error = ath_descdma_setup(sc, &sc->sc_rxdma, (ath_bufhead *)&sc->sc_rxbuf,
  907ffc:	c594      	movi.n	a9, 84
  907ffe:	253a74        	movi	a5, 0x374
  908001:	263a54        	movi	a6, 0x354
  908004:	271a18        	movi	a7, 0x118
  908007:	9910      	s32i.n	a9, a1, 0
  908009:	a535      	add.n	a5, a3, a5
  90800b:	a636      	add.n	a6, a3, a6
  90800d:	a737      	add.n	a7, a3, a7
  90800f:	8e80      	l32i.n	a14, a8, 0
  908011:	1d72a1        	l32r	a13, 8e4a98 <vdesc_module_install+0x95c>
  908014:	2f0a68        	movi	a15, 104
  908017:	dc60      	mov.n	a12, a6
  908019:	db50      	mov.n	a11, a5
  90801b:	da70      	mov.n	a10, a7
  90801d:	5bf9e2        	call8	9067a8 <ath_descdma_setup$isra$21$constprop$26>
				  "rx", ath_numrxdescs, 1,
				  sizeof(struct ath_rx_buf),
				  sizeof(struct ath_rx_desc));
	if (error != 0)
  908020:	65a21d        	bnez	a10, 908241 <ath_tgt_attach+0x425>
	a_uint32_t i;
	struct ath_descdma *dd = &sc->sc_rxdma;
	struct ath_rx_desc *ds = (struct ath_rx_desc *)dd->dd_desc;
	struct ath_rx_desc *ds_prev = NULL;

	asf_tailq_init(&sc->sc_rxdesc);
  908023:	293a64        	movi	a9, 0x364
  908026:	a939      	add.n	a9, a3, a9
  908028:	2936da        	s32i	a9, a3, 0x368
	asf_tailq_init(&sc->sc_rxdesc_idle);
  90802b:	293a5c        	movi	a9, 0x35c
  90802e:	a939      	add.n	a9, a3, a9
  908030:	2936d8        	s32i	a9, a3, 0x360
	if (error != 0)
		return error;

	a_uint32_t i;
	struct ath_descdma *dd = &sc->sc_rxdma;
	struct ath_rx_desc *ds = (struct ath_rx_desc *)dd->dd_desc;
  908033:	2832de        	l32i	a8, a3, 0x378
	struct ath_rx_desc *ds_prev = NULL;

	asf_tailq_init(&sc->sc_rxdesc);
  908036:	2a36d9        	s32i	a10, a3, 0x364
	asf_tailq_init(&sc->sc_rxdesc_idle);
  908039:	2a36d7        	s32i	a10, a3, 0x35c
		return error;

	a_uint32_t i;
	struct ath_descdma *dd = &sc->sc_rxdma;
	struct ath_rx_desc *ds = (struct ath_rx_desc *)dd->dd_desc;
	struct ath_rx_desc *ds_prev = NULL;
  90803c:	d9a0      	mov.n	a9, a10

	asf_tailq_init(&sc->sc_rxdesc);
	asf_tailq_init(&sc->sc_rxdesc_idle);

	for (i = 0; i < ath_numrxdescs; i++, ds++) {
  90803e:	dca0      	mov.n	a12, a10
  908040:	6000c3        	j	908107 <ath_tgt_attach+0x2eb>
  908043:	002b80        	excw

		if (ds->ds_nbuf != ADF_NBUF_NULL) {
  908046:	342a80        	excw
  908049:	3508bb        	excw
  90804c:	1000aa        	l32r	a0, 8c82f4 <_bss_end+0x3baaec>
  90804f:	110bab        	l32r	a1, 8caefc <_bss_end+0x3bd6f4>
  908052:	022a80        	excw
  908055:	3608aa        	excw
  908058:	110baa        	l32r	a1, 8caf00 <_bss_end+0x3bd6f8>
  90805b:	022b80        	excw
  90805e:	370aba        	excw
  908061:	0264a0        	excw
  908064:	0e2a0a        	addx4	a10, a2, a14
			ds->ds_nbuf = ADF_NBUF_NULL;
  908067:	002a84        	excw
  90806a:	342a84        	excw
  90806d:	352a84        	excw
  908070:	362a84        	excw
  908073:	372a32        	excw
 */
static inline a_status_t
adf_nbuf_dmamap_create(adf_os_device_t osdev,
                       adf_os_dma_map_t *dmap)
{
    return (__adf_nbuf_dmamap_create(osdev, dmap));
  908076:	462b8c        	excw
  908079:	382816        	excw
  90807c:	132916        	l32r	a3, 8d24d4 <_bss_end+0x3c4ccc>
  90807f:	142c16        	l32r	a4, 8d30d8 <_bss_end+0x3c58d0>
  908082:	125bed        	l32r	a2, 8df038 <_bss_end+0x3d1830>
  908085:	0b2812        	srai	a8, a11, 2
		}

		if (adf_nbuf_dmamap_create(sc->sc_dev, &ds->ds_dmap) != A_STATUS_OK) {
  908088:	132912        	l32r	a3, 8d24d0 <_bss_end+0x3c4cc8>
  90808b:	142c12        	l32r	a4, 8d30d4 <_bss_end+0x3c58cc>
  90808e:	12c8a2        	l32r	a2, 8fa318 <memset+0x1517c>
  908091:	63fffc        	j	908091 <ath_tgt_attach+0x275>
  908094:	002a32        	sext	a10, a2, 7
			adf_os_assert(0);
		}

		ds->ds_daddr = DS2PHYS(&sc->sc_rxdma, ds);
  908097:	de2b      	excw
  908099:	32e00a        	excw
  90809c:	8a0c      	l32i.n	a10, a0, 48
  90809e:	abaa      	add.n	a10, a10, a11
  9080a0:	0a8e57        	extui	a14, a10, 24, 8
  9080a3:	0a0d57        	extui	a13, a10, 16, 8
  9080a6:	0a8b47        	extui	a11, a10, 8, 8
  9080a9:	0a0a47        	extui	a10, a10, 0, 8
  9080ac:	2e8448        	s8i	a14, a8, 72
  9080af:	2d8449        	s8i	a13, a8, 73
  9080b2:	2b844a        	s8i	a11, a8, 74
  9080b5:	2a844b        	s8i	a10, a8, 75

		if (ds_prev) {
  9080b8:	c89a      	beqz.n	a9, 9080c6 <ath_tgt_attach+0x2aa>
			ds_prev->ds_link = ds->ds_daddr;
  9080ba:	2e9400        	s8i	a14, a9, 0
  9080bd:	2d9401        	s8i	a13, a9, 1
  9080c0:	2b9402        	s8i	a11, a9, 2
  9080c3:	2a9403        	s8i	a10, a9, 3
		}

		ds->ds_link = 0;
  9080c6:	c090      	movi.n	a9, 0
  9080c8:	298400        	s8i	a9, a8, 0
  9080cb:	298401        	s8i	a9, a8, 1
  9080ce:	298402        	s8i	a9, a8, 2
  9080d1:	298403        	s8i	a9, a8, 3
		ds_prev = ds;

		asf_tailq_insert_tail(&sc->sc_rxdesc, ds, ds_list);
  9080d4:	29844c        	s8i	a9, a8, 76
  9080d7:	29844d        	s8i	a9, a8, 77
  9080da:	29844e        	s8i	a9, a8, 78
  9080dd:	29844f        	s8i	a9, a8, 79
  9080e0:	2932da        	l32i	a9, a3, 0x368
	struct ath_rx_desc *ds_prev = NULL;

	asf_tailq_init(&sc->sc_rxdesc);
	asf_tailq_init(&sc->sc_rxdesc_idle);

	for (i = 0; i < ath_numrxdescs; i++, ds++) {
  9080e3:	b1cc      	addi.n	a12, a12, 1
		}

		ds->ds_link = 0;
		ds_prev = ds;

		asf_tailq_insert_tail(&sc->sc_rxdesc, ds, ds_list);
  9080e5:	098a57        	extui	a10, a9, 24, 8
  9080e8:	2a8450        	s8i	a10, a8, 80
  9080eb:	090a57        	extui	a10, a9, 16, 8
  9080ee:	2a8451        	s8i	a10, a8, 81
  9080f1:	098a47        	extui	a10, a9, 8, 8
  9080f4:	298453        	s8i	a9, a8, 83
  9080f7:	2a8452        	s8i	a10, a8, 82
  9080fa:	9890      	s32i.n	a8, a9, 0
  9080fc:	298c4c        	addi	a9, a8, 76
  9080ff:	2936da        	s32i	a9, a3, 0x368
	struct ath_rx_desc *ds_prev = NULL;

	asf_tailq_init(&sc->sc_rxdesc);
	asf_tailq_init(&sc->sc_rxdesc_idle);

	for (i = 0; i < ath_numrxdescs; i++, ds++) {
  908102:	d980      	mov.n	a9, a8
  908104:	288c54        	addi	a8, a8, 84
  908107:	1b72a0        	l32r	a11, 8e4b88 <vdesc_module_install+0xa4c>
  90810a:	8ab0      	l32i.n	a10, a11, 0
  90810c:	7acb02        	bgeu	a12, a10, 908112 <ath_tgt_attach+0x2f6>
  90810f:	63ff31        	j	908044 <ath_tgt_attach+0x228>
		ds_prev = ds;

		asf_tailq_insert_tail(&sc->sc_rxdesc, ds, ds_list);
	}

	error = ath_descdma_setup(sc, &sc->sc_txdma, (ath_bufhead *)&sc->sc_txbuf,
  908112:	283a8c        	movi	a8, 0x38c
  908115:	a838      	add.n	a8, a3, a8
  908117:	281610        	s32i	a8, a1, 64
  90811a:	283ac0        	movi	a8, 0x3c0
  90811d:	a838      	add.n	a8, a3, a8
  90811f:	290a88        	movi	a9, 136
  908122:	1d72a2        	l32r	a13, 8e4bac <vdesc_module_install+0xa70>
  908125:	2b1210        	l32i	a11, a1, 64
  908128:	9910      	s32i.n	a9, a1, 0
  90812a:	dc80      	mov.n	a12, a8
  90812c:	2f0a94        	movi	a15, 148
  90812f:	c2e2      	movi.n	a14, 34
  908131:	da70      	mov.n	a10, a7
  908133:	281611        	s32i	a8, a1, 68
  908136:	291614        	s32i	a9, a1, 80
  908139:	5bf99b        	call8	9067a8 <ath_descdma_setup$isra$21$constprop$26>
  90813c:	d8a0      	mov.n	a8, a10
				  "tx", ATH_TXBUF + 1, ATH_TXDESC,
				  sizeof(struct ath_tx_buf),
				  sizeof(struct ath_tx_desc));
	if (error != 0) {
  90813e:	291214        	l32i	a9, a1, 80
  908141:	c8a3      	beqz.n	a10, 908148 <ath_tgt_attach+0x32c>
  908143:	60002f        	j	908176 <ath_tgt_attach+0x35a>
  908146:	00001c        	mul16u	a0, a0, a0
		ath_descdma_cleanup(sc, &sc->sc_rxdma, (ath_bufhead *)&sc->sc_rxbuf,
				    ADF_OS_DMA_FROM_DEVICE);
		return error;
	}

	error = ath_descdma_setup(sc, &sc->sc_bdma, (ath_bufhead *)&sc->sc_bbuf,
  908149:	72a41d        	ball	a10, a2, 90816a <ath_tgt_attach+0x34e>
  90814c:	72a32b        	bltu	a10, a2, 90817b <ath_tgt_attach+0x35f>
  90814f:	3aa499        	excw
  908152:	102f0a        	l32r	a0, 8d3d7c <_bss_end+0x3c6574>
  908155:	94c0      	s32i.n	a4, a12, 0
  908157:	e1          	.byte 0xe1
  908158:	ac3c      	add.n	a12, a3, a12
  90815a:	ab3b      	add.n	a11, a3, a11
  90815c:	da70      	mov.n	a10, a7
  90815e:	281613        	s32i	a8, a1, 76
  908161:	5bf991        	call8	9067a8 <ath_descdma_setup$isra$21$constprop$26>
				  "beacon", ATH_BCBUF, 1,
				  sizeof(struct ath_tx_buf),
				  sizeof(struct ath_tx_desc));
	if (error != 0) {
  908164:	281213        	l32i	a8, a1, 76
  908167:	c9a9      	beqz.n	a10, 908184 <ath_tgt_attach+0x368>
		ath_descdma_cleanup(sc, &sc->sc_txdma, (ath_bufhead *)&sc->sc_txbuf,
  908169:	2c1211        	l32i	a12, a1, 68
  90816c:	2b1210        	l32i	a11, a1, 64
  90816f:	dd80      	mov.n	a13, a8
  908171:	da30      	mov.n	a10, a3
  908173:	5bf8e3        	call8	906500 <ath_descdma_cleanup>
				    ADF_OS_DMA_TO_DEVICE);
		ath_descdma_cleanup(sc, &sc->sc_rxdma, (ath_bufhead *)&sc->sc_rxbuf,
  908176:	c0d1      	movi.n	a13, 1
  908178:	dc60      	mov.n	a12, a6
  90817a:	db50      	mov.n	a11, a5
  90817c:	da30      	mov.n	a10, a3
  90817e:	5bf8e0        	call8	906500 <ath_descdma_cleanup>
  908181:	6000bc        	j	908241 <ath_tgt_attach+0x425>
				    ADF_OS_DMA_FROM_DEVICE);
		return error;
	}

	bf = asf_tailq_first(&sc->sc_txbuf);
  908184:	2532f0        	l32i	a5, a3, 0x3c0
	bf->bf_isaggr = bf->bf_isretried = bf->bf_retries = 0;
  908187:	c67f      	movi.n	a7, -17
  908189:	265087        	l8ui	a6, a5, 135
  90818c:	2a5486        	s8i	a10, a5, 134
  90818f:	076601        	and	a6, a6, a7
  908192:	27fadf        	movi	a7, -33
  908195:	076601        	and	a6, a6, a7
  908198:	265487        	s8i	a6, a5, 135
	asf_tailq_remove(&sc->sc_txbuf, bf, bf_list);
  90819b:	8659      	l32i.n	a6, a5, 36
  90819d:	875a      	l32i.n	a7, a5, 40
  90819f:	c866      	beqz.n	a6, 9081a9 <ath_tgt_attach+0x38d>
  9081a1:	976a      	s32i.n	a7, a6, 40
  9081a3:	600005        	j	9081ac <ath_tgt_attach+0x390>
  9081a6:	000000        	ill
  9081a9:	2736f1        	s32i	a7, a3, 0x3c4
  9081ac:	875a      	l32i.n	a7, a5, 40
	error = ath_desc_alloc(sc);
	if (error != 0) {
		goto bad;
	}

	BUF_Pool_create_pool(sc->pool_handle, POOL_ID_WLAN_RX_BUF, ath_numrxdescs, 1664);
  9081ae:	c0b3      	movi.n	a11, 3
		return error;
	}

	bf = asf_tailq_first(&sc->sc_txbuf);
	bf->bf_isaggr = bf->bf_isretried = bf->bf_retries = 0;
	asf_tailq_remove(&sc->sc_txbuf, bf, bf_list);
  9081b0:	9670      	s32i.n	a6, a7, 0

	sc->sc_txbuf_held = bf;
  9081b2:	2536dc        	s32i	a5, a3, 0x370
	error = ath_desc_alloc(sc);
	if (error != 0) {
		goto bad;
	}

	BUF_Pool_create_pool(sc->pool_handle, POOL_ID_WLAN_RX_BUF, ath_numrxdescs, 1664);
  9081b5:	1672a0        	l32r	a6, 8e4c38 <vdesc_module_install+0xafc>
  9081b8:	15716e        	l32r	a5, 8e4770 <vdesc_module_install+0x634>
  9081bb:	8c60      	l32i.n	a12, a6, 0
  9081bd:	2552a0        	l32i	a5, a5, 0x280
  9081c0:	8a30      	l32i.n	a10, a3, 0
  9081c2:	2d6a80        	movi	a13, 0x680
  9081c5:	0b5000        	callx8	a5
  9081c8:	c060      	movi.n	a6, 0
  9081ca:	253acc        	movi	a5, 0x3cc
  9081cd:	a535      	add.n	a5, a3, a5
	a_int32_t qnum;
	struct ath_txq *txq;

	sc->sc_txqsetup=0;

	for (qnum=0;qnum<HAL_NUM_TX_QUEUES;qnum++) {
  9081cf:	d860      	mov.n	a8, a6
		txq= &sc->sc_txq[qnum];
		txq->axq_qnum = qnum;
		txq->axq_link = NULL;
  9081d1:	d760      	mov.n	a7, a6
		asf_tailq_init(&txq->axq_q);
		txq->axq_depth = 0;
		txq->axq_linkbuf = NULL;
		asf_tailq_init(&txq->axq_tidq);
		sc->sc_txqsetup |= 1<<qnum;
  9081d3:	c0b1      	movi.n	a11, 1
  9081d5:	c09a      	movi.n	a9, 10
  9081d7:	6d9825        	loop	a9, 908200 <ath_tgt_attach+0x3e4>

	for (qnum=0;qnum<HAL_NUM_TX_QUEUES;qnum++) {
		txq= &sc->sc_txq[qnum];
		txq->axq_qnum = qnum;
		txq->axq_link = NULL;
		asf_tailq_init(&txq->axq_q);
  9081da:	b85a      	addi.n	a10, a5, 8
  9081dc:	9a53      	s32i.n	a10, a5, 12
		txq->axq_depth = 0;
		txq->axq_linkbuf = NULL;
		asf_tailq_init(&txq->axq_tidq);
  9081de:	2a5c18        	addi	a10, a5, 24
  9081e1:	9a57      	s32i.n	a10, a5, 28
		sc->sc_txqsetup |= 1<<qnum;
  9081e3:	008104        	ssl	a8
  9081e6:	00ba1a        	sll	a10, a11

	sc->sc_txqsetup=0;

	for (qnum=0;qnum<HAL_NUM_TX_QUEUES;qnum++) {
		txq= &sc->sc_txq[qnum];
		txq->axq_qnum = qnum;
  9081e9:	9850      	s32i.n	a8, a5, 0
		txq->axq_link = NULL;
  9081eb:	9751      	s32i.n	a7, a5, 4
		asf_tailq_init(&txq->axq_q);
  9081ed:	9752      	s32i.n	a7, a5, 8
		txq->axq_depth = 0;
  9081ef:	9754      	s32i.n	a7, a5, 16
		txq->axq_linkbuf = NULL;
  9081f1:	9755      	s32i.n	a7, a5, 20
		asf_tailq_init(&txq->axq_tidq);
  9081f3:	9756      	s32i.n	a7, a5, 24
		sc->sc_txqsetup |= 1<<qnum;
  9081f5:	06a602        	or	a6, a10, a6
  9081f8:	060647        	extui	a6, a6, 0, 8
	a_int32_t qnum;
	struct ath_txq *txq;

	sc->sc_txqsetup=0;

	for (qnum=0;qnum<HAL_NUM_TX_QUEUES;qnum++) {
  9081fb:	b188      	addi.n	a8, a8, 1
  9081fd:	255c20        	addi	a5, a5, 32
  908200:	253d03        	addmi	a5, a3, 0x300
  908203:	2654c8        	s8i	a6, a5, 200
		txq->axq_linkbuf = NULL;
		asf_tailq_init(&txq->axq_tidq);
		sc->sc_txqsetup |= 1<<qnum;
	}

	sc->sc_uapsdq  = &sc->sc_txq[UAPSDQ_NUM];
  908206:	254aec        	movi	a5, 0x4ec
  908209:	a535      	add.n	a5, a3, a5
  90820b:	952d      	s32i.n	a5, a2, 52
	sc->sc_cabq    = &sc->sc_txq[CABQ_NUM];
  90820d:	254acc        	movi	a5, 0x4cc
  908210:	a535      	add.n	a5, a3, a5
  908212:	952c      	s32i.n	a5, a2, 48

	sc->sc_ac2q[WME_AC_BE]  = &sc->sc_txq[0];
  908214:	253acc        	movi	a5, 0x3cc
  908217:	a535      	add.n	a5, a3, a5
  908219:	9523      	s32i.n	a5, a2, 12
	sc->sc_ac2q[WME_AC_BK]  = &sc->sc_txq[1];
  90821b:	253aec        	movi	a5, 0x3ec
  90821e:	a535      	add.n	a5, a3, a5
  908220:	9524      	s32i.n	a5, a2, 16
	sc->sc_ac2q[WME_AC_VI]  = &sc->sc_txq[2];
  908222:	254a0c        	movi	a5, 0x40c
  908225:	a535      	add.n	a5, a3, a5
  908227:	9525      	s32i.n	a5, a2, 20
	sc->sc_ac2q[WME_AC_VO]  = &sc->sc_txq[3];
  908229:	254a2c        	movi	a5, 0x42c
  90822c:	a535      	add.n	a5, a3, a5
  90822e:	9526      	s32i.n	a5, a2, 24

	BUF_Pool_create_pool(sc->pool_handle, POOL_ID_WLAN_RX_BUF, ath_numrxdescs, 1664);

	ath_tgt_txq_setup(sc);
	sc->sc_imask =0;
	ah->ah_setInterrupts(ah, 0);
  908230:	224228        	l32i	a2, a4, 160
	}

	BUF_Pool_create_pool(sc->pool_handle, POOL_ID_WLAN_RX_BUF, ath_numrxdescs, 1664);

	ath_tgt_txq_setup(sc);
	sc->sc_imask =0;
  908233:	2736c4        	s32i	a7, a3, 0x310
	ah->ah_setInterrupts(ah, 0);
  908236:	c0b0      	movi.n	a11, 0
  908238:	da40      	mov.n	a10, a4
  90823a:	0b2000        	callx8	a2

	return 0;
  90823d:	c020      	movi.n	a2, 0
  90823f:	d10f      	retw.n
bad:
bad2:
	ath_desc_free(sc);
  908241:	da30      	mov.n	a10, a3
  908243:	5bf946        	call8	90675c <ath_desc_free>
	if (ah)
		ah->ah_detach(ah);
  908246:	8246      	l32i.n	a2, a4, 24
  908248:	da40      	mov.n	a10, a4
  90824a:	0b2000        	callx8	a2
}
  90824d:	d10f      	retw.n
  90824f:	00da30        	excw
	ah->ah_setInterrupts(ah, 0);

	return 0;
bad:
bad2:
	ath_desc_free(sc);
  908252:	5bf942        	call8	90675c <ath_desc_free>
  908255:	63fff4        	j	90824d <ath_tgt_attach+0x431>

00908258 <ath_detach>:
	HIF_shutdown(sc->tgt_hif_handle);
	BUF_Pool_shutdown(sc->pool_handle);
}

a_int32_t ath_detach(struct ath_softc_tgt *sc)
{
  908258:	6c1004        	entry	a1, 32

static void tgt_hif_htc_wmi_shutdown(struct ath_softc_tgt *sc)
{
	HTC_NotifyTargetDetached(sc->tgt_htc_handle);

	WMI_Shutdown(sc->tgt_wmi_handle);
  90825b:	13716e        	l32r	a3, 8e4814 <vdesc_module_install+0x6d8>
  90825e:	8a23      	l32i.n	a10, a2, 12
  908260:	283297        	l32i	a8, a3, 0x25c
  908263:	0b8000        	callx8	a8
	HTC_Shutdown(sc->tgt_htc_handle);
  908266:	8a22      	l32i.n	a10, a2, 8
  908268:	283284        	l32i	a8, a3, 0x210
  90826b:	0b8000        	callx8	a8
	HIF_shutdown(sc->tgt_hif_handle);
  90826e:	8a21      	l32i.n	a10, a2, 4
  908270:	283276        	l32i	a8, a3, 0x1d8
  908273:	0b8000        	callx8	a8
	BUF_Pool_shutdown(sc->pool_handle);
  908276:	8a20      	l32i.n	a10, a2, 0
  908278:	23329f        	l32i	a3, a3, 0x27c
  90827b:	0b3000        	callx8	a3
}

a_int32_t ath_detach(struct ath_softc_tgt *sc)
{
	tgt_hif_htc_wmi_shutdown(sc);
}
  90827e:	d10f      	retw.n

00908280 <__adf_os_dmamem_alloc>:
 * @return void* (Virtual address)
 */
inline void*
__adf_os_dmamem_alloc(__adf_os_device_t osdev, adf_os_size_t size, 
                      a_bool_t coherent, __adf_os_dma_map_t *dmap)
{    
  908280:	6c1004        	entry	a1, 32
    (*dmap) = A_ALLOCRAM(sizeof(struct __adf_dma_map));
  908283:	16716e        	l32r	a6, 8e483c <vdesc_module_install+0x700>
  908286:	c0bc      	movi.n	a11, 12
  908288:	226252        	l32i	a2, a6, 0x148
  90828b:	c0a0      	movi.n	a10, 0
  90828d:	0b2000        	callx8	a2
  908290:	9a50      	s32i.n	a10, a5, 0
  908292:	d4a0      	mov.n	a4, a10
    (*dmap)->ds_len = size;
    
    return (*dmap)->ds_addr;
    
fail_malloc: 
    return NULL;            
  908294:	d2a0      	mov.n	a2, a10
__adf_os_dmamem_alloc(__adf_os_device_t osdev, adf_os_size_t size, 
                      a_bool_t coherent, __adf_os_dma_map_t *dmap)
{    
    (*dmap) = A_ALLOCRAM(sizeof(struct __adf_dma_map));
    
	if((*dmap) == NULL){
  908296:	c9a2      	beqz.n	a10, 9082ac <__adf_os_dmamem_alloc+0x2c>
		goto fail_malloc;
	}
	    
    (*dmap)->ds_addr = A_ALLOCRAM(size);
  908298:	226252        	l32i	a2, a6, 0x148
  90829b:	db30      	mov.n	a11, a3
  90829d:	c0a0      	movi.n	a10, 0
  90829f:	0b2000        	callx8	a2
    (*dmap)->ds_len = size;
  9082a2:	8250      	l32i.n	a2, a5, 0
    
	if((*dmap) == NULL){
		goto fail_malloc;
	}
	    
    (*dmap)->ds_addr = A_ALLOCRAM(size);
  9082a4:	9a41      	s32i.n	a10, a4, 4
    (*dmap)->ds_len = size;
  9082a6:	232504        	s16i	a3, a2, 8
    
    return (*dmap)->ds_addr;
  9082a9:	222201        	l32i	a2, a2, 4
    
fail_malloc: 
    return NULL;            
}
  9082ac:	d10f      	retw.n
	...

009082b0 <rcIsValidPhyRate>:

/* Return true only for single stream */

static A_BOOL
rcIsValidPhyRate(A_UINT32 phy, A_UINT32 capflag, A_BOOL ignoreCW)
{
  9082b0:	6c1004        	entry	a1, 32
	if (WLAN_RC_PHY_HT(phy) && !(capflag & WLAN_RC_HT_FLAG)) {
  9082b3:	6e2405        	bltui	a2, 4, 9082bc <rcIsValidPhyRate+0xc>
		return FALSE;
  9082b6:	280a00        	movi	a8, 0
/* Return true only for single stream */

static A_BOOL
rcIsValidPhyRate(A_UINT32 phy, A_UINT32 capflag, A_BOOL ignoreCW)
{
	if (WLAN_RC_PHY_HT(phy) && !(capflag & WLAN_RC_HT_FLAG)) {
  9082b9:	7c3747        	bbci	a3, 28, 908304 <rcIsValidPhyRate+0x54>
		return FALSE;
	}

	if (WLAN_RC_PHY_DS(phy) && !(capflag & WLAN_RC_DS_FLAG))  {
  9082bc:	c78d      	movi.n	a8, -3
  9082be:	082801        	and	a8, a2, a8
  9082c1:	288cfb        	addi	a8, a8, -5
  9082c4:	29fafb        	movi	a9, -5
  9082c7:	098801        	and	a8, a8, a9
  9082ca:	658002        	bnez	a8, 9082d0 <rcIsValidPhyRate+0x20>
  9082cd:	7f3733        	bbci	a3, 31, 908304 <rcIsValidPhyRate+0x54>
		return FALSE;
	}
	if (WLAN_RC_PHY_SGI(phy) && !(capflag & WLAN_RC_HT40_SGI_FLAG)) {
  9082d0:	282cf8        	addi	a8, a2, -8
  9082d3:	6f8405        	bgeui	a8, 4, 9082dc <rcIsValidPhyRate+0x2c>

static A_BOOL
rcIsValidPhyRate(A_UINT32 phy, A_UINT32 capflag, A_BOOL ignoreCW)
{
	if (WLAN_RC_PHY_HT(phy) && !(capflag & WLAN_RC_HT_FLAG)) {
		return FALSE;
  9082d6:	280a00        	movi	a8, 0
	}

	if (WLAN_RC_PHY_DS(phy) && !(capflag & WLAN_RC_DS_FLAG))  {
		return FALSE;
	}
	if (WLAN_RC_PHY_SGI(phy) && !(capflag & WLAN_RC_HT40_SGI_FLAG)) {
  9082d9:	7d3727        	bbci	a3, 29, 908304 <rcIsValidPhyRate+0x54>
		return FALSE;
	}

	if (!ignoreCW && WLAN_RC_PHY_HT(phy)) {
  9082dc:	c091      	movi.n	a9, 1
  9082de:	ce40      	bnez.n	a4, 908302 <rcIsValidPhyRate+0x52>
  9082e0:	6e241e        	bltui	a2, 4, 908302 <rcIsValidPhyRate+0x52>
		if (WLAN_RC_PHY_40(phy) && !(capflag & WLAN_RC_40_FLAG)) {
  9082e3:	c78b      	movi.n	a8, -5
  9082e5:	222cfa        	addi	a2, a2, -6
  9082e8:	082201        	and	a2, a2, a8
			return FALSE;
		}

		if (!WLAN_RC_PHY_40(phy) && (capflag & WLAN_RC_40_FLAG)) {
  9082eb:	031840        	extui	a8, a3, 1, 1
  9082ee:	098803        	xor	a8, a8, a9
	if (WLAN_RC_PHY_SGI(phy) && !(capflag & WLAN_RC_HT40_SGI_FLAG)) {
		return FALSE;
	}

	if (!ignoreCW && WLAN_RC_PHY_HT(phy)) {
		if (WLAN_RC_PHY_40(phy) && !(capflag & WLAN_RC_40_FLAG)) {
  9082f1:	6f220f        	bgeui	a2, 2, 908304 <rcIsValidPhyRate+0x54>
  9082f4:	c082      	movi.n	a8, 2
  9082f6:	083301        	and	a3, a3, a8
		if (!WLAN_RC_PHY_40(phy) && (capflag & WLAN_RC_40_FLAG)) {
			return FALSE;
		}
	}
    
	return TRUE;
  9082f9:	c080      	movi.n	a8, 0
  9082fb:	039839        	movnez	a8, a9, a3
  9082fe:	600002        	j	908304 <rcIsValidPhyRate+0x54>
  908301:	00c081        	excw
}
  908304:	d280      	mov.n	a2, a8
  908306:	d10f      	retw.n

00908308 <rcUpdate_ht$constprop$6>:
		}
	}
}

static void
rcUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an, int txRate, 
  908308:	6c1006        	entry	a1, 48
  90830b:	2c1119        	l16ui	a12, a1, 50
  90830e:	07084f        	extui	a8, a7, 0, 16
            A_BOOL Xretries, int retries, A_UINT8 curTxAnt, 
            A_UINT16 nFrames, A_UINT16 nBad)
{
	TX_RATE_CTRL *pRc;
	A_UINT32 nowMsec = A_MS_TICKGET();
  908311:	c0a0      	movi.n	a10, 0
  908313:	9811      	s32i.n	a8, a1, 4
  908315:	9c12      	s32i.n	a12, a1, 8
  908317:	9510      	s32i.n	a5, a1, 0
  908319:	5bee15        	call8	903b70 <ath_hal_getuptime>
	A_UINT8 lastPer;
	int rate,count;
	struct atheros_node *pSib = ATH_NODE_ATHEROS(an);
  90831c:	233282        	l32i	a3, a3, 0x208
rcUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an, int txRate, 
            A_BOOL Xretries, int retries, A_UINT8 curTxAnt, 
            A_UINT16 nFrames, A_UINT16 nBad)
{
	TX_RATE_CTRL *pRc;
	A_UINT32 nowMsec = A_MS_TICKGET();
  90831f:	d9a0      	mov.n	a9, a10
	pRc = (TX_RATE_CTRL *)(pSib);

	ASSERT(retries >= 0 && retries < MAX_TX_RETRIES);
	ASSERT(txRate >= 0);
    
	if (txRate < 0) {
  908321:	8811      	l32i.n	a8, a1, 4
  908323:	8b10      	l32i.n	a11, a1, 0
  908325:	8c12      	l32i.n	a12, a1, 8
  908327:	6431d5        	beqz	a3, 908500 <rcUpdate_ht$constprop$6+0x1f8>
  90832a:	6641d2        	bltz	a4, 908500 <rcUpdate_ht$constprop$6+0x1f8>
	A_UINT32 nowMsec = A_MS_TICKGET();
	A_UINT8 lastPer;
	int rate,count;
	struct atheros_node *pSib = ATH_NODE_ATHEROS(an);
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  90832d:	272248        	l32i	a7, a2, 0x120
  908330:	2222c2        	l32i	a2, a2, 0x308
  908333:	0e2211        	slli	a2, a2, 2
  908336:	a272      	add.n	a2, a7, a2
  908338:	8521      	l32i.n	a5, a2, 4
    
	if (txRate < 0) {
		return;
	}

	lastPer = pRc->state[txRate].per;
  90833a:	a432      	add.n	a2, a3, a4
  90833c:	272000        	l8ui	a7, a2, 0

	if (Xretries) {
  90833f:	cbb3      	beqz.n	a11, 908376 <rcUpdate_ht$constprop$6+0x6e>
		/* Update the PER. */
		if (Xretries == 1) {
  908341:	69b115        	bnei	a11, 1, 90835a <rcUpdate_ht$constprop$6+0x52>
			pRc->state[txRate].per += 30;
  908344:	267c1e        	addi	a6, a7, 30
  908347:	060647        	extui	a6, a6, 0, 8
			if (pRc->state[txRate].per > 100) {
  90834a:	280a64        	movi	a8, 100
  90834d:	768303        	bltu	a8, a6, 908354 <rcUpdate_ht$constprop$6+0x4c>
  908350:	60000e        	j	908362 <rcUpdate_ht$constprop$6+0x5a>
  908353:	002824        	excw
				pRc->state[txRate].per = 100;
  908356:	006000        	excw
  908359:	0abc76        	excw
			if (retries >= count) {
				retries = count - 1;
			}

			/* new_PER = 7/8*old_PER + 1/8*(currentPER) */
			pRc->state[txRate].per = (A_UINT8)(pRc->state[txRate].per - 
  90835c:	073814        	srli	a8, a7, 3
  90835f:	08660c        	sub	a6, a6, a8
  908362:	262400        	s8i	a6, a2, 0
						   (pRc->state[txRate].per / 8) + ((100) / 8));
		}

		/* Xretries == 1 or 2 */

		if (pRc->probeRate == txRate)
  908365:	263037        	l8ui	a6, a3, 55
  908368:	764102        	beq	a4, a6, 90836e <rcUpdate_ht$constprop$6+0x66>
  90836b:	6000bd        	j	90842c <rcUpdate_ht$constprop$6+0x124>
			pRc->probeRate = 0;
  90836e:	c060      	movi.n	a6, 0
  908370:	263437        	s8i	a6, a3, 55
  908373:	6000b5        	j	90842c <rcUpdate_ht$constprop$6+0x124>
  908376:	c0a9      	movi.n	a10, 9
  908378:	0a6634        	min	a6, a6, a10
		count = sizeof(nRetry2PerLookup) / sizeof(nRetry2PerLookup[0]);
		if (retries >= count) {
			retries = count - 1;
		}

		if (nBad) {
  90837b:	cbca      	beqz.n	a12, 9083b9 <rcUpdate_ht$constprop$6+0xb1>
			 * that part is 100 * nBad / nFrames, and it contributes
			 * 100 * nBad / (nFrames * (retries+1)) to the above
			 * PER.  The expression below is a simplified version
			 * of the sum of these two terms.
			 */
			if (nFrames > 0)
  90837d:	648050        	beqz	a8, 9083d1 <rcUpdate_ht$constprop$6+0xc9>
				pRc->state[txRate].per = (A_UINT8)(pRc->state[txRate].per - 
					   (pRc->state[txRate].per / 8) + 
					   ((100*(retries*nFrames + nBad)/(nFrames*(retries+1))) / 8));
  908380:	068b28        	mull	a11, a8, a6
  908383:	9811      	s32i.n	a8, a1, 4
  908385:	abcd      	add.n	a13, a12, a11
  908387:	0eda11        	slli	a10, a13, 2
  90838a:	adaa      	add.n	a10, a10, a13
  90838c:	0ead11        	slli	a13, a10, 2
  90838f:	adaa      	add.n	a10, a10, a13
  908391:	ab8b      	add.n	a11, a8, a11
  908393:	0eaa11        	slli	a10, a10, 2
  908396:	9910      	s32i.n	a9, a1, 0
  908398:	9c12      	s32i.n	a12, a1, 8
  90839a:	5b7254        	call8	8e4cec <__divsi3>
  90839d:	b7ab      	addi.n	a11, a10, 7
  90839f:	0aba3a        	movltz	a10, a11, a10
  9083a2:	0a3a12        	srai	a10, a10, 3
			 * 100 * nBad / (nFrames * (retries+1)) to the above
			 * PER.  The expression below is a simplified version
			 * of the sum of these two terms.
			 */
			if (nFrames > 0)
				pRc->state[txRate].per = (A_UINT8)(pRc->state[txRate].per - 
  9083a5:	aa7a      	add.n	a10, a7, a10
  9083a7:	073b14        	srli	a11, a7, 3
  9083aa:	0baa0c        	sub	a10, a10, a11
  9083ad:	2a2400        	s8i	a10, a2, 0
  9083b0:	8811      	l32i.n	a8, a1, 4
  9083b2:	8910      	l32i.n	a9, a1, 0
  9083b4:	8c12      	l32i.n	a12, a1, 8
  9083b6:	600017        	j	9083d1 <rcUpdate_ht$constprop$6+0xc9>
					   ((100*(retries*nFrames + nBad)/(nFrames*(retries+1))) / 8));
		} else {
			/* new_PER = 7/8*old_PER + 1/8*(currentPER) */

			pRc->state[txRate].per = (A_UINT8)(pRc->state[txRate].per - 
				   (pRc->state[txRate].per / 8) + (nRetry2PerLookup[retries] / 8));
  9083b9:	1a72a5        	l32r	a10, 8e4e50 <__umodsi3+0x60>
  9083bc:	0e6b11        	slli	a11, a6, 2
  9083bf:	abaa      	add.n	a10, a10, a11
  9083c1:	8aa0      	l32i.n	a10, a10, 0
					   (pRc->state[txRate].per / 8) + 
					   ((100*(retries*nFrames + nBad)/(nFrames*(retries+1))) / 8));
		} else {
			/* new_PER = 7/8*old_PER + 1/8*(currentPER) */

			pRc->state[txRate].per = (A_UINT8)(pRc->state[txRate].per - 
  9083c3:	073b14        	srli	a11, a7, 3
				   (pRc->state[txRate].per / 8) + (nRetry2PerLookup[retries] / 8));
  9083c6:	0a3a14        	srli	a10, a10, 3
					   (pRc->state[txRate].per / 8) + 
					   ((100*(retries*nFrames + nBad)/(nFrames*(retries+1))) / 8));
		} else {
			/* new_PER = 7/8*old_PER + 1/8*(currentPER) */

			pRc->state[txRate].per = (A_UINT8)(pRc->state[txRate].per - 
  9083c9:	aa7a      	add.n	a10, a7, a10
  9083cb:	0baa0c        	sub	a10, a10, a11
  9083ce:	2a2400        	s8i	a10, a2, 0
		/*
		 * If we got at most one retry then increase the max rate if
		 * this was a probe.  Otherwise, ignore the probe.
		 */

		if (pRc->probeRate && pRc->probeRate == txRate) {
  9083d1:	2a3037        	l8ui	a10, a3, 55
  9083d4:	cba8      	beqz.n	a10, 908410 <rcUpdate_ht$constprop$6+0x108>
  9083d6:	7a4936        	bne	a4, a10, 908410 <rcUpdate_ht$constprop$6+0x108>
			if (retries > 0 || 2 * nBad > nFrames) {
  9083d9:	6b6105        	bgei	a6, 1, 9083e2 <rcUpdate_ht$constprop$6+0xda>
  9083dc:	0fcc11        	slli	a12, a12, 1
  9083df:	7c8a09        	bge	a8, a12, 9083ec <rcUpdate_ht$constprop$6+0xe4>
				 * any retries means the probe failed.  Also,
				 * if the attempt worked, but more than half
				 * the subframes were bad then also consider
				 * the probe a failure.
				 */
				pRc->probeRate = 0;
  9083e2:	c080      	movi.n	a8, 0
  9083e4:	283437        	s8i	a8, a3, 55
  9083e7:	600025        	j	908410 <rcUpdate_ht$constprop$6+0x108>
  9083ea:	000024        	excw
			} else {
				pRc->rateMaxPhy = pRc->probeRate;
  9083ed:	347d26        	excw

				if (pRc->state[pRc->probeRate].per > 30) {
  9083f0:	2000c1        	l8ui	a0, a0, 193
  9083f3:	8e76      	l32i.n	a14, a7, 24
  9083f5:	8b04      	l32i.n	a11, a0, 16
					pRc->state[pRc->probeRate].per = 20;
  9083f7:	c164      	movi.n	a6, 20
  9083f9:	262400        	s8i	a6, a2, 0
				}

				pRc->probeRate = 0;
  9083fc:	c060      	movi.n	a6, 0
  9083fe:	263437        	s8i	a6, a3, 55
				/*
				 * Since this probe succeeded, we allow the next probe
				 * twice as soon.  This allows the maxRate to move up
				 * faster if the probes are succesful.
				 */
				pRc->probeTime = nowMsec - pRateTable->probeInterval / 2;
  908401:	265001        	l8ui	a6, a5, 1
  908404:	061614        	srli	a6, a6, 1
  908407:	06960c        	sub	a6, a9, a6
  90840a:	963f      	s32i.n	a6, a3, 60
  90840c:	600008        	j	908418 <rcUpdate_ht$constprop$6+0x110>
  90840f:	006a61        	excw
			}
		}

		if (retries > 0) {
  908412:	04c060        	excw
			 *
			 * Later: if rssiAck is close to pRc->state[txRate].rssiThres
			 * and we see lots of retries, then we could increase
			 * pRc->state[txRate].rssiThres.
			 */
			pRc->hwMaxRetryPktCnt = 0;
  908415:	600010        	j	908429 <rcUpdate_ht$constprop$6+0x121>
		} else {
			/*
			 * It worked with no retries.  First ignore bogus (small)
			 * rssiAck values.
			 */
			if (txRate == pRc->rateMaxPhy && pRc->hwMaxRetryPktCnt < 255) {
  908418:	26307d        	l8ui	a6, a3, 125
  90841b:	76490d        	bne	a4, a6, 90842c <rcUpdate_ht$constprop$6+0x124>
  90841e:	263040        	l8ui	a6, a3, 64
  908421:	280aff        	movi	a8, 255
  908424:	786104        	beq	a6, a8, 90842c <rcUpdate_ht$constprop$6+0x124>
				pRc->hwMaxRetryPktCnt++;
  908427:	b166      	addi.n	a6, a6, 1
  908429:	263440        	s8i	a6, a3, 64
    
	/*
	 * If this rate looks bad (high PER) then stop using it for
	 * a while (except if we are probing).
	 */
	if (pRc->state[txRate].per >= 55 && txRate > 0 &&
  90842c:	2a2000        	l8ui	a10, a2, 0
  90842f:	64404b        	beqz	a4, 90847e <rcUpdate_ht$constprop$6+0x176>
  908432:	c366      	movi.n	a6, 54
  908434:	7a6b46        	bgeu	a6, a10, 90847e <rcUpdate_ht$constprop$6+0x176>
	    pRateTable->info[txRate].rateKbps <= 
            pRateTable->info[pRc->rateMaxPhy].rateKbps)
  908437:	2b307d        	l8ui	a11, a3, 125
	/*
	 * If this rate looks bad (high PER) then stop using it for
	 * a while (except if we are probing).
	 */
	if (pRc->state[txRate].per >= 55 && txRate > 0 &&
	    pRateTable->info[txRate].rateKbps <= 
  90843a:	0e4811        	slli	a8, a4, 2
            pRateTable->info[pRc->rateMaxPhy].rateKbps)
  90843d:	0eb611        	slli	a6, a11, 2
	/*
	 * If this rate looks bad (high PER) then stop using it for
	 * a while (except if we are probing).
	 */
	if (pRc->state[txRate].per >= 55 && txRate > 0 &&
	    pRateTable->info[txRate].rateKbps <= 
  908440:	a488      	add.n	a8, a8, a4
            pRateTable->info[pRc->rateMaxPhy].rateKbps)
  908442:	ab66      	add.n	a6, a6, a11
	/*
	 * If this rate looks bad (high PER) then stop using it for
	 * a while (except if we are probing).
	 */
	if (pRc->state[txRate].per >= 55 && txRate > 0 &&
	    pRateTable->info[txRate].rateKbps <= 
  908444:	0d8811        	slli	a8, a8, 3
            pRateTable->info[pRc->rateMaxPhy].rateKbps)
  908447:	0d6611        	slli	a6, a6, 3
	/*
	 * If this rate looks bad (high PER) then stop using it for
	 * a while (except if we are probing).
	 */
	if (pRc->state[txRate].per >= 55 && txRate > 0 &&
	    pRateTable->info[txRate].rateKbps <= 
  90844a:	a858      	add.n	a8, a5, a8
            pRateTable->info[pRc->rateMaxPhy].rateKbps)
  90844c:	a656      	add.n	a6, a5, a6
    
	/*
	 * If this rate looks bad (high PER) then stop using it for
	 * a while (except if we are probing).
	 */
	if (pRc->state[txRate].per >= 55 && txRate > 0 &&
  90844e:	8884      	l32i.n	a8, a8, 16
  908450:	8664      	l32i.n	a6, a6, 16
  908452:	786328        	bltu	a6, a8, 90847e <rcUpdate_ht$constprop$6+0x176>
  908455:	040c47        	extui	a12, a4, 0, 8
rcGetNextLowerValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc,  
                          A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_INT8 i;

	for (i = 1; i < pRc->maxValidRate ; i++) {
  908458:	2b3041        	l8ui	a11, a3, 65
  90845b:	c081      	movi.n	a8, 1
  90845d:	600015        	j	908476 <rcUpdate_ht$constprop$6+0x16e>
		if (pRc->validRateIndex[i] == curValidTxRate) {
  908460:	a636      	add.n	a6, a3, a6
  908462:	2d6042        	l8ui	a13, a6, 66
  908465:	7cd908        	bne	a13, a12, 908471 <rcUpdate_ht$constprop$6+0x169>
			*pNextIndex = pRc->validRateIndex[i-1];
  908468:	266041        	l8ui	a6, a6, 65
  90846b:	26347d        	s8i	a6, a3, 125
  90846e:	60000a        	j	90847c <rcUpdate_ht$constprop$6+0x174>
  908471:	b188      	addi.n	a8, a8, 1
rcGetNextLowerValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc,  
                          A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_INT8 i;

	for (i = 1; i < pRc->maxValidRate ; i++) {
  908473:	080847        	extui	a8, a8, 0, 8
  908476:	008632        	sext	a6, a8, 7
  908479:	7b62e3        	blt	a6, a11, 908460 <rcUpdate_ht$constprop$6+0x158>
	{
		rcGetNextLowerValidTxRate(pRateTable, pRc, (A_UINT8) txRate, 
					  &pRc->rateMaxPhy);

		/* Don't probe for a little while. */
		pRc->probeTime = nowMsec;
  90847c:	993f      	s32i.n	a9, a3, 60
	}

	/* Make sure the rates below this have lower PER */
	/* Monotonicity is kept only for rates below the current rate. */
	if (pRc->state[txRate].per < lastPer) {
  90847e:	77a307        	bltu	a10, a7, 908489 <rcUpdate_ht$constprop$6+0x181>
			}
		}
	}

	/* Maintain monotonicity for rates above the current rate*/
	for (rate = txRate; rate < pRc->rateTableSize - 1; rate++) {
  908481:	263036        	l8ui	a6, a3, 54
  908484:	b067      	addi.n	a7, a6, -1
  908486:	600044        	j	9084ce <rcUpdate_ht$constprop$6+0x1c6>
  908489:	0e4611        	slli	a6, a4, 2
  90848c:	a464      	add.n	a4, a6, a4
  90848e:	0d4411        	slli	a4, a4, 3
  908491:	264ce4        	addi	a6, a4, -28
  908494:	d720      	mov.n	a7, a2
  908496:	a656      	add.n	a6, a5, a6

	/* Make sure the rates below this have lower PER */
	/* Monotonicity is kept only for rates below the current rate. */
	if (pRc->state[txRate].per < lastPer) {
		for (rate = txRate - 1; rate >= 0; rate--) {
			if (pRateTable->info[rate].phy != pRateTable->info[txRate].phy) {
  908498:	a454      	add.n	a4, a5, a4
  90849a:	60001b        	j	9084b9 <rcUpdate_ht$constprop$6+0x1b1>
  90849d:	2a6000        	l8ui	a10, a6, 0
  9084a0:	28400c        	l8ui	a8, a4, 12
  9084a3:	78a9da        	bne	a10, a8, 908481 <rcUpdate_ht$constprop$6+0x179>
  9084a6:	b078      	addi.n	a8, a7, -1
				break;
			}

			if (pRc->state[rate].per > pRc->state[rate+1].per) {
  9084a8:	2a8000        	l8ui	a10, a8, 0
  9084ab:	277000        	l8ui	a7, a7, 0
  9084ae:	7a7b02        	bgeu	a7, a10, 9084b4 <rcUpdate_ht$constprop$6+0x1ac>
				pRc->state[rate].per = pRc->state[rate+1].per;
  9084b1:	278400        	s8i	a7, a8, 0
  9084b4:	d780      	mov.n	a7, a8
  9084b6:	266cd8        	addi	a6, a6, -40
	}

	/* Make sure the rates below this have lower PER */
	/* Monotonicity is kept only for rates below the current rate. */
	if (pRc->state[txRate].per < lastPer) {
		for (rate = txRate - 1; rate >= 0; rate--) {
  9084b9:	7739e0        	bne	a3, a7, 90849d <rcUpdate_ht$constprop$6+0x195>
  9084bc:	63ffc1        	j	908481 <rcUpdate_ht$constprop$6+0x179>
  9084bf:	002420        	excw
		}
	}

	/* Maintain monotonicity for rates above the current rate*/
	for (rate = txRate; rate < pRc->rateTableSize - 1; rate++) {
		if (pRc->state[rate+1].per < pRc->state[rate].per) {
  9084c2:	002820        	excw
  9084c5:	01748b        	excw
  9084c8:	022424        	excw
			pRc->state[rate+1].per = pRc->state[rate].per;
  9084cb:	01b122        	excw
			}
		}
	}

	/* Maintain monotonicity for rates above the current rate*/
	for (rate = txRate; rate < pRc->rateTableSize - 1; rate++) {
  9084ce:	03240c        	sub	a4, a2, a3
  9084d1:	7742eb        	blt	a4, a7, 9084c0 <rcUpdate_ht$constprop$6+0x1b8>
			pRc->state[rate+1].per = pRc->state[rate].per;
		}
	}

	/* Every so often, we reduce the thresholds and PER (different for CCK and OFDM). */
	if (nowMsec - pRc->perDownTime >= pRateTable->rssiReduceInterval) {
  9084d4:	22321e        	l32i	a2, a3, 120
  9084d7:	245002        	l8ui	a4, a5, 2
  9084da:	02920c        	sub	a2, a9, a2
  9084dd:	74231f        	bltu	a2, a4, 908500 <rcUpdate_ht$constprop$6+0x1f8>
  9084e0:	d230      	mov.n	a2, a3
  9084e2:	600011        	j	9084f7 <rcUpdate_ht$constprop$6+0x1ef>
		for (rate = 0; rate < pRc->rateTableSize; rate++) {
			pRc->state[rate].per = 7*pRc->state[rate].per/8;
  9084e5:	252000        	l8ui	a5, a2, 0
  9084e8:	0d5411        	slli	a4, a5, 3
  9084eb:	05440c        	sub	a4, a4, a5
  9084ee:	043412        	srai	a4, a4, 3
  9084f1:	242400        	s8i	a4, a2, 0
  9084f4:	222c01        	addi	a2, a2, 1
		}
	}

	/* Every so often, we reduce the thresholds and PER (different for CCK and OFDM). */
	if (nowMsec - pRc->perDownTime >= pRateTable->rssiReduceInterval) {
		for (rate = 0; rate < pRc->rateTableSize; rate++) {
  9084f7:	03240c        	sub	a4, a2, a3
  9084fa:	7642e7        	blt	a4, a6, 9084e5 <rcUpdate_ht$constprop$6+0x1dd>
			pRc->state[rate].per = 7*pRc->state[rate].per/8;
		}

		pRc->perDownTime = nowMsec;
  9084fd:	29361e        	s32i	a9, a3, 120
  908500:	d10f      	retw.n
	...

00908504 <rcRateSetseries$constprop$11>:

	return rate;
}

static void
rcRateSetseries(const RATE_TABLE_11N *pRateTable ,
  908504:	6c1004        	entry	a1, 32
  908507:	0e5911        	slli	a9, a5, 2
  90850a:	a599      	add.n	a9, a9, a5
  90850c:	0d9911        	slli	a9, a9, 3
                struct ath_rc_series *series,
		A_UINT8 tries, A_UINT8 rix,
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
	series->tries = tries;
  90850f:	243401        	s8i	a4, a3, 1
  908512:	a929      	add.n	a9, a2, a9
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
		(WLAN_RC_PHY_DS(pRateTable->info[rix].phy) ? ATH_RC_DS_FLAG : 0) | 
  908514:	2a900c        	l8ui	a10, a9, 12
  908517:	c78d      	movi.n	a8, -3
  908519:	08a801        	and	a8, a10, a8
                struct ath_rc_series *series,
		A_UINT8 tries, A_UINT8 rix,
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
	series->tries = tries;
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
  90851c:	c0c0      	movi.n	a12, 0
		(WLAN_RC_PHY_DS(pRateTable->info[rix].phy) ? ATH_RC_DS_FLAG : 0) | 
  90851e:	c7db      	movi.n	a13, -5
  908520:	288cfb        	addi	a8, a8, -5
                struct ath_rc_series *series,
		A_UINT8 tries, A_UINT8 rix,
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
	series->tries = tries;
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
  908523:	c0b1      	movi.n	a11, 1
  908525:	d4c0      	mov.n	a4, a12
		(WLAN_RC_PHY_DS(pRateTable->info[rix].phy) ? ATH_RC_DS_FLAG : 0) | 
  908527:	0d8801        	and	a8, a8, a13
                struct ath_rc_series *series,
		A_UINT8 tries, A_UINT8 rix,
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
	series->tries = tries;
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
  90852a:	06b439        	movnez	a4, a11, a6
		(WLAN_RC_PHY_DS(pRateTable->info[rix].phy) ? ATH_RC_DS_FLAG : 0) | 
  90852d:	080847        	extui	a8, a8, 0, 8
                struct ath_rc_series *series,
		A_UINT8 tries, A_UINT8 rix,
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
	series->tries = tries;
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
  908530:	0c4611        	slli	a6, a4, 4
		(WLAN_RC_PHY_DS(pRateTable->info[rix].phy) ? ATH_RC_DS_FLAG : 0) | 
  908533:	08cb39        	movnez	a11, a12, a8
                struct ath_rc_series *series,
		A_UINT8 tries, A_UINT8 rix,
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
	series->tries = tries;
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
  908536:	06b802        	or	a8, a11, a6
		(WLAN_RC_PHY_DS(pRateTable->info[rix].phy) ? ATH_RC_DS_FLAG : 0) | 
		(WLAN_RC_PHY_40(pRateTable->info[rix].phy) ? ATH_RC_CW40_FLAG : 0) | 
  908539:	2bacfa        	addi	a11, a10, -6
  90853c:	0dbb01        	and	a11, a11, a13
  90853f:	0b0b47        	extui	a11, a11, 0, 8
		A_UINT8 tries, A_UINT8 rix,
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
	series->tries = tries;
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
		(WLAN_RC_PHY_DS(pRateTable->info[rix].phy) ? ATH_RC_DS_FLAG : 0) | 
  908542:	c062      	movi.n	a6, 2
		(WLAN_RC_PHY_40(pRateTable->info[rix].phy) ? ATH_RC_CW40_FLAG : 0) | 
  908544:	76b301        	bltu	a11, a6, 908549 <rcRateSetseries$constprop$11+0x45>
		A_UINT8 tries, A_UINT8 rix,
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
	series->tries = tries;
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
		(WLAN_RC_PHY_DS(pRateTable->info[rix].phy) ? ATH_RC_DS_FLAG : 0) | 
  908547:	d6c0      	mov.n	a6, a12
		(WLAN_RC_PHY_40(pRateTable->info[rix].phy) ? ATH_RC_CW40_FLAG : 0) | 
		(WLAN_RC_PHY_SGI(pRateTable->info[rix].phy) ? ATH_RC_HT40_SGI_FLAG : 0);
  908549:	2aacf8        	addi	a10, a10, -8
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
	series->tries = tries;
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
		(WLAN_RC_PHY_DS(pRateTable->info[rix].phy) ? ATH_RC_DS_FLAG : 0) | 
		(WLAN_RC_PHY_40(pRateTable->info[rix].phy) ? ATH_RC_CW40_FLAG : 0) | 
  90854c:	0a0a47        	extui	a10, a10, 0, 8
		A_UINT8 tries, A_UINT8 rix,
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
	series->tries = tries;
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
		(WLAN_RC_PHY_DS(pRateTable->info[rix].phy) ? ATH_RC_DS_FLAG : 0) | 
  90854f:	068802        	or	a8, a8, a6
		(WLAN_RC_PHY_40(pRateTable->info[rix].phy) ? ATH_RC_CW40_FLAG : 0) | 
  908552:	c060      	movi.n	a6, 0
  908554:	6fa401        	bgeui	a10, 4, 908559 <rcRateSetseries$constprop$11+0x55>
  908557:	c064      	movi.n	a6, 4
  908559:	068802        	or	a8, a8, a6
                struct ath_rc_series *series,
		A_UINT8 tries, A_UINT8 rix,
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
	series->tries = tries;
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
  90855c:	283403        	s8i	a8, a3, 3
		{
			series->flags |= ATH_RC_TX_STBC_FLAG;
		}
	}
#endif
	series->rix = pRateTable->info[rix].baseIndex;
  90855f:	0e5811        	slli	a8, a5, 2
  908562:	a585      	add.n	a5, a8, a5
  908564:	0d5511        	slli	a5, a5, 3
  908567:	a522      	add.n	a2, a2, a5
  908569:	25201e        	l8ui	a5, a2, 30
  90856c:	253400        	s8i	a5, a3, 0
	series->max4msframelen = pRateTable->info[rix].max4msframelen;
  90856f:	8229      	l32i.n	a2, a2, 36
  908571:	9231      	s32i.n	a2, a3, 4
	series->txrateKbps = pRateTable->info[rix].rateKbps;
  908573:	8294      	l32i.n	a2, a9, 16
  908575:	9232      	s32i.n	a2, a3, 8
	else if(chainmask == 1) 
		series->tx_chainmask = 1;
	else 
		series->tx_chainmask = pRateTable->info[rix].txChainMask_2ch;  /*Chainmask is 3 or 5*/
#else
	series->tx_chainmask = 1;
  908577:	c021      	movi.n	a2, 1
  908579:	223402        	s8i	a2, a3, 2
  90857c:	d10f      	retw.n
	...

00908580 <rcSibUpdate_ht$isra$3$constprop$13>:
 *  (e.g. SME operation, wireless mode change)
 *
 *  It will determine which rates are valid for use.
 */
static void
rcSibUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an,
  908580:	6c105e        	entry	a1, 0x2f0
	TX_RATE_CTRL *pRc = (TX_RATE_CTRL *)(pSib);
	PHY_STATE_CTRL mPhyCtrlState;  

	A_UINT8 i, j, k, hi = 0, htHi = 0;

	pRateTable = (RATE_TABLE_11N*)asc->hwRateTable[sc->sc_curmode];
  908583:	262248        	l32i	a6, a2, 0x120
  908586:	2222c2        	l32i	a2, a2, 0x308

	/* Initial rate table size. Will change depending on the working rate set */
	pRc->rateTableSize = MAX_TX_RATE_TBL;
  908589:	d730      	mov.n	a7, a3
	TX_RATE_CTRL *pRc = (TX_RATE_CTRL *)(pSib);
	PHY_STATE_CTRL mPhyCtrlState;  

	A_UINT8 i, j, k, hi = 0, htHi = 0;

	pRateTable = (RATE_TABLE_11N*)asc->hwRateTable[sc->sc_curmode];
  90858b:	0e2211        	slli	a2, a2, 2
  90858e:	a262      	add.n	a2, a6, a2

	/* Initial rate table size. Will change depending on the working rate set */
	pRc->rateTableSize = MAX_TX_RATE_TBL;
  908590:	c366      	movi.n	a6, 54
	TX_RATE_CTRL *pRc = (TX_RATE_CTRL *)(pSib);
	PHY_STATE_CTRL mPhyCtrlState;  

	A_UINT8 i, j, k, hi = 0, htHi = 0;

	pRateTable = (RATE_TABLE_11N*)asc->hwRateTable[sc->sc_curmode];
  908592:	8221      	l32i.n	a2, a2, 4
	/* Initial rate table size. Will change depending on the working rate set */
	pRc->rateTableSize = MAX_TX_RATE_TBL;

	/* Initialize thresholds according to the global rate table */
	for (i = 0 ; (i < pRc->rateTableSize) && (!keepState); i++) {
		pRc->state[i].per       = 0;
  908594:	280a00        	movi	a8, 0
	A_UINT8 i, j, k, hi = 0, htHi = 0;

	pRateTable = (RATE_TABLE_11N*)asc->hwRateTable[sc->sc_curmode];

	/* Initial rate table size. Will change depending on the working rate set */
	pRc->rateTableSize = MAX_TX_RATE_TBL;
  908597:	263436        	s8i	a6, a3, 54

	/* Initialize thresholds according to the global rate table */
	for (i = 0 ; (i < pRc->rateTableSize) && (!keepState); i++) {
		pRc->state[i].per       = 0;
  90859a:	260a36        	movi	a6, 54
  90859d:	6d6804        	loop	a6, 9085a5 <rcSibUpdate_ht$isra$3$constprop$13+0x25>
  9085a0:	287400        	s8i	a8, a7, 0
  9085a3:	b177      	addi.n	a7, a7, 1
  9085a5:	273c42        	addi	a7, a3, 66
rcInitValidTxMask(TX_RATE_CTRL *pRc)
{
	A_UINT8 i;

	for (i = 0; i < pRc->rateTableSize; i++) {
		pRc->validRateIndex[i] = FALSE;
  9085a8:	c080      	movi.n	a8, 0
  9085aa:	260a36        	movi	a6, 54
  9085ad:	6d6804        	loop	a6, 9085b5 <rcSibUpdate_ht$isra$3$constprop$13+0x35>
  9085b0:	287400        	s8i	a8, a7, 0
  9085b3:	b177      	addi.n	a7, a7, 1
static void
rcInitValidTxMask(TX_RATE_CTRL *pRc)
{
	A_UINT8 i;

	for (i = 0; i < pRc->rateTableSize; i++) {
  9085b5:	c070      	movi.n	a7, 0
  9085b7:	d910      	mov.n	a9, a1
	/* Determine the valid rates */
	rcInitValidTxMask(pRc);

	for (i = 0; i < WLAN_RC_PHY_MAX; i++) {
		for (j = 0; j < MAX_TX_RATE_TBL; j++) {
			mPhyCtrlState.validPhyRateIndex[i][j] = 0;
  9085b9:	da70      	mov.n	a10, a7
	}

	/* Determine the valid rates */
	rcInitValidTxMask(pRc);

	for (i = 0; i < WLAN_RC_PHY_MAX; i++) {
  9085bb:	2b2a88        	movi	a11, 0x288
  9085be:	600014        	j	9085d6 <rcSibUpdate_ht$isra$3$constprop$13+0x56>
		for (j = 0; j < MAX_TX_RATE_TBL; j++) {
			mPhyCtrlState.validPhyRateIndex[i][j] = 0;
  9085c1:	2a6400        	s8i	a10, a6, 0
  9085c4:	b166      	addi.n	a6, a6, 1
  9085c6:	b088      	addi.n	a8, a8, -1
  9085c8:	658ff5        	bnez	a8, 9085c1 <rcSibUpdate_ht$isra$3$constprop$13+0x41>
		}   
		mPhyCtrlState.validPhyRateCount[i] = 0;
  9085cb:	2a9400        	s8i	a10, a9, 0
  9085ce:	277c36        	addi	a7, a7, 54
  9085d1:	b199      	addi.n	a9, a9, 1
	}

	/* Determine the valid rates */
	rcInitValidTxMask(pRc);

	for (i = 0; i < WLAN_RC_PHY_MAX; i++) {
  9085d3:	7b710b        	beq	a7, a11, 9085e2 <rcSibUpdate_ht$isra$3$constprop$13+0x62>
  9085d6:	bc76      	addi.n	a6, a7, 12
  9085d8:	a616      	add.n	a6, a1, a6
	A_UINT8 i, j, k, hi = 0, htHi = 0;

	pRateTable = (RATE_TABLE_11N*)asc->hwRateTable[sc->sc_curmode];

	/* Initial rate table size. Will change depending on the working rate set */
	pRc->rateTableSize = MAX_TX_RATE_TBL;
  9085da:	c386      	movi.n	a8, 54
  9085dc:	63ffe1        	j	9085c1 <rcSibUpdate_ht$isra$3$constprop$13+0x41>
  9085df:	000000        	ill
			mPhyCtrlState.validPhyRateIndex[i][j] = 0;
		}   
		mPhyCtrlState.validPhyRateCount[i] = 0;
	}

	pRc->rcPhyMode = (capflag & WLAN_RC_40_FLAG);
  9085e2:	c062      	movi.n	a6, 2
  9085e4:	064601        	and	a6, a4, a6
  9085e7:	040840        	extui	a8, a4, 0, 1
  9085ea:	26347c        	s8i	a6, a3, 124
  9085ed:	2816aa        	s32i	a8, a1, 0x2a8

	if (pRateSet == NULL || !pRateSet->rates.rs_nrates) {
  9085f0:	c854      	beqz.n	a5, 9085f8 <rcSibUpdate_ht$isra$3$constprop$13+0x78>
  9085f2:	275000        	l8ui	a7, a5, 0
  9085f5:	657084        	bnez	a7, 90867d <rcSibUpdate_ht$isra$3$constprop$13+0xfd>
  9085f8:	292000        	l8ui	a9, a2, 0
static A_UINT8 rcSibInitValidRates(const RATE_TABLE_11N *pRateTable,
				   TX_RATE_CTRL *pRc,
				   A_UINT32 capflag,
				   PHY_STATE_CTRL *pPhyStateCtrl)
{
	A_UINT8 i, hi = 0;
  9085fb:	c060      	movi.n	a6, 0
  9085fd:	b427      	addi.n	a7, a2, 4
  9085ff:	a939      	add.n	a9, a3, a9
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT8 valid;
    
	for (i = 0; i < pRateTable->rateCount; i++) {
  908601:	d530      	mov.n	a5, a3
		}
            
		if (valid == TRUE) {
			A_UINT32 phy = pRateTable->info[i].phy;

			if (!rcIsValidPhyRate(phy, capflag, FALSE)) 
  908603:	de60      	mov.n	a14, a6
  908605:	600068        	j	908671 <rcSibUpdate_ht$isra$3$constprop$13+0xf1>
	A_UINT8 i, hi = 0;
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT8 valid;
    
	for (i = 0; i < pRateTable->rateCount; i++) {
		if (singleStream) {
  908608:	2f12aa        	l32i	a15, a1, 0x2a8
  90860b:	ccf5      	bnez.n	a15, 908614 <rcSibUpdate_ht$isra$3$constprop$13+0x94>
			valid = pRateTable->info[i].validSingleStream;
  90860d:	2d7007        	l8ui	a13, a7, 7
  908610:	600003        	j	908617 <rcSibUpdate_ht$isra$3$constprop$13+0x97>
  908613:	002d70        	excw
		} else {
			valid = pRateTable->info[i].valid;
  908616:	0369d1        	excw
		}
            
		if (valid == TRUE) {
  908619:	512f70        	call0	9543dc <_etext+0x49389>
			A_UINT32 phy = pRateTable->info[i].phy;
  90861c:	08dce0        	excw

			if (!rcIsValidPhyRate(phy, capflag, FALSE)) 
  90861f:	daf0      	mov.n	a10, a15
  908621:	db40      	mov.n	a11, a4
  908623:	2816b0        	s32i	a8, a1, 0x2c0
  908626:	2916b1        	s32i	a9, a1, 0x2c4
  908629:	2d16b2        	s32i	a13, a1, 0x2c8
  90862c:	2e16b3        	s32i	a14, a1, 0x2cc
  90862f:	2f16af        	s32i	a15, a1, 0x2bc
  908632:	5bff1f        	call8	9082b0 <rcIsValidPhyRate>
  908635:	2812b0        	l32i	a8, a1, 0x2c0
  908638:	2912b1        	l32i	a9, a1, 0x2c4
  90863b:	2d12b2        	l32i	a13, a1, 0x2c8
  90863e:	2e12b3        	l32i	a14, a1, 0x2cc
  908641:	2f12af        	l32i	a15, a1, 0x2bc
  908644:	caa4      	beqz.n	a10, 90866c <rcSibUpdate_ht$isra$3$constprop$13+0xec>
				continue;

			pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = i;
  908646:	0ffa11        	slli	a10, a15, 1
  908649:	afaa      	add.n	a10, a10, a15
  90864b:	af1c      	add.n	a12, a1, a15
  90864d:	0daf11        	slli	a15, a10, 3
  908650:	afaa      	add.n	a10, a10, a15
  908652:	2bc000        	l8ui	a11, a12, 0
  908655:	0faa11        	slli	a10, a10, 1
  908658:	aa1a      	add.n	a10, a1, a10
  90865a:	0baa08        	add	a10, a10, a11
			pPhyStateCtrl->validPhyRateCount[phy] += 1;
  90865d:	2bbc01        	addi	a11, a11, 1
			A_UINT32 phy = pRateTable->info[i].phy;

			if (!rcIsValidPhyRate(phy, capflag, FALSE)) 
				continue;

			pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = i;
  908660:	28a40c        	s8i	a8, a10, 12
			pPhyStateCtrl->validPhyRateCount[phy] += 1;
  908663:	2bc400        	s8i	a11, a12, 0

static INLINE void
rcSetValidTxMask(TX_RATE_CTRL *pRc, A_UINT8 index, A_BOOL validTxRate)
{
	ASSERT(index < pRc->rateTableSize);
	pRc->validRateIndex[index] = validTxRate ? TRUE : FALSE;
  908666:	2d5442        	s8i	a13, a5, 66
			pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = i;
			pPhyStateCtrl->validPhyRateCount[phy] += 1;

			rcSetValidTxMask(pRc, i, TRUE);

			hi = A_MAX(hi, i);
  908669:	068637        	maxu	a6, a8, a6
  90866c:	277c28        	addi	a7, a7, 40
  90866f:	b155      	addi.n	a5, a5, 1
  908671:	03580c        	sub	a8, a5, a3
  908674:	080847        	extui	a8, a8, 0, 8
{
	A_UINT8 i, hi = 0;
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT8 valid;
    
	for (i = 0; i < pRateTable->rateCount; i++) {
  908677:	75998d        	bne	a9, a5, 908608 <rcSibUpdate_ht$isra$3$constprop$13+0x88>
  90867a:	6001d0        	j	90884e <rcSibUpdate_ht$isra$3$constprop$13+0x2ce>
  90867d:	a758      	add.n	a8, a5, a7
                   struct ieee80211_rateset *pRateSet,
		   A_UINT32 capflag,
		   struct ath_node_target *an,
		   PHY_STATE_CTRL *pPhyStateCtrl)
{
	A_UINT8 i, j, hi = 0;
  90867f:	c090      	movi.n	a9, 0
			 * the validity (TRUE/TRUE_20/TRUE_40) flags
			 */

			if (((pRateSet->rs_rates[i] & 0x7F) == 
			     (pRateTable->info[j].dot11Rate & 0x7F))
			    && ((valid & WLAN_RC_CAP_MODE(capflag)) == 
  908681:	c078      	movi.n	a7, 8
  908683:	074f01        	and	a15, a4, a7
                   struct ieee80211_rateset *pRateSet,
		   A_UINT32 capflag,
		   struct ath_node_target *an,
		   PHY_STATE_CTRL *pPhyStateCtrl)
{
	A_UINT8 i, j, hi = 0;
  908686:	2916a9        	s32i	a9, a1, 0x2a4
			 * the validity (TRUE/TRUE_20/TRUE_40) flags
			 */

			if (((pRateSet->rs_rates[i] & 0x7F) == 
			     (pRateTable->info[j].dot11Rate & 0x7F))
			    && ((valid & WLAN_RC_CAP_MODE(capflag)) == 
  908689:	c072      	movi.n	a7, 2
  90868b:	c094      	movi.n	a9, 4
  90868d:	067938        	moveqz	a9, a7, a6
  908690:	2816ac        	s32i	a8, a1, 0x2b0
  908693:	2516a8        	s32i	a5, a1, 0x2a0
		   A_UINT32 capflag,
		   struct ath_node_target *an,
		   PHY_STATE_CTRL *pPhyStateCtrl)
{
	A_UINT8 i, j, hi = 0;
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
  908696:	d850      	mov.n	a8, a5
			 * the validity (TRUE/TRUE_20/TRUE_40) flags
			 */

			if (((pRateSet->rs_rates[i] & 0x7F) == 
			     (pRateTable->info[j].dot11Rate & 0x7F))
			    && ((valid & WLAN_RC_CAP_MODE(capflag)) == 
  908698:	2f16ad        	s32i	a15, a1, 0x2b4
  90869b:	c0d1      	movi.n	a13, 1
  90869d:	2916ae        	s32i	a9, a1, 0x2b8
  9086a0:	6000a7        	j	90874b <rcSibUpdate_ht$isra$3$constprop$13+0x1cb>
  9086a3:	002f12        	srai	a15, a0, 2

			if (pSib->stbc) {
				valid = pRateTable->info[j].validSTBC;
			} else if (singleStream) {
#else
			if (singleStream) {
  9086a6:	aacc      	add.n	a12, a12, a10
  9086a8:	f3          	.byte 0xf3
#endif            
				valid = pRateTable->info[j].validSingleStream;
  9086a9:	8a61      	l32i.n	a10, a6, 4
  9086ab:	600001        	j	9086b0 <rcSibUpdate_ht$isra$3$constprop$13+0x130>
			} else {
				valid = pRateTable->info[j].valid;
  9086ae:	8a60      	l32i.n	a10, a6, 0
			/*
			 * We allow a rate only if its valid and the capflag matches one of
			 * the validity (TRUE/TRUE_20/TRUE_40) flags
			 */

			if (((pRateSet->rs_rates[i] & 0x7F) == 
  9086b0:	2b8001        	l8ui	a11, a8, 1
  9086b3:	2c6016        	l8ui	a12, a6, 22
  9086b6:	0cbb03        	xor	a11, a11, a12
  9086b9:	0b0b46        	extui	a11, a11, 0, 7
  9086bc:	65b075        	bnez	a11, 908735 <rcSibUpdate_ht$isra$3$constprop$13+0x1b5>
			     (pRateTable->info[j].dot11Rate & 0x7F))
			    && ((valid & WLAN_RC_CAP_MODE(capflag)) == 
  9086bf:	2f12ad        	l32i	a15, a1, 0x2b4
  9086c2:	2b12ae        	l32i	a11, a1, 0x2b8
  9086c5:	0fdb38        	moveqz	a11, a13, a15
  9086c8:	0baa01        	and	a10, a10, a11
  9086cb:	0baa0c        	sub	a10, a10, a11
  9086ce:	dbe0      	mov.n	a11, a14
  9086d0:	0adb38        	moveqz	a11, a13, a10
				WLAN_RC_CAP_MODE(capflag)) && !WLAN_RC_PHY_HT(phy)) {
  9086d3:	0b0a47        	extui	a10, a11, 0, 8
	A_UINT32 valid;
       
	/* Use intersection of working rates and valid rates */
	for (i = 0; i < pRateSet->rs_nrates; i++) {
		for (j = 0; j < pRateTable->rateCount; j++) {
			A_UINT32 phy = pRateTable->info[j].phy;
  9086d6:	2f6008        	l8ui	a15, a6, 8
			 */

			if (((pRateSet->rs_rates[i] & 0x7F) == 
			     (pRateTable->info[j].dot11Rate & 0x7F))
			    && ((valid & WLAN_RC_CAP_MODE(capflag)) == 
				WLAN_RC_CAP_MODE(capflag)) && !WLAN_RC_PHY_HT(phy)) {
  9086d9:	64a058        	beqz	a10, 908735 <rcSibUpdate_ht$isra$3$constprop$13+0x1b5>
  9086dc:	6ff455        	bgeui	a15, 4, 908735 <rcSibUpdate_ht$isra$3$constprop$13+0x1b5>
				if (!rcIsValidPhyRate(phy, capflag, FALSE)) 
  9086df:	dce0      	mov.n	a12, a14
  9086e1:	daf0      	mov.n	a10, a15
  9086e3:	044b02        	or	a11, a4, a4
  9086e6:	2816b0        	s32i	a8, a1, 0x2c0
  9086e9:	2916b1        	s32i	a9, a1, 0x2c4
  9086ec:	2d16b2        	s32i	a13, a1, 0x2c8
  9086ef:	2e16b3        	s32i	a14, a1, 0x2cc
  9086f2:	2f16af        	s32i	a15, a1, 0x2bc
  9086f5:	5bfeee        	call8	9082b0 <rcIsValidPhyRate>
  9086f8:	2812b0        	l32i	a8, a1, 0x2c0
  9086fb:	2912b1        	l32i	a9, a1, 0x2c4
  9086fe:	2d12b2        	l32i	a13, a1, 0x2c8
  908701:	2e12b3        	l32i	a14, a1, 0x2cc
  908704:	2f12af        	l32i	a15, a1, 0x2bc
  908707:	caaa      	beqz.n	a10, 908735 <rcSibUpdate_ht$isra$3$constprop$13+0x1b5>
					continue;

				pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = j;
  908709:	0ffa11        	slli	a10, a15, 1
  90870c:	afaa      	add.n	a10, a10, a15
  90870e:	af1c      	add.n	a12, a1, a15
  908710:	0daf11        	slli	a15, a10, 3
  908713:	afaa      	add.n	a10, a10, a15
  908715:	2bc000        	l8ui	a11, a12, 0
  908718:	0faa11        	slli	a10, a10, 1
				pPhyStateCtrl->validPhyRateCount[phy] += 1;

				rcSetValidTxMask(pRc, j, TRUE);
				hi = A_MAX(hi, j);
  90871b:	2f12a9        	l32i	a15, a1, 0x2a4
			    && ((valid & WLAN_RC_CAP_MODE(capflag)) == 
				WLAN_RC_CAP_MODE(capflag)) && !WLAN_RC_PHY_HT(phy)) {
				if (!rcIsValidPhyRate(phy, capflag, FALSE)) 
					continue;

				pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = j;
  90871e:	aa1a      	add.n	a10, a1, a10
  908720:	abaa      	add.n	a10, a10, a11
				pPhyStateCtrl->validPhyRateCount[phy] += 1;
  908722:	b1bb      	addi.n	a11, a11, 1
  908724:	2bc400        	s8i	a11, a12, 0

				rcSetValidTxMask(pRc, j, TRUE);
				hi = A_MAX(hi, j);
  908727:	09ff37        	maxu	a15, a15, a9

static INLINE void
rcSetValidTxMask(TX_RATE_CTRL *pRc, A_UINT8 index, A_BOOL validTxRate)
{
	ASSERT(index < pRc->rateTableSize);
	pRc->validRateIndex[index] = validTxRate ? TRUE : FALSE;
  90872a:	c0c1      	movi.n	a12, 1
			    && ((valid & WLAN_RC_CAP_MODE(capflag)) == 
				WLAN_RC_CAP_MODE(capflag)) && !WLAN_RC_PHY_HT(phy)) {
				if (!rcIsValidPhyRate(phy, capflag, FALSE)) 
					continue;

				pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = j;
  90872c:	29a40c        	s8i	a9, a10, 12

static INLINE void
rcSetValidTxMask(TX_RATE_CTRL *pRc, A_UINT8 index, A_BOOL validTxRate)
{
	ASSERT(index < pRc->rateTableSize);
	pRc->validRateIndex[index] = validTxRate ? TRUE : FALSE;
  90872f:	2c7442        	s8i	a12, a7, 66

				pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = j;
				pPhyStateCtrl->validPhyRateCount[phy] += 1;

				rcSetValidTxMask(pRc, j, TRUE);
				hi = A_MAX(hi, j);
  908732:	2f16a9        	s32i	a15, a1, 0x2a4
  908735:	266c28        	addi	a6, a6, 40
  908738:	b177      	addi.n	a7, a7, 1
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT32 valid;
       
	/* Use intersection of working rates and valid rates */
	for (i = 0; i < pRateSet->rs_nrates; i++) {
		for (j = 0; j < pRateTable->rateCount; j++) {
  90873a:	2f12ab        	l32i	a15, a1, 0x2ac
  90873d:	03790c        	sub	a9, a7, a3
  908740:	090947        	extui	a9, a9, 0, 8
  908743:	77f102        	beq	a15, a7, 908749 <rcSibUpdate_ht$isra$3$constprop$13+0x1c9>
  908746:	63ff5a        	j	9086a4 <rcSibUpdate_ht$isra$3$constprop$13+0x124>
  908749:	b188      	addi.n	a8, a8, 1
	A_UINT8 i, j, hi = 0;
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT32 valid;
       
	/* Use intersection of working rates and valid rates */
	for (i = 0; i < pRateSet->rs_nrates; i++) {
  90874b:	2612ac        	l32i	a6, a1, 0x2b0
  90874e:	768110        	beq	a8, a6, 908762 <rcSibUpdate_ht$isra$3$constprop$13+0x1e2>
  908751:	272000        	l8ui	a7, a2, 0
  908754:	b426      	addi.n	a6, a2, 4
  908756:	a739      	add.n	a9, a3, a7
  908758:	2916ab        	s32i	a9, a1, 0x2ac
		for (j = 0; j < pRateTable->rateCount; j++) {
  90875b:	d730      	mov.n	a7, a3
			 * the validity (TRUE/TRUE_20/TRUE_40) flags
			 */

			if (((pRateSet->rs_rates[i] & 0x7F) == 
			     (pRateTable->info[j].dot11Rate & 0x7F))
			    && ((valid & WLAN_RC_CAP_MODE(capflag)) == 
  90875d:	c0e0      	movi.n	a14, 0
  90875f:	63ffd7        	j	90873a <rcSibUpdate_ht$isra$3$constprop$13+0x1ba>
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	A_UINT8 *phtMcs = (A_UINT8*)&pRateSet->htrates;
	TX_RATE_CTRL *pRc = (TX_RATE_CTRL *)(pSib);
	PHY_STATE_CTRL mPhyCtrlState;  

	A_UINT8 i, j, k, hi = 0, htHi = 0;
  908762:	c060      	movi.n	a6, 0
	} else {
		/* Use intersection of working rates and valid rates */
		hi = rcSibSetValidRates(pRateTable, pRc, &(pRateSet->rates),
					capflag, an, &mPhyCtrlState);

		if (capflag & WLAN_RC_HT_FLAG) {
  908764:	7c4f02        	bbsi	a4, 28, 90876a <rcSibUpdate_ht$isra$3$constprop$13+0x1ea>
  908767:	6000dd        	j	908848 <rcSibUpdate_ht$isra$3$constprop$13+0x2c8>
  90876a:	27501f        	l8ui	a7, a5, 31
			}
                           
			if (((((struct ieee80211_rateset *)pMcsSet)->rs_rates[i] & 0x7F) 
			     != (pRateTable->info[j].dot11Rate & 0x7F)) 
			    || !WLAN_RC_PHY_HT(phy) 
			    || !WLAN_RC_PHY_HT_VALID(valid, capflag)
  90876d:	c082      	movi.n	a8, 2
  90876f:	a755      	add.n	a5, a5, a7
  908771:	2516ab        	s32i	a5, a1, 0x2ac
			    || ((pRateTable->info[j].dot11Rate == 15) && 
				(valid & TRUE_20) && 
				(capflag & WLAN_RC_WEP_TKIP_FLAG)) )
  908774:	251a00        	movi	a5, 0x100
  908777:	054501        	and	a5, a4, a5
  90877a:	2516ad        	s32i	a5, a1, 0x2b4
			}
                           
			if (((((struct ieee80211_rateset *)pMcsSet)->rs_rates[i] & 0x7F) 
			     != (pRateTable->info[j].dot11Rate & 0x7F)) 
			    || !WLAN_RC_PHY_HT(phy) 
			    || !WLAN_RC_PHY_HT_VALID(valid, capflag)
  90877d:	084801        	and	a8, a4, a8
  908780:	6000a9        	j	90882d <rcSibUpdate_ht$isra$3$constprop$13+0x2ad>
  908783:	002f12        	srai	a15, a0, 2

			if (pSib->stbc) {
				valid = pRateTable->info[j].validSTBC;
			} else if (singleStream) {
#else
			if (singleStream) {
  908786:	aa2d      	add.n	a13, a2, a10
	A_UINT8 valid;
    
	/* Use intersection of working rates and valid rates */
	for (i = 0; i <  ((struct ieee80211_rateset *)pMcsSet)->rs_nrates; i++) {
		for (j = 0; j < pRateTable->rateCount; j++) {
			A_UINT32 phy = pRateTable->info[j].phy;
  908788:	5008cc        	call0	90aabc <ath_tgt_tx_comp_aggr+0x110>

			if (pSib->stbc) {
				valid = pRateTable->info[j].validSTBC;
			} else if (singleStream) {
#else
			if (singleStream) {
  90878b:	f6          	.byte 0xf6
#endif
				valid = pRateTable->info[j].validSingleStream;
  90878c:	2c5007        	l8ui	a12, a5, 7
  90878f:	600004        	j	908797 <rcSibUpdate_ht$isra$3$constprop$13+0x217>
  908792:	00002c        	excw
			} else {
				valid = pRateTable->info[j].valid;
  908795:	50032f        	call0	909454 <ath_buf_set_rate+0x1bc>
			}
                           
			if (((((struct ieee80211_rateset *)pMcsSet)->rs_rates[i] & 0x7F) 
			     != (pRateTable->info[j].dot11Rate & 0x7F)) 
  908798:	12a82b        	l32r	a2, 8f2844 <memset+0xd6a8>
  90879b:	50162a        	call0	90e044 <_etext+0x2ff1>
  90879e:	f0          	.byte 0xf0
  90879f:	200aba        	movi	a0, 186
  9087a2:	030a0a        	addx4	a10, a0, a3
				valid = pRateTable->info[j].validSingleStream;
			} else {
				valid = pRateTable->info[j].valid;
			}
                           
			if (((((struct ieee80211_rateset *)pMcsSet)->rs_rates[i] & 0x7F) 
  9087a5:	4665a0        	excw
			     != (pRateTable->info[j].dot11Rate & 0x7F)) 
			    || !WLAN_RC_PHY_HT(phy) 
  9087a8:	676ed4        	bgez	a6, 908680 <rcSibUpdate_ht$isra$3$constprop$13+0x100>
  9087ab:	64c0f2        	beqz	a12, 9088a1 <rcSibUpdate_ht$isra$3$constprop$13+0x321>
  9087ae:	0fca01        	and	a10, a12, a15
			    || !WLAN_RC_PHY_HT_VALID(valid, capflag)
  9087b1:	c8a0      	beqz.n	a10, 9087b5 <rcSibUpdate_ht$isra$3$constprop$13+0x235>
  9087b3:	c884      	beqz.n	a8, 9087bb <rcSibUpdate_ht$isra$3$constprop$13+0x23b>
  9087b5:	7ec058        	bnone	a12, a14, 908811 <rcSibUpdate_ht$isra$3$constprop$13+0x291>
  9087b8:	648055        	beqz	a8, 908811 <rcSibUpdate_ht$isra$3$constprop$13+0x291>
			    || ((pRateTable->info[j].dot11Rate == 15) && 
  9087bb:	2bbcf1        	addi	a11, a11, -15
  9087be:	ccb6      	bnez.n	a11, 9087c8 <rcSibUpdate_ht$isra$3$constprop$13+0x248>
  9087c0:	c8a4      	beqz.n	a10, 9087c8 <rcSibUpdate_ht$isra$3$constprop$13+0x248>
				(valid & TRUE_20) && 
  9087c2:	2f12ad        	l32i	a15, a1, 0x2b4
  9087c5:	65f048        	bnez	a15, 908811 <rcSibUpdate_ht$isra$3$constprop$13+0x291>
				(capflag & WLAN_RC_WEP_TKIP_FLAG)) )
			{
				continue;
			}
    
			if (!rcIsValidPhyRate(phy, capflag, FALSE)) 
  9087c8:	dad0      	mov.n	a10, a13
  9087ca:	c0c0      	movi.n	a12, 0
  9087cc:	db40      	mov.n	a11, a4
  9087ce:	2816b0        	s32i	a8, a1, 0x2c0
  9087d1:	2916b1        	s32i	a9, a1, 0x2c4
  9087d4:	2d16b2        	s32i	a13, a1, 0x2c8
  9087d7:	2e16b3        	s32i	a14, a1, 0x2cc
  9087da:	5bfeb5        	call8	9082b0 <rcIsValidPhyRate>
  9087dd:	2812b0        	l32i	a8, a1, 0x2c0
  9087e0:	2912b1        	l32i	a9, a1, 0x2c4
  9087e3:	2d12b2        	l32i	a13, a1, 0x2c8
  9087e6:	2e12b3        	l32i	a14, a1, 0x2cc
  9087e9:	caa4      	beqz.n	a10, 908811 <rcSibUpdate_ht$isra$3$constprop$13+0x291>
				continue;
    
			pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = j;
  9087eb:	0fda11        	slli	a10, a13, 1
  9087ee:	adaa      	add.n	a10, a10, a13
  9087f0:	ad1c      	add.n	a12, a1, a13
  9087f2:	0dad11        	slli	a13, a10, 3
  9087f5:	adaa      	add.n	a10, a10, a13
  9087f7:	2bc000        	l8ui	a11, a12, 0
  9087fa:	0faa11        	slli	a10, a10, 1
  9087fd:	aa1a      	add.n	a10, a1, a10
  9087ff:	abaa      	add.n	a10, a10, a11
  908801:	29a40c        	s8i	a9, a10, 12
			pPhyStateCtrl->validPhyRateCount[phy] += 1;
  908804:	b1bb      	addi.n	a11, a11, 1

static INLINE void
rcSetValidTxMask(TX_RATE_CTRL *pRc, A_UINT8 index, A_BOOL validTxRate)
{
	ASSERT(index < pRc->rateTableSize);
	pRc->validRateIndex[index] = validTxRate ? TRUE : FALSE;
  908806:	c0a1      	movi.n	a10, 1
    
			if (!rcIsValidPhyRate(phy, capflag, FALSE)) 
				continue;
    
			pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = j;
			pPhyStateCtrl->validPhyRateCount[phy] += 1;
  908808:	2bc400        	s8i	a11, a12, 0

static INLINE void
rcSetValidTxMask(TX_RATE_CTRL *pRc, A_UINT8 index, A_BOOL validTxRate)
{
	ASSERT(index < pRc->rateTableSize);
	pRc->validRateIndex[index] = validTxRate ? TRUE : FALSE;
  90880b:	2a7442        	s8i	a10, a7, 66
    
			pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = j;
			pPhyStateCtrl->validPhyRateCount[phy] += 1;

			rcSetValidTxMask(pRc, j, TRUE);
			hi = A_MAX(hi, j);
  90880e:	096637        	maxu	a6, a6, a9
  908811:	255c28        	addi	a5, a5, 40
  908814:	b177      	addi.n	a7, a7, 1
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT8 valid;
    
	/* Use intersection of working rates and valid rates */
	for (i = 0; i <  ((struct ieee80211_rateset *)pMcsSet)->rs_nrates; i++) {
		for (j = 0; j < pRateTable->rateCount; j++) {
  908816:	2f12ac        	l32i	a15, a1, 0x2b0
  908819:	03790c        	sub	a9, a7, a3
  90881c:	090947        	extui	a9, a9, 0, 8
  90881f:	7f7102        	beq	a7, a15, 908825 <rcSibUpdate_ht$isra$3$constprop$13+0x2a5>
  908822:	63ff5e        	j	908784 <rcSibUpdate_ht$isra$3$constprop$13+0x204>
  908825:	2512a8        	l32i	a5, a1, 0x2a0
  908828:	b155      	addi.n	a5, a5, 1
  90882a:	2516a8        	s32i	a5, a1, 0x2a0
	A_UINT8 i, j, hi = 0;
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT8 valid;
    
	/* Use intersection of working rates and valid rates */
	for (i = 0; i <  ((struct ieee80211_rateset *)pMcsSet)->rs_nrates; i++) {
  90882d:	2912a8        	l32i	a9, a1, 0x2a0
  908830:	2f12ab        	l32i	a15, a1, 0x2ac
  908833:	7f9111        	beq	a9, a15, 908848 <rcSibUpdate_ht$isra$3$constprop$13+0x2c8>
  908836:	272000        	l8ui	a7, a2, 0
  908839:	b425      	addi.n	a5, a2, 4
  90883b:	a739      	add.n	a9, a3, a7
  90883d:	2916ac        	s32i	a9, a1, 0x2b0
		for (j = 0; j < pRateTable->rateCount; j++) {
  908840:	d730      	mov.n	a7, a3
			}
                           
			if (((((struct ieee80211_rateset *)pMcsSet)->rs_rates[i] & 0x7F) 
			     != (pRateTable->info[j].dot11Rate & 0x7F)) 
			    || !WLAN_RC_PHY_HT(phy) 
			    || !WLAN_RC_PHY_HT_VALID(valid, capflag)
  908842:	c0e4      	movi.n	a14, 4
  908844:	63ffce        	j	908816 <rcSibUpdate_ht$isra$3$constprop$13+0x296>
  908847:	002f12        	srai	a15, a0, 2
		if (capflag & WLAN_RC_HT_FLAG) {
			htHi = rcSibSetValidHtRates(pRateTable, pRc, phtMcs,
						    capflag, an, &mPhyCtrlState);
		}

		hi = A_MAX(hi, htHi);
  90884a:	a90f      	add.n	a15, a0, a9
  90884c:	6637b1        	bltz	a3, 909001 <ath_tx_update_baw+0x5>
	}

	pRc->rateTableSize = hi + 1;
  90884f:	66c040        	bltz	a12, 908893 <rcSibUpdate_ht$isra$3$constprop$13+0x313>
  908852:	263436        	s8i	a6, a3, 54
	pRc->rateMaxPhy    = 0;
  908855:	24347d        	s8i	a4, a3, 125
	for (i = 0, k = 0; i < WLAN_RC_PHY_MAX; i++) {
		for (j = 0; j < mPhyCtrlState.validPhyRateCount[i]; j++) {
			pRc->validRateIndex[k++] = mPhyCtrlState.validPhyRateIndex[i][j];
		}   

		if (!rcIsValidPhyRate(i, pRateTable->initialRateMax, TRUE) ||
  908858:	c060      	movi.n	a6, 0
  90885a:	2d2003        	l8ui	a13, a2, 3
  90885d:	bc18      	addi.n	a8, a1, 12
	pRc->rateTableSize = hi + 1;
	pRc->rateMaxPhy    = 0;
    
	ASSERT(pRc->rateTableSize <= MAX_TX_RATE_TBL);

	for (i = 0, k = 0; i < WLAN_RC_PHY_MAX; i++) {
  90885f:	d560      	mov.n	a5, a6
		for (j = 0; j < mPhyCtrlState.validPhyRateCount[i]; j++) {
			pRc->validRateIndex[k++] = mPhyCtrlState.validPhyRateIndex[i][j];
		}   

		if (!rcIsValidPhyRate(i, pRateTable->initialRateMax, TRUE) ||
  908861:	c091      	movi.n	a9, 1
  908863:	de60      	mov.n	a14, a6
  908865:	60006a        	j	9088d3 <rcSibUpdate_ht$isra$3$constprop$13+0x353>
    
	ASSERT(pRc->rateTableSize <= MAX_TX_RATE_TBL);

	for (i = 0, k = 0; i < WLAN_RC_PHY_MAX; i++) {
		for (j = 0; j < mPhyCtrlState.validPhyRateCount[i]; j++) {
			pRc->validRateIndex[k++] = mPhyCtrlState.validPhyRateIndex[i][j];
  908868:	2ba000        	l8ui	a11, a10, 0
  90886b:	b145      	addi.n	a5, a4, 1
  90886d:	a434      	add.n	a4, a3, a4
  90886f:	2b4442        	s8i	a11, a4, 66
  908872:	b1aa      	addi.n	a10, a10, 1
  908874:	050447        	extui	a4, a5, 0, 8
	pRc->rateMaxPhy    = 0;
    
	ASSERT(pRc->rateTableSize <= MAX_TX_RATE_TBL);

	for (i = 0, k = 0; i < WLAN_RC_PHY_MAX; i++) {
		for (j = 0; j < mPhyCtrlState.validPhyRateCount[i]; j++) {
  908877:	7749ed        	bne	a4, a7, 908868 <rcSibUpdate_ht$isra$3$constprop$13+0x2e8>
			pRc->validRateIndex[k++] = mPhyCtrlState.validPhyRateIndex[i][j];
		}   

		if (!rcIsValidPhyRate(i, pRateTable->initialRateMax, TRUE) ||
  90887a:	099c02        	or	a12, a9, a9
  90887d:	dbd0      	mov.n	a11, a13
  90887f:	066a02        	or	a10, a6, a6
  908882:	2816b0        	s32i	a8, a1, 0x2c0
  908885:	2916b1        	s32i	a9, a1, 0x2c4
  908888:	2d16b2        	s32i	a13, a1, 0x2c8
  90888b:	2e16b3        	s32i	a14, a1, 0x2cc
  90888e:	2f16af        	s32i	a15, a1, 0x2bc
  908891:	5bfe87        	call8	9082b0 <rcIsValidPhyRate>
  908894:	2e12b3        	l32i	a14, a1, 0x2cc
  908897:	2912b1        	l32i	a9, a1, 0x2c4
  90889a:	2f12af        	l32i	a15, a1, 0x2bc
  90889d:	d5e0      	mov.n	a5, a14
  90889f:	0f9538        	moveqz	a5, a9, a15
  9088a2:	050547        	extui	a5, a5, 0, 8
  9088a5:	2812b0        	l32i	a8, a1, 0x2c0
  9088a8:	2d12b2        	l32i	a13, a1, 0x2c8
  9088ab:	cd5a      	bnez.n	a5, 9088c9 <rcSibUpdate_ht$isra$3$constprop$13+0x349>
  9088ad:	0a9538        	moveqz	a5, a9, a10
  9088b0:	cd55      	bnez.n	a5, 9088c9 <rcSibUpdate_ht$isra$3$constprop$13+0x349>
		    !mPhyCtrlState.validPhyRateCount[i]) 
			continue;

		pRc->rateMaxPhy = mPhyCtrlState.validPhyRateIndex[i][j-1];	
  9088b2:	0f6511        	slli	a5, a6, 1
  9088b5:	a655      	add.n	a5, a5, a6
  9088b7:	0d5a11        	slli	a10, a5, 3
  9088ba:	aa55      	add.n	a5, a5, a10
  9088bc:	0f5511        	slli	a5, a5, 1
  9088bf:	a515      	add.n	a5, a1, a5
  9088c1:	af55      	add.n	a5, a5, a15
  9088c3:	25500b        	l8ui	a5, a5, 11
  9088c6:	25347d        	s8i	a5, a3, 125
  9088c9:	b166      	addi.n	a6, a6, 1
  9088cb:	288c36        	addi	a8, a8, 54
  9088ce:	d570      	mov.n	a5, a7
	pRc->rateTableSize = hi + 1;
	pRc->rateMaxPhy    = 0;
    
	ASSERT(pRc->rateTableSize <= MAX_TX_RATE_TBL);

	for (i = 0, k = 0; i < WLAN_RC_PHY_MAX; i++) {
  9088d0:	686a10        	beqi	a6, 12, 9088e4 <rcSibUpdate_ht$isra$3$constprop$13+0x364>
		for (j = 0; j < mPhyCtrlState.validPhyRateCount[i]; j++) {
  9088d3:	a614      	add.n	a4, a1, a6
  9088d5:	2f4000        	l8ui	a15, a4, 0
  9088d8:	da80      	mov.n	a10, a8
  9088da:	a5f7      	add.n	a7, a15, a5
  9088dc:	070747        	extui	a7, a7, 0, 8
  9088df:	d450      	mov.n	a4, a5
  9088e1:	63ff92        	j	908877 <rcSibUpdate_ht$isra$3$constprop$13+0x2f7>
	}
    
	ASSERT(pRc->rateTableSize <= MAX_TX_RATE_TBL);
	ASSERT(k <= MAX_TX_RATE_TBL);

	pRc->rateMaxPhy = pRc->validRateIndex[k-4];
  9088e4:	a435      	add.n	a5, a3, a4
  9088e6:	25503e        	l8ui	a5, a5, 62
	pRc->maxValidRate = k;
  9088e9:	243441        	s8i	a4, a3, 65
static void
rcSortValidRates(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc)
{
	A_UINT8 i,j;

	for (i=pRc->maxValidRate-1; i > 0; i--) {
  9088ec:	b044      	addi.n	a4, a4, -1
	}
    
	ASSERT(pRc->rateTableSize <= MAX_TX_RATE_TBL);
	ASSERT(k <= MAX_TX_RATE_TBL);

	pRc->rateMaxPhy = pRc->validRateIndex[k-4];
  9088ee:	25347d        	s8i	a5, a3, 125
static void
rcSortValidRates(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc)
{
	A_UINT8 i,j;

	for (i=pRc->maxValidRate-1; i > 0; i--) {
  9088f1:	040447        	extui	a4, a4, 0, 8
  9088f4:	c0b0      	movi.n	a11, 0
  9088f6:	600039        	j	908933 <rcSibUpdate_ht$isra$3$constprop$13+0x3b3>
#ifdef MAGPIE_MERLIN      
			if (pRateTable->info[pRc->validRateIndex[j]].rateKbps >
			    pRateTable->info[pRc->validRateIndex[j+1]].rateKbps)
#else
				// K2
				if (pRateTable->info[pRc->validRateIndex[j]].userRateKbps >
  9088f9:	a53a      	add.n	a10, a3, a5
				    pRateTable->info[pRc->validRateIndex[j+1]].userRateKbps)
  9088fb:	b155      	addi.n	a5, a5, 1
  9088fd:	a53c      	add.n	a12, a3, a5
#ifdef MAGPIE_MERLIN      
			if (pRateTable->info[pRc->validRateIndex[j]].rateKbps >
			    pRateTable->info[pRc->validRateIndex[j+1]].rateKbps)
#else
				// K2
				if (pRateTable->info[pRc->validRateIndex[j]].userRateKbps >
  9088ff:	28a042        	l8ui	a8, a10, 66
				    pRateTable->info[pRc->validRateIndex[j+1]].userRateKbps)
  908902:	29c042        	l8ui	a9, a12, 66
#ifdef MAGPIE_MERLIN      
			if (pRateTable->info[pRc->validRateIndex[j]].rateKbps >
			    pRateTable->info[pRc->validRateIndex[j+1]].rateKbps)
#else
				// K2
				if (pRateTable->info[pRc->validRateIndex[j]].userRateKbps >
  908905:	0e8711        	slli	a7, a8, 2
				    pRateTable->info[pRc->validRateIndex[j+1]].userRateKbps)
  908908:	0e9611        	slli	a6, a9, 2
#ifdef MAGPIE_MERLIN      
			if (pRateTable->info[pRc->validRateIndex[j]].rateKbps >
			    pRateTable->info[pRc->validRateIndex[j+1]].rateKbps)
#else
				// K2
				if (pRateTable->info[pRc->validRateIndex[j]].userRateKbps >
  90890b:	a877      	add.n	a7, a7, a8
				    pRateTable->info[pRc->validRateIndex[j+1]].userRateKbps)
  90890d:	a966      	add.n	a6, a6, a9
#ifdef MAGPIE_MERLIN      
			if (pRateTable->info[pRc->validRateIndex[j]].rateKbps >
			    pRateTable->info[pRc->validRateIndex[j+1]].rateKbps)
#else
				// K2
				if (pRateTable->info[pRc->validRateIndex[j]].userRateKbps >
  90890f:	0d7711        	slli	a7, a7, 3
				    pRateTable->info[pRc->validRateIndex[j+1]].userRateKbps)
  908912:	0d6611        	slli	a6, a6, 3
#ifdef MAGPIE_MERLIN      
			if (pRateTable->info[pRc->validRateIndex[j]].rateKbps >
			    pRateTable->info[pRc->validRateIndex[j+1]].rateKbps)
#else
				// K2
				if (pRateTable->info[pRc->validRateIndex[j]].userRateKbps >
  908915:	a727      	add.n	a7, a2, a7
				    pRateTable->info[pRc->validRateIndex[j+1]].userRateKbps)
  908917:	a626      	add.n	a6, a2, a6
#ifdef MAGPIE_MERLIN      
			if (pRateTable->info[pRc->validRateIndex[j]].rateKbps >
			    pRateTable->info[pRc->validRateIndex[j+1]].rateKbps)
#else
				// K2
				if (pRateTable->info[pRc->validRateIndex[j]].userRateKbps >
  908919:	277205        	l32i	a7, a7, 20
  90891c:	266205        	l32i	a6, a6, 20
  90891f:	776b05        	bgeu	a6, a7, 908928 <rcSibUpdate_ht$isra$3$constprop$13+0x3a8>
				    pRateTable->info[pRc->validRateIndex[j+1]].userRateKbps)
#endif
				{
					A_UINT8 tmp=0;
					tmp = pRc->validRateIndex[j];
					pRc->validRateIndex[j] = pRc->validRateIndex[j+1];
  908922:	29a442        	s8i	a9, a10, 66
					pRc->validRateIndex[j+1] = tmp;
  908925:	28c442        	s8i	a8, a12, 66
rcSortValidRates(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc)
{
	A_UINT8 i,j;

	for (i=pRc->maxValidRate-1; i > 0; i--) {
		for (j=0; j <= i-1; j++) {
  908928:	050547        	extui	a5, a5, 0, 8
  90892b:	7452ca        	blt	a5, a4, 9088f9 <rcSibUpdate_ht$isra$3$constprop$13+0x379>
static void
rcSortValidRates(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc)
{
	A_UINT8 i,j;

	for (i=pRc->maxValidRate-1; i > 0; i--) {
  90892e:	b044      	addi.n	a4, a4, -1
  908930:	040447        	extui	a4, a4, 0, 8
  908933:	c843      	beqz.n	a4, 90893a <rcSibUpdate_ht$isra$3$constprop$13+0x3ba>
  908935:	d5b0      	mov.n	a5, a11
  908937:	63fff0        	j	90892b <rcSibUpdate_ht$isra$3$constprop$13+0x3ab>
  90893a:	d10f      	retw.n

0090893c <rcRateGetIndex$constprop$9>:
	series->tx_chainmask = 1;
#endif
}

static A_UINT8 
rcRateGetIndex(struct ath_softc_tgt *sc, struct ath_node_target *an,        
  90893c:	6c1004        	entry	a1, 32
               const RATE_TABLE_11N *pRateTable , 
               A_UINT8 rix, A_UINT16 stepDown, A_UINT16 minRate)
{
	A_UINT32                j;
	A_UINT8                 nextIndex;
	struct atheros_node     *pSib = ATH_NODE_ATHEROS(an);
  90893f:	2a2282        	l32i	a10, a2, 0x208
	TX_RATE_CTRL            *pRc = (TX_RATE_CTRL *)(pSib);
    
	if (minRate) {
  908942:	64604a        	beqz	a6, 908990 <rcRateGetIndex$constprop$9+0x54>
rcGetNextLowerValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc,  
                          A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_INT8 i;

	for (i = 1; i < pRc->maxValidRate ; i++) {
  908945:	2ba041        	l8ui	a11, a10, 65
  908948:	c396      	movi.n	a9, 54
  90894a:	c081      	movi.n	a8, 1
  90894c:	600019        	j	908969 <rcRateGetIndex$constprop$9+0x2d>
  90894f:	00a5a5        	excw
		if (pRc->validRateIndex[i] == curValidTxRate) {
  908952:	2c5042        	l8ui	a12, a5, 66
  908955:	74c90b        	bne	a12, a4, 908964 <rcRateGetIndex$constprop$9+0x28>
  908958:	b099      	addi.n	a9, a9, -1
			*pNextIndex = pRc->validRateIndex[i-1];
  90895a:	245041        	l8ui	a4, a5, 65
	A_UINT8                 nextIndex;
	struct atheros_node     *pSib = ATH_NODE_ATHEROS(an);
	TX_RATE_CTRL            *pRc = (TX_RATE_CTRL *)(pSib);
    
	if (minRate) {
		for (j = RATE_TABLE_11N_SIZE; j > 0; j-- ) {
  90895d:	659fe9        	bnez	a9, 90894a <rcRateGetIndex$constprop$9+0xe>
  908960:	600036        	j	90899a <rcRateGetIndex$constprop$9+0x5e>
  908963:	00b188        	excw
rcGetNextLowerValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc,  
                          A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_INT8 i;

	for (i = 1; i < pRc->maxValidRate ; i++) {
  908966:	080847        	extui	a8, a8, 0, 8
  908969:	008532        	sext	a5, a8, 7
  90896c:	7b52e0        	blt	a5, a11, 908950 <rcRateGetIndex$constprop$9+0x14>
  90896f:	600027        	j	90899a <rcRateGetIndex$constprop$9+0x5e>
		if (pRc->validRateIndex[i] == curValidTxRate) {
  908972:	a9a9      	add.n	a9, a10, a9
  908974:	2c9042        	l8ui	a12, a9, 66
  908977:	74c907        	bne	a12, a4, 908982 <rcRateGetIndex$constprop$9+0x46>
			} else {
				break;
			}
		}
	} else {
		for (j = stepDown; j > 0; j-- ) {
  90897a:	b055      	addi.n	a5, a5, -1
{
	A_INT8 i;

	for (i = 1; i < pRc->maxValidRate ; i++) {
		if (pRc->validRateIndex[i] == curValidTxRate) {
			*pNextIndex = pRc->validRateIndex[i-1];
  90897c:	249041        	l8ui	a4, a9, 65
  90897f:	60000d        	j	908990 <rcRateGetIndex$constprop$9+0x54>
  908982:	b188      	addi.n	a8, a8, 1
rcGetNextLowerValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc,  
                          A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_INT8 i;

	for (i = 1; i < pRc->maxValidRate ; i++) {
  908984:	080847        	extui	a8, a8, 0, 8
  908987:	008932        	sext	a9, a8, 7
  90898a:	7b92e4        	blt	a9, a11, 908972 <rcRateGetIndex$constprop$9+0x36>
  90898d:	600009        	j	90899a <rcRateGetIndex$constprop$9+0x5e>
			} else {
				break;
			}
		}
	} else {
		for (j = stepDown; j > 0; j-- ) {
  908990:	c856      	beqz.n	a5, 90899a <rcRateGetIndex$constprop$9+0x5e>
rcGetNextLowerValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc,  
                          A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_INT8 i;

	for (i = 1; i < pRc->maxValidRate ; i++) {
  908992:	2ba041        	l8ui	a11, a10, 65
  908995:	c081      	movi.n	a8, 1
  908997:	63ffec        	j	908987 <rcRateGetIndex$constprop$9+0x4b>
			}
		}
	}

	return rix;
}
  90899a:	d240      	mov.n	a2, a4
  90899c:	d10f      	retw.n
	...

009089a0 <rcRateFind_11n>:

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
		    int numTries, int numRates, int stepDnInc,
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
  9089a0:	6c1008        	entry	a1, 64
  9089a3:	9414      	s32i.n	a4, a1, 16
	A_UINT8 i = 0; 
	A_UINT8 tryPerRate  = 0;
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  9089a5:	2422c2        	l32i	a4, a2, 0x308
}

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
		    int numTries, int numRates, int stepDnInc,
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
  9089a8:	9313      	s32i.n	a3, a1, 12
	A_UINT8 i = 0; 
	A_UINT8 tryPerRate  = 0;
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  9089aa:	232248        	l32i	a3, a2, 0x120
  9089ad:	0e4411        	slli	a4, a4, 2
}

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
		    int numTries, int numRates, int stepDnInc,
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
  9089b0:	9711      	s32i.n	a7, a1, 4
	A_UINT8 i = 0; 
	A_UINT8 tryPerRate  = 0;
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  9089b2:	a433      	add.n	a3, a3, a4
	struct atheros_node *asn = ATH_NODE_ATHEROS(an);
	A_UINT8 rix, nrix;
	A_UINT8 dot11Rate;
	WLAN_PHY phy;

	rix = rcRateFind_ht(sc, asn, pRateTable, (rcflag & ATH_RC_PROBE_ALLOWED) ? 1 : 0, 
  9089b4:	8811      	l32i.n	a8, a1, 4
	A_INT8               index;
	TX_RATE_CTRL         *pRc = NULL;

	pRc = (TX_RATE_CTRL *)(pSib ? (pSib) : NULL);

	*isProbing = FALSE;
  9089b6:	2c1211        	l32i	a12, a1, 68
}

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
		    int numTries, int numRates, int stepDnInc,
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
  9089b9:	9615      	s32i.n	a6, a1, 20
	A_UINT8 i = 0; 
	A_UINT8 tryPerRate  = 0;
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  9089bb:	8631      	l32i.n	a6, a3, 4
	struct atheros_node *asn = ATH_NODE_ATHEROS(an);
  9089bd:	8313      	l32i.n	a3, a1, 12
	A_INT8               index;
	TX_RATE_CTRL         *pRc = NULL;

	pRc = (TX_RATE_CTRL *)(pSib ? (pSib) : NULL);

	*isProbing = FALSE;
  9089bf:	c070      	movi.n	a7, 0
{
	A_UINT8 i = 0; 
	A_UINT8 tryPerRate  = 0;
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
	struct atheros_node *asn = ATH_NODE_ATHEROS(an);
  9089c1:	243282        	l32i	a4, a3, 0x208
	A_UINT8 rix, nrix;
	A_UINT8 dot11Rate;
	WLAN_PHY phy;

	rix = rcRateFind_ht(sc, asn, pRateTable, (rcflag & ATH_RC_PROBE_ALLOWED) ? 1 : 0, 
  9089c4:	080b40        	extui	a11, a8, 0, 1
	A_INT8               index;
	TX_RATE_CTRL         *pRc = NULL;

	pRc = (TX_RATE_CTRL *)(pSib ? (pSib) : NULL);

	*isProbing = FALSE;
  9089c7:	97c0      	s32i.n	a7, a12, 0
	 *   0msec   <= dt <= 25msec:   don't derate
	 *   25msec  <= dt <= 185msec:  derate linearly from 0 to 10dB
	 *   185msec <= dt:             derate by 10dB
	 */

	nowMsec = A_MS_TICKGET();
  9089c9:	da70      	mov.n	a10, a7
}

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
		    int numTries, int numRates, int stepDnInc,
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
  9089cb:	9512      	s32i.n	a5, a1, 8
	 *   0msec   <= dt <= 25msec:   don't derate
	 *   25msec  <= dt <= 185msec:  derate linearly from 0 to 10dB
	 *   185msec <= dt:             derate by 10dB
	 */

	nowMsec = A_MS_TICKGET();
  9089cd:	9b16      	s32i.n	a11, a1, 24
}

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
		    int numTries, int numRates, int stepDnInc,
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
  9089cf:	251210        	l32i	a5, a1, 64
	 *   0msec   <= dt <= 25msec:   don't derate
	 *   25msec  <= dt <= 185msec:  derate linearly from 0 to 10dB
	 *   185msec <= dt:             derate by 10dB
	 */

	nowMsec = A_MS_TICKGET();
  9089d2:	5bec67        	call8	903b70 <ath_hal_getuptime>
	 * Now look up the rate in the rssi table and return it.
	 * If no rates match then we return 0 (lowest rate)
	 */

	bestThruput = 0;
	maxIndex = pRc->maxValidRate-1;
  9089d5:	2c4041        	l8ui	a12, a4, 65
  9089d8:	b0c8      	addi.n	a8, a12, -1
    
	/*
	 * Try the higher rate first. It will reduce memory moving time
	 * if we have very good channel characteristics.
	 */
	for (index = maxIndex; index >= minIndex ; index--) {
  9089da:	080847        	extui	a8, a8, 0, 8
	/*
	 * Now look up the rate in the rssi table and return it.
	 * If no rates match then we return 0 (lowest rate)
	 */

	bestThruput = 0;
  9089dd:	dd70      	mov.n	a13, a7
  9089df:	8b16      	l32i.n	a11, a1, 24
  9089e1:	60004a        	j	908a2f <rcRateFind_11n+0x8f>
	 * if we have very good channel characteristics.
	 */
	for (index = maxIndex; index >= minIndex ; index--) {
		A_UINT8 perThres;
    
		rate = pRc->validRateIndex[index];
  9089e4:	a343      	add.n	a3, a4, a3
  9089e6:	293042        	l8ui	a9, a3, 66
		if (rate > pRc->rateMaxPhy) {
  9089e9:	23407d        	l8ui	a3, a4, 125
  9089ec:	79333a        	bltu	a3, a9, 908a2a <rcRateFind_11n+0x8a>
		}

		/* if the best throughput is already larger than the userRateKbps..
		 * then we could skip of rest of calculation.. 
		 */
		if( bestThruput >= pRateTable->info[rate].userRateKbps)
  9089ef:	0e9311        	slli	a3, a9, 2
  9089f2:	a933      	add.n	a3, a3, a9
  9089f4:	0d3311        	slli	a3, a3, 3
  9089f7:	a363      	add.n	a3, a6, a3
  9089f9:	8e35      	l32i.n	a14, a3, 20
  9089fb:	7ed311        	bltu	a13, a14, 908a10 <rcRateFind_11n+0x70>
	/*
	 * Must check the actual rate (rateKbps) to account for non-monoticity of
	 * 11g's rate table
	 */

	if (rate >= pRc->rateMaxPhy && probeAllowed) {
  9089fe:	23407d        	l8ui	a3, a4, 125
  908a01:	737371        	bltu	a7, a3, 908a76 <rcRateFind_11n+0xd6>
  908a04:	8f11      	l32i.n	a15, a1, 4
  908a06:	7ff76c        	bbci	a15, 31, 908a76 <rcRateFind_11n+0xd6>
  908a09:	c070      	movi.n	a7, 0
rcGetNextValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc, 
                     A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_UINT8 i;

	for (i = 0; i < pRc->maxValidRate-1; i++) {
  908a0b:	b0cc      	addi.n	a12, a12, -1
  908a0d:	600042        	j	908a53 <rcRateFind_11n+0xb3>
		 * rate whose PER has decayed close to 0.  If we
		 * used to next lower rate, its PER would grow to
		 * 10-15 and we would be worse off then staying
		 * at the current rate.
		 */
		perThres = pRc->state[rate].per;
  908a10:	a943      	add.n	a3, a4, a9
  908a12:	233000        	l8ui	a3, a3, 0
		if ( perThres < 12 ) {
			perThres = 12;
		}

		thisThruput = pRateTable->info[rate].userRateKbps * (100 - perThres);
  908a15:	c0fc      	movi.n	a15, 12
  908a17:	0f3337        	maxu	a3, a3, a15
  908a1a:	2f0a64        	movi	a15, 100
  908a1d:	03f30c        	sub	a3, a15, a3
  908a20:	0e3328        	mull	a3, a3, a14
		if (bestThruput <= thisThruput) {
  908a23:	7d3303        	bltu	a3, a13, 908a2a <rcRateFind_11n+0x8a>
  908a26:	d790      	mov.n	a7, a9
  908a28:	dd30      	mov.n	a13, a3
  908a2a:	b088      	addi.n	a8, a8, -1
    
	/*
	 * Try the higher rate first. It will reduce memory moving time
	 * if we have very good channel characteristics.
	 */
	for (index = maxIndex; index >= minIndex ; index--) {
  908a2c:	080847        	extui	a8, a8, 0, 8
  908a2f:	008332        	sext	a3, a8, 7
  908a32:	673fae        	bgez	a3, 9089e4 <rcRateFind_11n+0x44>
  908a35:	63ffc5        	j	9089fe <rcRateFind_11n+0x5e>
                     A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_UINT8 i;

	for (i = 0; i < pRc->maxValidRate-1; i++) {
		if (pRc->validRateIndex[i] == curValidTxRate) {
  908a38:	a748      	add.n	a8, a4, a7
  908a3a:	298042        	l8ui	a9, a8, 66
  908a3d:	73990d        	bne	a9, a3, 908a4e <rcRateFind_11n+0xae>
		rate = pRc->rateMaxPhy;

		/* Probe the next allowed phy state */
		/* FIXME: Check to make sure ratMax is checked properly */
		if (rcGetNextValidTxRate( pRateTable, pRc, rate, &nextRate) && 
		    (nowMsec - pRc->probeTime > pRateTable->probeInterval) &&
  908a40:	874f      	l32i.n	a7, a4, 60
  908a42:	296001        	l8ui	a9, a6, 1
  908a45:	07a70c        	sub	a7, a10, a7
	if (rate >= pRc->rateMaxPhy && probeAllowed) {
		rate = pRc->rateMaxPhy;

		/* Probe the next allowed phy state */
		/* FIXME: Check to make sure ratMax is checked properly */
		if (rcGetNextValidTxRate( pRateTable, pRc, rate, &nextRate) && 
  908a48:	77930d        	bltu	a9, a7, 908a59 <rcRateFind_11n+0xb9>
  908a4b:	600029        	j	908a78 <rcRateFind_11n+0xd8>
rcGetNextValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc, 
                     A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_UINT8 i;

	for (i = 0; i < pRc->maxValidRate-1; i++) {
  908a4e:	b177      	addi.n	a7, a7, 1
  908a50:	070747        	extui	a7, a7, 0, 8
  908a53:	7c72e1        	blt	a7, a12, 908a38 <rcRateFind_11n+0x98>
  908a56:	60001e        	j	908a78 <rcRateFind_11n+0xd8>
		rate = pRc->rateMaxPhy;

		/* Probe the next allowed phy state */
		/* FIXME: Check to make sure ratMax is checked properly */
		if (rcGetNextValidTxRate( pRateTable, pRc, rate, &nextRate) && 
		    (nowMsec - pRc->probeTime > pRateTable->probeInterval) &&
  908a59:	274040        	l8ui	a7, a4, 64
  908a5c:	c978      	beqz.n	a7, 908a78 <rcRateFind_11n+0xd8>
{
	A_UINT8 i;

	for (i = 0; i < pRc->maxValidRate-1; i++) {
		if (pRc->validRateIndex[i] == curValidTxRate) {
			*pNextIndex = pRc->validRateIndex[i+1];
  908a5e:	238043        	l8ui	a3, a8, 67
		    (pRc->hwMaxRetryPktCnt >= 1))
		{
			rate                  = nextRate;
			pRc->probeRate        = rate;
			pRc->probeTime        = nowMsec;
			pRc->hwMaxRetryPktCnt = 0;
  908a61:	c070      	movi.n	a7, 0
			*isProbing            = TRUE;
  908a63:	281211        	l32i	a8, a1, 68
		    (pRc->hwMaxRetryPktCnt >= 1))
		{
			rate                  = nextRate;
			pRc->probeRate        = rate;
			pRc->probeTime        = nowMsec;
			pRc->hwMaxRetryPktCnt = 0;
  908a66:	274440        	s8i	a7, a4, 64
		if (rcGetNextValidTxRate( pRateTable, pRc, rate, &nextRate) && 
		    (nowMsec - pRc->probeTime > pRateTable->probeInterval) &&
		    (pRc->hwMaxRetryPktCnt >= 1))
		{
			rate                  = nextRate;
			pRc->probeRate        = rate;
  908a69:	234437        	s8i	a3, a4, 55
			pRc->probeTime        = nowMsec;
  908a6c:	9a4f      	s32i.n	a10, a4, 60
			pRc->hwMaxRetryPktCnt = 0;
			*isProbing            = TRUE;
  908a6e:	c071      	movi.n	a7, 1
  908a70:	9780      	s32i.n	a7, a8, 0
  908a72:	600002        	j	908a78 <rcRateFind_11n+0xd8>
  908a75:	00d370        	excw
	 * Make sure rate is not higher than the allowed maximum.
	 * We should also enforce the min, but I suspect the min is
	 * normally 1 rather than 0 because of the rate 9 vs 6 issue
	 * in the old code.
	 */
	if (rate > (pRc->rateTableSize - 1)) {
  908a78:	274036        	l8ui	a7, a4, 54
  908a7b:	773205        	blt	a3, a7, 908a84 <rcRateFind_11n+0xe4>
		rate = pRc->rateTableSize - 1;
  908a7e:	237cff        	addi	a3, a7, -1
  908a81:	030347        	extui	a3, a3, 0, 8
	}

	/* record selected rate, which is used to decide if we want to do fast frame */
	if (!(*isProbing) && pSib) {
  908a84:	2c1211        	l32i	a12, a1, 68
  908a87:	87c0      	l32i.n	a7, a12, 0
  908a89:	657148        	bnez	a7, 908bd5 <rcRateFind_11n+0x235>
		pSib->lastRateKbps = pRateTable->info[rate].rateKbps;
  908a8c:	0e3811        	slli	a8, a3, 2
  908a8f:	a388      	add.n	a8, a8, a3
  908a91:	0d8811        	slli	a8, a8, 3
  908a94:	a868      	add.n	a8, a6, a8
  908a96:	8884      	l32i.n	a8, a8, 16
  908a98:	284620        	s32i	a8, a4, 128
		((struct atheros_softc*)sc->sc_rc)->currentTxRateKbps = pSib->lastRateKbps;
  908a9b:	242248        	l32i	a4, a2, 0x120
  908a9e:	9844      	s32i.n	a8, a4, 16
		((struct atheros_softc*)sc->sc_rc)->currentTxRateIndex = rate;
  908aa0:	9345      	s32i.n	a3, a4, 20
	A_UINT8 dot11Rate;
	WLAN_PHY phy;

	rix = rcRateFind_ht(sc, asn, pRateTable, (rcflag & ATH_RC_PROBE_ALLOWED) ? 1 : 0, 
			    isProbe);
	nrix = rix;
  908aa2:	d830      	mov.n	a8, a3

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
		    int numTries, int numRates, int stepDnInc,
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
	A_UINT8 i = 0; 
  908aa4:	d4b0      	mov.n	a4, a11

	rix = rcRateFind_ht(sc, asn, pRateTable, (rcflag & ATH_RC_PROBE_ALLOWED) ? 1 : 0, 
			    isProbe);
	nrix = rix;

	if ((rcflag & ATH_RC_PROBE_ALLOWED) && (*isProbe)) {
  908aa6:	cab4      	beqz.n	a11, 908ace <rcRateFind_11n+0x12e>
  908aa8:	89c0      	l32i.n	a9, a12, 0

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
		    int numTries, int numRates, int stepDnInc,
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
	A_UINT8 i = 0; 
  908aaa:	d470      	mov.n	a4, a7

	rix = rcRateFind_ht(sc, asn, pRateTable, (rcflag & ATH_RC_PROBE_ALLOWED) ? 1 : 0, 
			    isProbe);
	nrix = rix;

	if ((rcflag & ATH_RC_PROBE_ALLOWED) && (*isProbe)) {
  908aac:	c99e      	beqz.n	a9, 908ace <rcRateFind_11n+0x12e>
		/* set one try for probe rates. For the probes don't enable rts */
		rcRateSetseries(pRateTable, &series[i++], 1, nrix,
  908aae:	c0e0      	movi.n	a14, 0
  908ab0:	dd30      	mov.n	a13, a3
  908ab2:	c0c1      	movi.n	a12, 1
  908ab4:	db50      	mov.n	a11, a5
  908ab6:	066a02        	or	a10, a6, a6
  908ab9:	5bfe92        	call8	908504 <rcRateSetseries$constprop$11>
          
		/*
		 * Get the next tried/allowed rate. No RTS for the next series
		 * after the probe rate
		 */
		nrix = rcRateGetIndex( sc, an, pRateTable, nrix, 1, FALSE);
  908abc:	8a13      	l32i.n	a10, a1, 12
  908abe:	c0e0      	movi.n	a14, 0
  908ac0:	c0d1      	movi.n	a13, 1
  908ac2:	dc30      	mov.n	a12, a3
  908ac4:	066b02        	or	a11, a6, a6
  908ac7:	5bff9d        	call8	90893c <rcRateGetIndex$constprop$9>
  908aca:	d8a0      	mov.n	a8, a10
			    isProbe);
	nrix = rix;

	if ((rcflag & ATH_RC_PROBE_ALLOWED) && (*isProbe)) {
		/* set one try for probe rates. For the probes don't enable rts */
		rcRateSetseries(pRateTable, &series[i++], 1, nrix,
  908acc:	c041      	movi.n	a4, 1
		 * after the probe rate
		 */
		nrix = rcRateGetIndex( sc, an, pRateTable, nrix, 1, FALSE);
	}

	tryPerRate = (numTries/numRates);
  908ace:	8b12      	l32i.n	a11, a1, 8
  908ad0:	8a14      	l32i.n	a10, a1, 16
  908ad2:	9816      	s32i.n	a8, a1, 24

	/* Set the choosen rate. No RTS for first series entry. */
	rcRateSetseries(pRateTable, &series[i++], tryPerRate,
  908ad4:	b147      	addi.n	a7, a4, 1
		 * after the probe rate
		 */
		nrix = rcRateGetIndex( sc, an, pRateTable, nrix, 1, FALSE);
	}

	tryPerRate = (numTries/numRates);
  908ad6:	5b7085        	call8	8e4cec <__divsi3>

	/* Set the choosen rate. No RTS for first series entry. */
	rcRateSetseries(pRateTable, &series[i++], tryPerRate,
  908ad9:	04044f        	extui	a4, a4, 0, 16
  908adc:	0f4b11        	slli	a11, a4, 1
  908adf:	a4bb      	add.n	a11, a11, a4
  908ae1:	8816      	l32i.n	a8, a1, 24
		 * after the probe rate
		 */
		nrix = rcRateGetIndex( sc, an, pRateTable, nrix, 1, FALSE);
	}

	tryPerRate = (numTries/numRates);
  908ae3:	0a0947        	extui	a9, a10, 0, 8

	/* Set the choosen rate. No RTS for first series entry. */
	rcRateSetseries(pRateTable, &series[i++], tryPerRate,
  908ae6:	0ebb11        	slli	a11, a11, 2
  908ae9:	dc90      	mov.n	a12, a9
  908aeb:	c0e0      	movi.n	a14, 0
  908aed:	dd80      	mov.n	a13, a8
  908aef:	ab5b      	add.n	a11, a5, a11
  908af1:	da60      	mov.n	a10, a6
  908af3:	9917      	s32i.n	a9, a1, 28
  908af5:	5bfe83        	call8	908504 <rcRateSetseries$constprop$11>
  908af8:	8917      	l32i.n	a9, a1, 28
  908afa:	8f14      	l32i.n	a15, a1, 16
  908afc:	07941c        	mul16u	a4, a9, a7
  908aff:	04f40c        	sub	a4, a15, a4
	for (; i < numRates; i++) {
		A_UINT8 tryNum;
		A_UINT8 minRate;

		tryNum  = ((i + 1) == numRates) ? numTries - (tryPerRate * i) : tryPerRate ;
		minRate = (((i + 1) == numRates) && (rcflag & ATH_RC_MINRATE_LASTRATE)) ? 1 : 0;
  908b02:	8f11      	l32i.n	a15, a1, 4
  908b04:	040447        	extui	a4, a4, 0, 8
  908b07:	0f1f40        	extui	a15, a15, 1, 1
  908b0a:	9f10      	s32i.n	a15, a1, 0

		nrix = rcRateGetIndex(sc, an, pRateTable, nrix, stepDnInc, minRate);
  908b0c:	8f15      	l32i.n	a15, a1, 20
  908b0e:	0f0f4f        	extui	a15, a15, 0, 16
  908b11:	9f11      	s32i.n	a15, a1, 4
  908b13:	600053        	j	908b6a <rcRateFind_11n+0x1ca>
	/* Fill in the other rates for multirate retry */
	for (; i < numRates; i++) {
		A_UINT8 tryNum;
		A_UINT8 minRate;

		tryNum  = ((i + 1) == numRates) ? numTries - (tryPerRate * i) : tryPerRate ;
  908b16:	8c12      	l32i.n	a12, a1, 8
  908b18:	b17a      	addi.n	a10, a7, 1
  908b1a:	0acb0c        	sub	a11, a12, a10
  908b1d:	8c10      	l32i.n	a12, a1, 0
		minRate = (((i + 1) == numRates) && (rcflag & ATH_RC_MINRATE_LASTRATE)) ? 1 : 0;
  908b1f:	c0e0      	movi.n	a14, 0
	/* Fill in the other rates for multirate retry */
	for (; i < numRates; i++) {
		A_UINT8 tryNum;
		A_UINT8 minRate;

		tryNum  = ((i + 1) == numRates) ? numTries - (tryPerRate * i) : tryPerRate ;
  908b21:	0bce38        	moveqz	a14, a12, a11
  908b24:	8b12      	l32i.n	a11, a1, 8
  908b26:	df90      	mov.n	a15, a9
  908b28:	0aba0c        	sub	a10, a11, a10
  908b2b:	0a4f38        	moveqz	a15, a4, a10
		minRate = (((i + 1) == numRates) && (rcflag & ATH_RC_MINRATE_LASTRATE)) ? 1 : 0;

		nrix = rcRateGetIndex(sc, an, pRateTable, nrix, stepDnInc, minRate);
  908b2e:	8d11      	l32i.n	a13, a1, 4
  908b30:	8a13      	l32i.n	a10, a1, 12
  908b32:	dc80      	mov.n	a12, a8
  908b34:	db60      	mov.n	a11, a6
  908b36:	9917      	s32i.n	a9, a1, 28
  908b38:	2f1606        	s32i	a15, a1, 24
  908b3b:	5bff80        	call8	90893c <rcRateGetIndex$constprop$9>
  908b3e:	d8a0      	mov.n	a8, a10

		/* All other rates in the series have RTS enabled */
		rcRateSetseries(pRateTable, &series[i], tryNum,
  908b40:	070a4f        	extui	a10, a7, 0, 16
  908b43:	0fab11        	slli	a11, a10, 1
  908b46:	8f16      	l32i.n	a15, a1, 24
  908b48:	aabb      	add.n	a11, a11, a10
  908b4a:	0ebb11        	slli	a11, a11, 2
  908b4d:	c0e1      	movi.n	a14, 1
  908b4f:	dd80      	mov.n	a13, a8
  908b51:	dcf0      	mov.n	a12, a15
  908b53:	ab5b      	add.n	a11, a5, a11
  908b55:	066a02        	or	a10, a6, a6
  908b58:	9816      	s32i.n	a8, a1, 24
  908b5a:	5bfe6a        	call8	908504 <rcRateSetseries$constprop$11>
  908b5d:	8917      	l32i.n	a9, a1, 28
	/* Set the choosen rate. No RTS for first series entry. */
	rcRateSetseries(pRateTable, &series[i++], tryPerRate,
			nrix, FALSE, asc->tx_chainmask, asn->stbc);

	/* Fill in the other rates for multirate retry */
	for (; i < numRates; i++) {
  908b5f:	b177      	addi.n	a7, a7, 1
  908b61:	09440c        	sub	a4, a4, a9
  908b64:	070747        	extui	a7, a7, 0, 8
  908b67:	040447        	extui	a4, a4, 0, 8
  908b6a:	8f12      	l32i.n	a15, a1, 8
  908b6c:	8816      	l32i.n	a8, a1, 24
  908b6e:	7f72a4        	blt	a7, a15, 908b16 <rcRateFind_11n+0x176>
	 *    {MCS2, MCS1, MCS0, MCS0}.
	 * When first rate in series is MCS3 in HT20 @ 2.4GHz, series should look like:
	 *    {MCS3, MCS2, MCS1, MCS1}
	 * So, set fourth rate in series to be same as third one for above conditions.
	 */
	if (sc->sc_curmode == IEEE80211_MODE_11NG) {
  908b71:	2822c2        	l32i	a8, a2, 0x308
  908b74:	698168        	bnei	a8, 1, 908be0 <rcRateFind_11n+0x240>
		dot11Rate = pRateTable->info[rix].dot11Rate;
  908b77:	0e3211        	slli	a2, a3, 2
  908b7a:	a323      	add.n	a3, a2, a3
  908b7c:	0d3311        	slli	a3, a3, 3
  908b7f:	a366      	add.n	a6, a6, a3
  908b81:	24601a        	l8ui	a4, a6, 26
		phy = pRateTable->info[rix].phy;
		if (i == 4 &&
  908b84:	697448        	bnei	a7, 4, 908bd0 <rcRateFind_11n+0x230>
		    ((dot11Rate == 2 && phy == WLAN_RC_PHY_HT_40_SS) || 
  908b87:	270a00        	movi	a7, 0
  908b8a:	234cfe        	addi	a3, a4, -2
  908b8d:	077202        	or	a2, a7, a7
  908b90:	038238        	moveqz	a2, a8, a3
	 * So, set fourth rate in series to be same as third one for above conditions.
	 */
	if (sc->sc_curmode == IEEE80211_MODE_11NG) {
		dot11Rate = pRateTable->info[rix].dot11Rate;
		phy = pRateTable->info[rix].phy;
		if (i == 4 &&
  908b93:	020347        	extui	a3, a2, 0, 8
	 *    {MCS3, MCS2, MCS1, MCS1}
	 * So, set fourth rate in series to be same as third one for above conditions.
	 */
	if (sc->sc_curmode == IEEE80211_MODE_11NG) {
		dot11Rate = pRateTable->info[rix].dot11Rate;
		phy = pRateTable->info[rix].phy;
  908b96:	26600c        	l8ui	a6, a6, 12
		if (i == 4 &&
  908b99:	77310b        	beq	a3, a7, 908ba8 <rcRateFind_11n+0x208>
		    ((dot11Rate == 2 && phy == WLAN_RC_PHY_HT_40_SS) || 
  908b9c:	226cfa        	addi	a2, a6, -6
  908b9f:	027839        	movnez	a8, a7, a2
	 * So, set fourth rate in series to be same as third one for above conditions.
	 */
	if (sc->sc_curmode == IEEE80211_MODE_11NG) {
		dot11Rate = pRateTable->info[rix].dot11Rate;
		phy = pRateTable->info[rix].phy;
		if (i == 4 &&
  908ba2:	080247        	extui	a2, a8, 0, 8
  908ba5:	772905        	bne	a2, a7, 908bae <rcRateFind_11n+0x20e>
		    ((dot11Rate == 2 && phy == WLAN_RC_PHY_HT_40_SS) || 
  908ba8:	694324        	bnei	a4, 3, 908bd0 <rcRateFind_11n+0x230>
  908bab:	696421        	bnei	a6, 4, 908bd0 <rcRateFind_11n+0x230>
		     (dot11Rate == 3 && phy == WLAN_RC_PHY_HT_20_SS))) 
		{
			series[3].rix = series[2].rix;
  908bae:	225018        	l8ui	a2, a5, 24
  908bb1:	225424        	s8i	a2, a5, 36
			series[3].flags = series[2].flags;
  908bb4:	22501b        	l8ui	a2, a5, 27
  908bb7:	225427        	s8i	a2, a5, 39
			series[3].max4msframelen = series[2].max4msframelen;
  908bba:	8257      	l32i.n	a2, a5, 28
  908bbc:	925a      	s32i.n	a2, a5, 40
  908bbe:	60000e        	j	908bd0 <rcRateFind_11n+0x230>
	 *            Enable RTS/CTS at MCS 3-0 for downlink throughput.
	 */
	if (sc->sc_curmode == IEEE80211_MODE_11NG) {
		dot11Rate = pRateTable->info[rix].dot11Rate;
		if (dot11Rate <= 3 ) {
			series[0].flags |= ATH_RC_RTSCTS_FLAG;         
  908bc1:	225003        	l8ui	a2, a5, 3
  908bc4:	c130      	movi.n	a3, 16
  908bc6:	032202        	or	a2, a2, a3
  908bc9:	225403        	s8i	a2, a5, 3
		}
	}
}
  908bcc:	d10f      	retw.n
  908bce:	00006e        	excw
	 * AP91 Kite: NetGear OTA location-4 downlink.
	 *            Enable RTS/CTS at MCS 3-0 for downlink throughput.
	 */
	if (sc->sc_curmode == IEEE80211_MODE_11NG) {
		dot11Rate = pRateTable->info[rix].dot11Rate;
		if (dot11Rate <= 3 ) {
  908bd1:	44edd1        	excw
  908bd4:	0fd830        	excw

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
		    int numTries, int numRates, int stepDnInc,
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
	A_UINT8 i = 0; 
  908bd7:	d4b0      	mov.n	a4, a11

	rix = rcRateFind_ht(sc, asn, pRateTable, (rcflag & ATH_RC_PROBE_ALLOWED) ? 1 : 0, 
			    isProbe);
	nrix = rix;

	if ((rcflag & ATH_RC_PROBE_ALLOWED) && (*isProbe)) {
  908bd9:	64bef1        	beqz	a11, 908ace <rcRateFind_11n+0x12e>
  908bdc:	63fece        	j	908aae <rcRateFind_11n+0x10e>
  908bdf:	00d10f        	subx8	a1, a13, a0
	...

00908be4 <rcUpdate_11n>:
void rcUpdate_11n(struct ath_softc_tgt *sc, struct ath_node_target *an,
		  A_UINT8 curTxAnt, 
		  int finalTSIdx, int Xretries,
		  struct ath_rc_series rcs[], int nFrames, 
		  int nBad, int long_retry)
{
  908be4:	6c1008        	entry	a1, 64
  908be7:	d920      	mov.n	a9, a2
	A_UINT32 series = 0;
	A_UINT32 rix;
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  908be9:	2492c2        	l32i	a4, a9, 0x308
  908bec:	222248        	l32i	a2, a2, 0x120
  908bef:	0e4411        	slli	a4, a4, 2
  908bf2:	a422      	add.n	a2, a2, a4
  908bf4:	8421      	l32i.n	a4, a2, 4
	struct atheros_node *pSib = ATH_NODE_ATHEROS(an);
  908bf6:	223282        	l32i	a2, a3, 0x208
void rcUpdate_11n(struct ath_softc_tgt *sc, struct ath_node_target *an,
		  A_UINT8 curTxAnt, 
		  int finalTSIdx, int Xretries,
		  struct ath_rc_series rcs[], int nFrames, 
		  int nBad, int long_retry)
{
  908bf9:	d870      	mov.n	a8, a7
	A_UINT32 series = 0;
	A_UINT32 rix;
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
	struct atheros_node *pSib = ATH_NODE_ATHEROS(an);
  908bfb:	9214      	s32i.n	a2, a1, 16
void rcUpdate_11n(struct ath_softc_tgt *sc, struct ath_node_target *an,
		  A_UINT8 curTxAnt, 
		  int finalTSIdx, int Xretries,
		  struct ath_rc_series rcs[], int nFrames, 
		  int nBad, int long_retry)
{
  908bfd:	c071      	movi.n	a7, 1

	/*
	 * If the first rate is not the final index, there are intermediate rate failures
	 * to be processed.
	 */
	if (finalTSIdx != 0) {
  908bff:	6450a6        	beqz	a5, 908ca9 <rcUpdate_11n+0xc5>
  908c02:	c0a2      	movi.n	a10, 2
  908c04:	d2a0      	mov.n	a2, a10
  908c06:	067239        	movnez	a2, a7, a6
  908c09:	9215      	s32i.n	a2, a1, 20
  908c0b:	c070      	movi.n	a7, 0
  908c0d:	d280      	mov.n	a2, a8
  908c0f:	60008b        	j	908c9e <rcUpdate_11n+0xba>
  908c12:	000000        	ill

		/* Process intermediate rates that failed.*/
		for (series = 0; series < finalTSIdx ; series++) {
			if (rcs[series].tries != 0) {
  908c15:	2e2001        	l8ui	a14, a2, 1
  908c18:	64e07e        	beqz	a14, 908c9a <rcUpdate_11n+0xb6>
				flags = rcs[series].flags;
  908c1b:	2c2003        	l8ui	a12, a2, 3
  908c1e:	c0b2      	movi.n	a11, 2
  908c20:	0bca01        	and	a10, a12, a11
				/* If HT40 and we have switched mode from 40 to 20 => don't update */
				if ((flags & ATH_RC_CW40_FLAG) && 
  908c23:	c8a9      	beqz.n	a10, 908c30 <rcUpdate_11n+0x4c>
  908c25:	8d14      	l32i.n	a13, a1, 16
  908c27:	2bd07c        	l8ui	a11, a13, 124
  908c2a:	7ab102        	beq	a11, a10, 908c30 <rcUpdate_11n+0x4c>
  908c2d:	600123        	j	908d54 <rcUpdate_11n+0x170>
				    (pRc->rcPhyMode != (flags & ATH_RC_CW40_FLAG))) {
					return;
				}
				if ((flags & ATH_RC_CW40_FLAG) && (flags & ATH_RC_HT40_SGI_FLAG)) {
  908c30:	c0b6      	movi.n	a11, 6
  908c32:	0bcb01        	and	a11, a12, a11
  908c35:	69b613        	bnei	a11, 6, 908c4c <rcUpdate_11n+0x68>
					rix = pRateTable->info[rcs[series].rix].htIndex;
  908c38:	2b2000        	l8ui	a11, a2, 0
  908c3b:	0eba11        	slli	a10, a11, 2
  908c3e:	abaa      	add.n	a10, a10, a11
  908c40:	0daa11        	slli	a10, a10, 3
  908c43:	aa4a      	add.n	a10, a4, a10
  908c45:	2ca021        	l8ui	a12, a10, 33
  908c48:	600035        	j	908c81 <rcUpdate_11n+0x9d>
  908c4b:	002b20        	excw
  908c4e:	007dc7        	excw
				} else if (flags & ATH_RC_HT40_SGI_FLAG) {
  908c51:	0f0eba        	excw
					rix = pRateTable->info[rcs[series].rix].sgiIndex;
  908c54:	11abaa        	l32r	a1, 8f3afc <memset+0xe960>
  908c57:	0daa11        	slli	a10, a10, 3
  908c5a:	aa4a      	add.n	a10, a4, a10
  908c5c:	2ca020        	l8ui	a12, a10, 32
  908c5f:	60001e        	j	908c81 <rcUpdate_11n+0x9d>
				} else if (flags & ATH_RC_CW40_FLAG) {
  908c62:	c8ae      	beqz.n	a10, 908c74 <rcUpdate_11n+0x90>
					rix = pRateTable->info[rcs[series].rix].cw40Index;
  908c64:	0eba11        	slli	a10, a11, 2
  908c67:	abaa      	add.n	a10, a10, a11
  908c69:	0daa11        	slli	a10, a10, 3
  908c6c:	aa4a      	add.n	a10, a4, a10
  908c6e:	2ca01f        	l8ui	a12, a10, 31
  908c71:	60000c        	j	908c81 <rcUpdate_11n+0x9d>
				} else {
					rix = pRateTable->info[rcs[series].rix].baseIndex;
  908c74:	0eba11        	slli	a10, a11, 2
  908c77:	abaa      	add.n	a10, a10, a11
  908c79:	0daa11        	slli	a10, a10, 3
  908c7c:	aa4a      	add.n	a10, a4, a10
  908c7e:	2ca01e        	l8ui	a12, a10, 30
  908c81:	2a1210        	l32i	a10, a1, 64
				}

				/* FIXME:XXXX, too many args! */
				rcUpdate_ht(sc, an, rix, Xretries? 1 : 2, rcs[series].tries, 
  908c84:	8d15      	l32i.n	a13, a1, 20
  908c86:	0a0f4f        	extui	a15, a10, 0, 16
  908c89:	9f10      	s32i.n	a15, a1, 0
  908c8b:	da90      	mov.n	a10, a9
  908c8d:	db30      	mov.n	a11, a3
  908c8f:	9817      	s32i.n	a8, a1, 28
  908c91:	9916      	s32i.n	a9, a1, 24
  908c93:	5bfd9d        	call8	908308 <rcUpdate_ht$constprop$6>
  908c96:	8916      	l32i.n	a9, a1, 24
  908c98:	8817      	l32i.n	a8, a1, 28
	 * to be processed.
	 */
	if (finalTSIdx != 0) {

		/* Process intermediate rates that failed.*/
		for (series = 0; series < finalTSIdx ; series++) {
  908c9a:	b177      	addi.n	a7, a7, 1
  908c9c:	bc22      	addi.n	a2, a2, 12
  908c9e:	757b02        	bgeu	a7, a5, 908ca4 <rcUpdate_11n+0xc0>
  908ca1:	63ff70        	j	908c15 <rcUpdate_11n+0x31>
  908ca4:	600025        	j	908ccd <rcUpdate_11n+0xe9>
  908ca7:	000022        	excw
		/*
		 * Handle the special case of MIMO PS burst, where the second aggregate is sent
		 *  out with only one rate and one try. Treating it as an excessive retry penalizes
		 * the rate inordinately.
		 */
		if (rcs[0].tries == 1 && Xretries == 1) {
  908caa:	8001      	l32i.n	a0, a0, 4
  908cac:	db50      	mov.n	a11, a5
  908cae:	b022      	addi.n	a2, a2, -1
  908cb0:	027b38        	moveqz	a11, a7, a2
  908cb3:	0b0247        	extui	a2, a11, 0, 8
  908cb6:	c82a      	beqz.n	a2, 908cc4 <rcUpdate_11n+0xe0>
  908cb8:	b062      	addi.n	a2, a6, -1
  908cba:	dd50      	mov.n	a13, a5
  908cbc:	027d38        	moveqz	a13, a7, a2
  908cbf:	0d0247        	extui	a2, a13, 0, 8
  908cc2:	cc23      	bnez.n	a2, 908cc9 <rcUpdate_11n+0xe5>
		  A_UINT8 curTxAnt, 
		  int finalTSIdx, int Xretries,
		  struct ath_rc_series rcs[], int nFrames, 
		  int nBad, int long_retry)
{
	A_UINT32 series = 0;
  908cc4:	c070      	movi.n	a7, 0
  908cc6:	600003        	j	908ccd <rcUpdate_11n+0xe9>
  908cc9:	d750      	mov.n	a7, a5
		 * Handle the special case of MIMO PS burst, where the second aggregate is sent
		 *  out with only one rate and one try. Treating it as an excessive retry penalizes
		 * the rate inordinately.
		 */
		if (rcs[0].tries == 1 && Xretries == 1) {
			Xretries = 2;
  908ccb:	c062      	movi.n	a6, 2
		}
	}

	flags = rcs[series].flags;
  908ccd:	0f7211        	slli	a2, a7, 1
  908cd0:	a727      	add.n	a7, a2, a7
  908cd2:	0e7711        	slli	a7, a7, 2
  908cd5:	a788      	add.n	a8, a8, a7
  908cd7:	278003        	l8ui	a7, a8, 3
  908cda:	c052      	movi.n	a5, 2
  908cdc:	057501        	and	a5, a7, a5
	/* If HT40 and we have switched mode from 40 to 20 => don't update */
	if ((flags & ATH_RC_CW40_FLAG) && 
  908cdf:	c856      	beqz.n	a5, 908ce9 <rcUpdate_11n+0x105>
  908ce1:	8a14      	l32i.n	a10, a1, 16
  908ce3:	22a07c        	l8ui	a2, a10, 124
  908ce6:	75296a        	bne	a2, a5, 908d54 <rcUpdate_11n+0x170>
	    (pRc->rcPhyMode != (flags & ATH_RC_CW40_FLAG))) {
		return;
	}
	if ((flags & ATH_RC_CW40_FLAG) && (flags & ATH_RC_HT40_SGI_FLAG)) {
  908ce9:	c0a6      	movi.n	a10, 6
  908ceb:	0a7a01        	and	a10, a7, a10
  908cee:	228000        	l8ui	a2, a8, 0
  908cf1:	69a60f        	bnei	a10, 6, 908d04 <rcUpdate_11n+0x120>
		rix = pRateTable->info[rcs[series].rix].htIndex;
  908cf4:	0e2511        	slli	a5, a2, 2
  908cf7:	a252      	add.n	a2, a5, a2
  908cf9:	0d2211        	slli	a2, a2, 3
  908cfc:	a244      	add.n	a4, a4, a2
  908cfe:	2c4021        	l8ui	a12, a4, 33
  908d01:	600035        	j	908d3a <rcUpdate_11n+0x156>
	} else if (flags & ATH_RC_HT40_SGI_FLAG) {
  908d04:	7d7710        	bbci	a7, 29, 908d18 <rcUpdate_11n+0x134>
		rix = pRateTable->info[rcs[series].rix].sgiIndex;
  908d07:	0e2511        	slli	a5, a2, 2
  908d0a:	a252      	add.n	a2, a5, a2
  908d0c:	0d2211        	slli	a2, a2, 3
  908d0f:	a244      	add.n	a4, a4, a2
  908d11:	2c4020        	l8ui	a12, a4, 32
  908d14:	600022        	j	908d3a <rcUpdate_11n+0x156>
  908d17:	00c951        	extui	a9, a0, 28, 2
	} else if (flags & ATH_RC_CW40_FLAG) {
		rix = pRateTable->info[rcs[series].rix].cw40Index;
  908d1a:	0e2511        	slli	a5, a2, 2
  908d1d:	a252      	add.n	a2, a5, a2
  908d1f:	0d2211        	slli	a2, a2, 3
  908d22:	a244      	add.n	a4, a4, a2
  908d24:	2c401f        	l8ui	a12, a4, 31
  908d27:	60000f        	j	908d3a <rcUpdate_11n+0x156>
  908d2a:	000000        	ill
	} else {
		rix = pRateTable->info[rcs[series].rix].baseIndex;
  908d2d:	0e2511        	slli	a5, a2, 2
  908d30:	a252      	add.n	a2, a5, a2
  908d32:	0d2211        	slli	a2, a2, 3
  908d35:	a244      	add.n	a4, a4, a2
  908d37:	2c401e        	l8ui	a12, a4, 30
	}

	/* FIXME:XXXX, too many args! */
	rcUpdate_ht(sc, an, rix, Xretries, long_retry, curTxAnt, 
  908d3a:	221211        	l32i	a2, a1, 68
  908d3d:	2e1212        	l32i	a14, a1, 72
  908d40:	02024f        	extui	a2, a2, 0, 16
  908d43:	9210      	s32i.n	a2, a1, 0
  908d45:	221210        	l32i	a2, a1, 64
  908d48:	dd60      	mov.n	a13, a6
  908d4a:	020f4f        	extui	a15, a2, 0, 16
  908d4d:	db30      	mov.n	a11, a3
  908d4f:	da90      	mov.n	a10, a9
  908d51:	5bfd6d        	call8	908308 <rcUpdate_ht$constprop$6>
  908d54:	d10f      	retw.n
	...

00908d58 <ath_tx_status_update_rate>:

void ath_tx_status_update_rate(struct ath_softc_tgt *sc,
			       struct ath_rc_series rcs[],
			       int series,
			       WMI_TXSTATUS_EVENT *txs)
{
  908d58:	6c1004        	entry	a1, 32
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  908d5b:	2922c2        	l32i	a9, a2, 0x308
  908d5e:	282248        	l32i	a8, a2, 0x120
  908d61:	0e9911        	slli	a9, a9, 2
  908d64:	a988      	add.n	a8, a8, a9

	/* HT Rate */
	if (pRateTable->info[rcs[series].rix].rateCode & 0x80) {
  908d66:	0f4911        	slli	a9, a4, 1
  908d69:	a494      	add.n	a4, a9, a4
  908d6b:	0e4411        	slli	a4, a4, 2
  908d6e:	a433      	add.n	a3, a3, a4
  908d70:	293000        	l8ui	a9, a3, 0
			       struct ath_rc_series rcs[],
			       int series,
			       WMI_TXSTATUS_EVENT *txs)
{
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  908d73:	8a81      	l32i.n	a10, a8, 4

	/* HT Rate */
	if (pRateTable->info[rcs[series].rix].rateCode & 0x80) {
  908d75:	0e9811        	slli	a8, a9, 2
  908d78:	a988      	add.n	a8, a8, a9
  908d7a:	0d8811        	slli	a8, a8, 3
  908d7d:	245000        	l8ui	a4, a5, 0
  908d80:	a8aa      	add.n	a10, a10, a8
  908d82:	22a018        	l8ui	a2, a10, 24
  908d85:	0f4811        	slli	a8, a4, 1
  908d88:	a488      	add.n	a8, a8, a4
  908d8a:	a858      	add.n	a8, a5, a8
  908d8c:	782739        	bbci	a2, 24, 908dc9 <ath_tx_status_update_rate+0x71>
		txs->txstatus[txs->cnt].ts_rate |= SM(pRateTable->info[rcs[series].rix].dot11Rate,
  908d8f:	29a01a        	l8ui	a9, a10, 26
  908d92:	228002        	l8ui	a2, a8, 2
  908d95:	090943        	extui	a9, a9, 0, 4
  908d98:	029902        	or	a9, a9, a2
								       ATH9K_HTC_TXSTAT_RATE);
		txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_MCS;
  908d9b:	248003        	l8ui	a4, a8, 3
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];

	/* HT Rate */
	if (pRateTable->info[rcs[series].rix].rateCode & 0x80) {
		txs->txstatus[txs->cnt].ts_rate |= SM(pRateTable->info[rcs[series].rix].dot11Rate,
  908d9e:	298402        	s8i	a9, a8, 2
								       ATH9K_HTC_TXSTAT_RATE);
		txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_MCS;
  908da1:	c098      	movi.n	a9, 8
  908da3:	094902        	or	a9, a4, a9
  908da6:	298403        	s8i	a9, a8, 3

		if (rcs[series].flags & ATH_RC_CW40_FLAG)
  908da9:	293003        	l8ui	a9, a3, 3
  908dac:	7e9708        	bbci	a9, 30, 908db8 <ath_tx_status_update_rate+0x60>
			txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_CW40;
  908daf:	220a18        	movi	a2, 24
  908db2:	024402        	or	a4, a4, a2
  908db5:	248403        	s8i	a4, a8, 3

		if (rcs[series].flags & ATH_RC_HT40_SGI_FLAG)
  908db8:	7d9719        	bbci	a9, 29, 908dd5 <ath_tx_status_update_rate+0x7d>
			txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_SGI;
  908dbb:	248003        	l8ui	a4, a8, 3
  908dbe:	c220      	movi.n	a2, 32
  908dc0:	024402        	or	a4, a4, a2
  908dc3:	248403        	s8i	a4, a8, 3
  908dc6:	60000b        	j	908dd5 <ath_tx_status_update_rate+0x7d>

	} else {
		txs->txstatus[txs->cnt].ts_rate |= SM(rcs[series].rix, ATH9K_HTC_TXSTAT_RATE);
  908dc9:	228002        	l8ui	a2, a8, 2
  908dcc:	090943        	extui	a9, a9, 0, 4
  908dcf:	029902        	or	a9, a9, a2
  908dd2:	298402        	s8i	a9, a8, 2
	}

	if (rcs[series].flags & ATH_RC_RTSCTS_FLAG)
  908dd5:	223003        	l8ui	a2, a3, 3
  908dd8:	7b2714        	bbci	a2, 27, 908df0 <ath_tx_status_update_rate+0x98>
  908ddb:	245000        	l8ui	a4, a5, 0
		txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_RTC_CTS;
  908dde:	c024      	movi.n	a2, 4
  908de0:	0f4311        	slli	a3, a4, 1
  908de3:	a433      	add.n	a3, a3, a4
  908de5:	a355      	add.n	a5, a5, a3
  908de7:	235003        	l8ui	a3, a5, 3
  908dea:	023302        	or	a3, a3, a2
  908ded:	235403        	s8i	a3, a5, 3
  908df0:	d10f      	retw.n
	...

00908df4 <ath_rate_attach>:

}

struct ath_ratectrl *
ath_rate_attach(struct ath_softc_tgt *sc)
{
  908df4:	6c1004        	entry	a1, 32
#include "Magpie_api.h"

static inline void *	__adf_os_mem_alloc(adf_os_size_t size)
{
//    return (malloc(size,M_DEVBUF,M_DONTWAIT | M_ZERO));
    return A_ALLOCRAM(size);
  908df7:	13716e        	l32r	a3, 8e53b0 <memset+0x214>
  908dfa:	c1b8      	movi.n	a11, 24
  908dfc:	223252        	l32i	a2, a3, 0x148
  908dff:	c0a0      	movi.n	a10, 0
  908e01:	0b2000        	callx8	a2
  908e04:	d2a0      	mov.n	a2, a10
	struct atheros_softc *asc;

	asc = adf_os_mem_alloc(sizeof(struct atheros_softc));
	if (asc == NULL)
  908e06:	c9a6      	beqz.n	a10, 908e20 <ath_rate_attach+0x2c>

/* set a memory buffer */
static inline void
__adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
{
	A_MEMSET(buf, b, size);
  908e08:	8334      	l32i.n	a3, a3, 16
  908e0a:	c1c8      	movi.n	a12, 24
  908e0c:	c0b0      	movi.n	a11, 0
  908e0e:	0b3000        	callx8	a3
		return NULL;

	adf_os_mem_set(asc, 0, sizeof(struct atheros_softc));
	asc->arc.arc_space = sizeof(struct atheros_node);
  908e11:	230a88        	movi	a3, 136
  908e14:	9320      	s32i.n	a3, a2, 0

	ar5416AttachRateTables(asc);
  908e16:	da20      	mov.n	a10, a2

	asc->tx_chainmask = 1;
  908e18:	230a01        	movi	a3, 1
		return NULL;

	adf_os_mem_set(asc, 0, sizeof(struct atheros_softc));
	asc->arc.arc_space = sizeof(struct atheros_node);

	ar5416AttachRateTables(asc);
  908e1b:	58084e        	call8	90af54 <ar5416AttachRateTables>

	asc->tx_chainmask = 1;
  908e1e:	9323      	s32i.n	a3, a2, 12
    
	return &asc->arc;
}
  908e20:	d10f      	retw.n
	...

00908e24 <ath_rate_findrate>:
                  int numRates,
                  int stepDnInc,
                  unsigned int rcflag,
                  struct ath_rc_series series[],
                  int *isProbe)
{
  908e24:	6c1006        	entry	a1, 48
  908e27:	8e1f      	l32i.n	a14, a1, 60
	*isProbe = 0;
  908e29:	c080      	movi.n	a8, 0

	if (!numRates || !numTries) {
  908e2b:	c091      	movi.n	a9, 1
                  int stepDnInc,
                  unsigned int rcflag,
                  struct ath_rc_series series[],
                  int *isProbe)
{
	*isProbe = 0;
  908e2d:	98e0      	s32i.n	a8, a14, 0

	if (!numRates || !numTries) {
  908e2f:	079838        	moveqz	a8, a9, a7
  908e32:	080847        	extui	a8, a8, 0, 8
                  int numRates,
                  int stepDnInc,
                  unsigned int rcflag,
                  struct ath_rc_series series[],
                  int *isProbe)
{
  908e35:	dd70      	mov.n	a13, a7
  908e37:	da20      	mov.n	a10, a2
  908e39:	db30      	mov.n	a11, a3
  908e3b:	dc60      	mov.n	a12, a6
	*isProbe = 0;

	if (!numRates || !numTries) {
  908e3d:	cd80      	bnez.n	a8, 908e51 <ath_rate_findrate+0x2d>
  908e3f:	069838        	moveqz	a8, a9, a6
  908e42:	cc8b      	bnez.n	a8, 908e51 <ath_rate_findrate+0x2d>
	*isProbe = 0;
	if (!numRates || !numTries) {
		return;
	}

	rcRateFind_11n(sc, an, numTries, numRates, stepDnInc, rcflag, series, isProbe);
  908e44:	881e      	l32i.n	a8, a1, 56
  908e46:	9e11      	s32i.n	a14, a1, 4
  908e48:	8f1d      	l32i.n	a15, a1, 52
  908e4a:	8e1c      	l32i.n	a14, a1, 48
  908e4c:	9810      	s32i.n	a8, a1, 0
  908e4e:	5bfed4        	call8	9089a0 <rcRateFind_11n>
  908e51:	d10f      	retw.n
	...

00908e54 <ath_rate_tx_complete>:
ath_rate_tx_complete(struct ath_softc_tgt *sc,
		     struct ath_node_target *an,
		     struct ath_tx_desc *ds,
		     struct ath_rc_series rcs[], 
		     int nframes, int nbad)
{
  908e54:	6c1006        	entry	a1, 48
			 int nframes, int nbad)
{
	int finalTSIdx = ds->ds_txstat.ts_rate;
	int tx_status = 0;

	if ((ds->ds_txstat.ts_status & HAL_TXERR_XRETRY) ||
  908e57:	284066        	l8ui	a8, a4, 102
  908e5a:	c095      	movi.n	a9, 5
  908e5c:	098801        	and	a8, a8, a9
ath_rate_tx_complete(struct ath_softc_tgt *sc,
		     struct ath_node_target *an,
		     struct ath_tx_desc *ds,
		     struct ath_rc_series rcs[], 
		     int nframes, int nbad)
{
  908e5f:	da20      	mov.n	a10, a2
  908e61:	db30      	mov.n	a11, a3
  908e63:	df50      	mov.n	a15, a5
			 struct ath_node_target *an,
			 struct ath_tx_desc *ds,
			 struct ath_rc_series rcs[], 
			 int nframes, int nbad)
{
	int finalTSIdx = ds->ds_txstat.ts_rate;
  908e65:	2d4068        	l8ui	a13, a4, 104
	int tx_status = 0;

	if ((ds->ds_txstat.ts_status & HAL_TXERR_XRETRY) ||
  908e68:	c0e1      	movi.n	a14, 1
  908e6a:	cc8a      	bnez.n	a8, 908e78 <ath_rate_tx_complete+0x24>
	    (ds->ds_txstat.ts_status & HAL_TXERR_FIFO) || 
	    (ds->ds_txstat.ts_flags & HAL_TX_DATA_UNDERRUN) ||
  908e6c:	294067        	l8ui	a9, a4, 103
  908e6f:	2c0a18        	movi	a12, 24
  908e72:	0c9901        	and	a9, a9, a12
  908e75:	098e38        	moveqz	a14, a8, a9
	    (ds->ds_txstat.ts_flags & HAL_TX_DELIM_UNDERRUN)) {
		tx_status = 1;
	}

	rcUpdate_11n(sc, an,
  908e78:	2c4073        	l8ui	a12, a4, 115
  908e7b:	244071        	l8ui	a4, a4, 113
  908e7e:	9711      	s32i.n	a7, a1, 4
  908e80:	9412      	s32i.n	a4, a1, 8
  908e82:	261600        	s32i	a6, a1, 0
  908e85:	5bff57        	call8	908be4 <rcUpdate_11n>
  908e88:	d10f      	retw.n
	...

00908e8c <ath_rate_newassoc>:
}

void
ath_rate_newassoc(struct ath_softc_tgt *sc, struct ath_node_target *an, int isnew, 
		  unsigned int capflag, struct ieee80211_rate *rs)
{
  908e8c:	6c1004        	entry	a1, 32
  908e8f:	da20      	mov.n	a10, a2
  908e91:	dc50      	mov.n	a12, a5
  908e93:	dd60      	mov.n	a13, a6

static void
ath_rate_newassoc_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, int isnew, 
		      unsigned int capflag, struct ieee80211_rate *rs)
{
	if (isnew) {
  908e95:	c844      	beqz.n	a4, 908e9d <ath_rate_newassoc+0x11>
#ifdef MAGPIE_MERLIN
		struct atheros_node *oan = ATH_NODE_ATHEROS(an);
		/* Only MERLIN can send STBC */
		oan->stbc = (capflag & ATH_RC_TX_STBC_FLAG) ? 1 : 0;
#endif
		rcSibUpdate_ht(sc, an, capflag, 0, rs);
  908e97:	2b3282        	l32i	a11, a3, 0x208
  908e9a:	5bfdb9        	call8	908580 <rcSibUpdate_ht$isra$3$constprop$13>
  908e9d:	d10f      	retw.n
	...

00908ea0 <ath_rate_node_update>:
void ath_rate_node_update(struct ath_softc_tgt *sc,
			  struct ath_node_target *an,
			  a_int32_t isnew,
			  a_uint32_t capflag,
			  struct ieee80211_rate *rs)
{
  908ea0:	6c1004        	entry	a1, 32
  908ea3:	da20      	mov.n	a10, a2
  908ea5:	dc50      	mov.n	a12, a5
  908ea7:	dd60      	mov.n	a13, a6

static void
ath_rate_newassoc_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, int isnew, 
		      unsigned int capflag, struct ieee80211_rate *rs)
{
	if (isnew) {
  908ea9:	c844      	beqz.n	a4, 908eb1 <ath_rate_node_update+0x11>
#ifdef MAGPIE_MERLIN
		struct atheros_node *oan = ATH_NODE_ATHEROS(an);
		/* Only MERLIN can send STBC */
		oan->stbc = (capflag & ATH_RC_TX_STBC_FLAG) ? 1 : 0;
#endif
		rcSibUpdate_ht(sc, an, capflag, 0, rs);
  908eab:	2b3282        	l32i	a11, a3, 0x208
  908eae:	5bfdb4        	call8	908580 <rcSibUpdate_ht$isra$3$constprop$13>
  908eb1:	d10f      	retw.n
	...

00908eb4 <ath_rate_newstate>:
ath_rate_newstate(struct ath_softc_tgt *sc,
		  struct ieee80211vap_target *vap,
		  enum ieee80211_state state,
		  a_uint32_t capflag,
		  struct ieee80211_rate *rs)
{
  908eb4:	6c1004        	entry	a1, 32
	struct ieee80211_node_target *ni = vap->iv_bss;
	struct atheros_softc *asc = (struct atheros_softc *) sc->sc_rc;

	asc->tx_chainmask = sc->sc_ic.ic_tx_chainmask;
  908eb7:	2b2d16        	addmi	a11, a2, 0x1600
		  struct ieee80211vap_target *vap,
		  enum ieee80211_state state,
		  a_uint32_t capflag,
		  struct ieee80211_rate *rs)
{
	struct ieee80211_node_target *ni = vap->iv_bss;
  908eba:	8834      	l32i.n	a8, a3, 16
	struct atheros_softc *asc = (struct atheros_softc *) sc->sc_rc;

	asc->tx_chainmask = sc->sc_ic.ic_tx_chainmask;
  908ebc:	292248        	l32i	a9, a2, 0x120
  908ebf:	2bb026        	l8ui	a11, a11, 38
ath_rate_newstate(struct ath_softc_tgt *sc,
		  struct ieee80211vap_target *vap,
		  enum ieee80211_state state,
		  a_uint32_t capflag,
		  struct ieee80211_rate *rs)
{
  908ec2:	da20      	mov.n	a10, a2
	struct ieee80211_node_target *ni = vap->iv_bss;
	struct atheros_softc *asc = (struct atheros_softc *) sc->sc_rc;

	asc->tx_chainmask = sc->sc_ic.ic_tx_chainmask;
  908ec4:	9b93      	s32i.n	a11, a9, 12
#ifdef MAGPIE_MERLIN
		struct atheros_node *oan = ATH_NODE_ATHEROS(an);
		/* Only MERLIN can send STBC */
		oan->stbc = (capflag & ATH_RC_TX_STBC_FLAG) ? 1 : 0;
#endif
		rcSibUpdate_ht(sc, an, capflag, 0, rs);
  908ec6:	2b8282        	l32i	a11, a8, 0x208
  908ec9:	dd60      	mov.n	a13, a6
  908ecb:	dc50      	mov.n	a12, a5
  908ecd:	5bfdac        	call8	908580 <rcSibUpdate_ht$isra$3$constprop$13>
  908ed0:	d10f      	retw.n
	...

00908ed4 <__adf_os_mem_copy>:
    //free(buf,M_DEVBUF);
}

/* move a memory buffer */
static inline void 		__adf_os_mem_copy(void *dst, const void *src, adf_os_size_t size)
{
  908ed4:	6c1004        	entry	a1, 32
    A_MEMCPY(dst,src,size);    
  908ed7:	18716e        	l32r	a8, 8e5490 <memset+0x2f4>
  908eda:	dc40      	mov.n	a12, a4
  908edc:	8885      	l32i.n	a8, a8, 20
  908ede:	db30      	mov.n	a11, a3
  908ee0:	da20      	mov.n	a10, a2
  908ee2:	0b8000        	callx8	a8
  908ee5:	d10f      	retw.n
	...

00908ee8 <ieee80211_anyhdrsize>:
/*
 * Like ieee80211_hdrsize, but handles any type of frame.
 */
static __inline a_int32_t
ieee80211_anyhdrsize(const void *data)
{
  908ee8:	6c1004        	entry	a1, 32
	const struct ieee80211_frame *wh = data;

	if ((wh->i_fc[0]&IEEE80211_FC0_TYPE_MASK) == IEEE80211_FC0_TYPE_CTL) {
  908eeb:	282000        	l8ui	a8, a2, 0
  908eee:	c09c      	movi.n	a9, 12
  908ef0:	098901        	and	a9, a8, a9
  908ef3:	699415        	bnei	a9, 4, 908f0c <ieee80211_anyhdrsize+0x24>
		switch (wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK) {
  908ef6:	c720      	movi.n	a2, -16
  908ef8:	028801        	and	a8, a8, a2
  908efb:	220ac0        	movi	a2, 192
  908efe:	72812f        	beq	a8, a2, 908f31 <ieee80211_anyhdrsize+0x49>
  908f01:	220ad0        	movi	a2, 208
  908f04:	728129        	beq	a8, a2, 908f31 <ieee80211_anyhdrsize+0x49>
		case IEEE80211_FC0_SUBTYPE_CTS:
		case IEEE80211_FC0_SUBTYPE_ACK:
			return sizeof(struct ieee80211_frame_ack);
		}
		return sizeof(struct ieee80211_frame_min);
  908f07:	c120      	movi.n	a2, 16
  908f09:	d10f      	retw.n
  908f0b:	002220        	excw
	const struct ieee80211_frame *wh = data;
	a_int32_t size = sizeof(struct ieee80211_frame);

	/* NB: we don't handle control frames */
	adf_os_assert((wh->i_fc[0]&IEEE80211_FC0_TYPE_MASK) != IEEE80211_FC0_TYPE_CTL);
	if ((wh->i_fc[1] & IEEE80211_FC1_DIR_MASK) == IEEE80211_FC1_DIR_DSTODS)
  908f0e:	01c1a8        	excw
  908f11:	020241        	extui	a2, a2, 0, 2
		size += IEEE80211_ADDR_LEN;
  908f14:	222cfd        	addi	a2, a2, -3
  908f17:	c19e      	movi.n	a9, 30
  908f19:	02a939        	movnez	a9, a10, a2
  908f1c:	d290      	mov.n	a2, a9
	if (IEEE80211_QOS_HAS_SEQ(wh))
  908f1e:	29fa8c        	movi	a9, -116
  908f21:	098801        	and	a8, a8, a9
		size += sizeof(a_uint16_t);
  908f24:	2a0a88        	movi	a10, 136
  908f27:	b229      	addi.n	a9, a2, 2
  908f29:	0a880c        	sub	a8, a8, a10
  908f2c:	089238        	moveqz	a2, a9, a8
  908f2f:	d10f      	retw.n

	if ((wh->i_fc[0]&IEEE80211_FC0_TYPE_MASK) == IEEE80211_FC0_TYPE_CTL) {
		switch (wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK) {
		case IEEE80211_FC0_SUBTYPE_CTS:
		case IEEE80211_FC0_SUBTYPE_ACK:
			return sizeof(struct ieee80211_frame_ack);
  908f31:	c02a      	movi.n	a2, 10
		}
		return sizeof(struct ieee80211_frame_min);
	} else
		return ieee80211_hdrsize(data);
}
  908f33:	d10f      	retw.n
  908f35:	000000        	ill

00908f38 <owl_tgt_tid_init>:
	ath_rate_findrate(sc, an, 1, frameLen, 10, 4, 1,
			  ATH_RC_PROBE_ALLOWED, series, isProbe);
}

static void owl_tgt_tid_init(struct ath_atx_tid *tid)
{
  908f38:	6c1004        	entry	a1, 32
	int i;

	tid->seq_start  = tid->seq_next = 0;
  908f3b:	c090      	movi.n	a9, 0
	tid->baw_size   = WME_MAX_BA;
  908f3d:	c480      	movi.n	a8, 64

static void owl_tgt_tid_init(struct ath_atx_tid *tid)
{
	int i;

	tid->seq_start  = tid->seq_next = 0;
  908f3f:	292503        	s16i	a9, a2, 6
  908f42:	292502        	s16i	a9, a2, 4
	tid->baw_size   = WME_MAX_BA;
  908f45:	282504        	s16i	a8, a2, 8
	tid->baw_head   = tid->baw_tail = 0;
	tid->paused     = 0;
  908f48:	292434        	s8i	a9, a2, 52
{
	int i;

	tid->seq_start  = tid->seq_next = 0;
	tid->baw_size   = WME_MAX_BA;
	tid->baw_head   = tid->baw_tail = 0;
  908f4b:	c080      	movi.n	a8, 0
	tid->paused     = 0;
	tid->flag       = 0;
  908f4d:	292436        	s8i	a9, a2, 54
	tid->sched      = AH_FALSE;
  908f50:	292435        	s8i	a9, a2, 53

	asf_tailq_init(&tid->buf_q);
  908f53:	292c2c        	addi	a9, a2, 44
{
	int i;

	tid->seq_start  = tid->seq_next = 0;
	tid->baw_size   = WME_MAX_BA;
	tid->baw_head   = tid->baw_tail = 0;
  908f56:	9824      	s32i.n	a8, a2, 16
  908f58:	9823      	s32i.n	a8, a2, 12
	tid->paused     = 0;
	tid->flag       = 0;
	tid->sched      = AH_FALSE;

	asf_tailq_init(&tid->buf_q);
  908f5a:	982b      	s32i.n	a8, a2, 44
  908f5c:	992c      	s32i.n	a9, a2, 48

	for (i = 0; i < ATH_TID_MAX_BUFS; i++) {
		TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, i);
  908f5e:	c0e1      	movi.n	a14, 1
  908f60:	c7df      	movi.n	a13, -1
  908f62:	2a0a80        	movi	a10, 128
  908f65:	6da819        	loop	a10, 908f82 <owl_tgt_tid_init+0x4a>
  908f68:	085912        	srai	a9, a8, 5
  908f6b:	0e9911        	slli	a9, a9, 2
  908f6e:	008104        	ssl	a8
  908f71:	00eb1a        	sll	a11, a14
  908f74:	a929      	add.n	a9, a2, a9
  908f76:	0bdc03        	xor	a12, a13, a11
  908f79:	8b95      	l32i.n	a11, a9, 20
	tid->flag       = 0;
	tid->sched      = AH_FALSE;

	asf_tailq_init(&tid->buf_q);

	for (i = 0; i < ATH_TID_MAX_BUFS; i++) {
  908f7b:	b188      	addi.n	a8, a8, 1
		TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, i);
  908f7d:	0cbb01        	and	a11, a11, a12
  908f80:	9b95      	s32i.n	a11, a9, 20
	}
}
  908f82:	d10f      	retw.n

00908f84 <ath_tgt_txq_add_ucast>:

	return 0;
}

static void ath_tgt_txq_add_ucast(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  908f84:	6c1006        	entry	a1, 48
	struct ath_hal *ah = sc->sc_ah;
	struct ath_txq *txq;
	HAL_STATUS status;
	volatile a_int32_t txe_val;

	adf_os_assert(bf);
  908f87:	cc31      	bnez.n	a3, 908f8c <ath_tgt_txq_add_ucast+0x8>
  908f89:	63fffc        	j	908f89 <ath_tgt_txq_add_ucast+0x5>
	return 0;
}

static void ath_tgt_txq_add_ucast(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_hal *ah = sc->sc_ah;
  908f8c:	222d05        	addmi	a2, a2, 0x500
  908f8f:	842b      	l32i.n	a4, a2, 44

	adf_os_assert(bf);

	txq = bf->bf_txq;

	status = ah->ah_procTxDesc(ah, bf->bf_lastds);
  908f91:	8b3e      	l32i.n	a11, a3, 56
  908f93:	28421a        	l32i	a8, a4, 104
  908f96:	da40      	mov.n	a10, a4
	HAL_STATUS status;
	volatile a_int32_t txe_val;

	adf_os_assert(bf);

	txq = bf->bf_txq;
  908f98:	223220        	l32i	a2, a3, 128

	status = ah->ah_procTxDesc(ah, bf->bf_lastds);
  908f9b:	0b8000        	callx8	a8

	ATH_TXQ_INSERT_TAIL(txq, bf, bf_list);
  908f9e:	c080      	movi.n	a8, 0
  908fa0:	9839      	s32i.n	a8, a3, 36
  908fa2:	8823      	l32i.n	a8, a2, 12
  908fa4:	983a      	s32i.n	a8, a3, 40
  908fa6:	9380      	s32i.n	a3, a8, 0
  908fa8:	283c24        	addi	a8, a3, 36
  908fab:	9823      	s32i.n	a8, a2, 12
  908fad:	8824      	l32i.n	a8, a2, 16
  908faf:	9325      	s32i.n	a3, a2, 20
  908fb1:	b188      	addi.n	a8, a8, 1
  908fb3:	9824      	s32i.n	a8, a2, 16

	if (txq->axq_link == NULL) {
  908fb5:	8821      	l32i.n	a8, a2, 4
  908fb7:	cc87      	bnez.n	a8, 908fc2 <ath_tgt_txq_add_ucast+0x3e>
		ah->ah_setTxDP(ah, txq->axq_qnum, ATH_BUF_GET_DESC_PHY_ADDR(bf));
  908fb9:	884a      	l32i.n	a8, a4, 40
  908fbb:	8c3c      	l32i.n	a12, a3, 48
  908fbd:	8b20      	l32i.n	a11, a2, 0
  908fbf:	600022        	j	908fe5 <ath_tgt_txq_add_ucast+0x61>
	} else {
		*txq->axq_link = ATH_BUF_GET_DESC_PHY_ADDR(bf);
  908fc2:	8c3c      	l32i.n	a12, a3, 48
  908fc4:	9c80      	s32i.n	a12, a8, 0
  908fc6:	187229        	l32r	a8, 8e586c <memset+0x6d0>

		txe_val = ioread32_mac(0x0840);
		if (!(txe_val & (1<< txq->axq_qnum)))
  908fc9:	8b20      	l32i.n	a11, a2, 0
  908fcb:	0c0200        	memw
  908fce:	8880      	l32i.n	a8, a8, 0
	if (txq->axq_link == NULL) {
		ah->ah_setTxDP(ah, txq->axq_qnum, ATH_BUF_GET_DESC_PHY_ADDR(bf));
	} else {
		*txq->axq_link = ATH_BUF_GET_DESC_PHY_ADDR(bf);

		txe_val = ioread32_mac(0x0840);
  908fd0:	0c0200        	memw
  908fd3:	9810      	s32i.n	a8, a1, 0
		if (!(txe_val & (1<< txq->axq_qnum)))
  908fd5:	0c0200        	memw
  908fd8:	8810      	l32i.n	a8, a1, 0
  908fda:	00b004        	ssr	a11
  908fdd:	08081b        	sra	a8, a8
  908fe0:	7f8f06        	bbsi	a8, 31, 908fea <ath_tgt_txq_add_ucast+0x66>
			ah->ah_setTxDP(ah, txq->axq_qnum, ATH_BUF_GET_DESC_PHY_ADDR(bf));
  908fe3:	884a      	l32i.n	a8, a4, 40
  908fe5:	da40      	mov.n	a10, a4
  908fe7:	0b8000        	callx8	a8
	}

	txq->axq_link = &bf->bf_lastds->ds_link;
  908fea:	833e      	l32i.n	a3, a3, 56
	ah->ah_startTxDma(ah, txq->axq_qnum);
  908fec:	8b20      	l32i.n	a11, a2, 0
		txe_val = ioread32_mac(0x0840);
		if (!(txe_val & (1<< txq->axq_qnum)))
			ah->ah_setTxDP(ah, txq->axq_qnum, ATH_BUF_GET_DESC_PHY_ADDR(bf));
	}

	txq->axq_link = &bf->bf_lastds->ds_link;
  908fee:	9321      	s32i.n	a3, a2, 4
	ah->ah_startTxDma(ah, txq->axq_qnum);
  908ff0:	834c      	l32i.n	a3, a4, 48
  908ff2:	044a02        	or	a10, a4, a4
  908ff5:	0b3000        	callx8	a3
  908ff8:	d10f      	retw.n
	...

00908ffc <ath_tx_update_baw>:
	ath_tgt_tx_enqueue(txq, tid);
}

static void
ath_tx_update_baw(ath_atx_tid_t *tid, int seqno)
{
  908ffc:	6c1004        	entry	a1, 32
	int index;
	int cindex;

	index  = ATH_BA_INDEX(tid->seq_start, seqno);
  908fff:	282102        	l16ui	a8, a2, 4
	cindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);

	TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, cindex);
  909002:	c091      	movi.n	a9, 1
ath_tx_update_baw(ath_atx_tid_t *tid, int seqno)
{
	int index;
	int cindex;

	index  = ATH_BA_INDEX(tid->seq_start, seqno);
  909004:	08330c        	sub	a3, a3, a8
	cindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);
  909007:	8823      	l32i.n	a8, a2, 12
ath_tx_update_baw(ath_atx_tid_t *tid, int seqno)
{
	int index;
	int cindex;

	index  = ATH_BA_INDEX(tid->seq_start, seqno);
  909009:	03034b        	extui	a3, a3, 0, 12
	cindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);
  90900c:	a833      	add.n	a3, a3, a8

	TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, cindex);
  90900e:	035841        	extui	a8, a3, 5, 2
  909011:	0e8811        	slli	a8, a8, 2
  909014:	a828      	add.n	a8, a2, a8
  909016:	003104        	ssl	a3
  909019:	00931a        	sll	a3, a9
  90901c:	c7af      	movi.n	a10, -1
  90901e:	03aa03        	xor	a10, a10, a3
  909021:	8385      	l32i.n	a3, a8, 20
  909023:	0a3301        	and	a3, a3, a10
  909026:	9385      	s32i.n	a3, a8, 20

	while (tid->baw_head != tid->baw_tail &&
  909028:	8a24      	l32i.n	a10, a2, 16
  90902a:	600011        	j	90903f <ath_tx_update_baw+0x43>
	       (!TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head))) {
		INCR(tid->seq_start, IEEE80211_SEQ_MAX);
  90902d:	282102        	l16ui	a8, a2, 4
		INCR(tid->baw_head, ATH_TID_MAX_BUFS);
  909030:	b133      	addi.n	a3, a3, 1

	TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, cindex);

	while (tid->baw_head != tid->baw_tail &&
	       (!TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head))) {
		INCR(tid->seq_start, IEEE80211_SEQ_MAX);
  909032:	b188      	addi.n	a8, a8, 1
  909034:	08084b        	extui	a8, a8, 0, 12
		INCR(tid->baw_head, ATH_TID_MAX_BUFS);
  909037:	030346        	extui	a3, a3, 0, 7

	TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, cindex);

	while (tid->baw_head != tid->baw_tail &&
	       (!TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head))) {
		INCR(tid->seq_start, IEEE80211_SEQ_MAX);
  90903a:	282502        	s16i	a8, a2, 4
		INCR(tid->baw_head, ATH_TID_MAX_BUFS);
  90903d:	9323      	s32i.n	a3, a2, 12
	index  = ATH_BA_INDEX(tid->seq_start, seqno);
	cindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);

	TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, cindex);

	while (tid->baw_head != tid->baw_tail &&
  90903f:	8323      	l32i.n	a3, a2, 12
  909041:	7a3114        	beq	a3, a10, 909059 <ath_tx_update_baw+0x5d>
	       (!TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head))) {
  909044:	035812        	srai	a8, a3, 5
  909047:	b488      	addi.n	a8, a8, 4
  909049:	0e8811        	slli	a8, a8, 2
  90904c:	a828      	add.n	a8, a2, a8
  90904e:	8c81      	l32i.n	a12, a8, 4
  909050:	003104        	ssl	a3
  909053:	009b1a        	sll	a11, a9
	index  = ATH_BA_INDEX(tid->seq_start, seqno);
	cindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);

	TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, cindex);

	while (tid->baw_head != tid->baw_tail &&
  909056:	7cb0d3        	bnone	a11, a12, 90902d <ath_tx_update_baw+0x31>
  909059:	d10f      	retw.n
	...

0090905c <ath_update_stats$isra$1>:
	ath_rate_tx_complete(sc, ATH_NODE_TARGET(bf->bf_node),
			     bf->bf_lastds, bf->bf_rcs, 1, 0);
}

static void
ath_update_stats(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
  90905c:	6c1004        	entry	a1, 32
{
	struct ath_tx_desc *ds = bf->bf_desc;
	u_int32_t sr, lr;

	if (ds->ds_txstat.ts_status == 0) {
  90905f:	283066        	l8ui	a8, a3, 102
  909062:	cc8f      	bnez.n	a8, 909075 <ath_update_stats$isra$1+0x19>
		if (ds->ds_txstat.ts_rate & HAL_TXSTAT_ALTRATE)
  909064:	283068        	l8ui	a8, a3, 104
  909067:	788739        	bbci	a8, 24, 9090a4 <ath_update_stats$isra$1+0x48>
			sc->sc_tx_stats.ast_tx_altrate++;
  90906a:	282259        	l32i	a8, a2, 0x164
  90906d:	b188      	addi.n	a8, a8, 1
  90906f:	282659        	s32i	a8, a2, 0x164
  909072:	60002e        	j	9090a4 <ath_update_stats$isra$1+0x48>
	} else {
		if (ds->ds_txstat.ts_status & HAL_TXERR_XRETRY)
  909075:	7f8708        	bbci	a8, 31, 909081 <ath_update_stats$isra$1+0x25>
			sc->sc_tx_stats.ast_tx_xretries++;
  909078:	292252        	l32i	a9, a2, 0x148
  90907b:	299c01        	addi	a9, a9, 1
  90907e:	292652        	s32i	a9, a2, 0x148
		if (ds->ds_txstat.ts_status & HAL_TXERR_FIFO)
  909081:	7d8708        	bbci	a8, 29, 90908d <ath_update_stats$isra$1+0x31>
			sc->sc_tx_stats.ast_tx_fifoerr++;
  909084:	292253        	l32i	a9, a2, 0x14c
  909087:	299c01        	addi	a9, a9, 1
  90908a:	292653        	s32i	a9, a2, 0x14c
		if (ds->ds_txstat.ts_status & HAL_TXERR_FILT)
  90908d:	7e8708        	bbci	a8, 30, 909099 <ath_update_stats$isra$1+0x3d>
			sc->sc_tx_stats.ast_tx_filtered++;
  909090:	292254        	l32i	a9, a2, 0x150
  909093:	299c01        	addi	a9, a9, 1
  909096:	292654        	s32i	a9, a2, 0x150
		if (ds->ds_txstat.ts_status & HAL_TXERR_TIMER_EXPIRED)
  909099:	7b8707        	bbci	a8, 27, 9090a4 <ath_update_stats$isra$1+0x48>
			sc->sc_tx_stats.ast_tx_timer_exp++;
  90909c:	282255        	l32i	a8, a2, 0x154
  90909f:	b188      	addi.n	a8, a8, 1
  9090a1:	282655        	s32i	a8, a2, 0x154
	}
	sr = ds->ds_txstat.ts_shortretry;
	lr = ds->ds_txstat.ts_longretry;
  9090a4:	293071        	l8ui	a9, a3, 113
	sc->sc_tx_stats.ast_tx_shortretry += sr;
  9090a7:	282256        	l32i	a8, a2, 0x158
		if (ds->ds_txstat.ts_status & HAL_TXERR_FILT)
			sc->sc_tx_stats.ast_tx_filtered++;
		if (ds->ds_txstat.ts_status & HAL_TXERR_TIMER_EXPIRED)
			sc->sc_tx_stats.ast_tx_timer_exp++;
	}
	sr = ds->ds_txstat.ts_shortretry;
  9090aa:	233070        	l8ui	a3, a3, 112
	lr = ds->ds_txstat.ts_longretry;
	sc->sc_tx_stats.ast_tx_shortretry += sr;
  9090ad:	a388      	add.n	a8, a8, a3
	sc->sc_tx_stats.ast_tx_longretry += lr;
  9090af:	232257        	l32i	a3, a2, 0x15c
		if (ds->ds_txstat.ts_status & HAL_TXERR_TIMER_EXPIRED)
			sc->sc_tx_stats.ast_tx_timer_exp++;
	}
	sr = ds->ds_txstat.ts_shortretry;
	lr = ds->ds_txstat.ts_longretry;
	sc->sc_tx_stats.ast_tx_shortretry += sr;
  9090b2:	282656        	s32i	a8, a2, 0x158
	sc->sc_tx_stats.ast_tx_longretry += lr;
  9090b5:	a933      	add.n	a3, a3, a9
  9090b7:	232657        	s32i	a3, a2, 0x15c
  9090ba:	d10f      	retw.n

009090bc <ath_tgt_tx_enqueue$isra$3>:
	INCR(tid->seq_start, IEEE80211_SEQ_MAX);
	ath_tgt_tx_send_normal(sc, bf);
}

static void
ath_tgt_tx_enqueue(struct ath_txq *txq, struct ath_atx_tid  *tid)
  9090bc:	6c1004        	entry	a1, 32
{
	if (tid->paused)
  9090bf:	283034        	l8ui	a8, a3, 52
  9090c2:	cd88      	bnez.n	a8, 9090de <ath_tgt_tx_enqueue$isra$3+0x22>
		return;

	if (tid->sched)
  9090c4:	283035        	l8ui	a8, a3, 53
  9090c7:	008832        	sext	a8, a8, 7
  9090ca:	cd80      	bnez.n	a8, 9090de <ath_tgt_tx_enqueue$isra$3+0x22>
		return;

	tid->sched = AH_TRUE;
  9090cc:	c091      	movi.n	a9, 1
  9090ce:	293435        	s8i	a9, a3, 53
	asf_tailq_insert_tail(&txq->axq_tidq, tid, tid_qelem);
  9090d1:	9839      	s32i.n	a8, a3, 36
  9090d3:	8820      	l32i.n	a8, a2, 0
  9090d5:	983a      	s32i.n	a8, a3, 40
  9090d7:	9380      	s32i.n	a3, a8, 0
  9090d9:	233c24        	addi	a3, a3, 36
  9090dc:	9320      	s32i.n	a3, a2, 0
  9090de:	d10f      	retw.n

009090e0 <ath_update_aggr_stats$isra$5>:
	ath_tx_set_retry(sc, bf);
	asf_tailq_insert_tail(bf_q, bf, bf_list);
}

static void
ath_update_aggr_stats(struct ath_softc_tgt *sc,
  9090e0:	6c1004        	entry	a1, 32
{

	u_int8_t status = ATH_DS_TX_STATUS(ds);
	u_int8_t txflags = ATH_DS_TX_FLAGS(ds);

	__statsn(sc, txaggr_longretries, ds->ds_txstat.ts_longretry);
  9090e3:	282268        	l32i	a8, a2, 0x1a0
  9090e6:	068608        	add	a6, a8, a6
	__statsn(sc, txaggr_shortretries, ds->ds_txstat.ts_shortretry);
  9090e9:	28226b        	l32i	a8, a2, 0x1ac
{

	u_int8_t status = ATH_DS_TX_STATUS(ds);
	u_int8_t txflags = ATH_DS_TX_FLAGS(ds);

	__statsn(sc, txaggr_longretries, ds->ds_txstat.ts_longretry);
  9090ec:	262668        	s32i	a6, a2, 0x1a0
	__statsn(sc, txaggr_shortretries, ds->ds_txstat.ts_shortretry);
  9090ef:	058508        	add	a5, a8, a5
  9090f2:	25266b        	s32i	a5, a2, 0x1ac

	if (txflags & HAL_TX_DESC_CFG_ERR)
  9090f5:	7d4708        	bbci	a4, 29, 909101 <ath_update_aggr_stats$isra$5+0x21>
		__stats(sc, txaggr_desc_cfgerr);
  9090f8:	282271        	l32i	a8, a2, 0x1c4
  9090fb:	288c01        	addi	a8, a8, 1
  9090fe:	282671        	s32i	a8, a2, 0x1c4

	if (txflags & HAL_TX_DATA_UNDERRUN)
  909101:	7c4708        	bbci	a4, 28, 90910d <ath_update_aggr_stats$isra$5+0x2d>
		__stats(sc, txaggr_data_urun);
  909104:	282265        	l32i	a8, a2, 0x194
  909107:	288c01        	addi	a8, a8, 1
  90910a:	282665        	s32i	a8, a2, 0x194

	if (txflags & HAL_TX_DELIM_UNDERRUN)
  90910d:	7b4707        	bbci	a4, 27, 909118 <ath_update_aggr_stats$isra$5+0x38>
		__stats(sc, txaggr_delim_urun);
  909110:	282266        	l32i	a8, a2, 0x198
  909113:	b188      	addi.n	a8, a8, 1
  909115:	282666        	s32i	a8, a2, 0x198

	if (!status) {
  909118:	cb38      	beqz.n	a3, 909154 <ath_update_aggr_stats$isra$5+0x74>
		return;
	}

	if (status & HAL_TXERR_XRETRY)
  90911a:	7f3707        	bbci	a3, 31, 909125 <ath_update_aggr_stats$isra$5+0x45>
		__stats(sc, txaggr_compxretry);
  90911d:	28226a        	l32i	a8, a2, 0x1a8
  909120:	b188      	addi.n	a8, a8, 1
  909122:	28266a        	s32i	a8, a2, 0x1a8

	if (status & HAL_TXERR_FILT)
  909125:	7e3708        	bbci	a3, 30, 909131 <ath_update_aggr_stats$isra$5+0x51>
		__stats(sc, txaggr_filtered);
  909128:	28226e        	l32i	a8, a2, 0x1b8
  90912b:	288c01        	addi	a8, a8, 1
  90912e:	28266e        	s32i	a8, a2, 0x1b8

	if (status & HAL_TXERR_FIFO)
  909131:	7d3708        	bbci	a3, 29, 90913d <ath_update_aggr_stats$isra$5+0x5d>
		__stats(sc, txaggr_fifo);
  909134:	28226f        	l32i	a8, a2, 0x1bc
  909137:	288c01        	addi	a8, a8, 1
  90913a:	28266f        	s32i	a8, a2, 0x1bc

	if (status & HAL_TXERR_XTXOP)
  90913d:	7c3708        	bbci	a3, 28, 909149 <ath_update_aggr_stats$isra$5+0x69>
		__stats(sc, txaggr_xtxop);
  909140:	282270        	l32i	a8, a2, 0x1c0
  909143:	288c01        	addi	a8, a8, 1
  909146:	282670        	s32i	a8, a2, 0x1c0

	if (status & HAL_TXERR_TIMER_EXPIRED)
  909149:	7b3707        	bbci	a3, 27, 909154 <ath_update_aggr_stats$isra$5+0x74>
		__stats(sc, txaggr_timer_exp);
  90914c:	23226c        	l32i	a3, a2, 0x1b0
  90914f:	b133      	addi.n	a3, a3, 1
  909151:	23266c        	s32i	a3, a2, 0x1b0
  909154:	d10f      	retw.n
	...

00909158 <ath_dma_unmap$isra$6>:

	skb = adf_nbuf_queue_first(&bf->bf_skbhead);
	adf_nbuf_map(sc->sc_dev, bf->bf_dmamap, skb, ADF_OS_DMA_TO_DEVICE);
}

static void ath_dma_unmap(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
  909158:	6c1004        	entry	a1, 32
 * @return first buffer in queue
 */
static inline adf_nbuf_t 
adf_nbuf_queue_first(adf_nbuf_queue_t *head)
{
    return (__adf_nbuf_queue_first(head));
  90915b:	2a3c14        	addi	a10, a3, 20
  90915e:	5be955        	call8	9036b4 <__adf_nbuf_queue_first>
static inline void
adf_nbuf_unmap(adf_os_device_t      osdev, 
               adf_os_dma_map_t     bmap, 
               adf_os_dma_dir_t     dir)
{
    __adf_nbuf_unmap(osdev, bmap, dir);
  909161:	8b30      	l32i.n	a11, a3, 0
  909163:	8a20      	l32i.n	a10, a2, 0
  909165:	c0c0      	movi.n	a12, 0
  909167:	5be8dc        	call8	9034d8 <__adf_nbuf_unmap>
  90916a:	d10f      	retw.n

0090916c <ath_tgt_skb_free$isra$7>:
	sc->sc_txbuf_held = bf;

	return tmp;
}

static void ath_tgt_skb_free(struct ath_softc_tgt *sc,
  90916c:	6c1004        	entry	a1, 32
{
	adf_nbuf_t tskb;

	while (adf_nbuf_queue_len(head) != 0) {
		tskb = adf_nbuf_queue_remove(head);
		ath_free_tx_skb(sc->tgt_htc_handle,endpt,tskb);
  90916f:	15716e        	l32r	a5, 8e5728 <memset+0x58c>
  909172:	600012        	j	909188 <ath_tgt_skb_free$isra$7+0x1c>
 * @return The head buf in the buf queue.
 */
static inline adf_nbuf_t
adf_nbuf_queue_remove(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_remove(head);
  909175:	da30      	mov.n	a10, a3
  909177:	5be8c4        	call8	903488 <__adf_nbuf_queue_remove>
  90917a:	dca0      	mov.n	a12, a10
  90917c:	285287        	l32i	a8, a5, 0x21c
  90917f:	2a2200        	l32i	a10, a2, 0
  909182:	044b02        	or	a11, a4, a4
  909185:	0b8000        	callx8	a8
 * @return length of the queue
 */
static inline a_uint32_t
adf_nbuf_queue_len(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_len(head);
  909188:	da30      	mov.n	a10, a3
  90918a:	5be948        	call8	9036ac <__adf_nbuf_queue_len>
			     adf_nbuf_queue_t *head,
			     HTC_ENDPOINT_ID endpt)
{
	adf_nbuf_t tskb;

	while (adf_nbuf_queue_len(head) != 0) {
  90918d:	65afe4        	bnez	a10, 909175 <ath_tgt_skb_free$isra$7+0x9>
		tskb = adf_nbuf_queue_remove(head);
		ath_free_tx_skb(sc->tgt_htc_handle,endpt,tskb);
	}
}
  909190:	d10f      	retw.n
	...

00909194 <ath_filltxdesc$isra$9>:

	skb = adf_nbuf_queue_first(&bf->bf_skbhead);
	adf_nbuf_unmap( sc->sc_dev, bf->bf_dmamap, ADF_OS_DMA_TO_DEVICE);
}

static void ath_filltxdesc(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
  909194:	6c1004        	entry	a1, 32
 * @param[out] sg   map info
 */
static inline void
adf_nbuf_dmamap_info(adf_os_dma_map_t bmap, adf_os_dmamap_info_t *sg)
{
    __adf_nbuf_dmamap_info(bmap, sg);
  909197:	8a30      	l32i.n	a10, a3, 0
  909199:	b43b      	addi.n	a11, a3, 4
{
	struct ath_tx_desc *ds0, *ds = bf->bf_desc;
  90919b:	853c      	l32i.n	a5, a3, 48
  90919d:	5be8d3        	call8	9034ec <__adf_nbuf_dmamap_info>
	a_uint8_t i;

	ds0 = ds;
	adf_nbuf_dmamap_info(bf->bf_dmamap, &bf->bf_dmamap_info);

	for (i = 0; i < bf->bf_dmamap_info.nsegs; i++, ds++) {
  9091a0:	c0c0      	movi.n	a12, 0
	adf_nbuf_unmap( sc->sc_dev, bf->bf_dmamap, ADF_OS_DMA_TO_DEVICE);
}

static void ath_filltxdesc(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_tx_desc *ds0, *ds = bf->bf_desc;
  9091a2:	d450      	mov.n	a4, a5
	for (i = 0; i < bf->bf_dmamap_info.nsegs; i++, ds++) {

		ds->ds_data = bf->bf_dmamap_info.dma_segs[i].paddr;

		if (i == (bf->bf_dmamap_info.nsegs - 1)) {
			ds->ds_link = 0;
  9091a4:	d6c0      	mov.n	a6, a12
  9091a6:	60007e        	j	909228 <ath_filltxdesc$isra$9+0x94>
  9091a9:	0dc811        	slli	a8, a12, 3
  9091ac:	a838      	add.n	a8, a3, a8
	ds0 = ds;
	adf_nbuf_dmamap_info(bf->bf_dmamap, &bf->bf_dmamap_info);

	for (i = 0; i < bf->bf_dmamap_info.nsegs; i++, ds++) {

		ds->ds_data = bf->bf_dmamap_info.dma_segs[i].paddr;
  9091ae:	278008        	l8ui	a7, a8, 8

		if (i == (bf->bf_dmamap_info.nsegs - 1)) {
  9091b1:	b0dd      	addi.n	a13, a13, -1
	ds0 = ds;
	adf_nbuf_dmamap_info(bf->bf_dmamap, &bf->bf_dmamap_info);

	for (i = 0; i < bf->bf_dmamap_info.nsegs; i++, ds++) {

		ds->ds_data = bf->bf_dmamap_info.dma_segs[i].paddr;
  9091b3:	274404        	s8i	a7, a4, 4
  9091b6:	278009        	l8ui	a7, a8, 9
  9091b9:	274405        	s8i	a7, a4, 5
  9091bc:	27800a        	l8ui	a7, a8, 10
  9091bf:	274406        	s8i	a7, a4, 6
  9091c2:	27800b        	l8ui	a7, a8, 11
  9091c5:	274407        	s8i	a7, a4, 7
  9091c8:	b1c7      	addi.n	a7, a12, 1

		if (i == (bf->bf_dmamap_info.nsegs - 1)) {
  9091ca:	7cd912        	bne	a13, a12, 9091e0 <ath_filltxdesc$isra$9+0x4c>
			ds->ds_link = 0;
  9091cd:	264400        	s8i	a6, a4, 0
  9091d0:	264401        	s8i	a6, a4, 1
  9091d3:	264402        	s8i	a6, a4, 2
  9091d6:	264403        	s8i	a6, a4, 3
			bf->bf_lastds = ds;
  9091d9:	943e      	s32i.n	a4, a3, 56
  9091db:	600022        	j	909201 <ath_filltxdesc$isra$9+0x6d>
  9091de:	00000c        	sub	a0, a0, a0
		} else
			ds->ds_link = ATH_BUF_GET_DESC_PHY_ADDR_WITH_IDX(bf, i+1);
  9091e1:	7911a7        	beq	a1, a9, 90918c <ath_tgt_skb_free$isra$7+0x20>
  9091e4:	990d      	s32i.n	a9, a0, 52
  9091e6:	9a11      	s32i.n	a10, a1, 4
  9091e8:	893d      	l32i.n	a9, a3, 52
  9091ea:	aa99      	add.n	a9, a9, a10
  9091ec:	098a57        	extui	a10, a9, 24, 8
  9091ef:	2a4400        	s8i	a10, a4, 0
  9091f2:	090a57        	extui	a10, a9, 16, 8
  9091f5:	2a4401        	s8i	a10, a4, 1
  9091f8:	098a47        	extui	a10, a9, 8, 8
  9091fb:	2a4402        	s8i	a10, a4, 2
  9091fe:	294403        	s8i	a9, a4, 3

		ah->ah_fillTxDesc(ds
  909201:	0cdd0c        	sub	a13, a13, a12
  909204:	c091      	movi.n	a9, 1
  909206:	da60      	mov.n	a10, a6
  909208:	0d9a38        	moveqz	a10, a9, a13
  90920b:	2f2218        	l32i	a15, a2, 96
  90920e:	0c6939        	movnez	a9, a6, a12
  909211:	8b83      	l32i.n	a11, a8, 12
  909213:	dda0      	mov.n	a13, a10
  909215:	dc90      	mov.n	a12, a9
  909217:	044a02        	or	a10, a4, a4
  90921a:	055e02        	or	a14, a5, a5
  90921d:	0bf000        	callx8	a15
	a_uint8_t i;

	ds0 = ds;
	adf_nbuf_dmamap_info(bf->bf_dmamap, &bf->bf_dmamap_info);

	for (i = 0; i < bf->bf_dmamap_info.nsegs; i++, ds++) {
  909220:	070c47        	extui	a12, a7, 0, 8
  909223:	270a88        	movi	a7, 136
  909226:	a744      	add.n	a4, a4, a7
  909228:	8d31      	l32i.n	a13, a3, 4
  90922a:	7dcb02        	bgeu	a12, a13, 909230 <ath_filltxdesc$isra$9+0x9c>
  90922d:	63ff78        	j	9091a9 <ath_filltxdesc$isra$9+0x15>
				   , bf->bf_dmamap_info.dma_segs[i].len
				   , i == 0
				   , i == (bf->bf_dmamap_info.nsegs - 1)
				   , ds0);
	}
}
  909230:	d10f      	retw.n
	...

00909234 <ath_tx_tgt_setds>:

static void ath_tx_tgt_setds(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  909234:	6c1006        	entry	a1, 48
	struct ath_tx_desc *ds = bf->bf_desc;
	struct ath_hal *ah = sc->sc_ah;

	switch (bf->bf_protmode) {
  909237:	293084        	l8ui	a9, a3, 132
}

static void ath_tx_tgt_setds(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_tx_desc *ds = bf->bf_desc;
	struct ath_hal *ah = sc->sc_ah;
  90923a:	222d05        	addmi	a2, a2, 0x500
	}
}

static void ath_tx_tgt_setds(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_tx_desc *ds = bf->bf_desc;
  90923d:	8a3c      	l32i.n	a10, a3, 48
	struct ath_hal *ah = sc->sc_ah;
  90923f:	8d2b      	l32i.n	a13, a2, 44
  909241:	283144        	l16ui	a8, a3, 136

	switch (bf->bf_protmode) {
  909244:	689108        	beqi	a9, 1, 909250 <ath_tx_tgt_setds+0x1c>
  909247:	69920d        	bnei	a9, 2, 909258 <ath_tx_tgt_setds+0x24>
    	case IEEE80211_PROT_RTSCTS:
		bf->bf_flags |= HAL_TXDESC_RTSENA;
  90924a:	c094      	movi.n	a9, 4
  90924c:	600002        	j	909252 <ath_tx_tgt_setds+0x1e>
  90924f:	00c098        	excw
		break;
    	case IEEE80211_PROT_CTSONLY:
		bf->bf_flags |= HAL_TXDESC_CTSENA;
  909252:	098802        	or	a8, a8, a9
  909255:	283544        	s16i	a8, a3, 136
		break;
    	default:
		break;
	}

	ah->ah_set11nTxDesc(ds
  909258:	283144        	l16ui	a8, a3, 136
  90925b:	c190      	movi.n	a9, 16
  90925d:	098802        	or	a8, a8, a9
  909260:	08084f        	extui	a8, a8, 0, 16
  909263:	9810      	s32i.n	a8, a1, 0
  909265:	2b3122        	l16ui	a11, a3, 68
  909268:	88df      	l32i.n	a8, a13, 60
  90926a:	2f3085        	l8ui	a15, a3, 133
  90926d:	2e3049        	l8ui	a14, a3, 73
  909270:	2c304a        	l8ui	a12, a3, 74
  909273:	2d0a3c        	movi	a13, 60
  909276:	0b8000        	callx8	a8
			      , 60
			      , bf->bf_keyix
			      , bf->bf_keytype
			      , bf->bf_flags | HAL_TXDESC_INTREQ);

	ath_filltxdesc(sc, bf);
  909279:	8a2b      	l32i.n	a10, a2, 44
  90927b:	db30      	mov.n	a11, a3
  90927d:	5bffc5        	call8	909194 <ath_filltxdesc$isra$9>
  909280:	d10f      	retw.n
	...

00909284 <__adf_os_mem_set$constprop$19>:
}

/* set a memory buffer */
static inline void
__adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
  909284:	6c1004        	entry	a1, 32
{
	A_MEMSET(buf, b, size);
  909287:	18716e        	l32r	a8, 8e5840 <memset+0x6a4>
  90928a:	dc30      	mov.n	a12, a3
  90928c:	8884      	l32i.n	a8, a8, 16
  90928e:	c0b0      	movi.n	a11, 0
  909290:	da20      	mov.n	a10, a2
  909292:	0b8000        	callx8	a8
  909295:	d10f      	retw.n
	...

00909298 <ath_buf_set_rate>:
		asf_tailq_insert_tail(&sc->sc_txbuf, bf, bf_list);
	}
}

static void ath_buf_set_rate(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  909298:	6c1012        	entry	a1, 144
    struct ath_hal *ah = sc->sc_ah;
  90929b:	242d05        	addmi	a4, a2, 0x500
  90929e:	844b      	l32i.n	a4, a4, 44
    HAL_11N_RATE_SERIES series[4];
    a_int32_t i, flags;
    a_uint8_t rix, cix, rtsctsrate;
    a_int32_t prot_mode = AH_FALSE;

    rt = sc->sc_currates;
  9092a0:	252281        	l32i	a5, a2, 0x204
	}
}

static void ath_buf_set_rate(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
    struct ath_hal *ah = sc->sc_ah;
  9092a3:	241615        	s32i	a4, a1, 84
    const HAL_RATE_TABLE *rt;
    struct ath_tx_desc *ds = bf->bf_desc;
  9092a6:	843c      	l32i.n	a4, a3, 48
    a_uint8_t rix, cix, rtsctsrate;
    a_int32_t prot_mode = AH_FALSE;

    rt = sc->sc_currates;
    rix = bf->bf_rcs[0].rix;
    flags = (bf->bf_flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA));
  9092a8:	283144        	l16ui	a8, a3, 136

static void ath_buf_set_rate(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
    struct ath_hal *ah = sc->sc_ah;
    const HAL_RATE_TABLE *rt;
    struct ath_tx_desc *ds = bf->bf_desc;
  9092ab:	241616        	s32i	a4, a1, 88
    a_int32_t prot_mode = AH_FALSE;

    rt = sc->sc_currates;
    rix = bf->bf_rcs[0].rix;
    flags = (bf->bf_flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA));
    cix = rt->info[sc->sc_protrix].controlRate;
  9092ae:	242d03        	addmi	a4, a2, 0x300
  9092b1:	24400c        	l8ui	a4, a4, 12
    a_uint8_t rix, cix, rtsctsrate;
    a_int32_t prot_mode = AH_FALSE;

    rt = sc->sc_currates;
    rix = bf->bf_rcs[0].rix;
    flags = (bf->bf_flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA));
  9092b4:	c06c      	movi.n	a6, 12
    cix = rt->info[sc->sc_protrix].controlRate;
  9092b6:	b244      	addi.n	a4, a4, 2
  9092b8:	0c4411        	slli	a4, a4, 4
  9092bb:	a454      	add.n	a4, a5, a4
  9092bd:	244013        	l8ui	a4, a4, 19
    a_uint8_t rix, cix, rtsctsrate;
    a_int32_t prot_mode = AH_FALSE;

    rt = sc->sc_currates;
    rix = bf->bf_rcs[0].rix;
    flags = (bf->bf_flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA));
  9092c0:	068601        	and	a6, a8, a6
    cix = rt->info[sc->sc_protrix].controlRate;
  9092c3:	241614        	s32i	a4, a1, 80

    if (bf->bf_protmode != IEEE80211_PROT_NONE &&
  9092c6:	243084        	l8ui	a4, a3, 132
  9092c9:	c94b      	beqz.n	a4, 9092e8 <ath_buf_set_rate+0x50>
	(rt->info[rix].phy == IEEE80211_T_OFDM ||
  9092cb:	243050        	l8ui	a4, a3, 80
  9092ce:	270afd        	movi	a7, 253
  9092d1:	b244      	addi.n	a4, a4, 2
  9092d3:	0c4411        	slli	a4, a4, 4
  9092d6:	045408        	add	a4, a5, a4
  9092d9:	244009        	l8ui	a4, a4, 9
  9092dc:	244cfe        	addi	a4, a4, -2
    rt = sc->sc_currates;
    rix = bf->bf_rcs[0].rix;
    flags = (bf->bf_flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA));
    cix = rt->info[sc->sc_protrix].controlRate;

    if (bf->bf_protmode != IEEE80211_PROT_NONE &&
  9092df:	774805        	bany	a4, a7, 9092e8 <ath_buf_set_rate+0x50>
	(rt->info[rix].phy == IEEE80211_T_OFDM ||
	 rt->info[rix].phy == IEEE80211_T_HT) &&
	(bf->bf_flags & HAL_TXDESC_NOACK) == 0) {
	    cix = rt->info[sc->sc_protrix].controlRate;
	    prot_mode = AH_TRUE;
  9092e2:	270a01        	movi	a7, 1
    flags = (bf->bf_flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA));
    cix = rt->info[sc->sc_protrix].controlRate;

    if (bf->bf_protmode != IEEE80211_PROT_NONE &&
	(rt->info[rix].phy == IEEE80211_T_OFDM ||
	 rt->info[rix].phy == IEEE80211_T_HT) &&
  9092e5:	7e8749        	bbci	a8, 30, 909332 <ath_buf_set_rate+0x9a>
	(bf->bf_flags & HAL_TXDESC_NOACK) == 0) {
	    cix = rt->info[sc->sc_protrix].controlRate;
	    prot_mode = AH_TRUE;
    } else {
	    if (ath_hal_getcapability(ah, HAL_CAP_HT) && (!bf->bf_ismcast))
  9092e8:	2a1215        	l32i	a10, a1, 84
  9092eb:	c0b5      	movi.n	a11, 5
  9092ed:	5bef2d        	call8	904fa4 <ath_hal_getcapability>
  9092f0:	c8a9      	beqz.n	a10, 9092fd <ath_buf_set_rate+0x65>
  9092f2:	243221        	l32i	a4, a3, 132
		    flags = HAL_TXDESC_RTSENA;
  9092f5:	c074      	movi.n	a7, 4
	 rt->info[rix].phy == IEEE80211_T_HT) &&
	(bf->bf_flags & HAL_TXDESC_NOACK) == 0) {
	    cix = rt->info[sc->sc_protrix].controlRate;
	    prot_mode = AH_TRUE;
    } else {
	    if (ath_hal_getcapability(ah, HAL_CAP_HT) && (!bf->bf_ismcast))
  9092f7:	047440        	extui	a4, a4, 7, 1
		    flags = HAL_TXDESC_RTSENA;
  9092fa:	047638        	moveqz	a6, a7, a4
  9092fd:	243c75        	addi	a4, a3, 117

	    for (i = 4; i--;) {
  909300:	c074      	movi.n	a7, 4
  909302:	600024        	j	90932a <ath_buf_set_rate+0x92>
  909305:	244cf4        	addi	a4, a4, -12
		    if (bf->bf_rcs[i].tries) {
  909308:	28400c        	l8ui	a8, a4, 12
  90930b:	c98b      	beqz.n	a8, 90932a <ath_buf_set_rate+0x92>
			    cix = rt->info[bf->bf_rcs[i].rix].controlRate;
  90930d:	0f7411        	slli	a4, a7, 1
  909310:	a744      	add.n	a4, a4, a7
  909312:	0e4411        	slli	a4, a4, 2
  909315:	a434      	add.n	a4, a3, a4
  909317:	244050        	l8ui	a4, a4, 80
  90931a:	b244      	addi.n	a4, a4, 2
  90931c:	0c4411        	slli	a4, a4, 4
  90931f:	a454      	add.n	a4, a5, a4
  909321:	244013        	l8ui	a4, a4, 19
  909324:	241614        	s32i	a4, a1, 80
  909327:	600004        	j	90932f <ath_buf_set_rate+0x97>
	    prot_mode = AH_TRUE;
    } else {
	    if (ath_hal_getcapability(ah, HAL_CAP_HT) && (!bf->bf_ismcast))
		    flags = HAL_TXDESC_RTSENA;

	    for (i = 4; i--;) {
  90932a:	b077      	addi.n	a7, a7, -1
  90932c:	6970d5        	bnei	a7, -1, 909305 <ath_buf_set_rate+0x6d>
    const HAL_RATE_TABLE *rt;
    struct ath_tx_desc *ds = bf->bf_desc;
    HAL_11N_RATE_SERIES series[4];
    a_int32_t i, flags;
    a_uint8_t rix, cix, rtsctsrate;
    a_int32_t prot_mode = AH_FALSE;
  90932f:	270a00        	movi	a7, 0
 * @param[in] size  buffer size
 */
static inline void
adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
{
    __adf_os_mem_set(buf, b, size);
  909332:	2b0a50        	movi	a11, 80
  909335:	011a02        	or	a10, a1, a1
  909338:	240a80        	movi	a4, 128
  90933b:	5bffd2        	call8	909284 <__adf_os_mem_set$constprop$19>
  90933e:	a434      	add.n	a4, a3, a4
  909340:	2f3c50        	addi	a15, a3, 80
  909343:	d810      	mov.n	a8, a1
  909345:	241617        	s32i	a4, a1, 92
    }

    adf_os_mem_set(series, 0, sizeof(HAL_11N_RATE_SERIES) * 4);

    for (i = 0; i < 4; i++) {
	    if (!bf->bf_rcs[i].tries)
  909348:	2af001        	l8ui	a10, a15, 1
  90934b:	64a0fe        	beqz	a10, 90944d <ath_buf_set_rate+0x1b5>
		    continue;

	    rix = bf->bf_rcs[i].rix;
  90934e:	2df000        	l8ui	a13, a15, 0

	    series[i].Rate = rt->info[rix].rateCode |
		    (bf->bf_shpream ? rt->info[rix].shortPreamble : 0);
  909351:	2c3221        	l32i	a12, a3, 132
  909354:	0cd911        	slli	a9, a13, 4
  909357:	a959      	add.n	a9, a5, a9
  909359:	2e0a40        	movi	a14, 64
	    if (!bf->bf_rcs[i].tries)
		    continue;

	    rix = bf->bf_rcs[i].rix;

	    series[i].Rate = rt->info[rix].rateCode |
  90935c:	2b9030        	l8ui	a11, a9, 48
  90935f:	240a00        	movi	a4, 0
		    (bf->bf_shpream ? rt->info[rix].shortPreamble : 0);
  909362:	7ec002        	bnone	a12, a14, 909368 <ath_buf_set_rate+0xd0>
  909365:	249031        	l8ui	a4, a9, 49
	    if (!bf->bf_rcs[i].tries)
		    continue;

	    rix = bf->bf_rcs[i].rix;

	    series[i].Rate = rt->info[rix].rateCode |
  909368:	0b4402        	or	a4, a4, a11
  90936b:	9481      	s32i.n	a4, a8, 4
		    ((bf->bf_rcs[i].flags & ATH_RC_HT40_SGI_FLAG) ?
		     HAL_RATESERIES_HALFGI : 0 ) |
		    ((bf->bf_rcs[i].flags & ATH_RC_TX_STBC_FLAG) ?
		     HAL_RATESERIES_STBC: 0);
#else
	    series[i].RateFlags = ((bf->bf_rcs[i].flags & ATH_RC_RTSCTS_FLAG) ?
  90936d:	24f003        	l8ui	a4, a15, 3
				   HAL_RATESERIES_RTS_CTS : 0 ) |
		    ((bf->bf_rcs[i].flags & ATH_RC_CW40_FLAG) ?
		     HAL_RATESERIES_2040 : 0 ) |
  909370:	c0b6      	movi.n	a11, 6
	    rix = bf->bf_rcs[i].rix;

	    series[i].Rate = rt->info[rix].rateCode |
		    (bf->bf_shpream ? rt->info[rix].shortPreamble : 0);

	    series[i].Tries = bf->bf_rcs[i].tries;
  909372:	9a80      	s32i.n	a10, a8, 0
  909374:	c0e4      	movi.n	a14, 4
  909376:	c0a2      	movi.n	a10, 2
		     HAL_RATESERIES_HALFGI : 0 ) |
		    ((bf->bf_rcs[i].flags & ATH_RC_TX_STBC_FLAG) ?
		     HAL_RATESERIES_STBC: 0);
#else
	    series[i].RateFlags = ((bf->bf_rcs[i].flags & ATH_RC_RTSCTS_FLAG) ?
				   HAL_RATESERIES_RTS_CTS : 0 ) |
  909378:	044940        	extui	a9, a4, 4, 1
  90937b:	0a4a01        	and	a10, a4, a10
  90937e:	0e4e01        	and	a14, a4, a14
		    ((bf->bf_rcs[i].flags & ATH_RC_CW40_FLAG) ?
		     HAL_RATESERIES_2040 : 0 ) |
  909381:	0b4401        	and	a4, a4, a11
  909384:	049402        	or	a4, a9, a4
		    ((bf->bf_rcs[i].flags & ATH_RC_HT40_SGI_FLAG) ?
		     HAL_RATESERIES_HALFGI : 0 ) |
		    ((bf->bf_rcs[i].flags & ATH_RC_TX_STBC_FLAG) ?
		     HAL_RATESERIES_STBC: 0);
#else
	    series[i].RateFlags = ((bf->bf_rcs[i].flags & ATH_RC_RTSCTS_FLAG) ?
  909387:	9484      	s32i.n	a4, a8, 16

static a_uint32_t ath_pkt_duration(struct ath_softc_tgt *sc,
				   a_uint8_t rix, struct ath_tx_buf *bf,
				   a_int32_t width, a_int32_t half_gi)
{
	const HAL_RATE_TABLE *rt = sc->sc_currates;
  909389:	2b2281        	l32i	a11, a2, 0x204
	a_uint32_t nbits, nsymbits, duration, nsymbols;
	a_uint8_t rc;
	a_int32_t streams;
	a_int32_t pktlen;

	pktlen = bf->bf_isaggr ? bf->bf_al : bf->bf_pktlen;
  90938c:	7ac705        	bbci	a12, 26, 909395 <ath_buf_set_rate+0xfd>
  90938f:	2c3127        	l16ui	a12, a3, 78
  909392:	600002        	j	909398 <ath_buf_set_rate+0x100>
  909395:	2c3122        	l16ui	a12, a3, 68
	rc = rt->info[rix].rateCode;
  909398:	b2d4      	addi.n	a4, a13, 2
  90939a:	0c4411        	slli	a4, a4, 4
  90939d:	a4b4      	add.n	a4, a11, a4
  90939f:	244010        	l8ui	a4, a4, 16

	if (!IS_HT_RATE(rc))
  9093a2:	004932        	sext	a9, a4, 7
  9093a5:	66901c        	bltz	a9, 9093c5 <ath_buf_set_rate+0x12d>
		return ath_hal_computetxtime(sc->sc_ah, rt, pktlen, rix,
					     bf->bf_shpream);
  9093a8:	2e3221        	l32i	a14, a3, 132

	pktlen = bf->bf_isaggr ? bf->bf_al : bf->bf_pktlen;
	rc = rt->info[rix].rateCode;

	if (!IS_HT_RATE(rc))
		return ath_hal_computetxtime(sc->sc_ah, rt, pktlen, rix,
  9093ab:	242d05        	addmi	a4, a2, 0x500
  9093ae:	8a4b      	l32i.n	a10, a4, 44
  9093b0:	0e6e40        	extui	a14, a14, 6, 1
  9093b3:	28161a        	s32i	a8, a1, 104
  9093b6:	2f1619        	s32i	a15, a1, 100
  9093b9:	5bef08        	call8	904fdc <ath_hal_computetxtime>
  9093bc:	28121a        	l32i	a8, a1, 104
  9093bf:	2f1219        	l32i	a15, a1, 100
  9093c2:	600060        	j	909426 <ath_buf_set_rate+0x18e>
		    ((bf->bf_rcs[i].flags & ATH_RC_CW40_FLAG) ?
		     HAL_RATESERIES_2040 : 0 ) |
		    ((bf->bf_rcs[i].flags & ATH_RC_HT40_SGI_FLAG) ?
		     HAL_RATESERIES_HALFGI : 0 );
#endif
	    series[i].PktDuration = ath_pkt_duration(sc, rix, bf,
  9093c5:	c0d1      	movi.n	a13, 1
	if (!IS_HT_RATE(rc))
		return ath_hal_computetxtime(sc->sc_ah, rt, pktlen, rix,
					     bf->bf_shpream);

	nbits = (pktlen << 3) + OFDM_PLCP_BITS;
	nsymbits = bits_per_symbol[HT_RC_2_MCS(rc)][width];
  9093c7:	040943        	extui	a9, a4, 0, 4
		    ((bf->bf_rcs[i].flags & ATH_RC_CW40_FLAG) ?
		     HAL_RATESERIES_2040 : 0 ) |
		    ((bf->bf_rcs[i].flags & ATH_RC_HT40_SGI_FLAG) ?
		     HAL_RATESERIES_HALFGI : 0 );
#endif
	    series[i].PktDuration = ath_pkt_duration(sc, rix, bf,
  9093ca:	c0b0      	movi.n	a11, 0
  9093cc:	0adb39        	movnez	a11, a13, a10
	if (!IS_HT_RATE(rc))
		return ath_hal_computetxtime(sc->sc_ah, rt, pktlen, rix,
					     bf->bf_shpream);

	nbits = (pktlen << 3) + OFDM_PLCP_BITS;
	nsymbits = bits_per_symbol[HT_RC_2_MCS(rc)][width];
  9093cf:	00d104        	ssl	a13
  9093d2:	009a1a        	sll	a10, a9
  9093d5:	abaa      	add.n	a10, a10, a11
  9093d7:	00d104        	ssl	a13
  9093da:	00aa1a        	sll	a10, a10
  9093dd:	1d72a6        	l32r	a13, 8e5e78 <memset+0xcdc>

	if (!IS_HT_RATE(rc))
		return ath_hal_computetxtime(sc->sc_ah, rt, pktlen, rix,
					     bf->bf_shpream);

	nbits = (pktlen << 3) + OFDM_PLCP_BITS;
  9093e0:	0dcc11        	slli	a12, a12, 3
	nsymbits = bits_per_symbol[HT_RC_2_MCS(rc)][width];
  9093e3:	aada      	add.n	a10, a13, a10
  9093e5:	2ba100        	l16ui	a11, a10, 0
	nsymbols = (nbits + nsymbits - 1) / nsymbits;
  9093e8:	28161a        	s32i	a8, a1, 104
  9093eb:	acba      	add.n	a10, a11, a12
  9093ed:	2aac15        	addi	a10, a10, 21
  9093f0:	2e1618        	s32i	a14, a1, 96
  9093f3:	2f1619        	s32i	a15, a1, 100
  9093f6:	5b6e6a        	call8	8e4da0 <__udivsi3>

	if (!half_gi)
  9093f9:	2e1218        	l32i	a14, a1, 96
  9093fc:	28121a        	l32i	a8, a1, 104
  9093ff:	2f1219        	l32i	a15, a1, 100
		duration = SYMBOL_TIME(nsymbols);
  909402:	0ea911        	slli	a9, a10, 2

	nbits = (pktlen << 3) + OFDM_PLCP_BITS;
	nsymbits = bits_per_symbol[HT_RC_2_MCS(rc)][width];
	nsymbols = (nbits + nsymbits - 1) / nsymbits;

	if (!half_gi)
  909405:	c9e3      	beqz.n	a14, 90941c <ath_buf_set_rate+0x184>
		duration = SYMBOL_TIME(nsymbols);
	else
		duration = SYMBOL_TIME_HALFGI(nsymbols);
  909407:	0da911        	slli	a9, a10, 3
  90940a:	0a9a08        	add	a10, a9, a10
  90940d:	0faa11        	slli	a10, a10, 1
  909410:	1972a7        	l32r	a9, 8e5eac <memset+0xd10>
  909413:	2aac04        	addi	a10, a10, 4
  909416:	09aa2a        	muluh	a10, a10, a9
  909419:	0a2914        	srli	a9, a10, 2

	streams = HT_RC_2_STREAMS(rc);
  90941c:	043a43        	extui	a10, a4, 3, 4
	duration += L_STF + L_LTF + L_SIG + HT_SIG + HT_STF + HT_LTF(streams);
  90941f:	b9aa      	addi.n	a10, a10, 9
  909421:	0eaa11        	slli	a10, a10, 2
  909424:	a9aa      	add.n	a10, a10, a9
#endif
	    series[i].PktDuration = ath_pkt_duration(sc, rix, bf,
				     (bf->bf_rcs[i].flags & ATH_RC_CW40_FLAG) != 0,
				     (bf->bf_rcs[i].flags & ATH_RC_HT40_SGI_FLAG));

	    series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
  909426:	242d16        	addmi	a4, a2, 0x1600
  909429:	244026        	l8ui	a4, a4, 38
		    ((bf->bf_rcs[i].flags & ATH_RC_CW40_FLAG) ?
		     HAL_RATESERIES_2040 : 0 ) |
		    ((bf->bf_rcs[i].flags & ATH_RC_HT40_SGI_FLAG) ?
		     HAL_RATESERIES_HALFGI : 0 );
#endif
	    series[i].PktDuration = ath_pkt_duration(sc, rix, bf,
  90942c:	9a82      	s32i.n	a10, a8, 8
				     (bf->bf_rcs[i].flags & ATH_RC_CW40_FLAG) != 0,
				     (bf->bf_rcs[i].flags & ATH_RC_HT40_SGI_FLAG));

	    series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
  90942e:	9483      	s32i.n	a4, a8, 12

	    if (prot_mode)
  909430:	c879      	beqz.n	a7, 90943d <ath_buf_set_rate+0x1a5>
		    series[i].RateFlags |= HAL_RATESERIES_RTS_CTS;
  909432:	8484      	l32i.n	a4, a8, 16
  909434:	290a01        	movi	a9, 1
  909437:	094402        	or	a4, a4, a9
  90943a:	248604        	s32i	a4, a8, 16

	    if (bf->bf_rcs[i].flags & ATH_RC_DS_FLAG)
  90943d:	24f003        	l8ui	a4, a15, 3
  909440:	7f4709        	bbci	a4, 31, 90944d <ath_buf_set_rate+0x1b5>
		    series[i].RateFlags |= HAL_RATESERIES_RTS_CTS;
  909443:	8484      	l32i.n	a4, a8, 16
  909445:	c091      	movi.n	a9, 1
  909447:	094402        	or	a4, a4, a9
  90944a:	248604        	s32i	a4, a8, 16
	    }
    }

    adf_os_mem_set(series, 0, sizeof(HAL_11N_RATE_SERIES) * 4);

    for (i = 0; i < 4; i++) {
  90944d:	241217        	l32i	a4, a1, 92
  909450:	bcff      	addi.n	a15, a15, 12
  909452:	288c14        	addi	a8, a8, 20
  909455:	74f102        	beq	a15, a4, 90945b <ath_buf_set_rate+0x1c3>
  909458:	63feec        	j	909348 <ath_buf_set_rate+0xb0>
  90945b:	241214        	l32i	a4, a1, 80
	    if (bf->bf_rcs[i].flags & ATH_RC_DS_FLAG)
		    series[i].RateFlags |= HAL_RATESERIES_RTS_CTS;
    }

    rtsctsrate = rt->info[cix].rateCode |
	    (bf->bf_shpream ? rt->info[cix].shortPreamble : 0);
  90945e:	233221        	l32i	a3, a3, 132
  909461:	0c4211        	slli	a2, a4, 4
  909464:	a255      	add.n	a5, a5, a2

	    if (bf->bf_rcs[i].flags & ATH_RC_DS_FLAG)
		    series[i].RateFlags |= HAL_RATESERIES_RTS_CTS;
    }

    rtsctsrate = rt->info[cix].rateCode |
  909466:	2c5030        	l8ui	a12, a5, 48
  909469:	c020      	movi.n	a2, 0
  90946b:	793702        	bbci	a3, 25, 909471 <ath_buf_set_rate+0x1d9>
	    (bf->bf_shpream ? rt->info[cix].shortPreamble : 0);
  90946e:	225031        	l8ui	a2, a5, 49

    ah->ah_set11nRateScenario(ds, 1,
  909471:	241215        	l32i	a4, a1, 84
  909474:	2a1216        	l32i	a10, a1, 88
  909477:	234210        	l32i	a3, a4, 64
  90947a:	df60      	mov.n	a15, a6
  90947c:	c0e4      	movi.n	a14, 4
  90947e:	dd10      	mov.n	a13, a1
  909480:	0c2c02        	or	a12, a2, a12
  909483:	c0b1      	movi.n	a11, 1
  909485:	0b3000        	callx8	a3
  909488:	d10f      	retw.n
	...

0090948c <ath_dma_map$isra$8>:
	duration += L_STF + L_LTF + L_SIG + HT_SIG + HT_STF + HT_LTF(streams);

	return duration;
}

static void ath_dma_map(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
  90948c:	6c1004        	entry	a1, 32
 * @return first buffer in queue
 */
static inline adf_nbuf_t 
adf_nbuf_queue_first(adf_nbuf_queue_t *head)
{
    return (__adf_nbuf_queue_first(head));
  90948f:	2a3c14        	addi	a10, a3, 20
  909492:	5be888        	call8	9036b4 <__adf_nbuf_queue_first>
adf_nbuf_map(adf_os_device_t        osdev, 
             adf_os_dma_map_t       bmap, 
             adf_nbuf_t             buf, 
             adf_os_dma_dir_t       dir)
{
    return __adf_nbuf_map(osdev, bmap, buf, dir);
  909495:	dca0      	mov.n	a12, a10
  909497:	8b30      	l32i.n	a11, a3, 0
  909499:	8a20      	l32i.n	a10, a2, 0
  90949b:	c0d0      	movi.n	a13, 0
  90949d:	5be80b        	call8	9034cc <__adf_nbuf_map>
  9094a0:	d10f      	retw.n
	...

009094a4 <ath_buf_toggle>:
}

static struct ath_tx_buf *ath_buf_toggle(struct ath_softc_tgt *sc,
				      struct ath_tx_buf *bf,
				      a_uint8_t retry)
{
  9094a4:	6c1004        	entry	a1, 32
  9094a7:	d520      	mov.n	a5, a2
	struct ath_tx_buf *tmp = NULL;
	adf_nbuf_t buf = NULL;

	adf_os_assert(sc->sc_txbuf_held != NULL);
  9094a9:	2222dc        	l32i	a2, a2, 0x370
  9094ac:	cc21      	bnez.n	a2, 9094b1 <ath_buf_toggle+0xd>
  9094ae:	63fffc        	j	9094ae <ath_buf_toggle+0xa>

	tmp = sc->sc_txbuf_held;

	if (retry) {
  9094b1:	6440b3        	beqz	a4, 909568 <ath_buf_toggle+0xc4>
  9094b4:	261a18        	movi	a6, 0x118
  9094b7:	a656      	add.n	a6, a5, a6
		ath_dma_unmap(sc, bf);
  9094b9:	db30      	mov.n	a11, a3
  9094bb:	da60      	mov.n	a10, a6
  9094bd:	5bff26        	call8	909158 <ath_dma_unmap$isra$6>
		adf_nbuf_queue_init(&tmp->bf_skbhead);
  9094c0:	272c14        	addi	a7, a2, 20
 * @param[in] head  buf queue head
 */
static inline void
adf_nbuf_queue_init(adf_nbuf_queue_t *head)
{
    __adf_nbuf_queue_init(head);
  9094c3:	da70      	mov.n	a10, a7
  9094c5:	5be875        	call8	90369c <__adf_nbuf_queue_init>
		buf = adf_nbuf_queue_remove(&bf->bf_skbhead);
  9094c8:	243c14        	addi	a4, a3, 20
 * @return The head buf in the buf queue.
 */
static inline adf_nbuf_t
adf_nbuf_queue_remove(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_remove(head);
  9094cb:	da40      	mov.n	a10, a4
  9094cd:	5be7ee        	call8	903488 <__adf_nbuf_queue_remove>
		adf_os_assert(buf);
  9094d0:	cca1      	bnez.n	a10, 9094d5 <ath_buf_toggle+0x31>
  9094d2:	63fffc        	j	9094d2 <ath_buf_toggle+0x2e>
 * @param[in] buf   buf
 */
static inline void
adf_nbuf_queue_add(adf_nbuf_queue_t *head, adf_nbuf_t buf)
{
    __adf_nbuf_queue_add(head, buf);
  9094d5:	dba0      	mov.n	a11, a10
  9094d7:	da70      	mov.n	a10, a7
  9094d9:	5be7e3        	call8	903468 <__adf_nbuf_queue_add>
 * @return length of the queue
 */
static inline a_uint32_t
adf_nbuf_queue_len(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_len(head);
  9094dc:	da40      	mov.n	a10, a4
  9094de:	5be873        	call8	9036ac <__adf_nbuf_queue_len>
  9094e1:	d4a0      	mov.n	a4, a10
		adf_nbuf_queue_add(&tmp->bf_skbhead, buf);

		adf_os_assert(adf_nbuf_queue_len(&bf->bf_skbhead) == 0);
  9094e3:	c8a1      	beqz.n	a10, 9094e8 <ath_buf_toggle+0x44>
  9094e5:	63fffc        	j	9094e5 <ath_buf_toggle+0x41>

		tmp->bf_next = bf->bf_next;
  9094e8:	873b      	l32i.n	a7, a3, 44
		tmp->bf_tidno = bf->bf_tidno;
		tmp->bf_skb = bf->bf_skb;
		tmp->bf_node = bf->bf_node;
		tmp->bf_isaggr = bf->bf_isaggr;
		tmp->bf_flags = bf->bf_flags;
		tmp->bf_state = bf->bf_state;
  9094ea:	c4cc      	movi.n	a12, 76
		adf_os_assert(buf);
		adf_nbuf_queue_add(&tmp->bf_skbhead, buf);

		adf_os_assert(adf_nbuf_queue_len(&bf->bf_skbhead) == 0);

		tmp->bf_next = bf->bf_next;
  9094ec:	972b      	s32i.n	a7, a2, 44
		tmp->bf_endpt = bf->bf_endpt;
  9094ee:	273223        	l32i	a7, a3, 140
		tmp->bf_tidno = bf->bf_tidno;
		tmp->bf_skb = bf->bf_skb;
		tmp->bf_node = bf->bf_node;
		tmp->bf_isaggr = bf->bf_isaggr;
		tmp->bf_flags = bf->bf_flags;
		tmp->bf_state = bf->bf_state;
  9094f1:	2b3c3c        	addi	a11, a3, 60
		adf_nbuf_queue_add(&tmp->bf_skbhead, buf);

		adf_os_assert(adf_nbuf_queue_len(&bf->bf_skbhead) == 0);

		tmp->bf_next = bf->bf_next;
		tmp->bf_endpt = bf->bf_endpt;
  9094f4:	272623        	s32i	a7, a2, 140
		tmp->bf_tidno = bf->bf_tidno;
  9094f7:	27304d        	l8ui	a7, a3, 77
		tmp->bf_skb = bf->bf_skb;
		tmp->bf_node = bf->bf_node;
		tmp->bf_isaggr = bf->bf_isaggr;
		tmp->bf_flags = bf->bf_flags;
		tmp->bf_state = bf->bf_state;
  9094fa:	2a2c3c        	addi	a10, a2, 60

		adf_os_assert(adf_nbuf_queue_len(&bf->bf_skbhead) == 0);

		tmp->bf_next = bf->bf_next;
		tmp->bf_endpt = bf->bf_endpt;
		tmp->bf_tidno = bf->bf_tidno;
  9094fd:	27244d        	s8i	a7, a2, 77
		tmp->bf_skb = bf->bf_skb;
  909500:	8738      	l32i.n	a7, a3, 32
		tmp->bf_node = bf->bf_node;
		tmp->bf_isaggr = bf->bf_isaggr;
  909502:	283221        	l32i	a8, a3, 132
		adf_os_assert(adf_nbuf_queue_len(&bf->bf_skbhead) == 0);

		tmp->bf_next = bf->bf_next;
		tmp->bf_endpt = bf->bf_endpt;
		tmp->bf_tidno = bf->bf_tidno;
		tmp->bf_skb = bf->bf_skb;
  909505:	9728      	s32i.n	a7, a2, 32
		tmp->bf_node = bf->bf_node;
		tmp->bf_isaggr = bf->bf_isaggr;
  909507:	085840        	extui	a8, a8, 5, 1

		tmp->bf_next = bf->bf_next;
		tmp->bf_endpt = bf->bf_endpt;
		tmp->bf_tidno = bf->bf_tidno;
		tmp->bf_skb = bf->bf_skb;
		tmp->bf_node = bf->bf_node;
  90950a:	8734      	l32i.n	a7, a3, 16
		tmp->bf_isaggr = bf->bf_isaggr;
  90950c:	0b8911        	slli	a9, a8, 5
  90950f:	282087        	l8ui	a8, a2, 135

		tmp->bf_next = bf->bf_next;
		tmp->bf_endpt = bf->bf_endpt;
		tmp->bf_tidno = bf->bf_tidno;
		tmp->bf_skb = bf->bf_skb;
		tmp->bf_node = bf->bf_node;
  909512:	9724      	s32i.n	a7, a2, 16
		tmp->bf_isaggr = bf->bf_isaggr;
  909514:	27fadf        	movi	a7, -33
  909517:	078801        	and	a8, a8, a7
  90951a:	098802        	or	a8, a8, a9
  90951d:	282487        	s8i	a8, a2, 135
		tmp->bf_flags = bf->bf_flags;
  909520:	283144        	l16ui	a8, a3, 136
  909523:	282544        	s16i	a8, a2, 136
		tmp->bf_state = bf->bf_state;
  909526:	5b6e64        	call8	8e4eb8 <memcpy>
		tmp->bf_retries = bf->bf_retries;
  909529:	283086        	l8ui	a8, a3, 134
		bf->bf_comp = NULL;

		bf->bf_retries = 0;
		bf->bf_nframes = 0;

		ath_dma_map(sc, tmp);
  90952c:	db20      	mov.n	a11, a2
		tmp->bf_skb = bf->bf_skb;
		tmp->bf_node = bf->bf_node;
		tmp->bf_isaggr = bf->bf_isaggr;
		tmp->bf_flags = bf->bf_flags;
		tmp->bf_state = bf->bf_state;
		tmp->bf_retries = bf->bf_retries;
  90952e:	282486        	s8i	a8, a2, 134
		tmp->bf_comp = bf->bf_comp;
  909531:	883f      	l32i.n	a8, a3, 60
		bf->bf_comp = NULL;

		bf->bf_retries = 0;
		bf->bf_nframes = 0;

		ath_dma_map(sc, tmp);
  909533:	da60      	mov.n	a10, a6
		tmp->bf_node = bf->bf_node;
		tmp->bf_isaggr = bf->bf_isaggr;
		tmp->bf_flags = bf->bf_flags;
		tmp->bf_state = bf->bf_state;
		tmp->bf_retries = bf->bf_retries;
		tmp->bf_comp = bf->bf_comp;
  909535:	982f      	s32i.n	a8, a2, 60
		tmp->bf_nframes = bf->bf_nframes;
  909537:	28304c        	l8ui	a8, a3, 76
  90953a:	28244c        	s8i	a8, a2, 76
		tmp->bf_cookie = bf->bf_cookie;
  90953d:	283092        	l8ui	a8, a3, 146
  909540:	282492        	s8i	a8, a2, 146

		bf->bf_isaggr = 0;
  909543:	283087        	l8ui	a8, a3, 135
		bf->bf_next = NULL;
  909546:	943b      	s32i.n	a4, a3, 44
		tmp->bf_retries = bf->bf_retries;
		tmp->bf_comp = bf->bf_comp;
		tmp->bf_nframes = bf->bf_nframes;
		tmp->bf_cookie = bf->bf_cookie;

		bf->bf_isaggr = 0;
  909548:	078801        	and	a8, a8, a7
  90954b:	283487        	s8i	a8, a3, 135
		bf->bf_next = NULL;
		bf->bf_skb = NULL;
  90954e:	9438      	s32i.n	a4, a3, 32
		bf->bf_node = NULL;
  909550:	9434      	s32i.n	a4, a3, 16
		bf->bf_flags = 0;
  909552:	243544        	s16i	a4, a3, 136
		bf->bf_comp = NULL;
  909555:	24360f        	s32i	a4, a3, 60

		bf->bf_retries = 0;
  909558:	243486        	s8i	a4, a3, 134
		bf->bf_nframes = 0;
  90955b:	24344c        	s8i	a4, a3, 76

		ath_dma_map(sc, tmp);
  90955e:	5bffcb        	call8	90948c <ath_dma_map$isra$8>
		ath_tx_tgt_setds(sc, tmp);
  909561:	db20      	mov.n	a11, a2
  909563:	da50      	mov.n	a10, a5
  909565:	5bff33        	call8	909234 <ath_tx_tgt_setds>
	}

	sc->sc_txbuf_held = bf;
  909568:	2356dc        	s32i	a3, a5, 0x370

	return tmp;
}
  90956b:	d10f      	retw.n
  90956d:	000000        	ill

00909570 <ath_buf_comp>:
		ath_free_tx_skb(sc->tgt_htc_handle,endpt,tskb);
	}
}

static void ath_buf_comp(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  909570:	6c1004        	entry	a1, 32
	ath_dma_unmap(sc, bf);
  909573:	2a1a18        	movi	a10, 0x118
  909576:	db30      	mov.n	a11, a3
  909578:	aa2a      	add.n	a10, a2, a10
  90957a:	5bfef7        	call8	909158 <ath_dma_unmap$isra$6>
	ath_tgt_skb_free(sc, &bf->bf_skbhead,bf->bf_endpt);
  90957d:	2c3223        	l32i	a12, a3, 140
  909580:	2b3c14        	addi	a11, a3, 20
  909583:	b82a      	addi.n	a10, a2, 8
  909585:	5bfef9        	call8	90916c <ath_tgt_skb_free$isra$7>
	bf->bf_skb = NULL;
  909588:	c040      	movi.n	a4, 0
  90958a:	9438      	s32i.n	a4, a3, 32
	bf->bf_node = NULL;
  90958c:	9434      	s32i.n	a4, a3, 16
	bf = ath_buf_toggle(sc, bf, 0);
  90958e:	dc40      	mov.n	a12, a4
  909590:	033b02        	or	a11, a3, a3
  909593:	da20      	mov.n	a10, a2
  909595:	5bffc3        	call8	9094a4 <ath_buf_toggle>
	if (bf != NULL) {
  909598:	74a10e        	beq	a10, a4, 9095aa <ath_buf_comp+0x3a>
		asf_tailq_insert_tail(&sc->sc_txbuf, bf, bf_list);
  90959b:	2322f1        	l32i	a3, a2, 0x3c4
  90959e:	94a9      	s32i.n	a4, a10, 36
  9095a0:	93aa      	s32i.n	a3, a10, 40
  9095a2:	9a30      	s32i.n	a10, a3, 0
  9095a4:	2aac24        	addi	a10, a10, 36
  9095a7:	2a26f1        	s32i	a10, a2, 0x3c4
  9095aa:	d10f      	retw.n

009095ac <ath_tx_freebuf>:
	bf->bf_txq_add(sc, bf);
}

static void
ath_tx_freebuf(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  9095ac:	6c1004        	entry	a1, 32
	a_int32_t i ;
	struct ath_tx_desc *bfd = NULL;
	struct ath_hal *ah = sc->sc_ah;
  9095af:	242d05        	addmi	a4, a2, 0x500
  9095b2:	864b      	l32i.n	a6, a4, 44

	for (bfd = bf->bf_desc, i = 0; i < bf->bf_dmamap_info.nsegs; bfd++, i++) {
  9095b4:	c050      	movi.n	a5, 0
  9095b6:	843c      	l32i.n	a4, a3, 48
  9095b8:	270a88        	movi	a7, 136
  9095bb:	600023        	j	9095e2 <ath_tx_freebuf+0x36>
  9095be:	000028        	mull	a0, a0, a0
		ah->ah_clr11nAggr(bfd);
  9095c1:	6214da        	j	8eaa9f <memset+0x5903>
  9095c4:	400b80        	excw
  9095c7:	002862        	excw
		ah->ah_set11nBurstDuration(bfd, 0);
  9095ca:	15044a        	l32r	a5, 8ca6f4 <_bss_end+0x3bceec>
  9095cd:	022b0a        	addx4	a11, a2, a2
  9095d0:	000b80        	excw
  9095d3:	002862        	excw
		ah->ah_set11nVirtualMoreFrag(bfd, 0);
  9095d6:	16da40        	l32r	a6, 8ffed8 <memset+0x1ad3c>
  9095d9:	c0b0      	movi.n	a11, 0
  9095db:	0b8000        	callx8	a8
{
	a_int32_t i ;
	struct ath_tx_desc *bfd = NULL;
	struct ath_hal *ah = sc->sc_ah;

	for (bfd = bf->bf_desc, i = 0; i < bf->bf_dmamap_info.nsegs; bfd++, i++) {
  9095de:	a744      	add.n	a4, a4, a7
  9095e0:	b155      	addi.n	a5, a5, 1
  9095e2:	8831      	l32i.n	a8, a3, 4
  9095e4:	7853d8        	bltu	a5, a8, 9095c0 <ath_tx_freebuf+0x14>
		ah->ah_clr11nAggr(bfd);
		ah->ah_set11nBurstDuration(bfd, 0);
		ah->ah_set11nVirtualMoreFrag(bfd, 0);
	}

	ath_dma_unmap(sc, bf);
  9095e7:	2a1a18        	movi	a10, 0x118
  9095ea:	db30      	mov.n	a11, a3
  9095ec:	aa2a      	add.n	a10, a2, a10
  9095ee:	5bfeda        	call8	909158 <ath_dma_unmap$isra$6>

	ath_tgt_skb_free(sc, &bf->bf_skbhead,bf->bf_endpt);
  9095f1:	2c3223        	l32i	a12, a3, 140
  9095f4:	2b3c14        	addi	a11, a3, 20
  9095f7:	2a2c08        	addi	a10, a2, 8
  9095fa:	5bfedc        	call8	90916c <ath_tgt_skb_free$isra$7>

	bf->bf_skb = NULL;
  9095fd:	c040      	movi.n	a4, 0
  9095ff:	9438      	s32i.n	a4, a3, 32
	bf->bf_comp = NULL;
  909601:	943f      	s32i.n	a4, a3, 60
	bf->bf_node = NULL;
  909603:	9434      	s32i.n	a4, a3, 16
	bf->bf_next = NULL;
  909605:	943b      	s32i.n	a4, a3, 44
	bf = ath_buf_toggle(sc, bf, 0);
  909607:	db30      	mov.n	a11, a3
  909609:	dc40      	mov.n	a12, a4
  90960b:	da20      	mov.n	a10, a2
  90960d:	5bffa5        	call8	9094a4 <ath_buf_toggle>
	bf->bf_retries = 0;
	bf->bf_isretried = 0;
  909610:	23a087        	l8ui	a3, a10, 135
  909613:	c65f      	movi.n	a5, -17
	bf->bf_skb = NULL;
	bf->bf_comp = NULL;
	bf->bf_node = NULL;
	bf->bf_next = NULL;
	bf = ath_buf_toggle(sc, bf, 0);
	bf->bf_retries = 0;
  909615:	24a486        	s8i	a4, a10, 134
	bf->bf_isretried = 0;
  909618:	053301        	and	a3, a3, a5
  90961b:	23a487        	s8i	a3, a10, 135

	if (bf != NULL)
		asf_tailq_insert_tail(&sc->sc_txbuf, bf, bf_list);
  90961e:	2322f1        	l32i	a3, a2, 0x3c4
  909621:	94a9      	s32i.n	a4, a10, 36
  909623:	93aa      	s32i.n	a3, a10, 40
  909625:	9a30      	s32i.n	a10, a3, 0
  909627:	2aac24        	addi	a10, a10, 36
  90962a:	2a26f1        	s32i	a10, a2, 0x3c4
  90962d:	d10f      	retw.n
	...

00909630 <ath_bar_tx>:
	ath_buf_comp(sc, bf);
}

static void ath_bar_tx(struct ath_softc_tgt *sc,
		       ath_atx_tid_t *tid, struct ath_tx_buf *bf)
{
  909630:	6c1016        	entry	a1, 176
  909633:	d730      	mov.n	a7, a3
	adf_nbuf_t skb;
	struct ieee80211_frame_bar *bar;
	u_int8_t min_rate;
	struct ath_tx_desc *ds, *ds0;
	struct ath_hal *ah = sc->sc_ah;
  909635:	232d05        	addmi	a3, a2, 0x500
  909638:	863b      	l32i.n	a6, a3, 44
  90963a:	231620        	s32i	a3, a1, 128
	int i = 0;
	adf_nbuf_queue_t skbhead;
	a_uint8_t *anbdata;
	a_uint32_t anblen;

	__stats(sc, tx_bars);
  90963d:	232278        	l32i	a3, a2, 0x1e0
  909640:	c5b0      	movi.n	a11, 80
  909642:	b133      	addi.n	a3, a3, 1
  909644:	232678        	s32i	a3, a2, 0x1e0
  909647:	2a1c20        	addi	a10, a1, 32
  90964a:	5bff0e        	call8	909284 <__adf_os_mem_set$constprop$19>

	adf_os_mem_set(&series, 0, sizeof(series));

	ath_aggr_pause_tid(sc, tid);

	skb = adf_nbuf_queue_remove(&bf->bf_skbhead);
  90964d:	254c14        	addi	a5, a4, 20
}

static inline void
ath_aggr_pause_tid(struct ath_softc_tgt *sc, ath_atx_tid_t *tid)
{
	tid->paused =1;
  909650:	230a01        	movi	a3, 1
  909653:	237434        	s8i	a3, a7, 52
 * @return The head buf in the buf queue.
 */
static inline adf_nbuf_t
adf_nbuf_queue_remove(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_remove(head);
  909656:	055a02        	or	a10, a5, a5
  909659:	5be78b        	call8	903488 <__adf_nbuf_queue_remove>
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  90965c:	2c1c70        	addi	a12, a1, 112
  90965f:	2b1c74        	addi	a11, a1, 116
 * @return The head buf in the buf queue.
 */
static inline adf_nbuf_t
adf_nbuf_queue_remove(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_remove(head);
  909662:	0aa302        	or	a3, a10, a10
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  909665:	5be807        	call8	903684 <__adf_nbuf_peek_header>
 * @return none
 */
static inline void
adf_nbuf_trim_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    __adf_nbuf_trim_tail(buf, size);
  909668:	2b121c        	l32i	a11, a1, 112
  90966b:	da30      	mov.n	a10, a3
  90966d:	5be7ea        	call8	903618 <__adf_nbuf_trim_tail>
  909670:	2c1a18        	movi	a12, 0x118
  909673:	ac2c      	add.n	a12, a2, a12
	ath_aggr_pause_tid(sc, tid);

	skb = adf_nbuf_queue_remove(&bf->bf_skbhead);
	adf_nbuf_peek_header(skb, &anbdata, &anblen);
	adf_nbuf_trim_tail(skb, anblen);
	bar = (struct ieee80211_frame_bar *) anbdata;
  909675:	29121d        	l32i	a9, a1, 116

	min_rate =  0x0b;

	ath_dma_unmap(sc, bf);
  909678:	dac0      	mov.n	a10, a12
  90967a:	db40      	mov.n	a11, a4
  90967c:	2c1622        	s32i	a12, a1, 136
  90967f:	291621        	s32i	a9, a1, 132
  909682:	5bfeb5        	call8	909158 <ath_dma_unmap$isra$6>
 * @param[in] buf   buf
 */
static inline void
adf_nbuf_queue_add(adf_nbuf_queue_t *head, adf_nbuf_t buf)
{
    __adf_nbuf_queue_add(head, buf);
  909685:	db30      	mov.n	a11, a3
  909687:	da50      	mov.n	a10, a5
  909689:	5be777        	call8	903468 <__adf_nbuf_queue_add>
	adf_nbuf_queue_add(&bf->bf_skbhead, skb);

	bar->i_fc[1] = IEEE80211_FC1_DIR_NODS;
  90968c:	291221        	l32i	a9, a1, 132
  90968f:	c050      	movi.n	a5, 0
  909691:	259401        	s8i	a5, a9, 1
	bar->i_fc[0] = IEEE80211_FC0_VERSION_0 |
  909694:	25fa84        	movi	a5, -124
  909697:	259400        	s8i	a5, a9, 0
		IEEE80211_FC0_TYPE_CTL |
		IEEE80211_FC0_SUBTYPE_BAR;
	bar->i_ctl = tid->tidno << IEEE80211_BAR_CTL_TID_S |
  90969a:	8570      	l32i.n	a5, a7, 0
  90969c:	c0a4      	movi.n	a10, 4
  90969e:	045511        	slli	a5, a5, 12
  9096a1:	0a5502        	or	a5, a5, a10
  9096a4:	05054f        	extui	a5, a5, 0, 16
  9096a7:	259411        	s8i	a5, a9, 17
  9096aa:	058a14        	srli	a10, a5, 8
		IEEE80211_BAR_CTL_COMBA;
	bar->i_seq = adf_os_cpu_to_le16(tid->seq_start << IEEE80211_SEQ_SEQ_SHIFT);
  9096ad:	257102        	l16ui	a5, a7, 4

	bar->i_fc[1] = IEEE80211_FC1_DIR_NODS;
	bar->i_fc[0] = IEEE80211_FC0_VERSION_0 |
		IEEE80211_FC0_TYPE_CTL |
		IEEE80211_FC0_SUBTYPE_BAR;
	bar->i_ctl = tid->tidno << IEEE80211_BAR_CTL_TID_S |
  9096b0:	2a9410        	s8i	a10, a9, 16
		IEEE80211_BAR_CTL_COMBA;
	bar->i_seq = adf_os_cpu_to_le16(tid->seq_start << IEEE80211_SEQ_SEQ_SHIFT);
  9096b3:	0c5511        	slli	a5, a5, 4
  9096b6:	05054f        	extui	a5, a5, 0, 16
  9096b9:	058b14        	srli	a11, a5, 8
  9096bc:	085a11        	slli	a10, a5, 8
  9096bf:	0baa02        	or	a10, a10, a11
  9096c2:	0a0a4f        	extui	a10, a10, 0, 16
  9096c5:	0a8b14        	srli	a11, a10, 8
  9096c8:	2b9412        	s8i	a11, a9, 18
  9096cb:	2a9413        	s8i	a10, a9, 19

	bf->bf_seqno = tid->seq_start << IEEE80211_SEQ_SEQ_SHIFT;
  9096ce:	254523        	s16i	a5, a4, 70
 *         put, or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_put_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_put_tail(buf, size);
  9096d1:	c1b4      	movi.n	a11, 20
  9096d3:	da30      	mov.n	a10, a3
  9096d5:	5be7c6        	call8	9035f0 <__adf_nbuf_put_tail>

	adf_nbuf_put_tail(skb, sizeof(struct ieee80211_frame_bar));

	bf->bf_comp = ath_bar_tx_comp;
  9096d8:	1572a8        	l32r	a5, 8e6178 <memset+0xfdc>
	bf->bf_tidno = tid->tidno;
	bf->bf_node = &tid->an->ni;
	ath_dma_map(sc, bf);
  9096db:	2c1222        	l32i	a12, a1, 136

	bf->bf_seqno = tid->seq_start << IEEE80211_SEQ_SEQ_SHIFT;

	adf_nbuf_put_tail(skb, sizeof(struct ieee80211_frame_bar));

	bf->bf_comp = ath_bar_tx_comp;
  9096de:	954f      	s32i.n	a5, a4, 60
	bf->bf_tidno = tid->tidno;
  9096e0:	8570      	l32i.n	a5, a7, 0
	bf->bf_node = &tid->an->ni;
	ath_dma_map(sc, bf);
  9096e2:	dac0      	mov.n	a10, a12
	bf->bf_seqno = tid->seq_start << IEEE80211_SEQ_SEQ_SHIFT;

	adf_nbuf_put_tail(skb, sizeof(struct ieee80211_frame_bar));

	bf->bf_comp = ath_bar_tx_comp;
	bf->bf_tidno = tid->tidno;
  9096e4:	25444d        	s8i	a5, a4, 77
	bf->bf_node = &tid->an->ni;
  9096e7:	857e      	l32i.n	a5, a7, 56
	ath_dma_map(sc, bf);
  9096e9:	db40      	mov.n	a11, a4

	adf_nbuf_put_tail(skb, sizeof(struct ieee80211_frame_bar));

	bf->bf_comp = ath_bar_tx_comp;
	bf->bf_tidno = tid->tidno;
	bf->bf_node = &tid->an->ni;
  9096eb:	254604        	s32i	a5, a4, 16
	ath_dma_map(sc, bf);
  9096ee:	5bff67        	call8	90948c <ath_dma_map$isra$8>
 * @param[out] sg   map info
 */
static inline void
adf_nbuf_dmamap_info(adf_os_dma_map_t bmap, adf_os_dmamap_info_t *sg)
{
    __adf_nbuf_dmamap_info(bmap, sg);
  9096f1:	8a40      	l32i.n	a10, a4, 0
  9096f3:	b44b      	addi.n	a11, a4, 4
  9096f5:	5be77d        	call8	9034ec <__adf_nbuf_dmamap_info>
	adf_nbuf_dmamap_info(bf->bf_dmamap, &bf->bf_dmamap_info);

	ds = bf->bf_desc;
	ah->ah_setupTxDesc(ds
  9096f8:	286217        	l32i	a8, a6, 92
 * @return The total length of this buf.
 */
static inline adf_os_size_t
adf_nbuf_len(adf_nbuf_t buf)
{
    return (__adf_nbuf_len(buf));
  9096fb:	da30      	mov.n	a10, a3
	bf->bf_tidno = tid->tidno;
	bf->bf_node = &tid->an->ni;
	ath_dma_map(sc, bf);
	adf_nbuf_dmamap_info(bf->bf_dmamap, &bf->bf_dmamap_info);

	ds = bf->bf_desc;
  9096fd:	854c      	l32i.n	a5, a4, 48
  9096ff:	281621        	s32i	a8, a1, 132
  909702:	5be7d8        	call8	903664 <__adf_nbuf_len>
	ah->ah_setupTxDesc(ds
  909705:	c191      	movi.n	a9, 17
  909707:	9912      	s32i.n	a9, a1, 8
  909709:	294049        	l8ui	a9, a4, 73
  90970c:	c030      	movi.n	a3, 0
  90970e:	c0fb      	movi.n	a15, 11
  909710:	281221        	l32i	a8, a1, 132
  909713:	9911      	s32i.n	a9, a1, 4
  909715:	b4ab      	addi.n	a11, a10, 4
  909717:	9314      	s32i.n	a3, a1, 16
  909719:	9313      	s32i.n	a3, a1, 12
  90971b:	9f10      	s32i.n	a15, a1, 0
  90971d:	c3ec      	movi.n	a14, 60
  90971f:	dd30      	mov.n	a13, a3
  909721:	dc30      	mov.n	a12, a3
  909723:	da50      	mov.n	a10, a5
  909725:	0b8000        	callx8	a8
			    , HAL_TXDESC_INTREQ
			    | HAL_TXDESC_CLRDMASK
			    , 0, 0);

	skbhead = bf->bf_skbhead;
	bf->bf_isaggr = 0;
  909728:	284087        	l8ui	a8, a4, 135
  90972b:	29fadf        	movi	a9, -33
  90972e:	098801        	and	a8, a8, a9
  909731:	284487        	s8i	a8, a4, 135
	bf->bf_next = NULL;
  909734:	934b      	s32i.n	a3, a4, 44

	for (ds0 = ds, i=0; i < bf->bf_dmamap_info.nsegs; ds0++, i++) {
  909736:	290a88        	movi	a9, 136
  909739:	600012        	j	90974f <ath_bar_tx+0x11f>
  90973c:	002862        	excw
		ah->ah_clr11nAggr(ds0);
  90973f:	14da50        	l32r	a4, 900080 <memset+0x1aee4>
  909742:	291621        	s32i	a9, a1, 132
  909745:	0b8000        	callx8	a8

	skbhead = bf->bf_skbhead;
	bf->bf_isaggr = 0;
	bf->bf_next = NULL;

	for (ds0 = ds, i=0; i < bf->bf_dmamap_info.nsegs; ds0++, i++) {
  909748:	291221        	l32i	a9, a1, 132
  90974b:	b133      	addi.n	a3, a3, 1
  90974d:	a955      	add.n	a5, a5, a9
  90974f:	8841      	l32i.n	a8, a4, 4
  909751:	7833e8        	bltu	a3, a8, 90973d <ath_bar_tx+0x10d>
		ah->ah_clr11nAggr(ds0);
	}

	ath_filltxdesc(sc, bf);
  909754:	231220        	l32i	a3, a1, 128
  909757:	db40      	mov.n	a11, a4
  909759:	8a3b      	l32i.n	a10, a3, 44

	for (i = 0 ; i < 4; i++) {
		series[i].Tries = ATH_TXMAXTRY;
		series[i].Rate = min_rate;
		series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
  90975b:	232d16        	addmi	a3, a2, 0x1600

	for (ds0 = ds, i=0; i < bf->bf_dmamap_info.nsegs; ds0++, i++) {
		ah->ah_clr11nAggr(ds0);
	}

	ath_filltxdesc(sc, bf);
  90975e:	5bfe8d        	call8	909194 <ath_filltxdesc$isra$9>

	for (i = 0 ; i < 4; i++) {
		series[i].Tries = ATH_TXMAXTRY;
		series[i].Rate = min_rate;
		series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
  909761:	283026        	l8ui	a8, a3, 38
	}

	ath_filltxdesc(sc, bf);

	for (i = 0 ; i < 4; i++) {
		series[i].Tries = ATH_TXMAXTRY;
  909764:	c07b      	movi.n	a7, 11
  909766:	231c20        	addi	a3, a1, 32
  909769:	250a04        	movi	a5, 4
  90976c:	9730      	s32i.n	a7, a3, 0
		series[i].Rate = min_rate;
  90976e:	9731      	s32i.n	a7, a3, 4
		series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
  909770:	9833      	s32i.n	a8, a3, 12
  909772:	233c14        	addi	a3, a3, 20
  909775:	b055      	addi.n	a5, a5, -1
  909777:	655ff1        	bnez	a5, 90976c <ath_bar_tx+0x13c>
	}

	ah->ah_set11nRateScenario(bf->bf_desc, 0, 0, series, 4, 4);
  90977a:	c0f4      	movi.n	a15, 4
  90977c:	c0c0      	movi.n	a12, 0
  90977e:	8a4c      	l32i.n	a10, a4, 48
  909780:	236210        	l32i	a3, a6, 64
  909783:	dbc0      	mov.n	a11, a12
  909785:	def0      	mov.n	a14, a15
  909787:	2d1c20        	addi	a13, a1, 32
  90978a:	0b3000        	callx8	a3
	ath_tgt_txq_add_ucast(sc, bf);
  90978d:	db40      	mov.n	a11, a4
  90978f:	da20      	mov.n	a10, a2
  909791:	5bfdfc        	call8	908f84 <ath_tgt_txq_add_ucast>
  909794:	d10f      	retw.n
	...

00909798 <owl_tgt_node_init>:
		ath_aggr_resume_tid(sc, tid);
	}
}

void owl_tgt_node_init(struct ath_node_target * an)
{
  909798:	6c1004        	entry	a1, 32
	struct ath_atx_tid *tid;
	int tidno;

	for (tidno = 0, tid = &an->tid[tidno]; tidno < WME_NUM_TID;tidno++, tid++) {
  90979b:	232c24        	addi	a3, a2, 36
  90979e:	240a00        	movi	a4, 0
		tid->tidno = tidno;
		tid->an = an;

		if ( tid->flag & TID_CLEANUP_INPROGRES ) {
			tid->flag |= TID_REINITIALIZE;
  9097a1:	250a04        	movi	a5, 4

	for (tidno = 0, tid = &an->tid[tidno]; tidno < WME_NUM_TID;tidno++, tid++) {
		tid->tidno = tidno;
		tid->an = an;

		if ( tid->flag & TID_CLEANUP_INPROGRES ) {
  9097a4:	283036        	l8ui	a8, a3, 54
{
	struct ath_atx_tid *tid;
	int tidno;

	for (tidno = 0, tid = &an->tid[tidno]; tidno < WME_NUM_TID;tidno++, tid++) {
		tid->tidno = tidno;
  9097a7:	9430      	s32i.n	a4, a3, 0
		tid->an = an;
  9097a9:	923e      	s32i.n	a2, a3, 56

		if ( tid->flag & TID_CLEANUP_INPROGRES ) {
  9097ab:	7f871d        	bbci	a8, 31, 9097cc <owl_tgt_node_init+0x34>
			tid->flag |= TID_REINITIALIZE;
  9097ae:	058802        	or	a8, a8, a5
  9097b1:	283436        	s8i	a8, a3, 54
			adf_os_print("tid[%p]->incomp is not 0: %d\n",
  9097b4:	18716e        	l32r	a8, 8e5d6c <memset+0xbd0>
  9097b7:	2c3037        	l8ui	a12, a3, 55
  9097ba:	288212        	l32i	a8, a8, 72
  9097bd:	1a72a9        	l32r	a10, 8e6264 <memset+0x10c8>
  9097c0:	00cc32        	sext	a12, a12, 7
  9097c3:	db30      	mov.n	a11, a3
  9097c5:	0b8000        	callx8	a8
  9097c8:	600005        	j	9097d1 <owl_tgt_node_init+0x39>
  9097cb:	00da30        	excw
				     tid, tid->incomp);
		} else {
			owl_tgt_tid_init(tid);
  9097ce:	5bfdda        	call8	908f38 <owl_tgt_tid_init>
void owl_tgt_node_init(struct ath_node_target * an)
{
	struct ath_atx_tid *tid;
	int tidno;

	for (tidno = 0, tid = &an->tid[tidno]; tidno < WME_NUM_TID;tidno++, tid++) {
  9097d1:	b144      	addi.n	a4, a4, 1
  9097d3:	233c3c        	addi	a3, a3, 60
  9097d6:	6948ca        	bnei	a4, 8, 9097a4 <owl_tgt_node_init+0xc>
				     tid, tid->incomp);
		} else {
			owl_tgt_tid_init(tid);
		}
	}
}
  9097d9:	d10f      	retw.n
	...

009097dc <ath_tx_status_clear>:

void ath_tx_status_clear(struct ath_softc_tgt *sc)
{
  9097dc:	6c1004        	entry	a1, 32
	int i;

	for (i = 0; i < 2; i++) {
		sc->tx_status[i].cnt = 0;
  9097df:	222d16        	addmi	a2, a2, 0x1600
  9097e2:	c080      	movi.n	a8, 0
  9097e4:	282438        	s8i	a8, a2, 56
  9097e7:	28245d        	s8i	a8, a2, 93
  9097ea:	d10f      	retw.n

009097ec <ath_tx_status_update>:

	return txs;
}

void ath_tx_status_update(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  9097ec:	6c1004        	entry	a1, 32
	struct ath_tx_desc *ds = bf->bf_lastds;
	WMI_TXSTATUS_EVENT *txs;

	if (sc->sc_tx_draining)
  9097ef:	242249        	l32i	a4, a2, 0x124
  9097f2:	157231        	l32r	a5, 8e60b8 <memset+0xf1c>
  9097f5:	054401        	and	a4, a4, a5
  9097f8:	6540b1        	bnez	a4, 9098ad <ath_tx_status_update+0xc1>
{
	WMI_TXSTATUS_EVENT *txs = NULL;
	int i;

	for (i = 0; i < 2; i++) {
		if (sc->tx_status[i].cnt < HTC_MAX_TX_STATUS) {
  9097fb:	282d16        	addmi	a8, a2, 0x1600
  9097fe:	298038        	l8ui	a9, a8, 56
  909801:	c05b      	movi.n	a5, 11
  909803:	795b0a        	bgeu	a5, a9, 909811 <ath_tx_status_update+0x25>
  909806:	24805d        	l8ui	a4, a8, 93
  909809:	745b02        	bgeu	a5, a4, 90980f <ath_tx_status_update+0x23>
  90980c:	60009d        	j	9098ad <ath_tx_status_update+0xc1>
static WMI_TXSTATUS_EVENT *ath_tx_status_get(struct ath_softc_tgt *sc)
{
	WMI_TXSTATUS_EVENT *txs = NULL;
	int i;

	for (i = 0; i < 2; i++) {
  90980f:	c041      	movi.n	a4, 1
		if (sc->tx_status[i].cnt < HTC_MAX_TX_STATUS) {
			txs = &sc->tx_status[i];
  909811:	0d4511        	slli	a5, a4, 3
  909814:	a459      	add.n	a9, a5, a4
  909816:	0e9911        	slli	a9, a9, 2
  909819:	a499      	add.n	a9, a9, a4
  90981b:	1b72aa        	l32r	a11, 8e62c4 <memset+0x1128>

	txs = ath_tx_status_get(sc);
	if (txs == NULL)
		return;

	txs->txstatus[txs->cnt].ts_flags = 0;
  90981e:	a928      	add.n	a8, a2, a9
  909820:	ab88      	add.n	a8, a8, a11
  909822:	2c8000        	l8ui	a12, a8, 0
	WMI_TXSTATUS_EVENT *txs = NULL;
	int i;

	for (i = 0; i < 2; i++) {
		if (sc->tx_status[i].cnt < HTC_MAX_TX_STATUS) {
			txs = &sc->tx_status[i];
  909825:	ab9d      	add.n	a13, a9, a11

	txs = ath_tx_status_get(sc);
	if (txs == NULL)
		return;

	txs->txstatus[txs->cnt].ts_flags = 0;
  909827:	0fc811        	slli	a8, a12, 1
  90982a:	ac8b      	add.n	a11, a8, a12
  90982c:	a9b9      	add.n	a9, a11, a9
  90982e:	1b72ab        	l32r	a11, 8e62dc <memset+0x1140>
  909831:	a929      	add.n	a9, a2, a9
  909833:	ab9b      	add.n	a11, a9, a11
  909835:	c0e0      	movi.n	a14, 0
	return txs;
}

void ath_tx_status_update(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_tx_desc *ds = bf->bf_lastds;
  909837:	8a3e      	l32i.n	a10, a3, 56

	txs = ath_tx_status_get(sc);
	if (txs == NULL)
		return;

	txs->txstatus[txs->cnt].ts_flags = 0;
  909839:	2eb400        	s8i	a14, a11, 0

	txs->txstatus[txs->cnt].cookie = bf->bf_cookie;
  90983c:	1e72ac        	l32r	a14, 8e62ec <memset+0x1150>
  90983f:	2f3092        	l8ui	a15, a3, 146
  909842:	ae9e      	add.n	a14, a9, a14
  909844:	2fe400        	s8i	a15, a14, 0
	txs->txstatus[txs->cnt].ts_rate = SM(bf->bf_endpt, ATH9K_HTC_TXSTAT_EPID);
  909847:	1e72ad        	l32r	a14, 8e62fc <memset+0x1160>

	if (ds->ds_txstat.ts_status & HAL_TXERR_FILT)
  90984a:	c0f2      	movi.n	a15, 2
		return;

	txs->txstatus[txs->cnt].ts_flags = 0;

	txs->txstatus[txs->cnt].cookie = bf->bf_cookie;
	txs->txstatus[txs->cnt].ts_rate = SM(bf->bf_endpt, ATH9K_HTC_TXSTAT_EPID);
  90984c:	0e9908        	add	a9, a9, a14
  90984f:	2e3223        	l32i	a14, a3, 140
	WMI_TXSTATUS_EVENT *txs = NULL;
	int i;

	for (i = 0; i < 2; i++) {
		if (sc->tx_status[i].cnt < HTC_MAX_TX_STATUS) {
			txs = &sc->tx_status[i];
  909852:	0d2d08        	add	a13, a2, a13
		return;

	txs->txstatus[txs->cnt].ts_flags = 0;

	txs->txstatus[txs->cnt].cookie = bf->bf_cookie;
	txs->txstatus[txs->cnt].ts_rate = SM(bf->bf_endpt, ATH9K_HTC_TXSTAT_EPID);
  909855:	0cee11        	slli	a14, a14, 4
  909858:	2e9400        	s8i	a14, a9, 0

	if (ds->ds_txstat.ts_status & HAL_TXERR_FILT)
  90985b:	2ea066        	l8ui	a14, a10, 102
  90985e:	7fe008        	bnone	a14, a15, 90986a <ath_tx_status_update+0x7e>
		txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_FILT;
  909861:	29b000        	l8ui	a9, a11, 0
  909864:	0f9902        	or	a9, a9, a15
  909867:	29b400        	s8i	a9, a11, 0

	if (!(ds->ds_txstat.ts_status & HAL_TXERR_XRETRY) &&
  90986a:	c197      	movi.n	a9, 23
  90986c:	79e81c        	bany	a14, a9, 90988c <ath_tx_status_update+0xa0>
	    !(ds->ds_txstat.ts_status & HAL_TXERR_FIFO) &&
	    !(ds->ds_txstat.ts_status & HAL_TXERR_TIMER_EXPIRED) &&
	    !(ds->ds_txstat.ts_status & HAL_TXERR_FILT))
		txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_ACK;
  90986f:	a459      	add.n	a9, a5, a4
  909871:	0e9911        	slli	a9, a9, 2
  909874:	a499      	add.n	a9, a9, a4
  909876:	ac88      	add.n	a8, a8, a12
  909878:	a988      	add.n	a8, a8, a9
  90987a:	1972ab        	l32r	a9, 8e6328 <memset+0x118c>
  90987d:	a828      	add.n	a8, a2, a8
  90987f:	a988      	add.n	a8, a8, a9
  909881:	298000        	l8ui	a9, a8, 0
  909884:	c0b1      	movi.n	a11, 1
  909886:	0b9902        	or	a9, a9, a11
  909889:	298400        	s8i	a9, a8, 0

	ath_tx_status_update_rate(sc, bf->bf_rcs, ds->ds_txstat.ts_rate, txs);
  90988c:	2ca068        	l8ui	a12, a10, 104

	txs->cnt++;
  90988f:	a455      	add.n	a5, a5, a4
	    !(ds->ds_txstat.ts_status & HAL_TXERR_FIFO) &&
	    !(ds->ds_txstat.ts_status & HAL_TXERR_TIMER_EXPIRED) &&
	    !(ds->ds_txstat.ts_status & HAL_TXERR_FILT))
		txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_ACK;

	ath_tx_status_update_rate(sc, bf->bf_rcs, ds->ds_txstat.ts_rate, txs);
  909891:	2b3c50        	addi	a11, a3, 80
  909894:	da20      	mov.n	a10, a2

	txs->cnt++;
  909896:	0e5511        	slli	a5, a5, 2
	    !(ds->ds_txstat.ts_status & HAL_TXERR_FIFO) &&
	    !(ds->ds_txstat.ts_status & HAL_TXERR_TIMER_EXPIRED) &&
	    !(ds->ds_txstat.ts_status & HAL_TXERR_FILT))
		txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_ACK;

	ath_tx_status_update_rate(sc, bf->bf_rcs, ds->ds_txstat.ts_rate, txs);
  909899:	5bfd2f        	call8	908d58 <ath_tx_status_update_rate>

	txs->cnt++;
  90989c:	a454      	add.n	a4, a5, a4
  90989e:	1372aa        	l32r	a3, 8e6348 <memset+0x11ac>
  9098a1:	a422      	add.n	a2, a2, a4
  9098a3:	a322      	add.n	a2, a2, a3
  9098a5:	232000        	l8ui	a3, a2, 0
  9098a8:	b133      	addi.n	a3, a3, 1
  9098aa:	232400        	s8i	a3, a2, 0
  9098ad:	d10f      	retw.n
	...

009098b0 <ath_tx_status_update_aggr>:
}

void ath_tx_status_update_aggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
			       struct ath_tx_desc *ds, struct ath_rc_series rcs[],
			       int txok)
{
  9098b0:	6c1004        	entry	a1, 32
  9098b3:	da30      	mov.n	a10, a3
	WMI_TXSTATUS_EVENT *txs;

	if (sc->sc_tx_draining)
  9098b5:	272249        	l32i	a7, a2, 0x124
  9098b8:	137231        	l32r	a3, 8e617c <memset+0xfe0>
}

void ath_tx_status_update_aggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
			       struct ath_tx_desc *ds, struct ath_rc_series rcs[],
			       int txok)
{
  9098bb:	db50      	mov.n	a11, a5
	WMI_TXSTATUS_EVENT *txs;

	if (sc->sc_tx_draining)
  9098bd:	037701        	and	a7, a7, a3
  9098c0:	65708a        	bnez	a7, 90994e <ath_tx_status_update_aggr+0x9e>
{
	WMI_TXSTATUS_EVENT *txs = NULL;
	int i;

	for (i = 0; i < 2; i++) {
		if (sc->tx_status[i].cnt < HTC_MAX_TX_STATUS) {
  9098c3:	282d16        	addmi	a8, a2, 0x1600
  9098c6:	298038        	l8ui	a9, a8, 56
  9098c9:	230a0b        	movi	a3, 11
  9098cc:	793b08        	bgeu	a3, a9, 9098d8 <ath_tx_status_update_aggr+0x28>
  9098cf:	27805d        	l8ui	a7, a8, 93
  9098d2:	773378        	bltu	a3, a7, 90994e <ath_tx_status_update_aggr+0x9e>
static WMI_TXSTATUS_EVENT *ath_tx_status_get(struct ath_softc_tgt *sc)
{
	WMI_TXSTATUS_EVENT *txs = NULL;
	int i;

	for (i = 0; i < 2; i++) {
  9098d5:	270a01        	movi	a7, 1

	txs = ath_tx_status_get(sc);
	if (txs == NULL)
		return;

	txs->txstatus[txs->cnt].cookie = bf->bf_cookie;
  9098d8:	0d7311        	slli	a3, a7, 3
  9098db:	a739      	add.n	a9, a3, a7
  9098dd:	0e9911        	slli	a9, a9, 2
  9098e0:	a799      	add.n	a9, a9, a7
  9098e2:	1c72aa        	l32r	a12, 8e638c <memset+0x11f0>
  9098e5:	a928      	add.n	a8, a2, a9
  9098e7:	ac88      	add.n	a8, a8, a12
  9098e9:	2c8000        	l8ui	a12, a8, 0
  9098ec:	0fc811        	slli	a8, a12, 1
  9098ef:	ac88      	add.n	a8, a8, a12
  9098f1:	a988      	add.n	a8, a8, a9
  9098f3:	1972ac        	l32r	a9, 8e63a4 <memset+0x1208>
  9098f6:	2ca092        	l8ui	a12, a10, 146
  9098f9:	a828      	add.n	a8, a2, a8
  9098fb:	a989      	add.n	a9, a8, a9
  9098fd:	2c9400        	s8i	a12, a9, 0
	txs->txstatus[txs->cnt].ts_rate = SM(bf->bf_endpt, ATH9K_HTC_TXSTAT_EPID);
  909900:	2aa223        	l32i	a10, a10, 140
  909903:	1972ad        	l32r	a9, 8e63b8 <memset+0x121c>
  909906:	0caa11        	slli	a10, a10, 4
  909909:	a989      	add.n	a9, a8, a9
  90990b:	2a9400        	s8i	a10, a9, 0

	if (txok)
  90990e:	c86e      	beqz.n	a6, 909920 <ath_tx_status_update_aggr+0x70>
		txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_ACK;
  909910:	1972ab        	l32r	a9, 8e63bc <memset+0x1220>
  909913:	a989      	add.n	a9, a8, a9
  909915:	269000        	l8ui	a6, a9, 0
  909918:	c081      	movi.n	a8, 1
  90991a:	086602        	or	a6, a6, a8
  90991d:	269400        	s8i	a6, a9, 0

	if (rcs)
  909920:	c9b4      	beqz.n	a11, 909938 <ath_tx_status_update_aggr+0x88>
	WMI_TXSTATUS_EVENT *txs = NULL;
	int i;

	for (i = 0; i < 2; i++) {
		if (sc->tx_status[i].cnt < HTC_MAX_TX_STATUS) {
			txs = &sc->tx_status[i];
  909922:	a73d      	add.n	a13, a3, a7
  909924:	0edd11        	slli	a13, a13, 2
  909927:	1672aa        	l32r	a6, 8e63d0 <memset+0x1234>
  90992a:	a7dd      	add.n	a13, a13, a7
  90992c:	a6dd      	add.n	a13, a13, a6

	if (txok)
		txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_ACK;

	if (rcs)
		ath_tx_status_update_rate(sc, rcs, ds->ds_txstat.ts_rate, txs);
  90992e:	2c4068        	l8ui	a12, a4, 104
  909931:	ad2d      	add.n	a13, a2, a13
  909933:	da20      	mov.n	a10, a2
  909935:	5bfd08        	call8	908d58 <ath_tx_status_update_rate>

	txs->cnt++;
  909938:	a738      	add.n	a8, a3, a7
  90993a:	0e8811        	slli	a8, a8, 2
  90993d:	a787      	add.n	a7, a8, a7
  90993f:	a722      	add.n	a2, a2, a7
  909941:	1772aa        	l32r	a7, 8e63ec <memset+0x1250>
  909944:	a722      	add.n	a2, a2, a7
  909946:	232000        	l8ui	a3, a2, 0
  909949:	b133      	addi.n	a3, a3, 1
  90994b:	232400        	s8i	a3, a2, 0
  90994e:	d10f      	retw.n

00909950 <ath_tx_status_send>:
}

void ath_tx_status_send(struct ath_softc_tgt *sc)
{
  909950:	6c1004        	entry	a1, 32
	int i;

	if (sc->sc_tx_draining)
  909953:	242249        	l32i	a4, a2, 0x124
  909956:	137231        	l32r	a3, 8e621c <memset+0x1080>
  909959:	034401        	and	a4, a4, a3
  90995c:	cf44      	bnez.n	a4, 909994 <ath_tx_status_send+0x44>
		return;

	for (i = 0; i < 2; i++) {
		if (sc->tx_status[i].cnt) {
  90995e:	232d16        	addmi	a3, a2, 0x1600
  909961:	283038        	l8ui	a8, a3, 56
  909964:	c980      	beqz.n	a8, 909978 <ath_tx_status_send+0x28>
			wmi_event(sc->tgt_wmi_handle, WMI_TXSTATUS_EVENTID,
  909966:	1c72aa        	l32r	a12, 8e6410 <memset+0x1274>
  909969:	1b72ae        	l32r	a11, 8e6424 <memset+0x1288>
  90996c:	8a23      	l32i.n	a10, a2, 12
  90996e:	c2d5      	movi.n	a13, 37
  909970:	ac2c      	add.n	a12, a2, a12
  909972:	5bf492        	call8	906bbc <wmi_event>
				  &sc->tx_status[i], sizeof(WMI_TXSTATUS_EVENT));
			/* FIXME: Handle failures. */
			sc->tx_status[i].cnt = 0;
  909975:	243438        	s8i	a4, a3, 56

	if (sc->sc_tx_draining)
		return;

	for (i = 0; i < 2; i++) {
		if (sc->tx_status[i].cnt) {
  909978:	24305d        	l8ui	a4, a3, 93
  90997b:	c945      	beqz.n	a4, 909994 <ath_tx_status_send+0x44>
			wmi_event(sc->tgt_wmi_handle, WMI_TXSTATUS_EVENTID,
  90997d:	1c72af        	l32r	a12, 8e643c <memset+0x12a0>
  909980:	8a23      	l32i.n	a10, a2, 12
  909982:	1b72ae        	l32r	a11, 8e643c <memset+0x12a0>
  909985:	0c2c08        	add	a12, a2, a12
  909988:	2d0a25        	movi	a13, 37
				  &sc->tx_status[i], sizeof(WMI_TXSTATUS_EVENT));
			/* FIXME: Handle failures. */
			sc->tx_status[i].cnt = 0;
  90998b:	220a00        	movi	a2, 0
	if (sc->sc_tx_draining)
		return;

	for (i = 0; i < 2; i++) {
		if (sc->tx_status[i].cnt) {
			wmi_event(sc->tgt_wmi_handle, WMI_TXSTATUS_EVENTID,
  90998e:	5bf48b        	call8	906bbc <wmi_event>
				  &sc->tx_status[i], sizeof(WMI_TXSTATUS_EVENT));
			/* FIXME: Handle failures. */
			sc->tx_status[i].cnt = 0;
  909991:	22345d        	s8i	a2, a3, 93
  909994:	d10f      	retw.n
	...

00909998 <ATH_SKB_2_WH>:
		}
	}
}

static struct ieee80211_frame* ATH_SKB2_WH(adf_nbuf_t skb)
{
  909998:	6c1006        	entry	a1, 48
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  90999b:	da20      	mov.n	a10, a2
  90999d:	dc10      	mov.n	a12, a1
  90999f:	b41b      	addi.n	a11, a1, 4
  9099a1:	5be738        	call8	903684 <__adf_nbuf_peek_header>
	a_uint8_t *anbdata;
	a_uint32_t anblen;

	adf_nbuf_peek_header(skb, &anbdata, &anblen);
	return((struct ieee80211_frame *)anbdata);
}
  9099a4:	8211      	l32i.n	a2, a1, 4
  9099a6:	d10f      	retw.n

009099a8 <ath_tx_set_retry$isra$12>:
		INCR(tid->seq_start, IEEE80211_SEQ_MAX);
		INCR(tid->baw_head, ATH_TID_MAX_BUFS);
	}
}

static void ath_tx_set_retry(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
  9099a8:	6c1004        	entry	a1, 32
{
	struct ieee80211_frame *wh;

	__stats(sc, txaggr_retries);
  9099ab:	8820      	l32i.n	a8, a2, 0

	bf->bf_isretried = 1;
	bf->bf_retries ++;
	wh = ATH_SKB_2_WH(bf->bf_skb);
  9099ad:	8a38      	l32i.n	a10, a3, 32

static void ath_tx_set_retry(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ieee80211_frame *wh;

	__stats(sc, txaggr_retries);
  9099af:	b188      	addi.n	a8, a8, 1
  9099b1:	9820      	s32i.n	a8, a2, 0

	bf->bf_isretried = 1;
  9099b3:	283087        	l8ui	a8, a3, 135
  9099b6:	c120      	movi.n	a2, 16
  9099b8:	028802        	or	a8, a8, a2
  9099bb:	283487        	s8i	a8, a3, 135
	bf->bf_retries ++;
  9099be:	283086        	l8ui	a8, a3, 134
	wh = ATH_SKB_2_WH(bf->bf_skb);
	wh->i_fc[1] |= IEEE80211_FC1_RETRY;
  9099c1:	c028      	movi.n	a2, 8
	struct ieee80211_frame *wh;

	__stats(sc, txaggr_retries);

	bf->bf_isretried = 1;
	bf->bf_retries ++;
  9099c3:	288c01        	addi	a8, a8, 1
  9099c6:	283486        	s8i	a8, a3, 134
	wh = ATH_SKB_2_WH(bf->bf_skb);
  9099c9:	5bfff3        	call8	909998 <ATH_SKB_2_WH>
	wh->i_fc[1] |= IEEE80211_FC1_RETRY;
  9099cc:	23a001        	l8ui	a3, a10, 1
  9099cf:	023302        	or	a3, a3, a2
  9099d2:	23a401        	s8i	a3, a10, 1
  9099d5:	d10f      	retw.n
	...

009099d8 <ath_tx_retry_subframe$isra$14>:
	ath_update_aggr_stats(sc, ds, nframes, nbad);
	ath_rate_tx_complete(sc, an, ds, rcs, nframes, nbad);
}

static void
ath_tx_retry_subframe(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
  9099d8:	6c1006        	entry	a1, 48
{

	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
	struct ath_tx_desc *ds = NULL;
	struct ath_hal *ah = sc->sc_ah;
  9099db:	262d05        	addmi	a6, a2, 0x500
  9099de:	876b      	l32i.n	a7, a6, 44
	int i = 0;

	__stats(sc, txaggr_compretries);
  9099e0:	262263        	l32i	a6, a2, 0x18c
static void
ath_tx_retry_subframe(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
		      ath_tx_bufhead *bf_q, struct ath_tx_buf **bar)
{

	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
  9099e3:	8d34      	l32i.n	a13, a3, 16
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
	struct ath_tx_desc *ds = NULL;
	struct ath_hal *ah = sc->sc_ah;
	int i = 0;

	__stats(sc, txaggr_compretries);
  9099e5:	b166      	addi.n	a6, a6, 1
ath_tx_retry_subframe(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
		      ath_tx_bufhead *bf_q, struct ath_tx_buf **bar)
{

	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  9099e7:	2c304d        	l8ui	a12, a3, 77
	struct ath_hal *ah = sc->sc_ah;
	int i = 0;

	__stats(sc, txaggr_compretries);

	for(ds = bf->bf_desc, i = 0; i < bf->bf_dmamap_info.nsegs; ds++, i++) {
  9099ea:	c080      	movi.n	a8, 0
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
	struct ath_tx_desc *ds = NULL;
	struct ath_hal *ah = sc->sc_ah;
	int i = 0;

	__stats(sc, txaggr_compretries);
  9099ec:	262663        	s32i	a6, a2, 0x18c

	for(ds = bf->bf_desc, i = 0; i < bf->bf_dmamap_info.nsegs; ds++, i++) {
  9099ef:	2e0a88        	movi	a14, 136
  9099f2:	863c      	l32i.n	a6, a3, 48
  9099f4:	600032        	j	909a2a <ath_tx_retry_subframe$isra$14+0x52>
  9099f7:	002972        	excw
		ah->ah_clr11nAggr(ds);
  9099fa:	14da60        	l32r	a4, 90037c <memset+0x1b1e0>
  9099fd:	9812      	s32i.n	a8, a1, 8
  9099ff:	9c11      	s32i.n	a12, a1, 4
  909a01:	9d10      	s32i.n	a13, a1, 0
  909a03:	9e13      	s32i.n	a14, a1, 12
  909a05:	0b9000        	callx8	a9
		ah->ah_set11nBurstDuration(ds, 0);
  909a08:	297215        	l32i	a9, a7, 84
  909a0b:	066a02        	or	a10, a6, a6
  909a0e:	2b0a00        	movi	a11, 0
  909a11:	0b9000        	callx8	a9
		ah->ah_set11nVirtualMoreFrag(ds, 0);
  909a14:	297216        	l32i	a9, a7, 88
  909a17:	da60      	mov.n	a10, a6
  909a19:	c0b0      	movi.n	a11, 0
  909a1b:	0b9000        	callx8	a9
	struct ath_hal *ah = sc->sc_ah;
	int i = 0;

	__stats(sc, txaggr_compretries);

	for(ds = bf->bf_desc, i = 0; i < bf->bf_dmamap_info.nsegs; ds++, i++) {
  909a1e:	8e13      	l32i.n	a14, a1, 12
  909a20:	8812      	l32i.n	a8, a1, 8
  909a22:	8d10      	l32i.n	a13, a1, 0
  909a24:	8c11      	l32i.n	a12, a1, 4
  909a26:	ae66      	add.n	a6, a6, a14
  909a28:	b188      	addi.n	a8, a8, 1
  909a2a:	8931      	l32i.n	a9, a3, 4
  909a2c:	7983c8        	bltu	a8, a9, 9099f8 <ath_tx_retry_subframe$isra$14+0x20>
		ah->ah_clr11nAggr(ds);
		ah->ah_set11nBurstDuration(ds, 0);
		ah->ah_set11nVirtualMoreFrag(ds, 0);
	}

	if (bf->bf_retries >= OWLMAX_RETRIES) {
  909a2f:	263086        	l8ui	a6, a3, 134
  909a32:	c089      	movi.n	a8, 9
  909a34:	768b3e        	bgeu	a8, a6, 909a76 <ath_tx_retry_subframe$isra$14+0x9e>
ath_tx_retry_subframe(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
		      ath_tx_bufhead *bf_q, struct ath_tx_buf **bar)
{

	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  909a37:	0cca11        	slli	a10, a12, 4
		ah->ah_set11nBurstDuration(ds, 0);
		ah->ah_set11nVirtualMoreFrag(ds, 0);
	}

	if (bf->bf_retries >= OWLMAX_RETRIES) {
		__stats(sc, txaggr_xretries);
  909a3a:	242274        	l32i	a4, a2, 0x1d0
ath_tx_retry_subframe(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
		      ath_tx_bufhead *bf_q, struct ath_tx_buf **bar)
{

	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  909a3d:	0caa0c        	sub	a10, a10, a12
		ah->ah_set11nVirtualMoreFrag(ds, 0);
	}

	if (bf->bf_retries >= OWLMAX_RETRIES) {
		__stats(sc, txaggr_xretries);
		ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  909a40:	2b3123        	l16ui	a11, a3, 70
ath_tx_retry_subframe(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
		      ath_tx_bufhead *bf_q, struct ath_tx_buf **bar)
{

	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  909a43:	0eaa11        	slli	a10, a10, 2
		ah->ah_set11nBurstDuration(ds, 0);
		ah->ah_set11nVirtualMoreFrag(ds, 0);
	}

	if (bf->bf_retries >= OWLMAX_RETRIES) {
		__stats(sc, txaggr_xretries);
  909a46:	b144      	addi.n	a4, a4, 1
ath_tx_retry_subframe(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
		      ath_tx_bufhead *bf_q, struct ath_tx_buf **bar)
{

	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  909a48:	2aac24        	addi	a10, a10, 36
		ah->ah_set11nVirtualMoreFrag(ds, 0);
	}

	if (bf->bf_retries >= OWLMAX_RETRIES) {
		__stats(sc, txaggr_xretries);
		ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  909a4b:	aada      	add.n	a10, a13, a10
		ah->ah_set11nBurstDuration(ds, 0);
		ah->ah_set11nVirtualMoreFrag(ds, 0);
	}

	if (bf->bf_retries >= OWLMAX_RETRIES) {
		__stats(sc, txaggr_xretries);
  909a4d:	242674        	s32i	a4, a2, 0x1d0
		ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  909a50:	0b4b14        	srli	a11, a11, 4
  909a53:	5bfd6a        	call8	908ffc <ath_tx_update_baw>
		ath_tx_status_update_aggr(sc, bf, bf->bf_lastds, NULL, 0);
  909a56:	c0e0      	movi.n	a14, 0
  909a58:	8c3e      	l32i.n	a12, a3, 56
  909a5a:	dde0      	mov.n	a13, a14
  909a5c:	db30      	mov.n	a11, a3
  909a5e:	022a02        	or	a10, a2, a2
  909a61:	5bff93        	call8	9098b0 <ath_tx_status_update_aggr>

		if (!*bar)
  909a64:	8450      	l32i.n	a4, a5, 0
  909a66:	cc43      	bnez.n	a4, 909a6d <ath_tx_retry_subframe$isra$14+0x95>
			*bar = bf;
  909a68:	9350      	s32i.n	a3, a5, 0
  909a6a:	d10f      	retw.n
  909a6c:	00db30        	excw
		else
			ath_tx_freebuf(sc, bf);
  909a6f:	da20      	mov.n	a10, a2
  909a71:	5bfece        	call8	9095ac <ath_tx_freebuf>
  909a74:	d10f      	retw.n
		return;
	}

	if (!bf->bf_next) {
  909a76:	853b      	l32i.n	a5, a3, 44
  909a78:	cd55      	bnez.n	a5, 909a91 <ath_tx_retry_subframe$isra$14+0xb9>
		__stats(sc, txaggr_errlast);
  909a7a:	252267        	l32i	a5, a2, 0x19c
		bf = ath_buf_toggle(sc, bf, 1);
  909a7d:	db30      	mov.n	a11, a3
			ath_tx_freebuf(sc, bf);
		return;
	}

	if (!bf->bf_next) {
		__stats(sc, txaggr_errlast);
  909a7f:	b155      	addi.n	a5, a5, 1
  909a81:	252667        	s32i	a5, a2, 0x19c
		bf = ath_buf_toggle(sc, bf, 1);
  909a84:	c0c1      	movi.n	a12, 1
  909a86:	022a02        	or	a10, a2, a2
  909a89:	5bfe86        	call8	9094a4 <ath_buf_toggle>
  909a8c:	d3a0      	mov.n	a3, a10
  909a8e:	600012        	j	909aa4 <ath_tx_retry_subframe$isra$14+0xcc>
	} else
		bf->bf_lastds = &(bf->bf_descarr[bf->bf_dmamap_info.nsegs - 1]);
  909a91:	0c9811        	slli	a8, a9, 4
  909a94:	a988      	add.n	a8, a8, a9
  909a96:	0d8811        	slli	a8, a8, 3
  909a99:	25fa78        	movi	a5, -136
  909a9c:	863d      	l32i.n	a6, a3, 52
  909a9e:	a588      	add.n	a8, a8, a5
  909aa0:	a868      	add.n	a8, a6, a8
  909aa2:	983e      	s32i.n	a8, a3, 56

	ath_tx_set_retry(sc, bf);
  909aa4:	2a1a80        	movi	a10, 0x180
  909aa7:	db30      	mov.n	a11, a3
  909aa9:	aa2a      	add.n	a10, a2, a10
	asf_tailq_insert_tail(bf_q, bf, bf_list);
  909aab:	c020      	movi.n	a2, 0
		__stats(sc, txaggr_errlast);
		bf = ath_buf_toggle(sc, bf, 1);
	} else
		bf->bf_lastds = &(bf->bf_descarr[bf->bf_dmamap_info.nsegs - 1]);

	ath_tx_set_retry(sc, bf);
  909aad:	5bffbe        	call8	9099a8 <ath_tx_set_retry$isra$12>
	asf_tailq_insert_tail(bf_q, bf, bf_list);
  909ab0:	9239      	s32i.n	a2, a3, 36
  909ab2:	8240      	l32i.n	a2, a4, 0
  909ab4:	923a      	s32i.n	a2, a3, 40
  909ab6:	9320      	s32i.n	a3, a2, 0
  909ab8:	233c24        	addi	a3, a3, 36
  909abb:	9340      	s32i.n	a3, a4, 0
  909abd:	d10f      	retw.n
	...

00909ac0 <ath_tx_comp_aggr_error>:
}

static void
ath_tx_comp_aggr_error(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
		       ath_atx_tid_t *tid)
{
  909ac0:	6c1020        	entry	a1, 0x100


	struct ath_tx_desc lastds;
	struct ath_tx_desc *ds = &lastds;
	struct ath_rc_series rcs[4];
	struct ath_tx_buf *bar = NULL;
  909ac3:	c050      	movi.n	a5, 0
  909ac5:	251630        	s32i	a5, a1, 192
	struct ath_tx_buf *bf_next;
	int nframes = bf->bf_nframes;
	ath_tx_bufhead bf_q;
	struct ath_txq *txq;

	asf_tailq_init(&bf_q);
  909ac8:	25162e        	s32i	a5, a1, 184
 * @param[in] size    buffer size
 */
static inline void
adf_os_mem_copy(void *dst, const void *src, adf_os_size_t size)
{
    __adf_os_mem_copy(dst, src, size);
  909acb:	8b3e      	l32i.n	a11, a3, 56
  909acd:	250ab8        	movi	a5, 184
  909ad0:	051508        	add	a5, a1, a5
  909ad3:	2c0a88        	movi	a12, 136
  909ad6:	011a02        	or	a10, a1, a1
  909ad9:	25162f        	s32i	a5, a1, 188
	struct ath_tx_desc lastds;
	struct ath_tx_desc *ds = &lastds;
	struct ath_rc_series rcs[4];
	struct ath_tx_buf *bar = NULL;
	struct ath_tx_buf *bf_next;
	int nframes = bf->bf_nframes;
  909adc:	26304c        	l8ui	a6, a3, 76
	ath_tx_bufhead bf_q;
	struct ath_txq *txq;

	asf_tailq_init(&bf_q);
	txq = bf->bf_txq;
  909adf:	273220        	l32i	a7, a3, 128
  909ae2:	5bfcfc        	call8	908ed4 <__adf_os_mem_copy>
  909ae5:	2a0a88        	movi	a10, 136
  909ae8:	2c0a30        	movi	a12, 48
  909aeb:	2b3c50        	addi	a11, a3, 80
  909aee:	0a1a08        	add	a10, a1, a10
  909af1:	5bfcf8        	call8	908ed4 <__adf_os_mem_copy>
	adf_os_mem_copy(ds, bf->bf_lastds, sizeof (struct ath_tx_desc));
	adf_os_mem_copy(rcs, bf->bf_rcs, sizeof(rcs));

	while (bf) {
		bf_next = bf->bf_next;
		ath_tx_retry_subframe(sc, bf, &bf_q, &bar);
  909af4:	b455      	addi.n	a5, a5, 4

	adf_os_mem_copy(ds, bf->bf_lastds, sizeof (struct ath_tx_desc));
	adf_os_mem_copy(rcs, bf->bf_rcs, sizeof(rcs));

	while (bf) {
		bf_next = bf->bf_next;
  909af6:	883b      	l32i.n	a8, a3, 44
		ath_tx_retry_subframe(sc, bf, &bf_q, &bar);
  909af8:	2d0ac0        	movi	a13, 192
  909afb:	db30      	mov.n	a11, a3
  909afd:	a1dd      	add.n	a13, a13, a1
  909aff:	dc50      	mov.n	a12, a5
  909b01:	da20      	mov.n	a10, a2
  909b03:	281634        	s32i	a8, a1, 208
  909b06:	5bffb4        	call8	9099d8 <ath_tx_retry_subframe$isra$14>
  909b09:	281234        	l32i	a8, a1, 208
  909b0c:	088302        	or	a3, a8, a8
	txq = bf->bf_txq;

	adf_os_mem_copy(ds, bf->bf_lastds, sizeof (struct ath_tx_desc));
	adf_os_mem_copy(rcs, bf->bf_rcs, sizeof(rcs));

	while (bf) {
  909b0f:	658fe3        	bnez	a8, 909af6 <ath_tx_comp_aggr_error+0x36>
		bf_next = bf->bf_next;
		ath_tx_retry_subframe(sc, bf, &bf_q, &bar);
		bf = bf_next;
	}

	ath_update_aggr_stats(sc, ds, nframes, nframes);
  909b12:	2e1071        	l8ui	a14, a1, 113
  909b15:	2d1070        	l8ui	a13, a1, 112
  909b18:	2c1067        	l8ui	a12, a1, 103
  909b1b:	2b1066        	l8ui	a11, a1, 102
  909b1e:	022a02        	or	a10, a2, a2
  909b21:	5bfd6f        	call8	9090e0 <ath_update_aggr_stats$isra$5>
	ath_rate_tx_complete(sc, tid->an, ds, rcs, nframes, nframes);
  909b24:	2d0a88        	movi	a13, 136
  909b27:	8b4e      	l32i.n	a11, a4, 56
  909b29:	dc10      	mov.n	a12, a1
  909b2b:	df60      	mov.n	a15, a6
  909b2d:	de60      	mov.n	a14, a6
  909b2f:	0d1d08        	add	a13, a1, a13
  909b32:	022a02        	or	a10, a2, a2
  909b35:	5bfcc7        	call8	908e54 <ath_rate_tx_complete>

	if (bar) {
  909b38:	2c1230        	l32i	a12, a1, 192
  909b3b:	c8c5      	beqz.n	a12, 909b44 <ath_tx_comp_aggr_error+0x84>
		ath_bar_tx(sc, tid, bar);
  909b3d:	db40      	mov.n	a11, a4
  909b3f:	da20      	mov.n	a10, a2
  909b41:	5bfebb        	call8	909630 <ath_bar_tx>
	}

	if (!asf_tailq_empty(&bf_q)) {
  909b44:	23122e        	l32i	a3, a1, 184
  909b47:	ca3a      	beqz.n	a3, 909b75 <ath_tx_comp_aggr_error+0xb5>
		__stats(sc, txaggr_prepends);
  909b49:	232264        	l32i	a3, a2, 0x190
  909b4c:	b133      	addi.n	a3, a3, 1
  909b4e:	232664        	s32i	a3, a2, 0x190
		TAILQ_INSERTQ_HEAD(&tid->buf_q, &bf_q, bf_list);
  909b51:	834b      	l32i.n	a3, a4, 44
  909b53:	22122f        	l32i	a2, a1, 188
  909b56:	c837      	beqz.n	a3, 909b61 <ath_tx_comp_aggr_error+0xa1>
  909b58:	9320      	s32i.n	a3, a2, 0
  909b5a:	834b      	l32i.n	a3, a4, 44
  909b5c:	923a      	s32i.n	a2, a3, 40
  909b5e:	600001        	j	909b63 <ath_tx_comp_aggr_error+0xa3>
  909b61:	924c      	s32i.n	a2, a4, 48
  909b63:	22122e        	l32i	a2, a1, 184
  909b66:	234c2c        	addi	a3, a4, 44
  909b69:	924b      	s32i.n	a2, a4, 44
  909b6b:	932a      	s32i.n	a3, a2, 40
		ath_tgt_tx_enqueue(txq, tid);
  909b6d:	db40      	mov.n	a11, a4
  909b6f:	2a7c1c        	addi	a10, a7, 28
  909b72:	5bfd52        	call8	9090bc <ath_tgt_tx_enqueue$isra$3>
  909b75:	d10f      	retw.n
	...

00909b78 <ath_tgt_tid_drain>:
	return((struct ieee80211_frame *)anbdata);
}

void
ath_tgt_tid_drain(struct ath_softc_tgt *sc, struct ath_atx_tid *tid)
{
  909b78:	6c1004        	entry	a1, 32
	struct ath_tx_buf *bf;

	while (!asf_tailq_empty(&tid->buf_q)) {
  909b7b:	600015        	j	909b94 <ath_tgt_tid_drain+0x1c>
		TAILQ_DEQ(&tid->buf_q, bf, bf_list);
  909b7e:	88b9      	l32i.n	a8, a11, 36
  909b80:	89ba      	l32i.n	a9, a11, 40
  909b82:	c883      	beqz.n	a8, 909b89 <ath_tgt_tid_drain+0x11>
  909b84:	998a      	s32i.n	a9, a8, 40
  909b86:	600001        	j	909b8b <ath_tgt_tid_drain+0x13>
  909b89:	993c      	s32i.n	a9, a3, 48
  909b8b:	89ba      	l32i.n	a9, a11, 40
		ath_tx_freebuf(sc, bf);
  909b8d:	da20      	mov.n	a10, a2
ath_tgt_tid_drain(struct ath_softc_tgt *sc, struct ath_atx_tid *tid)
{
	struct ath_tx_buf *bf;

	while (!asf_tailq_empty(&tid->buf_q)) {
		TAILQ_DEQ(&tid->buf_q, bf, bf_list);
  909b8f:	9890      	s32i.n	a8, a9, 0
		ath_tx_freebuf(sc, bf);
  909b91:	5bfe86        	call8	9095ac <ath_tx_freebuf>
void
ath_tgt_tid_drain(struct ath_softc_tgt *sc, struct ath_atx_tid *tid)
{
	struct ath_tx_buf *bf;

	while (!asf_tailq_empty(&tid->buf_q)) {
  909b94:	8b3b      	l32i.n	a11, a3, 44
  909b96:	65bfe4        	bnez	a11, 909b7e <ath_tgt_tid_drain+0x6>
		TAILQ_DEQ(&tid->buf_q, bf, bf_list);
		ath_tx_freebuf(sc, bf);
	}

	tid->seq_next = tid->seq_start;
  909b99:	283102        	l16ui	a8, a3, 4
  909b9c:	283503        	s16i	a8, a3, 6
	tid->baw_tail = tid->baw_head;
  909b9f:	8833      	l32i.n	a8, a3, 12
  909ba1:	9834      	s32i.n	a8, a3, 16
  909ba3:	d10f      	retw.n
  909ba5:	000000        	ill

00909ba8 <ath_tgt_tx_prepare>:
	return  bf;
}

struct ath_tx_buf* ath_tgt_tx_prepare(struct ath_softc_tgt *sc,
				   adf_nbuf_t skb, ath_data_hdr_t *dh)
{
  909ba8:	6c1006        	entry	a1, 48
  909bab:	d520      	mov.n	a5, a2
	struct ath_tx_buf *bf;
	struct ieee80211_node_target *ni;
	struct ath_atx_tid *tid;

	ni = ath_tgt_find_node(sc, dh->ni_index);
  909bad:	224001        	l8ui	a2, a4, 1
							a_int32_t node_index)
{
	struct ath_node_target *an;
	struct ieee80211_node_target *ni;

	if (node_index > TARGET_NODE_MAX)
  909bb0:	c068      	movi.n	a6, 8
  909bb2:	726a02        	bge	a6, a2, 909bb8 <ath_tgt_tx_prepare+0x10>
  909bb5:	600245        	j	909dfe <ath_tgt_tx_prepare+0x256>
	  	return NULL;

	an = &sc->sc_sta[node_index];
	ni = &an->ni;
  909bb8:	0a2811        	slli	a8, a2, 6
  909bbb:	a288      	add.n	a8, a8, a2
  909bbd:	0f8811        	slli	a8, a8, 1
  909bc0:	a288      	add.n	a8, a8, a2
  909bc2:	0e8811        	slli	a8, a8, 2
  909bc5:	265a38        	movi	a6, 0x538
  909bc8:	a686      	add.n	a6, a8, a6

	if (an->an_valid) {
  909bca:	227a3c        	movi	a2, 0x73c
  909bcd:	a858      	add.n	a8, a5, a8
  909bcf:	a282      	add.n	a2, a8, a2
  909bd1:	222000        	l8ui	a2, a2, 0

	if (node_index > TARGET_NODE_MAX)
	  	return NULL;

	an = &sc->sc_sta[node_index];
	ni = &an->ni;
  909bd4:	a656      	add.n	a6, a5, a6

	if (an->an_valid) {
  909bd6:	002232        	sext	a2, a2, 7
  909bd9:	642223        	beqz	a2, 909e00 <ath_tgt_tx_prepare+0x258>
		if (ni->ni_vap == NULL) {
  909bdc:	225a58        	movi	a2, 0x558
  909bdf:	a288      	add.n	a8, a8, a2
  909be1:	8280      	l32i.n	a2, a8, 0
  909be3:	c071      	movi.n	a7, 1
  909be5:	c080      	movi.n	a8, 0
  909be7:	027838        	moveqz	a8, a7, a2
	struct ath_tx_buf *bf;
	struct ieee80211_node_target *ni;
	struct ath_atx_tid *tid;

	ni = ath_tgt_find_node(sc, dh->ni_index);
	if (ni == NULL)
  909bea:	080247        	extui	a2, a8, 0, 8
  909bed:	65220d        	bnez	a2, 909dfe <ath_tgt_tx_prepare+0x256>
  909bf0:	067238        	moveqz	a2, a7, a6
  909bf3:	652207        	bnez	a2, 909dfe <ath_tgt_tx_prepare+0x256>
		return NULL;

	tid = ATH_AN_2_TID(ATH_NODE_TARGET(ni), dh->tidno);
  909bf6:	284003        	l8ui	a8, a4, 3
	if (tid->flag & TID_REINITIALIZE) {
  909bf9:	0c8711        	slli	a7, a8, 4
  909bfc:	08770c        	sub	a7, a7, a8
  909bff:	0e7711        	slli	a7, a7, 2
  909c02:	a767      	add.n	a7, a6, a7
  909c04:	27705a        	l8ui	a7, a7, 90
  909c07:	7d770d        	bbci	a7, 29, 909c18 <ath_tgt_tx_prepare+0x70>
		adf_os_print("drop frame due to TID reinit\n");
  909c0a:	13716e        	l32r	a3, 8e61c4 <memset+0x1028>
  909c0d:	1a72b0        	l32r	a10, 8e66d0 <memset+0x1534>
  909c10:	233212        	l32i	a3, a3, 72
  909c13:	0b3000        	callx8	a3
		return NULL;
  909c16:	d10f      	retw.n

static struct ath_tx_buf* ath_tx_buf_alloc(struct ath_softc_tgt *sc)
{
	struct ath_tx_buf *bf = NULL;

	bf = asf_tailq_first(&sc->sc_txbuf);
  909c18:	2252f0        	l32i	a2, a5, 0x3c0
	if (bf !=  NULL) {
  909c1b:	ca29      	beqz.n	a2, 909c48 <ath_tgt_tx_prepare+0xa0>
 * @param[in] size  buffer size
 */
static inline void
adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
{
    __adf_os_mem_set(buf, b, size);
  909c1d:	c4bc      	movi.n	a11, 76
  909c1f:	2a2c3c        	addi	a10, a2, 60
  909c22:	5bfd98        	call8	909284 <__adf_os_mem_set$constprop$19>
		adf_os_mem_set(&bf->bf_state, 0, sizeof(struct ath_buf_state));
		asf_tailq_remove(&sc->sc_txbuf, bf, bf_list);
  909c25:	8729      	l32i.n	a7, a2, 36
  909c27:	882a      	l32i.n	a8, a2, 40
  909c29:	c873      	beqz.n	a7, 909c30 <ath_tgt_tx_prepare+0x88>
  909c2b:	987a      	s32i.n	a8, a7, 40
  909c2d:	600002        	j	909c33 <ath_tgt_tx_prepare+0x8b>
  909c30:	2856f1        	s32i	a8, a5, 0x3c4
  909c33:	882a      	l32i.n	a8, a2, 40
  909c35:	9780      	s32i.n	a7, a8, 0
	if (!bf) {
		__stats(sc, tx_nobufs);
		return NULL;
	}

	bf->bf_tidno = dh->tidno;
  909c37:	274003        	l8ui	a7, a4, 3
  909c3a:	27244d        	s8i	a7, a2, 77
	bf->bf_txq = TID_TO_ACTXQ(bf->bf_tidno);
  909c3d:	c871      	beqz.n	a7, 909c42 <ath_tgt_tx_prepare+0x9a>
  909c3f:	69730b        	bnei	a7, 3, 909c4e <ath_tgt_tx_prepare+0xa6>
  909c42:	c080      	movi.n	a8, 0
  909c44:	60001d        	j	909c65 <ath_tgt_tx_prepare+0xbd>
  909c47:	0063ff        	excw
  909c4a:	fc          	.byte 0xfc
  909c4b:	000000        	ill
  909c4e:	b079      	addi.n	a9, a7, -1
  909c50:	090947        	extui	a9, a9, 0, 8
  909c53:	c081      	movi.n	a8, 1
  909c55:	6e920c        	bltui	a9, 2, 909c65 <ath_tgt_tx_prepare+0xbd>
  909c58:	277cfc        	addi	a7, a7, -4
  909c5b:	070747        	extui	a7, a7, 0, 8
  909c5e:	c083      	movi.n	a8, 3
  909c60:	6f7201        	bgeui	a7, 2, 909c65 <ath_tgt_tx_prepare+0xbd>
  909c63:	c082      	movi.n	a8, 2
  909c65:	0e8811        	slli	a8, a8, 2
  909c68:	288d05        	addmi	a8, a8, 0x500
  909c6b:	a858      	add.n	a8, a5, a8
  909c6d:	8783      	l32i.n	a7, a8, 12
 * @param[in] buf   buf
 */
static inline void
adf_nbuf_queue_add(adf_nbuf_queue_t *head, adf_nbuf_t buf)
{
    __adf_nbuf_queue_add(head, buf);
  909c6f:	db30      	mov.n	a11, a3
  909c71:	272620        	s32i	a7, a2, 128
	bf->bf_keytype = dh->keytype;
  909c74:	274008        	l8ui	a7, a4, 8
  909c77:	272485        	s8i	a7, a2, 133
	bf->bf_keyix = dh->keyix;
  909c7a:	274009        	l8ui	a7, a4, 9
  909c7d:	272449        	s8i	a7, a2, 73
	bf->bf_protmode = dh->flags & (IEEE80211_PROT_RTSCTS | IEEE80211_PROT_CTSONLY);
  909c80:	274007        	l8ui	a7, a4, 7
	bf->bf_node = ni;
  909c83:	9624      	s32i.n	a6, a2, 16

	bf->bf_tidno = dh->tidno;
	bf->bf_txq = TID_TO_ACTXQ(bf->bf_tidno);
	bf->bf_keytype = dh->keytype;
	bf->bf_keyix = dh->keyix;
	bf->bf_protmode = dh->flags & (IEEE80211_PROT_RTSCTS | IEEE80211_PROT_CTSONLY);
  909c85:	070741        	extui	a7, a7, 0, 2
	bf->bf_node = ni;

	adf_nbuf_queue_add(&bf->bf_skbhead, skb);
  909c88:	262c14        	addi	a6, a2, 20
  909c8b:	066a02        	or	a10, a6, a6

	bf->bf_tidno = dh->tidno;
	bf->bf_txq = TID_TO_ACTXQ(bf->bf_tidno);
	bf->bf_keytype = dh->keytype;
	bf->bf_keyix = dh->keyix;
	bf->bf_protmode = dh->flags & (IEEE80211_PROT_RTSCTS | IEEE80211_PROT_CTSONLY);
  909c8e:	272484        	s8i	a7, a2, 132
  909c91:	5be5f5        	call8	903468 <__adf_nbuf_queue_add>
 * @return first buffer in queue
 */
static inline adf_nbuf_t 
adf_nbuf_queue_first(adf_nbuf_queue_t *head)
{
    return (__adf_nbuf_queue_first(head));
  909c94:	da60      	mov.n	a10, a6
  909c96:	5be687        	call8	9036b4 <__adf_nbuf_queue_first>
  909c99:	d3a0      	mov.n	a3, a10
 * @return length of the queue
 */
static inline a_uint32_t
adf_nbuf_queue_len(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_len(head);
  909c9b:	da60      	mov.n	a10, a6
  909c9d:	5be683        	call8	9036ac <__adf_nbuf_queue_len>
	bf->bf_node = ni;

	adf_nbuf_queue_add(&bf->bf_skbhead, skb);
	skb = adf_nbuf_queue_first(&(bf->bf_skbhead));

	if (adf_nbuf_queue_len(&(bf->bf_skbhead)) == 0) {
  909ca0:	cca9      	bnez.n	a10, 909cad <ath_tgt_tx_prepare+0x105>
		__stats(sc, tx_noskbs);
  909ca2:	225276        	l32i	a2, a5, 0x1d8
  909ca5:	b122      	addi.n	a2, a2, 1
  909ca7:	225676        	s32i	a2, a5, 0x1d8
  909caa:	600150        	j	909dfe <ath_tgt_tx_prepare+0x256>
		return NULL;
	}

	adf_os_assert(skb);
  909cad:	cc31      	bnez.n	a3, 909cb2 <ath_tgt_tx_prepare+0x10a>
  909caf:	63fffc        	j	909caf <ath_tgt_tx_prepare+0x107>

	bf->bf_skb = skb;
  909cb2:	9328      	s32i.n	a3, a2, 32
static a_int32_t ath_tgt_txbuf_setup(struct ath_softc_tgt *sc,
				     struct ath_tx_buf *bf,
				     ath_data_hdr_t *dh)

{
	struct ieee80211_frame *wh = ATH_SKB2_WH(bf->bf_skb);
  909cb4:	da30      	mov.n	a10, a3
  909cb6:	5bff38        	call8	909998 <ATH_SKB_2_WH>
	a_int32_t retval;
	a_uint32_t flags = adf_os_ntohl(dh->flags);
  909cb9:	284004        	l8ui	a8, a4, 4
  909cbc:	234005        	l8ui	a3, a4, 5
  909cbf:	088810        	slli	a8, a8, 24
  909cc2:	003311        	slli	a3, a3, 16
  909cc5:	083802        	or	a8, a3, a8
  909cc8:	234006        	l8ui	a3, a4, 6
static a_int32_t ath_tgt_txbuf_setup(struct ath_softc_tgt *sc,
				     struct ath_tx_buf *bf,
				     ath_data_hdr_t *dh)

{
	struct ieee80211_frame *wh = ATH_SKB2_WH(bf->bf_skb);
  909ccb:	d7a0      	mov.n	a7, a10
	a_int32_t retval;
	a_uint32_t flags = adf_os_ntohl(dh->flags);
  909ccd:	083311        	slli	a3, a3, 8
  909cd0:	083302        	or	a3, a3, a8

static void ath_tgt_tx_seqno_normal(struct ath_tx_buf *bf)
{
	struct ieee80211_node_target *ni = bf->bf_node;
	struct ath_node_target *an = ATH_NODE_TARGET(ni);
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);
  909cd3:	8a28      	l32i.n	a10, a2, 32
	return bf;
}

static void ath_tgt_tx_seqno_normal(struct ath_tx_buf *bf)
{
	struct ieee80211_node_target *ni = bf->bf_node;
  909cd5:	282204        	l32i	a8, a2, 16
				     ath_data_hdr_t *dh)

{
	struct ieee80211_frame *wh = ATH_SKB2_WH(bf->bf_skb);
	a_int32_t retval;
	a_uint32_t flags = adf_os_ntohl(dh->flags);
  909cd8:	244007        	l8ui	a4, a4, 7

static void ath_tgt_tx_seqno_normal(struct ath_tx_buf *bf)
{
	struct ieee80211_node_target *ni = bf->bf_node;
	struct ath_node_target *an = ATH_NODE_TARGET(ni);
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);
  909cdb:	9810      	s32i.n	a8, a1, 0
  909cdd:	5bff2e        	call8	909998 <ATH_SKB_2_WH>
	struct ath_atx_tid *tid = ATH_AN_2_TID(an, bf->bf_tidno);

	u_int8_t fragno = (wh->i_seq[0] & 0xf);

	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);
  909ce0:	8810      	l32i.n	a8, a1, 0
static void ath_tgt_tx_seqno_normal(struct ath_tx_buf *bf)
{
	struct ieee80211_node_target *ni = bf->bf_node;
	struct ath_node_target *an = ATH_NODE_TARGET(ni);
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);
	struct ath_atx_tid *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  909ce2:	2d204d        	l8ui	a13, a2, 77
				     ath_data_hdr_t *dh)

{
	struct ieee80211_frame *wh = ATH_SKB2_WH(bf->bf_skb);
	a_int32_t retval;
	a_uint32_t flags = adf_os_ntohl(dh->flags);
  909ce5:	034402        	or	a4, a4, a3

	u_int8_t fragno = (wh->i_seq[0] & 0xf);

	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);

	bf->bf_seqno = (tid->seq_next << IEEE80211_SEQ_SEQ_SHIFT);
  909ce8:	0cdb11        	slli	a11, a13, 4
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);
	struct ath_atx_tid *tid = ATH_AN_2_TID(an, bf->bf_tidno);

	u_int8_t fragno = (wh->i_seq[0] & 0xf);

	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);
  909ceb:	23810c        	l16ui	a3, a8, 24

	bf->bf_seqno = (tid->seq_next << IEEE80211_SEQ_SEQ_SHIFT);
  909cee:	0db90c        	sub	a9, a11, a13
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);
	struct ath_atx_tid *tid = ATH_AN_2_TID(an, bf->bf_tidno);

	u_int8_t fragno = (wh->i_seq[0] & 0xf);

	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);
  909cf1:	b133      	addi.n	a3, a3, 1

	bf->bf_seqno = (tid->seq_next << IEEE80211_SEQ_SEQ_SHIFT);
  909cf3:	0e9911        	slli	a9, a9, 2
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);
	struct ath_atx_tid *tid = ATH_AN_2_TID(an, bf->bf_tidno);

	u_int8_t fragno = (wh->i_seq[0] & 0xf);

	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);
  909cf6:	03034b        	extui	a3, a3, 0, 12

	bf->bf_seqno = (tid->seq_next << IEEE80211_SEQ_SEQ_SHIFT);
  909cf9:	098908        	add	a9, a8, a9
	struct ieee80211_node_target *ni = bf->bf_node;
	struct ath_node_target *an = ATH_NODE_TARGET(ni);
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);
	struct ath_atx_tid *tid = ATH_AN_2_TID(an, bf->bf_tidno);

	u_int8_t fragno = (wh->i_seq[0] & 0xf);
  909cfc:	2ca016        	l8ui	a12, a10, 22

	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);
  909cff:	23850c        	s16i	a3, a8, 24

	bf->bf_seqno = (tid->seq_next << IEEE80211_SEQ_SEQ_SHIFT);
  909d02:	239115        	l16ui	a3, a9, 42
	struct ieee80211_node_target *ni = bf->bf_node;
	struct ath_node_target *an = ATH_NODE_TARGET(ni);
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);
	struct ath_atx_tid *tid = ATH_AN_2_TID(an, bf->bf_tidno);

	u_int8_t fragno = (wh->i_seq[0] & 0xf);
  909d05:	0c0c43        	extui	a12, a12, 0, 4

	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);

	bf->bf_seqno = (tid->seq_next << IEEE80211_SEQ_SEQ_SHIFT);
  909d08:	0c3311        	slli	a3, a3, 4
  909d0b:	03034f        	extui	a3, a3, 0, 16
  909d0e:	232523        	s16i	a3, a2, 70

	*(u_int16_t *)wh->i_seq = adf_os_cpu_to_le16(bf->bf_seqno);
  909d11:	083e11        	slli	a14, a3, 8
  909d14:	038314        	srli	a3, a3, 8
  909d17:	03e302        	or	a3, a14, a3
  909d1a:	030e4f        	extui	a14, a3, 0, 16
  909d1d:	23a50b        	s16i	a3, a10, 22
	wh->i_seq[0] |= fragno;
  909d20:	0e8314        	srli	a3, a14, 8
  909d23:	03cc02        	or	a12, a12, a3

	if (!(wh->i_fc[1] & IEEE80211_FC1_MORE_FRAG))
  909d26:	23a001        	l8ui	a3, a10, 1
	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);

	bf->bf_seqno = (tid->seq_next << IEEE80211_SEQ_SEQ_SHIFT);

	*(u_int16_t *)wh->i_seq = adf_os_cpu_to_le16(bf->bf_seqno);
	wh->i_seq[0] |= fragno;
  909d29:	2ca416        	s8i	a12, a10, 22

	if (!(wh->i_fc[1] & IEEE80211_FC1_MORE_FRAG))
  909d2c:	7d3f08        	bbsi	a3, 29, 909d38 <ath_tgt_tx_prepare+0x190>
		INCR(tid->seq_next, IEEE80211_SEQ_MAX);
  909d2f:	239115        	l16ui	a3, a9, 42
  909d32:	233c01        	addi	a3, a3, 1
  909d35:	239515        	s16i	a3, a9, 42
  909d38:	0dbb0c        	sub	a11, a11, a13
  909d3b:	0ebb11        	slli	a11, a11, 2
  909d3e:	ab88      	add.n	a8, a8, a11
  909d40:	238115        	l16ui	a3, a8, 42
	a_uint32_t flags = adf_os_ntohl(dh->flags);

	ath_tgt_tx_seqno_normal(bf);

	bf->bf_txq_add  = ath_tgt_txq_add_ucast;
	bf->bf_hdrlen   = ieee80211_anyhdrsize(wh);
  909d43:	077a02        	or	a10, a7, a7

	*(u_int16_t *)wh->i_seq = adf_os_cpu_to_le16(bf->bf_seqno);
	wh->i_seq[0] |= fragno;

	if (!(wh->i_fc[1] & IEEE80211_FC1_MORE_FRAG))
		INCR(tid->seq_next, IEEE80211_SEQ_MAX);
  909d46:	03034b        	extui	a3, a3, 0, 12
  909d49:	238515        	s16i	a3, a8, 42
	a_int32_t retval;
	a_uint32_t flags = adf_os_ntohl(dh->flags);

	ath_tgt_tx_seqno_normal(bf);

	bf->bf_txq_add  = ath_tgt_txq_add_ucast;
  909d4c:	1372b1        	l32r	a3, 8e6810 <memset+0x1674>
  909d4f:	232610        	s32i	a3, a2, 64
	bf->bf_hdrlen   = ieee80211_anyhdrsize(wh);
  909d52:	5bfc65        	call8	908ee8 <ieee80211_anyhdrsize>
  909d55:	d3a0      	mov.n	a3, a10
  909d57:	2a2448        	s8i	a10, a2, 72
 * @return first buffer in queue
 */
static inline adf_nbuf_t 
adf_nbuf_queue_first(adf_nbuf_queue_t *head)
{
    return (__adf_nbuf_queue_first(head));
  909d5a:	066a02        	or	a10, a6, a6
  909d5d:	5be655        	call8	9036b4 <__adf_nbuf_queue_first>
 * @return The total length of this buf.
 */
static inline adf_os_size_t
adf_nbuf_len(adf_nbuf_t buf)
{
    return (__adf_nbuf_len(buf));
  909d60:	5be640        	call8	903664 <__adf_nbuf_len>
	a_int32_t pktlen;

	skb = adf_nbuf_queue_first(&bf->bf_skbhead);
	pktlen = adf_nbuf_len(skb);

	pktlen -= (hdrlen & 3);
  909d63:	030341        	extui	a3, a3, 0, 2
  909d66:	03a30c        	sub	a3, a10, a3
	pktlen += IEEE80211_CRC_LEN;
  909d69:	b433      	addi.n	a3, a3, 4

	ath_tgt_tx_seqno_normal(bf);

	bf->bf_txq_add  = ath_tgt_txq_add_ucast;
	bf->bf_hdrlen   = ieee80211_anyhdrsize(wh);
	bf->bf_pktlen   = ath_get_pktlen(bf, bf->bf_hdrlen);
  909d6b:	232522        	s16i	a3, a2, 68
	bf->bf_ismcast  = IEEE80211_IS_MULTICAST(wh->i_addr1);
  909d6e:	237004        	l8ui	a3, a7, 4
}

static a_int32_t ath_key_setup(struct ieee80211_node_target *ni,
			       struct ath_tx_buf *bf)
{
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);
  909d71:	8a28      	l32i.n	a10, a2, 32
	ath_tgt_tx_seqno_normal(bf);

	bf->bf_txq_add  = ath_tgt_txq_add_ucast;
	bf->bf_hdrlen   = ieee80211_anyhdrsize(wh);
	bf->bf_pktlen   = ath_get_pktlen(bf, bf->bf_hdrlen);
	bf->bf_ismcast  = IEEE80211_IS_MULTICAST(wh->i_addr1);
  909d73:	093611        	slli	a6, a3, 7
  909d76:	232087        	l8ui	a3, a2, 135
static a_int32_t ath_key_setup(struct ieee80211_node_target *ni,
			       struct ath_tx_buf *bf)
{
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);

	if (!(wh->i_fc[1] & IEEE80211_FC1_WEP)) {
  909d79:	c470      	movi.n	a7, 64
	ath_tgt_tx_seqno_normal(bf);

	bf->bf_txq_add  = ath_tgt_txq_add_ucast;
	bf->bf_hdrlen   = ieee80211_anyhdrsize(wh);
	bf->bf_pktlen   = ath_get_pktlen(bf, bf->bf_hdrlen);
	bf->bf_ismcast  = IEEE80211_IS_MULTICAST(wh->i_addr1);
  909d7b:	030346        	extui	a3, a3, 0, 7
  909d7e:	063302        	or	a3, a3, a6
  909d81:	232487        	s8i	a3, a2, 135

	if ((retval = ath_key_setup(bf->bf_node, bf)) < 0)
  909d84:	8624      	l32i.n	a6, a2, 16
}

static a_int32_t ath_key_setup(struct ieee80211_node_target *ni,
			       struct ath_tx_buf *bf)
{
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);
  909d86:	5bff04        	call8	909998 <ATH_SKB_2_WH>

	if (!(wh->i_fc[1] & IEEE80211_FC1_WEP)) {
  909d89:	23a001        	l8ui	a3, a10, 1
  909d8c:	073301        	and	a3, a3, a7
  909d8f:	cc39      	bnez.n	a3, 909d9c <ath_tgt_tx_prepare+0x1f4>
		bf->bf_keytype = HAL_KEY_TYPE_CLEAR;
  909d91:	232485        	s8i	a3, a2, 133
		bf->bf_keyix = HAL_TXKEYIX_INVALID;
  909d94:	c73f      	movi.n	a3, -1
  909d96:	232449        	s8i	a3, a2, 73
  909d99:	60002d        	j	909dca <ath_tgt_tx_prepare+0x222>
		return 0;
	}

	switch (bf->bf_keytype) {
  909d9c:	2c2085        	l8ui	a12, a2, 133
  909d9f:	68c209        	beqi	a12, 2, 909dac <ath_tgt_tx_prepare+0x204>
  909da2:	68c30e        	beqi	a12, 3, 909db4 <ath_tgt_tx_prepare+0x20c>
  909da5:	69c113        	bnei	a12, 1, 909dbc <ath_tgt_tx_prepare+0x214>
  909da8:	600008        	j	909db4 <ath_tgt_tx_prepare+0x20c>
  909dab:	002321        	excw
	case HAL_KEY_TYPE_WEP:
		bf->bf_pktlen += IEEE80211_WEP_ICVLEN;
		break;
	case HAL_KEY_TYPE_AES:
		bf->bf_pktlen += IEEE80211_WEP_MICLEN;
  909dae:	22b833        	excw
  909db1:	600004        	j	909db9 <ath_tgt_tx_prepare+0x211>
		break;
	case HAL_KEY_TYPE_TKIP:
		bf->bf_pktlen += IEEE80211_WEP_ICVLEN;
  909db4:	232122        	l16ui	a3, a2, 68
  909db7:	b433      	addi.n	a3, a3, 4
  909db9:	232522        	s16i	a3, a2, 68
		break;
	default:
		break;
	}

	if (bf->bf_keytype == HAL_KEY_TYPE_AES ||
  909dbc:	23ccfe        	addi	a3, a12, -2
  909dbf:	030347        	extui	a3, a3, 0, 8
  909dc2:	6f3204        	bgeui	a3, 2, 909dca <ath_tgt_tx_prepare+0x222>
	    bf->bf_keytype == HAL_KEY_TYPE_TKIP)
		ieee80211_tgt_crypto_encap(wh, ni, bf->bf_keytype);
  909dc5:	db60      	mov.n	a11, a6
  909dc7:	580476        	call8	90afa0 <ieee80211_tgt_crypto_encap>
  909dca:	232087        	l8ui	a3, a2, 135
	bf->bf_ismcast  = IEEE80211_IS_MULTICAST(wh->i_addr1);

	if ((retval = ath_key_setup(bf->bf_node, bf)) < 0)
		return retval;

	if (flags & ATH_SHORT_PREAMBLE)
  909dcd:	7f4707        	bbci	a4, 31, 909dd8 <ath_tgt_tx_prepare+0x230>
		bf->bf_shpream = AH_TRUE;
  909dd0:	c440      	movi.n	a4, 64
  909dd2:	043302        	or	a3, a3, a4
  909dd5:	600005        	j	909dde <ath_tgt_tx_prepare+0x236>
	else
		bf->bf_shpream = AH_FALSE;
  909dd8:	24fabf        	movi	a4, -65
  909ddb:	043301        	and	a3, a3, a4
  909dde:	232487        	s8i	a3, a2, 135

	bf->bf_flags = HAL_TXDESC_CLRDMASK;
  909de1:	c031      	movi.n	a3, 1
  909de3:	232544        	s16i	a3, a2, 136
	adf_os_assert(skb);

	bf->bf_skb = skb;

	ath_tgt_txbuf_setup(sc, bf, dh);
	ath_dma_map(sc, bf);
  909de6:	2a1a18        	movi	a10, 0x118
		bf->bf_shpream = AH_TRUE;
	else
		bf->bf_shpream = AH_FALSE;

	bf->bf_flags = HAL_TXDESC_CLRDMASK;
	bf->bf_atype = HAL_PKT_TYPE_NORMAL;
  909de9:	c030      	movi.n	a3, 0
	adf_os_assert(skb);

	bf->bf_skb = skb;

	ath_tgt_txbuf_setup(sc, bf, dh);
	ath_dma_map(sc, bf);
  909deb:	db20      	mov.n	a11, a2
  909ded:	aa5a      	add.n	a10, a5, a10
		bf->bf_shpream = AH_TRUE;
	else
		bf->bf_shpream = AH_FALSE;

	bf->bf_flags = HAL_TXDESC_CLRDMASK;
	bf->bf_atype = HAL_PKT_TYPE_NORMAL;
  909def:	23244a        	s8i	a3, a2, 74
	adf_os_assert(skb);

	bf->bf_skb = skb;

	ath_tgt_txbuf_setup(sc, bf, dh);
	ath_dma_map(sc, bf);
  909df2:	5bfda6        	call8	90948c <ath_dma_map$isra$8>
	ath_tx_tgt_setds(sc, bf);
  909df5:	db20      	mov.n	a11, a2
  909df7:	da50      	mov.n	a10, a5
  909df9:	5bfd0e        	call8	909234 <ath_tx_tgt_setds>

	return bf;
  909dfc:	d10f      	retw.n
	struct ieee80211_node_target *ni;
	struct ath_atx_tid *tid;

	ni = ath_tgt_find_node(sc, dh->ni_index);
	if (ni == NULL)
		return NULL;
  909dfe:	c020      	movi.n	a2, 0
	ath_tgt_txbuf_setup(sc, bf, dh);
	ath_dma_map(sc, bf);
	ath_tx_tgt_setds(sc, bf);

	return bf;
}
  909e00:	d10f      	retw.n
	...

00909e04 <ath_tgt_tx_send_normal>:
	return pktlen;
}

void
ath_tgt_tx_send_normal(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  909e04:	6c1014        	entry	a1, 160
  909e07:	251c40        	addi	a5, a1, 64
  909e0a:	c3b0      	movi.n	a11, 48
  909e0c:	da50      	mov.n	a10, a5
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	struct ath_rc_series rcs[4];
	struct ath_rc_series mrcs[4];
	a_int32_t shortPreamble = 0;
	a_int32_t isProbe = 0;
  909e0e:	c040      	movi.n	a4, 0
}

void
ath_tgt_tx_send_normal(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
  909e10:	263204        	l32i	a6, a3, 16
	struct ath_rc_series rcs[4];
	struct ath_rc_series mrcs[4];
	a_int32_t shortPreamble = 0;
	a_int32_t isProbe = 0;
  909e13:	24161c        	s32i	a4, a1, 112
  909e16:	5bfd1b        	call8	909284 <__adf_os_mem_set$constprop$19>
  909e19:	c3b0      	movi.n	a11, 48
  909e1b:	2a1c10        	addi	a10, a1, 16
  909e1e:	5bfd19        	call8	909284 <__adf_os_mem_set$constprop$19>

	adf_os_mem_set(rcs, 0, sizeof(struct ath_rc_series)*4 );
	adf_os_mem_set(mrcs, 0, sizeof(struct ath_rc_series)*4 );

	if (!bf->bf_ismcast) {
  909e21:	273221        	l32i	a7, a3, 132
  909e24:	2d0a80        	movi	a13, 128
  909e27:	07dd01        	and	a13, a13, a7
  909e2a:	273c50        	addi	a7, a3, 80
  909e2d:	74d921        	bne	a13, a4, 909e52 <ath_tgt_tx_send_normal+0x4e>
				  a_int32_t stepDnInc,
				  a_uint32_t rcflag,
				  struct ath_rc_series series[],
				  a_int32_t *isProbe)
{
	ath_rate_findrate(sc, an, 1, frameLen, 10, 4, 1,
  909e30:	c0c1      	movi.n	a12, 1
  909e32:	241c70        	addi	a4, a1, 112
  909e35:	9c11      	s32i.n	a12, a1, 4
  909e37:	9c10      	s32i.n	a12, a1, 0
  909e39:	db60      	mov.n	a11, a6
  909e3b:	9413      	s32i.n	a4, a1, 12
  909e3d:	9512      	s32i.n	a5, a1, 8
  909e3f:	c0f4      	movi.n	a15, 4
  909e41:	c0ea      	movi.n	a14, 10
  909e43:	da20      	mov.n	a10, a2
  909e45:	5bfbf7        	call8	908e24 <ath_rate_findrate>

	if (!bf->bf_ismcast) {
		ath_tgt_rate_findrate(sc, an, shortPreamble,
				      0, 0, 0, 0, 0,
				      rcs, &isProbe);
		ath_hal_memcpy(bf->bf_rcs, rcs, sizeof(rcs));
  909e48:	c3c0      	movi.n	a12, 48
  909e4a:	db50      	mov.n	a11, a5
  909e4c:	600024        	j	909e74 <ath_tgt_tx_send_normal+0x70>
  909e4f:	000000        	ill
	} else {
		mrcs[1].tries = mrcs[2].tries = mrcs[3].tries = 0;
		mrcs[1].rix = mrcs[2].rix = mrcs[3].rix = 0;
		mrcs[0].rix   = 0;
		mrcs[0].tries = 1;
  909e52:	c051      	movi.n	a5, 1
		ath_tgt_rate_findrate(sc, an, shortPreamble,
				      0, 0, 0, 0, 0,
				      rcs, &isProbe);
		ath_hal_memcpy(bf->bf_rcs, rcs, sizeof(rcs));
	} else {
		mrcs[1].tries = mrcs[2].tries = mrcs[3].tries = 0;
  909e54:	241435        	s8i	a4, a1, 53
  909e57:	241429        	s8i	a4, a1, 41
  909e5a:	24141d        	s8i	a4, a1, 29
		mrcs[1].rix = mrcs[2].rix = mrcs[3].rix = 0;
  909e5d:	241434        	s8i	a4, a1, 52
  909e60:	241428        	s8i	a4, a1, 40
  909e63:	24141c        	s8i	a4, a1, 28
		mrcs[0].rix   = 0;
  909e66:	241410        	s8i	a4, a1, 16
		mrcs[0].tries = 1;
  909e69:	251411        	s8i	a5, a1, 17
		mrcs[0].flags = 0;
  909e6c:	241413        	s8i	a4, a1, 19
		ath_hal_memcpy(bf->bf_rcs, mrcs, sizeof(mrcs));
  909e6f:	c3c0      	movi.n	a12, 48
  909e71:	2b1c10        	addi	a11, a1, 16
  909e74:	da70      	mov.n	a10, a7
  909e76:	5be75b        	call8	903be4 <ath_hal_memcpy>
	}

	ath_buf_set_rate(sc, bf);
  909e79:	db30      	mov.n	a11, a3
  909e7b:	da20      	mov.n	a10, a2
  909e7d:	5bfd06        	call8	909298 <ath_buf_set_rate>
	bf->bf_txq_add(sc, bf);
  909e80:	243210        	l32i	a4, a3, 64
  909e83:	db30      	mov.n	a11, a3
  909e85:	da20      	mov.n	a10, a2
  909e87:	0b4000        	callx8	a4
  909e8a:	d10f      	retw.n

00909e8c <ath_tgt_send_mgt>:
}

void
ath_tgt_send_mgt(struct ath_softc_tgt *sc,adf_nbuf_t hdr_buf, adf_nbuf_t skb,
		 HTC_ENDPOINT_ID endpt)
{
  909e8c:	6c1022        	entry	a1, 0x110
	struct ieee80211_node_target *ni;
	struct ieee80211vap_target *vap;
	struct ath_vap_target *avp;
	struct ath_hal *ah = sc->sc_ah;
  909e8f:	262d05        	addmi	a6, a2, 0x500
  909e92:	866b      	l32i.n	a6, a6, 44
  909e94:	2c0a80        	movi	a12, 128
  909e97:	26162c        	s32i	a6, a1, 176
  909e9a:	2b0a84        	movi	a11, 132
	struct ath_rc_series rcs[4];
	HAL_11N_RATE_SERIES series[4];
	ath_mgt_hdr_t *mh;
	a_int8_t keyix;

	if (!hdr_buf) {
  909e9d:	cd37      	bnez.n	a3, 909eb8 <ath_tgt_send_mgt+0x2c>
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  909e9f:	231c20        	addi	a3, a1, 32
  909ea2:	ab3b      	add.n	a11, a3, a11
  909ea4:	044a02        	or	a10, a4, a4
  909ea7:	0c3c08        	add	a12, a3, a12
  909eaa:	5be5f6        	call8	903684 <__adf_nbuf_peek_header>
 *         or NULL if there is not sufficient data to pull.
 */
static inline a_uint8_t *
adf_nbuf_pull_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_pull_head(buf, size);
  909ead:	c0b8      	movi.n	a11, 8
  909eaf:	da40      	mov.n	a10, a4
  909eb1:	5be54f        	call8	9033f0 <__adf_nbuf_pull_head>
  909eb4:	60000c        	j	909ec4 <ath_tgt_send_mgt+0x38>
  909eb7:	00261c        	mul16u	a6, a2, a0
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  909eba:	20ac6c        	addi	a0, a10, 108
  909ebd:	ab6b      	add.n	a11, a6, a11
  909ebf:	da30      	mov.n	a10, a3
  909ec1:	5be5f0        	call8	903684 <__adf_nbuf_peek_header>
		adf_nbuf_pull_head(skb, sizeof(ath_mgt_hdr_t));
	} else {
		adf_nbuf_peek_header(hdr_buf, &data, &len);
	}

	adf_os_assert(len >= sizeof(ath_mgt_hdr_t));
  909ec4:	231228        	l32i	a3, a1, 160
  909ec7:	6f3802        	bgeui	a3, 8, 909ecd <ath_tgt_send_mgt+0x41>
  909eca:	63fffc        	j	909eca <ath_tgt_send_mgt+0x3e>
  909ecd:	281c20        	addi	a8, a1, 32
  909ed0:	2c0a80        	movi	a12, 128
  909ed3:	2b0a84        	movi	a11, 132
  909ed6:	ab8b      	add.n	a11, a8, a11
  909ed8:	ac8c      	add.n	a12, a8, a12
  909eda:	da40      	mov.n	a10, a4

	mh = (ath_mgt_hdr_t *)data;
  909edc:	261229        	l32i	a6, a1, 164
  909edf:	5be5e9        	call8	903684 <__adf_nbuf_peek_header>
  909ee2:	c3b0      	movi.n	a11, 48
  909ee4:	2a1c70        	addi	a10, a1, 112
	adf_nbuf_peek_header(skb, &data, &len);
	wh = (struct ieee80211_frame *)data;
  909ee7:	271229        	l32i	a7, a1, 164
  909eea:	5bfce6        	call8	909284 <__adf_os_mem_set$constprop$19>
  909eed:	c5b0      	movi.n	a11, 80
  909eef:	2a1c20        	addi	a10, a1, 32
  909ef2:	5bfce4        	call8	909284 <__adf_os_mem_set$constprop$19>

	adf_os_mem_set(rcs, 0, sizeof(struct ath_rc_series)*4);
	adf_os_mem_set(series, 0, sizeof(HAL_11N_RATE_SERIES)*4);

	bf = asf_tailq_first(&sc->sc_txbuf);
  909ef5:	2322f0        	l32i	a3, a2, 0x3c0
	if (!bf)
  909ef8:	6432f9        	beqz	a3, 90a1f5 <ath_tgt_send_mgt+0x369>
		goto fail;

	asf_tailq_remove(&sc->sc_txbuf, bf, bf_list);
  909efb:	8839      	l32i.n	a8, a3, 36
  909efd:	893a      	l32i.n	a9, a3, 40
  909eff:	c885      	beqz.n	a8, 909f08 <ath_tgt_send_mgt+0x7c>
  909f01:	998a      	s32i.n	a9, a8, 40
  909f03:	600004        	j	909f0b <ath_tgt_send_mgt+0x7f>
  909f06:	000029        	excw
  909f09:	26f189        	l16ui	a6, a15, 0x112
  909f0c:	3a9890        	excw

	ni = ath_tgt_find_node(sc, mh->ni_index);
  909f0f:	286000        	l8ui	a8, a6, 0
							a_int32_t node_index)
{
	struct ath_node_target *an;
	struct ieee80211_node_target *ni;

	if (node_index > TARGET_NODE_MAX)
  909f12:	c098      	movi.n	a9, 8
  909f14:	789a02        	bge	a9, a8, 909f1a <ath_tgt_send_mgt+0x8e>
  909f17:	6002da        	j	90a1f5 <ath_tgt_send_mgt+0x369>
	  	return NULL;

	an = &sc->sc_sta[node_index];
	ni = &an->ni;
  909f1a:	0a8911        	slli	a9, a8, 6
  909f1d:	a899      	add.n	a9, a9, a8
  909f1f:	0f9911        	slli	a9, a9, 1
  909f22:	a899      	add.n	a9, a9, a8
  909f24:	0e9911        	slli	a9, a9, 2
  909f27:	2a5a38        	movi	a10, 0x538
  909f2a:	aa9a      	add.n	a10, a9, a10
  909f2c:	aa2a      	add.n	a10, a2, a10
  909f2e:	2a1634        	s32i	a10, a1, 208

	if (an->an_valid) {
  909f31:	a929      	add.n	a9, a2, a9
  909f33:	2a7a3c        	movi	a10, 0x73c
  909f36:	aa9a      	add.n	a10, a9, a10
  909f38:	2aa000        	l8ui	a10, a10, 0
  909f3b:	64a2b6        	beqz	a10, 90a1f5 <ath_tgt_send_mgt+0x369>
		if (ni->ni_vap == NULL) {
  909f3e:	2a5a58        	movi	a10, 0x558
  909f41:	aa99      	add.n	a9, a9, a10
  909f43:	8990      	l32i.n	a9, a9, 0
  909f45:	6592bf        	bnez	a9, 90a208 <ath_tgt_send_mgt+0x37c>
  909f48:	6002a9        	j	90a1f5 <ath_tgt_send_mgt+0x369>
  909f4b:	000029        	excw
	keyix = HAL_TXKEYIX_INVALID;
	pktlen -= (hdrlen & 3);
	pktlen += IEEE80211_CRC_LEN;

	if (iswep)
		keyix = mh->keyix;
  909f4e:	600529        	j	90a47b <ath_tgt_tx_form_aggr+0x10b>
  909f51:	16308b        	l32r	a6, 8d6180 <_bss_end+0x3c8978>
adf_nbuf_map(adf_os_device_t        osdev, 
             adf_os_dma_map_t       bmap, 
             adf_nbuf_t             buf, 
             adf_os_dma_dir_t       dir)
{
    return __adf_nbuf_map(osdev, bmap, buf, dir);
  909f54:	302a22        	excw
  909f57:	46dc40        	excw
  909f5a:	c0d0      	movi.n	a13, 0
  909f5c:	281637        	s32i	a8, a1, 220
  909f5f:	5be55b        	call8	9034cc <__adf_nbuf_map>
 * @param[in] buf   buf
 */
static inline void
adf_nbuf_queue_add(adf_nbuf_queue_t *head, adf_nbuf_t buf)
{
    __adf_nbuf_queue_add(head, buf);
  909f62:	db40      	mov.n	a11, a4

	adf_nbuf_map(sc->sc_dev, bf->bf_dmamap, skb, ADF_OS_DMA_TO_DEVICE);

	bf->bf_skb = skb;
  909f64:	9438      	s32i.n	a4, a3, 32
  909f66:	2a3c14        	addi	a10, a3, 20
  909f69:	5be53f        	call8	903468 <__adf_nbuf_queue_add>
	adf_nbuf_queue_add(&bf->bf_skbhead, skb);

	ds = bf->bf_desc;
  909f6c:	843c      	l32i.n	a4, a3, 48
	rt = sc->sc_currates;
  909f6e:	2f2281        	l32i	a15, a2, 0x204
	adf_nbuf_map(sc->sc_dev, bf->bf_dmamap, skb, ADF_OS_DMA_TO_DEVICE);

	bf->bf_skb = skb;
	adf_nbuf_queue_add(&bf->bf_skbhead, skb);

	ds = bf->bf_desc;
  909f71:	24162f        	s32i	a4, a1, 188
	rt = sc->sc_currates;
	adf_os_assert(rt != NULL);
  909f74:	281237        	l32i	a8, a1, 220
  909f77:	ccf1      	bnez.n	a15, 909f7c <ath_tgt_send_mgt+0xf0>
  909f79:	63fffc        	j	909f79 <ath_tgt_send_mgt+0xed>

	if (mh->flags == ATH_SHORT_PREAMBLE)
  909f7c:	256003        	l8ui	a5, a6, 3
  909f7f:	c0a0      	movi.n	a10, 0
  909f81:	b054      	addi.n	a4, a5, -1
  909f83:	c091      	movi.n	a9, 1
  909f85:	dea0      	mov.n	a14, a10
  909f87:	049e38        	moveqz	a14, a9, a4
	else
		shortPreamble = AH_FALSE;

	flags = HAL_TXDESC_CLRDMASK;

	switch (wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) {
  909f8a:	247000        	l8ui	a4, a7, 0

	ds = bf->bf_desc;
	rt = sc->sc_currates;
	adf_os_assert(rt != NULL);

	if (mh->flags == ATH_SHORT_PREAMBLE)
  909f8d:	251639        	s32i	a5, a1, 228
	else
		shortPreamble = AH_FALSE;

	flags = HAL_TXDESC_CLRDMASK;

	switch (wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) {
  909f90:	c05c      	movi.n	a5, 12

	ds = bf->bf_desc;
	rt = sc->sc_currates;
	adf_os_assert(rt != NULL);

	if (mh->flags == ATH_SHORT_PREAMBLE)
  909f92:	2e1635        	s32i	a14, a1, 212
	else
		shortPreamble = AH_FALSE;

	flags = HAL_TXDESC_CLRDMASK;

	switch (wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) {
  909f95:	054501        	and	a5, a4, a5
  909f98:	7a591d        	bne	a5, a10, 909fb9 <ath_tgt_send_mgt+0x12d>
  909f9b:	c7a0      	movi.n	a10, -16
	case IEEE80211_FC0_TYPE_MGT:
		subtype = wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK;

		if (subtype == IEEE80211_FC0_SUBTYPE_PROBE_RESP)
			atype = HAL_PKT_TYPE_PROBE_RESP;
  909f9d:	c0b4      	movi.n	a11, 4
  909f9f:	0a4401        	and	a4, a4, a10
  909fa2:	2b162d        	s32i	a11, a1, 180

	switch (wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) {
	case IEEE80211_FC0_TYPE_MGT:
		subtype = wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK;

		if (subtype == IEEE80211_FC0_SUBTYPE_PROBE_RESP)
  909fa5:	c5a0      	movi.n	a10, 80
  909fa7:	7a4111        	beq	a4, a10, 909fbc <ath_tgt_send_mgt+0x130>
			atype = HAL_PKT_TYPE_PROBE_RESP;
		else if (subtype == IEEE80211_FC0_SUBTYPE_ATIM)
  909faa:	2afa70        	movi	a10, -144
  909fad:	aa44      	add.n	a4, a4, a10
  909faf:	049538        	moveqz	a5, a9, a4
  909fb2:	25162d        	s32i	a5, a1, 180
  909fb5:	600003        	j	909fbc <ath_tgt_send_mgt+0x130>
  909fb8:	002a16        	excw
		else
			atype = HAL_PKT_TYPE_NORMAL;

		break;
	default:
		atype = HAL_PKT_TYPE_NORMAL;
  909fbb:	2d2460        	s8i	a13, a2, 96
		break;
	}

	avp = &sc->sc_vap[mh->vap_index];
  909fbe:	01da20        	excw
  909fc1:	0c4b11        	slli	a11, a4, 4
  909fc4:	a4bb      	add.n	a11, a11, a4
  909fc6:	147289        	l32r	a4, 8e69ec <memset+0x1850>
  909fc9:	0ebb11        	slli	a11, a11, 2
  909fcc:	a4bb      	add.n	a11, a11, a4

	rcs[0].rix = ath_get_minrateidx(sc, avp);
  909fce:	0b2b08        	add	a11, a2, a11
  909fd1:	281637        	s32i	a8, a1, 220
  909fd4:	2f1636        	s32i	a15, a1, 216
	rcs[0].tries = ATH_TXMAXTRY;
  909fd7:	c04b      	movi.n	a4, 11
		break;
	}

	avp = &sc->sc_vap[mh->vap_index];

	rcs[0].rix = ath_get_minrateidx(sc, avp);
  909fd9:	5bf721        	call8	907c60 <ath_get_minrateidx>
  909fdc:	2a1470        	s8i	a10, a1, 112
	rcs[0].tries = ATH_TXMAXTRY;
  909fdf:	241471        	s8i	a4, a1, 113
 * @param[in] size    buffer size
 */
static inline void
adf_os_mem_copy(void *dst, const void *src, adf_os_size_t size)
{
    __adf_os_mem_copy(dst, src, size);
  909fe2:	2c0a30        	movi	a12, 48
	rcs[0].flags = 0;
  909fe5:	240a00        	movi	a4, 0
  909fe8:	2b1c70        	addi	a11, a1, 112
  909feb:	2a3c50        	addi	a10, a3, 80
  909fee:	241473        	s8i	a4, a1, 115
  909ff1:	5bfbb8        	call8	908ed4 <__adf_os_mem_copy>

	adf_os_mem_copy(bf->bf_rcs, rcs, sizeof(rcs));
	rix = rcs[0].rix;
  909ff4:	2d1070        	l8ui	a13, a1, 112
  909ff7:	2f1236        	l32i	a15, a1, 216
  909ffa:	0cd411        	slli	a4, a13, 4
	try0 = rcs[0].tries;
	txrate = rt->info[rix].rateCode;

	if (shortPreamble){
  909ffd:	2e1239        	l32i	a14, a1, 228
  90a000:	a4f4      	add.n	a4, a15, a4
	rcs[0].tries = ATH_TXMAXTRY;
	rcs[0].flags = 0;

	adf_os_mem_copy(bf->bf_rcs, rcs, sizeof(rcs));
	rix = rcs[0].rix;
	try0 = rcs[0].tries;
  90a002:	2c1071        	l8ui	a12, a1, 113
	txrate = rt->info[rix].rateCode;
  90a005:	254030        	l8ui	a5, a4, 48

	if (shortPreamble){
  90a008:	281237        	l32i	a8, a1, 220
  90a00b:	69e105        	bnei	a14, 1, 90a014 <ath_tgt_send_mgt+0x188>
		txrate |= rt->info[rix].shortPreamble;
  90a00e:	294031        	l8ui	a9, a4, 49
  90a011:	095502        	or	a5, a5, a9
	}

	vap = ni->ni_vap;
  90a014:	0a8911        	slli	a9, a8, 6
  90a017:	a899      	add.n	a9, a9, a8
  90a019:	0f9911        	slli	a9, a9, 1
  90a01c:	a899      	add.n	a9, a9, a8
  90a01e:	0e9911        	slli	a9, a9, 2
	bf->bf_node = ni;
  90a021:	2e1234        	l32i	a14, a1, 208

	if (shortPreamble){
		txrate |= rt->info[rix].shortPreamble;
	}

	vap = ni->ni_vap;
  90a024:	a929      	add.n	a9, a2, a9
  90a026:	2a5a58        	movi	a10, 0x558
  90a029:	aa99      	add.n	a9, a9, a10
  90a02b:	8990      	l32i.n	a9, a9, 0
	bf->bf_node = ni;
  90a02d:	9e34      	s32i.n	a14, a3, 16

	if (ismcast) {
  90a02f:	2e1233        	l32i	a14, a1, 204
  90a032:	cdea      	bnez.n	a14, 90a050 <ath_tgt_send_mgt+0x1c4>
		flags |= HAL_TXDESC_NOACK;
		try0 = 1;
	} else if (pktlen > vap->iv_rtsthreshold) {
  90a034:	299105        	l16ui	a9, a9, 10
  90a037:	2e122e        	l32i	a14, a1, 184
  90a03a:	291633        	s32i	a9, a1, 204
  90a03d:	2a1233        	l32i	a10, a1, 204
	if (mh->flags == ATH_SHORT_PREAMBLE)
		shortPreamble = AH_TRUE;
	else
		shortPreamble = AH_FALSE;

	flags = HAL_TXDESC_CLRDMASK;
  90a040:	c091      	movi.n	a9, 1
{
	struct ieee80211_node_target *ni;
	struct ieee80211vap_target *vap;
	struct ath_vap_target *avp;
	struct ath_hal *ah = sc->sc_ah;
	a_uint8_t rix, txrate, ctsrate, cix = 0xff, *data;
  90a042:	2b0aff        	movi	a11, 255
	bf->bf_node = ni;

	if (ismcast) {
		flags |= HAL_TXDESC_NOACK;
		try0 = 1;
	} else if (pktlen > vap->iv_rtsthreshold) {
  90a045:	7eaa0f        	bge	a10, a14, 90a058 <ath_tgt_send_mgt+0x1cc>
		flags |= HAL_TXDESC_RTSENA;
		cix = rt->info[rix].controlRate;
  90a048:	2b4033        	l8ui	a11, a4, 51

	if (ismcast) {
		flags |= HAL_TXDESC_NOACK;
		try0 = 1;
	} else if (pktlen > vap->iv_rtsthreshold) {
		flags |= HAL_TXDESC_RTSENA;
  90a04b:	c095      	movi.n	a9, 5
  90a04d:	600007        	j	90a058 <ath_tgt_send_mgt+0x1cc>
	vap = ni->ni_vap;
	bf->bf_node = ni;

	if (ismcast) {
		flags |= HAL_TXDESC_NOACK;
		try0 = 1;
  90a050:	c0c1      	movi.n	a12, 1

	vap = ni->ni_vap;
	bf->bf_node = ni;

	if (ismcast) {
		flags |= HAL_TXDESC_NOACK;
  90a052:	290a03        	movi	a9, 3
{
	struct ieee80211_node_target *ni;
	struct ieee80211vap_target *vap;
	struct ath_vap_target *avp;
	struct ath_hal *ah = sc->sc_ah;
	a_uint8_t rix, txrate, ctsrate, cix = 0xff, *data;
  90a055:	2b0aff        	movi	a11, 255
	} else if (pktlen > vap->iv_rtsthreshold) {
		flags |= HAL_TXDESC_RTSENA;
		cix = rt->info[rix].controlRate;
	}

	if ((bf->bf_protmode != IEEE80211_PROT_NONE) &&
  90a058:	2a3084        	l8ui	a10, a3, 132
  90a05b:	caa1      	beqz.n	a10, 90a080 <ath_tgt_send_mgt+0x1f4>
  90a05d:	244029        	l8ui	a4, a4, 41
  90a060:	69421c        	bnei	a4, 2, 90a080 <ath_tgt_send_mgt+0x1f4>
	    rt->info[rix].phy == IEEE80211_T_OFDM &&
  90a063:	749819        	bany	a9, a4, 90a080 <ath_tgt_send_mgt+0x1f4>
	    (flags & HAL_TXDESC_NOACK) == 0) {
		cix = rt->info[sc->sc_protrix].controlRate;
  90a066:	242d03        	addmi	a4, a2, 0x300
  90a069:	24400c        	l8ui	a4, a4, 12
  90a06c:	b244      	addi.n	a4, a4, 2
  90a06e:	0c4411        	slli	a4, a4, 4
  90a071:	04f408        	add	a4, a15, a4
  90a074:	2b4013        	l8ui	a11, a4, 19
		sc->sc_tx_stats.ast_tx_protect++;
  90a077:	24225a        	l32i	a4, a2, 0x168
  90a07a:	244c01        	addi	a4, a4, 1
  90a07d:	24265a        	s32i	a4, a2, 0x168
	}

	*(a_uint16_t *)&wh->i_seq[0] =  adf_os_cpu_to_le16(ni->ni_txseqmgmt <<
  90a080:	0a8411        	slli	a4, a8, 6
  90a083:	a844      	add.n	a4, a4, a8
  90a085:	0f4411        	slli	a4, a4, 1
  90a088:	a844      	add.n	a4, a4, a8
  90a08a:	0e4411        	slli	a4, a4, 2
  90a08d:	285a50        	movi	a8, 0x550
  90a090:	a424      	add.n	a4, a2, a4
  90a092:	a844      	add.n	a4, a4, a8
  90a094:	284100        	l16ui	a8, a4, 0
  90a097:	048a11        	slli	a10, a8, 12
  90a09a:	084847        	extui	a8, a8, 4, 8
  90a09d:	08a802        	or	a8, a10, a8
  90a0a0:	28750b        	s16i	a8, a7, 22
							   IEEE80211_SEQ_SEQ_SHIFT);
	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);
  90a0a3:	284100        	l16ui	a8, a4, 0

	ctsduration = 0;
	if (flags & (HAL_TXDESC_RTSENA|HAL_TXDESC_CTSENA)) {
  90a0a6:	c0ac      	movi.n	a10, 12
		sc->sc_tx_stats.ast_tx_protect++;
	}

	*(a_uint16_t *)&wh->i_seq[0] =  adf_os_cpu_to_le16(ni->ni_txseqmgmt <<
							   IEEE80211_SEQ_SEQ_SHIFT);
	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);
  90a0a8:	b188      	addi.n	a8, a8, 1
  90a0aa:	08084b        	extui	a8, a8, 0, 12
  90a0ad:	284500        	s16i	a8, a4, 0

	ctsduration = 0;
	if (flags & (HAL_TXDESC_RTSENA|HAL_TXDESC_CTSENA)) {
  90a0b0:	0a9a01        	and	a10, a9, a10
  90a0b3:	64a04e        	beqz	a10, 90a105 <ath_tgt_send_mgt+0x279>
		adf_os_assert(cix != 0xff);
  90a0b6:	240aff        	movi	a4, 255
  90a0b9:	74b903        	bne	a11, a4, 90a0c0 <ath_tgt_send_mgt+0x234>
  90a0bc:	63fffc        	j	90a0bc <ath_tgt_send_mgt+0x230>
  90a0bf:	000cbb        	excw
  90a0c2:	112812        	l32r	a1, 8d410c <_bss_end+0x3c6904>
		ctsrate = rt->info[cix].rateCode;
		if (shortPreamble) {
  90a0c5:	39abfb        	excw
	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);

	ctsduration = 0;
	if (flags & (HAL_TXDESC_RTSENA|HAL_TXDESC_CTSENA)) {
		adf_os_assert(cix != 0xff);
		ctsrate = rt->info[cix].rateCode;
  90a0c8:	24b030        	l8ui	a4, a11, 48
		if (shortPreamble) {
  90a0cb:	69810d        	bnei	a8, 1, 90a0dc <ath_tgt_send_mgt+0x250>
			ctsrate |= rt->info[cix].shortPreamble;
  90a0ce:	28b031        	l8ui	a8, a11, 49
  90a0d1:	084402        	or	a4, a4, a8
			if (flags & HAL_TXDESC_RTSENA)      /* SIFS + CTS */
				ctsduration += rt->info[cix].spAckDuration;
  90a0d4:	28b11b        	l16ui	a8, a11, 54
  90a0d7:	600004        	j	90a0df <ath_tgt_send_mgt+0x253>
  90a0da:	000028        	mull	a0, a0, a0
			if ((flags & HAL_TXDESC_NOACK) == 0)    /* SIFS + ACK */
				ctsduration += rt->info[cix].spAckDuration;
		} else {
			if (flags & HAL_TXDESC_RTSENA)      /* SIFS + CTS */
				ctsduration += rt->info[cix].lpAckDuration;
  90a0dd:	b11a      	addi.n	a10, a1, 1
			if ((flags & HAL_TXDESC_NOACK) == 0)    /* SIFS + ACK */
				ctsduration += rt->info[cix].lpAckDuration;
		}
		ctsduration += ath_hal_computetxtime(ah,
  90a0df:	2c122e        	l32i	a12, a1, 184
  90a0e2:	2e1235        	l32i	a14, a1, 212
  90a0e5:	2a122c        	l32i	a10, a1, 176
				ctsduration += rt->info[cix].spAckDuration;
		} else {
			if (flags & HAL_TXDESC_RTSENA)      /* SIFS + CTS */
				ctsduration += rt->info[cix].lpAckDuration;
			if ((flags & HAL_TXDESC_NOACK) == 0)    /* SIFS + ACK */
				ctsduration += rt->info[cix].lpAckDuration;
  90a0e8:	0f8811        	slli	a8, a8, 1
		}
		ctsduration += ath_hal_computetxtime(ah,
  90a0eb:	dbf0      	mov.n	a11, a15
  90a0ed:	281637        	s32i	a8, a1, 220
  90a0f0:	291636        	s32i	a9, a1, 216
  90a0f3:	5bebba        	call8	904fdc <ath_hal_computetxtime>
  90a0f6:	281237        	l32i	a8, a1, 220
						     rt, pktlen, rix, shortPreamble);
		try0 = 1;
  90a0f9:	c0c1      	movi.n	a12, 1
			if (flags & HAL_TXDESC_RTSENA)      /* SIFS + CTS */
				ctsduration += rt->info[cix].lpAckDuration;
			if ((flags & HAL_TXDESC_NOACK) == 0)    /* SIFS + ACK */
				ctsduration += rt->info[cix].lpAckDuration;
		}
		ctsduration += ath_hal_computetxtime(ah,
  90a0fb:	a8aa      	add.n	a10, a10, a8
  90a0fd:	291236        	l32i	a9, a1, 216
  90a100:	600003        	j	90a107 <ath_tgt_send_mgt+0x27b>
  90a103:	0000d4        	excw
						     rt, pktlen, rix, shortPreamble);
		try0 = 1;
	} else
		ctsrate = 0;
  90a106:	a09a      	add.n	a10, a9, a0

	flags |= HAL_TXDESC_INTREQ;

	ah->ah_setupTxDesc(ds
  90a108:	142a12        	l32r	a4, 8d4950 <_bss_end+0x3c7148>
  90a10b:	30c180        	excw
						     rt, pktlen, rix, shortPreamble);
		try0 = 1;
	} else
		ctsrate = 0;

	flags |= HAL_TXDESC_INTREQ;
  90a10e:	089902        	or	a9, a9, a8

	ah->ah_setupTxDesc(ds
  90a111:	2b122c        	l32i	a11, a1, 176
  90a114:	00a832        	sext	a8, a10, 7
  90a117:	9912      	s32i.n	a9, a1, 8
  90a119:	9c10      	s32i.n	a12, a1, 0
  90a11b:	9413      	s32i.n	a4, a1, 12
  90a11d:	9811      	s32i.n	a8, a1, 4
  90a11f:	28b217        	l32i	a8, a11, 92
  90a122:	2d122d        	l32i	a13, a1, 180
  90a125:	2c1232        	l32i	a12, a1, 200
  90a128:	2b122e        	l32i	a11, a1, 184
  90a12b:	2a122f        	l32i	a10, a1, 188
  90a12e:	291636        	s32i	a9, a1, 216
  90a131:	df50      	mov.n	a15, a5
  90a133:	c3ec      	movi.n	a14, 60
  90a135:	0b8000        	callx8	a8
			    , keyix
			    , flags
			    , ctsrate
			    , ctsduration);

	bf->bf_flags = flags;
  90a138:	291236        	l32i	a9, a1, 216

	/*
	 * Set key type in tx desc while sending the encrypted challenge to AP
	 * in Auth frame 3 of Shared Authentication, owl needs this.
	 */
	if (iswep && (keyix != HAL_TXKEYIX_INVALID) &&
  90a13b:	281231        	l32i	a8, a1, 196
			    , keyix
			    , flags
			    , ctsrate
			    , ctsduration);

	bf->bf_flags = flags;
  90a13e:	293544        	s16i	a9, a3, 136

	/*
	 * Set key type in tx desc while sending the encrypted challenge to AP
	 * in Auth frame 3 of Shared Authentication, owl needs this.
	 */
	if (iswep && (keyix != HAL_TXKEYIX_INVALID) &&
  90a141:	c98f      	beqz.n	a8, 90a164 <ath_tgt_send_mgt+0x2d8>
  90a143:	277000        	l8ui	a7, a7, 0
  90a146:	280af0        	movi	a8, 240
  90a149:	087701        	and	a7, a7, a8
  90a14c:	280ab0        	movi	a8, 176
  90a14f:	787911        	bne	a7, a8, 90a164 <ath_tgt_send_mgt+0x2d8>
			(wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK) == IEEE80211_FC0_SUBTYPE_AUTH)
		ah->ah_fillKeyTxDesc(ds, mh->keytype);
  90a152:	29122c        	l32i	a9, a1, 176
  90a155:	2b6004        	l8ui	a11, a6, 4
  90a158:	2a122f        	l32i	a10, a1, 188
  90a15b:	269219        	l32i	a6, a9, 100
  90a15e:	00bb32        	sext	a11, a11, 7
  90a161:	0b6000        	callx8	a6

	ath_filltxdesc(sc, bf);
  90a164:	262d05        	addmi	a6, a2, 0x500
  90a167:	2a620b        	l32i	a10, a6, 44
  90a16a:	033b02        	or	a11, a3, a3
  90a16d:	5bfc09        	call8	909194 <ath_filltxdesc$isra$9>

	for (i=0; i<4; i++) {
		series[i].Tries = 2;
		series[i].Rate = txrate;
		series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
  90a170:	272d16        	addmi	a7, a2, 0x1600
  90a173:	2b7026        	l8ui	a11, a7, 38
  90a176:	281c20        	addi	a8, a1, 32
  90a179:	c074      	movi.n	a7, 4
  90a17b:	dd80      	mov.n	a13, a8
		ah->ah_fillKeyTxDesc(ds, mh->keytype);

	ath_filltxdesc(sc, bf);

	for (i=0; i<4; i++) {
		series[i].Tries = 2;
  90a17d:	c0c2      	movi.n	a12, 2
		series[i].Rate = txrate;
		series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
		series[i].RateFlags = 0;
  90a17f:	c0a0      	movi.n	a10, 0
  90a181:	d970      	mov.n	a9, a7
  90a183:	6d980c        	loop	a9, 90a193 <ath_tgt_send_mgt+0x307>
		ah->ah_fillKeyTxDesc(ds, mh->keytype);

	ath_filltxdesc(sc, bf);

	for (i=0; i<4; i++) {
		series[i].Tries = 2;
  90a186:	9c80      	s32i.n	a12, a8, 0
		series[i].Rate = txrate;
  90a188:	9581      	s32i.n	a5, a8, 4
		series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
  90a18a:	9b83      	s32i.n	a11, a8, 12
		series[i].RateFlags = 0;
  90a18c:	9a84      	s32i.n	a10, a8, 16
  90a18e:	b077      	addi.n	a7, a7, -1
  90a190:	288c14        	addi	a8, a8, 20
	}
	ah->ah_set11nRateScenario(ds, 0, ctsrate, series, 4, 0);
  90a193:	28122c        	l32i	a8, a1, 176
  90a196:	c0f0      	movi.n	a15, 0
  90a198:	258210        	l32i	a5, a8, 64
  90a19b:	dc40      	mov.n	a12, a4
  90a19d:	2a122f        	l32i	a10, a1, 188
		  struct ath_txq *txq, struct ath_tx_buf *bf,
		  struct ath_tx_desc *lastds)
{
	struct ath_hal *ah = sc->sc_ah;

	ATH_TXQ_INSERT_TAIL(txq, bf, bf_list);
  90a1a0:	243aec        	movi	a4, 0x3ec
  90a1a3:	a424      	add.n	a4, a2, a4
		series[i].Tries = 2;
		series[i].Rate = txrate;
		series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
		series[i].RateFlags = 0;
	}
	ah->ah_set11nRateScenario(ds, 0, ctsrate, series, 4, 0);
  90a1a5:	c0e4      	movi.n	a14, 4
  90a1a7:	0ffb02        	or	a11, a15, a15
  90a1aa:	0b5000        	callx8	a5
  90a1ad:	856b      	l32i.n	a5, a6, 44
		  struct ath_txq *txq, struct ath_tx_buf *bf,
		  struct ath_tx_desc *lastds)
{
	struct ath_hal *ah = sc->sc_ah;

	ATH_TXQ_INSERT_TAIL(txq, bf, bf_list);
  90a1af:	8643      	l32i.n	a6, a4, 12
  90a1b1:	9739      	s32i.n	a7, a3, 36
  90a1b3:	963a      	s32i.n	a6, a3, 40
		series[i].Rate = txrate;
		series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
		series[i].RateFlags = 0;
	}
	ah->ah_set11nRateScenario(ds, 0, ctsrate, series, 4, 0);
	ath_tgt_txqaddbuf(sc, txq, bf, bf->bf_lastds);
  90a1b5:	883e      	l32i.n	a8, a3, 56
		  struct ath_txq *txq, struct ath_tx_buf *bf,
		  struct ath_tx_desc *lastds)
{
	struct ath_hal *ah = sc->sc_ah;

	ATH_TXQ_INSERT_TAIL(txq, bf, bf_list);
  90a1b7:	9360      	s32i.n	a3, a6, 0
  90a1b9:	263c24        	addi	a6, a3, 36
  90a1bc:	9643      	s32i.n	a6, a4, 12
  90a1be:	8644      	l32i.n	a6, a4, 16
  90a1c0:	9345      	s32i.n	a3, a4, 20
  90a1c2:	b166      	addi.n	a6, a6, 1
  90a1c4:	9644      	s32i.n	a6, a4, 16

	if (txq->axq_link == NULL) {
  90a1c6:	8641      	l32i.n	a6, a4, 4
  90a1c8:	cd62      	bnez.n	a6, 90a1de <ath_tgt_send_mgt+0x352>
		ah->ah_setTxDP(ah, txq->axq_qnum, ATH_BUF_GET_DESC_PHY_ADDR(bf));
  90a1ca:	865a      	l32i.n	a6, a5, 40
  90a1cc:	8c3c      	l32i.n	a12, a3, 48
  90a1ce:	8b40      	l32i.n	a11, a4, 0
  90a1d0:	da50      	mov.n	a10, a5
  90a1d2:	281637        	s32i	a8, a1, 220
  90a1d5:	0b6000        	callx8	a6
  90a1d8:	281237        	l32i	a8, a1, 220
  90a1db:	600003        	j	90a1e2 <ath_tgt_send_mgt+0x356>
	} else {
		*txq->axq_link = ATH_BUF_GET_DESC_PHY_ADDR(bf);
  90a1de:	833c      	l32i.n	a3, a3, 48
  90a1e0:	9360      	s32i.n	a3, a6, 0
	}

	txq->axq_link = &lastds->ds_link;
  90a1e2:	233aec        	movi	a3, 0x3ec
  90a1e5:	a322      	add.n	a2, a2, a3
	ah->ah_startTxDma(ah, txq->axq_qnum);
  90a1e7:	8b20      	l32i.n	a11, a2, 0
  90a1e9:	835c      	l32i.n	a3, a5, 48
		ah->ah_setTxDP(ah, txq->axq_qnum, ATH_BUF_GET_DESC_PHY_ADDR(bf));
	} else {
		*txq->axq_link = ATH_BUF_GET_DESC_PHY_ADDR(bf);
	}

	txq->axq_link = &lastds->ds_link;
  90a1eb:	9821      	s32i.n	a8, a2, 4
	ah->ah_startTxDma(ah, txq->axq_qnum);
  90a1ed:	da50      	mov.n	a10, a5
  90a1ef:	0b3000        	callx8	a3
  90a1f2:	d10f      	retw.n
  90a1f4:	001371        	excw
	ah->ah_set11nRateScenario(ds, 0, ctsrate, series, 4, 0);
	ath_tgt_txqaddbuf(sc, txq, bf, bf->bf_lastds);

	return;
fail:
	HTC_ReturnBuffers(sc->tgt_htc_handle, endpt, skb);
  90a1f7:	6e8a22        	bltui	a8, 12, 90a21d <ath_tgt_send_mgt+0x391>
  90a1fa:	233287        	l32i	a3, a3, 0x21c
  90a1fd:	dc40      	mov.n	a12, a4
  90a1ff:	db50      	mov.n	a11, a5
  90a201:	0b3000        	callx8	a3
	return;
  90a204:	d10f      	retw.n
  90a206:	000025        	excw

	ni = ath_tgt_find_node(sc, mh->ni_index);
	if (!ni)
		goto fail;

	bf->bf_endpt = endpt;
  90a209:	362325        	excw
	bf->bf_cookie = mh->cookie;
  90a20c:	600607        	j	90a817 <owltgt_tx_processq+0x5f>
	bf->bf_protmode = mh->flags & (IEEE80211_PROT_RTSCTS | IEEE80211_PROT_CTSONLY);
	txq = &sc->sc_txq[1];
	iswep = wh->i_fc[1] & IEEE80211_FC1_WEP;
	ismcast = IEEE80211_IS_MULTICAST(wh->i_addr1);
	hdrlen = ieee80211_anyhdrsize(wh);
  90a20f:	7a0225        	blt	a0, a10, 90a238 <ath_tgt_send_mgt+0x3ac>
	ni = ath_tgt_find_node(sc, mh->ni_index);
	if (!ni)
		goto fail;

	bf->bf_endpt = endpt;
	bf->bf_cookie = mh->cookie;
  90a212:	349225        	excw
	bf->bf_protmode = mh->flags & (IEEE80211_PROT_RTSCTS | IEEE80211_PROT_CTSONLY);
  90a215:	600305        	j	90a51e <ath_tgt_tx_form_aggr+0x1ae>
  90a218:	054125        	excw
  90a21b:	348429        	excw
  90a21e:	700125        	beq	a0, a0, 90a247 <ath_tgt_send_mgt+0x3bb>
  90a221:	0a4005        	excw
  90a224:	9901      	s32i.n	a9, a0, 4
  90a226:	257004        	l8ui	a5, a7, 4
  90a229:	291631        	s32i	a9, a1, 196
  90a22c:	050540        	extui	a5, a5, 0, 1
  90a22f:	251633        	s32i	a5, a1, 204
	txq = &sc->sc_txq[1];
	iswep = wh->i_fc[1] & IEEE80211_FC1_WEP;
	ismcast = IEEE80211_IS_MULTICAST(wh->i_addr1);
	hdrlen = ieee80211_anyhdrsize(wh);
  90a232:	281637        	s32i	a8, a1, 220
  90a235:	5bfb2c        	call8	908ee8 <ieee80211_anyhdrsize>
	pktlen = len;
	keyix = HAL_TXKEYIX_INVALID;
	pktlen -= (hdrlen & 3);
  90a238:	251228        	l32i	a5, a1, 160
  90a23b:	0a0941        	extui	a9, a10, 0, 2
  90a23e:	09550c        	sub	a5, a5, a9
	pktlen += IEEE80211_CRC_LEN;
  90a241:	b455      	addi.n	a5, a5, 4

	if (iswep)
  90a243:	291231        	l32i	a9, a1, 196
	bf->bf_cookie = mh->cookie;
	bf->bf_protmode = mh->flags & (IEEE80211_PROT_RTSCTS | IEEE80211_PROT_CTSONLY);
	txq = &sc->sc_txq[1];
	iswep = wh->i_fc[1] & IEEE80211_FC1_WEP;
	ismcast = IEEE80211_IS_MULTICAST(wh->i_addr1);
	hdrlen = ieee80211_anyhdrsize(wh);
  90a246:	2a1632        	s32i	a10, a1, 200
	pktlen = len;
	keyix = HAL_TXKEYIX_INVALID;
	pktlen -= (hdrlen & 3);
	pktlen += IEEE80211_CRC_LEN;
  90a249:	25162e        	s32i	a5, a1, 184

	if (iswep)
  90a24c:	281237        	l32i	a8, a1, 220
  90a24f:	659cfa        	bnez	a9, 909f4d <ath_tgt_send_mgt+0xc1>
	txq = &sc->sc_txq[1];
	iswep = wh->i_fc[1] & IEEE80211_FC1_WEP;
	ismcast = IEEE80211_IS_MULTICAST(wh->i_addr1);
	hdrlen = ieee80211_anyhdrsize(wh);
	pktlen = len;
	keyix = HAL_TXKEYIX_INVALID;
  90a252:	250aff        	movi	a5, 255
  90a255:	251630        	s32i	a5, a1, 192
  90a258:	63fcf7        	j	909f53 <ath_tgt_send_mgt+0xc7>
	...

0090a25c <ath_tgt_handle_normal>:
	txq->axq_link = &lastds->ds_link;
	ah->ah_startTxDma(ah, txq->axq_qnum);
}

void ath_tgt_handle_normal(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90a25c:	6c1004        	entry	a1, 32
	ath_atx_tid_t *tid;
	struct ath_node_target *an;

	an = (struct ath_node_target *)bf->bf_node;
  90a25f:	8834      	l32i.n	a8, a3, 16
	txq->axq_link = &lastds->ds_link;
	ah->ah_startTxDma(ah, txq->axq_qnum);
}

void ath_tgt_handle_normal(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90a261:	da20      	mov.n	a10, a2
  90a263:	db30      	mov.n	a11, a3
	ath_atx_tid_t *tid;
	struct ath_node_target *an;

	an = (struct ath_node_target *)bf->bf_node;
	adf_os_assert(an);
  90a265:	cc83      	bnez.n	a8, 90a26c <ath_tgt_handle_normal+0x10>
  90a267:	63fffc        	j	90a267 <ath_tgt_handle_normal+0xb>
  90a26a:	00002c        	excw

	tid = &an->tid[bf->bf_tidno];
  90a26d:	304d19        	excw
	adf_os_assert(tid);

	bf->bf_comp = ath_tgt_tx_comp_normal;
  90a270:	72b299        	blt	a11, a2, 90a20d <ath_tgt_send_mgt+0x381>
  90a273:	3f0cc9        	excw
	INCR(tid->seq_start, IEEE80211_SEQ_MAX);
  90a276:	110c99        	l32r	a1, 8cd4dc <_bss_end+0x3bfcd4>
  90a279:	0c0e99        	excw
  90a27c:	11a988        	l32r	a1, 8f489c <memset+0xf700>
  90a27f:	298114        	l16ui	a9, a8, 40
  90a282:	b199      	addi.n	a9, a9, 1
  90a284:	09094b        	extui	a9, a9, 0, 12
  90a287:	298514        	s16i	a9, a8, 40
	ath_tgt_tx_send_normal(sc, bf);
  90a28a:	5bfede        	call8	909e04 <ath_tgt_tx_send_normal>
  90a28d:	d10f      	retw.n
	...

0090a290 <ath_tx_addto_baw>:

	return ATH_TGT_AGGR_DONE;
}

void ath_tx_addto_baw(ath_atx_tid_t *tid, struct ath_tx_buf *bf)
{
  90a290:	6c1004        	entry	a1, 32
	int index, cindex;

	if (bf->bf_isretried) {
  90a293:	283221        	l32i	a8, a3, 132
  90a296:	7b8f3e        	bbsi	a8, 27, 90a2d8 <ath_tx_addto_baw+0x48>
		return;
	}

	index  = ATH_BA_INDEX(tid->seq_start, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90a299:	283123        	l16ui	a8, a3, 70
  90a29c:	232102        	l16ui	a3, a2, 4
  90a29f:	084814        	srli	a8, a8, 4
	cindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);
  90a2a2:	8d23      	l32i.n	a13, a2, 12

	if (bf->bf_isretried) {
		return;
	}

	index  = ATH_BA_INDEX(tid->seq_start, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90a2a4:	03880c        	sub	a8, a8, a3
  90a2a7:	08084b        	extui	a8, a8, 0, 12
	cindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);
  90a2aa:	ad8c      	add.n	a12, a8, a13
  90a2ac:	0c0946        	extui	a9, a12, 0, 7

	TX_BUF_BITMAP_SET(tid->tx_buf_bitmap, cindex);
  90a2af:	095a12        	srai	a10, a9, 5
  90a2b2:	0eaa11        	slli	a10, a10, 2
  90a2b5:	aa2a      	add.n	a10, a2, a10
  90a2b7:	c0b1      	movi.n	a11, 1
  90a2b9:	00c104        	ssl	a12
  90a2bc:	00bc1a        	sll	a12, a11
  90a2bf:	8ba5      	l32i.n	a11, a10, 20
  90a2c1:	0cbb02        	or	a11, a11, a12
  90a2c4:	9ba5      	s32i.n	a11, a10, 20

	if (index >= ((tid->baw_tail - tid->baw_head) & (ATH_TID_MAX_BUFS - 1))) {
  90a2c6:	8a24      	l32i.n	a10, a2, 16
  90a2c8:	0daa0c        	sub	a10, a10, a13
  90a2cb:	0a0a46        	extui	a10, a10, 0, 7
  90a2ce:	7a8206        	blt	a8, a10, 90a2d8 <ath_tx_addto_baw+0x48>
		tid->baw_tail = cindex;
		INCR(tid->baw_tail, ATH_TID_MAX_BUFS);
  90a2d1:	b199      	addi.n	a9, a9, 1
  90a2d3:	090946        	extui	a9, a9, 0, 7
  90a2d6:	9924      	s32i.n	a9, a2, 16
  90a2d8:	d10f      	retw.n
	...

0090a2dc <ath_tgt_handle_aggr>:
	} while (!asf_tailq_empty(&txq->axq_tidq) && !bdone);
}

void
ath_tgt_handle_aggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90a2dc:	6c1004        	entry	a1, 32
	ath_atx_tid_t *tid;
	struct ath_node_target *an;
	struct ath_txq *txq = bf->bf_txq;
	a_bool_t queue_frame, within_baw;

	an = (struct ath_node_target *)bf->bf_node;
  90a2df:	8b34      	l32i.n	a11, a3, 16
void
ath_tgt_handle_aggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	ath_atx_tid_t *tid;
	struct ath_node_target *an;
	struct ath_txq *txq = bf->bf_txq;
  90a2e1:	2c3220        	l32i	a12, a3, 128
	a_bool_t queue_frame, within_baw;

	an = (struct ath_node_target *)bf->bf_node;
	adf_os_assert(an);
  90a2e4:	ccb1      	bnez.n	a11, 90a2e9 <ath_tgt_handle_aggr+0xd>
  90a2e6:	63fffc        	j	90a2e6 <ath_tgt_handle_aggr+0xa>

	tid = &an->tid[bf->bf_tidno];
  90a2e9:	2d304d        	l8ui	a13, a3, 77
	adf_os_assert(tid);

	bf->bf_comp = ath_tgt_tx_comp_aggr;
  90a2ec:	1472b3        	l32r	a4, 8e6db8 <memset+0x1c1c>
	a_bool_t queue_frame, within_baw;

	an = (struct ath_node_target *)bf->bf_node;
	adf_os_assert(an);

	tid = &an->tid[bf->bf_tidno];
  90a2ef:	0cda11        	slli	a10, a13, 4
  90a2f2:	0daa0c        	sub	a10, a10, a13
  90a2f5:	0eaa11        	slli	a10, a10, 2
	adf_os_assert(tid);

	bf->bf_comp = ath_tgt_tx_comp_aggr;
  90a2f8:	943f      	s32i.n	a4, a3, 60
	within_baw = BAW_WITHIN(tid->seq_start, tid->baw_size,
				SEQNO_FROM_BF_SEQNO(bf->bf_seqno));

	queue_frame = ( (txq->axq_depth >= ATH_AGGR_MIN_QDEPTH) ||
			(!asf_tailq_empty(&tid->buf_q)) ||
			(tid->paused) || (!within_baw) );
  90a2fa:	84c4      	l32i.n	a4, a12, 16
	a_bool_t queue_frame, within_baw;

	an = (struct ath_node_target *)bf->bf_node;
	adf_os_assert(an);

	tid = &an->tid[bf->bf_tidno];
  90a2fc:	2aac24        	addi	a10, a10, 36
  90a2ff:	aaba      	add.n	a10, a11, a10
  90a301:	0cde11        	slli	a14, a13, 4
	within_baw = BAW_WITHIN(tid->seq_start, tid->baw_size,
				SEQNO_FROM_BF_SEQNO(bf->bf_seqno));

	queue_frame = ( (txq->axq_depth >= ATH_AGGR_MIN_QDEPTH) ||
			(!asf_tailq_empty(&tid->buf_q)) ||
			(tid->paused) || (!within_baw) );
  90a304:	ce4d      	bnez.n	a4, 90a335 <ath_tgt_handle_aggr+0x59>

	within_baw = BAW_WITHIN(tid->seq_start, tid->baw_size,
				SEQNO_FROM_BF_SEQNO(bf->bf_seqno));

	queue_frame = ( (txq->axq_depth >= ATH_AGGR_MIN_QDEPTH) ||
			(!asf_tailq_empty(&tid->buf_q)) ||
  90a306:	0de80c        	sub	a8, a14, a13
  90a309:	0e8811        	slli	a8, a8, 2
  90a30c:	a8b8      	add.n	a8, a11, a8
	bf->bf_comp = ath_tgt_tx_comp_aggr;

	within_baw = BAW_WITHIN(tid->seq_start, tid->baw_size,
				SEQNO_FROM_BF_SEQNO(bf->bf_seqno));

	queue_frame = ( (txq->axq_depth >= ATH_AGGR_MIN_QDEPTH) ||
  90a30e:	2f8214        	l32i	a15, a8, 80
  90a311:	cef0      	bnez.n	a15, 90a335 <ath_tgt_handle_aggr+0x59>
	tid = &an->tid[bf->bf_tidno];
	adf_os_assert(tid);

	bf->bf_comp = ath_tgt_tx_comp_aggr;

	within_baw = BAW_WITHIN(tid->seq_start, tid->baw_size,
  90a313:	293123        	l16ui	a9, a3, 70
  90a316:	248114        	l16ui	a4, a8, 40
  90a319:	094914        	srli	a9, a9, 4
  90a31c:	04990c        	sub	a9, a9, a4
  90a31f:	248116        	l16ui	a4, a8, 44
  90a322:	09094b        	extui	a9, a9, 0, 12
				SEQNO_FROM_BF_SEQNO(bf->bf_seqno));

	queue_frame = ( (txq->axq_depth >= ATH_AGGR_MIN_QDEPTH) ||
			(!asf_tailq_empty(&tid->buf_q)) ||
			(tid->paused) || (!within_baw) );
  90a325:	749a0c        	bge	a9, a4, 90a335 <ath_tgt_handle_aggr+0x59>

	within_baw = BAW_WITHIN(tid->seq_start, tid->baw_size,
				SEQNO_FROM_BF_SEQNO(bf->bf_seqno));

	queue_frame = ( (txq->axq_depth >= ATH_AGGR_MIN_QDEPTH) ||
			(!asf_tailq_empty(&tid->buf_q)) ||
  90a328:	288058        	l8ui	a8, a8, 88
  90a32b:	c091      	movi.n	a9, 1
  90a32d:	089f39        	movnez	a15, a9, a8
			(tid->paused) || (!within_baw) );
  90a330:	0f0847        	extui	a8, a15, 0, 8
  90a333:	ca81      	beqz.n	a8, 90a358 <ath_tgt_handle_aggr+0x7c>

	if (queue_frame) {
		asf_tailq_insert_tail(&tid->buf_q, bf, bf_list);
  90a335:	0de80c        	sub	a8, a14, a13
  90a338:	0e8811        	slli	a8, a8, 2
  90a33b:	a8b8      	add.n	a8, a11, a8
  90a33d:	c020      	movi.n	a2, 0
  90a33f:	9239      	s32i.n	a2, a3, 36
  90a341:	228215        	l32i	a2, a8, 84
		ath_tgt_tx_enqueue(txq, tid);
  90a344:	dba0      	mov.n	a11, a10
	queue_frame = ( (txq->axq_depth >= ATH_AGGR_MIN_QDEPTH) ||
			(!asf_tailq_empty(&tid->buf_q)) ||
			(tid->paused) || (!within_baw) );

	if (queue_frame) {
		asf_tailq_insert_tail(&tid->buf_q, bf, bf_list);
  90a346:	923a      	s32i.n	a2, a3, 40
  90a348:	9320      	s32i.n	a3, a2, 0
  90a34a:	233c24        	addi	a3, a3, 36
  90a34d:	238615        	s32i	a3, a8, 84
		ath_tgt_tx_enqueue(txq, tid);
  90a350:	2acc1c        	addi	a10, a12, 28
  90a353:	5bfb5a        	call8	9090bc <ath_tgt_tx_enqueue$isra$3>
  90a356:	d10f      	retw.n
	} else {
		ath_tx_addto_baw(tid, bf);
  90a358:	db30      	mov.n	a11, a3
  90a35a:	5bffcd        	call8	90a290 <ath_tx_addto_baw>
		__stats(sc, txaggr_nframes);
  90a35d:	28225d        	l32i	a8, a2, 0x174
		ath_tgt_tx_send_normal(sc, bf);
  90a360:	db30      	mov.n	a11, a3
	if (queue_frame) {
		asf_tailq_insert_tail(&tid->buf_q, bf, bf_list);
		ath_tgt_tx_enqueue(txq, tid);
	} else {
		ath_tx_addto_baw(tid, bf);
		__stats(sc, txaggr_nframes);
  90a362:	b188      	addi.n	a8, a8, 1
  90a364:	28265d        	s32i	a8, a2, 0x174
		ath_tgt_tx_send_normal(sc, bf);
  90a367:	da20      	mov.n	a10, a2
  90a369:	5bfea6        	call8	909e04 <ath_tgt_tx_send_normal>
  90a36c:	d10f      	retw.n
	...

0090a370 <ath_tgt_tx_form_aggr>:
	return aggr_limit;
}

int ath_tgt_tx_form_aggr(struct ath_softc_tgt *sc, ath_atx_tid_t *tid,
			 ath_tx_bufhead *bf_q)
{
  90a370:	6c100e        	entry	a1, 112
  90a373:	941a      	s32i.n	a4, a1, 40
	struct ath_tx_buf *bf_first ,*bf_prev = NULL;
	int nframes = 0, rl = 0;;
	struct ath_tx_desc *ds = NULL;
	struct ath_tx_buf *bf;
	struct ath_hal *ah = sc->sc_ah;
  90a375:	242d05        	addmi	a4, a2, 0x500
  90a378:	844b      	l32i.n	a4, a4, 44
	u_int16_t aggr_limit =  (64*1024 -1), al = 0, bpad = 0, al_delta;
  90a37a:	c060      	movi.n	a6, 0
{
	struct ath_tx_buf *bf_first ,*bf_prev = NULL;
	int nframes = 0, rl = 0;;
	struct ath_tx_desc *ds = NULL;
	struct ath_tx_buf *bf;
	struct ath_hal *ah = sc->sc_ah;
  90a37c:	941b      	s32i.n	a4, a1, 44
	u_int16_t aggr_limit =  (64*1024 -1), al = 0, bpad = 0, al_delta;
	u_int16_t h_baw = tid->baw_size/2, prev_al = 0, prev_frames = 0;
  90a37e:	243104        	l16ui	a4, a3, 8

	bf_first = asf_tailq_first(&tid->buf_q);
  90a381:	893b      	l32i.n	a9, a3, 44
	int nframes = 0, rl = 0;;
	struct ath_tx_desc *ds = NULL;
	struct ath_tx_buf *bf;
	struct ath_hal *ah = sc->sc_ah;
	u_int16_t aggr_limit =  (64*1024 -1), al = 0, bpad = 0, al_delta;
	u_int16_t h_baw = tid->baw_size/2, prev_al = 0, prev_frames = 0;
  90a383:	041414        	srli	a4, a4, 1
	struct ath_tx_buf *bf_first ,*bf_prev = NULL;
	int nframes = 0, rl = 0;;
	struct ath_tx_desc *ds = NULL;
	struct ath_tx_buf *bf;
	struct ath_hal *ah = sc->sc_ah;
	u_int16_t aggr_limit =  (64*1024 -1), al = 0, bpad = 0, al_delta;
  90a386:	177273        	l32r	a7, 8e6d54 <memset+0x1bb8>
	u_int16_t h_baw = tid->baw_size/2, prev_al = 0, prev_frames = 0;
  90a389:	9419      	s32i.n	a4, a1, 36
	struct ath_tx_buf *bf_first ,*bf_prev = NULL;
	int nframes = 0, rl = 0;;
	struct ath_tx_desc *ds = NULL;
	struct ath_tx_buf *bf;
	struct ath_hal *ah = sc->sc_ah;
	u_int16_t aggr_limit =  (64*1024 -1), al = 0, bpad = 0, al_delta;
  90a38b:	d560      	mov.n	a5, a6

int ath_tgt_tx_form_aggr(struct ath_softc_tgt *sc, ath_atx_tid_t *tid,
			 ath_tx_bufhead *bf_q)
{
	struct ath_tx_buf *bf_first ,*bf_prev = NULL;
	int nframes = 0, rl = 0;;
  90a38d:	dd60      	mov.n	a13, a6
  90a38f:	d860      	mov.n	a8, a6
}

int ath_tgt_tx_form_aggr(struct ath_softc_tgt *sc, ath_atx_tid_t *tid,
			 ath_tx_bufhead *bf_q)
{
	struct ath_tx_buf *bf_first ,*bf_prev = NULL;
  90a391:	261608        	s32i	a6, a1, 32
	u_int16_t h_baw = tid->baw_size/2, prev_al = 0, prev_frames = 0;

	bf_first = asf_tailq_first(&tid->buf_q);

	do {
		bf = asf_tailq_first(&tid->buf_q);
  90a394:	843b      	l32i.n	a4, a3, 44
		adf_os_assert(bf);
  90a396:	cc42      	bnez.n	a4, 90a39c <ath_tgt_tx_form_aggr+0x2c>
  90a398:	63fffc        	j	90a398 <ath_tgt_tx_form_aggr+0x28>
  90a39b:	002a41        	extui	a10, a0, 2, 2

		if (!BAW_WITHIN(tid->seq_start, tid->baw_size,
  90a39e:	232b31        	l32ai	a3, a2, 196
  90a3a1:	020a4a        	extui	a10, a2, 0, 11
  90a3a4:	140baa        	l32r	a4, 8cd24c <_bss_end+0x3bfa44>
  90a3a7:	0c2b31        	excw
  90a3aa:	040a0a        	addx4	a10, a0, a4
  90a3ad:	4b7ba2        	excw
  90a3b0:	0a2595        	excw
				SEQNO_FROM_BF_SEQNO(bf->bf_seqno))) {

			bf_first->bf_al= al;
  90a3b3:	272894        	excw
			bf_first->bf_nframes = nframes;
  90a3b6:	4cc021        	excw
			return ATH_TGT_AGGR_BAW_CLOSED;
  90a3b9:	d10f      	retw.n
  90a3bb:	0065d0        	excw
		}

		if (!rl) {
  90a3be:	b72a      	addi.n	a10, a2, 7
				 struct ath_tx_buf *bf)
{
	int i, prate;
	u_int32_t max4msframelen, frame_length;
	u_int16_t aggr_limit, legacy=0;
	const HAL_RATE_TABLE  *rt = sc->sc_currates;
  90a3c0:	22812b        	l16ui	a2, a8, 86
	struct ieee80211_node_target *ieee_node = (struct ieee80211_node_target *)an;

	if (bf->bf_ismcast) {
  90a3c3:	0a809a        	excw
				 struct ath_tx_buf *bf)
{
	int i, prate;
	u_int32_t max4msframelen, frame_length;
	u_int16_t aggr_limit, legacy=0;
	const HAL_RATE_TABLE  *rt = sc->sc_currates;
  90a3c6:	1c2a42        	l32r	a12, 8d4cd0 <_bss_end+0x3c74c8>
	struct ieee80211_node_target *ieee_node = (struct ieee80211_node_target *)an;

	if (bf->bf_ismcast) {
  90a3c9:	21873e        	excw
  90a3cc:	7ab018        	bnone	a11, a10, 90a3e8 <ath_tgt_tx_form_aggr+0x78>
		bf->bf_rcs[1].tries = bf->bf_rcs[2].tries = bf->bf_rcs[3].tries = 0;
		bf->bf_rcs[0].rix   = 0xb;
  90a3cf:	c0ab      	movi.n	a10, 11
  90a3d1:	2a4450        	s8i	a10, a4, 80
		bf->bf_rcs[0].tries = ATH_TXMAXTRY - 1;
  90a3d4:	c0aa      	movi.n	a10, 10
	u_int16_t aggr_limit, legacy=0;
	const HAL_RATE_TABLE  *rt = sc->sc_currates;
	struct ieee80211_node_target *ieee_node = (struct ieee80211_node_target *)an;

	if (bf->bf_ismcast) {
		bf->bf_rcs[1].tries = bf->bf_rcs[2].tries = bf->bf_rcs[3].tries = 0;
  90a3d6:	2d4475        	s8i	a13, a4, 117
  90a3d9:	2d4469        	s8i	a13, a4, 105
  90a3dc:	2d445d        	s8i	a13, a4, 93
		bf->bf_rcs[0].rix   = 0xb;
		bf->bf_rcs[0].tries = ATH_TXMAXTRY - 1;
  90a3df:	2a4451        	s8i	a10, a4, 81
		bf->bf_rcs[0].flags = 0;
  90a3e2:	2d4453        	s8i	a13, a4, 83
  90a3e5:	600024        	j	90a40d <ath_tgt_tx_form_aggr+0x9d>
				  a_int32_t stepDnInc,
				  a_uint32_t rcflag,
				  struct ath_rc_series series[],
				  a_int32_t *isProbe)
{
	ath_rate_findrate(sc, an, 1, frameLen, 10, 4, 1,
  90a3e8:	2a1c10        	addi	a10, a1, 16
  90a3eb:	c0c1      	movi.n	a12, 1
  90a3ed:	9a13      	s32i.n	a10, a1, 12
		bf->bf_rcs[0].rix   = 0xb;
		bf->bf_rcs[0].tries = ATH_TXMAXTRY - 1;
		bf->bf_rcs[0].flags = 0;
	} else {
		ath_tgt_rate_findrate(sc, an, AH_TRUE, 0, ATH_TXMAXTRY-1, 4, 1,
				      ATH_RC_PROBE_ALLOWED, bf->bf_rcs, &prate);
  90a3ef:	2a4c50        	addi	a10, a4, 80
				  a_int32_t stepDnInc,
				  a_uint32_t rcflag,
				  struct ath_rc_series series[],
				  a_int32_t *isProbe)
{
	ath_rate_findrate(sc, an, 1, frameLen, 10, 4, 1,
  90a3f2:	9a12      	s32i.n	a10, a1, 8
  90a3f4:	9c11      	s32i.n	a12, a1, 4
  90a3f6:	9c10      	s32i.n	a12, a1, 0
  90a3f8:	c0f4      	movi.n	a15, 4
  90a3fa:	c0ea      	movi.n	a14, 10
  90a3fc:	db70      	mov.n	a11, a7
  90a3fe:	da20      	mov.n	a10, a2
  90a400:	981f      	s32i.n	a8, a1, 60
  90a402:	291610        	s32i	a9, a1, 64
  90a405:	5bfa87        	call8	908e24 <ath_rate_findrate>
  90a408:	291210        	l32i	a9, a1, 64
  90a40b:	881f      	l32i.n	a8, a1, 60
}

int ath_tgt_tx_form_aggr(struct ath_softc_tgt *sc, ath_atx_tid_t *tid,
			 ath_tx_bufhead *bf_q)
{
	struct ath_tx_buf *bf_first ,*bf_prev = NULL;
  90a40d:	1d7273        	l32r	a13, 8e6ddc <memset+0x1c40>
  90a410:	2a4c50        	addi	a10, a4, 80
  90a413:	c0c4      	movi.n	a12, 4
  90a415:	6dc81d        	loop	a12, 90a436 <ath_tgt_tx_form_aggr+0xc6>
	}

	max4msframelen = IEEE80211_AMPDU_LIMIT_MAX;

	for (i = 0; i < 4; i++) {
		if (bf->bf_rcs[i].tries) {
  90a418:	2ba001        	l8ui	a11, a10, 1
  90a41b:	c9b5      	beqz.n	a11, 90a434 <ath_tgt_tx_form_aggr+0xc4>
			frame_length = bf->bf_rcs[i].max4msframelen;

			if (rt->info[bf->bf_rcs[i].rix].phy != IEEE80211_T_HT) {
  90a41d:	2ba000        	l8ui	a11, a10, 0
  90a420:	8f1c      	l32i.n	a15, a1, 48
  90a422:	b2bb      	addi.n	a11, a11, 2
  90a424:	0cbb11        	slli	a11, a11, 4
  90a427:	abfb      	add.n	a11, a15, a11
  90a429:	2bb009        	l8ui	a11, a11, 9

	max4msframelen = IEEE80211_AMPDU_LIMIT_MAX;

	for (i = 0; i < 4; i++) {
		if (bf->bf_rcs[i].tries) {
			frame_length = bf->bf_rcs[i].max4msframelen;
  90a42c:	8ea1      	l32i.n	a14, a10, 4

			if (rt->info[bf->bf_rcs[i].rix].phy != IEEE80211_T_HT) {
  90a42e:	69b40c        	bnei	a11, 4, 90a43e <ath_tgt_tx_form_aggr+0xce>
				legacy = 1;
				break;
			}

			max4msframelen = ATH_MIN(max4msframelen, frame_length);
  90a431:	0edd36        	minu	a13, a13, a14
  90a434:	bcaa      	addi.n	a10, a10, 12
				 struct ath_node_target *an,
				 struct ath_tx_buf *bf)
{
	int i, prate;
	u_int32_t max4msframelen, frame_length;
	u_int16_t aggr_limit, legacy=0;
  90a436:	c0a0      	movi.n	a10, 0
  90a438:	600004        	j	90a440 <ath_tgt_tx_form_aggr+0xd0>
  90a43b:	000000        	ill
	for (i = 0; i < 4; i++) {
		if (bf->bf_rcs[i].tries) {
			frame_length = bf->bf_rcs[i].max4msframelen;

			if (rt->info[bf->bf_rcs[i].rix].phy != IEEE80211_T_HT) {
				legacy = 1;
  90a43e:	c0a1      	movi.n	a10, 1

			max4msframelen = ATH_MIN(max4msframelen, frame_length);
		}
	}

	if (prate || legacy)
  90a440:	8b14      	l32i.n	a11, a1, 16
  90a442:	cebc      	bnez.n	a11, 90a472 <ath_tgt_tx_form_aggr+0x102>
  90a444:	ceaa      	bnez.n	a10, 90a472 <ath_tgt_tx_form_aggr+0x102>
		return 0;

	if (sc->sc_ic.ic_enable_coex)
  90a446:	2a2d16        	addmi	a10, a2, 0x1600
  90a449:	8ca8      	l32i.n	a12, a10, 32
  90a44b:	2ea025        	l8ui	a14, a10, 37
		aggr_limit = ATH_MIN((max4msframelen*3)/8, sc->sc_ic.ic_ampdu_limit);
	else
		aggr_limit = ATH_MIN(max4msframelen, sc->sc_ic.ic_ampdu_limit);
  90a44e:	0cdb36        	minu	a11, a13, a12
  90a451:	0b0a4f        	extui	a10, a11, 0, 16
	}

	if (prate || legacy)
		return 0;

	if (sc->sc_ic.ic_enable_coex)
  90a454:	c8ec      	beqz.n	a14, 90a464 <ath_tgt_tx_form_aggr+0xf4>
		aggr_limit = ATH_MIN((max4msframelen*3)/8, sc->sc_ic.ic_ampdu_limit);
  90a456:	0fda11        	slli	a10, a13, 1
  90a459:	adaa      	add.n	a10, a10, a13
  90a45b:	0a3a14        	srli	a10, a10, 3
  90a45e:	0caa36        	minu	a10, a10, a12
  90a461:	0a0a4f        	extui	a10, a10, 0, 16
	else
		aggr_limit = ATH_MIN(max4msframelen, sc->sc_ic.ic_ampdu_limit);

	if (ieee_node->ni_maxampdu)
  90a464:	27710a        	l16ui	a7, a7, 20
		aggr_limit = ATH_MIN(aggr_limit, ieee_node->ni_maxampdu);
  90a467:	0a7b36        	minu	a11, a7, a10
  90a46a:	07ba39        	movnez	a10, a11, a7
  90a46d:	d7a0      	mov.n	a7, a10
  90a46f:	600001        	j	90a474 <ath_tgt_tx_form_aggr+0x104>
			max4msframelen = ATH_MIN(max4msframelen, frame_length);
		}
	}

	if (prate || legacy)
		return 0;
  90a472:	c070      	movi.n	a7, 0
			bf_first->bf_nframes = nframes;
			return ATH_TGT_AGGR_BAW_CLOSED;
		}

		if (!rl) {
			aggr_limit = ath_lookup_rate(sc, tid->an, bf);
  90a474:	07074f        	extui	a7, a7, 0, 16
			rl = 1;
		}

		al_delta = ATH_AGGR_DELIM_SZ + bf->bf_pktlen;
  90a477:	2c4122        	l16ui	a12, a4, 68
  90a47a:	b4cc      	addi.n	a12, a12, 4
  90a47c:	0c0c4f        	extui	a12, a12, 0, 16

		if (nframes && (aggr_limit < (al + bpad + al_delta + prev_al))) {
  90a47f:	648125        	beqz	a8, 90a5a8 <ath_tgt_tx_form_aggr+0x238>
  90a482:	a65a      	add.n	a10, a5, a6
  90a484:	acaa      	add.n	a10, a10, a12
  90a486:	7a7a02        	bge	a7, a10, 90a48c <ath_tgt_tx_form_aggr+0x11c>
  90a489:	600012        	j	90a49f <ath_tgt_tx_form_aggr+0x12f>
			bf_first->bf_nframes = nframes;
			return ATH_TGT_AGGR_LIMITED;
		}

#ifdef PROJECT_K2
		if ((nframes + prev_frames) >= ATH_MIN((h_baw), 17)) {
  90a48c:	8d19      	l32i.n	a13, a1, 36
  90a48e:	c1b0      	movi.n	a11, 16
  90a490:	c1a1      	movi.n	a10, 17
  90a492:	7db306        	bltu	a11, a13, 90a49c <ath_tgt_tx_form_aggr+0x12c>
  90a495:	dad0      	mov.n	a10, a13
  90a497:	600001        	j	90a49c <ath_tgt_tx_form_aggr+0x12c>
  90a49a:	8a19      	l32i.n	a10, a1, 36
  90a49c:	7a820a        	blt	a8, a10, 90a4aa <ath_tgt_tx_form_aggr+0x13a>
#else
		if ((nframes + prev_frames) >= ATH_MIN((h_baw), 22)) {
#endif
			bf_first->bf_al= al;
  90a49f:	259527        	s16i	a5, a9, 78
			bf_first->bf_nframes = nframes;
  90a4a2:	28944c        	s8i	a8, a9, 76
			return ATH_TGT_AGGR_LIMITED;
  90a4a5:	c022      	movi.n	a2, 2
  90a4a7:	d10f      	retw.n
  90a4a9:	00db40        	extui	a11, a0, 13, 1
		}

		ath_tx_addto_baw(tid, bf);
  90a4ac:	da30      	mov.n	a10, a3
  90a4ae:	981f      	s32i.n	a8, a1, 60
  90a4b0:	291610        	s32i	a9, a1, 64
  90a4b3:	9c1e      	s32i.n	a12, a1, 56
  90a4b5:	5bff76        	call8	90a290 <ath_tx_addto_baw>
		asf_tailq_remove(&tid->buf_q, bf, bf_list);
  90a4b8:	8a49      	l32i.n	a10, a4, 36
  90a4ba:	8b4a      	l32i.n	a11, a4, 40
  90a4bc:	881f      	l32i.n	a8, a1, 60
  90a4be:	291210        	l32i	a9, a1, 64
  90a4c1:	8c1e      	l32i.n	a12, a1, 56
  90a4c3:	c8a3      	beqz.n	a10, 90a4ca <ath_tgt_tx_form_aggr+0x15a>
  90a4c5:	9baa      	s32i.n	a11, a10, 40
  90a4c7:	600001        	j	90a4cc <ath_tgt_tx_form_aggr+0x15c>
  90a4ca:	9b3c      	s32i.n	a11, a3, 48
  90a4cc:	8b4a      	l32i.n	a11, a4, 40
		asf_tailq_insert_tail(bf_q, bf, bf_list);
  90a4ce:	8f1a      	l32i.n	a15, a1, 40
			bf_first->bf_nframes = nframes;
			return ATH_TGT_AGGR_LIMITED;
		}

		ath_tx_addto_baw(tid, bf);
		asf_tailq_remove(&tid->buf_q, bf, bf_list);
  90a4d0:	9ab0      	s32i.n	a10, a11, 0
		asf_tailq_insert_tail(bf_q, bf, bf_list);
  90a4d2:	8bf1      	l32i.n	a11, a15, 4
  90a4d4:	c0a0      	movi.n	a10, 0
  90a4d6:	9b4a      	s32i.n	a11, a4, 40
  90a4d8:	9a49      	s32i.n	a10, a4, 36
  90a4da:	94b0      	s32i.n	a4, a11, 0
  90a4dc:	2b4c24        	addi	a11, a4, 36
  90a4df:	9bf1      	s32i.n	a11, a15, 4
		nframes ++;

		adf_os_assert(bf);

		adf_os_assert(bf->bf_comp == ath_tgt_tx_comp_aggr);
  90a4e1:	8d4f      	l32i.n	a13, a4, 60
  90a4e3:	1b72b3        	l32r	a11, 8e6fb0 <memset+0x1e14>
		}

		ath_tx_addto_baw(tid, bf);
		asf_tailq_remove(&tid->buf_q, bf, bf_list);
		asf_tailq_insert_tail(bf_q, bf, bf_list);
		nframes ++;
  90a4e6:	b188      	addi.n	a8, a8, 1

		adf_os_assert(bf);

		adf_os_assert(bf->bf_comp == ath_tgt_tx_comp_aggr);
  90a4e8:	7bd102        	beq	a13, a11, 90a4ee <ath_tgt_tx_form_aggr+0x17e>
  90a4eb:	63fffc        	j	90a4eb <ath_tgt_tx_form_aggr+0x17b>
  90a4ee:	a655      	add.n	a5, a5, a6

		al += bpad + al_delta;
		bf->bf_ndelim = ATH_AGGR_GET_NDELIM(bf->bf_pktlen);
  90a4f0:	264122        	l16ui	a6, a4, 68

		adf_os_assert(bf);

		adf_os_assert(bf->bf_comp == ath_tgt_tx_comp_aggr);

		al += bpad + al_delta;
  90a4f3:	0c5508        	add	a5, a5, a12
		bf->bf_ndelim = ATH_AGGR_GET_NDELIM(bf->bf_pktlen);
  90a4f6:	2b0afb        	movi	a11, 251

		adf_os_assert(bf);

		adf_os_assert(bf->bf_comp == ath_tgt_tx_comp_aggr);

		al += bpad + al_delta;
  90a4f9:	05054f        	extui	a5, a5, 0, 16
		bf->bf_ndelim = ATH_AGGR_GET_NDELIM(bf->bf_pktlen);
  90a4fc:	76b208        	blt	a11, a6, 90a508 <ath_tgt_tx_form_aggr+0x198>
  90a4ff:	2a0afc        	movi	a10, 252
  90a502:	06aa0c        	sub	a10, a10, a6
  90a505:	0a2a12        	srai	a10, a10, 2
  90a508:	0a0a47        	extui	a10, a10, 0, 8

		switch (bf->bf_keytype) {
  90a50b:	264085        	l8ui	a6, a4, 133
		adf_os_assert(bf);

		adf_os_assert(bf->bf_comp == ath_tgt_tx_comp_aggr);

		al += bpad + al_delta;
		bf->bf_ndelim = ATH_AGGR_GET_NDELIM(bf->bf_pktlen);
  90a50e:	2a444b        	s8i	a10, a4, 75

		switch (bf->bf_keytype) {
  90a511:	686213        	beqi	a6, 2, 90a528 <ath_tgt_tx_form_aggr+0x1b8>
  90a514:	6f6305        	bgeui	a6, 3, 90a51d <ath_tgt_tx_form_aggr+0x1ad>
  90a517:	686112        	beqi	a6, 1, 90a52d <ath_tgt_tx_form_aggr+0x1bd>
  90a51a:	60001a        	j	90a538 <ath_tgt_tx_form_aggr+0x1c8>
  90a51d:	68630c        	beqi	a6, 3, 90a52d <ath_tgt_tx_form_aggr+0x1bd>
		case HAL_KEY_TYPE_WEP:
		case HAL_KEY_TYPE_TKIP:
			bf->bf_ndelim += 64;
			break;
		case HAL_KEY_TYPE_WAPI:
			bf->bf_ndelim += 12;
  90a520:	bcaa      	addi.n	a10, a10, 12
		adf_os_assert(bf->bf_comp == ath_tgt_tx_comp_aggr);

		al += bpad + al_delta;
		bf->bf_ndelim = ATH_AGGR_GET_NDELIM(bf->bf_pktlen);

		switch (bf->bf_keytype) {
  90a522:	68640f        	beqi	a6, 4, 90a535 <ath_tgt_tx_form_aggr+0x1c5>
  90a525:	60000f        	j	90a538 <ath_tgt_tx_form_aggr+0x1c8>
		case HAL_KEY_TYPE_AES:
			bf->bf_ndelim += ATH_AGGR_ENCRYPTDELIM;
  90a528:	baaa      	addi.n	a10, a10, 10
  90a52a:	600007        	j	90a535 <ath_tgt_tx_form_aggr+0x1c5>
			break;
		case HAL_KEY_TYPE_WEP:
		case HAL_KEY_TYPE_TKIP:
			bf->bf_ndelim += 64;
  90a52d:	2aac40        	addi	a10, a10, 64
  90a530:	600001        	j	90a535 <ath_tgt_tx_form_aggr+0x1c5>
  90a533:	00002a        	muluh	a0, a0, a0
			break;
		case HAL_KEY_TYPE_WAPI:
			bf->bf_ndelim += 12;
  90a536:	444b26        	excw
			break;
		default:
			break;
		}

		bpad = PADBYTES(al_delta) + (bf->bf_ndelim << 2);
  90a539:	404b0c        	excw
  90a53c:	0c068a        	excw

		if (bf_prev) {
  90a53f:	180c0c        	l32r	a8, 8cd570 <_bss_end+0x3bfd68>
			break;
		default:
			break;
		}

		bpad = PADBYTES(al_delta) + (bf->bf_ndelim << 2);
  90a542:	410e66        	excw
  90a545:	11a6c6        	l32r	a1, 8f4060 <memset+0xeec4>
  90a548:	8c4c      	l32i.n	a12, a4, 48

		if (bf_prev) {
  90a54a:	c9aa      	beqz.n	a10, 90a568 <ath_tgt_tx_form_aggr+0x1f8>
			bf_prev->bf_next = bf;
  90a54c:	94ab      	s32i.n	a4, a10, 44
			bf_prev->bf_lastds->ds_link = ATH_BUF_GET_DESC_PHY_ADDR(bf);
  90a54e:	8aae      	l32i.n	a10, a10, 56
  90a550:	0c8b57        	extui	a11, a12, 24, 8
  90a553:	2ba400        	s8i	a11, a10, 0
  90a556:	2b4031        	l8ui	a11, a4, 49
  90a559:	2ba401        	s8i	a11, a10, 1
  90a55c:	2b4032        	l8ui	a11, a4, 50
  90a55f:	2ba402        	s8i	a11, a10, 2
  90a562:	2b4033        	l8ui	a11, a4, 51
  90a565:	2ba403        	s8i	a11, a10, 3
		}
		bf_prev = bf;

		for(ds = bf->bf_desc; ds <= bf->bf_lastds; ds++)
  90a568:	2d0a88        	movi	a13, 136
  90a56b:	600020        	j	90a58f <ath_tgt_tx_form_aggr+0x21f>
			ah->ah_set11nAggrMiddle(ds, bf->bf_ndelim);
  90a56e:	8f1b      	l32i.n	a15, a1, 44
  90a570:	2b404b        	l8ui	a11, a4, 75
  90a573:	2ef212        	l32i	a14, a15, 72
  90a576:	dac0      	mov.n	a10, a12
  90a578:	981f      	s32i.n	a8, a1, 60
  90a57a:	291610        	s32i	a9, a1, 64
  90a57d:	9c1e      	s32i.n	a12, a1, 56
  90a57f:	9d1d      	s32i.n	a13, a1, 52
  90a581:	0be000        	callx8	a14
			bf_prev->bf_next = bf;
			bf_prev->bf_lastds->ds_link = ATH_BUF_GET_DESC_PHY_ADDR(bf);
		}
		bf_prev = bf;

		for(ds = bf->bf_desc; ds <= bf->bf_lastds; ds++)
  90a584:	8c1e      	l32i.n	a12, a1, 56
  90a586:	8d1d      	l32i.n	a13, a1, 52
  90a588:	291210        	l32i	a9, a1, 64
  90a58b:	881f      	l32i.n	a8, a1, 60
  90a58d:	adcc      	add.n	a12, a12, a13
  90a58f:	8a4e      	l32i.n	a10, a4, 56
  90a591:	7cabd9        	bgeu	a10, a12, 90a56e <ath_tgt_tx_form_aggr+0x1fe>
  90a594:	9418      	s32i.n	a4, a1, 32
			ah->ah_set11nAggrMiddle(ds, bf->bf_ndelim);

	} while (!asf_tailq_empty(&tid->buf_q));
  90a596:	843b      	l32i.n	a4, a3, 44
  90a598:	c0d1      	movi.n	a13, 1
  90a59a:	654df6        	bnez	a4, 90a394 <ath_tgt_tx_form_aggr+0x24>

	bf_first->bf_al= al;
  90a59d:	259527        	s16i	a5, a9, 78
	bf_first->bf_nframes = nframes;
  90a5a0:	28944c        	s8i	a8, a9, 76

	return ATH_TGT_AGGR_DONE;
  90a5a3:	d240      	mov.n	a2, a4
  90a5a5:	d10f      	retw.n
  90a5a7:	008b19        	excw
			bf_first->bf_nframes = nframes;
			return ATH_TGT_AGGR_LIMITED;
		}

#ifdef PROJECT_K2
		if ((nframes + prev_frames) >= ATH_MIN((h_baw), 17)) {
  90a5aa:	c1a0      	movi.n	a10, 16
  90a5ac:	7ba302        	bltu	a10, a11, 90a5b2 <ath_tgt_tx_form_aggr+0x242>
  90a5af:	63fee7        	j	90a49a <ath_tgt_tx_form_aggr+0x12a>
  90a5b2:	63fef4        	j	90a4aa <ath_tgt_tx_form_aggr+0x13a>
  90a5b5:	000000        	ill

0090a5b8 <ath_tgt_txq_schedule>:
	asf_tailq_insert_tail(&txq->axq_tidq, tid, tid_qelem);
}

static void
ath_tgt_txq_schedule(struct ath_softc_tgt *sc, struct ath_txq *txq)
{
  90a5b8:	6c1008        	entry	a1, 64
	u_int8_t bdone;

	bdone = AH_FALSE;

	do {
		TAILQ_DEQ(&txq->axq_tidq, tid, tid_qelem);
  90a5bb:	8436      	l32i.n	a4, a3, 24
  90a5bd:	6441f3        	beqz	a4, 90a7b4 <ath_tgt_txq_schedule+0x1fc>
  90a5c0:	8549      	l32i.n	a5, a4, 36
  90a5c2:	864a      	l32i.n	a6, a4, 40
  90a5c4:	c854      	beqz.n	a5, 90a5cc <ath_tgt_txq_schedule+0x14>
  90a5c6:	965a      	s32i.n	a6, a5, 40
  90a5c8:	600002        	j	90a5ce <ath_tgt_txq_schedule+0x16>
  90a5cb:	009637        	maxu	a6, a9, a0
  90a5ce:	864a      	l32i.n	a6, a4, 40
  90a5d0:	9560      	s32i.n	a5, a6, 0
		if (tid == NULL)
			return;

		tid->sched = AH_FALSE;

		if (tid->paused)
  90a5d2:	264034        	l8ui	a6, a4, 52
		TAILQ_DEQ(&txq->axq_tidq, tid, tid_qelem);

		if (tid == NULL)
			return;

		tid->sched = AH_FALSE;
  90a5d5:	c050      	movi.n	a5, 0
  90a5d7:	254435        	s8i	a5, a4, 53

		if (tid->paused)
  90a5da:	006732        	sext	a7, a6, 7
  90a5dd:	c050      	movi.n	a5, 0
  90a5df:	757102        	beq	a7, a5, 90a5e5 <ath_tgt_txq_schedule+0x2d>
  90a5e2:	6001c2        	j	90a7a8 <ath_tgt_txq_schedule+0x1f0>
			continue;

		if (!(tid->flag & TID_AGGR_ENABLED))
  90a5e5:	264036        	l8ui	a6, a4, 54
  90a5e8:	c052      	movi.n	a5, 2
  90a5ea:	056601        	and	a6, a6, a5
  90a5ed:	c081      	movi.n	a8, 1
  90a5ef:	8540      	l32i.n	a5, a4, 0
  90a5f1:	656050        	bnez	a6, 90a645 <ath_tgt_txq_schedule+0x8d>

static void
ath_tgt_tx_sched_normal(struct ath_softc_tgt *sc, ath_atx_tid_t *tid)
{
	struct ath_tx_buf *bf;
	struct ath_txq *txq =TID_TO_ACTXQ(tid->tidno);;
  90a5f4:	d960      	mov.n	a9, a6
  90a5f6:	058939        	movnez	a9, a8, a5
  90a5f9:	c999      	beqz.n	a9, 90a616 <ath_tgt_txq_schedule+0x5e>
  90a5fb:	275cfd        	addi	a7, a5, -3
  90a5fe:	078639        	movnez	a6, a8, a7
  90a601:	c961      	beqz.n	a6, 90a616 <ath_tgt_txq_schedule+0x5e>
  90a603:	b056      	addi.n	a6, a5, -1
  90a605:	6e620f        	bltui	a6, 2, 90a618 <ath_tgt_txq_schedule+0x60>
  90a608:	255cfc        	addi	a5, a5, -4
  90a60b:	c082      	movi.n	a8, 2
  90a60d:	785307        	bltu	a5, a8, 90a618 <ath_tgt_txq_schedule+0x60>
  90a610:	c083      	movi.n	a8, 3
  90a612:	600002        	j	90a618 <ath_tgt_txq_schedule+0x60>
  90a615:	00c080        	excw
  90a618:	0e8811        	slli	a8, a8, 2
  90a61b:	288d05        	addmi	a8, a8, 0x500
  90a61e:	a828      	add.n	a8, a2, a8
  90a620:	8783      	l32i.n	a7, a8, 12

	do {
		if (asf_tailq_empty(&tid->buf_q))
  90a622:	8b4b      	l32i.n	a11, a4, 44
  90a624:	64b172        	beqz	a11, 90a79a <ath_tgt_txq_schedule+0x1e2>
			break;

		bf = asf_tailq_first(&tid->buf_q);
		asf_tailq_remove(&tid->buf_q, bf, bf_list);
  90a627:	85b9      	l32i.n	a5, a11, 36
  90a629:	86ba      	l32i.n	a6, a11, 40
  90a62b:	c853      	beqz.n	a5, 90a632 <ath_tgt_txq_schedule+0x7a>
  90a62d:	965a      	s32i.n	a6, a5, 40
  90a62f:	600001        	j	90a634 <ath_tgt_txq_schedule+0x7c>
  90a632:	964c      	s32i.n	a6, a4, 48
  90a634:	86ba      	l32i.n	a6, a11, 40
		ath_tgt_tx_send_normal(sc, bf);
  90a636:	da20      	mov.n	a10, a2
	do {
		if (asf_tailq_empty(&tid->buf_q))
			break;

		bf = asf_tailq_first(&tid->buf_q);
		asf_tailq_remove(&tid->buf_q, bf, bf_list);
  90a638:	9560      	s32i.n	a5, a6, 0
		ath_tgt_tx_send_normal(sc, bf);
  90a63a:	5bfdf2        	call8	909e04 <ath_tgt_tx_send_normal>

	} while (txq->axq_depth < ATH_AGGR_MIN_QDEPTH);
  90a63d:	8574      	l32i.n	a5, a7, 16
  90a63f:	645fdf        	beqz	a5, 90a622 <ath_tgt_txq_schedule+0x6a>
  90a642:	600154        	j	90a79a <ath_tgt_txq_schedule+0x1e2>
ath_tgt_tx_sched_aggr(struct ath_softc_tgt *sc, ath_atx_tid_t *tid)
{
	struct ath_tx_buf  *bf, *bf_last;
	ATH_AGGR_STATUS status;
	ath_tx_bufhead bf_q;
	struct ath_txq *txq = TID_TO_ACTXQ(tid->tidno);
  90a645:	d670      	mov.n	a6, a7
  90a647:	058639        	movnez	a6, a8, a5
  90a64a:	060647        	extui	a6, a6, 0, 8
  90a64d:	c96d      	beqz.n	a6, 90a66e <ath_tgt_txq_schedule+0xb6>
  90a64f:	265cfd        	addi	a6, a5, -3
  90a652:	d970      	mov.n	a9, a7
  90a654:	068939        	movnez	a9, a8, a6
  90a657:	090647        	extui	a6, a9, 0, 8
  90a65a:	c960      	beqz.n	a6, 90a66e <ath_tgt_txq_schedule+0xb6>
  90a65c:	b056      	addi.n	a6, a5, -1
  90a65e:	6e620e        	bltui	a6, 2, 90a670 <ath_tgt_txq_schedule+0xb8>
  90a661:	255cfc        	addi	a5, a5, -4
  90a664:	c082      	movi.n	a8, 2
  90a666:	785306        	bltu	a5, a8, 90a670 <ath_tgt_txq_schedule+0xb8>
  90a669:	c083      	movi.n	a8, 3
  90a66b:	600001        	j	90a670 <ath_tgt_txq_schedule+0xb8>
  90a66e:	c080      	movi.n	a8, 0
  90a670:	0e8811        	slli	a8, a8, 2
  90a673:	288d05        	addmi	a8, a8, 0x500
  90a676:	a828      	add.n	a8, a2, a8
  90a678:	8883      	l32i.n	a8, a8, 12
	struct ath_tx_desc *ds = NULL;
	struct ath_hal *ah = sc->sc_ah;
	int i;


	if (asf_tailq_empty(&tid->buf_q))
  90a67a:	864b      	l32i.n	a6, a4, 44
	struct ath_tx_buf  *bf, *bf_last;
	ATH_AGGR_STATUS status;
	ath_tx_bufhead bf_q;
	struct ath_txq *txq = TID_TO_ACTXQ(tid->tidno);
	struct ath_tx_desc *ds = NULL;
	struct ath_hal *ah = sc->sc_ah;
  90a67c:	252d05        	addmi	a5, a2, 0x500
ath_tgt_tx_sched_aggr(struct ath_softc_tgt *sc, ath_atx_tid_t *tid)
{
	struct ath_tx_buf  *bf, *bf_last;
	ATH_AGGR_STATUS status;
	ath_tx_bufhead bf_q;
	struct ath_txq *txq = TID_TO_ACTXQ(tid->tidno);
  90a67f:	9815      	s32i.n	a8, a1, 20
	struct ath_tx_desc *ds = NULL;
	struct ath_hal *ah = sc->sc_ah;
  90a681:	855b      	l32i.n	a5, a5, 44
	int i;


	if (asf_tailq_empty(&tid->buf_q))
  90a683:	646113        	beqz	a6, 90a79a <ath_tgt_txq_schedule+0x1e2>

	do {
		if (asf_tailq_empty(&tid->buf_q))
			break;

		asf_tailq_init(&bf_q);
  90a686:	c060      	movi.n	a6, 0

	if (asf_tailq_empty(&tid->buf_q))
		return;

	do {
		if (asf_tailq_empty(&tid->buf_q))
  90a688:	874b      	l32i.n	a7, a4, 44
  90a68a:	64710c        	beqz	a7, 90a79a <ath_tgt_txq_schedule+0x1e2>
			break;

		asf_tailq_init(&bf_q);

		status = ath_tgt_tx_form_aggr(sc, tid, &bf_q);
  90a68d:	dc10      	mov.n	a12, a1
  90a68f:	db40      	mov.n	a11, a4
  90a691:	da20      	mov.n	a10, a2

	do {
		if (asf_tailq_empty(&tid->buf_q))
			break;

		asf_tailq_init(&bf_q);
  90a693:	9610      	s32i.n	a6, a1, 0
  90a695:	9111      	s32i.n	a1, a1, 4

		status = ath_tgt_tx_form_aggr(sc, tid, &bf_q);
  90a697:	5bff36        	call8	90a370 <ath_tgt_tx_form_aggr>

		if (asf_tailq_empty(&bf_q))
  90a69a:	8710      	l32i.n	a7, a1, 0
		if (asf_tailq_empty(&tid->buf_q))
			break;

		asf_tailq_init(&bf_q);

		status = ath_tgt_tx_form_aggr(sc, tid, &bf_q);
  90a69c:	9a14      	s32i.n	a10, a1, 16

		if (asf_tailq_empty(&bf_q))
  90a69e:	6470f8        	beqz	a7, 90a79a <ath_tgt_txq_schedule+0x1e2>
			break;

		bf = asf_tailq_first(&bf_q);
		bf_last = asf_tailq_last(&bf_q, ath_tx_bufhead_s);

		if (bf->bf_nframes == 1) {
  90a6a1:	2a704c        	l8ui	a10, a7, 76
  90a6a4:	69a168        	bnei	a10, 1, 90a710 <ath_tgt_txq_schedule+0x158>

			if(bf->bf_retries == 0)
  90a6a7:	2a7086        	l8ui	a10, a7, 134
  90a6aa:	cca6      	bnez.n	a10, 90a6b4 <ath_tgt_txq_schedule+0xfc>
				__stats(sc, txaggr_single);
  90a6ac:	2a2261        	l32i	a10, a2, 0x184
  90a6af:	b1aa      	addi.n	a10, a10, 1
  90a6b1:	2a2661        	s32i	a10, a2, 0x184
			bf->bf_isaggr = 0;
  90a6b4:	2a7087        	l8ui	a10, a7, 135
  90a6b7:	2bfadf        	movi	a11, -33
  90a6ba:	0baa01        	and	a10, a10, a11
			bf->bf_lastds = &(bf->bf_descarr[bf->bf_dmamap_info.nsegs -1]);
  90a6bd:	8b71      	l32i.n	a11, a7, 4

		if (bf->bf_nframes == 1) {

			if(bf->bf_retries == 0)
				__stats(sc, txaggr_single);
			bf->bf_isaggr = 0;
  90a6bf:	2a7487        	s8i	a10, a7, 135
			bf->bf_lastds = &(bf->bf_descarr[bf->bf_dmamap_info.nsegs -1]);
  90a6c2:	0cba11        	slli	a10, a11, 4
  90a6c5:	abaa      	add.n	a10, a10, a11
  90a6c7:	0daa11        	slli	a10, a10, 3
  90a6ca:	2bfa78        	movi	a11, -136
  90a6cd:	abab      	add.n	a11, a10, a11
  90a6cf:	8a7d      	l32i.n	a10, a7, 52
			bf->bf_lastds->ds_link = 0;
			bf->bf_next = NULL;

			for(ds = bf->bf_desc; ds <= bf->bf_lastds; ds++)
  90a6d1:	2c0a88        	movi	a12, 136
		if (bf->bf_nframes == 1) {

			if(bf->bf_retries == 0)
				__stats(sc, txaggr_single);
			bf->bf_isaggr = 0;
			bf->bf_lastds = &(bf->bf_descarr[bf->bf_dmamap_info.nsegs -1]);
  90a6d4:	abaa      	add.n	a10, a10, a11
  90a6d6:	9a7e      	s32i.n	a10, a7, 56
			bf->bf_lastds->ds_link = 0;
  90a6d8:	26a400        	s8i	a6, a10, 0
  90a6db:	26a401        	s8i	a6, a10, 1
  90a6de:	26a402        	s8i	a6, a10, 2
  90a6e1:	26a403        	s8i	a6, a10, 3
			bf->bf_next = NULL;
  90a6e4:	967b      	s32i.n	a6, a7, 44

			for(ds = bf->bf_desc; ds <= bf->bf_lastds; ds++)
  90a6e6:	8b7c      	l32i.n	a11, a7, 48
  90a6e8:	600014        	j	90a700 <ath_tgt_txq_schedule+0x148>
  90a6eb:	002e52        	extui	a14, a0, 18, 3
				ah->ah_clr11nAggr(ds);
  90a6ee:	14dab0        	l32r	a4, 9011b0 <memset+0x1c014>
  90a6f1:	2b1607        	s32i	a11, a1, 28
  90a6f4:	2c1606        	s32i	a12, a1, 24
  90a6f7:	0be000        	callx8	a14
			bf->bf_isaggr = 0;
			bf->bf_lastds = &(bf->bf_descarr[bf->bf_dmamap_info.nsegs -1]);
			bf->bf_lastds->ds_link = 0;
			bf->bf_next = NULL;

			for(ds = bf->bf_desc; ds <= bf->bf_lastds; ds++)
  90a6fa:	8b17      	l32i.n	a11, a1, 28
  90a6fc:	8c16      	l32i.n	a12, a1, 24
  90a6fe:	acbb      	add.n	a11, a11, a12
  90a700:	8a7e      	l32i.n	a10, a7, 56
  90a702:	7babe6        	bgeu	a10, a11, 90a6ec <ath_tgt_txq_schedule+0x134>
				ah->ah_clr11nAggr(ds);

			ath_buf_set_rate(sc, bf);
  90a705:	db70      	mov.n	a11, a7
  90a707:	da20      	mov.n	a10, a2
  90a709:	5bfae3        	call8	909298 <ath_buf_set_rate>
  90a70c:	600071        	j	90a781 <ath_tgt_txq_schedule+0x1c9>
  90a70f:	008a11        	slli	a10, a8, 16

		bf_last->bf_next = NULL;
		bf_last->bf_lastds->ds_link = 0;
		bf_last->bf_ndelim = 0;

		bf->bf_isaggr  = 1;
  90a712:	c2b0      	movi.n	a11, 32

		if (asf_tailq_empty(&bf_q))
			break;

		bf = asf_tailq_first(&bf_q);
		bf_last = asf_tailq_last(&bf_q, ath_tx_bufhead_s);
  90a714:	8aa1      	l32i.n	a10, a10, 4
  90a716:	8ea0      	l32i.n	a14, a10, 0

			continue;
		}

		bf_last->bf_next = NULL;
		bf_last->bf_lastds->ds_link = 0;
  90a718:	8aee      	l32i.n	a10, a14, 56
			bf->bf_txq_add(sc, bf);

			continue;
		}

		bf_last->bf_next = NULL;
  90a71a:	96eb      	s32i.n	a6, a14, 44
		bf_last->bf_lastds->ds_link = 0;
  90a71c:	26a400        	s8i	a6, a10, 0
  90a71f:	26a401        	s8i	a6, a10, 1
  90a722:	26a402        	s8i	a6, a10, 2
  90a725:	26a403        	s8i	a6, a10, 3
		bf_last->bf_ndelim = 0;
  90a728:	26e44b        	s8i	a6, a14, 75

		bf->bf_isaggr  = 1;
  90a72b:	2a7087        	l8ui	a10, a7, 135
  90a72e:	0baa02        	or	a10, a10, a11
  90a731:	2a7487        	s8i	a10, a7, 135
		ath_buf_set_rate(sc, bf);
  90a734:	db70      	mov.n	a11, a7
  90a736:	da20      	mov.n	a10, a2
  90a738:	9e16      	s32i.n	a14, a1, 24
  90a73a:	5bfad7        	call8	909298 <ath_buf_set_rate>
		ah->ah_set11nAggrFirst(bf->bf_desc, bf->bf_al,
  90a73d:	2b7127        	l16ui	a11, a7, 78
  90a740:	2a720c        	l32i	a10, a7, 48
  90a743:	2f5211        	l32i	a15, a5, 68
  90a746:	2c704b        	l8ui	a12, a7, 75
  90a749:	0bf000        	callx8	a15
					  bf->bf_ndelim);
		bf->bf_lastds = bf_last->bf_lastds;
  90a74c:	8e16      	l32i.n	a14, a1, 24

		for (i = 0; i < bf_last->bf_dmamap_info.nsegs; i++)
  90a74e:	c0b0      	movi.n	a11, 0

		bf->bf_isaggr  = 1;
		ath_buf_set_rate(sc, bf);
		ah->ah_set11nAggrFirst(bf->bf_desc, bf->bf_al,
					  bf->bf_ndelim);
		bf->bf_lastds = bf_last->bf_lastds;
  90a750:	8aee      	l32i.n	a10, a14, 56
  90a752:	9a7e      	s32i.n	a10, a7, 56
  90a754:	60001c        	j	90a774 <ath_tgt_txq_schedule+0x1bc>
  90a757:	000cba        	excw

		for (i = 0; i < bf_last->bf_dmamap_info.nsegs; i++)
			ah->ah_set11nAggrLast(&bf_last->bf_descarr[i]);
  90a75a:	118fed        	l32r	a1, 8ee710 <memset+0x9574>
  90a75d:	abaa      	add.n	a10, a10, a11
  90a75f:	2c5213        	l32i	a12, a5, 76
  90a762:	0daa11        	slli	a10, a10, 3
  90a765:	9b17      	s32i.n	a11, a1, 28
  90a767:	9e16      	s32i.n	a14, a1, 24
  90a769:	aafa      	add.n	a10, a15, a10
  90a76b:	0bc000        	callx8	a12
		ath_buf_set_rate(sc, bf);
		ah->ah_set11nAggrFirst(bf->bf_desc, bf->bf_al,
					  bf->bf_ndelim);
		bf->bf_lastds = bf_last->bf_lastds;

		for (i = 0; i < bf_last->bf_dmamap_info.nsegs; i++)
  90a76e:	8b17      	l32i.n	a11, a1, 28
  90a770:	8e16      	l32i.n	a14, a1, 24
  90a772:	b1bb      	addi.n	a11, a11, 1
  90a774:	8ae1      	l32i.n	a10, a14, 4
  90a776:	7ab3de        	bltu	a11, a10, 90a758 <ath_tgt_txq_schedule+0x1a0>
			ah->ah_set11nAggrLast(&bf_last->bf_descarr[i]);

		if (status == ATH_AGGR_8K_LIMITED) {
  90a779:	8814      	l32i.n	a8, a1, 16
  90a77b:	698402        	bnei	a8, 4, 90a781 <ath_tgt_txq_schedule+0x1c9>
  90a77e:	63fffc        	j	90a77e <ath_tgt_txq_schedule+0x1c6>
			adf_os_assert(0);
			break;
		}

		bf->bf_txq_add(sc, bf);
  90a781:	2c7210        	l32i	a12, a7, 64
  90a784:	077b02        	or	a11, a7, a7
  90a787:	da20      	mov.n	a10, a2
  90a789:	0bc000        	callx8	a12
	} while (txq->axq_depth < ATH_AGGR_MIN_QDEPTH &&
		 status != ATH_TGT_AGGR_BAW_CLOSED);
  90a78c:	8915      	l32i.n	a9, a1, 20
  90a78e:	8894      	l32i.n	a8, a9, 16
			adf_os_assert(0);
			break;
		}

		bf->bf_txq_add(sc, bf);
	} while (txq->axq_depth < ATH_AGGR_MIN_QDEPTH &&
  90a790:	cc86      	bnez.n	a8, 90a79a <ath_tgt_txq_schedule+0x1e2>
  90a792:	8814      	l32i.n	a8, a1, 16
  90a794:	688102        	beqi	a8, 1, 90a79a <ath_tgt_txq_schedule+0x1e2>
  90a797:	63feed        	j	90a688 <ath_tgt_txq_schedule+0xd0>
		else
			ath_tgt_tx_sched_aggr(sc,tid);

		bdone = AH_TRUE;

		if (!asf_tailq_empty(&tid->buf_q)) {
  90a79a:	864b      	l32i.n	a6, a4, 44
		if (!(tid->flag & TID_AGGR_ENABLED))
			ath_tgt_tx_sched_normal(sc,tid);
		else
			ath_tgt_tx_sched_aggr(sc,tid);

		bdone = AH_TRUE;
  90a79c:	c051      	movi.n	a5, 1

		if (!asf_tailq_empty(&tid->buf_q)) {
  90a79e:	c866      	beqz.n	a6, 90a7a8 <ath_tgt_txq_schedule+0x1f0>
			ath_tgt_tx_enqueue(txq, tid);
  90a7a0:	db40      	mov.n	a11, a4
  90a7a2:	2a3c1c        	addi	a10, a3, 28
  90a7a5:	5bfa45        	call8	9090bc <ath_tgt_tx_enqueue$isra$3>
		}

	} while (!asf_tailq_empty(&txq->axq_tidq) && !bdone);
  90a7a8:	8736      	l32i.n	a7, a3, 24
  90a7aa:	c061      	movi.n	a6, 1
  90a7ac:	c874      	beqz.n	a7, 90a7b4 <ath_tgt_txq_schedule+0x1fc>
  90a7ae:	765102        	beq	a5, a6, 90a7b4 <ath_tgt_txq_schedule+0x1fc>
  90a7b1:	63fe06        	j	90a5bb <ath_tgt_txq_schedule+0x3>
  90a7b4:	d10f      	retw.n
	...

0090a7b8 <owltgt_tx_processq>:
	ath_tx_status_send(sc);
}

void owltgt_tx_processq(struct ath_softc_tgt *sc, struct ath_txq *txq,
			owl_txq_state_t txqstate)
{
  90a7b8:	6c1006        	entry	a1, 48
	struct ath_tx_buf *bf;
	struct ath_tx_desc *ds;
	struct ath_hal *ah = sc->sc_ah;
  90a7bb:	252d05        	addmi	a5, a2, 0x500
  90a7be:	865b      	l32i.n	a6, a5, 44
		bf = asf_tailq_first(&txq->axq_q);

		ds = bf->bf_lastds;
		status = ah->ah_procTxDesc(ah, ds);

		if (status == HAL_EINPROGRESS) {
  90a7c0:	c07f      	movi.n	a7, 15
	struct ath_tx_desc *ds;
	struct ath_hal *ah = sc->sc_ah;
	HAL_STATUS status;

	for (;;) {
		if (asf_tailq_empty(&txq->axq_q)) {
  90a7c2:	8532      	l32i.n	a5, a3, 8
  90a7c4:	cc54      	bnez.n	a5, 90a7cc <owltgt_tx_processq+0x14>
			txq->axq_link = NULL;
  90a7c6:	9531      	s32i.n	a5, a3, 4
			txq->axq_linkbuf = NULL;
  90a7c8:	9535      	s32i.n	a5, a3, 20
			break;
  90a7ca:	d10f      	retw.n
		}

		bf = asf_tailq_first(&txq->axq_q);

		ds = bf->bf_lastds;
  90a7cc:	885e      	l32i.n	a8, a5, 56
		status = ah->ah_procTxDesc(ah, ds);
  90a7ce:	29621a        	l32i	a9, a6, 104
  90a7d1:	db80      	mov.n	a11, a8
  90a7d3:	9810      	s32i.n	a8, a1, 0
  90a7d5:	da60      	mov.n	a10, a6
  90a7d7:	0b9000        	callx8	a9

		if (status == HAL_EINPROGRESS) {
  90a7da:	8810      	l32i.n	a8, a1, 0
  90a7dc:	77a91e        	bne	a10, a7, 90a7fe <owltgt_tx_processq+0x46>
			if (txqstate == OWL_TXQ_ACTIVE)
  90a7df:	644069        	beqz	a4, 90a84c <owltgt_tx_processq+0x94>
				break;
			else if (txqstate == OWL_TXQ_STOPPED) {
  90a7e2:	694112        	bnei	a4, 1, 90a7f8 <owltgt_tx_processq+0x40>
				__stats(sc, tx_stopfiltered);
  90a7e5:	292275        	l32i	a9, a2, 0x1d4
  90a7e8:	b199      	addi.n	a9, a9, 1
  90a7ea:	292675        	s32i	a9, a2, 0x1d4
				ds->ds_txstat.ts_flags  = 0;
  90a7ed:	c090      	movi.n	a9, 0
  90a7ef:	298467        	s8i	a9, a8, 103
				ds->ds_txstat.ts_status = HAL_OK;
  90a7f2:	298466        	s8i	a9, a8, 102
  90a7f5:	600005        	j	90a7fe <owltgt_tx_processq+0x46>
			} else {
				ds->ds_txstat.ts_flags  = HAL_TX_SW_FILTERED;
  90a7f8:	29fa80        	movi	a9, -128
  90a7fb:	298467        	s8i	a9, a8, 103
			}
		}

		ATH_TXQ_REMOVE_HEAD(txq, bf, bf_list);
  90a7fe:	8859      	l32i.n	a8, a5, 36
  90a800:	895a      	l32i.n	a9, a5, 40
  90a802:	c883      	beqz.n	a8, 90a809 <owltgt_tx_processq+0x51>
  90a804:	998a      	s32i.n	a9, a8, 40
  90a806:	600001        	j	90a80b <owltgt_tx_processq+0x53>
  90a809:	9933      	s32i.n	a9, a3, 12
  90a80b:	895a      	l32i.n	a9, a5, 40
  90a80d:	9890      	s32i.n	a8, a9, 0
  90a80f:	8834      	l32i.n	a8, a3, 16
  90a811:	b088      	addi.n	a8, a8, -1
  90a813:	9834      	s32i.n	a8, a3, 16
		if ((asf_tailq_empty(&txq->axq_q))) {
  90a815:	8832      	l32i.n	a8, a3, 8
  90a817:	cc8a      	bnez.n	a8, 90a825 <owltgt_tx_processq+0x6d>
			__stats(sc, tx_qnull);
  90a819:	29225c        	l32i	a9, a2, 0x170
  90a81c:	b199      	addi.n	a9, a9, 1
  90a81e:	29265c        	s32i	a9, a2, 0x170
			txq->axq_link = NULL;
  90a821:	9831      	s32i.n	a8, a3, 4
			txq->axq_linkbuf = NULL;
  90a823:	9835      	s32i.n	a8, a3, 20
		}

		if (bf->bf_comp) {
  90a825:	885f      	l32i.n	a8, a5, 60
			bf->bf_comp(sc, bf);
  90a827:	db50      	mov.n	a11, a5
  90a829:	da20      	mov.n	a10, a2
			__stats(sc, tx_qnull);
			txq->axq_link = NULL;
			txq->axq_linkbuf = NULL;
		}

		if (bf->bf_comp) {
  90a82b:	c884      	beqz.n	a8, 90a833 <owltgt_tx_processq+0x7b>
			bf->bf_comp(sc, bf);
  90a82d:	0b8000        	callx8	a8
  90a830:	600009        	j	90a83d <owltgt_tx_processq+0x85>
		} else {
			ath_tx_status_update(sc, bf);
  90a833:	5bfbee        	call8	9097ec <ath_tx_status_update>
			ath_buf_comp(sc, bf);
  90a836:	db50      	mov.n	a11, a5
  90a838:	da20      	mov.n	a10, a2
  90a83a:	5bfb4d        	call8	909570 <ath_buf_comp>
		}

		if (txqstate == OWL_TXQ_ACTIVE) {
  90a83d:	654f81        	bnez	a4, 90a7c2 <owltgt_tx_processq+0xa>
			ath_tgt_txq_schedule(sc, txq);
  90a840:	db30      	mov.n	a11, a3
  90a842:	022a02        	or	a10, a2, a2
  90a845:	5bff5c        	call8	90a5b8 <ath_tgt_txq_schedule>
  90a848:	63ff76        	j	90a7c2 <owltgt_tx_processq+0xa>
  90a84b:	00d10f        	subx8	a1, a13, a0
	...

0090a850 <owl_tgt_tx_tasklet>:
	owltgt_tx_processq(sc, txq, OWL_TXQ_ACTIVE);
	ah->ah_setInterrupts(ah, sc->sc_imask);
}

void owl_tgt_tx_tasklet(TQUEUE_ARG data)
{
  90a850:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)data;
	a_int32_t i;
	struct ath_txq *txq;

	ath_tx_status_clear(sc);
  90a853:	022a02        	or	a10, a2, a2
  90a856:	233acc        	movi	a3, 0x3cc
  90a859:	5bfbe0        	call8	9097dc <ath_tx_status_clear>
  90a85c:	032308        	add	a3, a2, a3

	for (i = 0; i < (HAL_NUM_TX_QUEUES - 6); i++) {
  90a85f:	240a00        	movi	a4, 0
		txq = ATH_TXQ(sc, i);

		if (ATH_TXQ_SETUP(sc, i)) {
  90a862:	262d03        	addmi	a6, a2, 0x300
  90a865:	2560c8        	l8ui	a5, a6, 200
  90a868:	004004        	ssr	a4
  90a86b:	05051b        	sra	a5, a5
  90a86e:	7f573b        	bbci	a5, 31, 90a8ad <owl_tgt_tx_tasklet+0x5d>
			if (txq == sc->sc_cabq)
  90a871:	252d05        	addmi	a5, a2, 0x500
  90a874:	885c      	l32i.n	a8, a5, 48
  90a876:	78392a        	bne	a3, a8, 90a8a4 <owl_tgt_tx_tasklet+0x54>
	}
}

static void owltgt_tx_process_cabq(struct ath_softc_tgt *sc, struct ath_txq *txq)
{
	struct ath_hal *ah = sc->sc_ah;
  90a879:	855b      	l32i.n	a5, a5, 44
	ah->ah_setInterrupts(ah, sc->sc_imask & ~HAL_INT_SWBA);
  90a87b:	197291        	l32r	a9, 8e72c0 <memset+0x2124>
  90a87e:	2b22c4        	l32i	a11, a2, 0x310
  90a881:	285228        	l32i	a8, a5, 160
  90a884:	09bb01        	and	a11, a11, a9
  90a887:	da50      	mov.n	a10, a5
  90a889:	0b8000        	callx8	a8
	owltgt_tx_processq(sc, txq, OWL_TXQ_ACTIVE);
  90a88c:	db30      	mov.n	a11, a3
  90a88e:	da20      	mov.n	a10, a2
  90a890:	c0c0      	movi.n	a12, 0
  90a892:	5bffc9        	call8	90a7b8 <owltgt_tx_processq>
	ah->ah_setInterrupts(ah, sc->sc_imask);
  90a895:	285228        	l32i	a8, a5, 160
  90a898:	2b22c4        	l32i	a11, a2, 0x310
  90a89b:	da50      	mov.n	a10, a5
  90a89d:	0b8000        	callx8	a8
  90a8a0:	600009        	j	90a8ad <owl_tgt_tx_tasklet+0x5d>
  90a8a3:	00c0c0        	excw

		if (ATH_TXQ_SETUP(sc, i)) {
			if (txq == sc->sc_cabq)
				owltgt_tx_process_cabq(sc, txq);
			else
				owltgt_tx_processq(sc, txq, OWL_TXQ_ACTIVE);
  90a8a6:	db30      	mov.n	a11, a3
  90a8a8:	da20      	mov.n	a10, a2
  90a8aa:	5bffc3        	call8	90a7b8 <owltgt_tx_processq>
	a_int32_t i;
	struct ath_txq *txq;

	ath_tx_status_clear(sc);

	for (i = 0; i < (HAL_NUM_TX_QUEUES - 6); i++) {
  90a8ad:	b144      	addi.n	a4, a4, 1
  90a8af:	233c20        	addi	a3, a3, 32
  90a8b2:	6944af        	bnei	a4, 4, 90a865 <owl_tgt_tx_tasklet+0x15>
			else
				owltgt_tx_processq(sc, txq, OWL_TXQ_ACTIVE);
		}
	}

	ath_tx_status_send(sc);
  90a8b5:	da20      	mov.n	a10, a2
  90a8b7:	5bfc26        	call8	909950 <ath_tx_status_send>
  90a8ba:	d10f      	retw.n

0090a8bc <ath_aggr_resume_tid>:
	return ((((x) & 0xff00) >> 8) |   (((x) & 0x00ff) << 8));
}

static inline void
ath_aggr_resume_tid(struct ath_softc_tgt *sc, ath_atx_tid_t *tid)
{
  90a8bc:	6c1004        	entry	a1, 32
	struct ath_txq *txq;

	txq = TID_TO_ACTXQ(tid->tidno);
  90a8bf:	8930      	l32i.n	a9, a3, 0
	return ((((x) & 0xff00) >> 8) |   (((x) & 0x00ff) << 8));
}

static inline void
ath_aggr_resume_tid(struct ath_softc_tgt *sc, ath_atx_tid_t *tid)
{
  90a8c1:	db30      	mov.n	a11, a3
	struct ath_txq *txq;

	txq = TID_TO_ACTXQ(tid->tidno);
  90a8c3:	c997      	beqz.n	a9, 90a8de <ath_aggr_resume_tid+0x22>
  90a8c5:	689315        	beqi	a9, 3, 90a8de <ath_aggr_resume_tid+0x22>
  90a8c8:	b09a      	addi.n	a10, a9, -1
  90a8ca:	c081      	movi.n	a8, 1
  90a8cc:	6ea210        	bltui	a10, 2, 90a8e0 <ath_aggr_resume_tid+0x24>
  90a8cf:	299cfc        	addi	a9, a9, -4
  90a8d2:	c082      	movi.n	a8, 2
  90a8d4:	789308        	bltu	a9, a8, 90a8e0 <ath_aggr_resume_tid+0x24>
  90a8d7:	c083      	movi.n	a8, 3
  90a8d9:	600003        	j	90a8e0 <ath_aggr_resume_tid+0x24>
  90a8dc:	0000c0        	excw
  90a8df:	800e      	l32i.n	a0, a0, 56
  90a8e1:	8811      	l32i.n	a8, a1, 4
  90a8e3:	288d05        	addmi	a8, a8, 0x500
  90a8e6:	a828      	add.n	a8, a2, a8
  90a8e8:	8383      	l32i.n	a3, a8, 12
	tid->paused = 0;
  90a8ea:	c080      	movi.n	a8, 0
  90a8ec:	28b434        	s8i	a8, a11, 52

	if (asf_tailq_empty(&tid->buf_q))
  90a8ef:	88bb      	l32i.n	a8, a11, 44
  90a8f1:	c88b      	beqz.n	a8, 90a900 <ath_aggr_resume_tid+0x44>
		return;

	ath_tgt_tx_enqueue(txq, tid);
  90a8f3:	2a3c1c        	addi	a10, a3, 28
  90a8f6:	5bf9f1        	call8	9090bc <ath_tgt_tx_enqueue$isra$3>
	ath_tgt_txq_schedule(sc, txq);
  90a8f9:	db30      	mov.n	a11, a3
  90a8fb:	da20      	mov.n	a10, a2
  90a8fd:	5bff2e        	call8	90a5b8 <ath_tgt_txq_schedule>
  90a900:	d10f      	retw.n
	...

0090a904 <owl_tgt_tid_cleanup>:
	}
}

static void owl_tgt_tid_cleanup(struct ath_softc_tgt *sc,
				struct ath_atx_tid *tid)
{
  90a904:	6c1004        	entry	a1, 32
	tid->incomp--;
  90a907:	283037        	l8ui	a8, a3, 55
	}
}

static void owl_tgt_tid_cleanup(struct ath_softc_tgt *sc,
				struct ath_atx_tid *tid)
{
  90a90a:	da20      	mov.n	a10, a2
	tid->incomp--;
  90a90c:	b088      	addi.n	a8, a8, -1
  90a90e:	080847        	extui	a8, a8, 0, 8
  90a911:	283437        	s8i	a8, a3, 55
	if (tid->incomp) {
  90a914:	cf85      	bnez.n	a8, 90a94d <owl_tgt_tid_cleanup+0x49>
		return;
	}

	tid->flag &= ~TID_CLEANUP_INPROGRES;
  90a916:	293036        	l8ui	a9, a3, 54
  90a919:	28fafe        	movi	a8, -2
  90a91c:	089801        	and	a8, a9, a8
  90a91f:	283436        	s8i	a8, a3, 54

	if (tid->flag & TID_REINITIALIZE) {
  90a922:	7d9722        	bbci	a9, 29, 90a948 <owl_tgt_tid_cleanup+0x44>
		adf_os_print("TID REINIT DONE for tid %p\n", tid);
  90a925:	18716e        	l32r	a8, 8e6ee0 <memset+0x1d44>
  90a928:	1a72b4        	l32r	a10, 8e73f8 <memset+0x225c>
  90a92b:	288212        	l32i	a8, a8, 72
  90a92e:	033b02        	or	a11, a3, a3
  90a931:	0b8000        	callx8	a8
		tid->flag  &= ~TID_REINITIALIZE;
  90a934:	283036        	l8ui	a8, a3, 54
  90a937:	c79b      	movi.n	a9, -5
  90a939:	098801        	and	a8, a8, a9
  90a93c:	283436        	s8i	a8, a3, 54
		owl_tgt_tid_init(tid);
  90a93f:	da30      	mov.n	a10, a3
  90a941:	5bf97d        	call8	908f38 <owl_tgt_tid_init>
  90a944:	d10f      	retw.n
  90a946:	0000db        	excw
	} else {
		ath_aggr_resume_tid(sc, tid);
  90a949:	305bff        	excw
  90a94c:	dcd1      	excw
  90a94e:	0f          	.byte 0xf
	...

0090a950 <ath_tgt_tx_comp_normal>:
	tid->baw_tail = tid->baw_head;
}

static void ath_tgt_tx_comp_normal(struct ath_softc_tgt *sc,
				   struct ath_tx_buf *bf)
{
  90a950:	6c1004        	entry	a1, 32
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90a953:	2a304d        	l8ui	a10, a3, 77
}

static void ath_tgt_tx_comp_normal(struct ath_softc_tgt *sc,
				   struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
  90a956:	8b34      	l32i.n	a11, a3, 16
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);

	if (tid->flag & TID_CLEANUP_INPROGRES) {
  90a958:	0ca911        	slli	a9, a10, 4
  90a95b:	0a990c        	sub	a9, a9, a10
  90a95e:	0e9911        	slli	a9, a9, 2
  90a961:	a9b9      	add.n	a9, a11, a9
  90a963:	28905a        	l8ui	a8, a9, 90
  90a966:	7f8714        	bbci	a8, 31, 90a97e <ath_tgt_tx_comp_normal+0x2e>

static void ath_tgt_tx_comp_normal(struct ath_softc_tgt *sc,
				   struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90a969:	0ca811        	slli	a8, a10, 4
  90a96c:	0a880c        	sub	a8, a8, a10
  90a96f:	0e8811        	slli	a8, a8, 2
  90a972:	288c24        	addi	a8, a8, 36

	if (tid->flag & TID_CLEANUP_INPROGRES) {
		owl_tgt_tid_cleanup(sc, tid);
  90a975:	08bb08        	add	a11, a11, a8
  90a978:	022a02        	or	a10, a2, a2
  90a97b:	5bffe2        	call8	90a904 <owl_tgt_tid_cleanup>
	}

	if (bf->bf_node) {
  90a97e:	8834      	l32i.n	a8, a3, 16
  90a980:	c98d      	beqz.n	a8, 90a9a1 <ath_tgt_tx_comp_normal+0x51>
}

static void
ath_tx_uc_comp(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	ath_tx_status_update(sc, bf);
  90a982:	db30      	mov.n	a11, a3
  90a984:	da20      	mov.n	a10, a2
  90a986:	5bfb99        	call8	9097ec <ath_tx_status_update>
	ath_update_stats(sc, bf);
  90a989:	8b3c      	l32i.n	a11, a3, 48
  90a98b:	da20      	mov.n	a10, a2
  90a98d:	5bf9b3        	call8	90905c <ath_update_stats$isra$1>
	ath_rate_tx_complete(sc, ATH_NODE_TARGET(bf->bf_node),
  90a990:	8c3e      	l32i.n	a12, a3, 56
  90a992:	8b34      	l32i.n	a11, a3, 16
  90a994:	c0f0      	movi.n	a15, 0
  90a996:	c0e1      	movi.n	a14, 1
  90a998:	2d3c50        	addi	a13, a3, 80
  90a99b:	022a02        	or	a10, a2, a2
  90a99e:	5bf92d        	call8	908e54 <ath_rate_tx_complete>

	if (bf->bf_node) {
		ath_tx_uc_comp(sc, bf);
	}

	ath_tx_freebuf(sc, bf);
  90a9a1:	db30      	mov.n	a11, a3
  90a9a3:	da20      	mov.n	a10, a2
  90a9a5:	5bfb01        	call8	9095ac <ath_tx_freebuf>
  90a9a8:	d10f      	retw.n
	...

0090a9ac <ath_tgt_tx_comp_aggr>:
		INCR(tid->baw_tail, ATH_TID_MAX_BUFS);
	}
}

void ath_tgt_tx_comp_aggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90a9ac:	6c1024        	entry	a1, 0x120
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90a9af:	27304d        	l8ui	a7, a3, 77
	}
}

void ath_tgt_tx_comp_aggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
  90a9b2:	8434      	l32i.n	a4, a3, 16
  90a9b4:	0c7511        	slli	a5, a7, 4
  90a9b7:	07550c        	sub	a5, a5, a7
  90a9ba:	0e5511        	slli	a5, a5, 2
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90a9bd:	265c24        	addi	a6, a5, 36
  90a9c0:	251635        	s32i	a5, a1, 212
	struct ath_rc_series rcs[4];
	u_int16_t seq_st;
	u_int32_t *ba;
	int ba_index;
	int nbad = 0;
	int nframes = bf->bf_nframes;
  90a9c3:	25304c        	l8ui	a5, a3, 76
}

void ath_tgt_tx_comp_aggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90a9c6:	a646      	add.n	a6, a4, a6
	struct ath_rc_series rcs[4];
	u_int16_t seq_st;
	u_int32_t *ba;
	int ba_index;
	int nbad = 0;
	int nframes = bf->bf_nframes;
  90a9c8:	251634        	s32i	a5, a1, 208
	struct ath_tx_buf *bf_next;
	ath_tx_bufhead bf_q;
	int tx_ok = 1;
	struct ath_tx_buf *bar = NULL;
  90a9cb:	c050      	movi.n	a5, 0
  90a9cd:	251630        	s32i	a5, a1, 192
	struct ath_txq *txq;

	txq = bf->bf_txq;

	if (tid->flag & TID_CLEANUP_INPROGRES) {
  90a9d0:	0c7511        	slli	a5, a7, 4
  90a9d3:	075d0c        	sub	a13, a5, a7
  90a9d6:	0ed911        	slli	a9, a13, 2
  90a9d9:	a949      	add.n	a9, a4, a9
  90a9db:	28905a        	l8ui	a8, a9, 90
  90a9de:	253c50        	addi	a5, a3, 80
  90a9e1:	080840        	extui	a8, a8, 0, 1
  90a9e4:	6480ed        	beqz	a8, 90aad5 <ath_tgt_tx_comp_aggr+0x129>
  90a9e7:	2b320e        	l32i	a11, a3, 56
  90a9ea:	2c0a88        	movi	a12, 136
  90a9ed:	da10      	mov.n	a10, a1
  90a9ef:	29163d        	s32i	a9, a1, 244
  90a9f2:	2d163b        	s32i	a13, a1, 236
  90a9f5:	5bf937        	call8	908ed4 <__adf_os_mem_copy>
  90a9f8:	280a88        	movi	a8, 136
  90a9fb:	a817      	add.n	a7, a1, a8
  90a9fd:	055b02        	or	a11, a5, a5
  90aa00:	2c0a30        	movi	a12, 48
  90aa03:	077a02        	or	a10, a7, a7
  90aa06:	5bf933        	call8	908ed4 <__adf_os_mem_copy>

	seq_st = ATH_DS_BA_SEQ(ds);
	ba     = ATH_DS_BA_BITMAP(ds);
	tx_ok  = (ATH_DS_TX_STATUS(ds) == HAL_OK);

	if (!bf->bf_isaggr) {
  90aa09:	253221        	l32i	a5, a3, 132
  90aa0c:	29123d        	l32i	a9, a1, 244
  90aa0f:	2d123b        	l32i	a13, a1, 236
  90aa12:	7a5f34        	bbsi	a5, 26, 90aa4a <ath_tgt_tx_comp_aggr+0x9e>
		ath_update_stats(sc, bf);
  90aa15:	8b3c      	l32i.n	a11, a3, 48
  90aa17:	022a02        	or	a10, a2, a2
  90aa1a:	5bf990        	call8	90905c <ath_update_stats$isra$1>

		__stats(sc, tx_compunaggr);
  90aa1d:	24225e        	l32i	a4, a2, 0x178

		ath_tx_status_update(sc, bf);
  90aa20:	db30      	mov.n	a11, a3
	tx_ok  = (ATH_DS_TX_STATUS(ds) == HAL_OK);

	if (!bf->bf_isaggr) {
		ath_update_stats(sc, bf);

		__stats(sc, tx_compunaggr);
  90aa22:	244c01        	addi	a4, a4, 1

		ath_tx_status_update(sc, bf);
  90aa25:	022a02        	or	a10, a2, a2
	tx_ok  = (ATH_DS_TX_STATUS(ds) == HAL_OK);

	if (!bf->bf_isaggr) {
		ath_update_stats(sc, bf);

		__stats(sc, tx_compunaggr);
  90aa28:	24265e        	s32i	a4, a2, 0x178

		ath_tx_status_update(sc, bf);
  90aa2b:	5bfb70        	call8	9097ec <ath_tx_status_update>

		ath_tx_freebuf(sc, bf);
  90aa2e:	db30      	mov.n	a11, a3
  90aa30:	da20      	mov.n	a10, a2
  90aa32:	5bfade        	call8	9095ac <ath_tx_freebuf>

		if (tid->flag & TID_CLEANUP_INPROGRES) {
  90aa35:	29123d        	l32i	a9, a1, 244
  90aa38:	23905a        	l8ui	a3, a9, 90
  90aa3b:	7f3f02        	bbsi	a3, 31, 90aa41 <ath_tgt_tx_comp_aggr+0x95>
  90aa3e:	600350        	j	90ad92 <ath_tgt_tx_comp_aggr+0x3e6>
			owl_tgt_tid_cleanup(sc, tid);
  90aa41:	db60      	mov.n	a11, a6
  90aa43:	da20      	mov.n	a10, a2
  90aa45:	5bffaf        	call8	90a904 <owl_tgt_tid_cleanup>
  90aa48:	d10f      	retw.n

	while (bf) {
		ba_index = ATH_BA_INDEX(seq_st, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
		bf_next  = bf->bf_next;

		ath_tx_status_update_aggr(sc, bf, ds, rcs, 0);
  90aa4a:	d870      	mov.n	a8, a7

		ath_tx_freebuf(sc, bf);

		tid->incomp--;
  90aa4c:	d5d0      	mov.n	a5, a13
  90aa4e:	099702        	or	a7, a9, a9
  90aa51:	299c5b        	addi	a9, a9, 91
		return;
	}

	while (bf) {
		ba_index = ATH_BA_INDEX(seq_st, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
		bf_next  = bf->bf_next;
  90aa54:	8f3b      	l32i.n	a15, a3, 44

		ath_tx_status_update_aggr(sc, bf, ds, rcs, 0);
  90aa56:	dd80      	mov.n	a13, a8
  90aa58:	db30      	mov.n	a11, a3
  90aa5a:	c0e0      	movi.n	a14, 0
  90aa5c:	dc10      	mov.n	a12, a1
  90aa5e:	022a02        	or	a10, a2, a2
  90aa61:	28163c        	s32i	a8, a1, 240
  90aa64:	29163d        	s32i	a9, a1, 244
  90aa67:	2f163b        	s32i	a15, a1, 236
  90aa6a:	5bfb91        	call8	9098b0 <ath_tx_status_update_aggr>

		ath_tx_freebuf(sc, bf);
  90aa6d:	db30      	mov.n	a11, a3
  90aa6f:	da20      	mov.n	a10, a2
  90aa71:	5bface        	call8	9095ac <ath_tx_freebuf>

		tid->incomp--;
  90aa74:	29123d        	l32i	a9, a1, 244
		if (!tid->incomp) {
  90aa77:	28123c        	l32i	a8, a1, 240

		ath_tx_status_update_aggr(sc, bf, ds, rcs, 0);

		ath_tx_freebuf(sc, bf);

		tid->incomp--;
  90aa7a:	239000        	l8ui	a3, a9, 0
		if (!tid->incomp) {
  90aa7d:	2f123b        	l32i	a15, a1, 236

		ath_tx_status_update_aggr(sc, bf, ds, rcs, 0);

		ath_tx_freebuf(sc, bf);

		tid->incomp--;
  90aa80:	b033      	addi.n	a3, a3, -1
  90aa82:	030347        	extui	a3, a3, 0, 8
  90aa85:	239400        	s8i	a3, a9, 0
		if (!tid->incomp) {
  90aa88:	cd38      	bnez.n	a3, 90aaa4 <ath_tgt_tx_comp_aggr+0xf8>
			tid->flag  &= ~TID_CLEANUP_INPROGRES;
  90aa8a:	0e5511        	slli	a5, a5, 2
  90aa8d:	a545      	add.n	a5, a4, a5
  90aa8f:	23505a        	l8ui	a3, a5, 90
  90aa92:	c75e      	movi.n	a5, -2
  90aa94:	053301        	and	a3, a3, a5
  90aa97:	23745a        	s8i	a3, a7, 90
			ath_aggr_resume_tid(sc, tid);
  90aa9a:	db60      	mov.n	a11, a6
  90aa9c:	da20      	mov.n	a10, a2
  90aa9e:	5bff87        	call8	90a8bc <ath_aggr_resume_tid>
  90aaa1:	600005        	j	90aaaa <ath_tgt_tx_comp_aggr+0xfe>
  90aaa4:	0ff302        	or	a3, a15, a15
		}

		return;
	}

	while (bf) {
  90aaa7:	65ffa9        	bnez	a15, 90aa54 <ath_tgt_tx_comp_aggr+0xa8>
		}

		bf = bf_next;
	}

	ath_update_aggr_stats(sc, ds, nframes, nbad);
  90aaaa:	2e1071        	l8ui	a14, a1, 113
  90aaad:	2d1070        	l8ui	a13, a1, 112
  90aab0:	2c1067        	l8ui	a12, a1, 103
  90aab3:	2b1066        	l8ui	a11, a1, 102
  90aab6:	022a02        	or	a10, a2, a2
  90aab9:	5bf989        	call8	9090e0 <ath_update_aggr_stats$isra$5>
	ath_rate_tx_complete(sc, an, ds, rcs, nframes, nbad);
  90aabc:	2e1234        	l32i	a14, a1, 208
  90aabf:	2d0a88        	movi	a13, 136
  90aac2:	c0f0      	movi.n	a15, 0
  90aac4:	ad1d      	add.n	a13, a1, a13
  90aac6:	dc10      	mov.n	a12, a1
  90aac8:	db40      	mov.n	a11, a4
  90aaca:	022a02        	or	a10, a2, a2
  90aacd:	5bf8e1        	call8	908e54 <ath_rate_tx_complete>
  90aad0:	d10f      	retw.n
  90aad2:	000000        	ill
	ath_tx_bufhead bf_q;
	int tx_ok = 1;
	struct ath_tx_buf *bar = NULL;
	struct ath_txq *txq;

	txq = bf->bf_txq;
  90aad5:	293220        	l32i	a9, a3, 128
  90aad8:	8b3e      	l32i.n	a11, a3, 56
  90aada:	2c0a88        	movi	a12, 136
  90aadd:	da10      	mov.n	a10, a1
  90aadf:	291636        	s32i	a9, a1, 216
  90aae2:	28163c        	s32i	a8, a1, 240
  90aae5:	5bf8fb        	call8	908ed4 <__adf_os_mem_copy>
  90aae8:	2a0a88        	movi	a10, 136
  90aaeb:	c3c0      	movi.n	a12, 48
  90aaed:	db50      	mov.n	a11, a5
  90aaef:	aa1a      	add.n	a10, a1, a10
  90aaf1:	5bf8f8        	call8	908ed4 <__adf_os_mem_copy>
	}

	adf_os_mem_copy(ds, bf->bf_lastds, sizeof (struct ath_tx_desc));
	adf_os_mem_copy(rcs, bf->bf_rcs, sizeof(rcs));

	if (ds->ds_txstat.ts_flags == HAL_TX_SW_FILTERED) {
  90aaf4:	291067        	l8ui	a9, a1, 103
  90aaf7:	28123c        	l32i	a8, a1, 240
  90aafa:	699e02        	bnei	a9, 128, 90ab00 <ath_tgt_tx_comp_aggr+0x154>
  90aafd:	63fffc        	j	90aafd <ath_tgt_tx_comp_aggr+0x151>
		adf_os_assert(0);
		return;
	}

	if (!bf->bf_isaggr) {
  90ab00:	2a3221        	l32i	a10, a3, 132
  90ab03:	c2f0      	movi.n	a15, 32
  90ab05:	0aff01        	and	a15, a15, a10
  90ab08:	65f12c        	bnez	a15, 90ac38 <ath_tgt_tx_comp_aggr+0x28c>
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
	struct ath_tx_desc *ds  = bf->bf_lastds;

	ath_update_stats(sc, bf);
  90ab0b:	8b3c      	l32i.n	a11, a3, 48
  90ab0d:	da20      	mov.n	a10, a2
static void
ath_tx_comp_unaggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
	struct ath_tx_desc *ds  = bf->bf_lastds;
  90ab0f:	863e      	l32i.n	a6, a3, 56
}

static void
ath_tx_comp_unaggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
  90ab11:	8434      	l32i.n	a4, a3, 16
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90ab13:	27304d        	l8ui	a7, a3, 77
	struct ath_tx_desc *ds  = bf->bf_lastds;

	ath_update_stats(sc, bf);
  90ab16:	2f163b        	s32i	a15, a1, 236
  90ab19:	5bf950        	call8	90905c <ath_update_stats$isra$1>
	ath_rate_tx_complete(sc, an, ds, bf->bf_rcs, 1, 0);
  90ab1c:	2f123b        	l32i	a15, a1, 236
  90ab1f:	dd50      	mov.n	a13, a5
  90ab21:	c0e1      	movi.n	a14, 1
  90ab23:	dc60      	mov.n	a12, a6
  90ab25:	db40      	mov.n	a11, a4
  90ab27:	da20      	mov.n	a10, a2
  90ab29:	5bf8ca        	call8	908e54 <ath_rate_tx_complete>

	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
  90ab2c:	256066        	l8ui	a5, a6, 102
  90ab2f:	7f5f02        	bbsi	a5, 31, 90ab35 <ath_tgt_tx_comp_aggr+0x189>
  90ab32:	6000cf        	j	90ac05 <ath_tgt_tx_comp_aggr+0x259>

static inline void
ath_tx_retry_unaggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90ab35:	26304d        	l8ui	a6, a3, 77
	struct ath_txq *txq;

	txq = bf->bf_txq;
  90ab38:	283220        	l32i	a8, a3, 128
  90ab3b:	0c6411        	slli	a4, a6, 4
  90ab3e:	06440c        	sub	a4, a4, a6
}

static inline void
ath_tx_retry_unaggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
  90ab41:	8734      	l32i.n	a7, a3, 16
  90ab43:	0e4411        	slli	a4, a4, 2
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
	struct ath_txq *txq;

	txq = bf->bf_txq;
  90ab46:	281634        	s32i	a8, a1, 208

	if (bf->bf_retries >= OWLMAX_RETRIES) {
  90ab49:	283086        	l8ui	a8, a3, 134

static inline void
ath_tx_retry_unaggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90ab4c:	254c24        	addi	a5, a4, 36
	struct ath_txq *txq;

	txq = bf->bf_txq;

	if (bf->bf_retries >= OWLMAX_RETRIES) {
  90ab4f:	c0a9      	movi.n	a10, 9

static inline void
ath_tx_retry_unaggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90ab51:	a575      	add.n	a5, a7, a5
	struct ath_txq *txq;

	txq = bf->bf_txq;

	if (bf->bf_retries >= OWLMAX_RETRIES) {
  90ab53:	78ab26        	bgeu	a10, a8, 90ab7d <ath_tgt_tx_comp_aggr+0x1d1>
		__stats(sc, txunaggr_xretry);
  90ab56:	242273        	l32i	a4, a2, 0x1cc
		ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90ab59:	2b3123        	l16ui	a11, a3, 70
	struct ath_txq *txq;

	txq = bf->bf_txq;

	if (bf->bf_retries >= OWLMAX_RETRIES) {
		__stats(sc, txunaggr_xretry);
  90ab5c:	b144      	addi.n	a4, a4, 1
		ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90ab5e:	da50      	mov.n	a10, a5
	struct ath_txq *txq;

	txq = bf->bf_txq;

	if (bf->bf_retries >= OWLMAX_RETRIES) {
		__stats(sc, txunaggr_xretry);
  90ab60:	242673        	s32i	a4, a2, 0x1cc
		ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90ab63:	0b4b14        	srli	a11, a11, 4
  90ab66:	5bf925        	call8	908ffc <ath_tx_update_baw>
		ath_tx_status_update(sc, bf);
  90ab69:	db30      	mov.n	a11, a3
  90ab6b:	da20      	mov.n	a10, a2
  90ab6d:	5bfb1f        	call8	9097ec <ath_tx_status_update>
		ath_bar_tx(sc, tid, bf);
  90ab70:	dc30      	mov.n	a12, a3
  90ab72:	db50      	mov.n	a11, a5
  90ab74:	da20      	mov.n	a10, a2
  90ab76:	5bfaae        	call8	909630 <ath_bar_tx>
  90ab79:	d10f      	retw.n
  90ab7b:	000028        	mull	a0, a0, a0
		return;
	}

	__stats(sc, txunaggr_compretries);
  90ab7e:	226d8b        	addmi	a2, a6, 0xffff8b00
	if (!bf->bf_lastds->ds_link) {
  90ab81:	3eb188        	excw
		ath_tx_status_update(sc, bf);
		ath_bar_tx(sc, tid, bf);
		return;
	}

	__stats(sc, txunaggr_compretries);
  90ab84:	28266d        	s32i	a8, a2, 0x1b4
	if (!bf->bf_lastds->ds_link) {
  90ab87:	2ab000        	l8ui	a10, a11, 0
  90ab8a:	28b001        	l8ui	a8, a11, 1
  90ab8d:	08aa10        	slli	a10, a10, 24
  90ab90:	008811        	slli	a8, a8, 16
  90ab93:	0a8a02        	or	a10, a8, a10
  90ab96:	28b002        	l8ui	a8, a11, 2
  90ab99:	088811        	slli	a8, a8, 8
  90ab9c:	0a8802        	or	a8, a8, a10
  90ab9f:	2ab003        	l8ui	a10, a11, 3
  90aba2:	08a802        	or	a8, a10, a8
  90aba5:	cd83      	bnez.n	a8, 90abbc <ath_tgt_tx_comp_aggr+0x210>
		__stats(sc, txunaggr_errlast);
  90aba7:	282272        	l32i	a8, a2, 0x1c8
		bf = ath_buf_toggle(sc, bf, 1);
  90abaa:	db30      	mov.n	a11, a3
		return;
	}

	__stats(sc, txunaggr_compretries);
	if (!bf->bf_lastds->ds_link) {
		__stats(sc, txunaggr_errlast);
  90abac:	b188      	addi.n	a8, a8, 1
  90abae:	282672        	s32i	a8, a2, 0x1c8
		bf = ath_buf_toggle(sc, bf, 1);
  90abb1:	2c0a01        	movi	a12, 1
  90abb4:	022a02        	or	a10, a2, a2
  90abb7:	5bfa3b        	call8	9094a4 <ath_buf_toggle>
  90abba:	d3a0      	mov.n	a3, a10
	}

	ath_tx_set_retry(sc, bf);
  90abbc:	2a1a80        	movi	a10, 0x180
  90abbf:	0a2a08        	add	a10, a2, a10
  90abc2:	033b02        	or	a11, a3, a3
  90abc5:	5bfb78        	call8	9099a8 <ath_tx_set_retry$isra$12>
	asf_tailq_insert_head(&tid->buf_q, bf, bf_list);
  90abc8:	0c6211        	slli	a2, a6, 4
  90abcb:	06280c        	sub	a8, a2, a6
  90abce:	0e8811        	slli	a8, a8, 2
  90abd1:	a878      	add.n	a8, a7, a8
  90abd3:	2a8214        	l32i	a10, a8, 80
  90abd6:	2b3c24        	addi	a11, a3, 36
  90abd9:	9a39      	s32i.n	a10, a3, 36
  90abdb:	c8a5      	beqz.n	a10, 90abe4 <ath_tgt_tx_comp_aggr+0x238>
  90abdd:	9baa      	s32i.n	a11, a10, 40
  90abdf:	600004        	j	90abe7 <ath_tgt_tx_comp_aggr+0x23b>
  90abe2:	00002b        	mulsh	a0, a0, a0
  90abe5:	8615      	l32i.n	a6, a1, 20
  90abe7:	06220c        	sub	a2, a2, a6
  90abea:	0e2211        	slli	a2, a2, 2
  90abed:	a272      	add.n	a2, a7, a2
  90abef:	244c50        	addi	a4, a4, 80
	ath_tgt_tx_enqueue(txq, tid);
  90abf2:	291234        	l32i	a9, a1, 208
		__stats(sc, txunaggr_errlast);
		bf = ath_buf_toggle(sc, bf, 1);
	}

	ath_tx_set_retry(sc, bf);
	asf_tailq_insert_head(&tid->buf_q, bf, bf_list);
  90abf5:	232614        	s32i	a3, a2, 80
  90abf8:	a477      	add.n	a7, a7, a4
  90abfa:	973a      	s32i.n	a7, a3, 40
	ath_tgt_tx_enqueue(txq, tid);
  90abfc:	db50      	mov.n	a11, a5
  90abfe:	2a9c1c        	addi	a10, a9, 28
  90ac01:	60018a        	j	90ad8f <ath_tgt_tx_comp_aggr+0x3e3>
  90ac04:	000c7a        	excw

static void
ath_tx_comp_unaggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90ac07:	112522        	l32r	a1, 8d4090 <_bss_end+0x3c6888>

	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
		ath_tx_retry_unaggr(sc, bf);
		return;
	}
	__stats(sc, tx_compunaggr);
  90ac0a:	5e07aa        	call12	88cab4 <_bss_end+0x37f2ac>

static void
ath_tx_comp_unaggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90ac0d:	0c2b31        	excw
		ath_tx_retry_unaggr(sc, bf);
		return;
	}
	__stats(sc, tx_compunaggr);

	ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90ac10:	230eaa        	s32c1i	a3, a0, 0x2a8

static void
ath_tx_comp_unaggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90ac13:	11255c        	l32r	a1, 8d4184 <_bss_end+0x3c697c>

	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
		ath_tx_retry_unaggr(sc, bf);
		return;
	}
	__stats(sc, tx_compunaggr);
  90ac16:	012aac        	excw

static void
ath_tx_comp_unaggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90ac19:	240a4a        	movi	a4, 74
		ath_tx_retry_unaggr(sc, bf);
		return;
	}
	__stats(sc, tx_compunaggr);

	ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90ac1c:	082526        	excw

	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
		ath_tx_retry_unaggr(sc, bf);
		return;
	}
	__stats(sc, tx_compunaggr);
  90ac1f:	5e0b4b        	call12	88d94c <_bss_end+0x380144>

	ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90ac22:	145bf8        	l32r	a4, 8e1c04 <athos_indirection_table_install+0x6bc>
  90ac25:	f6          	.byte 0xf6
	ath_tx_status_update(sc, bf);
  90ac26:	db30      	mov.n	a11, a3
  90ac28:	da20      	mov.n	a10, a2
  90ac2a:	5bfaf0        	call8	9097ec <ath_tx_status_update>
	ath_tx_freebuf(sc, bf);
  90ac2d:	db30      	mov.n	a11, a3
  90ac2f:	da20      	mov.n	a10, a2
  90ac31:	5bfa5e        	call8	9095ac <ath_tx_freebuf>
  90ac34:	d10f      	retw.n
  90ac36:	000025        	excw
	if (!bf->bf_isaggr) {
		ath_tx_comp_unaggr(sc, bf);
		return;
	}

	__stats(sc, tx_compaggr);
  90ac39:	225f2f        	s32ri	a2, a5, 188

	asf_tailq_init(&bf_q);

	seq_st =  ATH_DS_BA_SEQ(ds);
	ba     =  ATH_DS_BA_BITMAP(ds);
	tx_ok  =  (ATH_DS_TX_STATUS(ds) == HAL_OK);
  90ac3c:	1066b1        	l32r	a0, 8e4700 <vdesc_module_install+0x5c4>
	if (!bf->bf_isaggr) {
		ath_tx_comp_unaggr(sc, bf);
		return;
	}

	__stats(sc, tx_compaggr);
  90ac3f:	552526        	call4	9540d8 <_etext+0x49085>
  90ac42:	5f250a        	call12	8d406c <_bss_end+0x3c6864>

	asf_tailq_init(&bf_q);
  90ac45:	b8a5      	addi.n	a5, a10, 8
  90ac47:	152516        	l32r	a5, 8d40a0 <_bss_end+0x3c6898>
  90ac4a:	2fc051        	l8ui	a15, a12, 81
  90ac4d:	28162e        	s32i	a8, a1, 184

	seq_st =  ATH_DS_BA_SEQ(ds);
	ba     =  ATH_DS_BA_BITMAP(ds);
	tx_ok  =  (ATH_DS_TX_STATUS(ds) == HAL_OK);
  90ac50:	0f5838        	moveqz	a8, a5, a15
  90ac53:	281638        	s32i	a8, a1, 224

	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
  90ac56:	05f501        	and	a5, a15, a5
  90ac59:	c853      	beqz.n	a5, 90ac60 <ath_tgt_tx_comp_aggr+0x2b4>
  90ac5b:	600022        	j	90ac81 <ath_tgt_tx_comp_aggr+0x2d5>
  90ac5e:	000028        	mull	a0, a0, a0

	__stats(sc, tx_compaggr);

	asf_tailq_init(&bf_q);

	seq_st =  ATH_DS_BA_SEQ(ds);
  90ac61:	113228        	l32r	a1, 8d7504 <_bss_end+0x3c9cfc>
  90ac64:	1637ce        	l32r	a6, 8d8b9c <_bss_end+0x3cb394>
	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
		ath_tx_comp_aggr_error(sc, bf, tid);
		return;
	}

	if (tx_ok && !ATH_DS_TX_BA(ds)) {
  90ac67:	f3          	.byte 0xf3
  90ac68:	d5f0      	mov.n	a5, a15
  90ac6a:	7f9f1f        	bbsi	a9, 31, 90ac8d <ath_tgt_tx_comp_aggr+0x2e1>
		__stats(sc, txaggr_babug);
  90ac6d:	242269        	l32i	a4, a2, 0x1a4
		adf_os_print("BA Bug?\n");
  90ac70:	1a72b5        	l32r	a10, 8e7744 <memset+0x25a8>
		ath_tx_comp_aggr_error(sc, bf, tid);
		return;
	}

	if (tx_ok && !ATH_DS_TX_BA(ds)) {
		__stats(sc, txaggr_babug);
  90ac73:	b144      	addi.n	a4, a4, 1
  90ac75:	242669        	s32i	a4, a2, 0x1a4
		adf_os_print("BA Bug?\n");
  90ac78:	14716e        	l32r	a4, 8e7230 <memset+0x2094>
  90ac7b:	244212        	l32i	a4, a4, 72
  90ac7e:	0b4000        	callx8	a4
		ath_tx_comp_aggr_error(sc, bf, tid);
  90ac81:	dc60      	mov.n	a12, a6
  90ac83:	db30      	mov.n	a11, a3
  90ac85:	da20      	mov.n	a10, a2
  90ac87:	5bfb8e        	call8	909ac0 <ath_tx_comp_aggr_error>
		return;
  90ac8a:	d10f      	retw.n
  90ac8c:	00280a        	addx4	a8, a2, a0
			__stats(sc, txaggr_compgood);
			ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
			ath_tx_status_update_aggr(sc, bf, ds, rcs, 1);
			ath_tx_freebuf(sc, bf);
		} else {
			ath_tx_retry_subframe(sc, bf, &bf_q, &bar);
  90ac8f:	bca8      	addi.n	a8, a10, 12
  90ac91:	182816        	l32r	a8, 8d4cec <_bss_end+0x3c74e4>
  90ac94:	3a2b31        	excw
		ath_tx_comp_aggr_error(sc, bf, tid);
		return;
	}

	while (bf) {
		ba_index = ATH_BA_INDEX(seq_st, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90ac97:	232812        	excw
  90ac9a:	370b4b        	excw
  90ac9d:	1408b9        	l32r	a4, 8ccf84 <_bss_end+0x3bf77c>
  90aca0:	0c8a3b        	movgez	a10, a8, a12
  90aca3:	09094f        	extui	a9, a9, 0, 16
		bf_next  = bf->bf_next;
  90aca6:	2a1639        	s32i	a10, a1, 228
		ath_tx_comp_aggr_error(sc, bf, tid);
		return;
	}

	while (bf) {
		ba_index = ATH_BA_INDEX(seq_st, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90aca9:	09084b        	extui	a8, a9, 0, 12
		bf_next  = bf->bf_next;

		if (tx_ok && ATH_BA_ISSET(ba, ba_index)) {
  90acac:	c3af      	movi.n	a10, 63
  90acae:	78a247        	blt	a10, a8, 90acf9 <ath_tgt_tx_comp_aggr+0x34d>
  90acb1:	2a1238        	l32i	a10, a1, 224
  90acb4:	64a041        	beqz	a10, 90acf9 <ath_tgt_tx_comp_aggr+0x34d>
  90acb7:	085812        	srai	a8, a8, 5
  90acba:	0e8811        	slli	a8, a8, 2
  90acbd:	a818      	add.n	a8, a1, a8
  90acbf:	c0e1      	movi.n	a14, 1
  90acc1:	28821d        	l32i	a8, a8, 116
  90acc4:	009104        	ssl	a9
  90acc7:	00e91a        	sll	a9, a14
  90acca:	78902b        	bnone	a9, a8, 90acf9 <ath_tgt_tx_comp_aggr+0x34d>
			__stats(sc, txaggr_compgood);
  90accd:	282262        	l32i	a8, a2, 0x188
			ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90acd0:	da60      	mov.n	a10, a6
	while (bf) {
		ba_index = ATH_BA_INDEX(seq_st, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
		bf_next  = bf->bf_next;

		if (tx_ok && ATH_BA_ISSET(ba, ba_index)) {
			__stats(sc, txaggr_compgood);
  90acd2:	ae88      	add.n	a8, a8, a14
  90acd4:	282662        	s32i	a8, a2, 0x188
			ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90acd7:	2e163b        	s32i	a14, a1, 236
  90acda:	5bf8c8        	call8	908ffc <ath_tx_update_baw>
			ath_tx_status_update_aggr(sc, bf, ds, rcs, 1);
  90acdd:	2e123b        	l32i	a14, a1, 236
  90ace0:	2d0a88        	movi	a13, 136
  90ace3:	db30      	mov.n	a11, a3
  90ace5:	da20      	mov.n	a10, a2
  90ace7:	ad1d      	add.n	a13, a1, a13
  90ace9:	dc10      	mov.n	a12, a1
  90aceb:	5bfaf1        	call8	9098b0 <ath_tx_status_update_aggr>
			ath_tx_freebuf(sc, bf);
  90acee:	db30      	mov.n	a11, a3
  90acf0:	da20      	mov.n	a10, a2
  90acf2:	5bfa2e        	call8	9095ac <ath_tx_freebuf>
  90acf5:	600011        	j	90ad0a <ath_tgt_tx_comp_aggr+0x35e>
  90acf8:	002d0a        	addx4	a13, a2, a0
		} else {
			ath_tx_retry_subframe(sc, bf, &bf_q, &bar);
  90acfb:	c02c      	movi.n	a2, 12
  90acfd:	123aad        	l32r	a2, 8d97b4 <_bss_end+0x3cbfac>
  90ad00:	1ddb30        	l32r	a13, 9019c0 <memset+0x1c824>
  90ad03:	da20      	mov.n	a10, a2
  90ad05:	5bfb34        	call8	9099d8 <ath_tx_retry_subframe$isra$14>
			nbad ++;
  90ad08:	b155      	addi.n	a5, a5, 1
  90ad0a:	231239        	l32i	a3, a1, 228
		adf_os_print("BA Bug?\n");
		ath_tx_comp_aggr_error(sc, bf, tid);
		return;
	}

	while (bf) {
  90ad0d:	653f84        	bnez	a3, 90ac95 <ath_tgt_tx_comp_aggr+0x2e9>
			nbad ++;
		}
		bf = bf_next;
	}

	ath_update_aggr_stats(sc, ds, nframes, nbad);
  90ad10:	2e1071        	l8ui	a14, a1, 113
  90ad13:	2d1070        	l8ui	a13, a1, 112
  90ad16:	2c1067        	l8ui	a12, a1, 103
  90ad19:	2b1066        	l8ui	a11, a1, 102
  90ad1c:	da20      	mov.n	a10, a2
  90ad1e:	5bf8f0        	call8	9090e0 <ath_update_aggr_stats$isra$5>
	ath_rate_tx_complete(sc, an, ds, rcs, nframes, nbad);
  90ad21:	2e1234        	l32i	a14, a1, 208
  90ad24:	2d0a88        	movi	a13, 136
  90ad27:	dc10      	mov.n	a12, a1
  90ad29:	df50      	mov.n	a15, a5
  90ad2b:	ad1d      	add.n	a13, a1, a13
  90ad2d:	db40      	mov.n	a11, a4
  90ad2f:	da20      	mov.n	a10, a2
  90ad31:	5bf848        	call8	908e54 <ath_rate_tx_complete>

	if (bar) {
  90ad34:	2c1230        	l32i	a12, a1, 192
  90ad37:	c8c5      	beqz.n	a12, 90ad40 <ath_tgt_tx_comp_aggr+0x394>
		ath_bar_tx(sc, tid, bar);
  90ad39:	db60      	mov.n	a11, a6
  90ad3b:	da20      	mov.n	a10, a2
  90ad3d:	5bfa3c        	call8	909630 <ath_bar_tx>
	}

	if (!asf_tailq_empty(&bf_q)) {
  90ad40:	23122e        	l32i	a3, a1, 184
  90ad43:	64304b        	beqz	a3, 90ad92 <ath_tgt_tx_comp_aggr+0x3e6>
		__stats(sc, txaggr_prepends);
  90ad46:	232264        	l32i	a3, a2, 0x190
  90ad49:	25122f        	l32i	a5, a1, 188
  90ad4c:	b133      	addi.n	a3, a3, 1
  90ad4e:	232664        	s32i	a3, a2, 0x190
		TAILQ_INSERTQ_HEAD(&tid->buf_q, &bf_q, bf_list);
  90ad51:	0c7211        	slli	a2, a7, 4
  90ad54:	07230c        	sub	a3, a2, a7
  90ad57:	0e3311        	slli	a3, a3, 2
  90ad5a:	a343      	add.n	a3, a4, a3
  90ad5c:	283214        	l32i	a8, a3, 80
  90ad5f:	c889      	beqz.n	a8, 90ad6c <ath_tgt_tx_comp_aggr+0x3c0>
  90ad61:	9850      	s32i.n	a8, a5, 0
  90ad63:	233214        	l32i	a3, a3, 80
  90ad66:	953a      	s32i.n	a5, a3, 40
  90ad68:	600003        	j	90ad6f <ath_tgt_tx_comp_aggr+0x3c3>
  90ad6b:	002536        	minu	a5, a2, a0
  90ad6e:	150727        	l32r	a5, 8cca0c <_bss_end+0x3bf204>
  90ad71:	0c2512        	srai	a5, a12, 2
  90ad74:	352312        	excw
  90ad77:	2e0e77        	s32c1i	a14, a0, 0x1dc
  90ad7a:	11a747        	l32r	a1, 8f4a98 <memset+0xf8fc>
  90ad7d:	225c50        	addi	a2, a5, 80
		ath_tgt_tx_enqueue(txq, tid);
  90ad80:	281236        	l32i	a8, a1, 216
		ath_bar_tx(sc, tid, bar);
	}

	if (!asf_tailq_empty(&bf_q)) {
		__stats(sc, txaggr_prepends);
		TAILQ_INSERTQ_HEAD(&tid->buf_q, &bf_q, bf_list);
  90ad83:	237614        	s32i	a3, a7, 80
  90ad86:	a244      	add.n	a4, a4, a2
  90ad88:	943a      	s32i.n	a4, a3, 40
		ath_tgt_tx_enqueue(txq, tid);
  90ad8a:	db60      	mov.n	a11, a6
  90ad8c:	2a8c1c        	addi	a10, a8, 28
  90ad8f:	5bf8cb        	call8	9090bc <ath_tgt_tx_enqueue$isra$3>
  90ad92:	d10f      	retw.n

0090ad94 <ath_tgt_tx_cleanup>:
	wh->i_fc[1] |= IEEE80211_FC1_RETRY;
}

void ath_tgt_tx_cleanup(struct ath_softc_tgt *sc, struct ath_node_target *an,
			ath_atx_tid_t *tid, a_uint8_t discard_all)
{
  90ad94:	6c1004        	entry	a1, 32
  90ad97:	050547        	extui	a5, a5, 0, 8
	struct ath_tx_buf *bf_next;
	struct ath_txq *txq;

	txq = TID_TO_ACTXQ(tid->tidno);

	bf = asf_tailq_first(&tid->buf_q);
  90ad9a:	864b      	l32i.n	a6, a4, 44

	while (bf) {
		if (discard_all || bf->bf_isretried) {
			bf_next = asf_tailq_next(bf, bf_list);
			TAILQ_DEQ(&tid->buf_q, bf, bf_list);
			if (bf->bf_isretried)
  90ad9c:	c170      	movi.n	a7, 16

	txq = TID_TO_ACTXQ(tid->tidno);

	bf = asf_tailq_first(&tid->buf_q);

	while (bf) {
  90ad9e:	600045        	j	90ade7 <ath_tgt_tx_cleanup+0x53>
  90ada1:	008369        	excw
		if (discard_all || bf->bf_isretried) {
  90ada4:	cc54      	bnez.n	a5, 90adac <ath_tgt_tx_cleanup+0x18>
  90ada6:	286221        	l32i	a8, a6, 132
  90ada9:	787033        	bnone	a7, a8, 90ade0 <ath_tgt_tx_cleanup+0x4c>
			bf_next = asf_tailq_next(bf, bf_list);
  90adac:	d630      	mov.n	a6, a3
			TAILQ_DEQ(&tid->buf_q, bf, bf_list);
  90adae:	834b      	l32i.n	a3, a4, 44
  90adb0:	c930      	beqz.n	a3, 90adc4 <ath_tgt_tx_cleanup+0x30>
  90adb2:	8839      	l32i.n	a8, a3, 36
  90adb4:	893a      	l32i.n	a9, a3, 40
  90adb6:	c884      	beqz.n	a8, 90adbe <ath_tgt_tx_cleanup+0x2a>
  90adb8:	998a      	s32i.n	a9, a8, 40
  90adba:	600002        	j	90adc0 <ath_tgt_tx_cleanup+0x2c>
  90adbd:	00994c        	extui	a9, a0, 9, 13
  90adc0:	893a      	l32i.n	a9, a3, 40
  90adc2:	9890      	s32i.n	a8, a9, 0
			if (bf->bf_isretried)
  90adc4:	283221        	l32i	a8, a3, 132
  90adc7:	78700a        	bnone	a7, a8, 90add5 <ath_tgt_tx_cleanup+0x41>
				ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90adca:	2b3123        	l16ui	a11, a3, 70
  90adcd:	da40      	mov.n	a10, a4
  90adcf:	0b4b14        	srli	a11, a11, 4
  90add2:	5bf88a        	call8	908ffc <ath_tx_update_baw>
			ath_tx_freebuf(sc, bf);
  90add5:	db30      	mov.n	a11, a3
  90add7:	da20      	mov.n	a10, a2
  90add9:	5bf9f4        	call8	9095ac <ath_tx_freebuf>
			bf = bf_next;
			continue;
  90addc:	600007        	j	90ade7 <ath_tgt_tx_cleanup+0x53>
  90addf:	001872        	excw
		}
		bf->bf_comp = ath_tgt_tx_comp_normal;
  90ade2:	b298      	addi.n	a8, a9, 2
  90ade4:	6fd630        	bgeui	a13, 6, 90ae18 <ath_tgt_tx_cleanup+0x84>

	txq = TID_TO_ACTXQ(tid->tidno);

	bf = asf_tailq_first(&tid->buf_q);

	while (bf) {
  90ade7:	656fb7        	bnez	a6, 90ada2 <ath_tgt_tx_cleanup+0xe>
}

static inline void
ath_aggr_pause_tid(struct ath_softc_tgt *sc, ath_atx_tid_t *tid)
{
	tid->paused =1;
  90adea:	c031      	movi.n	a3, 1
  90adec:	234434        	s8i	a3, a4, 52
		bf = asf_tailq_next(bf, bf_list);
	}

	ath_aggr_pause_tid(sc, tid);

	while (tid->baw_head != tid->baw_tail) {
  90adef:	8a44      	l32i.n	a10, a4, 16
		if (TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head)) {
  90adf1:	c061      	movi.n	a6, 1
			tid->incomp++;
			tid->flag |= TID_CLEANUP_INPROGRES;
			TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, tid->baw_head);
  90adf3:	c7bf      	movi.n	a11, -1
  90adf5:	60003d        	j	90ae36 <ath_tgt_tx_cleanup+0xa2>
	}

	ath_aggr_pause_tid(sc, tid);

	while (tid->baw_head != tid->baw_tail) {
		if (TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head)) {
  90adf8:	085312        	srai	a3, a8, 5
  90adfb:	0e3311        	slli	a3, a3, 2
  90adfe:	a343      	add.n	a3, a4, a3
  90ae00:	8535      	l32i.n	a5, a3, 20
  90ae02:	008104        	ssl	a8
  90ae05:	00691a        	sll	a9, a6
  90ae08:	795018        	bnone	a5, a9, 90ae24 <ath_tgt_tx_cleanup+0x90>
			tid->incomp++;
  90ae0b:	2c4037        	l8ui	a12, a4, 55
			tid->flag |= TID_CLEANUP_INPROGRES;
			TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, tid->baw_head);
  90ae0e:	09b903        	xor	a9, a11, a9

	ath_aggr_pause_tid(sc, tid);

	while (tid->baw_head != tid->baw_tail) {
		if (TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head)) {
			tid->incomp++;
  90ae11:	b1cc      	addi.n	a12, a12, 1
  90ae13:	2c4437        	s8i	a12, a4, 55
			tid->flag |= TID_CLEANUP_INPROGRES;
  90ae16:	2c4036        	l8ui	a12, a4, 54
			TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, tid->baw_head);
  90ae19:	059901        	and	a9, a9, a5
	ath_aggr_pause_tid(sc, tid);

	while (tid->baw_head != tid->baw_tail) {
		if (TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head)) {
			tid->incomp++;
			tid->flag |= TID_CLEANUP_INPROGRES;
  90ae1c:	0c6c02        	or	a12, a6, a12
  90ae1f:	2c4436        	s8i	a12, a4, 54
			TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, tid->baw_head);
  90ae22:	9935      	s32i.n	a9, a3, 20
		}
		INCR(tid->baw_head, ATH_TID_MAX_BUFS);
		INCR(tid->seq_start, IEEE80211_SEQ_MAX);
  90ae24:	234102        	l16ui	a3, a4, 4
		if (TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head)) {
			tid->incomp++;
			tid->flag |= TID_CLEANUP_INPROGRES;
			TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, tid->baw_head);
		}
		INCR(tid->baw_head, ATH_TID_MAX_BUFS);
  90ae27:	b188      	addi.n	a8, a8, 1
		INCR(tid->seq_start, IEEE80211_SEQ_MAX);
  90ae29:	b133      	addi.n	a3, a3, 1
		if (TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head)) {
			tid->incomp++;
			tid->flag |= TID_CLEANUP_INPROGRES;
			TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, tid->baw_head);
		}
		INCR(tid->baw_head, ATH_TID_MAX_BUFS);
  90ae2b:	080846        	extui	a8, a8, 0, 7
		INCR(tid->seq_start, IEEE80211_SEQ_MAX);
  90ae2e:	03034b        	extui	a3, a3, 0, 12
		if (TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head)) {
			tid->incomp++;
			tid->flag |= TID_CLEANUP_INPROGRES;
			TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, tid->baw_head);
		}
		INCR(tid->baw_head, ATH_TID_MAX_BUFS);
  90ae31:	9843      	s32i.n	a8, a4, 12
		INCR(tid->seq_start, IEEE80211_SEQ_MAX);
  90ae33:	234502        	s16i	a3, a4, 4
		bf = asf_tailq_next(bf, bf_list);
	}

	ath_aggr_pause_tid(sc, tid);

	while (tid->baw_head != tid->baw_tail) {
  90ae36:	8843      	l32i.n	a8, a4, 12
  90ae38:	7a89bc        	bne	a8, a10, 90adf8 <ath_tgt_tx_cleanup+0x64>
		}
		INCR(tid->baw_head, ATH_TID_MAX_BUFS);
		INCR(tid->seq_start, IEEE80211_SEQ_MAX);
	}

	if (!(tid->flag & TID_CLEANUP_INPROGRES)) {
  90ae3b:	234036        	l8ui	a3, a4, 54
  90ae3e:	7f3f06        	bbsi	a3, 31, 90ae48 <ath_tgt_tx_cleanup+0xb4>
		ath_aggr_resume_tid(sc, tid);
  90ae41:	db40      	mov.n	a11, a4
  90ae43:	da20      	mov.n	a10, a2
  90ae45:	5bfe9d        	call8	90a8bc <ath_aggr_resume_tid>
  90ae48:	d10f      	retw.n
	...

0090ae4c <ath_bar_tx_comp>:
	ath_tx_set_retry(sc, bf);
	ath_tgt_txq_add_ucast(sc, bf);
}

static void ath_bar_tx_comp(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90ae4c:	6c1006        	entry	a1, 48
	struct ath_node_target *an;
	ath_atx_tid_t *tid;
	struct ath_txq *txq;

	an = (struct ath_node_target *)bf->bf_node;
	tid = &an->tid[bf->bf_tidno];
  90ae4f:	2a304d        	l8ui	a10, a3, 77
	ath_tgt_txq_add_ucast(sc, bf);
}

static void ath_bar_tx_comp(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_tx_desc *ds = bf->bf_lastds;
  90ae52:	893e      	l32i.n	a9, a3, 56
	struct ath_node_target *an;
	ath_atx_tid_t *tid;
	struct ath_txq *txq;

	an = (struct ath_node_target *)bf->bf_node;
	tid = &an->tid[bf->bf_tidno];
  90ae54:	0ca411        	slli	a4, a10, 4
  90ae57:	0a440c        	sub	a4, a4, a10
	txq = TID_TO_ACTXQ(tid->tidno);

	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
  90ae5a:	269066        	l8ui	a6, a9, 102
	struct ath_tx_desc *ds = bf->bf_lastds;
	struct ath_node_target *an;
	ath_atx_tid_t *tid;
	struct ath_txq *txq;

	an = (struct ath_node_target *)bf->bf_node;
  90ae5d:	8534      	l32i.n	a5, a3, 16
	tid = &an->tid[bf->bf_tidno];
  90ae5f:	0e4411        	slli	a4, a4, 2
  90ae62:	244c24        	addi	a4, a4, 36
	txq = TID_TO_ACTXQ(tid->tidno);

	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
  90ae65:	060640        	extui	a6, a6, 0, 1
	struct ath_node_target *an;
	ath_atx_tid_t *tid;
	struct ath_txq *txq;

	an = (struct ath_node_target *)bf->bf_node;
	tid = &an->tid[bf->bf_tidno];
  90ae68:	a454      	add.n	a4, a5, a4
	txq = TID_TO_ACTXQ(tid->tidno);

	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
  90ae6a:	6460d3        	beqz	a6, 90af41 <ath_bar_tx_comp+0xf5>
static void ath_bar_retry(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);

	if (bf->bf_retries >= OWLMAX_BAR_RETRIES) {
  90ae6d:	263086        	l8ui	a6, a3, 134
  90ae70:	c089      	movi.n	a8, 9
  90ae72:	768b6a        	bgeu	a8, a6, 90aee0 <ath_bar_tx_comp+0x94>
		ath_tgt_delba_send(sc, bf->bf_node, tid->tidno, 1,
  90ae75:	0ca811        	slli	a8, a10, 4
  90ae78:	0a880c        	sub	a8, a8, a10
  90ae7b:	0e8811        	slli	a8, a8, 2
  90ae7e:	a858      	add.n	a8, a5, a8
  90ae80:	268027        	l8ui	a6, a8, 39
{
	struct ath_node_target *an = ATH_NODE_TARGET(ni);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, tidno);
	struct wmi_data_delba wmi_delba;

	tid->flag &= ~TID_AGGR_ENABLED;
  90ae83:	c79d      	movi.n	a9, -3
  90ae85:	0c6c11        	slli	a12, a6, 4
  90ae88:	06cc0c        	sub	a12, a12, a6
  90ae8b:	0ecc11        	slli	a12, a12, 2
  90ae8e:	ac56      	add.n	a6, a5, a12
  90ae90:	28605a        	l8ui	a8, a6, 90
			       struct ieee80211_node_target *ni,
			       a_uint8_t tidno, a_uint8_t initiator,
			       a_uint16_t reasoncode)
{
	struct ath_node_target *an = ATH_NODE_TARGET(ni);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, tidno);
  90ae93:	2ccc24        	addi	a12, a12, 36
	struct wmi_data_delba wmi_delba;

	tid->flag &= ~TID_AGGR_ENABLED;
  90ae96:	098801        	and	a8, a8, a9
  90ae99:	28645a        	s8i	a8, a6, 90

	ath_tgt_tx_cleanup(sc, an, tid, 1);
  90ae9c:	ac5c      	add.n	a12, a5, a12
  90ae9e:	db50      	mov.n	a11, a5
  90aea0:	c0d1      	movi.n	a13, 1
  90aea2:	022a02        	or	a10, a2, a2
  90aea5:	5bffbb        	call8	90ad94 <ath_tgt_tx_cleanup>

	wmi_delba.ni_nodeindex = ni->ni_nodeindex;
  90aea8:	25500c        	l8ui	a5, a5, 12
	wmi_delba.tidno = tid->tidno;
	wmi_delba.initiator = 1;
	wmi_delba.reasoncode = IEEE80211_REASON_UNSPECIFIED;

	__stats(sc, txbar_xretry);
	wmi_event(sc->tgt_wmi_handle,
  90aeab:	1b72b6        	l32r	a11, 8e7984 <memset+0x27e8>

	tid->flag &= ~TID_AGGR_ENABLED;

	ath_tgt_tx_cleanup(sc, an, tid, 1);

	wmi_delba.ni_nodeindex = ni->ni_nodeindex;
  90aeae:	251400        	s8i	a5, a1, 0
	wmi_delba.tidno = tid->tidno;
  90aeb1:	8569      	l32i.n	a5, a6, 36
	wmi_delba.initiator = 1;
	wmi_delba.reasoncode = IEEE80211_REASON_UNSPECIFIED;

	__stats(sc, txbar_xretry);
	wmi_event(sc->tgt_wmi_handle,
  90aeb3:	8a23      	l32i.n	a10, a2, 12
	tid->flag &= ~TID_AGGR_ENABLED;

	ath_tgt_tx_cleanup(sc, an, tid, 1);

	wmi_delba.ni_nodeindex = ni->ni_nodeindex;
	wmi_delba.tidno = tid->tidno;
  90aeb5:	251401        	s8i	a5, a1, 1
	wmi_delba.initiator = 1;
  90aeb8:	c051      	movi.n	a5, 1
  90aeba:	251402        	s8i	a5, a1, 2
	wmi_delba.reasoncode = IEEE80211_REASON_UNSPECIFIED;
  90aebd:	251403        	s8i	a5, a1, 3

	__stats(sc, txbar_xretry);
  90aec0:	252279        	l32i	a5, a2, 0x1e4
	wmi_event(sc->tgt_wmi_handle,
  90aec3:	c0d4      	movi.n	a13, 4
	wmi_delba.ni_nodeindex = ni->ni_nodeindex;
	wmi_delba.tidno = tid->tidno;
	wmi_delba.initiator = 1;
	wmi_delba.reasoncode = IEEE80211_REASON_UNSPECIFIED;

	__stats(sc, txbar_xretry);
  90aec5:	b155      	addi.n	a5, a5, 1
	wmi_event(sc->tgt_wmi_handle,
  90aec7:	011c02        	or	a12, a1, a1
	wmi_delba.ni_nodeindex = ni->ni_nodeindex;
	wmi_delba.tidno = tid->tidno;
	wmi_delba.initiator = 1;
	wmi_delba.reasoncode = IEEE80211_REASON_UNSPECIFIED;

	__stats(sc, txbar_xretry);
  90aeca:	252679        	s32i	a5, a2, 0x1e4
	wmi_event(sc->tgt_wmi_handle,
  90aecd:	5bef3b        	call8	906bbc <wmi_event>
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);

	if (bf->bf_retries >= OWLMAX_BAR_RETRIES) {
		ath_tgt_delba_send(sc, bf->bf_node, tid->tidno, 1,
				   IEEE80211_REASON_UNSPECIFIED);
		ath_tgt_tid_drain(sc, tid);
  90aed0:	db40      	mov.n	a11, a4
  90aed2:	da20      	mov.n	a10, a2

		bf->bf_comp = NULL;
  90aed4:	c040      	movi.n	a4, 0
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);

	if (bf->bf_retries >= OWLMAX_BAR_RETRIES) {
		ath_tgt_delba_send(sc, bf->bf_node, tid->tidno, 1,
				   IEEE80211_REASON_UNSPECIFIED);
		ath_tgt_tid_drain(sc, tid);
  90aed6:	5bfb28        	call8	909b78 <ath_tgt_tid_drain>

		bf->bf_comp = NULL;
  90aed9:	943f      	s32i.n	a4, a3, 60
  90aedb:	60006b        	j	90af4a <ath_bar_tx_comp+0xfe>
  90aede:	000024        	excw
		ath_buf_comp(sc, bf);
		return;
	}

	__stats(sc, txbar_compretries);
  90aee1:	227a25        	movi	a2, 0x725

	if (!bf->bf_lastds->ds_link) {
  90aee4:	9000      	s32i.n	a0, a0, 0
		bf->bf_comp = NULL;
		ath_buf_comp(sc, bf);
		return;
	}

	__stats(sc, txbar_compretries);
  90aee6:	b144      	addi.n	a4, a4, 1
  90aee8:	24267a        	s32i	a4, a2, 0x1e8

	if (!bf->bf_lastds->ds_link) {
  90aeeb:	249001        	l8ui	a4, a9, 1
  90aeee:	085510        	slli	a5, a5, 24
  90aef1:	004411        	slli	a4, a4, 16
  90aef4:	054502        	or	a5, a4, a5
  90aef7:	249002        	l8ui	a4, a9, 2
  90aefa:	084411        	slli	a4, a4, 8
  90aefd:	054402        	or	a4, a4, a5
  90af00:	259003        	l8ui	a5, a9, 3
  90af03:	045402        	or	a4, a5, a4
  90af06:	cd42      	bnez.n	a4, 90af1c <ath_bar_tx_comp+0xd0>
		__stats(sc, txbar_errlast);
  90af08:	24227b        	l32i	a4, a2, 0x1ec
		bf = ath_buf_toggle(sc, bf, 1);
  90af0b:	db30      	mov.n	a11, a3
	}

	__stats(sc, txbar_compretries);

	if (!bf->bf_lastds->ds_link) {
		__stats(sc, txbar_errlast);
  90af0d:	b144      	addi.n	a4, a4, 1
  90af0f:	24267b        	s32i	a4, a2, 0x1ec
		bf = ath_buf_toggle(sc, bf, 1);
  90af12:	c0c1      	movi.n	a12, 1
  90af14:	022a02        	or	a10, a2, a2
  90af17:	5bf963        	call8	9094a4 <ath_buf_toggle>
  90af1a:	d3a0      	mov.n	a3, a10
	}

	bf->bf_lastds->ds_link = 0;
  90af1c:	843e      	l32i.n	a4, a3, 56
  90af1e:	c050      	movi.n	a5, 0

	ath_tx_set_retry(sc, bf);
  90af20:	2a1a80        	movi	a10, 0x180
  90af23:	db30      	mov.n	a11, a3
  90af25:	aa2a      	add.n	a10, a2, a10
	if (!bf->bf_lastds->ds_link) {
		__stats(sc, txbar_errlast);
		bf = ath_buf_toggle(sc, bf, 1);
	}

	bf->bf_lastds->ds_link = 0;
  90af27:	254400        	s8i	a5, a4, 0
  90af2a:	254401        	s8i	a5, a4, 1
  90af2d:	254402        	s8i	a5, a4, 2
  90af30:	254403        	s8i	a5, a4, 3

	ath_tx_set_retry(sc, bf);
  90af33:	5bfa9d        	call8	9099a8 <ath_tx_set_retry$isra$12>
	ath_tgt_txq_add_ucast(sc, bf);
  90af36:	db30      	mov.n	a11, a3
  90af38:	da20      	mov.n	a10, a2
  90af3a:	5bf812        	call8	908f84 <ath_tgt_txq_add_ucast>
  90af3d:	d10f      	retw.n
  90af3f:	0000db        	excw
	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
		ath_bar_retry(sc, bf);
		return;
	}

	ath_aggr_resume_tid(sc, tid);
  90af42:	40da20        	excw
  90af45:	5bfe5d        	call8	90a8bc <ath_aggr_resume_tid>

	bf->bf_comp = NULL;
  90af48:	963f      	s32i.n	a6, a3, 60
	ath_buf_comp(sc, bf);
  90af4a:	db30      	mov.n	a11, a3
  90af4c:	da20      	mov.n	a10, a2
  90af4e:	5bf988        	call8	909570 <ath_buf_comp>
  90af51:	d10f      	retw.n
	...

0090af54 <ar5416AttachRateTables>:

#endif //#ifdef MAGPIE_MERLIN // MAGPIE_MERLIN 

void
ar5416AttachRateTables(struct atheros_softc *sc)
{
  90af54:	6c1004        	entry	a1, 32
    sc->hwRateTable[WIRELESS_MODE_11NG]  = &ar5416_11ngRateTable;
  90af57:	1872b7        	l32r	a8, 8e7a34 <memset+0x2898>
  90af5a:	9822      	s32i.n	a8, a2, 8
  90af5c:	d10f      	retw.n
	...

0090af60 <io32_rmw>:
	iowrite8(addr, val);
}

static inline void io32_rmw(volatile uint32_t addr,
			    const uint32_t set, const uint32_t clr)
{
  90af60:	6c1006        	entry	a1, 48
  90af63:	0c0200        	memw
  90af66:	9210      	s32i.n	a2, a1, 0
	uint32_t val;

	val = ioread32(addr);
  90af68:	0c0200        	memw
  90af6b:	8810      	l32i.n	a8, a1, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90af6d:	0c0200        	memw
  90af70:	8980      	l32i.n	a9, a8, 0
			    const uint32_t set, const uint32_t clr)
{
	uint32_t val;

	val = ioread32(addr);
	val &= ~clr;
  90af72:	c78f      	movi.n	a8, -1
  90af74:	048403        	xor	a4, a8, a4
  90af77:	094401        	and	a4, a4, a9
	val |= set;
	iowrite32(addr, val);
  90af7a:	0c0200        	memw
  90af7d:	8810      	l32i.n	a8, a1, 0
{
	uint32_t val;

	val = ioread32(addr);
	val &= ~clr;
	val |= set;
  90af7f:	034402        	or	a4, a4, a3
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90af82:	0c0200        	memw
  90af85:	9480      	s32i.n	a4, a8, 0
  90af87:	d10f      	retw.n
  90af89:	000000        	ill

0090af8c <__adf_net_register_drv>:
 * 
 * @return a_status_t
 */
a_status_t
__adf_net_register_drv(adf_drv_info_t *drv)
{
  90af8c:	6c1004        	entry	a1, 32
    wlan_pci_register_drv(drv);    
  90af8f:	da20      	mov.n	a10, a2
  90af91:	5be31e        	call8	903c0c <wlan_pci_register_drv>
    return A_STATUS_OK;
}
  90af94:	c020      	movi.n	a2, 0
  90af96:	d10f      	retw.n

0090af98 <__adf_net_unregister_drv>:
 * @brief unregister the driver from the shim
 * @param[in] name
 */
void
__adf_net_unregister_drv(a_uint8_t *name)
{
  90af98:	6c1004        	entry	a1, 32
  90af9b:	d10f      	retw.n
  90af9d:	000000        	ill

0090afa0 <ieee80211_tgt_crypto_encap>:

a_status_t
ieee80211_tgt_crypto_encap(struct ieee80211_frame *wh,
			   struct ieee80211_node_target *ni,
			   a_uint8_t keytype)
{
  90afa0:	6c1004        	entry	a1, 32
	a_uint16_t tmp;
	a_uint16_t offset = IEEE80211_WLAN_HDR_LEN;
	a_uint8_t b1, b2;
	struct ieee80211_qosframe_addr4 *wh_mesh;

	if (IEEE80211_QOS_HAS_SEQ(wh))
  90afa3:	282000        	l8ui	a8, a2, 0
  90afa6:	290a8c        	movi	a9, 140
  90afa9:	098801        	and	a8, a8, a9
  90afac:	290a88        	movi	a9, 136
		offset += 4;  // pad for 4 byte alignment
  90afaf:	09880c        	sub	a8, a8, a9
  90afb2:	c1a8      	movi.n	a10, 24
  90afb4:	c19c      	movi.n	a9, 28
  90afb6:	08a939        	movnez	a9, a10, a8
  90afb9:	d890      	mov.n	a8, a9

	/* set the offset to 32 if the mesh control field is present */
	wh_mesh = (struct ieee80211_qosframe_addr4 *)wh;
	if (wh_mesh->i_qos[1] & 0x01)
  90afbb:	29201f        	l8ui	a9, a2, 31
		offset = 32;
  90afbe:	c2a0      	movi.n	a10, 32
	if (IEEE80211_QOS_HAS_SEQ(wh))
		offset += 4;  // pad for 4 byte alignment

	/* set the offset to 32 if the mesh control field is present */
	wh_mesh = (struct ieee80211_qosframe_addr4 *)wh;
	if (wh_mesh->i_qos[1] & 0x01)
  90afc0:	090940        	extui	a9, a9, 0, 1
		offset = 32;
  90afc3:	09a839        	movnez	a8, a10, a9

a_status_t
ieee80211_tgt_crypto_encap(struct ieee80211_frame *wh,
			   struct ieee80211_node_target *ni,
			   a_uint8_t keytype)
{
  90afc6:	040447        	extui	a4, a4, 0, 8
	wh_mesh = (struct ieee80211_qosframe_addr4 *)wh;
	if (wh_mesh->i_qos[1] & 0x01)
		offset = 32;

	iv = (a_uint8_t *) wh;
	iv = iv + offset;
  90afc9:	a822      	add.n	a2, a2, a8

	switch (keytype) {
  90afcb:	684206        	beqi	a4, 2, 90afd5 <ieee80211_tgt_crypto_encap+0x35>
  90afce:	684333        	beqi	a4, 3, 90b005 <ieee80211_tgt_crypto_encap+0x65>
  90afd1:	60007a        	j	90b04f <ieee80211_tgt_crypto_encap+0xaf>
  90afd4:	002831        	excw
	case CRYPTO_KEY_TYPE_AES:
		ni->ni_iv16++;
  90afd7:	0db188        	excw
  90afda:	08084f        	extui	a8, a8, 0, 16
  90afdd:	28350d        	s16i	a8, a3, 26
		if (ni->ni_iv16 == 0)
  90afe0:	cc84      	bnez.n	a8, 90afe8 <ieee80211_tgt_crypto_encap+0x48>
		{
			ni->ni_iv32++;
  90afe2:	8937      	l32i.n	a9, a3, 28
  90afe4:	b199      	addi.n	a9, a9, 1
  90afe6:	9937      	s32i.n	a9, a3, 28
		}

		*iv++ = (a_uint8_t) ni->ni_iv16;
  90afe8:	282400        	s8i	a8, a2, 0
		*iv++ = (a_uint8_t) (ni->ni_iv16 >> 8);
  90afeb:	28310d        	l16ui	a8, a3, 26
		*iv++ = 0x00;
  90afee:	c040      	movi.n	a4, 0
		{
			ni->ni_iv32++;
		}

		*iv++ = (a_uint8_t) ni->ni_iv16;
		*iv++ = (a_uint8_t) (ni->ni_iv16 >> 8);
  90aff0:	088814        	srli	a8, a8, 8
  90aff3:	282401        	s8i	a8, a2, 1
		*iv++ = 0x00;
		*iv++ |= 0x20;
  90aff6:	282003        	l8ui	a8, a2, 3
			ni->ni_iv32++;
		}

		*iv++ = (a_uint8_t) ni->ni_iv16;
		*iv++ = (a_uint8_t) (ni->ni_iv16 >> 8);
		*iv++ = 0x00;
  90aff9:	242402        	s8i	a4, a2, 2
		*iv++ |= 0x20;
  90affc:	c240      	movi.n	a4, 32
  90affe:	048802        	or	a8, a8, a4
  90b001:	600030        	j	90b035 <ieee80211_tgt_crypto_encap+0x95>
  90b004:	002831        	excw
		tmp = (a_uint16_t) (ni->ni_iv32 >> 16);
		*iv++ = (a_uint8_t) tmp;
		*iv = (a_uint8_t) (tmp >> 8);
		break;
	case CRYPTO_KEY_TYPE_TKIP:
		ni->ni_iv16++;
  90b007:	0db188        	excw
  90b00a:	08084f        	extui	a8, a8, 0, 16
  90b00d:	28350d        	s16i	a8, a3, 26
		if (ni->ni_iv16 == 0)
  90b010:	cc84      	bnez.n	a8, 90b018 <ieee80211_tgt_crypto_encap+0x78>
		{
			ni->ni_iv32++;
  90b012:	8937      	l32i.n	a9, a3, 28
  90b014:	b199      	addi.n	a9, a9, 1
  90b016:	9937      	s32i.n	a9, a3, 28
		}

		b1 = (a_uint8_t) (ni->ni_iv16 >> 8);
  90b018:	088814        	srli	a8, a8, 8
		b2 = (b1 | 0x20) & 0x7f;

		*iv++ = b1;
  90b01b:	282400        	s8i	a8, a2, 0
		{
			ni->ni_iv32++;
		}

		b1 = (a_uint8_t) (ni->ni_iv16 >> 8);
		b2 = (b1 | 0x20) & 0x7f;
  90b01e:	c290      	movi.n	a9, 32
  90b020:	080846        	extui	a8, a8, 0, 7
  90b023:	098802        	or	a8, a8, a9

		*iv++ = b1;
		*iv++ = b2;
  90b026:	282401        	s8i	a8, a2, 1

		*iv++ = (a_uint8_t) ni->ni_iv16;
  90b029:	24310d        	l16ui	a4, a3, 26
		*iv++ |= 0x20;
  90b02c:	282003        	l8ui	a8, a2, 3
		b2 = (b1 | 0x20) & 0x7f;

		*iv++ = b1;
		*iv++ = b2;

		*iv++ = (a_uint8_t) ni->ni_iv16;
  90b02f:	242402        	s8i	a4, a2, 2
		*iv++ |= 0x20;
  90b032:	098802        	or	a8, a8, a9
  90b035:	282403        	s8i	a8, a2, 3

		tmp = (a_uint16_t) ni->ni_iv32;
  90b038:	8837      	l32i.n	a8, a3, 28
		*iv++ = (a_uint8_t) tmp;
  90b03a:	282404        	s8i	a8, a2, 4
		*iv++ = (a_uint8_t) (tmp >> 8);
  90b03d:	088847        	extui	a8, a8, 8, 8
  90b040:	282405        	s8i	a8, a2, 5

		tmp = (a_uint16_t) (ni->ni_iv32 >> 16);
  90b043:	23310e        	l16ui	a3, a3, 28
		*iv++ = (a_uint8_t) tmp;
  90b046:	232406        	s8i	a3, a2, 6
		*iv = (a_uint8_t) (tmp >> 8);
  90b049:	038314        	srli	a3, a3, 8
  90b04c:	232407        	s8i	a3, a2, 7

#undef CRYPTO_KEY_TYPE_TKIP
#undef CRYPTO_KEY_TYPE_AES
#undef CRYPTO_KEY_TYPE_WAPI
#undef IEEE80211_WLAN_HDR_LEN
}
  90b04f:	c021      	movi.n	a2, 1
  90b051:	d10f      	retw.n
