
/home/lex/tmp/my/ath9k-htc-firmware-blob/k2/fw.elf:     Dateiformat elf32-xtensa-be
/home/lex/tmp/my/ath9k-htc-firmware-blob/k2/fw.elf
Architektur: xtensa, Flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
Startadresse 0x00903000

Xtensa header:

Machine     = Base
Insn tables = true
Literal tables = true

Programm-Header:
    LOAD off    0x00501000 vaddr 0x00501000 paddr 0x00501000 align 2**29
         filesz 0x00000b40 memsz 0x00000b40 flags r--
    LOAD off    0x0050cb40 vaddr 0x0050cb40 paddr 0x0050cb40 align 2**29
         filesz 0x00000bfc memsz 0x00000cc8 flags rw-
    LOAD off    0x00903000 vaddr 0x00903000 paddr 0x00903000 align 2**29
         filesz 0x00007ec5 memsz 0x00007ec5 flags r-x

Sektionen:
Idx Name          Größe     VMA       LMA       Datei-Off Ausr.
  0 .lit4         0001be00  004e5200  004e5200  00000000  2**0
                  ALLOC
  1 .rodata       00000600  00501000  00501000  00501000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .literals     00000540  00501600  00501600  00501600  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .data         00000bfc  0050cb40  0050cb40  0050cb40  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          000000cc  0050d73c  0050d73c  0050d73c  2**2
                  ALLOC
  5 .boot         0000024e  00903000  00903000  00903000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .text         00007c75  00903250  00903250  00903250  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .debug_aranges 00000348  00000000  00000000  0090aec5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   00056ea3  00000000  00000000  0090b20d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00005923  00000000  00000000  009620b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   000112eb  00000000  00000000  009679d3  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  00001ce8  00000000  00000000  00978cc0  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00007f5b  00000000  00000000  0097a9a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    0000dbf1  00000000  00000000  00982903  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .xt.prop      00004bfc  00000000  00000000  009904f4  2**0
                  CONTENTS, READONLY
 15 .debug_ranges 00001390  00000000  00000000  009950f0  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .comment      0000006d  00000000  00000000  00996480  2**0
                  CONTENTS, READONLY
 17 .xtensa.info  00000038  00000000  00000000  009964ed  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
004e5200 l    d  .lit4	00000000 .lit4
00501000 l    d  .rodata	00000000 .rodata
00501600 l    d  .literals	00000000 .literals
0050cb40 l    d  .data	00000000 .data
0050d73c l    d  .bss	00000000 .bss
00903000 l    d  .boot	00000000 .boot
00903250 l    d  .text	00000000 .text
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .xt.prop	00000000 .xt.prop
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .xtensa.info	00000000 .xtensa.info
00000000 l    df *ABS*	00000000 magpie.c
00501000 l     O .rodata	0000000d __FUNCTION__$3683
00000000 l    df *ABS*	00000000 usb_api_main_patch.c
0050cb40 l     O .data	00000002 cmd_is_new$3658
0050d750 l     O .bss	00000004 evntbuf$3656
0050d754 l     O .bss	00000004 regaddr$3657
0050d758 l     O .bss	00000002 buf_len$3655
0050cb42 l     O .data	00000002 cmd_is_new$3677
0050d75c l     O .bss	00000004 buf$3675
0050d760 l     O .bss	00000002 cmd_len$3674
00501010 l     O .rodata	00000012 __func__$3678
0050d764 l     O .bss	00000004 regaddr$3673
00000000 l    df *ABS*	00000000 ar5416_hw.c
00501024 l     O .rodata	000000d0 ar5416hal_10
00000000 l    df *ABS*	00000000 if_ath.c
0090641c l     F .text	00000014 __adf_os_mem_alloc
00906430 l     F .text	00000013 __adf_os_mem_copy
00906444 l     F .text	00000013 __adf_os_mem_set
00906458 l     F .text	00000005 tgt_HTCRecv_uapsdhandler
00906460 l     F .text	00000006 dispatch_magpie_sys_cmds
00906468 l     F .text	00000005 htc_setup_comp
00906470 l     F .text	0000005b tgt_ServiceConnect
00906abc l     F .text	00000130 tgt_HTCSendCompleteHandler
009064cc l     F .text	0000002e tgt_reg_service
009064fc l     F .text	00000010 tgt_HTCRecv_mgmthandler
0090650c l     F .text	000000b6 ath_tgt_rx_tasklet
009065c4 l     F .text	00000098 ath_descdma_cleanup
0090665c l     F .text	00000014 __adf_os_init_bh$isra$4
00906670 l     F .text	00000010 __adf_os_sched_bh$isra$5
0050d77c l     O .bss	00000001 flg$7201
0050d77d l     O .bss	00000001 reset_pll$7195
00906680 l     F .text	0000008e ath_hal_reg_write_filter$isra$10
00906710 l     F .text	0000005c ath_reg_read_filter
0090676c l     F .text	0000004c ath_desc_free
009067b8 l     F .text	0000009b ath_descdma_setup$constprop$20
00906854 l     F .text	00000096 tgt_HTCRecvMessageHandler
009068ec l     F .text	0000003b tgt_HTCRecv_cabhandler
00906928 l     F .text	00000194 ath_rxdesc_init
00906c3c l     F .text	00000012 ath_fatal_tasklet
00906c50 l     F .text	00000012 ath_bmiss_tasklet
0050cdc0 l     O .data	00000004 ath_numrxbufs
0090739c l     F .text	0000004e ath_hal_reg_rmw_tgt
009073ec l     F .text	00000084 ath_rc_mask_tgt
00907470 l     F .text	00000023 ath_rx_stats_tgt
00907494 l     F .text	00000042 ath_tx_stats_tgt
009074d8 l     F .text	00000032 ath_int_stats_tgt
0090750c l     F .text	00000062 ath_node_update_tgt
00907570 l     F .text	0000002a ath_detach_tgt
00501118 l     O .rodata	00000014 __FUNCTION__$7117
0090759c l     F .text	00000088 ath_enable_aggr_tgt
00907624 l     F .text	0000002c ath_ic_update_tgt
00907650 l     F .text	00000056 handle_rc_rate_update_cmd
009076a8 l     F .text	00000052 handle_rc_state_change_cmd
009076fc l     F .text	0000002e ath_hal_reg_write_tgt
0090772c l     F .text	0000003f ath_hal_reg_read_tgt
0090776c l     F .text	0000005e ath_vap_create_tgt
009077cc l     F .text	00000054 ath_vap_delete_tgt
00907820 l     F .text	0000002c ath_node_cleanup_tgt
0090784c l     F .text	00000097 ath_node_create_tgt
009078e4 l     F .text	00000063 ath_setcurmode_tgt
00907948 l     F .text	00000050 ath_flushrecv_tgt
00907998 l     F .text	0000003a ath_stoprecv_tgt
009079d4 l     F .text	00000086 ath_startrecv_tgt
00907a5c l     F .text	000000c8 ath_draintxq_tgt
00907b24 l     F .text	0000002e ath_tx_draintxq_tgt
00907b54 l     F .text	00000023 ath_aborttx_dma_tgt
00907b78 l     F .text	00000026 ath_stop_tx_dma_tgt
00907ba0 l     F .text	00000040 ath_aborttxq_tgt
00907be0 l     F .text	0000004e ath_init_tgt
00907c30 l     F .text	00000054 ath_enable_intr_tgt
00907c84 l     F .text	00000026 ath_disable_intr_tgt
00907cac l     F .text	0000001e ath_get_tgt_version
00907ccc l     F .text	00000013 handle_echo_command
00907cf8 l     F .text	00000196 tgt_HTCRecv_beaconhandler
0050cdc8 l     O .data	00000100 Magpie_Sys_DispatchEntries
0050cdc4 l     O .data	00000004 ath_numrxdescs
00000000 l    df *ABS*	00000000 ratectrl_11n_ln.c
00908318 l     F .text	00000074 rcIsValidPhyRate
0090838c l     F .text	00000085 rcRateSetseries$isra$5
0050112c l     O .rodata	00000028 nRetry2PerLookup$7037
00908414 l     F .text	000001f6 rcUpdate_ht$isra$7
0090860c l     F .text	00000351 rcSibUpdate_ht$constprop$9
00000000 l    df *ABS*	00000000 if_owl.c
00908ec0 l     F .text	00000013 __adf_os_mem_copy
00501194 l     O .rodata	00000011 CSWTCH$54
00908ed4 l     F .text	0000004f ieee80211_anyhdrsize
00908f24 l     F .text	0000004b owl_tgt_tid_init
00908f70 l     F .text	00000077 ath_tgt_txq_add_ucast
00908fe8 l     F .text	0000006e ath_update_stats
00909058 l     F .text	0000005e ath_tx_update_baw
009090b8 l     F .text	00000016 ath_dma_unmap
009090d0 l     F .text	00000026 ath_tgt_skb_free
009090f8 l     F .text	000000a6 ath_filltxdesc
009091a0 l     F .text	0000004e ath_tx_tgt_setds
009091f0 l     F .text	00000024 ath_tgt_tx_enqueue
00909214 l     F .text	00000082 ath_update_aggr_stats$isra$2
00909298 l     F .text	00000013 __adf_os_mem_set$constprop$13
00501154 l     O .rodata	00000040 bits_per_symbol
009092ac l     F .text	000001ea ath_buf_set_rate
00909498 l     F .text	00000017 ath_dma_map
009094b0 l     F .text	000000cd ath_buf_toggle
0090accc l     F .text	000000f4 ath_bar_tx_comp
00909580 l     F .text	0000015b ath_bar_tx
009096dc l     F .text	0000003c ath_buf_comp
00909718 l     F .text	00000086 ath_tx_freebuf
009097b0 l     F .text	00000031 ath_tx_set_retry
00909934 l     F .text	000000e0 ath_tx_retry_subframe
00909a14 l     F .text	000000ae ath_tx_comp_aggr_error
0090a6e8 l     F .text	0000004e ath_tgt_tx_comp_normal
0090a45c l     F .text	000001f3 ath_tgt_txq_schedule
0090a650 l     F .text	0000004a ath_aggr_resume_tid
0090a69c l     F .text	0000004b owl_tgt_tid_cleanup
00000000 l    df *ABS*	00000000 app_start.c
0090adcc l     F .text	00000029 io32_rmw
00000000 l    df *ABS*	00000000 ah_osdep.c
00000000 l    df *ABS*	00000000 wlan_pci.c
00000000 l    df *ABS*	00000000 usb_api_k2_patch.c
00904698 l     F .text	0000002b io8_rmw
009046c4 l     F .text	00000021 io32_rmw$constprop$0
00000000 l    df *ABS*	00000000 k2_fw_cmnos_printf.c
00904ad0 l     F .text	00000055 _cvt
00904b28 l     F .text	0000002a cmnos_write_char
00000000 l    df *ABS*	00000000 if_ath_pci.c
00906348 l     F .text	00000005 ath_pci_suspend
00906350 l     F .text	00000005 ath_pci_resume
00906358 l     F .text	00000010 ath_pci_remove
0050cd80 l     O .data	00000020 ath_drv_info
00906378 l     F .text	0000007e ath_pci_probe
0050cda0 l     O .data	00000020 ath_pci_id_table
00000000 l    df *ABS*	00000000 init.c
0050d744 l     O .bss	00000004 loop_high
0050d748 l     O .bss	00000004 loop_low
00000000 l    df *ABS*	00000000 adf_nbuf.c
00000000 l    df *ABS*	00000000 buf_pool_static.c
00000000 l    df *ABS*	00000000 htc.c
00000000 l    df *ABS*	00000000 wmi_svc.c
0090447c l     F .text	0000000b WMIServiceConnect
00904488 l     F .text	00000007 _WMI_GetPendingEventsCount
00904490 l     F .text	00000007 _WMI_GetControlEp
00904498 l     F .text	00000014 _WMI_RegisterDispatchTable
009044ac l     F .text	00000005 _WMI_Shutdown
009044b4 l     F .text	0000008a WMIRecvMessageHandler
00904540 l     F .text	00000020 _WMI_SendCompleteHandler
00904560 l     F .text	00000030 _WMI_AllocEvent
00904590 l     F .text	00000036 _WMI_SendEvent
009045c8 l     F .text	0000006f _WMI_Init
00000000 l    df *ABS*	00000000 k2_HIF_usb_patch.c
00000000 l    df *ABS*	00000000 k2_cmnos_clock_patch.c
0050d778 l     O .bss	00000004 last_tick$3599
00000000 l    df *ABS*	00000000 ah.c
00000000 l    df *ABS*	00000000 ar5416_phy.c
00000000 l    df *ABS*	00000000 adf_net.c
00000000 l    df *ABS*	00000000 adf_os_irq_pvt.c
00000000 l    df *ABS*	00000000 adf_os_dma.c
00000000 l    df *ABS*	00000000 ar5416Phy.c
00000000 l    df *ABS*	00000000 ieee80211_output.c
00000000 l    df *ABS*	00000000 
005009e4 g       *ABS*	00000000 u16TxRxCounter
00903250 g     F .text	00000032 init_mem
00908e44 g     F .text	00000036 ath_rate_tx_complete
004e5200 g       *ABS*	00000000 _rom_literal_start
009034fc g     F .text	0000002b __adf_nbuf_dmamap_info
00903b24 g     F .text	00000078 bGet_descriptor_patch
00909b0c g     F .text	0000002d ath_tgt_tid_drain
009035f8 g     F .text	00000011 __adf_nbuf_last
0050d784 g     O .bss	00000004 save_cmnos_printf
005009f8 g       *ABS*	00000000 u8UsbInterfaceValue
0090342c g     F .text	0000000c __adf_nbuf_copy
0050d780 g     O .bss	00000004 _assfail_ori
009034dc g     F .text	00000009 __adf_nbuf_map
00501600 g       *ABS*	00000000 _bss_table_end
0090adf8 g     F .text	0000000c __adf_net_register_drv
0050d768 g     O .bss	00000004 g_wlan_intr
009034c0 g     F .text	0000001c __adf_nbuf_dmamap_create
009041c8 g     F .text	00000088 HTCControlSvcProcessMsg
0050cec8 g     O .data	00000004 ar5416_11ngRateTable
00903c28 g     F .text	0000000f wlan_pci_module_init
00500000 g       *ABS*	00000000 _indir_tbl
00904f30 g     F .text	00000010 ath_hal_attach_tgt
009037b4 g     F .text	00000023 buf_pool_module_install
00501000 g       *ABS*	00000000 _lit4_end
00903698 g     F .text	00000007 __adf_nbuf_is_cloned
0090394c g     F .text	00000107 usb_reg_out_patch
00903528 g     F .text	00000005 __adf_nbuf_set_rx_cksum
00905dcc g     F .text	000000bc ar5416AbortTxDma
0090aec5 g       *ABS*	00000000 _text_end
0090a738 g     F .text	0000035e ath_tgt_tx_comp_aggr
00904684 g     F .text	00000011 _HIFusb_isr_handler_patch
00908de8 g     F .text	0000002e ath_rate_attach
00905cd8 g     F .text	00000044 ar5416Set11nBurstDuration_20
00903a98 g     F .text	00000022 vUsbFIFO_EPxCfg_FS_patch
00903538 g     F .text	00000071 __adf_nbuf_create_frm_frag
0090381c g     F .text	00000022 cold_reboot
00501000 g       *ABS*	00000000 _lit4_start
00501b40 g       *ABS*	00000000 _dram0_literal_end
00904250 g     F .text	00000031 AdjustCreditThreshold
00501b40 g       *ABS*	00000000 _dram0_literal_start
00904fe4 g     F .text	00000029 ath_hal_wait
0090aec5 g       .text	00000000 _etext
00905d1c g     F .text	0000006f ar5416Set11nVirtualMoreFrag_20
008e408c g       *ABS*	00000000 vbuf_module_install
0050d740 g     O .bss	00000004 idle_cnt
009097e4 g     F .text	00000043 owl_tgt_node_init
00903840 g     F .text	0000010a usb_status_in_patch
00903c38 g     F .text	0000000a wlan_pci_register_drv
009033d4 g     F .text	0000002a __adf_nbuf_push_head
009037d8 g     F .text	00000022 _fw_usbfifo_recv_command
0090adc0 g     F .text	0000000a ar5416AttachRateTables
00903d5c g     F .text	000000bf _HTC_Init
009033bc g     F .text	00000006 __adf_nbuf_realloc_headroom
00905b08 g     F .text	00000089 ar5416Set11nAggrFirst_20
009034f4 g     F .text	00000005 __adf_nbuf_dmamap_destroy
00909e04 g     F .text	000003ae ath_tgt_send_mgt
00906338 g     F .text	00000010 ar5416GetRateTable
009036b8 g     F .text	0000000d __adf_nbuf_queue_init
008e4eb8 g       *ABS*	00000000 memcpy
00908e7c g     F .text	00000012 ath_rate_newassoc
00501600 g       *ABS*	00000000 _rodata_end
00903530 g     F .text	00000007 __adf_nbuf_get_vlan_info
00908c14 g     F .text	00000133 rcUpdate_11n
00904f7c g     F .text	00000067 ath_hal_computetxtime
00500a00 g       *ABS*	00000000 u8UsbDeviceDescriptor
00908d48 g     F .text	000000a0 ath_tx_status_update_rate
009036d0 g     F .text	00000007 __adf_nbuf_queue_first
0050d788 g     O .bss	00000004 htc_handle
009097a0 g     F .text	00000010 ATH_SKB_2_WH
0090ae0c g     F .text	000000b9 ieee80211_tgt_crypto_encap
008e4da0 g       *ABS*	00000000 __udivsi3
00903eac g     F .text	00000057 _HTC_Ready
00903b9c g     F .text	00000010 ath_hal_getuptime
0090360c g     F .text	00000024 __adf_nbuf_trim_tail
0050d740 g       *ABS*	00000000 _bss_start
0050cb40 g       *ABS*	00000000 _dram0_data_end
00903fac g     F .text	00000062 ReturnBuffers
00909d80 g     F .text	00000084 ath_tgt_tx_send_normal
005009fa g       *ABS*	00000000 u8UsbInterfaceAlternateSetting
0050d73c g       *ABS*	00000000 __XT_EXCEPTION_DESCS__
0090aba4 g     F .text	00000072 ath_tgt_handle_aggr
00903250 g       *ABS*	00000000 _text_start
009037fc g     F .text	00000020 _fw_usbfifo_init
0090aa98 g     F .text	0000009a owltgt_tx_processq
009033c4 g     F .text	00000006 __adf_nbuf_realloc_tailroom
0090a1b4 g     F .text	00000032 ath_tgt_handle_normal
00905400 g     F .text	00000015 ar5416StartTxDma
00905f98 g     F .text	00000059 ar5416SetRxFilter
00903c08 g     F .text	00000005 ath_hal_free
00904284 g     F .text	00000156 _HTC_SendMsg
009062c0 g     F .text	00000077 ar5416Attach
00903690 g     F .text	00000005 __adf_nbuf_cat
009053ec g     F .text	00000012 ar5416SetTxDP
00908e90 g     F .text	00000012 ath_rate_node_update
00903664 g     F .text	00000019 __adf_nbuf_tailroom
00903688 g     F .text	00000007 __adf_nbuf_clone
008e3ca4 g       *ABS*	00000000 mUsbFIFOConfig
00904a60 g     F .text	0000000a cmnos_clock_init_patch
008e2b58 g       *ABS*	00000000 _HIFusb_isr_handler
00903710 g     F .text	00000057 _buf_pool_static_create_pool
009036c8 g     F .text	00000007 __adf_nbuf_queue_len
00501000 g       *ABS*	00000000 _dport0_literal_start
009063f8 g     F .text	0000000b exit_ath_pci
0050d808 g       *ABS*	00000000 _bss_end
00903708 g     F .text	00000005 _buf_pool_static_shutdown
00905388 g     F .text	00000061 ar5416UpdateTxTrigLevel
0050d78c g     O .bss	0000002c g_poolCtx
0090346c g     F .text	0000000c __adf_nbuf_get_priv
00904144 g     F .text	00000082 HTCProcessConfigPipeMsg
00903768 g     F .text	00000022 _buf_pool_static_alloc_buf
00905eac g     F .text	0000000a ar5416Detach
009050fc g     F .text	0000000f ar5416EnableReceive
005009cc g       *ABS*	00000000 usbFifoConf
005009e0 g       *ABS*	00000000 pu8DescriptorEX
00904a6c g     F .text	0000000a cmnos_refclk_speed_get_patch
00905788 g     F .text	0000010c ar5416Set11nTxDesc_20
0050cb40 g       *ABS*	00000000 _dram0_data_start
00906368 g     F .text	0000000d init_ath_pci
008e2ec4 g       *ABS*	00000000 bGet_descriptor
00905418 g     F .text	0000002b ar5416NumTxPending
00907e90 g     F .text	00000432 ath_tgt_attach
00903d04 g     F .text	00000013 _HTC_GetReservedHeadroom
00903338 g     F .text	0000003c Magpie_init
0050d73c g       *ABS*	00000000 __XT_EXCEPTION_DESCS_END__
009035ac g     F .text	0000004c __adf_nbuf_split_to_frag
005009f0 g       *ABS*	00000000 eUsbCxCommand
00904638 g     F .text	00000037 WMI_service_module_install
0090378c g     F .text	00000010 _buf_pool_static_alloc_buf_align
008e4df0 g       *ABS*	00000000 __umodsi3
00501000 g       *ABS*	00000000 _dport0_rodata_start
0050cb40 g       *ABS*	00000000 _dport0_data_start
008e4cac g       *ABS*	00000000 xthal_get_ccount
009033cc g     F .text	00000006 __adf_nbuf_expand
00905034 g     F .text	00000083 ar5416SetInterrupts
009050ec g     F .text	0000000d ar5416SetRxDP
00909828 g     F .text	00000010 ath_tx_status_clear
0050d76c g     O .bss	00000004 g_wlan_drv_handle
008e2bd4 g       *ABS*	00000000 hif_module_install
00903d18 g     F .text	0000002a HTCSendDoneHandler
009046e8 g     F .text	000001d0 _fw_usb_suspend_reboot
008e3cec g       *ABS*	00000000 mUsbEPMxPtSzLow
009050b8 g     F .text	00000034 ar5416GetTsf64
0050d774 g     O .bss	00000004 ref_clk
00903f04 g     F .text	00000066 HTCCheckAndSendCreditReport
005009c0 g       *ABS*	00000000 ControlCmd
0050cb40 g       *ABS*	00000000 _data_start
005009f6 g       *ABS*	00000000 u8UsbConfigValue
00903be4 g     F .text	00000022 ath_hal_malloc
00905e88 g     F .text	00000021 ar5416StopDmaReceive
00903e1c g     F .text	00000005 _HTC_PauseRecv
0090ae04 g     F .text	00000005 __adf_net_unregister_drv
009082ec g     F .text	0000002b __adf_os_dmamem_alloc
008e3c68 g       *ABS*	00000000 mUsbEPMap
00903400 g     F .text	0000002b __adf_nbuf_pull_head
00906404 g     F .text	0000000c __adf_os_setup_intr
0050d74c g     O .bss	00000004 m_origUsbfifoRecvCmd
00904a94 g     F .text	0000002b cmnos_tick_patch
00903478 g     F .text	0000001e __adf_nbuf_queue_add
00907354 g     F .text	00000046 wmi_cmd_rsp
00903438 g     F .text	0000000c __adf_nbuf_unshare
0050d7b8 g     O .bss	00000012 UsbDeviceDescriptorPatch
0090379c g     F .text	00000016 _buf_pool_static_free_buf
009036e0 g     F .text	0000000e __adf_nbuf_is_queue_empty
00905010 g     F .text	00000022 ar5416IsInterruptPending
00903c10 g     F .text	00000015 ath_hal_memcpy
00903000 g     F .boot	0000024e app_start
00905444 g     F .text	000001e6 ar5416SetupTxDesc_20
0050088c g       *ABS*	00000000 cticks
008e413c g       *ABS*	00000000 vdesc_module_install
00909838 g     F .text	0000008b ath_tx_status_update
0050d73c g       *ABS*	00000000 _data_end
0090aec5 g       *ABS*	00000000 _iram0_text_end
0090a234 g     F .text	00000225 ath_tgt_tx_form_aggr
005015f0 g       *ABS*	00000000 __XT_EXCEPTION_TABLE__
0090a1e8 g     F .text	0000004a ath_tx_addto_baw
00903498 g     F .text	00000026 __adf_nbuf_queue_remove
009082c4 g     F .text	00000028 ath_detach
00903284 g     F .text	0000004d wlan_task
00501600 g       *ABS*	00000000 _literals_start
009036f0 g     F .text	00000017 _buf_pool_static_init
00903680 g     F .text	00000008 __adf_nbuf_len
00905d8c g     F .text	0000003d ar5416StopTxDma
00903cd4 g     F .text	00000016 wlan_pci_isr
008e519c g       *ABS*	00000000 memset
00501b40 g       *ABS*	00000000 _literals_end
00903cec g     F .text	00000005 _HTC_Shutdown
00904f40 g     F .text	0000003a ath_hal_getcapability
00903444 g     F .text	00000027 __adf_nbuf_frag_info
00501000 g       *ABS*	00000000 _dport0_rodata_end
00904a78 g     F .text	0000001c cmnos_delay_us_patch
005009ec g       *ABS*	00000000 eUsbCxFinishAction
00903e70 g     F .text	00000016 HTCFreeMsgBuffer
00905b94 g     F .text	00000083 ar5416Set11nAggrMiddle_20
009036a0 g     F .text	00000015 __adf_nbuf_peek_header
008e4cec g       *ABS*	00000000 __divsi3
0090519c g     F .text	000001ea ar5416ProcRxDescFast_20
00501000 g       *ABS*	00000000 _dram0_rodata_start
00501000 g       *ABS*	00000000 _rom_literal_end
00906bec g     F .text	0000004e wmi_event
00903ccc g     F .text	00000007 wlan_pci_config_read
00906c64 g     F .text	000006f0 ath_intr
00904010 g     F .text	00000010 _HTC_ReturnBuffers
008e1548 g       *ABS*	00000000 athos_indirection_table_install
0090ab34 g     F .text	0000006e owl_tgt_tx_tasklet
008e3cc4 g       *ABS*	00000000 mUsbEPMxPtSzHigh
00903bd4 g     F .text	00000010 ath_hal_delay
005009e8 g       *ABS*	00000000 u8ConfigDescriptorEX
00903374 g     F .text	0000003e __adf_nbuf_alloc
009036d8 g     F .text	00000007 __adf_nbuf_queue_next
005009f4 g       *ABS*	00000000 UsbChirpFinish
009043dc g     F .text	00000097 HTCMsgRecvHandler
009098c4 g     F .text	0000006e ath_tx_status_update_aggr
009033b4 g     F .text	00000006 __adf_nbuf_free
008e3c84 g       *ABS*	00000000 mUsbFIFOMap
009032d4 g     F .text	00000005 htc_setup_comp
005015f0 g       *ABS*	00000000 _bss_table_start
0050cb44 g     O .data	00000238 ar5416_11ng_table
009049d8 g     F .text	00000086 _fw_usb_reset_fifo
009034e8 g     F .text	00000009 __adf_nbuf_unmap
00903658 g     F .text	0000000a __adf_nbuf_headroom
0090ac18 g     F .text	000000b3 ath_tgt_tx_cleanup
008e328c g       *ABS*	00000000 bStandardCommand
008e2f7c g       *ABS*	00000000 bSet_configuration
00903c44 g     F .text	00000080 wlan_pci_probe
00903e2c g     F .text	00000041 htc_module_install
0050cb40 g       *ABS*	00000000 _dport0_data_end
00904ac0 g     F .text	0000000d cmnos_milliseconds_patch
00501000 g       *ABS*	00000000 _rodata_start
00907ce0 g     F .text	00000018 ath_get_minrateidx
0050d808 g       .bss	00000000 _end
00904670 g     F .text	00000011 _HIFusb_get_max_msg_len_patch
00909ac4 g     F .text	00000046 ath_tx_status_send
0090aec5 g       *ABS*	00000000 _iram0_text_start
00905c18 g     F .text	0000007d ar5416Set11nAggrLast_20
00903f6c g     F .text	0000003f HTCControlSvcProcessSendComplete
00903e88 g     F .text	00000021 HTCAllocMsgBuffer
0050cd7c g     O .data	00000004 g_pci_init_func
00903cf4 g     F .text	0000000d _HTC_RegisterService
00903bac g     F .text	00000026 _ath_hal_attach_tgt
00904064 g     F .text	000000e0 HTCProcessConnectMsg
00905c98 g     F .text	0000003e ar5416Clr11nAggr_20
00908960 g     F .text	000002b2 rcRateFind_11n
00903630 g     F .text	00000026 __adf_nbuf_put_tail
00908e18 g     F .text	0000002c ath_rate_findrate
0050d770 g     O .bss	00000004 g_wlan_drv
0090562c g     F .text	00000136 ar5416FillTxDesc_20
00903d44 g     F .text	00000017 HTC_AssembleBuffers
0050d808 g       *ABS*	00000000 _fw_image_end
00903e24 g     F .text	00000005 _HTC_ResumeRecv
00909b3c g     F .text	00000244 ath_tgt_tx_prepare
00903250 g       .text	00000000 _stext
00903abc g     F .text	00000023 bSet_configuration_patch
00906410 g     F .text	0000000c __adf_os_free_intr
00905764 g     F .text	00000021 ar5416FillKeyTxDesc_20
009032dc g     F .text	0000005a _wmi_cmd_rsp
00903cc4 g     F .text	00000007 wlan_pci_config_write
00904020 g     F .text	00000044 _HTC_ReturnBuffersList
00904b54 g     F .text	000003db fw_cmnos_printf
00905124 g     F .text	00000077 ar5416SetupRxDesc_20
008e3d10 g       *ABS*	00000000 mUsbEPinHighBandSet
00908ea4 g     F .text	0000001b ath_rate_newstate
0050cb40 g       *ABS*	00000000 _dport0_bss_start
00501000 g       *ABS*	00000000 _dram0_rodata_end
00905ff4 g     F .text	000002c9 ar5416ProcTxDesc_20
00904474 g     F .text	00000005 RedistributeCredit
00903a54 g     F .text	00000042 vUSBFIFO_EP6Cfg_FS_patch
0050cb40 g       *ABS*	00000000 _dport0_bss_end
00903ae0 g     F .text	00000044 bStandardCommand_patch
0050d7cc g     O .bss	0000003c ConfigDescriptorPatch
00905eb8 g     F .text	000000df ar5416GetPendingInterrupts
00501000 g       *ABS*	00000000 _dport0_literal_end
00905894 g     F .text	00000274 ar5416Set11nRateScenario_20
0090510c g     F .text	00000017 ar5416StopPcuReceive
009048b8 g     F .text	0000011e _fw_usb_fw_task



Disassembly of section .boot:

00903000 <app_start>:

extern BOOLEAN bJumptoFlash;
extern BOOLEAN bEepromExist;

void __section(boot) __noreturn __visible app_start(void)
{
  903000:	6c1004        	entry	a1, 32
#if defined(PROJECT_MAGPIE)
	T_EEP_RET retEEP;
#endif

	/* Zero BSS segment & dynamic memory section. */
	init_mem();
  903003:	580093        	call8	903250 <_text_start>

#if defined(PROJECT_MAGPIE)
	fatal_exception_func();
#endif

	if( IS_FLASHBOOT() ) {
  903006:	127182        	l32r	a2, 8df610 <_bss_end+0x3d1e08>
  903009:	0c0200        	memw
  90300c:	8320      	l32i.n	a3, a2, 0
  90300e:	127183        	l32r	a2, 8df61c <_bss_end+0x3d1e14>
  903011:	03035f        	extui	a3, a3, 16, 16
  903014:	723941        	bne	a3, a2, 903059 <app_start+0x59>
		athos_indirection_table_install();
  903017:	5b794c        	call8	8e1548 <athos_indirection_table_install>
		DBG_MODULE_INSTALL();
		A_CLOCK_INIT(SYSTEM_CLK);
  90301a:	127184        	l32r	a2, 8df62c <_bss_end+0x3d1e24>
  90301d:	1a7185        	l32r	a10, 8df634 <_bss_end+0x3d1e2c>
  903020:	232237        	l32i	a3, a2, 220
  903023:	0b3000        	callx8	a3
		A_UART_INIT();
  903026:	2a2213        	l32i	a10, a2, 76
  903029:	0ba000        	callx8	a10
		A_PRINTF_INIT();
  90302c:	232211        	l32i	a3, a2, 68
  90302f:	0b3000        	callx8	a3
		A_DBG_INIT();
		A_EEP_INIT();
  903032:	23225f        	l32i	a3, a2, 0x17c
  903035:	0b3000        	callx8	a3
		A_TASKLET_INIT();
  903038:	232269        	l32i	a3, a2, 0x1a4
  90303b:	0b3000        	callx8	a3
		_indir_tbl.cmnos.timer._timer_init();
  90303e:	222241        	l32i	a2, a2, 0x104
  903041:	0b2000        	callx8	a2
#if defined(PROJECT_K2)
		/*
		 * WAR: these variable is not initialized when boot from flash
		 *      either re-enumeration or config them to default value = 0 would fix the issue
		 */
		u8UsbInterfaceAlternateSetting = u8UsbConfigValue = u8UsbInterfaceValue = 0;
  903044:	137186        	l32r	a3, 8df65c <_bss_end+0x3d1e54>
  903047:	220a00        	movi	a2, 0
  90304a:	223500        	s16i	a2, a3, 0
  90304d:	137187        	l32r	a3, 8df66c <_bss_end+0x3d1e64>
  903050:	223500        	s16i	a2, a3, 0
  903053:	137188        	l32r	a3, 8df674 <_bss_end+0x3d1e6c>
  903056:	223500        	s16i	a2, a3, 0
	} else {
		bEepromExist = FALSE;
	}
#endif

	hostif = A_IS_HOST_PRESENT();
  903059:	127184        	l32r	a2, 8df66c <_bss_end+0x3d1e64>
  90305c:	8a2e      	l32i.n	a10, a2, 56
  90305e:	0ba000        	callx8	a10
  903061:	d4a0      	mov.n	a4, a10
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  903063:	137189        	l32r	a3, 8df688 <_bss_end+0x3d1e80>
#elif defined(PROJECT_K2)
	rst_status = ioread32(MAGPIE_REG_RST_STATUS_ADDR);
#endif /* #if defined(PROJECT_MAGPIE) */


	A_PRINTF(" A_WDT_INIT()\n\r");
  903066:	252212        	l32i	a5, a2, 72
  903069:	1a718a        	l32r	a10, 8df694 <_bss_end+0x3d1e8c>
  90306c:	0c0200        	memw
  90306f:	8330      	l32i.n	a3, a3, 0
  903071:	0b5000        	callx8	a5

#if defined(PROJECT_K2)
	save_cmnos_printf = fw_cmnos_printf;
  903074:	16718b        	l32r	a6, 8df6a0 <_bss_end+0x3d1e98>
  903077:	15718c        	l32r	a5, 8df6a8 <_bss_end+0x3d1ea0>
  90307a:	9560      	s32i.n	a5, a6, 0
#endif

	if( hostif == HIF_USB ) {
  90307c:	654014        	bnez	a4, 903094 <app_start+0x94>
#if defined(PROJECT_K2)
#if MOVE_PRINT_TO_RAM
		save_cmnos_printf = _indir_tbl.cmnos.printf._printf;
  90307f:	272212        	l32i	a7, a2, 72
		_indir_tbl.cmnos.printf._printf = fw_cmnos_printf;
  903082:	252612        	s32i	a5, a2, 72
#endif
		_indir_tbl.cmnos.usb._usb_fw_task = _fw_usb_fw_task;
  903085:	15718d        	l32r	a5, 8df6bc <_bss_end+0x3d1eb4>
#endif

	if( hostif == HIF_USB ) {
#if defined(PROJECT_K2)
#if MOVE_PRINT_TO_RAM
		save_cmnos_printf = _indir_tbl.cmnos.printf._printf;
  903088:	276600        	s32i	a7, a6, 0
		_indir_tbl.cmnos.printf._printf = fw_cmnos_printf;
#endif
		_indir_tbl.cmnos.usb._usb_fw_task = _fw_usb_fw_task;
  90308b:	25261d        	s32i	a5, a2, 116
		_indir_tbl.cmnos.usb._usb_reset_fifo = _fw_usb_reset_fifo;
  90308e:	15718e        	l32r	a5, 8df6c8 <_bss_end+0x3d1ec0>
  903091:	252629        	s32i	a5, a2, 164
#endif
	}

	if( rst_status == WDT_MAGIC_PATTERN ) {
  903094:	15718f        	l32r	a5, 8df6d0 <_bss_end+0x3d1ec8>
  903097:	127184        	l32r	a2, 8df6a8 <_bss_end+0x3d1ea0>
  90309a:	75391b        	bne	a3, a5, 9030b9 <app_start+0xb9>
		A_PRINTF(" ==>WDT reset<==\n");
  90309d:	222212        	l32i	a2, a2, 72
  9030a0:	1a7190        	l32r	a10, 8df6e0 <_bss_end+0x3d1ed8>
  9030a3:	0b2000        	callx8	a2
#if defined(PROJECT_MAGPIE)
		reset_EP4_FIFO();
#endif
		*((volatile uint32_t*)WATCH_DOG_RESET_COUNTER_ADDR)+=1;
  9030a6:	127191        	l32r	a2, 8df6ec <_bss_end+0x3d1ee4>
  9030a9:	0c0200        	memw
  9030ac:	8320      	l32i.n	a3, a2, 0
  9030ae:	b133      	addi.n	a3, a3, 1
  9030b0:	0c0200        	memw
  9030b3:	9320      	s32i.n	a3, a2, 0
  9030b5:	600012        	j	9030cb <app_start+0xcb>
  9030b8:	001571        	excw
	} else if (rst_status == SUS_MAGIC_PATTERN) {
  9030bb:	9222      	s32i.n	a2, a2, 8
		A_PRINTF(" ==>warm start<==\n");
  9030bd:	22121a        	l32i	a2, a1, 104
  9030c0:	719375        	bltu	a9, a1, 903139 <app_start+0x139>
		A_PRINTF(" ==>WDT reset<==\n");
#if defined(PROJECT_MAGPIE)
		reset_EP4_FIFO();
#endif
		*((volatile uint32_t*)WATCH_DOG_RESET_COUNTER_ADDR)+=1;
	} else if (rst_status == SUS_MAGIC_PATTERN) {
  9030c3:	31021a        	excw
		A_PRINTF(" ==>warm start<==\n");
	} else
		A_PRINTF(" ==>cold start<==\n");
  9030c6:	71940b        	ball	a9, a1, 9030d5 <app_start+0xd5>
  9030c9:	200013        	l8ui	a0, a0, 19
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  9030cc:	718f12        	bbsi	a8, 17, 9030e2 <app_start+0xe2>
  9030cf:	71891a        	bne	a8, a1, 9030ed <app_start+0xed>
	SFLASH_MODULE_INSTALL();
	A_SFLASH_INIT();
#endif
#endif

	HIF_MODULE_INSTALL();
  9030d2:	71950c        	bbc	a9, a1, 9030e2 <app_start+0xe2>
  9030d5:	020093        	excw
  9030d8:	205b7e        	l32ai	a0, a5, 0x1f8
  9030db:	be1a      	addi.n	a10, a1, 14
	HTC_MODULE_INSTALL();
  9030dd:	719658        	bbci	a9, 1, 903139 <app_start+0x139>
  9030e0:	03531a        	excw
	WMI_SERVICE_MODULE_INSTALL();
  9030e3:	719758        	bbci	a9, 17, 90313f <app_start+0x13f>
  9030e6:	05541a        	excw
	BUF_POOL_MODULE_INSTALL();
  9030e9:	719858        	bany	a9, a1, 903145 <app_start+0x145>
  9030ec:	01b21a        	excw
	VBUF_MODULE_INSTALL();
  9030ef:	71995b        	bne	a9, a1, 90314e <app_start+0x14e>
  9030f2:	83e6      	l32i.n	a3, a14, 24
	VDESC_MODULE_INSTALL();
  9030f4:	1a719a        	l32r	a10, 8df75c <_bss_end+0x3d1f54>
  9030f7:	5b8411        	call8	8e413c <vdesc_module_install>

	//init each module, should be put together..
	A_PRINTF("ALLOCRAM start 0x%x size %d\n", ALLOCRAM_START, ALLOCRAM_SIZE);
  9030fa:	13719b        	l32r	a3, 8df768 <_bss_end+0x3d1f60>
  9030fd:	15719c        	l32r	a5, 8df770 <_bss_end+0x3d1f68>
  903100:	127184        	l32r	a2, 8df710 <_bss_end+0x3d1f08>
  903103:	b437      	addi.n	a7, a3, 4
  903105:	282212        	l32i	a8, a2, 72
  903108:	03560c        	sub	a6, a5, a3
  90310b:	1a719d        	l32r	a10, 8df780 <_bss_end+0x3d1f78>
  90310e:	db70      	mov.n	a11, a7
  903110:	dc60      	mov.n	a12, a6
  903112:	0b8000        	callx8	a8
	A_ALLOCRAM_INIT(ALLOCRAM_START, ALLOCRAM_SIZE);
  903115:	c78c      	movi.n	a8, -4
  903117:	78310a        	beq	a3, a8, 903125 <app_start+0x125>
  90311a:	da70      	mov.n	a10, a7
  90311c:	753908        	bne	a3, a5, 903128 <app_start+0x128>
  90311f:	60000d        	j	903130 <app_start+0x130>
  903122:	000000        	ill
  903125:	1a7180        	l32r	a10, 8df728 <_bss_end+0x3d1f20>
  903128:	db60      	mov.n	a11, a6
  90312a:	600005        	j	903133 <app_start+0x133>
  90312d:	000000        	ill
  903130:	1b7181        	l32r	a11, 8df734 <_bss_end+0x3d1f2c>
  903133:	232251        	l32i	a3, a2, 0x144
  903136:	0b3000        	callx8	a3

	if( hostif == HIF_USB ) {
  903139:	6540b8        	bnez	a4, 9031f5 <app_start+0x1f5>
		_indir_tbl.hif._get_max_msg_len = _HIFusb_get_max_msg_len_patch;
  90313c:	13719e        	l32r	a3, 8df7b4 <_bss_end+0x3d1fac>
  90313f:	23267e        	s32i	a3, a2, 0x1f8
		_indir_tbl.cmnos.usb._usb_reg_out = usb_reg_out_patch;
  903142:	13719f        	l32r	a3, 8df7c0 <_bss_end+0x3d1fb8>
  903145:	232632        	s32i	a3, a2, 200
		_indir_tbl.hif._isr_handler = _HIFusb_isr_handler_patch;
  903148:	1371a0        	l32r	a3, 8df7c8 <_bss_end+0x3d1fc0>
  90314b:	232680        	s32i	a3, a2, 0x200
		_indir_tbl.cmnos.usb._usb_set_configuration = bSet_configuration_patch;
  90314e:	1371a1        	l32r	a3, 8df7d4 <_bss_end+0x3d1fcc>
  903151:	232625        	s32i	a3, a2, 148
		_indir_tbl.cmnos.usb._usb_status_in = usb_status_in_patch;
  903154:	1371a2        	l32r	a3, 8df7dc <_bss_end+0x3d1fd4>
  903157:	232633        	s32i	a3, a2, 204
		_indir_tbl.cmnos.usb._usb_get_descriptor = bGet_descriptor_patch;
  90315a:	1371a3        	l32r	a3, 8df7e8 <_bss_end+0x3d1fe0>
  90315d:	23262f        	s32i	a3, a2, 188
		_indir_tbl.cmnos.usb._usb_standard_cmd = bStandardCommand_patch;
  903160:	1371a4        	l32r	a3, 8df7f0 <_bss_end+0x3d1fe8>
  903163:	232626        	s32i	a3, a2, 152
		_indir_tbl.usbfifo_api._init = _fw_usbfifo_init;
  903166:	1371a5        	l32r	a3, 8df7fc <_bss_end+0x3d1ff4>
  903169:	23269b        	s32i	a3, a2, 0x26c

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  90316c:	1271a6        	l32r	a2, 8df804 <_bss_end+0x3d1ffc>
  90316f:	222000        	l8ui	a2, a2, 0
		_indir_tbl.hif._start = _HIFusb_start_patch;
		_indir_tbl.htc._HTC_MsgRecvHandler = HTCMsgRecvHandler_patch;
		_indir_tbl.htc._HTC_ControlSvcProcessMsg = HTCControlSvcProcessMsg_patch;
#endif

		if (!(ioread8_usb(ZM_MAIN_CTRL_OFFSET) & BIT6))
  903172:	792f02        	bbsi	a2, 25, 903178 <app_start+0x178>
			vUSBFIFO_EP6Cfg_FS_patch();
  903175:	580237        	call8	903a54 <vUSBFIFO_EP6Cfg_FS_patch>
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  903178:	1271a7        	l32r	a2, 8df814 <_bss_end+0x3d200c>

#ifdef FUSION_USB_ENABLE_TX_STREAM
		// For K2, enable tx stream mode
		A_PRINTF("Enable Tx Stream mode: 0x%x\r\n",
  90317b:	137184        	l32r	a3, 8df78c <_bss_end+0x3d1f84>
  90317e:	0c0200        	memw
  903181:	2b2200        	l32i	a11, a2, 0
  903184:	233212        	l32i	a3, a3, 72
  903187:	1a71a8        	l32r	a10, 8df828 <_bss_end+0x3d2020>
  90318a:	0b3000        	callx8	a3
			ioread32_usb(ZM_SOC_USB_MODE_CTRL_OFFSET));

		/* Patch for K2 USB STREAM mode */
		/* disable down stream DMA mode */
		io32_rmw_usb(ZM_SOC_USB_MODE_CTRL_OFFSET, BIT6, BIT0);
  90318d:	da20      	mov.n	a10, a2
  90318f:	c4b0      	movi.n	a11, 64
  903191:	c0c1      	movi.n	a12, 1
  903193:	581f0e        	call8	90adcc <io32_rmw>
#if SYSTEM_MODULE_HP_EP5
		io32_set_usb(ZM_SOC_USB_MODE_CTRL_OFFSET, BIT8);
  903196:	da20      	mov.n	a10, a2
  903198:	2b1a00        	movi	a11, 0x100
  90319b:	c0c0      	movi.n	a12, 0
  90319d:	581f0b        	call8	90adcc <io32_rmw>
#endif

#if SYSTEM_MODULE_HP_EP6
		io32_set_usb(ZM_SOC_USB_MODE_CTRL_OFFSET, BIT9);
  9031a0:	da20      	mov.n	a10, a2
  9031a2:	2b2a00        	movi	a11, 0x200
  9031a5:	c0c0      	movi.n	a12, 0
  9031a7:	581f09        	call8	90adcc <io32_rmw>
#endif
		/* enable down stream DMA mode */
		io32_set_usb(ZM_SOC_USB_MODE_CTRL_OFFSET, BIT0);
  9031aa:	da20      	mov.n	a10, a2
  9031ac:	c0b1      	movi.n	a11, 1
  9031ae:	2c0a00        	movi	a12, 0
  9031b1:	581f06        	call8	90adcc <io32_rmw>
#endif

#ifdef FUSION_USB_ENABLE_RX_STREAM
		/* Patch for K2 USB STREAM mode */
		/* disable upstream DMA mode and enable upstream stream mode */
		io32_clr_usb(ZM_SOC_USB_MODE_CTRL_OFFSET, BIT1 | BIT3);
  9031b4:	da20      	mov.n	a10, a2
  9031b6:	c0b0      	movi.n	a11, 0
  9031b8:	c0ca      	movi.n	a12, 10
  9031ba:	581f04        	call8	90adcc <io32_rmw>

		/* K2, Set maximum IN transfer to 8K */
		io32_rmw_usb(ZM_SOC_USB_MODE_CTRL_OFFSET, 0x20, 0x30);
  9031bd:	da20      	mov.n	a10, a2
  9031bf:	c2b0      	movi.n	a11, 32
  9031c1:	c3c0      	movi.n	a12, 48
  9031c3:	581f02        	call8	90adcc <io32_rmw>

		/* enable upstream DMA mode */
		io32_set_usb(ZM_SOC_USB_MODE_CTRL_OFFSET, BIT1);
  9031c6:	da20      	mov.n	a10, a2
  9031c8:	c0b2      	movi.n	a11, 2
  9031ca:	2c0a00        	movi	a12, 0
  9031cd:	581eff        	call8	90adcc <io32_rmw>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  9031d0:	1271a9        	l32r	a2, 8df874 <_bss_end+0x3d206c>
  9031d3:	230aa0        	movi	a3, 160
  9031d6:	0c0200        	memw
  9031d9:	9320      	s32i.n	a3, a2, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  9031db:	1271aa        	l32r	a2, 8df884 <_bss_end+0x3d207c>
  9031de:	0c0200        	memw
  9031e1:	8320      	l32i.n	a3, a2, 0
  9031e3:	1271ab        	l32r	a2, 8df890 <_bss_end+0x3d2088>

		/* set stream mode timeout critirea */
		iowrite32_usb(ZM_SOC_USB_TIME_CTRL_OFFSET, 0xa0);
#if defined(PROJECT_K2)
		/*0x10004020 is vaild in k2 but could be invaild in other chip*/
		if ((ioread32(0x10004020) & 0x2000) != 0) {
  9031e6:	723704        	bbci	a3, 18, 9031ee <app_start+0x1ee>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  9031e9:	c030      	movi.n	a3, 0
  9031eb:	600001        	j	9031f0 <app_start+0x1f0>
  9031ee:	c039      	movi.n	a3, 9
  9031f0:	0c0200        	memw
  9031f3:	9320      	s32i.n	a3, a2, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  9031f5:	1271ac        	l32r	a2, 8df8a8 <_bss_end+0x3d20a0>
	}
#if defined(PROJECT_MAGPIE) && !defined(ROM_VER_1_1)
	else if (hostif == HIF_PCI )
		hif_pci_patch_install(&_indir_tbl.hif);
#endif
	A_PRINTF("USB mode: 0x%x\r\n", ioread32_usb(0x100));
  9031f8:	1a71ad        	l32r	a10, 8df8ac <_bss_end+0x3d20a4>
  9031fb:	0c0200        	memw
  9031fe:	8b20      	l32i.n	a11, a2, 0
  903200:	127184        	l32r	a2, 8df810 <_bss_end+0x3d2008>
  903203:	232212        	l32i	a3, a2, 72
  903206:	0b3000        	callx8	a3

	// patch the clock function
	if(1) {
		_indir_tbl.cmnos.clock._clock_init = cmnos_clock_init_patch;
  903209:	1371ae        	l32r	a3, 8df8c4 <_bss_end+0x3d20bc>
		_indir_tbl.cmnos.clock._delay_us = cmnos_delay_us_patch;
		_indir_tbl.cmnos.clock._clock_tick = cmnos_tick_patch;
		_indir_tbl.cmnos.clock._milliseconds = cmnos_milliseconds_patch;

		//default clock, setup initial variable, SYSTEM_FREQ=40
		A_CLOCK_INIT(SYSTEM_FREQ);
  90320c:	2a0a28        	movi	a10, 40
#endif
	A_PRINTF("USB mode: 0x%x\r\n", ioread32_usb(0x100));

	// patch the clock function
	if(1) {
		_indir_tbl.cmnos.clock._clock_init = cmnos_clock_init_patch;
  90320f:	232637        	s32i	a3, a2, 220
		_indir_tbl.cmnos.clock._refclk_speed_get = cmnos_refclk_speed_get_patch;
  903212:	1371af        	l32r	a3, 8df8d0 <_bss_end+0x3d20c8>
  903215:	23263c        	s32i	a3, a2, 240
		_indir_tbl.cmnos.clock._delay_us = cmnos_delay_us_patch;
  903218:	1371b0        	l32r	a3, 8df8d8 <_bss_end+0x3d20d0>
  90321b:	23263a        	s32i	a3, a2, 232
		_indir_tbl.cmnos.clock._clock_tick = cmnos_tick_patch;
  90321e:	1371b1        	l32r	a3, 8df8e4 <_bss_end+0x3d20dc>
  903221:	232640        	s32i	a3, a2, 0x100
		_indir_tbl.cmnos.clock._milliseconds = cmnos_milliseconds_patch;
  903224:	1371b2        	l32r	a3, 8df8ec <_bss_end+0x3d20e4>
  903227:	23263d        	s32i	a3, a2, 244

		//default clock, setup initial variable, SYSTEM_FREQ=40
		A_CLOCK_INIT(SYSTEM_FREQ);
  90322a:	58060d        	call8	904a60 <cmnos_clock_init_patch>
	}

	Magpie_init();
  90322d:	580042        	call8	903338 <Magpie_init>

#if MAGPIE_ENABLE_WLAN == 1
	io32_clr(MAGPIE_REG_RST_RESET_ADDR, BIT10 | BIT8 | BIT7 | BIT6);
  903230:	1a71b3        	l32r	a10, 8df8fc <_bss_end+0x3d20f4>
  903233:	2b0a00        	movi	a11, 0
  903236:	2c5ac0        	movi	a12, 0x5c0
  903239:	581ee4        	call8	90adcc <io32_rmw>
#if defined(PROJECT_MAGPIE)
	io32_set(MAGPIE_REG_AHB_ARB_ADDR, BIT1);
#endif

	wlan_pci_module_init();
  90323c:	58027a        	call8	903c28 <wlan_pci_module_init>
	wlan_pci_probe();
  90323f:	580281        	call8	903c44 <wlan_pci_probe>
#endif


	A_PRINTF("Tgt running\n\r");
  903242:	1a71b4        	l32r	a10, 8df914 <_bss_end+0x3d210c>
  903245:	222212        	l32i	a2, a2, 72
  903248:	0b2000        	callx8	a2
		_indir_tbl.cmnos.misc._assfail = exception_reset;
	}

	change_magpie_clk();
#endif
	wlan_task(); //never return
  90324b:	58000e        	call8	903284 <wlan_task>

Disassembly of section .text:

00903250 <init_mem>:
	}
}
#endif

void init_mem()
{
  903250:	6c1004        	entry	a1, 32
	int i = 0;
	uint32_t *temp = (uint32_t *)ALLOCRAM_START;

	/* clear bss segment */
	for(temp = (uint32_t *)&START_BSS; temp < (uint32_t *)&END_BSS; temp++)
  903253:	1871b5        	l32r	a8, 8df928 <_bss_end+0x3d2120>
  903256:	1971b6        	l32r	a9, 8df930 <_bss_end+0x3d2128>
		*temp = 0;
  903259:	c0a0      	movi.n	a10, 0
{
	int i = 0;
	uint32_t *temp = (uint32_t *)ALLOCRAM_START;

	/* clear bss segment */
	for(temp = (uint32_t *)&START_BSS; temp < (uint32_t *)&END_BSS; temp++)
  90325b:	600003        	j	903262 <init_mem+0x12>
		*temp = 0;
  90325e:	9a80      	s32i.n	a10, a8, 0
{
	int i = 0;
	uint32_t *temp = (uint32_t *)ALLOCRAM_START;

	/* clear bss segment */
	for(temp = (uint32_t *)&START_BSS; temp < (uint32_t *)&END_BSS; temp++)
  903260:	b488      	addi.n	a8, a8, 4
  903262:	7983f8        	bltu	a8, a9, 90325e <init_mem+0xe>
		*temp = 0;

	/* clear heap segment */
	for(i = 0; i < ((ALLOCRAM_SIZE - 4)/4); i++)
  903265:	1a71b7        	l32r	a10, 8df944 <_bss_end+0x3d213c>
  903268:	19719b        	l32r	a9, 8df8d4 <_bss_end+0x3d20cc>
  90326b:	09a90c        	sub	a9, a10, a9
  90326e:	092914        	srli	a9, a9, 2
			HTCMsgRecvHandler( hdr_buf, buffer, context);
	}
}
#endif

void init_mem()
  903271:	08990a        	addx4	a9, a9, a8
	for(temp = (uint32_t *)&START_BSS; temp < (uint32_t *)&END_BSS; temp++)
		*temp = 0;

	/* clear heap segment */
	for(i = 0; i < ((ALLOCRAM_SIZE - 4)/4); i++)
		temp[i] = 0;
  903274:	c0a0      	movi.n	a10, 0
  903276:	600003        	j	90327d <init_mem+0x2d>
  903279:	9a80      	s32i.n	a10, a8, 0
  90327b:	b488      	addi.n	a8, a8, 4
	/* clear bss segment */
	for(temp = (uint32_t *)&START_BSS; temp < (uint32_t *)&END_BSS; temp++)
		*temp = 0;

	/* clear heap segment */
	for(i = 0; i < ((ALLOCRAM_SIZE - 4)/4); i++)
  90327d:	7989f8        	bne	a8, a9, 903279 <init_mem+0x29>
		temp[i] = 0;
}
  903280:	d10f      	retw.n
	...

00903284 <wlan_task>:
	}
	return;
}

void __noreturn wlan_task(void)
{
  903284:	6c1004        	entry	a1, 32
	loop_low=loop_high=0;
  903287:	1871b8        	l32r	a8, 8df968 <_bss_end+0x3d2160>
  90328a:	c020      	movi.n	a2, 0
  90328c:	9280      	s32i.n	a2, a8, 0
  90328e:	1871b9        	l32r	a8, 8df974 <_bss_end+0x3d216c>
  903291:	9280      	s32i.n	a2, a8, 0

	while(1) {
		/* update wdt timer */
		A_WDT_TASK();
  903293:	127184        	l32r	a2, 8df8a4 <_bss_end+0x3d209c>
  903296:	28225c        	l32i	a8, a2, 0x170
  903299:	0b8000        	callx8	a8

		/* UPDATE cticks - to be moved to idle_tsk, put here will be easier to read  */
		A_CLOCK_TICK();
  90329c:	282240        	l32i	a8, a2, 0x100
  90329f:	0b8000        	callx8	a8

		HIF_isr_handler(NULL);
  9032a2:	282280        	l32i	a8, a2, 0x200
  9032a5:	c0a0      	movi.n	a10, 0
  9032a7:	0b8000        	callx8	a8

#if MAGPIE_ENABLE_WLAN == 1
		wlan_pci_isr();
  9032aa:	58028a        	call8	903cd4 <wlan_pci_isr>
#endif

		A_TASKLET_RUN();
  9032ad:	28226d        	l32i	a8, a2, 0x1b4
  9032b0:	0b8000        	callx8	a8
		A_TIMER_RUN();
  9032b3:	282245        	l32i	a8, a2, 0x114
  9032b6:	0b8000        	callx8	a8
		temp[i] = 0;
}

static void idle_task()
{
	if (loop_low == 0xffffffff) {
  9032b9:	1871b9        	l32r	a8, 8df9a0 <_bss_end+0x3d2198>
  9032bc:	8980      	l32i.n	a9, a8, 0
  9032be:	699008        	bnei	a9, -1, 9032ca <wlan_task+0x46>
		loop_low = 0;
  9032c1:	c090      	movi.n	a9, 0
  9032c3:	9980      	s32i.n	a9, a8, 0
		loop_high++;
  9032c5:	1871b8        	l32r	a8, 8df9a8 <_bss_end+0x3d21a0>
  9032c8:	8980      	l32i.n	a9, a8, 0
	} else {
		loop_low++;
  9032ca:	b199      	addi.n	a9, a9, 1
  9032cc:	9980      	s32i.n	a9, a8, 0
  9032ce:	63ffc4        	j	903296 <wlan_task+0x12>
  9032d1:	000000        	ill

009032d4 <htc_setup_comp>:
#define MAGPIE 1

#if MAGPIE==1

void htc_setup_comp(void)
{
  9032d4:	6c1004        	entry	a1, 32
  9032d7:	d10f      	retw.n
  9032d9:	000000        	ill

009032dc <_wmi_cmd_rsp>:
	}
}

void _wmi_cmd_rsp(void *pContext, WMI_COMMAND_ID cmd_id, A_UINT16 SeqNo,
		  A_UINT8 *buffer, int Length)
{
  9032dc:	6c1006        	entry	a1, 48
	adf_nbuf_t netbuf = ADF_NBUF_NULL;
	A_UINT8 *pData;

	netbuf = WMI_AllocEvent(pContext, WMI_EVT_CLASS_CMD_REPLY, sizeof(WMI_CMD_HDR) + Length);
  9032df:	177184        	l32r	a7, 8df8f0 <_bss_end+0x3d20e8>
  9032e2:	022a02        	or	a10, a2, a2
  9032e5:	287292        	l32i	a8, a7, 0x248
  9032e8:	c0b1      	movi.n	a11, 1
  9032ea:	2c6c04        	addi	a12, a6, 4
  9032ed:	0b8000        	callx8	a8
	}
}

void _wmi_cmd_rsp(void *pContext, WMI_COMMAND_ID cmd_id, A_UINT16 SeqNo,
		  A_UINT8 *buffer, int Length)
{
  9032f0:	04044f        	extui	a4, a4, 0, 16
	adf_nbuf_t netbuf = ADF_NBUF_NULL;
	A_UINT8 *pData;

	netbuf = WMI_AllocEvent(pContext, WMI_EVT_CLASS_CMD_REPLY, sizeof(WMI_CMD_HDR) + Length);
  9032f3:	d8a0      	mov.n	a8, a10
    
	if (netbuf == ADF_NBUF_NULL) {
  9032f5:	cda1      	bnez.n	a10, 90330a <_wmi_cmd_rsp+0x2e>
		adf_os_print("%s: buffer allocation for event_id %x failed!\n", __FUNCTION__, cmd_id);
  9032f7:	227212        	l32i	a2, a7, 72
  9032fa:	1a71ba        	l32r	a10, 8df9e4 <_bss_end+0x3d21dc>
  9032fd:	1b71bb        	l32r	a11, 8df9ec <_bss_end+0x3d21e4>
  903300:	dc30      	mov.n	a12, a3
  903302:	0b2000        	callx8	a2
  903305:	63fffc        	j	903305 <_wmi_cmd_rsp+0x29>
  903308:	0000c9        	excw
		adf_os_assert(0);
		return;
	}

	if (Length != 0 && buffer != NULL) {
  90330b:	62c950        	j	8efc5f <memset+0xaac3>
 *         put, or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_put_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_put_tail(buf, size);
  90330e:	db60      	mov.n	a11, a6
  903310:	9810      	s32i.n	a8, a1, 0
  903312:	5800c7        	call8	903630 <__adf_nbuf_put_tail>
}

/* move a memory buffer */
static inline void 		__adf_os_mem_copy(void *dst, const void *src, adf_os_size_t size)
{
    A_MEMCPY(dst,src,size);    
  903315:	8775      	l32i.n	a7, a7, 20
  903317:	db50      	mov.n	a11, a5
  903319:	dc60      	mov.n	a12, a6
  90331b:	0b7000        	callx8	a7
  90331e:	8810      	l32i.n	a8, a1, 0
		pData = (A_UINT8 *)adf_nbuf_put_tail(netbuf, Length);
		adf_os_mem_copy(pData, buffer, Length);
	}

	WMI_SendEvent(pContext, netbuf, cmd_id, SeqNo, Length);
  903320:	157184        	l32r	a5, 8df930 <_bss_end+0x3d2128>
  903323:	da20      	mov.n	a10, a2
  903325:	255293        	l32i	a5, a5, 0x24c
  903328:	db80      	mov.n	a11, a8
  90332a:	030c4f        	extui	a12, a3, 0, 16
  90332d:	dd40      	mov.n	a13, a4
  90332f:	de60      	mov.n	a14, a6
  903331:	0b5000        	callx8	a5
  903334:	d10f      	retw.n
	...

00903338 <Magpie_init>:
}


void Magpie_init(void)
{
  903338:	6c1004        	entry	a1, 32
	A_PRINTF("[+++Magpie_init]\n\r");
  90333b:	127184        	l32r	a2, 8df94c <_bss_end+0x3d2144>
  90333e:	1a71bc        	l32r	a10, 8dfa30 <_bss_end+0x3d2228>
  903341:	232212        	l32i	a3, a2, 72
  903344:	0b3000        	callx8	a3
 
	A_PRINTF("[+++VBUF_init(%d)]\n\r", MAX_BUF_NUM);
  903347:	1371bd        	l32r	a3, 8dfa3c <_bss_end+0x3d2234>
  90334a:	282212        	l32i	a8, a2, 72
  90334d:	2b0a64        	movi	a11, 100
  903350:	da30      	mov.n	a10, a3
  903352:	0b8000        	callx8	a8
	VBUF_init(MAX_BUF_NUM);
  903355:	2822a5        	l32i	a8, a2, 0x294
  903358:	2a0a64        	movi	a10, 100
  90335b:	0b8000        	callx8	a8
    
	A_PRINTF("[+++VBUF_init(%d)]\n\r", MAX_DESC_NUM);
  90335e:	282212        	l32i	a8, a2, 72
  903361:	da30      	mov.n	a10, a3
  903363:	2b0a64        	movi	a11, 100
  903366:	0b8000        	callx8	a8
	VDESC_init(MAX_DESC_NUM);
  903369:	2222aa        	l32i	a2, a2, 0x2a8
  90336c:	2a0a64        	movi	a10, 100
  90336f:	0b2000        	callx8	a2
  903372:	d10f      	retw.n

00903374 <__adf_nbuf_alloc>:
 * @return newly allocated nbuf
 */
__adf_nbuf_t 
__adf_nbuf_alloc(adf_os_size_t size, a_uint32_t reserve, 
                 a_uint32_t align)
{
  903374:	6c1004        	entry	a1, 32
    VBUF *buf = NULL;
    VDESC *desc;
    
    buf = VBUF_alloc_vbuf();
  903377:	157184        	l32r	a5, 8df988 <_bss_end+0x3d2180>
 * @return newly allocated nbuf
 */
__adf_nbuf_t 
__adf_nbuf_alloc(adf_os_size_t size, a_uint32_t reserve, 
                 a_uint32_t align)
{
  90337a:	d620      	mov.n	a6, a2
    VBUF *buf = NULL;
    VDESC *desc;
    
    buf = VBUF_alloc_vbuf();
  90337c:	2a52a6        	l32i	a10, a5, 0x298
  90337f:	0ba000        	callx8	a10
  903382:	d2a0      	mov.n	a2, a10
    if ( buf != NULL ) {
  903384:	64a028        	beqz	a10, 9033b0 <__adf_nbuf_alloc+0x3c>
        desc = VDESC_alloc_vdesc();
  903387:	2a52ab        	l32i	a10, a5, 0x2ac
  90338a:	0ba000        	callx8	a10
        desc->buf_addr = (A_UINT8 *)A_ALLOCRAM(size);
  90338d:	255252        	l32i	a5, a5, 0x148
    VBUF *buf = NULL;
    VDESC *desc;
    
    buf = VBUF_alloc_vbuf();
    if ( buf != NULL ) {
        desc = VDESC_alloc_vdesc();
  903390:	d4a0      	mov.n	a4, a10
        desc->buf_addr = (A_UINT8 *)A_ALLOCRAM(size);
  903392:	db60      	mov.n	a11, a6
  903394:	c0a0      	movi.n	a10, 0
  903396:	0b5000        	callx8	a5
        desc->buf_size = size;
        desc->next_desc = NULL;
  903399:	c080      	movi.n	a8, 0
    VDESC *desc;
    
    buf = VBUF_alloc_vbuf();
    if ( buf != NULL ) {
        desc = VDESC_alloc_vdesc();
        desc->buf_addr = (A_UINT8 *)A_ALLOCRAM(size);
  90339b:	9a41      	s32i.n	a10, a4, 4
        desc->buf_size = size;
  90339d:	264504        	s16i	a6, a4, 8
        desc->next_desc = NULL;
  9033a0:	9840      	s32i.n	a8, a4, 0
        desc->data_offset = reserve;
  9033a2:	234505        	s16i	a3, a4, 10
        desc->data_size = 0;
  9033a5:	284506        	s16i	a8, a4, 12
        desc->control = 0;    
  9033a8:	284507        	s16i	a8, a4, 14
        
        buf->desc_list = desc;
  9033ab:	9420      	s32i.n	a4, a2, 0
        buf->buf_length = 0;    
  9033ad:	282504        	s16i	a8, a2, 8
    }
    
    return buf;
}   
  9033b0:	d10f      	retw.n
	...

009033b4 <__adf_nbuf_free>:
 * @param hdl
 * @param adf_nbuf
 * 
 */
void __adf_nbuf_free(__adf_nbuf_t  buf)
{
  9033b4:	6c1004        	entry	a1, 32
  9033b7:	63fffc        	j	9033b7 <__adf_nbuf_free+0x3>
	...

009033bc <__adf_nbuf_realloc_headroom>:
 * 
 * @return new nbuf
 */
__adf_nbuf_t 
__adf_nbuf_realloc_headroom(__adf_nbuf_t buf, a_uint32_t headroom)
{
  9033bc:	6c1004        	entry	a1, 32
  9033bf:	63fffc        	j	9033bf <__adf_nbuf_realloc_headroom+0x3>
	...

009033c4 <__adf_nbuf_realloc_tailroom>:
 * 
 * @return struct mbuf * (buffer with the new tailroom)
 */
__adf_nbuf_t 
__adf_nbuf_realloc_tailroom(__adf_nbuf_t  buf, a_uint32_t tailroom)
{
  9033c4:	6c1004        	entry	a1, 32
  9033c7:	63fffc        	j	9033c7 <__adf_nbuf_realloc_tailroom+0x3>
	...

009033cc <__adf_nbuf_expand>:
 * 
 * @return struct mbuf* (NULL if something goofed up)
 */
__adf_nbuf_t 
__adf_nbuf_expand(__adf_nbuf_t buf, a_uint32_t headroom, a_uint32_t tailroom)
{
  9033cc:	6c1004        	entry	a1, 32
  9033cf:	63fffc        	j	9033cf <__adf_nbuf_expand+0x3>
	...

009033d4 <__adf_nbuf_push_head>:
 * @return new data pointer ,NULL if the len is more than the
 *         space available in the head frag.
 */
a_uint8_t *       
__adf_nbuf_push_head(__adf_nbuf_t buf, adf_os_size_t len)
{
  9033d4:	6c1004        	entry	a1, 32
    a_uint8_t *ptr = NULL; 
    VDESC *desc = buf->desc_list;
  9033d7:	8820      	l32i.n	a8, a2, 0
    
    desc->data_offset -= len;
  9033d9:	03034f        	extui	a3, a3, 0, 16
    desc->data_size += len;
  9033dc:	2a8106        	l16ui	a10, a8, 12
__adf_nbuf_push_head(__adf_nbuf_t buf, adf_os_size_t len)
{
    a_uint8_t *ptr = NULL; 
    VDESC *desc = buf->desc_list;
    
    desc->data_offset -= len;
  9033df:	298105        	l16ui	a9, a8, 10
    desc->data_size += len;
  9033e2:	aa3a      	add.n	a10, a3, a10
  9033e4:	2a8506        	s16i	a10, a8, 12
__adf_nbuf_push_head(__adf_nbuf_t buf, adf_os_size_t len)
{
    a_uint8_t *ptr = NULL; 
    VDESC *desc = buf->desc_list;
    
    desc->data_offset -= len;
  9033e7:	03990c        	sub	a9, a9, a3
    desc->data_size += len;
    buf->buf_length += len;
  9033ea:	2a2104        	l16ui	a10, a2, 8
__adf_nbuf_push_head(__adf_nbuf_t buf, adf_os_size_t len)
{
    a_uint8_t *ptr = NULL; 
    VDESC *desc = buf->desc_list;
    
    desc->data_offset -= len;
  9033ed:	09094f        	extui	a9, a9, 0, 16
  9033f0:	298505        	s16i	a9, a8, 10
    desc->data_size += len;
    buf->buf_length += len;
  9033f3:	aa33      	add.n	a3, a3, a10
  9033f5:	232504        	s16i	a3, a2, 8
    ptr = desc->buf_addr + desc->data_offset;
  9033f8:	8281      	l32i.n	a2, a8, 4
    return(ptr);
}
  9033fa:	a922      	add.n	a2, a2, a9
  9033fc:	d10f      	retw.n
	...

00903400 <__adf_nbuf_pull_head>:
 * 
 * @return new data pointer
 */
a_uint8_t * 
__adf_nbuf_pull_head(__adf_nbuf_t buf, adf_os_size_t len)
{
  903400:	6c1004        	entry	a1, 32
    a_uint8_t *ptr = NULL;
    VDESC *desc = buf->desc_list;
  903403:	8820      	l32i.n	a8, a2, 0
    
    desc->data_offset += len;
  903405:	03034f        	extui	a3, a3, 0, 16
    desc->data_size -= len;
  903408:	2a8106        	l16ui	a10, a8, 12
__adf_nbuf_pull_head(__adf_nbuf_t buf, adf_os_size_t len)
{
    a_uint8_t *ptr = NULL;
    VDESC *desc = buf->desc_list;
    
    desc->data_offset += len;
  90340b:	298105        	l16ui	a9, a8, 10
    desc->data_size -= len;
  90340e:	03aa0c        	sub	a10, a10, a3
  903411:	2a8506        	s16i	a10, a8, 12
__adf_nbuf_pull_head(__adf_nbuf_t buf, adf_os_size_t len)
{
    a_uint8_t *ptr = NULL;
    VDESC *desc = buf->desc_list;
    
    desc->data_offset += len;
  903414:	a939      	add.n	a9, a3, a9
    desc->data_size -= len;
    buf->buf_length -= len;
  903416:	2a2104        	l16ui	a10, a2, 8
__adf_nbuf_pull_head(__adf_nbuf_t buf, adf_os_size_t len)
{
    a_uint8_t *ptr = NULL;
    VDESC *desc = buf->desc_list;
    
    desc->data_offset += len;
  903419:	09094f        	extui	a9, a9, 0, 16
  90341c:	298505        	s16i	a9, a8, 10
    desc->data_size -= len;
    buf->buf_length -= len;
  90341f:	03a30c        	sub	a3, a10, a3
  903422:	232504        	s16i	a3, a2, 8
    ptr = desc->buf_addr + desc->data_offset;
  903425:	8281      	l32i.n	a2, a8, 4
    
    return ptr;
}
  903427:	a922      	add.n	a2, a2, a9
  903429:	d10f      	retw.n
	...

0090342c <__adf_nbuf_copy>:
 * 
 * @return struct mbuf * (newly allocated buffer)
 */
__adf_nbuf_t 
__adf_nbuf_copy(__adf_nbuf_t src)
{
  90342c:	6c1004        	entry	a1, 32
    __adf_nbuf_t buf = NULL; 

    adf_os_assert(src != NULL);
  90342f:	cc21      	bnez.n	a2, 903434 <__adf_nbuf_copy+0x8>
  903431:	63fffc        	j	903431 <__adf_nbuf_copy+0x5>
    
    return buf;
}
  903434:	c020      	movi.n	a2, 0
  903436:	d10f      	retw.n

00903438 <__adf_nbuf_unshare>:
 * 
 * @return new nbuf
 */
__adf_nbuf_t 
__adf_nbuf_unshare(__adf_nbuf_t  src)
{
  903438:	6c1004        	entry	a1, 32
    __adf_nbuf_t buf = NULL;

    adf_os_assert(src != NULL);
  90343b:	cc21      	bnez.n	a2, 903440 <__adf_nbuf_unshare+0x8>
  90343d:	63fffc        	j	90343d <__adf_nbuf_unshare+0x5>

    return buf;
}
  903440:	c020      	movi.n	a2, 0
  903442:	d10f      	retw.n

00903444 <__adf_nbuf_frag_info>:
 * @param[out] sg (scatter/gather list of all the frags)
 * 
 */
void  
__adf_nbuf_frag_info(__adf_nbuf_t buf, adf_os_sglist_t	*sg)
{
  903444:	6c1004        	entry	a1, 32
    VDESC *desc = buf->desc_list;
  903447:	8820      	l32i.n	a8, a2, 0
  903449:	d930      	mov.n	a9, a3
    int count = 0;
  90344b:	c0a0      	movi.n	a10, 0
    
    while( desc != NULL ) {
  90344d:	600013        	j	903464 <__adf_nbuf_frag_info+0x20>
        sg->sg_segs[count].vaddr = desc->buf_addr + desc->data_offset;
  903450:	2b8105        	l16ui	a11, a8, 10
  903453:	8c81      	l32i.n	a12, a8, 4
        sg->sg_segs[count].len   = desc->data_size;
        
        count++;        
  903455:	b1aa      	addi.n	a10, a10, 1
{
    VDESC *desc = buf->desc_list;
    int count = 0;
    
    while( desc != NULL ) {
        sg->sg_segs[count].vaddr = desc->buf_addr + desc->data_offset;
  903457:	abcb      	add.n	a11, a12, a11
  903459:	9b91      	s32i.n	a11, a9, 4
        sg->sg_segs[count].len   = desc->data_size;
  90345b:	2b8106        	l16ui	a11, a8, 12
  90345e:	9b92      	s32i.n	a11, a9, 8
        
        count++;        
        desc = desc->next_desc;
  903460:	8880      	l32i.n	a8, a8, 0
  903462:	b899      	addi.n	a9, a9, 8
__adf_nbuf_frag_info(__adf_nbuf_t buf, adf_os_sglist_t	*sg)
{
    VDESC *desc = buf->desc_list;
    int count = 0;
    
    while( desc != NULL ) {
  903464:	658fe8        	bnez	a8, 903450 <__adf_nbuf_frag_info+0xc>
        
        count++;        
        desc = desc->next_desc;
    }
    
    sg->nsegs = count;
  903467:	9a30      	s32i.n	a10, a3, 0
  903469:	d10f      	retw.n
	...

0090346c <__adf_nbuf_get_priv>:
 * 
 * @return uint8_t* ( pointer to the data )
 */
a_uint8_t *
__adf_nbuf_get_priv(__adf_nbuf_t buf)
{
  90346c:	6c1004        	entry	a1, 32
    adf_os_assert(buf != NULL);
  90346f:	cc21      	bnez.n	a2, 903474 <__adf_nbuf_get_priv+0x8>
  903471:	63fffc        	j	903471 <__adf_nbuf_get_priv+0x5>

    return buf->ctx;
}
  903474:	bc22      	addi.n	a2, a2, 12
  903476:	d10f      	retw.n

00903478 <__adf_nbuf_queue_add>:
 * 
 */
void 
__adf_nbuf_queue_add(__adf_nbuf_qhead_t  *qhead, 
                     __adf_nbuf_t  buf)
{
  903478:	6c1004        	entry	a1, 32
    qhead->qlen++;
  90347b:	8822      	l32i.n	a8, a2, 8
  90347d:	b188      	addi.n	a8, a8, 1
  90347f:	9822      	s32i.n	a8, a2, 8

    buf->next_buf = NULL;
  903481:	c080      	movi.n	a8, 0
  903483:	9831      	s32i.n	a8, a3, 4

    if (qhead->head == NULL) {
  903485:	8820      	l32i.n	a8, a2, 0
  903487:	cc83      	bnez.n	a8, 90348e <__adf_nbuf_queue_add+0x16>
        qhead->head = buf;
  903489:	9320      	s32i.n	a3, a2, 0
  90348b:	600003        	j	903492 <__adf_nbuf_queue_add+0x1a>
    }
    else {
        qhead->tail->next_buf = buf;
  90348e:	8821      	l32i.n	a8, a2, 4
  903490:	9381      	s32i.n	a3, a8, 4
    }
    qhead->tail = buf;
  903492:	9321      	s32i.n	a3, a2, 4
  903494:	d10f      	retw.n
	...

00903498 <__adf_nbuf_queue_remove>:
 * 
 * @return the nbuf
 */
__adf_nbuf_t   
__adf_nbuf_queue_remove(__adf_nbuf_qhead_t *qhead)
{
  903498:	6c1004        	entry	a1, 32
  90349b:	d820      	mov.n	a8, a2
    __adf_nbuf_t  b0 = NULL;

    if (qhead->head) {
  90349d:	8220      	l32i.n	a2, a2, 0
  90349f:	c929      	beqz.n	a2, 9034bc <__adf_nbuf_queue_remove+0x24>
        qhead->qlen--;
  9034a1:	8982      	l32i.n	a9, a8, 8
        b0 = qhead->head;
        if ( qhead->head == qhead->tail ) {
  9034a3:	8a81      	l32i.n	a10, a8, 4
__adf_nbuf_queue_remove(__adf_nbuf_qhead_t *qhead)
{
    __adf_nbuf_t  b0 = NULL;

    if (qhead->head) {
        qhead->qlen--;
  9034a5:	b099      	addi.n	a9, a9, -1
  9034a7:	9982      	s32i.n	a9, a8, 8
  9034a9:	c090      	movi.n	a9, 0
        b0 = qhead->head;
        if ( qhead->head == qhead->tail ) {
  9034ab:	7a2907        	bne	a2, a10, 9034b6 <__adf_nbuf_queue_remove+0x1e>
            qhead->head = NULL;
  9034ae:	9980      	s32i.n	a9, a8, 0
            qhead->tail = NULL;
  9034b0:	9981      	s32i.n	a9, a8, 4
  9034b2:	600004        	j	9034ba <__adf_nbuf_queue_remove+0x22>
  9034b5:	008a21        	excw
        } else {
            qhead->head = qhead->head->next_buf;
  9034b8:	9a80      	s32i.n	a10, a8, 0
        }
    
        b0->next_buf = NULL;
  9034ba:	9921      	s32i.n	a9, a2, 4
    }
	return b0;
}
  9034bc:	d10f      	retw.n
	...

009034c0 <__adf_nbuf_dmamap_create>:
 * 
 * @return a_status_t
 */
a_status_t 
__adf_nbuf_dmamap_create(__adf_os_device_t osdev, __adf_os_dma_map_t *dmap)
{
  9034c0:	6c1004        	entry	a1, 32
    a_status_t retval = A_STATUS_OK;
    
    (*dmap) = A_ALLOCRAM(sizeof(struct __adf_dma_map));
  9034c3:	127184        	l32r	a2, 8dfad4 <_bss_end+0x3d22cc>
  9034c6:	c0a0      	movi.n	a10, 0
  9034c8:	222252        	l32i	a2, a2, 0x148
  9034cb:	c0bc      	movi.n	a11, 12
  9034cd:	0b2000        	callx8	a2
  9034d0:	9a30      	s32i.n	a10, a3, 0
    if(*dmap == NULL)
        return A_STATUS_ENOMEM;
  9034d2:	c023      	movi.n	a2, 3
__adf_nbuf_dmamap_create(__adf_os_device_t osdev, __adf_os_dma_map_t *dmap)
{
    a_status_t retval = A_STATUS_OK;
    
    (*dmap) = A_ALLOCRAM(sizeof(struct __adf_dma_map));
    if(*dmap == NULL)
  9034d4:	c8a2      	beqz.n	a10, 9034da <__adf_nbuf_dmamap_create+0x1a>
        return A_STATUS_ENOMEM;
            
    (*dmap)->buf = NULL;
  9034d6:	c020      	movi.n	a2, 0
  9034d8:	92a0      	s32i.n	a2, a10, 0
    return retval;
}
  9034da:	d10f      	retw.n

009034dc <__adf_nbuf_map>:


a_status_t 
__adf_nbuf_map(__adf_os_device_t osdev, __adf_os_dma_map_t bmap, 
                          __adf_nbuf_t buf, adf_os_dma_dir_t dir)
{   
  9034dc:	6c1004        	entry	a1, 32
    bmap->buf = buf;
  9034df:	9430      	s32i.n	a4, a3, 0
    
    return A_STATUS_OK;
}
  9034e1:	c020      	movi.n	a2, 0
  9034e3:	d10f      	retw.n
  9034e5:	000000        	ill

009034e8 <__adf_nbuf_unmap>:

void 
__adf_nbuf_unmap(__adf_os_device_t osdev, __adf_os_dma_map_t bmap, 
                            adf_os_dma_dir_t dir)
{
  9034e8:	6c1004        	entry	a1, 32
    bmap->buf = NULL;
  9034eb:	c080      	movi.n	a8, 0
  9034ed:	9830      	s32i.n	a8, a3, 0
  9034ef:	d10f      	retw.n
  9034f1:	000000        	ill

009034f4 <__adf_nbuf_dmamap_destroy>:
}

void
__adf_nbuf_dmamap_destroy(__adf_os_device_t osdev, 
                          __adf_os_dma_map_t dmap)
{
  9034f4:	6c1004        	entry	a1, 32
  9034f7:	d10f      	retw.n
  9034f9:	000000        	ill

009034fc <__adf_nbuf_dmamap_info>:
 * @param[in]  bmap
 * @param[out] sg (map_info ptr)
 */
void 
__adf_nbuf_dmamap_info(__adf_os_dma_map_t bmap, adf_os_dmamap_info_t *sg)
{
  9034fc:	6c1004        	entry	a1, 32
    VDESC *desc = bmap->buf->desc_list;
  9034ff:	8820      	l32i.n	a8, a2, 0
  903501:	d930      	mov.n	a9, a3
  903503:	8880      	l32i.n	a8, a8, 0
    int count = 0;
  903505:	c0a0      	movi.n	a10, 0
    
    while( desc != NULL ) {
  903507:	600015        	j	903520 <__adf_nbuf_dmamap_info+0x24>
  90350a:	00002b        	mulsh	a0, a0, a0
        sg->dma_segs[count].paddr = (adf_os_dma_addr_t)(desc->buf_addr + desc->data_offset);
  90350d:	8105      	l32i.n	a1, a0, 20
  90350f:	8c81      	l32i.n	a12, a8, 4
        sg->dma_segs[count].len   = desc->data_size;
        
        count++;        
  903511:	b1aa      	addi.n	a10, a10, 1
{
    VDESC *desc = bmap->buf->desc_list;
    int count = 0;
    
    while( desc != NULL ) {
        sg->dma_segs[count].paddr = (adf_os_dma_addr_t)(desc->buf_addr + desc->data_offset);
  903513:	abcb      	add.n	a11, a12, a11
  903515:	9b91      	s32i.n	a11, a9, 4
        sg->dma_segs[count].len   = desc->data_size;
  903517:	2b8106        	l16ui	a11, a8, 12
        
        count++;        
        desc = desc->next_desc;
  90351a:	8880      	l32i.n	a8, a8, 0
    VDESC *desc = bmap->buf->desc_list;
    int count = 0;
    
    while( desc != NULL ) {
        sg->dma_segs[count].paddr = (adf_os_dma_addr_t)(desc->buf_addr + desc->data_offset);
        sg->dma_segs[count].len   = desc->data_size;
  90351c:	9b92      	s32i.n	a11, a9, 8
  90351e:	b899      	addi.n	a9, a9, 8
__adf_nbuf_dmamap_info(__adf_os_dma_map_t bmap, adf_os_dmamap_info_t *sg)
{
    VDESC *desc = bmap->buf->desc_list;
    int count = 0;
    
    while( desc != NULL ) {
  903520:	658fe8        	bnez	a8, 90350c <__adf_nbuf_dmamap_info+0x10>
        
        count++;        
        desc = desc->next_desc;
    }
    
    sg->nsegs = count;    
  903523:	9a30      	s32i.n	a10, a3, 0
  903525:	d10f      	retw.n
	...

00903528 <__adf_nbuf_set_rx_cksum>:
 * @param buf
 * @param cksum
 */
void 
__adf_nbuf_set_rx_cksum(__adf_nbuf_t buf, adf_nbuf_rx_cksum_t *cksum)
{
  903528:	6c1004        	entry	a1, 32
  90352b:	d10f      	retw.n
  90352d:	000000        	ill

00903530 <__adf_nbuf_get_vlan_info>:
}

a_status_t      
__adf_nbuf_get_vlan_info(adf_net_handle_t hdl, __adf_nbuf_t buf, 
                         adf_net_vlanhdr_t *vlan)
{
  903530:	6c1004        	entry	a1, 32
    return A_STATUS_OK;
}
  903533:	c020      	movi.n	a2, 0
  903535:	d10f      	retw.n
	...

00903538 <__adf_nbuf_create_frm_frag>:

__adf_nbuf_t
__adf_nbuf_create_frm_frag(__adf_nbuf_queue_t *qhead)
{
  903538:	6c1006        	entry	a1, 48
    VBUF *buf_tmp, *buf_head = NULL;
    VDESC *vdesc_prev = NULL, *vdesc_tmp = NULL;
    a_uint32_t cnt = 0, len = __adf_nbuf_queue_len(qhead);
    a_uint16_t total_len = 0;

    buf_head = VBUF_alloc_vbuf();
  90353b:	167184        	l32r	a6, 8dfb4c <_bss_end+0x3d2344>
    return A_STATUS_OK;
}

__adf_nbuf_t
__adf_nbuf_create_frm_frag(__adf_nbuf_queue_t *qhead)
{
  90353e:	d420      	mov.n	a4, a2
    VBUF *buf_tmp, *buf_head = NULL;
    VDESC *vdesc_prev = NULL, *vdesc_tmp = NULL;
    a_uint32_t cnt = 0, len = __adf_nbuf_queue_len(qhead);
    a_uint16_t total_len = 0;

    buf_head = VBUF_alloc_vbuf();
  903540:	2a62a6        	l32i	a10, a6, 0x298
 * 
 */
a_uint32_t  
__adf_nbuf_queue_len(__adf_nbuf_qhead_t *qhead)
{
    return qhead->qlen;
  903543:	8522      	l32i.n	a5, a2, 8
    VBUF *buf_tmp, *buf_head = NULL;
    VDESC *vdesc_prev = NULL, *vdesc_tmp = NULL;
    a_uint32_t cnt = 0, len = __adf_nbuf_queue_len(qhead);
    a_uint16_t total_len = 0;

    buf_head = VBUF_alloc_vbuf();
  903545:	0ba000        	callx8	a10
  903548:	d2a0      	mov.n	a2, a10
 * @return (NULL if the Q is empty)
 */
__adf_nbuf_t   
__adf_nbuf_queue_first(__adf_nbuf_queue_t *qhead)
{
    return qhead->head;
  90354a:	8340      	l32i.n	a3, a4, 0
    a_uint16_t total_len = 0;

    buf_head = VBUF_alloc_vbuf();
    buf_tmp = __adf_nbuf_queue_first(qhead);

    __adf_os_assert(buf_head);
  90354c:	cca1      	bnez.n	a10, 903551 <__adf_nbuf_create_frm_frag+0x19>
  90354e:	63fffc        	j	90354e <__adf_nbuf_create_frm_frag+0x16>
    __adf_os_assert(buf_tmp);
  903551:	cc31      	bnez.n	a3, 903556 <__adf_nbuf_create_frm_frag+0x1e>
  903553:	63fffc        	j	903553 <__adf_nbuf_create_frm_frag+0x1b>

    buf_head->desc_list = buf_tmp->desc_list;
  903556:	8330      	l32i.n	a3, a3, 0
  903558:	93a0      	s32i.n	a3, a10, 0
__adf_nbuf_create_frm_frag(__adf_nbuf_queue_t *qhead)
{
    VBUF *buf_tmp, *buf_head = NULL;
    VDESC *vdesc_prev = NULL, *vdesc_tmp = NULL;
    a_uint32_t cnt = 0, len = __adf_nbuf_queue_len(qhead);
    a_uint16_t total_len = 0;
  90355a:	c030      	movi.n	a3, 0
__adf_nbuf_t
__adf_nbuf_create_frm_frag(__adf_nbuf_queue_t *qhead)
{
    VBUF *buf_tmp, *buf_head = NULL;
    VDESC *vdesc_prev = NULL, *vdesc_tmp = NULL;
    a_uint32_t cnt = 0, len = __adf_nbuf_queue_len(qhead);
  90355c:	d730      	mov.n	a7, a3

__adf_nbuf_t
__adf_nbuf_create_frm_frag(__adf_nbuf_queue_t *qhead)
{
    VBUF *buf_tmp, *buf_head = NULL;
    VDESC *vdesc_prev = NULL, *vdesc_tmp = NULL;
  90355e:	d830      	mov.n	a8, a3
    __adf_os_assert(buf_head);
    __adf_os_assert(buf_tmp);

    buf_head->desc_list = buf_tmp->desc_list;

    while ((buf_tmp = __adf_nbuf_queue_remove(qhead)) != NULL) {
  903560:	60002d        	j	903591 <__adf_nbuf_create_frm_frag+0x59>
  903563:	0029a1        	excw
        cnt++;

        //adf_os_print("merge buf: %x\n", buf_tmp->desc_list->buf_addr + buf_tmp->desc_list->data_offset);

        total_len += buf_tmp->buf_length;
  903566:	04b177        	excw
  903569:	a933      	add.n	a3, a3, a9
  90356b:	03034f        	extui	a3, a3, 0, 16
  90356e:	89a0      	l32i.n	a9, a10, 0

        if (vdesc_prev) {
  903570:	c886      	beqz.n	a8, 90357a <__adf_nbuf_create_frm_frag+0x42>
            /* link "the last VDESC of previous VBUF" to "the 1st VDESC of this VBUF" */
            vdesc_prev->next_desc = buf_tmp->desc_list;
  903572:	9980      	s32i.n	a9, a8, 0
        }

        /* traverse VDESC list in this VBUF to find out the last VDESC */
        vdesc_tmp = buf_tmp->desc_list;
        while (vdesc_tmp->next_desc) {
  903574:	600002        	j	90357a <__adf_nbuf_create_frm_frag+0x42>
  903577:	00d980        	excw
  90357a:	8890      	l32i.n	a8, a9, 0
  90357c:	658ff8        	bnez	a8, 903578 <__adf_nbuf_create_frm_frag+0x40>
            vdesc_tmp = vdesc_tmp->next_desc;
        }
        vdesc_prev = vdesc_tmp;

        /* return VBUF to the pool */
        buf_tmp->desc_list = NULL;
  90357f:	98a0      	s32i.n	a8, a10, 0
        buf_tmp->buf_length = 0;
  903581:	28a504        	s16i	a8, a10, 8
        VBUF_free_vbuf(buf_tmp);
  903584:	2862a8        	l32i	a8, a6, 0x2a0
  903587:	291600        	s32i	a9, a1, 0
  90358a:	0b8000        	callx8	a8
  90358d:	8910      	l32i.n	a9, a1, 0
  90358f:	d890      	mov.n	a8, a9
    __adf_os_assert(buf_head);
    __adf_os_assert(buf_tmp);

    buf_head->desc_list = buf_tmp->desc_list;

    while ((buf_tmp = __adf_nbuf_queue_remove(qhead)) != NULL) {
  903591:	da40      	mov.n	a10, a4
  903593:	9810      	s32i.n	a8, a1, 0
  903595:	5bffc0        	call8	903498 <__adf_nbuf_queue_remove>
  903598:	8810      	l32i.n	a8, a1, 0
  90359a:	65afc6        	bnez	a10, 903564 <__adf_nbuf_create_frm_frag+0x2c>
        buf_tmp->desc_list = NULL;
        buf_tmp->buf_length = 0;
        VBUF_free_vbuf(buf_tmp);
    }

    if (cnt != len) {
  90359d:	757103        	beq	a7, a5, 9035a4 <__adf_nbuf_create_frm_frag+0x6c>
  9035a0:	63fffc        	j	9035a0 <__adf_nbuf_create_frm_frag+0x68>
  9035a3:	002325        	excw
        //             __adf_nbuf_queue_len(qhead));
        adf_os_assert(0);
    }
    //__adf_os_assert(cnt == len);

    buf_head->buf_length = total_len;
  9035a6:	04d10f        	subx8	a1, a13, a4

    return buf_head;
}
  9035a9:	000000        	ill

009035ac <__adf_nbuf_split_to_frag>:

void
__adf_nbuf_split_to_frag(__adf_nbuf_t buf, __adf_nbuf_qhead_t *qhead)
{
  9035ac:	6c1004        	entry	a1, 32
 * @param qhead
 */
void 
__adf_nbuf_queue_init(__adf_nbuf_qhead_t *qhead)
{
    qhead->qlen = 0;
  9035af:	c040      	movi.n	a4, 0
  9035b1:	9432      	s32i.n	a4, a3, 8
    qhead->head = NULL;
  9035b3:	9430      	s32i.n	a4, a3, 0
    qhead->tail = NULL;
  9035b5:	9431      	s32i.n	a4, a3, 4
  9035b7:	167184        	l32r	a6, 8dfbc8 <_bss_end+0x3d23c0>
{
    VBUF *buf_tmp;
    VDESC *desc_tmp = NULL;

    __adf_nbuf_queue_init(qhead);
    desc_tmp = buf->desc_list;
  9035ba:	8420      	l32i.n	a4, a2, 0

    while (desc_tmp /*&& desc_tmp->buf_addr*/) {
  9035bc:	600026        	j	9035e6 <__adf_nbuf_split_to_frag+0x3a>
  9035bf:	002a62        	excw
        buf_tmp = VBUF_alloc_vbuf();
  9035c2:	a60b      	add.n	a11, a0, a6
  9035c4:	a000      	add.n	a0, a0, a0
  9035c6:	d5a0      	mov.n	a5, a10

        __adf_os_assert(buf_tmp);
  9035c8:	cca1      	bnez.n	a10, 9035cd <__adf_nbuf_split_to_frag+0x21>
  9035ca:	63fffc        	j	9035ca <__adf_nbuf_split_to_frag+0x1e>

        //desc_tmp->data_size = 0;
        buf_tmp->desc_list = desc_tmp;
        //buf_tmp->buf_length = desc_tmp->buf_size;
        buf_tmp->buf_length = desc_tmp->data_size;
  9035cd:	274106        	l16ui	a7, a4, 12
        buf_tmp = VBUF_alloc_vbuf();

        __adf_os_assert(buf_tmp);

        //desc_tmp->data_size = 0;
        buf_tmp->desc_list = desc_tmp;
  9035d0:	94a0      	s32i.n	a4, a10, 0
        //buf_tmp->buf_length = desc_tmp->buf_size;
        buf_tmp->buf_length = desc_tmp->data_size;
  9035d2:	27a504        	s16i	a7, a10, 8
        buf_tmp->next_buf = NULL;
  9035d5:	c070      	movi.n	a7, 0
  9035d7:	97a1      	s32i.n	a7, a10, 4

        //adf_os_print("split - buf: %x\n", buf_tmp->desc_list->buf_addr + buf_tmp->desc_list->data_offset);

        __adf_nbuf_queue_add(qhead, buf_tmp);
  9035d9:	db50      	mov.n	a11, a5
  9035db:	da30      	mov.n	a10, a3
  9035dd:	5bffa6        	call8	903478 <__adf_nbuf_queue_add>

        desc_tmp = desc_tmp->next_desc;

        buf_tmp->desc_list->next_desc = NULL;
  9035e0:	8550      	l32i.n	a5, a5, 0

        //adf_os_print("split - buf: %x\n", buf_tmp->desc_list->buf_addr + buf_tmp->desc_list->data_offset);

        __adf_nbuf_queue_add(qhead, buf_tmp);

        desc_tmp = desc_tmp->next_desc;
  9035e2:	8440      	l32i.n	a4, a4, 0

        buf_tmp->desc_list->next_desc = NULL;
  9035e4:	9750      	s32i.n	a7, a5, 0
    VDESC *desc_tmp = NULL;

    __adf_nbuf_queue_init(qhead);
    desc_tmp = buf->desc_list;

    while (desc_tmp /*&& desc_tmp->buf_addr*/) {
  9035e6:	654fd6        	bnez	a4, 9035c0 <__adf_nbuf_split_to_frag+0x14>
        buf_tmp->desc_list->next_desc = NULL;
    }

    buf->desc_list = NULL;
    buf->buf_length = 0;
    VBUF_free_vbuf(buf);
  9035e9:	2362a8        	l32i	a3, a6, 0x2a0
        desc_tmp = desc_tmp->next_desc;

        buf_tmp->desc_list->next_desc = NULL;
    }

    buf->desc_list = NULL;
  9035ec:	9420      	s32i.n	a4, a2, 0
    buf->buf_length = 0;
  9035ee:	242504        	s16i	a4, a2, 8
    VBUF_free_vbuf(buf);
  9035f1:	da20      	mov.n	a10, a2
  9035f3:	0b3000        	callx8	a3
  9035f6:	d10f      	retw.n

009035f8 <__adf_nbuf_last>:
 * 
 * @return struct mbuf*
 */
VDESC * 
__adf_nbuf_last(VBUF *buf)
{
  9035f8:	6c1004        	entry	a1, 32
    VDESC *desc = buf->desc_list;
  9035fb:	8220      	l32i.n	a2, a2, 0
    
    //for(; desc->next_desc != NULL; desc = desc->next_desc)
    //    ;
    while(desc->next_desc != NULL)
  9035fd:	600001        	j	903602 <__adf_nbuf_last+0xa>
    {
        desc = desc->next_desc;
  903600:	d280      	mov.n	a2, a8
{
    VDESC *desc = buf->desc_list;
    
    //for(; desc->next_desc != NULL; desc = desc->next_desc)
    //    ;
    while(desc->next_desc != NULL)
  903602:	8820      	l32i.n	a8, a2, 0
  903604:	658ff8        	bnez	a8, 903600 <__adf_nbuf_last+0x8>
    {
        desc = desc->next_desc;
    }
    
    return desc;
}
  903607:	d10f      	retw.n
  903609:	000000        	ill

0090360c <__adf_nbuf_trim_tail>:
 * @param len (how much to strip down)
 * 
 */
void 
__adf_nbuf_trim_tail(__adf_nbuf_t buf, adf_os_size_t len)
{
  90360c:	6c1004        	entry	a1, 32
    VDESC *last_desc = __adf_nbuf_last(buf);
  90360f:	da20      	mov.n	a10, a2
  903611:	5bfff9        	call8	9035f8 <__adf_nbuf_last>
    
    adf_os_assert(buf != NULL);
  903614:	cc21      	bnez.n	a2, 903619 <__adf_nbuf_trim_tail+0xd>
  903616:	63fffc        	j	903616 <__adf_nbuf_trim_tail+0xa>
    last_desc->data_size -= len;
  903619:	28a106        	l16ui	a8, a10, 12
  90361c:	03034f        	extui	a3, a3, 0, 16
  90361f:	03880c        	sub	a8, a8, a3
  903622:	28a506        	s16i	a8, a10, 12
    buf->buf_length -= len;
  903625:	282104        	l16ui	a8, a2, 8
  903628:	03830c        	sub	a3, a8, a3
  90362b:	232504        	s16i	a3, a2, 8
  90362e:	d10f      	retw.n

00903630 <__adf_nbuf_put_tail>:
 * @return previous tail (data+len),NULL if the len is more than
 *         space available
 */
a_uint8_t *
__adf_nbuf_put_tail(__adf_nbuf_t buf, adf_os_size_t len)
{
  903630:	6c1004        	entry	a1, 32
    a_uint8_t *tail = NULL;
    VDESC *last_desc = __adf_nbuf_last(buf);
  903633:	da20      	mov.n	a10, a2
  903635:	5bfff0        	call8	9035f8 <__adf_nbuf_last>
    
    tail = last_desc->buf_addr + last_desc->data_offset + last_desc->data_size;
  903638:	28a106        	l16ui	a8, a10, 12
  90363b:	29a105        	l16ui	a9, a10, 10
    last_desc->data_size += len;
  90363e:	03034f        	extui	a3, a3, 0, 16
__adf_nbuf_put_tail(__adf_nbuf_t buf, adf_os_size_t len)
{
    a_uint8_t *tail = NULL;
    VDESC *last_desc = __adf_nbuf_last(buf);
    
    tail = last_desc->buf_addr + last_desc->data_offset + last_desc->data_size;
  903641:	a989      	add.n	a9, a8, a9
    last_desc->data_size += len;
  903643:	a838      	add.n	a8, a3, a8
  903645:	28a506        	s16i	a8, a10, 12
    buf->buf_length += len;
  903648:	282104        	l16ui	a8, a2, 8
__adf_nbuf_put_tail(__adf_nbuf_t buf, adf_os_size_t len)
{
    a_uint8_t *tail = NULL;
    VDESC *last_desc = __adf_nbuf_last(buf);
    
    tail = last_desc->buf_addr + last_desc->data_offset + last_desc->data_size;
  90364b:	8ba1      	l32i.n	a11, a10, 4
    last_desc->data_size += len;
    buf->buf_length += len;
  90364d:	a833      	add.n	a3, a3, a8
  90364f:	232504        	s16i	a3, a2, 8
    
    return tail;
}
  903652:	a9b2      	add.n	a2, a11, a9
  903654:	d10f      	retw.n
	...

00903658 <__adf_nbuf_headroom>:
 * 
 * @return num of bytes available
 */
a_uint32_t
__adf_nbuf_headroom(__adf_nbuf_t  buf)
{
  903658:	6c1004        	entry	a1, 32
    return buf->desc_list->data_offset;
  90365b:	8820      	l32i.n	a8, a2, 0
}
  90365d:	228105        	l16ui	a2, a8, 10
  903660:	d10f      	retw.n
	...

00903664 <__adf_nbuf_tailroom>:
 * @return num of bytes
 */

a_uint32_t 
__adf_nbuf_tailroom(__adf_nbuf_t  buf)
{
  903664:	6c1004        	entry	a1, 32
    VDESC *last_desc = __adf_nbuf_last(buf);
  903667:	da20      	mov.n	a10, a2
  903669:	5bffe3        	call8	9035f8 <__adf_nbuf_last>
    
    return last_desc->buf_size - last_desc->data_offset - last_desc->data_size;
  90366c:	28a104        	l16ui	a8, a10, 8
  90366f:	22a105        	l16ui	a2, a10, 10
  903672:	02820c        	sub	a2, a8, a2
  903675:	28a106        	l16ui	a8, a10, 12
}
  903678:	08220c        	sub	a2, a2, a8
  90367b:	d10f      	retw.n
  90367d:	000000        	ill

00903680 <__adf_nbuf_len>:
 * 
 * @return total length of packet (sum of all frag lengths)
 */ 
a_uint32_t
__adf_nbuf_len(__adf_nbuf_t  buf)
{
  903680:	6c1004        	entry	a1, 32
    return buf->buf_length; 
}
  903683:	222104        	l16ui	a2, a2, 8
  903686:	d10f      	retw.n

00903688 <__adf_nbuf_clone>:
 * 
 * @return Read-only copy of the nbuf (including clusters)
 */
__adf_nbuf_t 
__adf_nbuf_clone(__adf_nbuf_t  src)
{
  903688:	6c1004        	entry	a1, 32
    __adf_nbuf_t buf = NULL;
    
    return buf;
}
  90368b:	c020      	movi.n	a2, 0
  90368d:	d10f      	retw.n
	...

00903690 <__adf_nbuf_cat>:

void
__adf_nbuf_cat(__adf_nbuf_t dst, __adf_nbuf_t src)
{
  903690:	6c1004        	entry	a1, 32
  903693:	d10f      	retw.n
  903695:	000000        	ill

00903698 <__adf_nbuf_is_cloned>:
 * 
 * @return a_bool_t
 */
a_bool_t
__adf_nbuf_is_cloned(__adf_nbuf_t  buf)
{
  903698:	6c1004        	entry	a1, 32
    return A_FALSE;
}
  90369b:	c020      	movi.n	a2, 0
  90369d:	d10f      	retw.n
	...

009036a0 <__adf_nbuf_peek_header>:
 * @brief This will return the header's addr & m_len
 */
void
__adf_nbuf_peek_header(__adf_nbuf_t buf, a_uint8_t   **addr, 
                       a_uint32_t	*len)
{
  9036a0:	6c1004        	entry	a1, 32
    VDESC *desc = buf->desc_list;
  9036a3:	8820      	l32i.n	a8, a2, 0
    
    *addr = desc->buf_addr + desc->data_offset;
  9036a5:	298105        	l16ui	a9, a8, 10
  9036a8:	8a81      	l32i.n	a10, a8, 4
    *len = desc->data_size; 
  9036aa:	288106        	l16ui	a8, a8, 12
__adf_nbuf_peek_header(__adf_nbuf_t buf, a_uint8_t   **addr, 
                       a_uint32_t	*len)
{
    VDESC *desc = buf->desc_list;
    
    *addr = desc->buf_addr + desc->data_offset;
  9036ad:	a9a9      	add.n	a9, a10, a9
  9036af:	9930      	s32i.n	a9, a3, 0
    *len = desc->data_size; 
  9036b1:	9840      	s32i.n	a8, a4, 0
  9036b3:	d10f      	retw.n
  9036b5:	000000        	ill

009036b8 <__adf_nbuf_queue_init>:
 * @brief init the queue
 * @param qhead
 */
void 
__adf_nbuf_queue_init(__adf_nbuf_qhead_t *qhead)
{
  9036b8:	6c1004        	entry	a1, 32
    qhead->qlen = 0;
  9036bb:	c080      	movi.n	a8, 0
  9036bd:	9822      	s32i.n	a8, a2, 8
    qhead->head = NULL;
  9036bf:	9820      	s32i.n	a8, a2, 0
    qhead->tail = NULL;
  9036c1:	9821      	s32i.n	a8, a2, 4
  9036c3:	d10f      	retw.n
  9036c5:	000000        	ill

009036c8 <__adf_nbuf_queue_len>:
 * @return length
 * 
 */
a_uint32_t  
__adf_nbuf_queue_len(__adf_nbuf_qhead_t *qhead)
{
  9036c8:	6c1004        	entry	a1, 32
    return qhead->qlen;
}
  9036cb:	8222      	l32i.n	a2, a2, 8
  9036cd:	d10f      	retw.n
	...

009036d0 <__adf_nbuf_queue_first>:
 * 
 * @return (NULL if the Q is empty)
 */
__adf_nbuf_t   
__adf_nbuf_queue_first(__adf_nbuf_queue_t *qhead)
{
  9036d0:	6c1004        	entry	a1, 32
    return qhead->head;
}
  9036d3:	8220      	l32i.n	a2, a2, 0
  9036d5:	d10f      	retw.n
	...

009036d8 <__adf_nbuf_queue_next>:
 * 
 * @return (NULL if no packets are there)
 */
__adf_nbuf_t   
__adf_nbuf_queue_next(__adf_nbuf_t  buf)
{
  9036d8:	6c1004        	entry	a1, 32
    return buf->next_buf;
}
  9036db:	8221      	l32i.n	a2, a2, 4
  9036dd:	d10f      	retw.n
	...

009036e0 <__adf_nbuf_is_queue_empty>:
 * 
 * @return a_bool_t
 */
a_bool_t  
__adf_nbuf_is_queue_empty(__adf_nbuf_qhead_t *qhead)
{
  9036e0:	6c1004        	entry	a1, 32
    return ((qhead->qlen == 0));
  9036e3:	8922      	l32i.n	a9, a2, 8
  9036e5:	c081      	movi.n	a8, 1
  9036e7:	c020      	movi.n	a2, 0
  9036e9:	098238        	moveqz	a2, a8, a9
}
  9036ec:	d10f      	retw.n
	...

009036f0 <_buf_pool_static_init>:
    pAPIs->_free_buf = _buf_pool_static_free_buf;
    pAPIs->_shutdown = _buf_pool_static_shutdown;
}
 
LOCAL pool_handle_t _buf_pool_static_init(adf_os_handle_t handle)
{
  9036f0:	6c1004        	entry	a1, 32
  9036f3:	c080      	movi.n	a8, 0
    pAPIs->_alloc_buf_align = _buf_pool_static_alloc_buf_align;
    pAPIs->_free_buf = _buf_pool_static_free_buf;
    pAPIs->_shutdown = _buf_pool_static_shutdown;
}
 
LOCAL pool_handle_t _buf_pool_static_init(adf_os_handle_t handle)
  9036f5:	1271be        	l32r	a2, 8dfdf0 <_bss_end+0x3d25e8>
{
#if 1
    int i;
    
    for(i=0; i < POOL_ID_MAX; i++) {
        g_poolCtx.bufQ[i] = NULL;
  9036f8:	db80      	mov.n	a11, a8
LOCAL pool_handle_t _buf_pool_static_init(adf_os_handle_t handle)
{
#if 1
    int i;
    
    for(i=0; i < POOL_ID_MAX; i++) {
  9036fa:	c298      	movi.n	a9, 40
    pAPIs->_alloc_buf_align = _buf_pool_static_alloc_buf_align;
    pAPIs->_free_buf = _buf_pool_static_free_buf;
    pAPIs->_shutdown = _buf_pool_static_shutdown;
}
 
LOCAL pool_handle_t _buf_pool_static_init(adf_os_handle_t handle)
  9036fc:	a28a      	add.n	a10, a8, a2
{
#if 1
    int i;
    
    for(i=0; i < POOL_ID_MAX; i++) {
        g_poolCtx.bufQ[i] = NULL;
  9036fe:	9ba0      	s32i.n	a11, a10, 0
  903700:	b488      	addi.n	a8, a8, 4
LOCAL pool_handle_t _buf_pool_static_init(adf_os_handle_t handle)
{
#if 1
    int i;
    
    for(i=0; i < POOL_ID_MAX; i++) {
  903702:	7989f6        	bne	a8, a9, 9036fc <_buf_pool_static_init+0xc>
    ctx = (BUF_POOL_STATIC_CONTEXT *)adf_os_mem_alloc(sizeof(BUF_POOL_STATIC_CONTEXT));
    ctx->NetHandle = handle;
    
    return ctx; 
#endif    
}      
  903705:	d10f      	retw.n
	...

00903708 <_buf_pool_static_shutdown>:
    
LOCAL void _buf_pool_static_shutdown(pool_handle_t handle) 
{
  903708:	6c1004        	entry	a1, 32
  90370b:	d10f      	retw.n
  90370d:	000000        	ill

00903710 <_buf_pool_static_create_pool>:
    // SHALL NOT BE USED in FW
}

LOCAL void _buf_pool_static_create_pool(pool_handle_t handle, BUF_POOL_ID poolId, int nItems, int nSize)
{
  903710:	6c1006        	entry	a1, 48
        desc->data_size = 0;
        
        buf->buf_length = 0;        
        buf->desc_list = desc;
        
        if ( g_poolCtx.bufQ[poolId] == NULL ) {
  903713:	1271be        	l32r	a2, 8dfe0c <_bss_end+0x3d2604>
{
    // SHALL NOT BE USED in FW
}

LOCAL void _buf_pool_static_create_pool(pool_handle_t handle, BUF_POOL_ID poolId, int nItems, int nSize)
{
  903716:	d940      	mov.n	a9, a4
    VDESC *desc;
    
    //BUF_POOL_STATIC_CONTEXT *ctx = (BUF_POOL_STATIC_CONTEXT *)handle;
    
    for ( i = 0; i < nItems; i++) {
        buf = VBUF_alloc_vbuf();
  903718:	177184        	l32r	a7, 8dfd28 <_bss_end+0x3d2520>
    VBUF *buf;
    VDESC *desc;
    
    //BUF_POOL_STATIC_CONTEXT *ctx = (BUF_POOL_STATIC_CONTEXT *)handle;
    
    for ( i = 0; i < nItems; i++) {
  90371b:	c040      	movi.n	a4, 0
        desc->data_size = 0;
        
        buf->buf_length = 0;        
        buf->desc_list = desc;
        
        if ( g_poolCtx.bufQ[poolId] == NULL ) {
  90371d:	02330a        	addx4	a3, a3, a2
    VBUF *buf;
    VDESC *desc;
    
    //BUF_POOL_STATIC_CONTEXT *ctx = (BUF_POOL_STATIC_CONTEXT *)handle;
    
    for ( i = 0; i < nItems; i++) {
  903720:	60003e        	j	903762 <_buf_pool_static_create_pool+0x52>
  903723:	002a72        	excw
        buf = VBUF_alloc_vbuf();
  903726:	a699      	add.n	a9, a9, a6
  903728:	100ba0        	l32r	a0, 8c65a8 <_bss_end+0x3b8da0>
  90372b:	00d2a0        	excw
        desc = VDESC_alloc_vdesc();
  90372e:	2a72ab        	l32i	a10, a7, 0x2ac
  903731:	0ba000        	callx8	a10
#include "Magpie_api.h"

static inline void *	__adf_os_mem_alloc(adf_os_size_t size)
{
//    return (malloc(size,M_DEVBUF,M_DONTWAIT | M_ZERO));
    return A_ALLOCRAM(size);
  903734:	287252        	l32i	a8, a7, 0x148
  903737:	d6a0      	mov.n	a6, a10
  903739:	db50      	mov.n	a11, a5
  90373b:	c0a0      	movi.n	a10, 0
  90373d:	0b8000        	callx8	a8

        desc->buf_addr = (A_UINT8 *)adf_os_mem_alloc(nSize);
        desc->buf_size = nSize;
        desc->data_offset = 0;
  903740:	c080      	movi.n	a8, 0
    
    for ( i = 0; i < nItems; i++) {
        buf = VBUF_alloc_vbuf();
        desc = VDESC_alloc_vdesc();

        desc->buf_addr = (A_UINT8 *)adf_os_mem_alloc(nSize);
  903742:	9a61      	s32i.n	a10, a6, 4
        desc->buf_size = nSize;
  903744:	256504        	s16i	a5, a6, 8
        desc->data_offset = 0;
  903747:	286505        	s16i	a8, a6, 10
        desc->data_size = 0;
  90374a:	286506        	s16i	a8, a6, 12
        
        buf->buf_length = 0;        
        buf->desc_list = desc;
  90374d:	9620      	s32i.n	a6, a2, 0
        
        if ( g_poolCtx.bufQ[poolId] == NULL ) {
  90374f:	8630      	l32i.n	a6, a3, 0
        desc->buf_addr = (A_UINT8 *)adf_os_mem_alloc(nSize);
        desc->buf_size = nSize;
        desc->data_offset = 0;
        desc->data_size = 0;
        
        buf->buf_length = 0;        
  903751:	282504        	s16i	a8, a2, 8
        buf->desc_list = desc;
        
        if ( g_poolCtx.bufQ[poolId] == NULL ) {
  903754:	8910      	l32i.n	a9, a1, 0
  903756:	cc62      	bnez.n	a6, 90375c <_buf_pool_static_create_pool+0x4c>
  903758:	600002        	j	90375e <_buf_pool_static_create_pool+0x4e>
  90375b:	009621        	excw
            g_poolCtx.bufQ[poolId] = buf;
        } else {
            buf->next_buf = g_poolCtx.bufQ[poolId];
            g_poolCtx.bufQ[poolId] = buf;
  90375e:	9230      	s32i.n	a2, a3, 0
    VBUF *buf;
    VDESC *desc;
    
    //BUF_POOL_STATIC_CONTEXT *ctx = (BUF_POOL_STATIC_CONTEXT *)handle;
    
    for ( i = 0; i < nItems; i++) {
  903760:	b144      	addi.n	a4, a4, 1
  903762:	7942be        	blt	a4, a9, 903724 <_buf_pool_static_create_pool+0x14>
        } else {
            buf->next_buf = g_poolCtx.bufQ[poolId];
            g_poolCtx.bufQ[poolId] = buf;
        }
    }
}
  903765:	d10f      	retw.n
	...

00903768 <_buf_pool_static_alloc_buf>:
            
LOCAL adf_nbuf_t  _buf_pool_static_alloc_buf(pool_handle_t handle, BUF_POOL_ID poolId, int reserve)
{
  903768:	6c1004        	entry	a1, 32
    VBUF *buf;
    
    buf = g_poolCtx.bufQ[poolId];
  90376b:	1271be        	l32r	a2, 8dfe64 <_bss_end+0x3d265c>
  90376e:	02330a        	addx4	a3, a3, a2
  903771:	8230      	l32i.n	a2, a3, 0
    if ( buf != NULL ) {
  903773:	c921      	beqz.n	a2, 903788 <_buf_pool_static_alloc_buf+0x20>
        g_poolCtx.bufQ[poolId] = buf->next_buf;
  903775:	8821      	l32i.n	a8, a2, 4
  903777:	9830      	s32i.n	a8, a3, 0
        
        buf->next_buf = NULL;
        buf->desc_list->data_offset = reserve;
  903779:	8920      	l32i.n	a9, a2, 0
    
    buf = g_poolCtx.bufQ[poolId];
    if ( buf != NULL ) {
        g_poolCtx.bufQ[poolId] = buf->next_buf;
        
        buf->next_buf = NULL;
  90377b:	c080      	movi.n	a8, 0
  90377d:	9821      	s32i.n	a8, a2, 4
        buf->desc_list->data_offset = reserve;
  90377f:	249505        	s16i	a4, a9, 10
        buf->desc_list->data_size = 0;
  903782:	289506        	s16i	a8, a9, 12
        buf->buf_length = 0;
  903785:	282504        	s16i	a8, a2, 8
    }
    
    return buf;
}
  903788:	d10f      	retw.n
	...

0090378c <_buf_pool_static_alloc_buf_align>:

LOCAL adf_nbuf_t  _buf_pool_static_alloc_buf_align(pool_handle_t handle, BUF_POOL_ID poolId, int reserve, int align)
{
  90378c:	6c1004        	entry	a1, 32
    return _buf_pool_static_alloc_buf(handle, poolId, reserve);
  90378f:	da20      	mov.n	a10, a2
  903791:	db30      	mov.n	a11, a3
  903793:	dc40      	mov.n	a12, a4
  903795:	5bfff4        	call8	903768 <_buf_pool_static_alloc_buf>
}
  903798:	d2a0      	mov.n	a2, a10
  90379a:	d10f      	retw.n

0090379c <_buf_pool_static_free_buf>:
    
LOCAL void _buf_pool_static_free_buf(pool_handle_t handle, BUF_POOL_ID poolId, adf_nbuf_t buf)
{
  90379c:	6c1004        	entry	a1, 32
    if ( g_poolCtx.bufQ[poolId] == NULL ) {
  90379f:	1871be        	l32r	a8, 8dfe98 <_bss_end+0x3d2690>
  9037a2:	08330a        	addx4	a3, a3, a8
  9037a5:	8830      	l32i.n	a8, a3, 0
  9037a7:	cc81      	bnez.n	a8, 9037ac <_buf_pool_static_free_buf+0x10>
  9037a9:	600001        	j	9037ae <_buf_pool_static_free_buf+0x12>
        g_poolCtx.bufQ[poolId] = buf;
    } else {
        buf->next_buf = g_poolCtx.bufQ[poolId];
  9037ac:	9841      	s32i.n	a8, a4, 4
        g_poolCtx.bufQ[poolId] = buf;
  9037ae:	9430      	s32i.n	a4, a3, 0
  9037b0:	d10f      	retw.n
	...

009037b4 <buf_pool_module_install>:
LOCAL void _buf_pool_static_shutdown(pool_handle_t handle);      

BUF_POOL_STATIC_CONTEXT g_poolCtx;

void buf_pool_module_install(struct buf_pool_api *pAPIs)
{   
  9037b4:	6c1004        	entry	a1, 32
    pAPIs->_init = _buf_pool_static_init;
  9037b7:	1871bf        	l32r	a8, 8dfeb4 <_bss_end+0x3d26ac>
  9037ba:	9820      	s32i.n	a8, a2, 0
    pAPIs->_create_pool = _buf_pool_static_create_pool;
  9037bc:	1871c0        	l32r	a8, 8dfebc <_bss_end+0x3d26b4>
  9037bf:	9822      	s32i.n	a8, a2, 8
    pAPIs->_alloc_buf = _buf_pool_static_alloc_buf;
  9037c1:	1871c1        	l32r	a8, 8dfec8 <_bss_end+0x3d26c0>
  9037c4:	9823      	s32i.n	a8, a2, 12
    pAPIs->_alloc_buf_align = _buf_pool_static_alloc_buf_align;
  9037c6:	1871c2        	l32r	a8, 8dfed0 <_bss_end+0x3d26c8>
  9037c9:	9824      	s32i.n	a8, a2, 16
    pAPIs->_free_buf = _buf_pool_static_free_buf;
  9037cb:	1871c3        	l32r	a8, 8dfed8 <_bss_end+0x3d26d0>
  9037ce:	9825      	s32i.n	a8, a2, 20
    pAPIs->_shutdown = _buf_pool_static_shutdown;
  9037d0:	1871c4        	l32r	a8, 8dfee0 <_bss_end+0x3d26d8>
  9037d3:	9821      	s32i.n	a8, a2, 4
  9037d5:	d10f      	retw.n
	...

009037d8 <_fw_usbfifo_recv_command>:

typedef void (* USBFIFO_recv_command)(VBUF *cmd);
USBFIFO_recv_command m_origUsbfifoRecvCmd = NULL;

void _fw_usbfifo_recv_command(VBUF *buf)
{
  9037d8:	6c1004        	entry	a1, 32
	uint8_t *cmd_data;
	uint32_t tmp;

	cmd_data = (uint8_t *)(buf->desc_list->buf_addr +
  9037db:	8820      	l32i.n	a8, a2, 0

typedef void (* USBFIFO_recv_command)(VBUF *cmd);
USBFIFO_recv_command m_origUsbfifoRecvCmd = NULL;

void _fw_usbfifo_recv_command(VBUF *buf)
{
  9037dd:	da20      	mov.n	a10, a2
	uint8_t *cmd_data;
	uint32_t tmp;

	cmd_data = (uint8_t *)(buf->desc_list->buf_addr +
  9037df:	298105        	l16ui	a9, a8, 10
				buf->desc_list->data_offset);
	tmp = *((uint32_t *)cmd_data);
  9037e2:	8881      	l32i.n	a8, a8, 4
  9037e4:	a988      	add.n	a8, a8, a9
	if (tmp == 0xFFFFFFFF)
  9037e6:	8880      	l32i.n	a8, a8, 0
  9037e8:	698004        	bnei	a8, -1, 9037f0 <_fw_usbfifo_recv_command+0x18>
		_fw_usb_suspend_reboot();
  9037eb:	5803bf        	call8	9046e8 <_fw_usb_suspend_reboot>
  9037ee:	d10f      	retw.n
	else
		m_origUsbfifoRecvCmd(buf);
  9037f0:	1871c5        	l32r	a8, 8dff04 <_bss_end+0x3d26fc>
  9037f3:	8880      	l32i.n	a8, a8, 0
  9037f5:	0b8000        	callx8	a8
  9037f8:	d10f      	retw.n
	...

009037fc <_fw_usbfifo_init>:
}

void _fw_usbfifo_init(USB_FIFO_CONFIG *pConfig)
{
  9037fc:	6c1004        	entry	a1, 32
	m_origUsbfifoRecvCmd = pConfig->recv_command;
  9037ff:	8921      	l32i.n	a9, a2, 4
  903801:	1871c5        	l32r	a8, 8dff18 <_bss_end+0x3d2710>
  903804:	9980      	s32i.n	a9, a8, 0

	usbFifoConf.get_command_buf = pConfig->get_command_buf;
  903806:	1871c6        	l32r	a8, 8dff20 <_bss_end+0x3d2718>
  903809:	8920      	l32i.n	a9, a2, 0
  90380b:	9980      	s32i.n	a9, a8, 0
	usbFifoConf.recv_command    = _fw_usbfifo_recv_command;
  90380d:	1971c7        	l32r	a9, 8dff2c <_bss_end+0x3d2724>
  903810:	9981      	s32i.n	a9, a8, 4
	usbFifoConf.get_event_buf   = pConfig->get_event_buf;
  903812:	8922      	l32i.n	a9, a2, 8
	usbFifoConf.send_event_done = pConfig->send_event_done;
  903814:	8223      	l32i.n	a2, a2, 12
{
	m_origUsbfifoRecvCmd = pConfig->recv_command;

	usbFifoConf.get_command_buf = pConfig->get_command_buf;
	usbFifoConf.recv_command    = _fw_usbfifo_recv_command;
	usbFifoConf.get_event_buf   = pConfig->get_event_buf;
  903816:	9982      	s32i.n	a9, a8, 8
	usbFifoConf.send_event_done = pConfig->send_event_done;
  903818:	9283      	s32i.n	a2, a8, 12
  90381a:	d10f      	retw.n

0090381c <cold_reboot>:
}

void cold_reboot(void)
{
  90381c:	6c1004        	entry	a1, 32
	A_PRINTF("Cold reboot initiated.");
  90381f:	127184        	l32r	a2, 8dfe30 <_bss_end+0x3d2628>
  903822:	1a71c8        	l32r	a10, 8dff44 <_bss_end+0x3d273c>
  903825:	282212        	l32i	a8, a2, 72
  903828:	0b8000        	callx8	a8
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90382b:	187189        	l32r	a8, 8dfe50 <_bss_end+0x3d2648>
  90382e:	c090      	movi.n	a9, 0
#if defined(PROJECT_MAGPIE)
	iowrite32(WATCH_DOG_MAGIC_PATTERN_ADDR, 0);
#elif defined(PROJECT_K2)
	iowrite32(MAGPIE_REG_RST_STATUS_ADDR, 0);
#endif /* #if defined(PROJECT_MAGPIE) */
	A_USB_JUMP_BOOT();
  903830:	22222b        	l32i	a2, a2, 172
  903833:	0c0200        	memw
  903836:	298600        	s32i	a9, a8, 0
  903839:	0b2000        	callx8	a2
  90383c:	d10f      	retw.n
	...

00903840 <usb_status_in_patch>:

/*
 * support more than 64 bytes command on ep3
 */
void usb_status_in_patch(void)
{
  903840:	6c1004        	entry	a1, 32
	static VBUF *evntbuf = NULL;
	static volatile uint32_t *regaddr;
	static BOOLEAN cmd_is_new = TRUE;
	BOOLEAN cmd_end = FALSE;

	if (cmd_is_new) {
  903843:	1271c9        	l32r	a2, 8dff68 <_bss_end+0x3d2760>
  903846:	282100        	l16ui	a8, a2, 0
  903849:	648048        	beqz	a8, 903895 <usb_status_in_patch+0x55>
		evntbuf = usbFifoConf.get_event_buf();
  90384c:	1871c6        	l32r	a8, 8dff64 <_bss_end+0x3d275c>
  90384f:	8a82      	l32i.n	a10, a8, 8
  903851:	0ba000        	callx8	a10
  903854:	1871ca        	l32r	a8, 8dff7c <_bss_end+0x3d2774>
  903857:	9a80      	s32i.n	a10, a8, 0
		if (evntbuf != NULL) {
  903859:	c9af      	beqz.n	a10, 90387c <usb_status_in_patch+0x3c>
			regaddr = (uint32_t *)VBUF_GET_DATA_ADDR(evntbuf);
  90385b:	88a0      	l32i.n	a8, a10, 0
  90385d:	298105        	l16ui	a9, a8, 10
  903860:	8881      	l32i.n	a8, a8, 4
  903862:	a989      	add.n	a9, a8, a9
  903864:	1871cb        	l32r	a8, 8dff90 <_bss_end+0x3d2788>
  903867:	9980      	s32i.n	a9, a8, 0
			buf_len = evntbuf->buf_length;
  903869:	1871cc        	l32r	a8, 8dff9c <_bss_end+0x3d2794>
  90386c:	29a104        	l16ui	a9, a10, 8
  90386f:	298500        	s16i	a9, a8, 0
		} else {
			mUSB_STATUS_IN_INT_DISABLE();
			return;
		}

		cmd_is_new = FALSE;
  903872:	c080      	movi.n	a8, 0
  903874:	282500        	s16i	a8, a2, 0
  903877:	60001a        	j	903895 <usb_status_in_patch+0x55>
  90387a:	000012        	srai	a0, a0, 0

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  90387d:	71cd29        	bbs	a12, a1, 9038aa <usb_status_in_patch+0x6a>
		evntbuf = usbFifoConf.get_event_buf();
		if (evntbuf != NULL) {
			regaddr = (uint32_t *)VBUF_GET_DATA_ADDR(evntbuf);
			buf_len = evntbuf->buf_length;
		} else {
			mUSB_STATUS_IN_INT_DISABLE();
  903880:	0ac028        	mull	a0, a12, a10
  903883:	200008        	l8ui	a0, a0, 8
  903886:	084709        	addx2	a7, a4, a8
  903889:	8802      	l32i.n	a8, a0, 8
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  90388b:	0c0200        	memw
  90388e:	282400        	s8i	a8, a2, 0
  903891:	d10f      	retw.n
  903893:	00001a        	sll	a0, a0
		}

		cmd_is_new = FALSE;
	}

	if (buf_len > USB_EP3_MAX_PKT_SIZE) {
  903896:	71ccc4        	bnall	a12, a1, 90385e <usb_status_in_patch+0x1e>
  903899:	9028      	s32i.n	a0, a2, 32
  90389b:	a100      	add.n	a0, a0, a1
	}
	/* TODO: 64 bytes...
	 * controller supposed will take care of zero-length? */
	else {
		reg_buf_len = buf_len;
		cmd_end = TRUE;
  90389d:	c021      	movi.n	a2, 1
		}

		cmd_is_new = FALSE;
	}

	if (buf_len > USB_EP3_MAX_PKT_SIZE) {
  90389f:	789b09        	bgeu	a9, a8, 9038ac <usb_status_in_patch+0x6c>
		reg_buf_len = USB_EP3_MAX_PKT_SIZE;
		buf_len -= USB_EP3_MAX_PKT_SIZE;
  9038a2:	288cc0        	addi	a8, a8, -64
  9038a5:	28a500        	s16i	a8, a10, 0
	uint16_t reg_buf_len;
	static uint16_t buf_len;
	static VBUF *evntbuf = NULL;
	static volatile uint32_t *regaddr;
	static BOOLEAN cmd_is_new = TRUE;
	BOOLEAN cmd_end = FALSE;
  9038a8:	c020      	movi.n	a2, 0

		cmd_is_new = FALSE;
	}

	if (buf_len > USB_EP3_MAX_PKT_SIZE) {
		reg_buf_len = USB_EP3_MAX_PKT_SIZE;
  9038aa:	d890      	mov.n	a8, a9
  9038ac:	1971cb        	l32r	a9, 8dffd8 <_bss_end+0x3d27d0>
		reg_buf_len = buf_len;
		cmd_end = TRUE;
	}

	/* INT use EP3 */
	for (count = 0; count < (reg_buf_len / 4); count++)
  9038af:	082c14        	srli	a12, a8, 2
  9038b2:	8b90      	l32i.n	a11, a9, 0
  9038b4:	1e71ce        	l32r	a14, 8dffec <_bss_end+0x3d27e4>
  9038b7:	dab0      	mov.n	a10, a11
  9038b9:	c090      	movi.n	a9, 0
  9038bb:	600010        	j	9038cf <usb_status_in_patch+0x8f>
  9038be:	00000c        	sub	a0, a0, a0
	{
		iowrite32_usb(ZM_EP3_DATA_OFFSET, *regaddr);
  9038c1:	02008d        	excw
  9038c4:	d0b1      	excw
		reg_buf_len = buf_len;
		cmd_end = TRUE;
	}

	/* INT use EP3 */
	for (count = 0; count < (reg_buf_len / 4); count++)
  9038c6:	990c      	s32i.n	a9, a0, 48
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  9038c8:	02009d        	excw
  9038cb:	e0          	.byte 0xe0
  9038cc:	09094f        	extui	a9, a9, 0, 16
  9038cf:	dda0      	mov.n	a13, a10
  9038d1:	b4aa      	addi.n	a10, a10, 4
  9038d3:	7c99e9        	bne	a9, a12, 9038c0 <usb_status_in_patch+0x80>
  9038d6:	1a71cb        	l32r	a10, 8e0004 <_bss_end+0x3d27fc>
  9038d9:	0b990a        	addx4	a9, a9, a11
  9038dc:	99a0      	s32i.n	a9, a10, 0
	{
		iowrite32_usb(ZM_EP3_DATA_OFFSET, *regaddr);
		regaddr++;
	}

	remainder = reg_buf_len % 4;
  9038de:	080841        	extui	a8, a8, 0, 2

	if (remainder) {
  9038e1:	cb84      	beqz.n	a8, 903919 <usb_status_in_patch+0xd9>
  9038e3:	1971ac        	l32r	a9, 8dff94 <_bss_end+0x3d278c>
		switch(remainder) {
  9038e6:	688207        	beqi	a8, 2, 9038f1 <usb_status_in_patch+0xb1>
  9038e9:	698309        	bnei	a8, 3, 9038f6 <usb_status_in_patch+0xb6>
  9038ec:	c087      	movi.n	a8, 7
  9038ee:	600006        	j	9038f8 <usb_status_in_patch+0xb8>
  9038f1:	c083      	movi.n	a8, 3
  9038f3:	600001        	j	9038f8 <usb_status_in_patch+0xb8>
  9038f6:	c081      	movi.n	a8, 1
  9038f8:	0c0200        	memw
  9038fb:	9890      	s32i.n	a8, a9, 0
		case 1:
			iowrite32_usb(ZM_CBUS_FIFO_SIZE_OFFSET, 0x1);
			break;
		}

		iowrite32_usb(ZM_EP3_DATA_OFFSET, *regaddr);
  9038fd:	1871cb        	l32r	a8, 8e002c <_bss_end+0x3d2824>
  903900:	8880      	l32i.n	a8, a8, 0
  903902:	0c0200        	memw
  903905:	8980      	l32i.n	a9, a8, 0
  903907:	1871ce        	l32r	a8, 8e0040 <_bss_end+0x3d2838>
  90390a:	0c0200        	memw
  90390d:	9980      	s32i.n	a9, a8, 0
  90390f:	1871ac        	l32r	a8, 8dffc0 <_bss_end+0x3d27b8>
  903912:	c09f      	movi.n	a9, 15
  903914:	0c0200        	memw
  903917:	9980      	s32i.n	a9, a8, 0

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  903919:	1871cf        	l32r	a8, 8e0058 <_bss_end+0x3d2850>

		/* Restore CBus FIFO size to word size */
		iowrite32_usb(ZM_CBUS_FIFO_SIZE_OFFSET, 0xF);
	}

	mUSB_EP3_XFER_DONE();
  90391c:	c0a8      	movi.n	a10, 8
  90391e:	298000        	l8ui	a9, a8, 0
  903921:	090947        	extui	a9, a9, 0, 8
  903924:	0a9902        	or	a9, a9, a10
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  903927:	0c0200        	memw
  90392a:	298400        	s8i	a9, a8, 0

	if (evntbuf != NULL && cmd_end) {
  90392d:	1871ca        	l32r	a8, 8e0058 <_bss_end+0x3d2850>
  903930:	8a80      	l32i.n	a10, a8, 0
  903932:	c9a2      	beqz.n	a10, 903948 <usb_status_in_patch+0x108>
  903934:	642010        	beqz	a2, 903948 <usb_status_in_patch+0x108>
		usbFifoConf.send_event_done(evntbuf);
  903937:	1271c6        	l32r	a2, 8e0050 <_bss_end+0x3d2848>
  90393a:	222203        	l32i	a2, a2, 12
  90393d:	0b2000        	callx8	a2
		cmd_is_new = TRUE;
  903940:	1271c9        	l32r	a2, 8e0064 <_bss_end+0x3d285c>
  903943:	c081      	movi.n	a8, 1
  903945:	282500        	s16i	a8, a2, 0
  903948:	d10f      	retw.n
	...

0090394c <usb_reg_out_patch>:

/*
 * support more than 64 bytes command on ep4 
 */
void usb_reg_out_patch(void)
{
  90394c:	6c1004        	entry	a1, 32

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  90394f:	1271d0        	l32r	a2, 8e0090 <_bss_end+0x3d2888>
	static BOOLEAN cmd_is_new = TRUE;

	/* get the size of this transcation */
	usbfifolen = ioread8_usb(ZM_EP4_BYTE_COUNT_LOW_OFFSET);

	if (usbfifolen > USB_EP4_MAX_PKT_SIZE) {
  903952:	230a40        	movi	a3, 64
  903955:	222000        	l8ui	a2, a2, 0
  903958:	020247        	extui	a2, a2, 0, 8
  90395b:	723b11        	bgeu	a3, a2, 903970 <usb_reg_out_patch+0x24>
		A_PRINTF("EP4 FIFO Bug? Buffer is too big: %x\n", usbfifolen);
  90395e:	137184        	l32r	a3, 8dff70 <_bss_end+0x3d2768>
  903961:	1a71d1        	l32r	a10, 8e00a8 <_bss_end+0x3d28a0>
  903964:	233212        	l32i	a3, a3, 72
  903967:	022b02        	or	a11, a2, a2
  90396a:	0b3000        	callx8	a3
		cold_reboot();
  90396d:	5bffab        	call8	90381c <cold_reboot>
	}

	/* check is command is new */
	if(cmd_is_new) {
  903970:	1371d2        	l32r	a3, 8e00b8 <_bss_end+0x3d28b0>
  903973:	243100        	l16ui	a4, a3, 0
  903976:	cb4a      	beqz.n	a4, 9039b4 <usb_reg_out_patch+0x68>

		buf = usbFifoConf.get_command_buf();
  903978:	1471c6        	l32r	a4, 8e0090 <_bss_end+0x3d2888>
  90397b:	8a40      	l32i.n	a10, a4, 0
  90397d:	0ba000        	callx8	a10
  903980:	1471d3        	l32r	a4, 8e00cc <_bss_end+0x3d28c4>
		cmd_len = 0;
  903983:	c080      	movi.n	a8, 0
	}

	/* check is command is new */
	if(cmd_is_new) {

		buf = usbFifoConf.get_command_buf();
  903985:	9a40      	s32i.n	a10, a4, 0
		cmd_len = 0;
  903987:	1471d4        	l32r	a4, 8e00d8 <_bss_end+0x3d28d0>
  90398a:	284500        	s16i	a8, a4, 0

		if(!buf) {
  90398d:	cda5      	bnez.n	a10, 9039a6 <usb_reg_out_patch+0x5a>
			A_PRINTF("%s: Filed to get new buffer.\n", __func__);
  90398f:	137184        	l32r	a3, 8dffa0 <_bss_end+0x3d2798>
  903992:	1a71d5        	l32r	a10, 8e00e8 <_bss_end+0x3d28e0>
  903995:	233212        	l32i	a3, a3, 72
  903998:	1b71d6        	l32r	a11, 8e00f0 <_bss_end+0x3d28e8>
  90399b:	0b3000        	callx8	a3
		usbfifolen = (usbfifolen >> 2) + 1;
	else
		usbfifolen = usbfifolen >> 2;

	/* retrieve the data from fifo */
	for(ii = 0; ii < usbfifolen; ii++) {
  90399e:	c080      	movi.n	a8, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  9039a0:	1371d9        	l32r	a3, 8e0104 <_bss_end+0x3d28fc>
  9039a3:	6000a7        	j	903a4e <usb_reg_out_patch+0x102>
			A_PRINTF("%s: Filed to get new buffer.\n", __func__);
			goto err;
		}

		/* copy free, assignment buffer of the address */
		regaddr = (uint32_t *)buf->desc_list->buf_addr;
  9039a6:	84a0      	l32i.n	a4, a10, 0

		cmd_is_new = FALSE;
  9039a8:	283500        	s16i	a8, a3, 0
			A_PRINTF("%s: Filed to get new buffer.\n", __func__);
			goto err;
		}

		/* copy free, assignment buffer of the address */
		regaddr = (uint32_t *)buf->desc_list->buf_addr;
  9039ab:	294201        	l32i	a9, a4, 4
  9039ae:	1471d7        	l32r	a4, 8e010c <_bss_end+0x3d2904>
  9039b1:	294600        	s32i	a9, a4, 0

		cmd_is_new = FALSE;
	}

	/* just in case, suppose should not happen */
	if(!buf)
  9039b4:	1371d3        	l32r	a3, 8e0100 <_bss_end+0x3d28f8>
  9039b7:	8a30      	l32i.n	a10, a3, 0
  9039b9:	64afe1        	beqz	a10, 90399e <usb_reg_out_patch+0x52>
	 */
	if(usbfifolen < USB_EP4_MAX_PKT_SIZE)
		cmd_is_last = TRUE;

	/* accumulate the size */
	cmd_len += usbfifolen;
  9039bc:	1371d4        	l32r	a3, 8e010c <_bss_end+0x3d2904>

	if (cmd_len > buf->desc_list->buf_size) {
  9039bf:	88a0      	l32i.n	a8, a10, 0
	 */
	if(usbfifolen < USB_EP4_MAX_PKT_SIZE)
		cmd_is_last = TRUE;

	/* accumulate the size */
	cmd_len += usbfifolen;
  9039c1:	293100        	l16ui	a9, a3, 0
  9039c4:	a929      	add.n	a9, a2, a9
  9039c6:	09094f        	extui	a9, a9, 0, 16
  9039c9:	293500        	s16i	a9, a3, 0

	if (cmd_len > buf->desc_list->buf_size) {
  9039cc:	238104        	l16ui	a3, a8, 8
  9039cf:	793b0b        	bgeu	a3, a9, 9039de <usb_reg_out_patch+0x92>
		A_PRINTF("%s: Data length on EP4 FIFO is bigger as "
  9039d2:	137184        	l32r	a3, 8dffe4 <_bss_end+0x3d27dc>
  9039d5:	1a71d8        	l32r	a10, 8e0138 <_bss_end+0x3d2930>
  9039d8:	233212        	l32i	a3, a3, 72
  9039db:	63ffb9        	j	903998 <usb_reg_out_patch+0x4c>
		goto err;
	}

	/* round it to alignment */
	if(usbfifolen % 4)
		usbfifolen = (usbfifolen >> 2) + 1;
  9039de:	c031      	movi.n	a3, 1
			 "allocated buffer data! Drop it!\n", __func__);
		goto err;
	}

	/* round it to alignment */
	if(usbfifolen % 4)
  9039e0:	020441        	extui	a4, a2, 0, 2
		usbfifolen = (usbfifolen >> 2) + 1;
  9039e3:	c0b0      	movi.n	a11, 0
  9039e5:	043b39        	movnez	a11, a3, a4
  9039e8:	1371d7        	l32r	a3, 8e0144 <_bss_end+0x3d293c>
	else
		usbfifolen = usbfifolen >> 2;
  9039eb:	022c14        	srli	a12, a2, 2
  9039ee:	8330      	l32i.n	a3, a3, 0
		goto err;
	}

	/* round it to alignment */
	if(usbfifolen % 4)
		usbfifolen = (usbfifolen >> 2) + 1;
  9039f0:	abcc      	add.n	a12, a12, a11
  9039f2:	dd30      	mov.n	a13, a3
	else
		usbfifolen = usbfifolen >> 2;

	/* retrieve the data from fifo */
	for(ii = 0; ii < usbfifolen; ii++) {
  9039f4:	c0b0      	movi.n	a11, 0
  9039f6:	1f71d9        	l32r	a15, 8e015c <_bss_end+0x3d2954>
  9039f9:	60000f        	j	903a0c <usb_reg_out_patch+0xc0>
  9039fc:	000c02        	or	a12, a0, a0
  9039ff:	0084f0        	excw
  903a02:	b1bb      	addi.n	a11, a11, 1
		/* read fifo data out */
		ep4_data = ioread32_usb(ZM_EP4_DATA_OFFSET);
		*regaddr = ep4_data;
  903a04:	0c0200        	memw
  903a07:	94e0      	s32i.n	a4, a14, 0
		usbfifolen = (usbfifolen >> 2) + 1;
	else
		usbfifolen = usbfifolen >> 2;

	/* retrieve the data from fifo */
	for(ii = 0; ii < usbfifolen; ii++) {
  903a09:	0b0b4f        	extui	a11, a11, 0, 16
  903a0c:	ded0      	mov.n	a14, a13
  903a0e:	b4dd      	addi.n	a13, a13, 4
  903a10:	7cb9e9        	bne	a11, a12, 9039fd <usb_reg_out_patch+0xb1>
  903a13:	1c71d7        	l32r	a12, 8e0170 <_bss_end+0x3d2968>
  903a16:	03bb0a        	addx4	a11, a11, a3
  903a19:	9bc0      	s32i.n	a11, a12, 0
		*regaddr = ep4_data;
		regaddr++;
	}

	/* if this is the last command, callback to HTC */
	if (cmd_is_last) {
  903a1b:	c33f      	movi.n	a3, 63
  903a1d:	723330        	bltu	a3, a2, 903a51 <usb_reg_out_patch+0x105>
		buf->desc_list->next_desc = NULL;
  903a20:	c020      	movi.n	a2, 0
  903a22:	9280      	s32i.n	a2, a8, 0
		buf->desc_list->data_offset = 0;
  903a24:	228505        	s16i	a2, a8, 10
		buf->desc_list->data_size = cmd_len;
		buf->desc_list->control = 0;
  903a27:	228507        	s16i	a2, a8, 14

	/* if this is the last command, callback to HTC */
	if (cmd_is_last) {
		buf->desc_list->next_desc = NULL;
		buf->desc_list->data_offset = 0;
		buf->desc_list->data_size = cmd_len;
  903a2a:	298506        	s16i	a9, a8, 12
		buf->desc_list->control = 0;
		buf->next_buf = NULL;
  903a2d:	92a1      	s32i.n	a2, a10, 4
		buf->buf_length = cmd_len;

		usbFifoConf.recv_command(buf);
  903a2f:	1271c6        	l32r	a2, 8e0148 <_bss_end+0x3d2940>
		buf->desc_list->next_desc = NULL;
		buf->desc_list->data_offset = 0;
		buf->desc_list->data_size = cmd_len;
		buf->desc_list->control = 0;
		buf->next_buf = NULL;
		buf->buf_length = cmd_len;
  903a32:	29a504        	s16i	a9, a10, 8

		usbFifoConf.recv_command(buf);
  903a35:	8221      	l32i.n	a2, a2, 4

		cmd_is_new = TRUE;
  903a37:	c031      	movi.n	a3, 1
		buf->desc_list->data_size = cmd_len;
		buf->desc_list->control = 0;
		buf->next_buf = NULL;
		buf->buf_length = cmd_len;

		usbFifoConf.recv_command(buf);
  903a39:	0b2000        	callx8	a2

		cmd_is_new = TRUE;
  903a3c:	1271d2        	l32r	a2, 8e0184 <_bss_end+0x3d297c>
  903a3f:	232500        	s16i	a3, a2, 0
  903a42:	d10f      	retw.n
	goto done;
err:
	/* we might get no command buffer here?
	 * but if we return here, the ep4 fifo will be lock out,
	 * so that we still read them out but just drop it? */
	for(ii = 0; ii < usbfifolen; ii++)
  903a44:	b188      	addi.n	a8, a8, 1
  903a46:	0c0200        	memw
  903a49:	8430      	l32i.n	a4, a3, 0
  903a4b:	08084f        	extui	a8, a8, 0, 16
  903a4e:	7283f2        	bltu	a8, a2, 903a44 <usb_reg_out_patch+0xf8>
  903a51:	d10f      	retw.n
	...

00903a54 <vUSBFIFO_EP6Cfg_FS_patch>:
#define FS_C1_I0_A0_EP6_MAP		\
	 (FS_C1_I0_A0_EP6_FIFO_START | (FS_C1_I0_A0_EP6_FIFO_START << 4) | \
	  (MASK_F0 >> (4*FS_C1_I0_A0_EP6_DIRECTION)))

void vUSBFIFO_EP6Cfg_FS_patch(void)
{
  903a54:	6c1004        	entry	a1, 32
#if (FS_C1_I0_A0_EP_NUMBER >= 6)
	int i;

	/* EP0X06 */
	mUsbEPMap(EP6, FS_C1_I0_A0_EP6_MAP);
  903a57:	2b0a6f        	movi	a11, 111
  903a5a:	2a0a06        	movi	a10, 6
  903a5d:	5b8082        	call8	8e3c68 <mUsbEPMap>
	mUsbFIFOMap(FS_C1_I0_A0_EP6_FIFO_START, FS_C1_I0_A0_EP6_FIFO_MAP);
  903a60:	2a0a06        	movi	a10, 6
  903a63:	0aab02        	or	a11, a10, a10
  903a66:	5b8087        	call8	8e3c84 <mUsbFIFOMap>
	mUsbFIFOConfig(FS_C1_I0_A0_EP6_FIFO_START, FS_C1_I0_A0_EP6_FIFO_CONFIG);
  903a69:	2b0a86        	movi	a11, 134
  903a6c:	c0a6      	movi.n	a10, 6
  903a6e:	5b808d        	call8	8e3ca4 <mUsbFIFOConfig>

	for(i = FS_C1_I0_A0_EP6_FIFO_START + 1 ;
            i < FS_C1_I0_A0_EP6_FIFO_START + FS_C1_I0_A0_EP6_FIFO_NO ; i ++)
	{
		mUsbFIFOConfig(i, (FS_C1_I0_A0_EP6_FIFO_CONFIG & (~BIT7)) );
  903a71:	c0b6      	movi.n	a11, 6
  903a73:	c0a7      	movi.n	a10, 7
  903a75:	5b808b        	call8	8e3ca4 <mUsbFIFOConfig>
	}

	mUsbEPMxPtSzHigh(EP6, FS_C1_I0_A0_EP6_DIRECTION,
  903a78:	c0b1      	movi.n	a11, 1
  903a7a:	c4c0      	movi.n	a12, 64
  903a7c:	c0a6      	movi.n	a10, 6
  903a7e:	5b8091        	call8	8e3cc4 <mUsbEPMxPtSzHigh>
			 (FS_C1_I0_A0_EP6_MAX_PACKET & 0x7ff));
	mUsbEPMxPtSzLow(EP6, FS_C1_I0_A0_EP6_DIRECTION,
  903a81:	c0b1      	movi.n	a11, 1
  903a83:	c4c0      	movi.n	a12, 64
  903a85:	c0a6      	movi.n	a10, 6
  903a87:	5b8099        	call8	8e3cec <mUsbEPMxPtSzLow>
			(FS_C1_I0_A0_EP6_MAX_PACKET & 0x7ff));
	mUsbEPinHighBandSet(EP6, FS_C1_I0_A0_EP6_DIRECTION,
  903a8a:	c0b1      	movi.n	a11, 1
  903a8c:	c4c0      	movi.n	a12, 64
  903a8e:	2a0a06        	movi	a10, 6
  903a91:	5b809f        	call8	8e3d10 <mUsbEPinHighBandSet>
  903a94:	d10f      	retw.n
	...

00903a98 <vUsbFIFO_EPxCfg_FS_patch>:
			    FS_C1_I0_A0_EP6_MAX_PACKET);
#endif
}

void vUsbFIFO_EPxCfg_FS_patch(void)
{
  903a98:	6c1004        	entry	a1, 32
	switch (u8UsbConfigValue)
  903a9b:	187187        	l32r	a8, 8e00b8 <_bss_end+0x3d28b0>
  903a9e:	288100        	l16ui	a8, a8, 0
  903aa1:	698113        	bnei	a8, 1, 903ab8 <vUsbFIFO_EPxCfg_FS_patch+0x20>
	{
#if (FS_CONFIGURATION_NUMBER >= 1)
		/* Configuration 0X01 */
        case 0X01:
		switch (u8UsbInterfaceValue)
  903aa4:	187186        	l32r	a8, 8e00bc <_bss_end+0x3d28b4>
  903aa7:	288100        	l16ui	a8, a8, 0
  903aaa:	cc8a      	bnez.n	a8, 903ab8 <vUsbFIFO_EPxCfg_FS_patch+0x20>
		{
#if (FS_C1_INTERFACE_NUMBER >= 1)
			/* Interface 0 */
                case 0:
			switch (u8UsbInterfaceAlternateSetting)
  903aac:	187188        	l32r	a8, 8e00cc <_bss_end+0x3d28c4>
  903aaf:	288100        	l16ui	a8, a8, 0
  903ab2:	658002        	bnez	a8, 903ab8 <vUsbFIFO_EPxCfg_FS_patch+0x20>
                        case 0:

				/* snapped.... */

				/* patch up this ep6_fs config */
				vUSBFIFO_EP6Cfg_FS_patch();
  903ab5:	5bffe7        	call8	903a54 <vUSBFIFO_EP6Cfg_FS_patch>
  903ab8:	d10f      	retw.n
	...

00903abc <bSet_configuration_patch>:
	}
	/* mCHECK_STACK(); */
}

BOOLEAN bSet_configuration_patch(void)
{
  903abc:	6c1004        	entry	a1, 32
	/* do some defaul configuration */
	bSet_configuration();
  903abf:	5b7d2f        	call8	8e2f7c <bSet_configuration>

	/* overwrite defaul FIFO configuration for FullSpeed USB */
	if ((mLOW_BYTE(mDEV_REQ_VALUE()) != 0) && !mUsbHighSpeedST())
  903ac2:	1271da        	l32r	a2, 8e022c <_bss_end+0x3d2a24>
  903ac5:	222007        	l8ui	a2, a2, 7
  903ac8:	c82a      	beqz.n	a2, 903ad6 <bSet_configuration_patch+0x1a>

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  903aca:	1271a6        	l32r	a2, 8e0164 <_bss_end+0x3d295c>
  903acd:	222000        	l8ui	a2, a2, 0
  903ad0:	792f02        	bbsi	a2, 25, 903ad6 <bSet_configuration_patch+0x1a>
			vUsbFIFO_EPxCfg_FS_patch();
  903ad3:	5bfff1        	call8	903a98 <vUsbFIFO_EPxCfg_FS_patch>

	eUsbCxFinishAction = ACT_DONE;
  903ad6:	1871db        	l32r	a8, 8e0244 <_bss_end+0x3d2a3c>
  903ad9:	c021      	movi.n	a2, 1
  903adb:	9280      	s32i.n	a2, a8, 0
	return TRUE;
}
  903add:	d10f      	retw.n
	...

00903ae0 <bStandardCommand_patch>:

extern BOOLEAN bStandardCommand(void);

BOOLEAN bStandardCommand_patch(void)
{
  903ae0:	6c1004        	entry	a1, 32
	if (mDEV_REQ_REQ() == USB_SET_CONFIGURATION) {
  903ae3:	1871da        	l32r	a8, 8e024c <_bss_end+0x3d2a44>
  903ae6:	298102        	l16ui	a9, a8, 4
  903ae9:	280a09        	movi	a8, 9
  903aec:	78992d        	bne	a9, a8, 903b1d <bStandardCommand_patch+0x3d>
		A_USB_SET_CONFIG();
  903aef:	187184        	l32r	a8, 8e0100 <_bss_end+0x3d28f8>
  903af2:	2a8225        	l32i	a10, a8, 148
  903af5:	0ba000        	callx8	a10

#if ENABLE_SWAP_DATA_MODE
		/* SWAP FUNCTION should be enabled while DMA engine
		 * is not working, the best place to enable it
		 * is before we trigger the DMA */
		MAGPIE_REG_USB_RX0_SWAP_DATA = 0x1;
  903af8:	1871dc        	l32r	a8, 8e0268 <_bss_end+0x3d2a60>
  903afb:	c0a1      	movi.n	a10, 1
  903afd:	0c0200        	memw
  903b00:	9a80      	s32i.n	a10, a8, 0
		MAGPIE_REG_USB_TX0_SWAP_DATA = 0x1;
  903b02:	1871dd        	l32r	a8, 8e0278 <_bss_end+0x3d2a70>
  903b05:	0c0200        	memw
  903b08:	9a80      	s32i.n	a10, a8, 0

#if SYSTEM_MODULE_HP_EP5
		MAGPIE_REG_USB_RX1_SWAP_DATA = 0x1;
  903b0a:	1871de        	l32r	a8, 8e0284 <_bss_end+0x3d2a7c>
  903b0d:	0c0200        	memw
  903b10:	9a80      	s32i.n	a10, a8, 0
#endif

#if SYSTEM_MODULE_HP_EP6
		MAGPIE_REG_USB_RX2_SWAP_DATA = 0x1;
  903b12:	1871df        	l32r	a8, 8e0290 <_bss_end+0x3d2a88>
  903b15:	0c0200        	memw
  903b18:	9a80      	s32i.n	a10, a8, 0
#endif

#endif /* ENABLE_SWAP_DATA_MODE */
		return TRUE;
  903b1a:	600002        	j	903b20 <bStandardCommand_patch+0x40>
	} else
		return bStandardCommand();
  903b1d:	5b7ddb        	call8	8e328c <bStandardCommand>
}
  903b20:	d2a0      	mov.n	a2, a10
  903b22:	d10f      	retw.n

00903b24 <bGet_descriptor_patch>:
#define EP3_INT_INTERVAL		19
#define EP4_TRANSFER_TYPE_OFFSET	21
#define EP4_INT_INTERVAL		22

BOOLEAN bGet_descriptor_patch(void)
{
  903b24:	6c1004        	entry	a1, 32
	if (mDEV_REQ_VALUE_HIGH() == 1)
  903b27:	1371da        	l32r	a3, 8e0290 <_bss_end+0x3d2a88>
  903b2a:	223103        	l16ui	a2, a3, 6
  903b2d:	028214        	srli	a2, a2, 8
  903b30:	692120        	bnei	a2, 1, 903b54 <bGet_descriptor_patch+0x30>
	{
		uint8_t *p = (uint8_t *)u8UsbDeviceDescriptor;

		/* Copy Usb Device Descriptor */
		ath_hal_memcpy(UsbDeviceDescriptorPatch, p,
  903b33:	1471e1        	l32r	a4, 8e02b8 <_bss_end+0x3d2ab0>
  903b36:	1271e0        	l32r	a2, 8e02b8 <_bss_end+0x3d2ab0>
  903b39:	8b40      	l32i.n	a11, a4, 0
  903b3b:	da20      	mov.n	a10, a2
  903b3d:	c1c2      	movi.n	a12, 18
  903b3f:	580034        	call8	903c10 <ath_hal_memcpy>
				sizeof(UsbDeviceDescriptorPatch));

		/* Change bcdDevice. we need it to detect if FW
		 * was uploaded. */
		UsbDeviceDescriptorPatch[BCD_DEVICE_OFFSET] =
  903b42:	c78f      	movi.n	a8, -1
  903b44:	282506        	s16i	a8, a2, 12
			BCD_DEVICE_FW_SIGNATURE;

		pu8DescriptorEX = UsbDeviceDescriptorPatch;
  903b47:	1871e2        	l32r	a8, 8e02d0 <_bss_end+0x3d2ac8>
  903b4a:	9280      	s32i.n	a2, a8, 0
		u16TxRxCounter = mTABLE_LEN(u8UsbDeviceDescriptor[0]);
  903b4c:	8240      	l32i.n	a2, a4, 0
  903b4e:	242001        	l8ui	a4, a2, 1
  903b51:	600024        	j	903b79 <bGet_descriptor_patch+0x55>
			u16TxRxCounter = mDEV_REQ_LENGTH();

		A_USB_EP0_TX_DATA();

		return TRUE;
	} else if (mDEV_REQ_VALUE_HIGH() == 2) {
  903b54:	69223d        	bnei	a2, 2, 903b95 <bGet_descriptor_patch+0x71>
		uint8_t *p = (uint8_t *)u8ConfigDescriptorEX;

		/* Copy ConfigDescriptor */
		ath_hal_memcpy(ConfigDescriptorPatch, p,
  903b57:	1271e5        	l32r	a2, 8e02ec <_bss_end+0x3d2ae4>
  903b5a:	1471e4        	l32r	a4, 8e02ec <_bss_end+0x3d2ae4>
  903b5d:	2b2200        	l32i	a11, a2, 0
  903b60:	044a02        	or	a10, a4, a4
  903b63:	2c0a3c        	movi	a12, 60
  903b66:	58002a        	call8	903c10 <ath_hal_memcpy>
				sizeof(ConfigDescriptorPatch));

		 /* place holder for EPx patches */

		if (mDEV_REQ_VALUE_LOW() == 0) {
  903b69:	283007        	l8ui	a8, a3, 7
			/* configuration no: 0 */
			pu8DescriptorEX = ConfigDescriptorPatch;
			u16TxRxCounter = ConfigDescriptorPatch[1];
		} else
			return FALSE;
  903b6c:	c020      	movi.n	a2, 0
		ath_hal_memcpy(ConfigDescriptorPatch, p,
				sizeof(ConfigDescriptorPatch));

		 /* place holder for EPx patches */

		if (mDEV_REQ_VALUE_LOW() == 0) {
  903b6e:	728928        	bne	a8, a2, 903b9a <bGet_descriptor_patch+0x76>
			/* configuration no: 0 */
			pu8DescriptorEX = ConfigDescriptorPatch;
  903b71:	1271e2        	l32r	a2, 8e02fc <_bss_end+0x3d2af4>
  903b74:	9420      	s32i.n	a4, a2, 0
			u16TxRxCounter = ConfigDescriptorPatch[1];
  903b76:	244101        	l16ui	a4, a4, 2
  903b79:	1271e3        	l32r	a2, 8e0308 <_bss_end+0x3d2b00>
		} else
			return FALSE;

		if (u16TxRxCounter > mDEV_REQ_LENGTH())
  903b7c:	233105        	l16ui	a3, a3, 10
		 /* place holder for EPx patches */

		if (mDEV_REQ_VALUE_LOW() == 0) {
			/* configuration no: 0 */
			pu8DescriptorEX = ConfigDescriptorPatch;
			u16TxRxCounter = ConfigDescriptorPatch[1];
  903b7f:	242500        	s16i	a4, a2, 0
		} else
			return FALSE;

		if (u16TxRxCounter > mDEV_REQ_LENGTH())
  903b82:	743b02        	bgeu	a3, a4, 903b88 <bGet_descriptor_patch+0x64>
			u16TxRxCounter = mDEV_REQ_LENGTH();
  903b85:	232500        	s16i	a3, a2, 0

		A_USB_EP0_TX_DATA();
  903b88:	127184        	l32r	a2, 8e0198 <_bss_end+0x3d2990>
  903b8b:	222234        	l32i	a2, a2, 208
  903b8e:	0b2000        	callx8	a2
		return TRUE;
  903b91:	c021      	movi.n	a2, 1
  903b93:	d10f      	retw.n
	} else
		return bGet_descriptor();
  903b95:	5b7ccb        	call8	8e2ec4 <bGet_descriptor>
  903b98:	d2a0      	mov.n	a2, a10
}
  903b9a:	d10f      	retw.n

00903b9c <ath_hal_getuptime>:
#include<ah_internal.h>
#include "ah_osdep.h"

a_uint32_t __ahdecl
ath_hal_getuptime(struct ath_hal *ah)
{
  903b9c:	6c1004        	entry	a1, 32
	return MSEC_TO_TICK(msecs);
}
static inline unsigned long
__adf_os_getuptime(void)
{
    return MSEC_TO_TICK(A_MILLISECONDS());;      
  903b9f:	187184        	l32r	a8, 8e01b0 <_bss_end+0x3d29a8>
  903ba2:	2a823d        	l32i	a10, a8, 244
  903ba5:	0ba000        	callx8	a10
	return adf_os_getuptime();
}
  903ba8:	d2a0      	mov.n	a2, a10
  903baa:	d10f      	retw.n

00903bac <_ath_hal_attach_tgt>:

struct ath_hal *
_ath_hal_attach_tgt(a_uint32_t devid, HAL_SOFTC sc,
		    adf_os_device_t dev, a_uint32_t flags, void* s)
{
  903bac:	6c1006        	entry	a1, 48
	HAL_STATUS status;
	struct ath_hal *ah = ath_hal_attach_tgt(devid, sc, dev, flags, &status);
  903baf:	db30      	mov.n	a11, a3
  903bb1:	dc40      	mov.n	a12, a4
  903bb3:	dd50      	mov.n	a13, a5
  903bb5:	de10      	mov.n	a14, a1
  903bb7:	da20      	mov.n	a10, a2
  903bb9:	5804dd        	call8	904f30 <ath_hal_attach_tgt>
	adf_os_print(" ath_hal = %p \n",ah);
  903bbc:	187184        	l32r	a8, 8e01cc <_bss_end+0x3d29c4>
struct ath_hal *
_ath_hal_attach_tgt(a_uint32_t devid, HAL_SOFTC sc,
		    adf_os_device_t dev, a_uint32_t flags, void* s)
{
	HAL_STATUS status;
	struct ath_hal *ah = ath_hal_attach_tgt(devid, sc, dev, flags, &status);
  903bbf:	d2a0      	mov.n	a2, a10
	adf_os_print(" ath_hal = %p \n",ah);
  903bc1:	288212        	l32i	a8, a8, 72
  903bc4:	1a71e6        	l32r	a10, 8e035c <_bss_end+0x3d2b54>
  903bc7:	db20      	mov.n	a11, a2
  903bc9:	0b8000        	callx8	a8
	*(HAL_STATUS *)s = status;
  903bcc:	8810      	l32i.n	a8, a1, 0
  903bce:	9860      	s32i.n	a8, a6, 0
	return ah;
}
  903bd0:	d10f      	retw.n
	...

00903bd4 <ath_hal_delay>:
/*
 * Delay n microseconds.
 */
void __ahdecl
ath_hal_delay(a_int32_t n)
{
  903bd4:	6c1004        	entry	a1, 32
}

static inline void
__adf_os_udelay(int usecs)
{
    A_DELAY_USECS(usecs);
  903bd7:	187184        	l32r	a8, 8e01e8 <_bss_end+0x3d29e0>
  903bda:	da20      	mov.n	a10, a2
  903bdc:	28823a        	l32i	a8, a8, 232
  903bdf:	0b8000        	callx8	a8
  903be2:	d10f      	retw.n

00903be4 <ath_hal_malloc>:
/*
 * Allocate/free memory.
 */
void * __ahdecl
ath_hal_malloc(adf_os_size_t size)
{
  903be4:	6c1004        	entry	a1, 32
  903be7:	147184        	l32r	a4, 8e01f8 <_bss_end+0x3d29f0>
  903bea:	d320      	mov.n	a3, a2
  903bec:	224252        	l32i	a2, a4, 0x148
  903bef:	c0a0      	movi.n	a10, 0
  903bf1:	db30      	mov.n	a11, a3
  903bf3:	0b2000        	callx8	a2
  903bf6:	d2a0      	mov.n	a2, a10
	void *p;

	p = adf_os_mem_alloc(size);
	if (p)
  903bf8:	c8a8      	beqz.n	a10, 903c04 <ath_hal_malloc+0x20>
}
/* zero a memory buffer */
static inline void
__adf_os_mem_zero(void *buf, adf_os_size_t size)
{
    A_MEMZERO(buf,size);
  903bfa:	8444      	l32i.n	a4, a4, 16
  903bfc:	c0b0      	movi.n	a11, 0
  903bfe:	033c02        	or	a12, a3, a3
  903c01:	0b4000        	callx8	a4
		adf_os_mem_zero(p, size);

	return p;
}
  903c04:	d10f      	retw.n
	...

00903c08 <ath_hal_free>:

void __ahdecl
ath_hal_free(void* p)
{
  903c08:	6c1004        	entry	a1, 32
  903c0b:	d10f      	retw.n
  903c0d:	000000        	ill

00903c10 <ath_hal_memcpy>:
	adf_os_mem_free(p);
}

void * __ahdecl
ath_hal_memcpy(void *dst, const void *src, adf_os_size_t n)
{
  903c10:	6c1004        	entry	a1, 32
}

/* move a memory buffer */
static inline void 		__adf_os_mem_copy(void *dst, const void *src, adf_os_size_t size)
{
    A_MEMCPY(dst,src,size);    
  903c13:	187184        	l32r	a8, 8e0224 <_bss_end+0x3d2a1c>
  903c16:	da20      	mov.n	a10, a2
  903c18:	8885      	l32i.n	a8, a8, 20
  903c1a:	db30      	mov.n	a11, a3
  903c1c:	dc40      	mov.n	a12, a4
  903c1e:	0b8000        	callx8	a8
	adf_os_mem_copy(dst, src, n);
	return 0;
}
  903c21:	c020      	movi.n	a2, 0
  903c23:	d10f      	retw.n
  903c25:	000000        	ill

00903c28 <wlan_pci_module_init>:
adf_drv_info_t* g_wlan_drv = NULL;
adf_drv_handle_t g_wlan_drv_handle = NULL;
adf_os_drv_intr g_wlan_intr = NULL;

void wlan_pci_module_init(void)
{
  903c28:	6c1004        	entry	a1, 32
	if (g_pci_init_func != NULL) {
  903c2b:	1871e7        	l32r	a8, 8e03c8 <_bss_end+0x3d2bc0>
  903c2e:	8a80      	l32i.n	a10, a8, 0
  903c30:	c8a1      	beqz.n	a10, 903c35 <wlan_pci_module_init+0xd>
		g_pci_init_func();
  903c32:	0ba000        	callx8	a10
  903c35:	d10f      	retw.n
	...

00903c38 <wlan_pci_register_drv>:
	}
}

void wlan_pci_register_drv(adf_drv_info_t *drv)
{
  903c38:	6c1004        	entry	a1, 32
	g_wlan_drv = drv;
  903c3b:	1871e8        	l32r	a8, 8e03dc <_bss_end+0x3d2bd4>
  903c3e:	9280      	s32i.n	a2, a8, 0
  903c40:	d10f      	retw.n
	...

00903c44 <wlan_pci_probe>:

#define ATHEROS_VENDOR_ID 0x168c
#define AR5416_DEVID_PCIE 0x24 	

void wlan_pci_probe(void)
{
  903c44:	6c100a        	entry	a1, 80
	__adf_softc_t           *sc;
	adf_os_resource_t       drv_res = {0};
  903c47:	c0b0      	movi.n	a11, 0
  903c49:	2c0a18        	movi	a12, 24
  903c4c:	011a02        	or	a10, a1, a1
  903c4f:	5b8553        	call8	8e519c <memset>
	adf_os_attach_data_t    drv_data = {{0}};   
  903c52:	c0b0      	movi.n	a11, 0
  903c54:	c1c0      	movi.n	a12, 16
  903c56:	2a1c18        	addi	a10, a1, 24
  903c59:	5b8550        	call8	8e519c <memset>
	int vendor_id;
	int device_id;

	A_PRINTF("<wlan_pci_probe>: Attaching the driver\n");
  903c5c:	127184        	l32r	a2, 8e026c <_bss_end+0x3d2a64>
  903c5f:	1a71e9        	l32r	a10, 8e0404 <_bss_end+0x3d2bfc>
  903c62:	232212        	l32i	a3, a2, 72
  903c65:	0b3000        	callx8	a3
	device_id = AR5416_DEVID_PCIE;
#else    
	vendor_id = wlan_pci_config_read(0, 2);
	device_id = wlan_pci_config_read(2, 2);
#endif    
	A_PRINTF("<wlan_pci_probe>: Vendor id 0x%x Dev id 0x%x\n", vendor_id, device_id);    
  903c68:	1371eb        	l32r	a3, 8e0414 <_bss_end+0x3d2c0c>
  903c6b:	282212        	l32i	a8, a2, 72
  903c6e:	1a71ea        	l32r	a10, 8e0418 <_bss_end+0x3d2c10>
  903c71:	db30      	mov.n	a11, a3
  903c73:	c2c4      	movi.n	a12, 36
  903c75:	0b8000        	callx8	a8
	}
            
	/**
	 * Allocate the sc & zero down
	 */
	sc = A_ALLOCRAM(sizeof(__adf_softc_t));
  903c78:	282252        	l32i	a8, a2, 0x148
  903c7b:	c0a0      	movi.n	a10, 0
  903c7d:	c0b4      	movi.n	a11, 4
  903c7f:	0b8000        	callx8	a8
	if (!sc) {
  903c82:	ccaa      	bnez.n	a10, 903c90 <wlan_pci_probe+0x4c>
		A_PRINTF("Cannot malloc softc\n");
  903c84:	222212        	l32i	a2, a2, 72
  903c87:	1a71ec        	l32r	a10, 8e0438 <_bss_end+0x3d2c30>
  903c8a:	0b2000        	callx8	a2
  903c8d:	d10f      	retw.n
  903c8f:	00c224        	excw
		goto mem_fail;
	}
    
#define AR5416_DEVID_PCIE 0x24 		

	drv_data.pci.device    = AR5416_DEVID_PCIE;
  903c92:	9217      	s32i.n	a2, a1, 28
    
	drv_res.start  = (a_uint32_t) 0;
	drv_res.end    = 0;
	drv_res.type   = ADF_OS_RESOURCE_TYPE_MEM;
        
	g_wlan_drv_handle = g_wlan_drv->drv_attach(&drv_res, 1, &drv_data, NULL);
  903c94:	1271e8        	l32r	a2, 8e0434 <_bss_end+0x3d2c2c>
    
#define AR5416_DEVID_PCIE 0x24 		

	drv_data.pci.device    = AR5416_DEVID_PCIE;
	drv_data.pci.vendor    = 0x168c;
	drv_data.pci.subvendor = 0;
  903c97:	c0d0      	movi.n	a13, 0
    
	drv_res.start  = (a_uint32_t) 0;
	drv_res.end    = 0;
	drv_res.type   = ADF_OS_RESOURCE_TYPE_MEM;
        
	g_wlan_drv_handle = g_wlan_drv->drv_attach(&drv_res, 1, &drv_data, NULL);
  903c99:	8220      	l32i.n	a2, a2, 0
	drv_data.pci.device    = AR5416_DEVID_PCIE;
	drv_data.pci.vendor    = 0x168c;
	drv_data.pci.subvendor = 0;
	drv_data.pci.subdevice = 0;
    
	drv_res.start  = (a_uint32_t) 0;
  903c9b:	1871ed        	l32r	a8, 8e0450 <_bss_end+0x3d2c48>
  903c9e:	1971ed        	l32r	a9, 8e0454 <_bss_end+0x3d2c4c>
	}
    
#define AR5416_DEVID_PCIE 0x24 		

	drv_data.pci.device    = AR5416_DEVID_PCIE;
	drv_data.pci.vendor    = 0x168c;
  903ca1:	9316      	s32i.n	a3, a1, 24
	drv_data.pci.subvendor = 0;
  903ca3:	9d18      	s32i.n	a13, a1, 32
	drv_data.pci.subdevice = 0;
  903ca5:	9d19      	s32i.n	a13, a1, 36
    
	drv_res.start  = (a_uint32_t) 0;
	drv_res.end    = 0;
	drv_res.type   = ADF_OS_RESOURCE_TYPE_MEM;
        
	g_wlan_drv_handle = g_wlan_drv->drv_attach(&drv_res, 1, &drv_data, NULL);
  903ca7:	8220      	l32i.n	a2, a2, 0
	drv_data.pci.device    = AR5416_DEVID_PCIE;
	drv_data.pci.vendor    = 0x168c;
	drv_data.pci.subvendor = 0;
	drv_data.pci.subdevice = 0;
    
	drv_res.start  = (a_uint32_t) 0;
  903ca9:	9810      	s32i.n	a8, a1, 0
  903cab:	9911      	s32i.n	a9, a1, 4
	drv_res.end    = 0;
  903cad:	9812      	s32i.n	a8, a1, 8
  903caf:	9913      	s32i.n	a9, a1, 12
	drv_res.type   = ADF_OS_RESOURCE_TYPE_MEM;
  903cb1:	9d14      	s32i.n	a13, a1, 16
        
	g_wlan_drv_handle = g_wlan_drv->drv_attach(&drv_res, 1, &drv_data, NULL);
  903cb3:	da10      	mov.n	a10, a1
  903cb5:	c0b1      	movi.n	a11, 1
  903cb7:	2c1c18        	addi	a12, a1, 24
  903cba:	0b2000        	callx8	a2
  903cbd:	1271ee        	l32r	a2, 8e0478 <_bss_end+0x3d2c70>
  903cc0:	9a20      	s32i.n	a10, a2, 0
  903cc2:	d10f      	retw.n

00903cc4 <wlan_pci_config_write>:
mem_fail:
	return;        
}

int wlan_pci_config_write(int offset, a_uint32_t val, int width)
{
  903cc4:	6c1004        	entry	a1, 32
		ptr[idx + i] = valptr[3-i];
	}            
#endif
    
	return 0;    
}
  903cc7:	c020      	movi.n	a2, 0
  903cc9:	d10f      	retw.n
	...

00903ccc <wlan_pci_config_read>:

int wlan_pci_config_read(int offset, int width)
{
  903ccc:	6c1004        	entry	a1, 32
		result |= (ptr[ 3 - (idx + i)] << (8*i));
	}            
    
	return result;    
#endif    
}
  903ccf:	c020      	movi.n	a2, 0
  903cd1:	d10f      	retw.n
	...

00903cd4 <wlan_pci_isr>:

void wlan_pci_isr()
{
  903cd4:	6c1004        	entry	a1, 32
	if (g_wlan_intr != NULL && g_wlan_drv_handle != NULL) {
  903cd7:	1871ef        	l32r	a8, 8e0494 <_bss_end+0x3d2c8c>
  903cda:	8880      	l32i.n	a8, a8, 0
  903cdc:	c888      	beqz.n	a8, 903ce8 <wlan_pci_isr+0x14>
  903cde:	1971ee        	l32r	a9, 8e0498 <_bss_end+0x3d2c90>
  903ce1:	8a90      	l32i.n	a10, a9, 0
  903ce3:	c8a1      	beqz.n	a10, 903ce8 <wlan_pci_isr+0x14>
		g_wlan_intr(g_wlan_drv_handle);
  903ce5:	0b8000        	callx8	a8
  903ce8:	d10f      	retw.n
	...

00903cec <_HTC_Shutdown>:
    
	return pHTC;
}

LOCAL void _HTC_Shutdown(htc_handle_t htcHandle)
{
  903cec:	6c1004        	entry	a1, 32
  903cef:	d10f      	retw.n
  903cf1:	000000        	ill

00903cf4 <_HTC_RegisterService>:
    
	adf_os_mem_free(pHTC);
}

LOCAL void _HTC_RegisterService(htc_handle_t htcHandle, HTC_SERVICE *pService)
{
  903cf4:	6c1004        	entry	a1, 32
	HTC_CONTEXT *pHTC = (HTC_CONTEXT *)htcHandle;
    
        /* add it to the list */
	pService->pNext = pHTC->pServiceList;
  903cf7:	282290        	l32i	a8, a2, 0x240
  903cfa:	9830      	s32i.n	a8, a3, 0
	pHTC->pServiceList = pService;
  903cfc:	232690        	s32i	a3, a2, 0x240
  903cff:	d10f      	retw.n
  903d01:	000000        	ill

00903d04 <_HTC_GetReservedHeadroom>:
void _HTC_ResumeRecv(HTC_ENDPOINT_ID EndpointID)
{
}

int _HTC_GetReservedHeadroom(htc_handle_t htcHandle)
{
  903d04:	6c1004        	entry	a1, 32
	HTC_CONTEXT *pHTC = (HTC_CONTEXT *)htcHandle;  
    
	return HTC_HDR_LENGTH + HIF_get_reserved_headroom(pHTC->hifHandle);
  903d07:	187184        	l32r	a8, 8e0318 <_bss_end+0x3d2b10>
  903d0a:	2a229a        	l32i	a10, a2, 0x268
  903d0d:	28827f        	l32i	a8, a8, 0x1fc
  903d10:	0b8000        	callx8	a8
}
  903d13:	b8a2      	addi.n	a2, a10, 8
  903d15:	d10f      	retw.n
	...

00903d18 <HTCSendDoneHandler>:
		HTCCheckAndSendCreditReport(pHTC, HTC_ANY_ENDPOINT_MASK,NULL,ENDPOINT_MAX);
	}  
}

LOCAL void HTCSendDoneHandler(adf_nbuf_t buf, void *context)
{
  903d18:	6c1004        	entry	a1, 32
 * @return data pointer to typecast into your priv structure
 */
static inline a_uint8_t *
adf_nbuf_get_priv(adf_nbuf_t buf)
{
    return (__adf_nbuf_get_priv(buf));
  903d1b:	022a02        	or	a10, a2, a2
  903d1e:	5bfdd3        	call8	90346c <__adf_nbuf_get_priv>
	A_UINT8 current_eid;
	HTC_CONTEXT *pHTC = (HTC_CONTEXT *)context;
	HTC_BUF_CONTEXT *ctx;
      
	ctx = (HTC_BUF_CONTEXT *)adf_nbuf_get_priv(buf);
	current_eid = ctx->end_point;
  903d21:	24a000        	l8ui	a4, a10, 0
 *         or NULL if there is not sufficient data to pull.
 */
static inline a_uint8_t *
adf_nbuf_pull_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_pull_head(buf, size);
  903d24:	c0b8      	movi.n	a11, 8
  903d26:	022a02        	or	a10, a2, a2
  903d29:	5bfdb5        	call8	903400 <__adf_nbuf_pull_head>
	/* Walk through the buffers and fixup the ones we used for HTC headers.
	 * The buffer list may contain more than one string of HTC buffers comprising of an
	 * HTC message so we need to check every buffer */            
	adf_nbuf_pull_head(buf, HTC_HDR_LENGTH);
                   
	pHTC->Endpoints[current_eid].pService->
  903d2c:	044809        	addx2	a8, a4, a4
  903d2f:	03830b        	addx8	a3, a8, a3
  903d32:	8832      	l32i.n	a8, a3, 8
		ProcessSendBufferComplete(current_eid, 
  903d34:	da40      	mov.n	a10, a4
  903d36:	8982      	l32i.n	a9, a8, 8
  903d38:	8c86      	l32i.n	a12, a8, 24
  903d3a:	022b02        	or	a11, a2, a2
  903d3d:	0b9000        	callx8	a9
  903d40:	d10f      	retw.n
	...

00903d44 <HTC_AssembleBuffers>:
	if ((pEndpoint)->ConnectionFlags & HTC_CONNECT_FLAGS_REDUCE_CREDIT_DRIBBLE) { \
		AdjustCreditThreshold((pEndpoint));			\
	}    

LOCAL void HTC_AssembleBuffers(HTC_CONTEXT *pHTC, int Count, int Size)
{
  903d44:	6c1004        	entry	a1, 32
	BUF_Pool_create_pool(pHTC->PoolHandle, POOL_ID_HTC_CONTROL, Count, Size);       
  903d47:	187184        	l32r	a8, 8e0358 <_bss_end+0x3d2b50>
  903d4a:	2a229b        	l32i	a10, a2, 0x26c
  903d4d:	2882a0        	l32i	a8, a8, 0x280
  903d50:	c0b0      	movi.n	a11, 0
  903d52:	dc30      	mov.n	a12, a3
  903d54:	dd40      	mov.n	a13, a4
  903d56:	0b8000        	callx8	a8
  903d59:	d10f      	retw.n
	...

00903d5c <_HTC_Init>:
}

LOCAL htc_handle_t _HTC_Init(HTC_SETUP_COMPLETE_CB SetupComplete,
                             HTC_CONFIG *pConfig)
{
  903d5c:	6c1006        	entry	a1, 48
#include "Magpie_api.h"

static inline void *	__adf_os_mem_alloc(adf_os_size_t size)
{
//    return (malloc(size,M_DEVBUF,M_DONTWAIT | M_ZERO));
    return A_ALLOCRAM(size);
  903d5f:	147184        	l32r	a4, 8e0370 <_bss_end+0x3d2b68>
  903d62:	022502        	or	a5, a2, a2
  903d65:	224252        	l32i	a2, a4, 0x148
  903d68:	2b2a74        	movi	a11, 0x274
  903d6b:	c0a0      	movi.n	a10, 0
  903d6d:	0b2000        	callx8	a2
}
/* zero a memory buffer */
static inline void
__adf_os_mem_zero(void *buf, adf_os_size_t size)
{
    A_MEMZERO(buf,size);
  903d70:	8844      	l32i.n	a8, a4, 16
  903d72:	2c2a74        	movi	a12, 0x274
  903d75:	c0b0      	movi.n	a11, 0
#include "Magpie_api.h"

static inline void *	__adf_os_mem_alloc(adf_os_size_t size)
{
//    return (malloc(size,M_DEVBUF,M_DONTWAIT | M_ZERO));
    return A_ALLOCRAM(size);
  903d77:	d2a0      	mov.n	a2, a10
}
/* zero a memory buffer */
static inline void
__adf_os_mem_zero(void *buf, adf_os_size_t size)
{
    A_MEMZERO(buf,size);
  903d79:	0b8000        	callx8	a8
    
        pHTC = (HTC_CONTEXT *)adf_os_mem_alloc(sizeof(HTC_CONTEXT));
    
	adf_os_mem_zero(pHTC, sizeof(HTC_CONTEXT));

	pHTC->OSHandle = pConfig->OSHandle;
  903d7c:	8832      	l32i.n	a8, a3, 8
	pHTC->PoolHandle = pConfig->PoolHandle;
	pHTC->hifHandle = pConfig->HIFHandle;
  903d7e:	8a33      	l32i.n	a10, a3, 12
    
        pHTC = (HTC_CONTEXT *)adf_os_mem_alloc(sizeof(HTC_CONTEXT));
    
	adf_os_mem_zero(pHTC, sizeof(HTC_CONTEXT));

	pHTC->OSHandle = pConfig->OSHandle;
  903d80:	9820      	s32i.n	a8, a2, 0
	pHTC->PoolHandle = pConfig->PoolHandle;
  903d82:	8834      	l32i.n	a8, a3, 16
	hifCBConfig.send_buf_done = A_INDIR(htc._HTC_SendDoneHandler);
	hifCBConfig.recv_buf = A_INDIR(htc._HTC_MsgRecvHandler);
	hifCBConfig.context = pHTC;
    
	/* initialize hardware layer */
	HIF_register_callback(pConfig->HIFHandle, &hifCBConfig);
  903d84:	db10      	mov.n	a11, a1
        pHTC = (HTC_CONTEXT *)adf_os_mem_alloc(sizeof(HTC_CONTEXT));
    
	adf_os_mem_zero(pHTC, sizeof(HTC_CONTEXT));

	pHTC->OSHandle = pConfig->OSHandle;
	pHTC->PoolHandle = pConfig->PoolHandle;
  903d86:	28269b        	s32i	a8, a2, 0x26c
	pHTC->hifHandle = pConfig->HIFHandle;
                        
	hifCBConfig.send_buf_done = A_INDIR(htc._HTC_SendDoneHandler);
  903d89:	28428c        	l32i	a8, a4, 0x230
    
	adf_os_mem_zero(pHTC, sizeof(HTC_CONTEXT));

	pHTC->OSHandle = pConfig->OSHandle;
	pHTC->PoolHandle = pConfig->PoolHandle;
	pHTC->hifHandle = pConfig->HIFHandle;
  903d8c:	2a269a        	s32i	a10, a2, 0x268
                        
	hifCBConfig.send_buf_done = A_INDIR(htc._HTC_SendDoneHandler);
  903d8f:	9810      	s32i.n	a8, a1, 0
	hifCBConfig.recv_buf = A_INDIR(htc._HTC_MsgRecvHandler);
  903d91:	28428b        	l32i	a8, a4, 0x22c
	hifCBConfig.context = pHTC;
  903d94:	9212      	s32i.n	a2, a1, 8
	pHTC->OSHandle = pConfig->OSHandle;
	pHTC->PoolHandle = pConfig->PoolHandle;
	pHTC->hifHandle = pConfig->HIFHandle;
                        
	hifCBConfig.send_buf_done = A_INDIR(htc._HTC_SendDoneHandler);
	hifCBConfig.recv_buf = A_INDIR(htc._HTC_MsgRecvHandler);
  903d96:	9811      	s32i.n	a8, a1, 4
	hifCBConfig.context = pHTC;
    
	/* initialize hardware layer */
	HIF_register_callback(pConfig->HIFHandle, &hifCBConfig);
  903d98:	284277        	l32i	a8, a4, 0x1dc
  903d9b:	0b8000        	callx8	a8
        /* see if the host wants us to override the number of ctrl buffers */
	pHTC->NumBuffersForCreditRpts = 0;
    
	if (0 == pHTC->NumBuffersForCreditRpts) {
		/* nothing to override, simply set default */
		pHTC->NumBuffersForCreditRpts = HTC_DEFAULT_NUM_CTRL_BUFFERS; 
  903d9e:	c086      	movi.n	a8, 6
  903da0:	282696        	s32i	a8, a2, 0x258
	}    
    
	pHTC->MaxEpPendingCreditRpts = 0;
    
	if (0 == pHTC->MaxEpPendingCreditRpts) {
		pHTC->MaxEpPendingCreditRpts = HTC_DEFAULT_MAX_EP_PENDING_CREDIT_REPORTS;    
  903da3:	c083      	movi.n	a8, 3
  903da5:	282699        	s32i	a8, a2, 0x264
	}
	/* calculate the total allocation size based on the number of credit report buffers */
	pHTC->CtrlBufferAllocSize = MIN_CREDIT_BUFFER_ALLOC_SIZE * pHTC->NumBuffersForCreditRpts;
  903da8:	280ad8        	movi	a8, 216
  903dab:	282697        	s32i	a8, a2, 0x25c
	/* we need at least enough buffer space for 1 ctrl message */
	pHTC->CtrlBufferAllocSize = A_MAX(pHTC->CtrlBufferAllocSize,MAX_HTC_SETUP_MSG_SIZE);
    
	/* save the size of each buffer/credit we will receive */
	pHTC->RecvBufferSize = pConfig->CreditSize; //RecvBufferSize;
  903dae:	8830      	l32i.n	a8, a3, 0
	pHTC->TotalCredits = pConfig->CreditNumber;
  903db0:	8331      	l32i.n	a3, a3, 4
	pHTC->CtrlBufferAllocSize = MIN_CREDIT_BUFFER_ALLOC_SIZE * pHTC->NumBuffersForCreditRpts;
	/* we need at least enough buffer space for 1 ctrl message */
	pHTC->CtrlBufferAllocSize = A_MAX(pHTC->CtrlBufferAllocSize,MAX_HTC_SETUP_MSG_SIZE);
    
	/* save the size of each buffer/credit we will receive */
	pHTC->RecvBufferSize = pConfig->CreditSize; //RecvBufferSize;
  903db2:	282691        	s32i	a8, a2, 0x244
	pHTC->TotalCredits = pConfig->CreditNumber;
  903db5:	232694        	s32i	a3, a2, 0x250
	pHTC->TotalCreditsAssigned = 0;
  903db8:	c030      	movi.n	a3, 0
  903dba:	232695        	s32i	a3, a2, 0x254
     
	/* setup the pseudo service that handles HTC control messages */
	pHTC->HTCControlService.ProcessRecvMsg = A_INDIR(htc._HTC_ControlSvcProcessMsg);
  903dbd:	23428d        	l32i	a3, a4, 0x234
	pHTC->HTCControlService.ProcessSendBufferComplete = A_INDIR(htc._HTC_ControlSvcProcessSendComplete);
	pHTC->HTCControlService.TrailerSpcCheckLimit = HTC_CTRL_BUFFER_CHECK_SIZE;
  903dc0:	c18c      	movi.n	a8, 28
	pHTC->RecvBufferSize = pConfig->CreditSize; //RecvBufferSize;
	pHTC->TotalCredits = pConfig->CreditNumber;
	pHTC->TotalCreditsAssigned = 0;
     
	/* setup the pseudo service that handles HTC control messages */
	pHTC->HTCControlService.ProcessRecvMsg = A_INDIR(htc._HTC_ControlSvcProcessMsg);
  903dc2:	23268a        	s32i	a3, a2, 0x228
	pHTC->HTCControlService.ProcessSendBufferComplete = A_INDIR(htc._HTC_ControlSvcProcessSendComplete);
  903dc5:	23428e        	l32i	a3, a4, 0x238
	pHTC->HTCControlService.MaxSvcMsgSize = MAX_HTC_SETUP_MSG_SIZE;
	pHTC->HTCControlService.ServiceCtx = pHTC;
    
	/* automatically register this pseudo service to endpoint 1 */
	pHTC->Endpoints[ENDPOINT0].pService = &pHTC->HTCControlService;
	HIF_get_default_pipe(pHTC->hifHandle, &pHTC->Endpoints[ENDPOINT0].UpLinkPipeID, 
  903dc8:	2a229a        	l32i	a10, a2, 0x268
	pHTC->TotalCredits = pConfig->CreditNumber;
	pHTC->TotalCreditsAssigned = 0;
     
	/* setup the pseudo service that handles HTC control messages */
	pHTC->HTCControlService.ProcessRecvMsg = A_INDIR(htc._HTC_ControlSvcProcessMsg);
	pHTC->HTCControlService.ProcessSendBufferComplete = A_INDIR(htc._HTC_ControlSvcProcessSendComplete);
  903dcb:	23268b        	s32i	a3, a2, 0x22c
	pHTC->HTCControlService.TrailerSpcCheckLimit = HTC_CTRL_BUFFER_CHECK_SIZE;
  903dce:	232d02        	addmi	a3, a2, 0x200
  903dd1:	28351d        	s16i	a8, a3, 58
	pHTC->HTCControlService.MaxSvcMsgSize = MAX_HTC_SETUP_MSG_SIZE;
  903dd4:	c480      	movi.n	a8, 64
  903dd6:	28351c        	s16i	a8, a3, 56
	pHTC->HTCControlService.ServiceCtx = pHTC;
    
	/* automatically register this pseudo service to endpoint 1 */
	pHTC->Endpoints[ENDPOINT0].pService = &pHTC->HTCControlService;
  903dd9:	232a24        	movi	a3, 0x224
  903ddc:	032308        	add	a3, a2, a3
  903ddf:	9322      	s32i.n	a3, a2, 8
	HIF_get_default_pipe(pHTC->hifHandle, &pHTC->Endpoints[ENDPOINT0].UpLinkPipeID, 
  903de1:	234281        	l32i	a3, a4, 0x204
  903de4:	2b2c19        	addi	a11, a2, 25
  903de7:	2c2c18        	addi	a12, a2, 24
	/* setup the pseudo service that handles HTC control messages */
	pHTC->HTCControlService.ProcessRecvMsg = A_INDIR(htc._HTC_ControlSvcProcessMsg);
	pHTC->HTCControlService.ProcessSendBufferComplete = A_INDIR(htc._HTC_ControlSvcProcessSendComplete);
	pHTC->HTCControlService.TrailerSpcCheckLimit = HTC_CTRL_BUFFER_CHECK_SIZE;
	pHTC->HTCControlService.MaxSvcMsgSize = MAX_HTC_SETUP_MSG_SIZE;
	pHTC->HTCControlService.ServiceCtx = pHTC;
  903dea:	22268f        	s32i	a2, a2, 0x23c
    
	/* automatically register this pseudo service to endpoint 1 */
	pHTC->Endpoints[ENDPOINT0].pService = &pHTC->HTCControlService;
	HIF_get_default_pipe(pHTC->hifHandle, &pHTC->Endpoints[ENDPOINT0].UpLinkPipeID, 
  903ded:	0b3000        	callx8	a3
			     &pHTC->Endpoints[ENDPOINT0].DownLinkPipeID);
    
	/* Initialize control pipe so we could receive the HTC control packets */
	// @TODO: msg size!
	HIF_config_pipe(pHTC->hifHandle, pHTC->Endpoints[ENDPOINT0].UpLinkPipeID, 1);    
  903df0:	2a229a        	l32i	a10, a2, 0x268
  903df3:	23427a        	l32i	a3, a4, 0x1e8
  903df6:	2b2019        	l8ui	a11, a2, 25
  903df9:	c0c1      	movi.n	a12, 1
  903dfb:	0b3000        	callx8	a3
    
	/* set the first free endpoint */
	pHTC->CurrentEpIndex = ENDPOINT1;
  903dfe:	c031      	movi.n	a3, 1
  903e00:	232688        	s32i	a3, a2, 0x220
	pHTC->SetupCompleteCb = SetupComplete;
    
        /* setup buffers for just the setup phase, we only need 1 buffer to handle
	 * setup */
	HTC_AssembleBuffers(pHTC, 4, MAX_HTC_SETUP_MSG_SIZE);
  903e03:	da20      	mov.n	a10, a2
	// @TODO: msg size!
	HIF_config_pipe(pHTC->hifHandle, pHTC->Endpoints[ENDPOINT0].UpLinkPipeID, 1);    
    
	/* set the first free endpoint */
	pHTC->CurrentEpIndex = ENDPOINT1;
	pHTC->SetupCompleteCb = SetupComplete;
  903e05:	252693        	s32i	a5, a2, 0x24c
    
        /* setup buffers for just the setup phase, we only need 1 buffer to handle
	 * setup */
	HTC_AssembleBuffers(pHTC, 4, MAX_HTC_SETUP_MSG_SIZE);
  903e08:	c0b4      	movi.n	a11, 4
  903e0a:	2c0a40        	movi	a12, 64
  903e0d:	5bffcd        	call8	903d44 <HTC_AssembleBuffers>
   
	/* start hardware layer so that we can queue buffers */
	HIF_start(pHTC->hifHandle);
  903e10:	2a229a        	l32i	a10, a2, 0x268
  903e13:	234279        	l32i	a3, a4, 0x1e4
  903e16:	0b3000        	callx8	a3
    
	return pHTC;
}
  903e19:	d10f      	retw.n
	...

00903e1c <_HTC_PauseRecv>:
	pHTCHdr->PayloadLen = adf_os_htons(totsz);  
	HIF_send_buffer(pHTC->hifHandle, pHTC->Endpoints[EndpointID].DownLinkPipeID, pBuffers);       
}

void _HTC_PauseRecv(HTC_ENDPOINT_ID EndpointID)
{
  903e1c:	6c1004        	entry	a1, 32
  903e1f:	d10f      	retw.n
  903e21:	000000        	ill

00903e24 <_HTC_ResumeRecv>:
}

void _HTC_ResumeRecv(HTC_ENDPOINT_ID EndpointID)
{
  903e24:	6c1004        	entry	a1, 32
  903e27:	d10f      	retw.n
  903e29:	000000        	ill

00903e2c <htc_module_install>:
    
	return HTC_HDR_LENGTH + HIF_get_reserved_headroom(pHTC->hifHandle);
}

void htc_module_install(struct htc_apis *pAPIs)
{   
  903e2c:	6c1004        	entry	a1, 32
	pAPIs->_HTC_Init = _HTC_Init;
  903e2f:	1871f0        	l32r	a8, 8e05f0 <_bss_end+0x3d2de8>
  903e32:	9820      	s32i.n	a8, a2, 0
	pAPIs->_HTC_ReturnBuffers = _HTC_ReturnBuffers;
  903e34:	1871f1        	l32r	a8, 8e05f8 <_bss_end+0x3d2df0>
  903e37:	9824      	s32i.n	a8, a2, 16
	pAPIs->_HTC_ReturnBuffersList = _HTC_ReturnBuffersList;
  903e39:	1871f2        	l32r	a8, 8e0604 <_bss_end+0x3d2dfc>
  903e3c:	9825      	s32i.n	a8, a2, 20
	pAPIs->_HTC_Ready = _HTC_Ready;
  903e3e:	1871f3        	l32r	a8, 8e060c <_bss_end+0x3d2e04>
  903e41:	9823      	s32i.n	a8, a2, 12
	pAPIs->_HTC_RegisterService = _HTC_RegisterService;
  903e43:	1871f4        	l32r	a8, 8e0614 <_bss_end+0x3d2e0c>
  903e46:	9822      	s32i.n	a8, a2, 8
	pAPIs->_HTC_SendMsg = _HTC_SendMsg;   
  903e48:	1871f5        	l32r	a8, 8e061c <_bss_end+0x3d2e14>
  903e4b:	9826      	s32i.n	a8, a2, 24
	pAPIs->_HTC_Shutdown = _HTC_Shutdown;
  903e4d:	1871f6        	l32r	a8, 8e0628 <_bss_end+0x3d2e20>
  903e50:	9821      	s32i.n	a8, a2, 4
	pAPIs->_HTC_GetReservedHeadroom = _HTC_GetReservedHeadroom;
  903e52:	1871f7        	l32r	a8, 8e0630 <_bss_end+0x3d2e28>
  903e55:	9827      	s32i.n	a8, a2, 28
	pAPIs->_HTC_MsgRecvHandler = HTCMsgRecvHandler;
  903e57:	1871f8        	l32r	a8, 8e0638 <_bss_end+0x3d2e30>
  903e5a:	9828      	s32i.n	a8, a2, 32
	pAPIs->_HTC_SendDoneHandler = HTCSendDoneHandler;
  903e5c:	1871f9        	l32r	a8, 8e0640 <_bss_end+0x3d2e38>
  903e5f:	9829      	s32i.n	a8, a2, 36
	pAPIs->_HTC_ControlSvcProcessMsg = HTCControlSvcProcessMsg;
  903e61:	1871fa        	l32r	a8, 8e064c <_bss_end+0x3d2e44>
  903e64:	982a      	s32i.n	a8, a2, 40
	pAPIs->_HTC_ControlSvcProcessSendComplete = HTCControlSvcProcessSendComplete;
  903e66:	1871fb        	l32r	a8, 8e0654 <_bss_end+0x3d2e4c>
  903e69:	982b      	s32i.n	a8, a2, 44
  903e6b:	d10f      	retw.n
  903e6d:	000000        	ill

00903e70 <HTCFreeMsgBuffer>:
}

/* free message to the free list */
LOCAL void HTCFreeMsgBuffer(HTC_CONTEXT *pHTC, adf_nbuf_t buf) 
{
  903e70:	6c1004        	entry	a1, 32
	BUF_Pool_free_buf(pHTC->PoolHandle, POOL_ID_HTC_CONTROL, buf);      
  903e73:	187184        	l32r	a8, 8e0484 <_bss_end+0x3d2c7c>
  903e76:	2a229b        	l32i	a10, a2, 0x26c
  903e79:	2882a3        	l32i	a8, a8, 0x28c
  903e7c:	c0b0      	movi.n	a11, 0
  903e7e:	033c02        	or	a12, a3, a3
  903e81:	0b8000        	callx8	a8
  903e84:	d10f      	retw.n
	...

00903e88 <HTCAllocMsgBuffer>:
}

/* HTC control message allocator (also used for empty frames to send trailer options) */
LOCAL adf_nbuf_t HTCAllocMsgBuffer(HTC_CONTEXT *pHTC)
{
  903e88:	6c1004        	entry	a1, 32
	return BUF_Pool_alloc_buf(pHTC->PoolHandle,
  903e8b:	187184        	l32r	a8, 8e049c <_bss_end+0x3d2c94>
  903e8e:	24229b        	l32i	a4, a2, 0x26c
  903e91:	2382a1        	l32i	a3, a8, 0x284
  903e94:	28828a        	l32i	a8, a8, 0x228
  903e97:	da20      	mov.n	a10, a2
  903e99:	0b8000        	callx8	a8
  903e9c:	dca0      	mov.n	a12, a10
  903e9e:	c0b0      	movi.n	a11, 0
  903ea0:	da40      	mov.n	a10, a4
  903ea2:	0b3000        	callx8	a3
				  POOL_ID_HTC_CONTROL,
				  HTC_GetReservedHeadroom(pHTC));   
}
  903ea5:	d2a0      	mov.n	a2, a10
  903ea7:	d10f      	retw.n
  903ea9:	000000        	ill

00903eac <_HTC_Ready>:
	pService->pNext = pHTC->pServiceList;
	pHTC->pServiceList = pService;
}

LOCAL void _HTC_Ready(htc_handle_t htcHandle)
{
  903eac:	6c1004        	entry	a1, 32
	adf_nbuf_t pBuffer;
	HTC_READY_MSG *pReady;
	a_uint8_t *addr;
	HTC_CONTEXT *pHTC = (HTC_CONTEXT *)htcHandle;
    
	pBuffer = HTCAllocMsgBuffer(pHTC);
  903eaf:	022a02        	or	a10, a2, a2
  903eb2:	5bfff5        	call8	903e88 <HTCAllocMsgBuffer>
 *         put, or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_put_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_put_tail(buf, size);
  903eb5:	c0b8      	movi.n	a11, 8
  903eb7:	d4a0      	mov.n	a4, a10
  903eb9:	5bfddd        	call8	903630 <__adf_nbuf_put_tail>
	/* an optimization... the header length is chosen to
	 * be aligned on a 16 bit bounday, the fields in the message are designed to
	 * be aligned */
	addr = adf_nbuf_put_tail(pBuffer, sizeof(HTC_READY_MSG));       
	pReady = (HTC_READY_MSG *)addr;     
	A_MEMZERO(pReady,sizeof(HTC_READY_MSG));  
  903ebc:	157184        	l32r	a5, 8e04cc <_bss_end+0x3d2cc4>
  903ebf:	c0b0      	movi.n	a11, 0
  903ec1:	8854      	l32i.n	a8, a5, 16
  903ec3:	c0c8      	movi.n	a12, 8
  903ec5:	d3a0      	mov.n	a3, a10
  903ec7:	0b8000        	callx8	a8
	pReady->MessageID = adf_os_htons(HTC_MSG_READY_ID);
  903eca:	c0b0      	movi.n	a11, 0
  903ecc:	c081      	movi.n	a8, 1
  903ece:	2b3400        	s8i	a11, a3, 0
  903ed1:	283401        	s8i	a8, a3, 1
	pReady->CreditSize = adf_os_htons((A_UINT16)pHTC->RecvBufferSize);
  903ed4:	282291        	l32i	a8, a2, 0x244
	pReady->CreditCount = adf_os_htons((A_UINT16)pHTC->TotalCredits);
	pReady->MaxEndpoints = ENDPOINT_MAX;
       
	/* send out the message */
	HTC_SendMsg(pHTC, ENDPOINT0, pBuffer);
  903ed7:	da20      	mov.n	a10, a2
	 * be aligned */
	addr = adf_nbuf_put_tail(pBuffer, sizeof(HTC_READY_MSG));       
	pReady = (HTC_READY_MSG *)addr;     
	A_MEMZERO(pReady,sizeof(HTC_READY_MSG));  
	pReady->MessageID = adf_os_htons(HTC_MSG_READY_ID);
	pReady->CreditSize = adf_os_htons((A_UINT16)pHTC->RecvBufferSize);
  903ed9:	08084f        	extui	a8, a8, 0, 16
  903edc:	088914        	srli	a9, a8, 8
  903edf:	293404        	s8i	a9, a3, 4
  903ee2:	283405        	s8i	a8, a3, 5
	pReady->CreditCount = adf_os_htons((A_UINT16)pHTC->TotalCredits);
  903ee5:	282294        	l32i	a8, a2, 0x250
	pReady->MaxEndpoints = ENDPOINT_MAX;
       
	/* send out the message */
	HTC_SendMsg(pHTC, ENDPOINT0, pBuffer);
  903ee8:	dc40      	mov.n	a12, a4
	addr = adf_nbuf_put_tail(pBuffer, sizeof(HTC_READY_MSG));       
	pReady = (HTC_READY_MSG *)addr;     
	A_MEMZERO(pReady,sizeof(HTC_READY_MSG));  
	pReady->MessageID = adf_os_htons(HTC_MSG_READY_ID);
	pReady->CreditSize = adf_os_htons((A_UINT16)pHTC->RecvBufferSize);
	pReady->CreditCount = adf_os_htons((A_UINT16)pHTC->TotalCredits);
  903eea:	08084f        	extui	a8, a8, 0, 16
  903eed:	088914        	srli	a9, a8, 8
  903ef0:	283403        	s8i	a8, a3, 3
	pReady->MaxEndpoints = ENDPOINT_MAX;
  903ef3:	c186      	movi.n	a8, 22
	addr = adf_nbuf_put_tail(pBuffer, sizeof(HTC_READY_MSG));       
	pReady = (HTC_READY_MSG *)addr;     
	A_MEMZERO(pReady,sizeof(HTC_READY_MSG));  
	pReady->MessageID = adf_os_htons(HTC_MSG_READY_ID);
	pReady->CreditSize = adf_os_htons((A_UINT16)pHTC->RecvBufferSize);
	pReady->CreditCount = adf_os_htons((A_UINT16)pHTC->TotalCredits);
  903ef5:	293402        	s8i	a9, a3, 2
	pReady->MaxEndpoints = ENDPOINT_MAX;
  903ef8:	283406        	s8i	a8, a3, 6
       
	/* send out the message */
	HTC_SendMsg(pHTC, ENDPOINT0, pBuffer);
  903efb:	235289        	l32i	a3, a5, 0x224
  903efe:	0b3000        	callx8	a3
  903f01:	d10f      	retw.n
	...

00903f04 <HTCCheckAndSendCreditReport>:
				  HTC_GetReservedHeadroom(pHTC));   
}

LOCAL void HTCCheckAndSendCreditReport(HTC_CONTEXT *pHTC, A_UINT32 EpMask,
				       HTC_ENDPOINT *pEndpoint, HTC_ENDPOINT_ID Eid)
{
  903f04:	6c1004        	entry	a1, 32
	adf_nbuf_t pCredBuffer;
	HTC_BUF_CONTEXT *ctx;    
        
	do {
		/* check if host needs credits */
		if (!(pHTC->EpHostNeedsCreditMap & EpMask)) {
  903f07:	282285        	l32i	a8, a2, 0x214
  903f0a:	78305a        	bnone	a3, a8, 903f68 <HTCCheckAndSendCreditReport+0x64>
			/* host does not need any credits for this set */
			break;    
		}
		/* check if any are pending */
		if (!(pHTC->EpCreditPendingMap & EpMask)) {
  903f0d:	282286        	l32i	a8, a2, 0x218
  903f10:	783054        	bnone	a3, a8, 903f68 <HTCCheckAndSendCreditReport+0x64>
			/* nothing to send up */
			break;    
		}  
		/* was an endpoint specified? */
		if (pEndpoint != NULL) {
  903f13:	c945      	beqz.n	a4, 903f2c <HTCCheckAndSendCreditReport+0x28>
			/* see if a threshold is in effect for this endpoint */
			if (pEndpoint->CreditReturnThreshhold != 0) {
  903f15:	234904        	l16si	a3, a4, 8
  903f18:	c834      	beqz.n	a3, 903f20 <HTCCheckAndSendCreditReport+0x1c>
				if (pEndpoint->CreditsToReturn < pEndpoint->CreditReturnThreshhold) {
  903f1a:	284900        	l16si	a8, a4, 0
  903f1d:	738247        	blt	a8, a3, 903f68 <HTCCheckAndSendCreditReport+0x64>
					 * back to the host */
					break;
				}
			}
         
			if (pEndpoint->PendingCreditReports >= pHTC->MaxEpPendingCreditRpts) {
  903f20:	8844      	l32i.n	a8, a4, 16
  903f22:	232299        	l32i	a3, a2, 0x264
  903f25:	738203        	blt	a8, a3, 903f2c <HTCCheckAndSendCreditReport+0x28>
  903f28:	600009        	j	903f35 <HTCCheckAndSendCreditReport+0x31>
  903f2b:	00da20        	excw
		}
        
		/* if we get here we have some credits to send up */
                        
		/* allocate a message buffer for the trailer */
		pCredBuffer = HTCAllocMsgBuffer(pHTC);
  903f2e:	5bffd6        	call8	903e88 <HTCAllocMsgBuffer>
  903f31:	d3a0      	mov.n	a3, a10
		if (NULL == pCredBuffer) {
  903f33:	ccae      	bnez.n	a10, 903f45 <HTCCheckAndSendCreditReport+0x41>
			/* no buffers left to send an empty message with trailers, host will just
			 * have to wait until we get our endpoint 0 messages back.. */
			/* mark that we need to send an update as soon as we can get a buffer back */
			pHTC->StateFlags |= HTC_SEND_CREDIT_UPDATE_SOON;
  903f35:	242292        	l32i	a4, a2, 0x248
  903f38:	c032      	movi.n	a3, 2
  903f3a:	034302        	or	a3, a4, a3
  903f3d:	232692        	s32i	a3, a2, 0x248
  903f40:	d10f      	retw.n
  903f42:	000000        	ill
 * @return data pointer to typecast into your priv structure
 */
static inline a_uint8_t *
adf_nbuf_get_priv(adf_nbuf_t buf)
{
    return (__adf_nbuf_get_priv(buf));
  903f45:	5bfd49        	call8	90346c <__adf_nbuf_get_priv>
			break;    
		}
        
		ctx = (HTC_BUF_CONTEXT *)adf_nbuf_get_priv(pCredBuffer);
		if (pEndpoint != NULL) {
  903f48:	c84d      	beqz.n	a4, 903f59 <HTCCheckAndSendCreditReport+0x55>
			/* keep track of pending reports */
			pEndpoint->PendingCreditReports++; 
  903f4a:	8844      	l32i.n	a8, a4, 16
  903f4c:	b188      	addi.n	a8, a8, 1
  903f4e:	9844      	s32i.n	a8, a4, 16
			/* save the endpoint in order to decrement the count when the send completes */
			ctx->htc_flags = Eid | HTC_FLAGS_CREDIT_RPT;
  903f50:	240a20        	movi	a4, 32
  903f53:	045502        	or	a5, a5, a4
  903f56:	25a401        	s8i	a5, a10, 1
		}   
            
		/* this is an empty message, the HTC_SendMsg will tack on a trailer in the remaining
		 * space, NOTE: no need to flush the cache, the header and trailers are assembled
		 * using uncached addresses */
		HTC_SendMsg(pHTC, ENDPOINT0, pCredBuffer);    
  903f59:	147184        	l32r	a4, 8e056c <_bss_end+0x3d2d64>
  903f5c:	da20      	mov.n	a10, a2
  903f5e:	244289        	l32i	a4, a4, 0x224
  903f61:	c0b0      	movi.n	a11, 0
  903f63:	dc30      	mov.n	a12, a3
  903f65:	0b4000        	callx8	a4
  903f68:	d10f      	retw.n
	...

00903f6c <HTCControlSvcProcessSendComplete>:
}

/* callback when endpoint 0 send buffers are completed */
LOCAL void HTCControlSvcProcessSendComplete(HTC_ENDPOINT_ID EndpointID,
					    adf_nbuf_t pBuffers, void *arg)
{
  903f6c:	6c1004        	entry	a1, 32
  903f6f:	da30      	mov.n	a10, a3
  903f71:	5bfd3e        	call8	90346c <__adf_nbuf_get_priv>
	HTC_ENDPOINT_ID creditRptEndpoint;
    
	ctx = (HTC_BUF_CONTEXT *)adf_nbuf_get_priv(pBuffers);       
    
	/* put them back into the pool */
	if ( ctx->htc_flags & HTC_FLAGS_CREDIT_RPT ) {   
  903f74:	28a001        	l8ui	a8, a10, 1
  903f77:	7a870e        	bbci	a8, 26, 903f89 <HTCControlSvcProcessSendComplete+0x1d>
		/* extract the endpoint number that requested this credit report */ 
		creditRptEndpoint = ctx->htc_flags & HTC_FLAGS_CRPT_EP_MASK;    
  903f7a:	080844        	extui	a8, a8, 0, 5
		pHTC->Endpoints[creditRptEndpoint].PendingCreditReports--;  
  903f7d:	088809        	addx2	a8, a8, a8
  903f80:	04880b        	addx8	a8, a8, a4
  903f83:	8985      	l32i.n	a9, a8, 20
  903f85:	b099      	addi.n	a9, a9, -1
  903f87:	9985      	s32i.n	a9, a8, 20
	}
    
	HTCFreeMsgBuffer(pHTC, pBuffers);
  903f89:	db30      	mov.n	a11, a3
  903f8b:	da40      	mov.n	a10, a4
  903f8d:	5bffb8        	call8	903e70 <HTCFreeMsgBuffer>
   
	if (pHTC->StateFlags & HTC_SEND_CREDIT_UPDATE_SOON) {
  903f90:	234292        	l32i	a3, a4, 0x248
  903f93:	7e3712        	bbci	a3, 30, 903fa9 <HTCControlSvcProcessSendComplete+0x3d>
		/* this flag is set when the host could not send a credit report
		 * because we ran out of HTC control buffers */
		pHTC->StateFlags &= ~HTC_SEND_CREDIT_UPDATE_SOON;
  903f96:	c78d      	movi.n	a8, -3
  903f98:	083301        	and	a3, a3, a8
  903f9b:	234692        	s32i	a3, a4, 0x248
		/* send out a report if anything is pending */
		HTCCheckAndSendCreditReport(pHTC, HTC_ANY_ENDPOINT_MASK,NULL,ENDPOINT_MAX);
  903f9e:	da40      	mov.n	a10, a4
  903fa0:	c7bf      	movi.n	a11, -1
  903fa2:	c0c0      	movi.n	a12, 0
  903fa4:	c1d6      	movi.n	a13, 22
  903fa6:	5bffd7        	call8	903f04 <HTCCheckAndSendCreditReport>
  903fa9:	d10f      	retw.n
	...

00903fac <ReturnBuffers>:
	/* now we need to wait for service connection requests */
}

LOCAL void ReturnBuffers(htc_handle_t htcHandle, HTC_ENDPOINT_ID EndpointID,
			 adf_nbuf_t pBuffers, A_BOOL sendCreditFlag)
{   
  903fac:	6c1004        	entry	a1, 32
 *         or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_push_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_push_head(buf, size);
  903faf:	044a02        	or	a10, a4, a4
  903fb2:	2b0a08        	movi	a11, 8
  903fb5:	5bfd07        	call8	9033d4 <__adf_nbuf_push_head>
    
	/* supply some head-room again */
	adf_nbuf_push_head(pBuffers, HTC_HDR_LENGTH);
              
	/* enqueue all buffers to the single mailbox */
	HIF_return_recv_buf(pHTC->hifHandle, pHTC->Endpoints[EndpointID].UpLinkPipeID, pBuffers);    
  903fb8:	187184        	l32r	a8, 8e05c8 <_bss_end+0x3d2dc0>
  903fbb:	033609        	addx2	a6, a3, a3
  903fbe:	02660b        	addx8	a6, a6, a2
  903fc1:	28827c        	l32i	a8, a8, 0x1f0
  903fc4:	2a229a        	l32i	a10, a2, 0x268
  903fc7:	2b6019        	l8ui	a11, a6, 25
  903fca:	044c02        	or	a12, a4, a4
  903fcd:	0b8000        	callx8	a8
     
	if (pHTC->StateFlags & HTC_STATE_SETUP_COMPLETE) {       
  903fd0:	242292        	l32i	a4, a2, 0x248
  903fd3:	7f472d        	bbci	a4, 31, 904004 <ReturnBuffers+0x58>
		A_UINT32    epCreditMask = (1 << EndpointID);
		/* we are running normally */
		/* update pending credit counts with the number of buffers that were added */
		pHTC->Endpoints[EndpointID].CreditsToReturn += (A_INT16)nbufs;
  903fd6:	246102        	l16ui	a4, a6, 4
              
	/* enqueue all buffers to the single mailbox */
	HIF_return_recv_buf(pHTC->hifHandle, pHTC->Endpoints[EndpointID].UpLinkPipeID, pBuffers);    
     
	if (pHTC->StateFlags & HTC_STATE_SETUP_COMPLETE) {       
		A_UINT32    epCreditMask = (1 << EndpointID);
  903fd9:	c0b1      	movi.n	a11, 1
		/* we are running normally */
		/* update pending credit counts with the number of buffers that were added */
		pHTC->Endpoints[EndpointID].CreditsToReturn += (A_INT16)nbufs;
  903fdb:	b144      	addi.n	a4, a4, 1
  903fdd:	246502        	s16i	a4, a6, 4
		pHTC->Endpoints[EndpointID].CreditsConsumed -= (A_INT16)nbufs;  
  903fe0:	246107        	l16ui	a4, a6, 14
              
	/* enqueue all buffers to the single mailbox */
	HIF_return_recv_buf(pHTC->hifHandle, pHTC->Endpoints[EndpointID].UpLinkPipeID, pBuffers);    
     
	if (pHTC->StateFlags & HTC_STATE_SETUP_COMPLETE) {       
		A_UINT32    epCreditMask = (1 << EndpointID);
  903fe3:	003104        	ssl	a3
  903fe6:	00bb1a        	sll	a11, a11
		/* we are running normally */
		/* update pending credit counts with the number of buffers that were added */
		pHTC->Endpoints[EndpointID].CreditsToReturn += (A_INT16)nbufs;
		pHTC->Endpoints[EndpointID].CreditsConsumed -= (A_INT16)nbufs;  
  903fe9:	b044      	addi.n	a4, a4, -1
  903feb:	246507        	s16i	a4, a6, 14
		/* update bit map that this endpoint has non-zero credits */
		pHTC->EpCreditPendingMap |= epCreditMask; 
  903fee:	242286        	l32i	a4, a2, 0x218
  903ff1:	0b4402        	or	a4, a4, a11
  903ff4:	242686        	s32i	a4, a2, 0x218

		if (sendCreditFlag) {
  903ff7:	c951      	beqz.n	a5, 90400c <ReturnBuffers+0x60>
			HTCCheckAndSendCreditReport(pHTC, epCreditMask,&pHTC->Endpoints[EndpointID],EndpointID);
  903ff9:	da20      	mov.n	a10, a2
  903ffb:	b46c      	addi.n	a12, a6, 4
  903ffd:	dd30      	mov.n	a13, a3
  903fff:	5bffc1        	call8	903f04 <HTCCheckAndSendCreditReport>
  904002:	d10f      	retw.n
	} else {
		/* we have not started yet so all return operations are simply adding buffers
		 * to the interface at startup, so we can keep track of how many total 
		 * credits we get */
		/* update global count that will be returned to the host */
		pHTC->TotalCredits += nbufs;
  904004:	232294        	l32i	a3, a2, 0x250
  904007:	b133      	addi.n	a3, a3, 1
  904009:	232694        	s32i	a3, a2, 0x250
  90400c:	d10f      	retw.n
	...

00904010 <_HTC_ReturnBuffers>:
	HTCCheckAndSendCreditReport(pHTC, (1 << EndpointID),&pHTC->Endpoints[EndpointID],EndpointID);
}

LOCAL void _HTC_ReturnBuffers(htc_handle_t htcHandle, HTC_ENDPOINT_ID EndpointID,
			      adf_nbuf_t pBuffers)
{
  904010:	6c1004        	entry	a1, 32
	ReturnBuffers(htcHandle, EndpointID, pBuffers, TRUE);
  904013:	da20      	mov.n	a10, a2
  904015:	db30      	mov.n	a11, a3
  904017:	dc40      	mov.n	a12, a4
  904019:	c0d1      	movi.n	a13, 1
  90401b:	5bffe4        	call8	903fac <ReturnBuffers>
  90401e:	d10f      	retw.n

00904020 <_HTC_ReturnBuffersList>:
}

LOCAL void _HTC_ReturnBuffersList(htc_handle_t htcHandle,
				  HTC_ENDPOINT_ID EndpointID,
				  adf_nbuf_queue_t bufHead)
{
  904020:	6c1006        	entry	a1, 48
 * @return first buffer in queue
 */
static inline adf_nbuf_t 
adf_nbuf_queue_first(adf_nbuf_queue_t *head)
{
    return (__adf_nbuf_queue_first(head));
  904023:	da10      	mov.n	a10, a1
  904025:	9410      	s32i.n	a4, a1, 0
  904027:	9511      	s32i.n	a5, a1, 4
  904029:	9612      	s32i.n	a6, a1, 8
  90402b:	5bfda9        	call8	9036d0 <__adf_nbuf_queue_first>
  90402e:	d4a0      	mov.n	a4, a10
	adf_nbuf_t netbuf, tmpNbuf;

	/* retrieve each nbuf in the queue */
	netbuf = adf_nbuf_queue_first(&bufHead);

	while (netbuf) {
  904030:	600014        	j	904048 <_HTC_ReturnBuffersList+0x28>
  904033:	00da40        	extui	a10, a0, 13, 1
 * @return next buffer/packet
 */
static inline adf_nbuf_t
adf_nbuf_queue_next(adf_nbuf_t buf)
{
    return (__adf_nbuf_queue_next(buf));
  904036:	5bfda8        	call8	9036d8 <__adf_nbuf_queue_next>
  904039:	d5a0      	mov.n	a5, a10

		tmpNbuf = netbuf;
		netbuf = adf_nbuf_queue_next(netbuf);

		ReturnBuffers(htcHandle, EndpointID, tmpNbuf, FALSE);
  90403b:	dc40      	mov.n	a12, a4
  90403d:	da20      	mov.n	a10, a2
  90403f:	db30      	mov.n	a11, a3
  904041:	c0d0      	movi.n	a13, 0
  904043:	5bffda        	call8	903fac <ReturnBuffers>
	netbuf = adf_nbuf_queue_first(&bufHead);

	while (netbuf) {

		tmpNbuf = netbuf;
		netbuf = adf_nbuf_queue_next(netbuf);
  904046:	d450      	mov.n	a4, a5
	adf_nbuf_t netbuf, tmpNbuf;

	/* retrieve each nbuf in the queue */
	netbuf = adf_nbuf_queue_first(&bufHead);

	while (netbuf) {
  904048:	654fe8        	bnez	a4, 904034 <_HTC_ReturnBuffersList+0x14>
		netbuf = adf_nbuf_queue_next(netbuf);

		ReturnBuffers(htcHandle, EndpointID, tmpNbuf, FALSE);
	}

	HTCCheckAndSendCreditReport(pHTC, (1 << EndpointID),&pHTC->Endpoints[EndpointID],EndpointID);
  90404b:	033c09        	addx2	a12, a3, a3
  90404e:	02cc0b        	addx8	a12, a12, a2
  904051:	c0b1      	movi.n	a11, 1
  904053:	da20      	mov.n	a10, a2
  904055:	003104        	ssl	a3
  904058:	00bb1a        	sll	a11, a11
  90405b:	b4cc      	addi.n	a12, a12, 4
  90405d:	dd30      	mov.n	a13, a3
  90405f:	5bffa9        	call8	903f04 <HTCCheckAndSendCreditReport>
  904062:	d10f      	retw.n

00904064 <HTCProcessConnectMsg>:
	} while (FALSE);      
}
        
/* called in response to the arrival of a service connection message */
LOCAL void HTCProcessConnectMsg(HTC_CONTEXT *pHTC, HTC_CONNECT_SERVICE_MSG *pMsg)
{
  904064:	6c1008        	entry	a1, 64
	HTC_SERVICE *pService = pHTC->pServiceList;
	A_UINT8 connectStatus = HTC_SERVICE_NOT_FOUND;
	adf_nbuf_t pBuffer;
	HTC_CONNECT_SERVICE_RESPONSE_MSG *pRspMsg;
	int metaDataOutLen = 0;
  904067:	c060      	movi.n	a6, 0
  904069:	9610      	s32i.n	a6, a1, 0
	A_UINT16 serviceId = adf_os_ntohs(pMsg->ServiceID);
    
	pBuffer = HTCAllocMsgBuffer(pHTC);
  90406b:	da20      	mov.n	a10, a2
	HTC_SERVICE *pService = pHTC->pServiceList;
	A_UINT8 connectStatus = HTC_SERVICE_NOT_FOUND;
	adf_nbuf_t pBuffer;
	HTC_CONNECT_SERVICE_RESPONSE_MSG *pRspMsg;
	int metaDataOutLen = 0;
	A_UINT16 serviceId = adf_os_ntohs(pMsg->ServiceID);
  90406d:	243003        	l8ui	a4, a3, 3
  904070:	273002        	l8ui	a7, a3, 2
}
        
/* called in response to the arrival of a service connection message */
LOCAL void HTCProcessConnectMsg(HTC_CONTEXT *pHTC, HTC_CONNECT_SERVICE_MSG *pMsg)
{
	HTC_SERVICE *pService = pHTC->pServiceList;
  904073:	252290        	l32i	a5, a2, 0x240
	adf_nbuf_t pBuffer;
	HTC_CONNECT_SERVICE_RESPONSE_MSG *pRspMsg;
	int metaDataOutLen = 0;
	A_UINT16 serviceId = adf_os_ntohs(pMsg->ServiceID);
    
	pBuffer = HTCAllocMsgBuffer(pHTC);
  904076:	5bff84        	call8	903e88 <HTCAllocMsgBuffer>
 *         put, or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_put_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_put_tail(buf, size);
  904079:	c0ba      	movi.n	a11, 10
  90407b:	9a14      	s32i.n	a10, a1, 16
  90407d:	5bfd6c        	call8	903630 <__adf_nbuf_put_tail>
	/* note : this will be aligned */
	pRspMsg = (HTC_CONNECT_SERVICE_RESPONSE_MSG *)
                adf_nbuf_put_tail(pBuffer, sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
                                 
	A_MEMZERO(pRspMsg,sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
  904080:	197184        	l32r	a9, 8e0690 <_bss_end+0x3d2e88>
	HTC_SERVICE *pService = pHTC->pServiceList;
	A_UINT8 connectStatus = HTC_SERVICE_NOT_FOUND;
	adf_nbuf_t pBuffer;
	HTC_CONNECT_SERVICE_RESPONSE_MSG *pRspMsg;
	int metaDataOutLen = 0;
	A_UINT16 serviceId = adf_os_ntohs(pMsg->ServiceID);
  904083:	087711        	slli	a7, a7, 8
	pBuffer = HTCAllocMsgBuffer(pHTC);
	/* note : this will be aligned */
	pRspMsg = (HTC_CONNECT_SERVICE_RESPONSE_MSG *)
                adf_nbuf_put_tail(pBuffer, sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
                                 
	A_MEMZERO(pRspMsg,sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
  904086:	8994      	l32i.n	a9, a9, 16
  904088:	db60      	mov.n	a11, a6
  90408a:	c0ca      	movi.n	a12, 10
	HTC_SERVICE *pService = pHTC->pServiceList;
	A_UINT8 connectStatus = HTC_SERVICE_NOT_FOUND;
	adf_nbuf_t pBuffer;
	HTC_CONNECT_SERVICE_RESPONSE_MSG *pRspMsg;
	int metaDataOutLen = 0;
	A_UINT16 serviceId = adf_os_ntohs(pMsg->ServiceID);
  90408c:	074702        	or	a7, a4, a7
  90408f:	d4a0      	mov.n	a4, a10
	pBuffer = HTCAllocMsgBuffer(pHTC);
	/* note : this will be aligned */
	pRspMsg = (HTC_CONNECT_SERVICE_RESPONSE_MSG *)
                adf_nbuf_put_tail(pBuffer, sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
                                 
	A_MEMZERO(pRspMsg,sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
  904091:	0b9000        	callx8	a9
	pRspMsg->MessageID = adf_os_htons(HTC_MSG_CONNECT_SERVICE_RESPONSE_ID);
  904094:	c083      	movi.n	a8, 3
  904096:	284401        	s8i	a8, a4, 1
	/* reflect the service ID for this connect attempt */
	pRspMsg->ServiceID = adf_os_htons(serviceId);
  904099:	078814        	srli	a8, a7, 8
  90409c:	284402        	s8i	a8, a4, 2
	/* note : this will be aligned */
	pRspMsg = (HTC_CONNECT_SERVICE_RESPONSE_MSG *)
                adf_nbuf_put_tail(pBuffer, sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
                                 
	A_MEMZERO(pRspMsg,sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
	pRspMsg->MessageID = adf_os_htons(HTC_MSG_CONNECT_SERVICE_RESPONSE_ID);
  90409f:	264400        	s8i	a6, a4, 0
	/* reflect the service ID for this connect attempt */
	pRspMsg->ServiceID = adf_os_htons(serviceId);
  9040a2:	274403        	s8i	a7, a4, 3

	while (pService) {
        
		if (pHTC->CurrentEpIndex >= ENDPOINT_MAX) {
  9040a5:	c185      	movi.n	a8, 21
	A_MEMZERO(pRspMsg,sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
	pRspMsg->MessageID = adf_os_htons(HTC_MSG_CONNECT_SERVICE_RESPONSE_ID);
	/* reflect the service ID for this connect attempt */
	pRspMsg->ServiceID = adf_os_htons(serviceId);

	while (pService) {
  9040a7:	600079        	j	904124 <HTCProcessConnectMsg+0xc0>
  9040aa:	00002b        	mulsh	a0, a0, a0
        
		if (pHTC->CurrentEpIndex >= ENDPOINT_MAX) {
  9040ad:	22887b        	excw
  9040b0:	827b      	l32i.n	a2, a7, 44
			/* no more endpoints */
			connectStatus = HTC_SERVICE_NO_RESOURCES;
			break;    
		}

		if (serviceId == pService->ServiceID) {
  9040b2:	295108        	l16ui	a9, a5, 16
  9040b5:	779969        	bne	a9, a7, 904122 <HTCProcessConnectMsg+0xbe>
			A_UINT8 *pMetaDataOut;
            
			/* outgoing meta data resides in the space after the response message */
			pMetaDataOut = ((A_UINT8 *)pRspMsg) + sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG);
            
			if (pMsg->ServiceMetaLength != 0) {
  9040b8:	2d3008        	l8ui	a13, a3, 8
				/* the meta data follows the connect service message */
				pMetaDataIN = ((A_UINT8 *)pMsg) + sizeof(HTC_CONNECT_SERVICE_MSG);
  9040bb:	ba37      	addi.n	a7, a3, 10
  9040bd:	c0c0      	movi.n	a12, 0
  9040bf:	0d7c39        	movnez	a12, a7, a13
			}

			/* call the connect callback with the endpoint to use and pointers to meta data */
			connectStatus = pService->ProcessConnect(pService,
  9040c2:	8753      	l32i.n	a7, a5, 12
  9040c4:	da50      	mov.n	a10, a5
  9040c6:	ba4e      	addi.n	a14, a4, 10
  9040c8:	df10      	mov.n	a15, a1
  9040ca:	0b7000        	callx8	a7
  9040cd:	d8a0      	mov.n	a8, a10
								 pMsg->ServiceMetaLength,
								 pMetaDataOut,
								 &metaDataOutLen);
            
			/* check if the service accepted this connection request */
			if (HTC_SERVICE_SUCCESS == connectStatus) {
  9040cf:	65a05d        	bnez	a10, 904130 <HTCProcessConnectMsg+0xcc>
				/* set the length of the response meta data going back to the host */
				pRspMsg->ServiceMetaLength = (A_UINT8)metaDataOutLen;
  9040d2:	8710      	l32i.n	a7, a1, 0
  9040d4:	274408        	s8i	a7, a4, 8
				/* set the endpoint ID the host will now communicate over */
				pRspMsg->EndpointID = pHTC->CurrentEpIndex;
  9040d7:	272288        	l32i	a7, a2, 0x220
  9040da:	274405        	s8i	a7, a4, 5
				/* return the maximum message size for this service */
				pRspMsg->MaxMsgSize = adf_os_htons((A_UINT16)pService->MaxSvcMsgSize);
  9040dd:	275014        	l8ui	a7, a5, 20
  9040e0:	274406        	s8i	a7, a4, 6
  9040e3:	275015        	l8ui	a7, a5, 21
  9040e6:	274407        	s8i	a7, a4, 7
				/* assign this endpoint to this service, this will be used in routing messages */
				pHTC->Endpoints[pHTC->CurrentEpIndex].pService = pService;
  9040e9:	272288        	l32i	a7, a2, 0x220
  9040ec:	077909        	addx2	a9, a7, a7
  9040ef:	02990b        	addx8	a9, a9, a2
  9040f2:	9592      	s32i.n	a5, a9, 8
				/* set connection flags */
				pHTC->Endpoints[pHTC->CurrentEpIndex].ConnectionFlags = pMsg->ConnectionFlags;
  9040f4:	2a3004        	l8ui	a10, a3, 4
  9040f7:	2b3005        	l8ui	a11, a3, 5
  9040fa:	08aa11        	slli	a10, a10, 8
  9040fd:	0aba02        	or	a10, a11, a10
  904100:	2a9508        	s16i	a10, a9, 16
                
				pHTC->Endpoints[pHTC->CurrentEpIndex].DownLinkPipeID = pMsg->DownLinkPipeID;
  904103:	2a3006        	l8ui	a10, a3, 6
				pHTC->Endpoints[pHTC->CurrentEpIndex].UpLinkPipeID = pMsg->UpLinkPipeID;
                
				/* mark that we are now connected */
				pService->ServiceFlags |= HTC_SERVICE_FLAGS_CONNECTED;
				/* bump up our index, this EP is now in use */
				pHTC->CurrentEpIndex++;   
  904106:	b177      	addi.n	a7, a7, 1
				/* assign this endpoint to this service, this will be used in routing messages */
				pHTC->Endpoints[pHTC->CurrentEpIndex].pService = pService;
				/* set connection flags */
				pHTC->Endpoints[pHTC->CurrentEpIndex].ConnectionFlags = pMsg->ConnectionFlags;
                
				pHTC->Endpoints[pHTC->CurrentEpIndex].DownLinkPipeID = pMsg->DownLinkPipeID;
  904108:	2a9418        	s8i	a10, a9, 24
				pHTC->Endpoints[pHTC->CurrentEpIndex].UpLinkPipeID = pMsg->UpLinkPipeID;
  90410b:	233007        	l8ui	a3, a3, 7
  90410e:	239419        	s8i	a3, a9, 25
                
				/* mark that we are now connected */
				pService->ServiceFlags |= HTC_SERVICE_FLAGS_CONNECTED;
  904111:	295109        	l16ui	a9, a5, 18
  904114:	c031      	movi.n	a3, 1
  904116:	039302        	or	a3, a9, a3
  904119:	235509        	s16i	a3, a5, 18
				/* bump up our index, this EP is now in use */
				pHTC->CurrentEpIndex++;   
  90411c:	272688        	s32i	a7, a2, 0x220
  90411f:	60000d        	j	904130 <HTCProcessConnectMsg+0xcc>
			}

			break;
		}       
        
		pService = pService->pNext;   
  904122:	8550      	l32i.n	a5, a5, 0
	A_MEMZERO(pRspMsg,sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
	pRspMsg->MessageID = adf_os_htons(HTC_MSG_CONNECT_SERVICE_RESPONSE_ID);
	/* reflect the service ID for this connect attempt */
	pRspMsg->ServiceID = adf_os_htons(serviceId);

	while (pService) {
  904124:	655f84        	bnez	a5, 9040ac <HTCProcessConnectMsg+0x48>
        
/* called in response to the arrival of a service connection message */
LOCAL void HTCProcessConnectMsg(HTC_CONTEXT *pHTC, HTC_CONNECT_SERVICE_MSG *pMsg)
{
	HTC_SERVICE *pService = pHTC->pServiceList;
	A_UINT8 connectStatus = HTC_SERVICE_NOT_FOUND;
  904127:	c081      	movi.n	a8, 1
  904129:	600003        	j	904130 <HTCProcessConnectMsg+0xcc>
  90412c:	0000c0        	excw

	while (pService) {
        
		if (pHTC->CurrentEpIndex >= ENDPOINT_MAX) {
			/* no more endpoints */
			connectStatus = HTC_SERVICE_NO_RESOURCES;
  90412f:	8313      	l32i.n	a3, a1, 12
	}
                   
	pRspMsg->Status = connectStatus;    
    
	/* send out the response message */
	HTC_SendMsg(pHTC, ENDPOINT0, pBuffer); 
  904131:	718428        	ball	a8, a1, 90415d <HTCProcessConfigPipeMsg+0x19>
		}       
        
		pService = pService->pNext;   
	}
                   
	pRspMsg->Status = connectStatus;    
  904134:	440423        	excw
    
	/* send out the response message */
	HTC_SendMsg(pHTC, ENDPOINT0, pBuffer); 
  904137:	32898c        	excw
  90413a:	14da20        	l32r	a4, 8fa9bc <memset+0x15820>
  90413d:	c0b0      	movi.n	a11, 0
  90413f:	0b3000        	callx8	a3
  904142:	d10f      	retw.n

00904144 <HTCProcessConfigPipeMsg>:
}

LOCAL void HTCProcessConfigPipeMsg(HTC_CONTEXT *pHTC, HTC_CONFIG_PIPE_MSG *pMsg)
{
  904144:	6c1004        	entry	a1, 32
	adf_nbuf_t pBuffer;
	HTC_CONFIG_PIPE_RESPONSE_MSG *pRspMsg;
        
	pBuffer = HTCAllocMsgBuffer(pHTC);
  904147:	022a02        	or	a10, a2, a2
  90414a:	5bff4f        	call8	903e88 <HTCAllocMsgBuffer>
  90414d:	c0b4      	movi.n	a11, 4
  90414f:	d6a0      	mov.n	a6, a10
  904151:	5bfd37        	call8	903630 <__adf_nbuf_put_tail>
       
	/* note : this will be aligned */
	pRspMsg = (HTC_CONFIG_PIPE_RESPONSE_MSG *)
                adf_nbuf_put_tail(pBuffer, sizeof(HTC_CONFIG_PIPE_RESPONSE_MSG));    
              
	A_MEMZERO(pRspMsg,sizeof(HTC_CONFIG_PIPE_RESPONSE_MSG));
  904154:	157184        	l32r	a5, 8e0764 <_bss_end+0x3d2f5c>
  904157:	c0b0      	movi.n	a11, 0
  904159:	8754      	l32i.n	a7, a5, 16
  90415b:	c0c4      	movi.n	a12, 4
  90415d:	d4a0      	mov.n	a4, a10
  90415f:	0b7000        	callx8	a7
    
	pRspMsg->MessageID = adf_os_htons(HTC_MSG_CONFIG_PIPE_RESPONSE_ID);
  904162:	c086      	movi.n	a8, 6
  904164:	c070      	movi.n	a7, 0
  904166:	274400        	s8i	a7, a4, 0
  904169:	284401        	s8i	a8, a4, 1
	/* reflect the service ID for this connect attempt */
	pRspMsg->PipeID = pMsg->PipeID;
  90416c:	283002        	l8ui	a8, a3, 2
  90416f:	284402        	s8i	a8, a4, 2

	if ( HIF_is_pipe_supported(pHTC->hifHandle, pMsg->PipeID) ) {
  904172:	28527d        	l32i	a8, a5, 0x1f4
  904175:	2a229a        	l32i	a10, a2, 0x268
  904178:	2b3002        	l8ui	a11, a3, 2
  90417b:	0b8000        	callx8	a8
  90417e:	c9a2      	beqz.n	a10, 904194 <HTCProcessConfigPipeMsg+0x50>
		pRspMsg->Status = 0;            
  904180:	274403        	s8i	a7, a4, 3
	} else {
		pRspMsg->Status = 1; 
		goto config_done;
	}

	if ( (pHTC->TotalCreditsAssigned + pMsg->CreditCount) <= pHTC->TotalCredits ) {
  904183:	283003        	l8ui	a8, a3, 3
  904186:	272295        	l32i	a7, a2, 0x254
  904189:	a787      	add.n	a7, a8, a7
  90418b:	282294        	l32i	a8, a2, 0x250
  90418e:	77821e        	blt	a8, a7, 9041b0 <HTCProcessConfigPipeMsg+0x6c>
  904191:	600005        	j	90419a <HTCProcessConfigPipeMsg+0x56>
	pRspMsg->PipeID = pMsg->PipeID;

	if ( HIF_is_pipe_supported(pHTC->hifHandle, pMsg->PipeID) ) {
		pRspMsg->Status = 0;            
	} else {
		pRspMsg->Status = 1; 
  904194:	c031      	movi.n	a3, 1
  904196:	600018        	j	9041b2 <HTCProcessConfigPipeMsg+0x6e>
  904199:	002726        	excw
		goto config_done;
	}

	if ( (pHTC->TotalCreditsAssigned + pMsg->CreditCount) <= pHTC->TotalCredits ) {
		pHTC->TotalCreditsAssigned += pMsg->CreditCount;
  90419c:	9524      	s32i.n	a5, a2, 16
	} else {
		pRspMsg->Status = 2;
		goto config_done;
	}
    
	HIF_config_pipe(pHTC->hifHandle, pMsg->PipeID, pMsg->CreditCount);
  90419e:	527a2a        	call0	8a2a48 <_bss_end+0x395240>
  9041a1:	229a2b        	movi	a2, 0xfffff92b
  9041a4:	30022c        	excw
  9041a7:	30030b        	excw
  9041aa:	400060        	excw
  9041ad:	000500        	syscall
	}

	if ( (pHTC->TotalCreditsAssigned + pMsg->CreditCount) <= pHTC->TotalCredits ) {
		pHTC->TotalCreditsAssigned += pMsg->CreditCount;
	} else {
		pRspMsg->Status = 2;
  9041b0:	c032      	movi.n	a3, 2
  9041b2:	234403        	s8i	a3, a4, 3
    
	HIF_config_pipe(pHTC->hifHandle, pMsg->PipeID, pMsg->CreditCount);
    
config_done:      
	/* send out the response message */
	HTC_SendMsg(pHTC, ENDPOINT0, pBuffer);             
  9041b5:	137184        	l32r	a3, 8e07c8 <_bss_end+0x3d2fc0>
  9041b8:	da20      	mov.n	a10, a2
  9041ba:	233289        	l32i	a3, a3, 0x224
  9041bd:	c0b0      	movi.n	a11, 0
  9041bf:	dc60      	mov.n	a12, a6
  9041c1:	0b3000        	callx8	a3
  9041c4:	d10f      	retw.n
	...

009041c8 <HTCControlSvcProcessMsg>:
}

/* process an incomming control message from the host */
LOCAL void HTCControlSvcProcessMsg(HTC_ENDPOINT_ID EndpointID, adf_nbuf_t hdr_buf,
				   adf_nbuf_t pBuffers, void *arg)
{  
  9041c8:	6c1006        	entry	a1, 48
	a_uint8_t *anbdata;
	a_uint32_t anblen;
	HTC_CONTEXT *pHTC = (HTC_CONTEXT *)arg;
	HTC_UNKNOWN_MSG  *pMsg;
	
	adf_os_assert(hdr_buf == ADF_NBUF_NULL);
  9041cb:	c831      	beqz.n	a3, 9041d0 <HTCControlSvcProcessMsg+0x8>
  9041cd:	63fffc        	j	9041cd <HTCControlSvcProcessMsg+0x5>
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  9041d0:	b41b      	addi.n	a11, a1, 4
  9041d2:	da40      	mov.n	a10, a4
  9041d4:	dc10      	mov.n	a12, a1
  9041d6:	5bfd32        	call8	9036a0 <__adf_nbuf_peek_header>

	/* we assume buffers are aligned such that we can access the message
	 * parameters directly*/
	adf_nbuf_peek_header(pBuffers, &anbdata, &anblen);
	pMsg = (HTC_UNKNOWN_MSG *)anbdata;
  9041d9:	8b11      	l32i.n	a11, a1, 4
    
	/* we cannot handle fragmented messages across buffers */
    
	switch ( adf_os_ntohs(pMsg->MessageID) ) {        
  9041db:	28b000        	l8ui	a8, a11, 0
  9041de:	26b001        	l8ui	a6, a11, 1
  9041e1:	088811        	slli	a8, a8, 8
  9041e4:	086802        	or	a8, a6, a8
		break;            
        case HTC_MSG_SETUP_COMPLETE_ID:
                /* the host has indicated that it has completed all
		   setup tasks and we can now let the services take over to
		   run the rest of the application */
		setupComplete = TRUE;  
  9041e7:	c061      	movi.n	a6, 1
	adf_nbuf_peek_header(pBuffers, &anbdata, &anblen);
	pMsg = (HTC_UNKNOWN_MSG *)anbdata;
    
	/* we cannot handle fragmented messages across buffers */
    
	switch ( adf_os_ntohs(pMsg->MessageID) ) {        
  9041e9:	688417        	beqi	a8, 4, 904204 <HTCControlSvcProcessMsg+0x3c>
  9041ec:	68850d        	beqi	a8, 5, 9041fd <HTCControlSvcProcessMsg+0x35>
  9041ef:	688202        	beqi	a8, 2, 9041f5 <HTCControlSvcProcessMsg+0x2d>
  9041f2:	60000c        	j	904202 <HTCControlSvcProcessMsg+0x3a>
        case HTC_MSG_CONNECT_SERVICE_ID:
		HTCProcessConnectMsg(pHTC, (HTC_CONNECT_SERVICE_MSG *)pMsg); 
  9041f5:	da50      	mov.n	a10, a5
  9041f7:	5bff9b        	call8	904064 <HTCProcessConnectMsg>
  9041fa:	600004        	j	904202 <HTCControlSvcProcessMsg+0x3a>
		break;
        case HTC_MSG_CONFIG_PIPE_ID:
		HTCProcessConfigPipeMsg(pHTC, (HTC_CONFIG_PIPE_MSG *)pMsg); 
  9041fd:	da50      	mov.n	a10, a5
  9041ff:	5bffd1        	call8	904144 <HTCProcessConfigPipeMsg>

/* process an incomming control message from the host */
LOCAL void HTCControlSvcProcessMsg(HTC_ENDPOINT_ID EndpointID, adf_nbuf_t hdr_buf,
				   adf_nbuf_t pBuffers, void *arg)
{  
	A_BOOL setupComplete = FALSE;
  904202:	d630      	mov.n	a6, a3
		break;
        default:
		;
	}  
        
	if (pHTC->StateFlags & HTC_STATE_SETUP_COMPLETE) {
  904204:	285292        	l32i	a8, a5, 0x248
  904207:	137184        	l32r	a3, 8e0818 <_bss_end+0x3d3010>
  90420a:	7f8710        	bbci	a8, 31, 90421e <HTCControlSvcProcessMsg+0x56>
		/* recycle buffer only if we are fully running */
		HTC_ReturnBuffers(pHTC, ENDPOINT0,pBuffers);
  90420d:	223287        	l32i	a2, a3, 0x21c
  904210:	da50      	mov.n	a10, a5
  904212:	c0b0      	movi.n	a11, 0
  904214:	dc40      	mov.n	a12, a4
  904216:	0b2000        	callx8	a2
  904219:	60001c        	j	904239 <HTCControlSvcProcessMsg+0x71>
  90421c:	0000c0        	excw
 *         or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_push_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_push_head(buf, size);
  90421f:	b8da      	addi.n	a10, a13, 8
  904221:	400222        	excw
	} else {
		/* supply some head-room again */
		adf_nbuf_push_head(pBuffers, HTC_HDR_LENGTH);
            
		/* otherwise return the packet back to mbox */
		HIF_return_recv_buf(pHTC->hifHandle, pHTC->Endpoints[EndpointID].UpLinkPipeID, pBuffers);        
  904224:	095bfc        	excw
  904227:	6b0522        	bgei	a0, 5, 90424d <HTCControlSvcProcessMsg+0x85>
  90422a:	0b2332        	sext	a3, a2, 18
  90422d:	7c2a52        	bge	a2, a12, 904283 <AdjustCreditThreshold+0x33>
  904230:	9a2b      	s32i.n	a10, a2, 44
  904232:	2019dc        	l16si	a0, a1, 0x1b8
  904235:	400b30        	excw
  904238:	00c961        	excw
	}

	if (setupComplete) {        
		/* mark that setup has completed */
		pHTC->StateFlags |= HTC_STATE_SETUP_COMPLETE; 
  90423b:	235292        	l32i	a3, a5, 0x248
  90423e:	c021      	movi.n	a2, 1
  904240:	023202        	or	a2, a3, a2
  904243:	225692        	s32i	a2, a5, 0x248
		if (pHTC->SetupCompleteCb != NULL) {
  904246:	225293        	l32i	a2, a5, 0x24c
  904249:	c821      	beqz.n	a2, 90424e <HTCControlSvcProcessMsg+0x86>
			pHTC->SetupCompleteCb();
  90424b:	0b2000        	callx8	a2
  90424e:	d10f      	retw.n

00904250 <AdjustCreditThreshold>:
					  buf, 
					  pHTC->Endpoints[current_eid].pService->ServiceCtx);
}

LOCAL void AdjustCreditThreshold(HTC_ENDPOINT  *pEndpoint)
{
  904250:	6c1004        	entry	a1, 32
	A_INT16 creditsOutstanding = pEndpoint->CreditsToReturn + pEndpoint->CreditsConsumed;
  904253:	292105        	l16ui	a9, a2, 10
  904256:	282100        	l16ui	a8, a2, 0
  904259:	a898      	add.n	a8, a9, a8
        /* set the new threshold based on the number of credits that have been consumed
         * and which have not been returned by the app.
         * Note: it is okay for this threshold to be zero which indicates no threshold 
         * is in use */    
	switch (pEndpoint->ConnectionFlags & HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_MASK) {
  90425b:	292106        	l16ui	a9, a2, 12
					  pHTC->Endpoints[current_eid].pService->ServiceCtx);
}

LOCAL void AdjustCreditThreshold(HTC_ENDPOINT  *pEndpoint)
{
	A_INT16 creditsOutstanding = pEndpoint->CreditsToReturn + pEndpoint->CreditsConsumed;
  90425e:	088832        	sext	a8, a8, 15
        /* set the new threshold based on the number of credits that have been consumed
         * and which have not been returned by the app.
         * Note: it is okay for this threshold to be zero which indicates no threshold 
         * is in use */    
	switch (pEndpoint->ConnectionFlags & HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_MASK) {
  904261:	090941        	extui	a9, a9, 0, 2
  904264:	689108        	beqi	a9, 1, 904270 <AdjustCreditThreshold+0x20>
  904267:	c89e      	beqz.n	a9, 904279 <AdjustCreditThreshold+0x29>
  904269:	69920f        	bnei	a9, 2, 90427c <AdjustCreditThreshold+0x2c>
  90426c:	600006        	j	904276 <AdjustCreditThreshold+0x26>
  90426f:	000818        	src	a8, a0, a0
        case HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_ONE_FOURTH :
		creditsOutstanding >>= 2;
		break;                    
        case HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_ONE_HALF :
		creditsOutstanding >>= 1;
  904272:	126000        	l32r	a2, 8dc274 <_bss_end+0x3cea6c>
		break;
  904275:	050888        	excw
        case HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_THREE_FOURTHS :  
		creditsOutstanding = (creditsOutstanding * 3) >> 2;                  
  904278:	090828        	mull	a8, a0, a9
  90427b:	122825        	l32r	a2, 8ce310 <_bss_end+0x3c0b08>
		break;
		/* default case is unity */    
	}
    
	pEndpoint->CreditReturnThreshhold = creditsOutstanding;
  90427e:	04d10f        	subx8	a1, a13, a4
  904281:	000000        	ill

00904284 <_HTC_SendMsg>:
	ReturnBuffers(htcHandle, EndpointID, pBuffers, TRUE);
}
 
LOCAL void _HTC_SendMsg(htc_handle_t htcHandle, HTC_ENDPOINT_ID EndpointID,
			adf_nbuf_t pBuffers)
{
  904284:	6c1008        	entry	a1, 64
 * @return data pointer to typecast into your priv structure
 */
static inline a_uint8_t *
adf_nbuf_get_priv(adf_nbuf_t buf)
{
    return (__adf_nbuf_get_priv(buf));
  904287:	044a02        	or	a10, a4, a4
  90428a:	5bfc78        	call8	90346c <__adf_nbuf_get_priv>
  90428d:	d6a0      	mov.n	a6, a10
 * @return The total length of this buf.
 */
static inline adf_os_size_t
adf_nbuf_len(adf_nbuf_t buf)
{
    return (__adf_nbuf_len(buf));
  90428f:	da40      	mov.n	a10, a4
  904291:	5bfcfb        	call8	903680 <__adf_nbuf_len>
 *         or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_push_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_push_head(buf, size);
  904294:	c0b8      	movi.n	a11, 8
 * @return The total length of this buf.
 */
static inline adf_os_size_t
adf_nbuf_len(adf_nbuf_t buf)
{
    return (__adf_nbuf_len(buf));
  904296:	d7a0      	mov.n	a7, a10
 *         or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_push_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_push_head(buf, size);
  904298:	da40      	mov.n	a10, a4
  90429a:	5bfc4e        	call8	9033d4 <__adf_nbuf_push_head>
	 * Note: in HTCSendDoneHandler(), we undo this so that the caller get's it's buffer
	 * back untainted */   
	pHTCHdr = (HTC_FRAME_HDR *)adf_nbuf_push_head(pBuffers, HTC_HDR_LENGTH);
    
	/* flag that this is the header buffer that was modified */
	ctx->htc_flags |= HTC_FLAGS_BUF_HDR;   
  90429d:	296001        	l8ui	a9, a6, 1
  9042a0:	c480      	movi.n	a8, 64
  9042a2:	089802        	or	a8, a9, a8
  9042a5:	286401        	s8i	a8, a6, 1
	/* mark where this buffer came from */
	ctx->end_point = EndpointID;      
  9042a8:	030847        	extui	a8, a3, 0, 8
  9042ab:	286400        	s8i	a8, a6, 0
	/* the header start is ALWAYS aligned since we DMA it directly */

        /* set some fields, the rest of them will be filled below when we check for
	 * trailer space */
	pHTCHdr->Flags = 0;
  9042ae:	c060      	movi.n	a6, 0
  9042b0:	26a401        	s8i	a6, a10, 1
	pHTCHdr->EndpointID = EndpointID;    
  9042b3:	28a400        	s8i	a8, a10, 0
		HTC_RECORD_HDR    *pRecHdr;
		int               pipeMaxLen;
		A_UINT32          roomForPipeMaxLen;
                          
		/* figure out how much room the last buffer can spare */
		pipeMaxLen = HIF_get_max_msg_len(pHTC->hifHandle,
  9042b6:	167184        	l32r	a6, 8e08c8 <_bss_end+0x3d30c0>
  9042b9:	033809        	addx2	a8, a3, a3
  9042bc:	02880b        	addx8	a8, a8, a2
  9042bf:	2b8018        	l8ui	a11, a8, 24
  9042c2:	26627e        	l32i	a6, a6, 0x1f8
  9042c5:	d5a0      	mov.n	a5, a10
  9042c7:	2a229a        	l32i	a10, a2, 0x268
  9042ca:	0b6000        	callx8	a6
  9042cd:	d6a0      	mov.n	a6, a10
 * @return amount of head room
 */
static inline a_uint32_t
adf_nbuf_headroom(adf_nbuf_t buf)
{
    return (__adf_nbuf_headroom(buf));
  9042cf:	da40      	mov.n	a10, a4
  9042d1:	5bfce1        	call8	903658 <__adf_nbuf_headroom>
						 pHTC->Endpoints[EndpointID].DownLinkPipeID);
		roomForPipeMaxLen = pipeMaxLen - adf_nbuf_headroom(pBuffers) - adf_nbuf_len(pBuffers);
  9042d4:	0a660c        	sub	a6, a6, a10
 * @return The total length of this buf.
 */
static inline adf_os_size_t
adf_nbuf_len(adf_nbuf_t buf)
{
    return (__adf_nbuf_len(buf));
  9042d7:	da40      	mov.n	a10, a4
  9042d9:	5bfce9        	call8	903680 <__adf_nbuf_len>
  9042dc:	0a660c        	sub	a6, a6, a10
 * @return amount of tail room 
 */
static inline a_uint32_t
adf_nbuf_tailroom(adf_nbuf_t buf)
{
    return (__adf_nbuf_tailroom(buf));
  9042df:	da40      	mov.n	a10, a4
  9042e1:	5bfce0        	call8	903664 <__adf_nbuf_tailroom>
		if ( roomForPipeMaxLen < 0 ) {
			roomForPipeMaxLen = 0;
		}
                        
		room = adf_os_min( adf_nbuf_tailroom(pBuffers), roomForPipeMaxLen);
  9042e4:	dd60      	mov.n	a13, a6
  9042e6:	76ab06        	bgeu	a10, a6, 9042f0 <_HTC_SendMsg+0x6c>
  9042e9:	da40      	mov.n	a10, a4
  9042eb:	5bfcde        	call8	903664 <__adf_nbuf_tailroom>
  9042ee:	dda0      	mov.n	a13, a10
		if (room < (int)(sizeof(HTC_CREDIT_REPORT) + sizeof(HTC_RECORD_HDR))) {
  9042f0:	6bd402        	bgei	a13, 4, 9042f6 <_HTC_SendMsg+0x72>
  9042f3:	6000bd        	j	9043b4 <_HTC_SendMsg+0x130>
		/* note, a record header only has 8 bit fields, so this is safe.
		 * we need an uncached pointer here too */            
		totalReportBytes = 0;
        
		/* get a copy */        
		creditsPendingMap = pHTC->EpCreditPendingMap;   
  9042f6:	262286        	l32i	a6, a2, 0x218
                           
		/* test pending map to see if we can send a report , if any
		 * credits are available, we might as well send them on the 
		 * unused space in the buffer */
		if (creditsPendingMap) { 
  9042f9:	6460b7        	beqz	a6, 9043b4 <_HTC_SendMsg+0x130>
 *         put, or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_put_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_put_tail(buf, size);
  9042fc:	da40      	mov.n	a10, a4
  9042fe:	c0b2      	movi.n	a11, 2
  904300:	9d15      	s32i.n	a13, a1, 20
  904302:	5bfccb        	call8	903630 <__adf_nbuf_put_tail>
			pRecHdr = (HTC_RECORD_HDR *)adf_nbuf_put_tail(pBuffers,
							      sizeof(HTC_RECORD_HDR));
            
			/* set the ID, the length will be updated with the number of credit reports we
			 * can fit (see below) */
			pRecHdr->RecordID = HTC_RECORD_CREDITS;
  904305:	c081      	movi.n	a8, 1
  904307:	28a400        	s8i	a8, a10, 0
			pRecHdr->Length = 0;
  90430a:	c080      	movi.n	a8, 0
  90430c:	28a401        	s8i	a8, a10, 1
			/* the credit report follows the record header */         
			totalReportBytes += sizeof(HTC_RECORD_HDR);
			room -= sizeof(HTC_RECORD_HDR);
  90430f:	8d15      	l32i.n	a13, a1, 20
  904311:	dea0      	mov.n	a14, a10
  904313:	2ddcfe        	addi	a13, a13, -2
  904316:	dc20      	mov.n	a12, a2
			/* set the ID, the length will be updated with the number of credit reports we
			 * can fit (see below) */
			pRecHdr->RecordID = HTC_RECORD_CREDITS;
			pRecHdr->Length = 0;
			/* the credit report follows the record header */         
			totalReportBytes += sizeof(HTC_RECORD_HDR);
  904318:	c092      	movi.n	a9, 2
			room -= sizeof(HTC_RECORD_HDR);
            
			/* walkthrough pending credits map and build the records */
			for (i = 0; 
  90431a:	c080      	movi.n	a8, 0
  90431c:	600077        	j	904397 <_HTC_SendMsg+0x113>
  90431f:	00c0a1        	excw
			     (creditsPendingMap != 0) && (room >= (int)sizeof(HTC_CREDIT_REPORT)); 
			     i++) {                
				compareMask = (1 << i);
  904322:	008104        	ssl	a8
  904325:	00af1a        	sll	a15, a10
				if (compareMask & creditsPendingMap) {
  904328:	76f066        	bnone	a15, a6, 904392 <_HTC_SendMsg+0x10e>
  90432b:	c0b2      	movi.n	a11, 2
  90432d:	da40      	mov.n	a10, a4
  90432f:	9811      	s32i.n	a8, a1, 4
  904331:	9912      	s32i.n	a9, a1, 8
  904333:	9c14      	s32i.n	a12, a1, 16
  904335:	9d15      	s32i.n	a13, a1, 20
  904337:	9e13      	s32i.n	a14, a1, 12
  904339:	9f10      	s32i.n	a15, a1, 0
  90433b:	5bfcbd        	call8	903630 <__adf_nbuf_put_tail>
									    sizeof(HTC_CREDIT_REPORT));
                                    
					/* clear pending mask, we are going to return all these credits */
					creditsPendingMap &= ~(compareMask);
					/* add this record */
					pCreditRpt->EndpointID = i;
  90433e:	8811      	l32i.n	a8, a1, 4
                        
					pCreditRpt = (HTC_CREDIT_REPORT *)adf_nbuf_put_tail(pBuffers,
									    sizeof(HTC_CREDIT_REPORT));
                                    
					/* clear pending mask, we are going to return all these credits */
					creditsPendingMap &= ~(compareMask);
  904340:	8f10      	l32i.n	a15, a1, 0
					/* add this record */
					pCreditRpt->EndpointID = i;
  904342:	28a400        	s8i	a8, a10, 0
					pCreditRpt->Credits = (A_UINT8)pHTC->Endpoints[i].CreditsToReturn;
  904345:	8c14      	l32i.n	a12, a1, 16
                        
					pCreditRpt = (HTC_CREDIT_REPORT *)adf_nbuf_put_tail(pBuffers,
									    sizeof(HTC_CREDIT_REPORT));
                                    
					/* clear pending mask, we are going to return all these credits */
					creditsPendingMap &= ~(compareMask);
  904347:	c7bf      	movi.n	a11, -1
  904349:	0fbf03        	xor	a15, a11, a15
					/* add this record */
					pCreditRpt->EndpointID = i;
					pCreditRpt->Credits = (A_UINT8)pHTC->Endpoints[i].CreditsToReturn;
  90434c:	2bc102        	l16ui	a11, a12, 4
                        
					pCreditRpt = (HTC_CREDIT_REPORT *)adf_nbuf_put_tail(pBuffers,
									    sizeof(HTC_CREDIT_REPORT));
                                    
					/* clear pending mask, we are going to return all these credits */
					creditsPendingMap &= ~(compareMask);
  90434f:	0f6601        	and	a6, a6, a15
					/* add this record */
					pCreditRpt->EndpointID = i;
					pCreditRpt->Credits = (A_UINT8)pHTC->Endpoints[i].CreditsToReturn;
  904352:	2ba401        	s8i	a11, a10, 1
					/* remove pending credits, we always send deltas */
					pHTC->Endpoints[i].CreditsToReturn = 0; 
  904355:	c0a0      	movi.n	a10, 0
  904357:	2ac502        	s16i	a10, a12, 4
					/* adjust new threshold for this endpoint if needed */
					CHECK_AND_ADJUST_CREDIT_THRESHOLD(&pHTC->Endpoints[i]);
  90435a:	2ac108        	l16ui	a10, a12, 16
  90435d:	8912      	l32i.n	a9, a1, 8
  90435f:	8d15      	l32i.n	a13, a1, 20
  904361:	8e13      	l32i.n	a14, a1, 12
  904363:	7da71a        	bbci	a10, 29, 904381 <_HTC_SendMsg+0xfd>
  904366:	088a09        	addx2	a10, a8, a8
  904369:	02aa0b        	addx8	a10, a10, a2
  90436c:	b4aa      	addi.n	a10, a10, 4
  90436e:	9811      	s32i.n	a8, a1, 4
  904370:	2c1604        	s32i	a12, a1, 16
  904373:	5bffb7        	call8	904250 <AdjustCreditThreshold>
  904376:	8e13      	l32i.n	a14, a1, 12
  904378:	8d15      	l32i.n	a13, a1, 20
  90437a:	8c14      	l32i.n	a12, a1, 16
  90437c:	8912      	l32i.n	a9, a1, 8
  90437e:	281201        	l32i	a8, a1, 4
					/* update this record length */
					pRecHdr->Length += sizeof(HTC_CREDIT_REPORT);
  904381:	2ae001        	l8ui	a10, a14, 1
					room -= sizeof(HTC_CREDIT_REPORT);
  904384:	2ddcfe        	addi	a13, a13, -2
					/* remove pending credits, we always send deltas */
					pHTC->Endpoints[i].CreditsToReturn = 0; 
					/* adjust new threshold for this endpoint if needed */
					CHECK_AND_ADJUST_CREDIT_THRESHOLD(&pHTC->Endpoints[i]);
					/* update this record length */
					pRecHdr->Length += sizeof(HTC_CREDIT_REPORT);
  904387:	b2aa      	addi.n	a10, a10, 2
  904389:	2ae401        	s8i	a10, a14, 1
					room -= sizeof(HTC_CREDIT_REPORT);
					totalReportBytes += sizeof(HTC_CREDIT_REPORT);
  90438c:	299c02        	addi	a9, a9, 2

					if ( room < sizeof(HTC_CREDIT_REPORT) ) {
  90438f:	6ed20a        	bltui	a13, 2, 90439d <_HTC_SendMsg+0x119>
			room -= sizeof(HTC_RECORD_HDR);
            
			/* walkthrough pending credits map and build the records */
			for (i = 0; 
			     (creditsPendingMap != 0) && (room >= (int)sizeof(HTC_CREDIT_REPORT)); 
			     i++) {                
  904392:	b188      	addi.n	a8, a8, 1
  904394:	2ccc18        	addi	a12, a12, 24
			totalReportBytes += sizeof(HTC_RECORD_HDR);
			room -= sizeof(HTC_RECORD_HDR);
            
			/* walkthrough pending credits map and build the records */
			for (i = 0; 
			     (creditsPendingMap != 0) && (room >= (int)sizeof(HTC_CREDIT_REPORT)); 
  904397:	6ad202        	blti	a13, 2, 90439d <_HTC_SendMsg+0x119>
			/* the credit report follows the record header */         
			totalReportBytes += sizeof(HTC_RECORD_HDR);
			room -= sizeof(HTC_RECORD_HDR);
            
			/* walkthrough pending credits map and build the records */
			for (i = 0; 
  90439a:	656f82        	bnez	a6, 904320 <_HTC_SendMsg+0x9c>
					}
				}
			}
            
			/* update new pending credits map */       
			pHTC->EpCreditPendingMap = creditsPendingMap;
  90439d:	262686        	s32i	a6, a2, 0x218
		}
        
		if (totalReportBytes <= 0) {
  9043a0:	6a9110        	blti	a9, 1, 9043b4 <_HTC_SendMsg+0x130>
		 */
        
		/* set header option bytes */ 
		pHTCHdr->ControlBytes[0] = totalReportBytes;
		/* HTC frame contains a trailer */
		pHTCHdr->Flags |= HTC_FLAGS_RECV_TRAILER;
  9043a3:	285001        	l8ui	a8, a5, 1
  9043a6:	c062      	movi.n	a6, 2
  9043a8:	068602        	or	a6, a8, a6
		 * The trailer can have at most 1 credit record with up to 32  reports in the record.
		 * The trailer can have at most 1 lookahead record with only 1 lookahead report in the record.
		 */
        
		/* set header option bytes */ 
		pHTCHdr->ControlBytes[0] = totalReportBytes;
  9043ab:	295404        	s8i	a9, a5, 4
		/* HTC frame contains a trailer */
		pHTCHdr->Flags |= HTC_FLAGS_RECV_TRAILER;
  9043ae:	265401        	s8i	a6, a5, 1
		/* increment total size by the reports we added */
		totsz += totalReportBytes;
  9043b1:	097708        	add	a7, a7, a9
          
	if (totsz == 0) {
	}
    
	/* set length for message (this includes any reports that were added above) */
	pHTCHdr->PayloadLen = adf_os_htons(totsz);  
  9043b4:	07074f        	extui	a7, a7, 0, 16
  9043b7:	078614        	srli	a6, a7, 8
  9043ba:	265402        	s8i	a6, a5, 2
  9043bd:	275403        	s8i	a7, a5, 3
	HIF_send_buffer(pHTC->hifHandle, pHTC->Endpoints[EndpointID].DownLinkPipeID, pBuffers);       
  9043c0:	033309        	addx2	a3, a3, a3
  9043c3:	157184        	l32r	a5, 8e09d4 <_bss_end+0x3d31cc>
  9043c6:	02330b        	addx8	a3, a3, a2
  9043c9:	25527b        	l32i	a5, a5, 0x1ec
  9043cc:	2a229a        	l32i	a10, a2, 0x268
  9043cf:	2b3018        	l8ui	a11, a3, 24
  9043d2:	044c02        	or	a12, a4, a4
  9043d5:	0b5000        	callx8	a5
  9043d8:	d10f      	retw.n
	...

009043dc <HTCMsgRecvHandler>:

}
            
/* callback from the mailbox hardware layer when a full message arrives */
LOCAL void HTCMsgRecvHandler(adf_nbuf_t hdr_buf, adf_nbuf_t buffer, void *context)
{
  9043dc:	6c1008        	entry	a1, 64
	HTC_CONTEXT *pHTC = (HTC_CONTEXT *)context;
	adf_nbuf_t tmp_nbuf;
                
	if (hdr_buf == ADF_NBUF_NULL) {
		/* HTC hdr is not in the hdr_buf */
		tmp_nbuf = buffer;
  9043df:	d530      	mov.n	a5, a3
  9043e1:	022539        	movnez	a5, a2, a2
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  9043e4:	da50      	mov.n	a10, a5
  9043e6:	b41b      	addi.n	a11, a1, 4
  9043e8:	dc10      	mov.n	a12, a1
  9043ea:	5bfcad        	call8	9036a0 <__adf_nbuf_peek_header>
	else {
		tmp_nbuf = hdr_buf;
	}
                
	adf_nbuf_peek_header(tmp_nbuf, &anbdata, &anblen);        
	pHTCHdr = (HTC_FRAME_HDR *)anbdata; 
  9043ed:	8911      	l32i.n	a9, a1, 4
	HTC_CONTEXT *pHTC = (HTC_CONTEXT *)context;
	adf_nbuf_t tmp_nbuf;
                
	if (hdr_buf == ADF_NBUF_NULL) {
		/* HTC hdr is not in the hdr_buf */
		tmp_nbuf = buffer;
  9043ef:	d750      	mov.n	a7, a5
	eid = pHTCHdr->EndpointID; 
    
	pEndpoint = &pHTC->Endpoints[eid];
	eidMask = 1 << eid;

	if (pHTCHdr->Flags & HTC_FLAGS_CREDIT_REDISTRIBUTION) {
  9043f1:	259001        	l8ui	a5, a9, 1
	adf_nbuf_peek_header(tmp_nbuf, &anbdata, &anblen);        
	pHTCHdr = (HTC_FRAME_HDR *)anbdata; 
      
	totsz = adf_os_ntohs(pHTCHdr->PayloadLen); 
    
	eid = pHTCHdr->EndpointID; 
  9043f4:	269000        	l8ui	a6, a9, 0
    
	pEndpoint = &pHTC->Endpoints[eid];
	eidMask = 1 << eid;

	if (pHTCHdr->Flags & HTC_FLAGS_CREDIT_REDISTRIBUTION) {
  9043f7:	7d5f76        	bbsi	a5, 29, 904471 <HTCMsgRecvHandler+0x95>
      
	totsz = adf_os_ntohs(pHTCHdr->PayloadLen); 
    
	eid = pHTCHdr->EndpointID; 
    
	pEndpoint = &pHTC->Endpoints[eid];
  9043fa:	066509        	addx2	a5, a6, a6
		 * Byte 0 */
		RedistributeCredit(tmp_nbuf, pHTCHdr->ControlBytes[0]);
		return;
	}

	if (pHTC->StateFlags & HTC_STATE_SETUP_COMPLETE) {
  9043fd:	284292        	l32i	a8, a4, 0x248
      
	totsz = adf_os_ntohs(pHTCHdr->PayloadLen); 
    
	eid = pHTCHdr->EndpointID; 
    
	pEndpoint = &pHTC->Endpoints[eid];
  904400:	04550b        	addx8	a5, a5, a4
  904403:	b455      	addi.n	a5, a5, 4
		 * Byte 0 */
		RedistributeCredit(tmp_nbuf, pHTCHdr->ControlBytes[0]);
		return;
	}

	if (pHTC->StateFlags & HTC_STATE_SETUP_COMPLETE) {
  904405:	7f8707        	bbci	a8, 31, 904410 <HTCMsgRecvHandler+0x34>
		/* after setup we keep track of credit consumption to allow us to
		 * adjust thresholds to reduce credit dribbling */  
		pEndpoint->CreditsConsumed ++;
  904408:	285105        	l16ui	a8, a5, 10
  90440b:	b188      	addi.n	a8, a8, 1
  90440d:	285505        	s16i	a8, a5, 10
	/* from the design document, we put the endpoint into a "host-needs-credit" state
	 * when we receive a frame with the NEED_CREDIT_UPDATE flag set .
	 * if the host received credits through an opportunistic path, then it can
	 * issue a another frame with this bit cleared, this signals the target to clear
	 * the "host-needs-credit" state */    
	if (pHTCHdr->Flags & HTC_FLAGS_NEED_CREDIT_UPDATE) {
  904410:	299001        	l8ui	a9, a9, 1
	totsz = adf_os_ntohs(pHTCHdr->PayloadLen); 
    
	eid = pHTCHdr->EndpointID; 
    
	pEndpoint = &pHTC->Endpoints[eid];
	eidMask = 1 << eid;
  904413:	c081      	movi.n	a8, 1
	/* from the design document, we put the endpoint into a "host-needs-credit" state
	 * when we receive a frame with the NEED_CREDIT_UPDATE flag set .
	 * if the host received credits through an opportunistic path, then it can
	 * issue a another frame with this bit cleared, this signals the target to clear
	 * the "host-needs-credit" state */    
	if (pHTCHdr->Flags & HTC_FLAGS_NEED_CREDIT_UPDATE) {
  904415:	090940        	extui	a9, a9, 0, 1
	totsz = adf_os_ntohs(pHTCHdr->PayloadLen); 
    
	eid = pHTCHdr->EndpointID; 
    
	pEndpoint = &pHTC->Endpoints[eid];
	eidMask = 1 << eid;
  904418:	006104        	ssl	a6
  90441b:	00881a        	sll	a8, a8
  90441e:	2a4285        	l32i	a10, a4, 0x214
	/* from the design document, we put the endpoint into a "host-needs-credit" state
	 * when we receive a frame with the NEED_CREDIT_UPDATE flag set .
	 * if the host received credits through an opportunistic path, then it can
	 * issue a another frame with this bit cleared, this signals the target to clear
	 * the "host-needs-credit" state */    
	if (pHTCHdr->Flags & HTC_FLAGS_NEED_CREDIT_UPDATE) {
  904421:	c997      	beqz.n	a9, 90443c <HTCMsgRecvHandler+0x60>
		/* the host is running low (or is out) of credits on this
		 * endpoint, update mask */
		pHTC->EpHostNeedsCreditMap |= eidMask; 
  904423:	08aa02        	or	a10, a10, a8
		/* check and set new threshold since host has reached a low credit situation */
		CHECK_AND_ADJUST_CREDIT_THRESHOLD(pEndpoint);                          
  904426:	295106        	l16ui	a9, a5, 12
	 * issue a another frame with this bit cleared, this signals the target to clear
	 * the "host-needs-credit" state */    
	if (pHTCHdr->Flags & HTC_FLAGS_NEED_CREDIT_UPDATE) {
		/* the host is running low (or is out) of credits on this
		 * endpoint, update mask */
		pHTC->EpHostNeedsCreditMap |= eidMask; 
  904429:	2a4685        	s32i	a10, a4, 0x214
		/* check and set new threshold since host has reached a low credit situation */
		CHECK_AND_ADJUST_CREDIT_THRESHOLD(pEndpoint);                          
  90442c:	7d971a        	bbci	a9, 29, 90444a <HTCMsgRecvHandler+0x6e>
  90442f:	da50      	mov.n	a10, a5
  904431:	9814      	s32i.n	a8, a1, 16
  904433:	5bff87        	call8	904250 <AdjustCreditThreshold>
  904436:	8814      	l32i.n	a8, a1, 16
  904438:	60000e        	j	90444a <HTCMsgRecvHandler+0x6e>
  90443b:	00c7bf        	excw
	} else {
		/* clear the flag */
		pHTC->EpHostNeedsCreditMap &= ~(eidMask);       
  90443e:	08bb03        	xor	a11, a11, a8
  904441:	0baa01        	and	a10, a10, a11
  904444:	2a4685        	s32i	a10, a4, 0x214
		pEndpoint->CreditReturnThreshhold = 0; 
  904447:	295504        	s16i	a9, a5, 8
 *         or NULL if there is not sufficient data to pull.
 */
static inline a_uint8_t *
adf_nbuf_pull_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_pull_head(buf, size);
  90444a:	da70      	mov.n	a10, a7
  90444c:	c0b8      	movi.n	a11, 8
  90444e:	281604        	s32i	a8, a1, 16
  904451:	5bfbeb        	call8	903400 <__adf_nbuf_pull_head>
	 *        as the result of parsing this message.  In either case, if there are
	 *        pending credits and the host needs them, a credit report will be sent either through 
	 *        the response message trailer or a NULL message through HTC_ReturnBuffers().
	 */       
        
	pEndpoint->pService->ProcessRecvMsg(eid, hdr_buf, buffer, pEndpoint->pService->ServiceCtx);
  904454:	8751      	l32i.n	a7, a5, 4
  904456:	da60      	mov.n	a10, a6
  904458:	8d76      	l32i.n	a13, a7, 24
  90445a:	8971      	l32i.n	a9, a7, 4
  90445c:	db20      	mov.n	a11, a2
  90445e:	033c02        	or	a12, a3, a3
  904461:	0b9000        	callx8	a9

	/* Calls to HTC_ReturnBuffers drives the endpoint credit reporting state machine. 
	 * We do not want to delay credits for too long in the event that the application is 
	 * holding onto buffers for excessive periods of time.  This gives us "some" better
	 * opportunities to send up credits. */
	HTCCheckAndSendCreditReport(pHTC, eidMask, pEndpoint, eid); 
  904464:	8814      	l32i.n	a8, a1, 16
  904466:	da40      	mov.n	a10, a4
  904468:	db80      	mov.n	a11, a8
  90446a:	dc50      	mov.n	a12, a5
  90446c:	dd60      	mov.n	a13, a6
  90446e:	5bfea5        	call8	903f04 <HTCCheckAndSendCreditReport>
  904471:	d10f      	retw.n
	...

00904474 <RedistributeCredit>:
	pEndpoint->CreditReturnThreshhold = creditsOutstanding;
    
}

LOCAL void RedistributeCredit(adf_nbuf_t buf, int toPipeId)
{
  904474:	6c1004        	entry	a1, 32
  904477:	d10f      	retw.n
  904479:	000000        	ill

0090447c <WMIServiceConnect>:
                                 HTC_ENDPOINT_ID eid, 
                                 A_UINT8 *pDataIn, 
                                 int LengthIn,
                                 A_UINT8 *pDataOut,
                                 int *pLengthOut)
{
  90447c:	6c1004        	entry	a1, 32
	WMI_SVC_CONTEXT *pWMI = (WMI_SVC_CONTEXT *)pService->ServiceCtx;
    
        /* save the eid to use */
	pWMI->ControlEp = eid;
  90447f:	8826      	l32i.n	a8, a2, 24
  904481:	938a      	s32i.n	a3, a8, 40
	return HTC_SERVICE_SUCCESS;
}
  904483:	c020      	movi.n	a2, 0
  904485:	d10f      	retw.n
	...

00904488 <_WMI_GetPendingEventsCount>:
    
	return pWMI;
}

static int _WMI_GetPendingEventsCount(wmi_handle_t handle)
{
  904488:	6c1004        	entry	a1, 32
	WMI_SVC_CONTEXT *pWMI = (WMI_SVC_CONTEXT *)handle;
	return pWMI->PendingEvents;
}
  90448b:	8222      	l32i.n	a2, a2, 8
  90448d:	d10f      	retw.n
	...

00904490 <_WMI_GetControlEp>:

static int  _WMI_GetControlEp(wmi_handle_t handle)
{
  904490:	6c1004        	entry	a1, 32
	WMI_SVC_CONTEXT *pWMI = (WMI_SVC_CONTEXT *)handle;
	return pWMI->ControlEp;
}
  904493:	822a      	l32i.n	a2, a2, 40
  904495:	d10f      	retw.n
	...

00904498 <_WMI_RegisterDispatchTable>:

static void _WMI_RegisterDispatchTable(wmi_handle_t handle,
				       WMI_DISPATCH_TABLE *pDispatchTable)
{
  904498:	6c1004        	entry	a1, 32
	WMI_SVC_CONTEXT *pWMI = (WMI_SVC_CONTEXT *)handle;
    
	if (NULL == pWMI->pDispatchHead) {
  90449b:	882b      	l32i.n	a8, a2, 44
  90449d:	cc83      	bnez.n	a8, 9044a4 <_WMI_RegisterDispatchTable+0xc>
		pWMI->pDispatchHead = pDispatchTable;
  90449f:	932b      	s32i.n	a3, a2, 44
  9044a1:	600003        	j	9044a8 <_WMI_RegisterDispatchTable+0x10>
		pWMI->pDispatchTail = pDispatchTable;        
	} else {
		/* link to the tail */
		pWMI->pDispatchTail->pNext = pDispatchTable;
  9044a4:	882c      	l32i.n	a8, a2, 48
  9044a6:	9380      	s32i.n	a3, a8, 0
		pWMI->pDispatchTail = pDispatchTable;        
  9044a8:	932c      	s32i.n	a3, a2, 48
  9044aa:	d10f      	retw.n

009044ac <_WMI_Shutdown>:
	
	HTC_SendMsg(pWMI->HtcHandle, pWMI->ControlEp, pEvt);    
}

static void _WMI_Shutdown(wmi_handle_t handle)
{
  9044ac:	6c1004        	entry	a1, 32
  9044af:	d10f      	retw.n
  9044b1:	000000        	ill

009044b4 <WMIRecvMessageHandler>:

#include "wmi_internal.h"

static void WMIRecvMessageHandler(HTC_ENDPOINT_ID EndPt, adf_nbuf_t hdr_buf,
				  adf_nbuf_t pHTCBuf, void *arg)
{
  9044b4:	6c1006        	entry	a1, 48
	int length;
	a_uint8_t *anbdata;
	a_uint32_t anblen;
	WMI_CMD_HDR *cmdHdr;
            
	adf_os_assert(hdr_buf == ADF_NBUF_NULL);
  9044b7:	c832      	beqz.n	a3, 9044bd <WMIRecvMessageHandler+0x9>
  9044b9:	63fffc        	j	9044b9 <WMIRecvMessageHandler+0x5>
  9044bc:	00da40        	extui	a10, a0, 13, 1
 * @return The total length of this buf.
 */
static inline adf_os_size_t
adf_nbuf_len(adf_nbuf_t buf)
{
    return (__adf_nbuf_len(buf));
  9044bf:	5bfc70        	call8	903680 <__adf_nbuf_len>
  9044c2:	d3a0      	mov.n	a3, a10

	do {
		length = adf_nbuf_len(pHTCBuf);
		if (length < sizeof(WMI_CMD_HDR)) {
  9044c4:	6ea465        	bltui	a10, 4, 90452d <WMIRecvMessageHandler+0x79>
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  9044c7:	b41b      	addi.n	a11, a1, 4
  9044c9:	dc10      	mov.n	a12, a1
  9044cb:	da40      	mov.n	a10, a4
  9044cd:	5bfc74        	call8	9036a0 <__adf_nbuf_peek_header>
		adf_nbuf_peek_header(pHTCBuf, &anbdata, &anblen);
        
		pCurrentTable = pWMI->pDispatchHead;
		length = length - sizeof(WMI_CMD_HDR);
        
		cmdHdr = (WMI_CMD_HDR *)anbdata;
  9044d0:	8d11      	l32i.n	a13, a1, 4
		}

		adf_nbuf_peek_header(pHTCBuf, &anbdata, &anblen);
        
		pCurrentTable = pWMI->pDispatchHead;
		length = length - sizeof(WMI_CMD_HDR);
  9044d2:	2e3cfc        	addi	a14, a3, -4
        
		cmdHdr = (WMI_CMD_HDR *)anbdata;
		cmd = adf_os_ntohs(cmdHdr->commandId);
  9044d5:	2bd000        	l8ui	a11, a13, 0
  9044d8:	23d001        	l8ui	a3, a13, 1
		seq = adf_os_ntohs(cmdHdr->seqNo);
  9044db:	2cd002        	l8ui	a12, a13, 2
        
		pCurrentTable = pWMI->pDispatchHead;
		length = length - sizeof(WMI_CMD_HDR);
        
		cmdHdr = (WMI_CMD_HDR *)anbdata;
		cmd = adf_os_ntohs(cmdHdr->commandId);
  9044de:	08bb11        	slli	a11, a11, 8
  9044e1:	0b3b02        	or	a11, a3, a11
		seq = adf_os_ntohs(cmdHdr->seqNo);
  9044e4:	23d003        	l8ui	a3, a13, 3
  9044e7:	08cc11        	slli	a12, a12, 8
			break;    
		}

		adf_nbuf_peek_header(pHTCBuf, &anbdata, &anblen);
        
		pCurrentTable = pWMI->pDispatchHead;
  9044ea:	885b      	l32i.n	a8, a5, 44
		length = length - sizeof(WMI_CMD_HDR);
        
		cmdHdr = (WMI_CMD_HDR *)anbdata;
		cmd = adf_os_ntohs(cmdHdr->commandId);
		seq = adf_os_ntohs(cmdHdr->seqNo);
  9044ec:	0c3c02        	or	a12, a3, a12
        
		pCmdBuffer = anbdata + sizeof(WMI_CMD_HDR); 
  9044ef:	b4dd      	addi.n	a13, a13, 4
		pCmdHandler = NULL;
        
		while (pCurrentTable != NULL) {
  9044f1:	600035        	j	90452a <WMIRecvMessageHandler+0x76>
            
			pContext = pCurrentTable->pContext;
  9044f4:	8a81      	l32i.n	a10, a8, 4
			pCurrentEntry = pCurrentTable->pTable;
  9044f6:	8983      	l32i.n	a9, a8, 12
        
			/* scan table entries */
			for (i = 0; i < pCurrentTable->NumberOfEntries; i++, pCurrentEntry++) {
  9044f8:	8382      	l32i.n	a3, a8, 8
  9044fa:	c0f0      	movi.n	a15, 0
  9044fc:	600018        	j	904518 <WMIRecvMessageHandler+0x64>
  9044ff:	002691        	excw
				if (pCurrentEntry->CmdID == cmd) {
  904502:	027b69        	excw
  904505:	0d2391        	excw
					/* found a match */
					pCmdHandler = pCurrentEntry->pCmdHandler;
        
					/* optionally check length */
					if ((pCurrentEntry->CheckLength != 0) &&
  904508:	038f90        	l32e	a3, a8, -4
  90450b:	c931      	beqz.n	a3, 904520 <WMIRecvMessageHandler+0x6c>
  90450d:	73e217        	blt	a14, a3, 904528 <WMIRecvMessageHandler+0x74>
  904510:	60000c        	j	904520 <WMIRecvMessageHandler+0x6c>
  904513:	00b1ff        	excw
            
			pContext = pCurrentTable->pContext;
			pCurrentEntry = pCurrentTable->pTable;
        
			/* scan table entries */
			for (i = 0; i < pCurrentTable->NumberOfEntries; i++, pCurrentEntry++) {
  904516:	b899      	addi.n	a9, a9, 8
  904518:	73f2e4        	blt	a15, a3, 904500 <WMIRecvMessageHandler+0x4c>
  90451b:	600009        	j	904528 <WMIRecvMessageHandler+0x74>
  90451e:	0000c8        	excw
					/* end search */                
					break;    
				}                        
			} 
            
			if (pCmdHandler != NULL) {
  904521:	f4          	.byte 0xf4
		}
            
		/* if we get here, we have a command handler to dispatch */
                
		/* call dispatch function */
		pCmdHandler(pContext, cmd, seq, pCmdBuffer, length);
  904522:	0bf000        	callx8	a15
  904525:	600004        	j	90452d <WMIRecvMessageHandler+0x79>
				/* found a handler */
				break;
			}
                
			/* scan next table */
			pCurrentTable = pCurrentTable->pNext;
  904528:	8880      	l32i.n	a8, a8, 0
		seq = adf_os_ntohs(cmdHdr->seqNo);
        
		pCmdBuffer = anbdata + sizeof(WMI_CMD_HDR); 
		pCmdHandler = NULL;
        
		while (pCurrentTable != NULL) {
  90452a:	658fc6        	bnez	a8, 9044f4 <WMIRecvMessageHandler+0x40>
        /* Invalidate the buffer (including HTC header). Note : we only need to invalidate up to the portion
	 * that was used (cache invalidate will also round up to the nearest cache line).  
	 * The rest of the buffer should still be coherent.
	 * */

	HTC_ReturnBuffers(pWMI->HtcHandle, EndPt, pHTCBuf);         
  90452d:	137184        	l32r	a3, 8e0b40 <_bss_end+0x3d3338>
  904530:	8a50      	l32i.n	a10, a5, 0
  904532:	233287        	l32i	a3, a3, 0x21c
  904535:	db20      	mov.n	a11, a2
  904537:	dc40      	mov.n	a12, a4
  904539:	0b3000        	callx8	a3
  90453c:	d10f      	retw.n
	...

00904540 <_WMI_SendCompleteHandler>:
}

/* send completion handler when any HTC buffers are returned */
static void _WMI_SendCompleteHandler(HTC_ENDPOINT_ID Endpt, adf_nbuf_t pHTCBuf, void *arg)
{
  904540:	6c1004        	entry	a1, 32
 * @return data pointer to typecast into your priv structure
 */
static inline a_uint8_t *
adf_nbuf_get_priv(adf_nbuf_t buf)
{
    return (__adf_nbuf_get_priv(buf));
  904543:	da30      	mov.n	a10, a3
  904545:	5bfbc9        	call8	90346c <__adf_nbuf_get_priv>
		poolId = POOL_ID_WMI_SVC_EVENT;
	} else {
		poolId = POOL_ID_WMI_SVC_CMD_REPLY;
	}
        
	BUF_Pool_free_buf(pWMI->PoolHandle, poolId, pHTCBuf);
  904548:	187184        	l32r	a8, 8e0b58 <_bss_end+0x3d3350>
	WMI_BUF_CONTEXT *ctx;
	BUF_POOL_ID poolId;
    
	ctx = (WMI_BUF_CONTEXT *)adf_nbuf_get_priv(pHTCBuf);
        
	if ( ctx->EventClass == WMI_EVT_CLASS_CMD_EVENT ) {
  90454b:	8ca1      	l32i.n	a12, a10, 4
		poolId = POOL_ID_WMI_SVC_EVENT;
	} else {
		poolId = POOL_ID_WMI_SVC_CMD_REPLY;
	}
        
	BUF_Pool_free_buf(pWMI->PoolHandle, poolId, pHTCBuf);
  90454d:	c092      	movi.n	a9, 2
  90454f:	2882a3        	l32i	a8, a8, 0x28c
  904552:	8a41      	l32i.n	a10, a4, 4
  904554:	c0b1      	movi.n	a11, 1
  904556:	0c9b38        	moveqz	a11, a9, a12
  904559:	dc30      	mov.n	a12, a3
  90455b:	0b8000        	callx8	a8
  90455e:	d10f      	retw.n

00904560 <_WMI_AllocEvent>:
	}
}

static adf_nbuf_t _WMI_AllocEvent(wmi_handle_t handle, WMI_EVT_CLASS EventClass,
				  int Length)
{     
  904560:	6c1004        	entry	a1, 32
		poolId = POOL_ID_WMI_SVC_EVENT;
	} else {
		poolId = POOL_ID_WMI_SVC_CMD_REPLY;
	}
    
	buf = BUF_Pool_alloc_buf(pWMI->PoolHandle, 
  904563:	187184        	l32r	a8, 8e0b74 <_bss_end+0x3d336c>
	WMI_SVC_CONTEXT *pWMI = (WMI_SVC_CONTEXT *)handle;
	adf_nbuf_t buf;
	WMI_BUF_CONTEXT *ctx;
    
	if ( EventClass == WMI_EVT_CLASS_CMD_EVENT ) {
		poolId = POOL_ID_WMI_SVC_EVENT;
  904566:	c051      	movi.n	a5, 1
  904568:	c042      	movi.n	a4, 2
  90456a:	035439        	movnez	a4, a5, a3
	} else {
		poolId = POOL_ID_WMI_SVC_CMD_REPLY;
	}
    
	buf = BUF_Pool_alloc_buf(pWMI->PoolHandle, 
  90456d:	8a20      	l32i.n	a10, a2, 0
  90456f:	2582a1        	l32i	a5, a8, 0x284
  904572:	28828a        	l32i	a8, a8, 0x228
  904575:	8621      	l32i.n	a6, a2, 4
  904577:	0b8000        	callx8	a8
  90457a:	b4ac      	addi.n	a12, a10, 4
  90457c:	044b02        	or	a11, a4, a4
  90457f:	066a02        	or	a10, a6, a6
  904582:	0b5000        	callx8	a5
  904585:	d2a0      	mov.n	a2, a10
				 poolId, 
				 sizeof(WMI_CMD_HDR) + HTC_GetReservedHeadroom(pWMI->HtcHandle));
     
	if ( buf != NULL ) {
  904587:	c8a3      	beqz.n	a10, 90458e <_WMI_AllocEvent+0x2e>
  904589:	5bfbb8        	call8	90346c <__adf_nbuf_get_priv>
		ctx = (WMI_BUF_CONTEXT *)adf_nbuf_get_priv(buf);
		ctx->EventClass = EventClass;
  90458c:	93a1      	s32i.n	a3, a10, 4
	}
	return buf;
}
  90458e:	d10f      	retw.n

00904590 <_WMI_SendEvent>:

static void _WMI_SendEvent(wmi_handle_t handle, adf_nbuf_t pEvt, 
                           A_UINT16 EventId, A_UINT16 SeqNo, int Length)
{
  904590:	6c1004        	entry	a1, 32
 *         or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_push_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_push_head(buf, size);
  904593:	033a02        	or	a10, a3, a3
  904596:	2b0a04        	movi	a11, 4
  904599:	5bfb8e        	call8	9033d4 <__adf_nbuf_push_head>
  90459c:	04044f        	extui	a4, a4, 0, 16
  90459f:	05054f        	extui	a5, a5, 0, 16
	WMI_SVC_CONTEXT *pWMI = (WMI_SVC_CONTEXT *)handle;
	A_UINT8 *pBuffer;
        
	pBuffer = adf_nbuf_push_head(pEvt, sizeof(WMI_CMD_HDR));
	A_SET_UINT16_FIELD(pBuffer, WMI_CMD_HDR, commandId, adf_os_htons(EventId));        
  9045a2:	24a401        	s8i	a4, a10, 1
  9045a5:	048814        	srli	a8, a4, 8
	A_SET_UINT16_FIELD(pBuffer, WMI_CMD_HDR, seqNo, adf_os_htons(SeqNo));
  9045a8:	058414        	srli	a4, a5, 8
  9045ab:	24a402        	s8i	a4, a10, 2
	
	HTC_SendMsg(pWMI->HtcHandle, pWMI->ControlEp, pEvt);    
  9045ae:	147184        	l32r	a4, 8e0bc0 <_bss_end+0x3d33b8>
{
	WMI_SVC_CONTEXT *pWMI = (WMI_SVC_CONTEXT *)handle;
	A_UINT8 *pBuffer;
        
	pBuffer = adf_nbuf_push_head(pEvt, sizeof(WMI_CMD_HDR));
	A_SET_UINT16_FIELD(pBuffer, WMI_CMD_HDR, commandId, adf_os_htons(EventId));        
  9045b1:	28a400        	s8i	a8, a10, 0
	A_SET_UINT16_FIELD(pBuffer, WMI_CMD_HDR, seqNo, adf_os_htons(SeqNo));
  9045b4:	25a403        	s8i	a5, a10, 3
	
	HTC_SendMsg(pWMI->HtcHandle, pWMI->ControlEp, pEvt);    
  9045b7:	244289        	l32i	a4, a4, 0x224
  9045ba:	8a20      	l32i.n	a10, a2, 0
  9045bc:	8b2a      	l32i.n	a11, a2, 40
  9045be:	033c02        	or	a12, a3, a3
  9045c1:	0b4000        	callx8	a4
  9045c4:	d10f      	retw.n
	...

009045c8 <_WMI_Init>:
}

/**************  public APIS ********************************************/
    
static wmi_handle_t _WMI_Init(WMI_SVC_CONFIG *pWmiConfig)
{
  9045c8:	6c1004        	entry	a1, 32
#include "Magpie_api.h"

static inline void *	__adf_os_mem_alloc(adf_os_size_t size)
{
//    return (malloc(size,M_DEVBUF,M_DONTWAIT | M_ZERO));
    return A_ALLOCRAM(size);
  9045cb:	137184        	l32r	a3, 8e0bdc <_bss_end+0x3d33d4>
  9045ce:	d420      	mov.n	a4, a2
  9045d0:	223252        	l32i	a2, a3, 0x148
  9045d3:	c0a0      	movi.n	a10, 0
  9045d5:	c3b8      	movi.n	a11, 56
  9045d7:	0b2000        	callx8	a2
  9045da:	d2a0      	mov.n	a2, a10
	WMI_SVC_CONTEXT *pWMI = NULL;
	int eventSize = WMI_SVC_MAX_BUFFERED_EVENT_SIZE + sizeof(WMI_CMD_HDR) + HTC_HDR_SZ;
    
	pWMI = (WMI_SVC_CONTEXT *)adf_os_mem_alloc(sizeof(WMI_SVC_CONTEXT));
	if (pWMI == NULL) {
  9045dc:	64a055        	beqz	a10, 904635 <_WMI_Init+0x6d>
		return NULL;    
	}
        
	pWMI->pDispatchHead = NULL;
  9045df:	c080      	movi.n	a8, 0
  9045e1:	98ab      	s32i.n	a8, a10, 44
	pWMI->PoolHandle = pWmiConfig->PoolHandle;
	pWMI->HtcHandle = pWmiConfig->HtcHandle;    
  9045e3:	8840      	l32i.n	a8, a4, 0
	if (pWMI == NULL) {
		return NULL;    
	}
        
	pWMI->pDispatchHead = NULL;
	pWMI->PoolHandle = pWmiConfig->PoolHandle;
  9045e5:	8a41      	l32i.n	a10, a4, 4
	pWMI->HtcHandle = pWmiConfig->HtcHandle;    
                                         
	BUF_Pool_create_pool(pWmiConfig->PoolHandle, POOL_ID_WMI_SVC_CMD_REPLY, 
  9045e7:	8c42      	l32i.n	a12, a4, 8
		return NULL;    
	}
        
	pWMI->pDispatchHead = NULL;
	pWMI->PoolHandle = pWmiConfig->PoolHandle;
	pWMI->HtcHandle = pWmiConfig->HtcHandle;    
  9045e9:	9820      	s32i.n	a8, a2, 0
                                         
	BUF_Pool_create_pool(pWmiConfig->PoolHandle, POOL_ID_WMI_SVC_CMD_REPLY, 
  9045eb:	2832a0        	l32i	a8, a3, 0x280
	if (pWMI == NULL) {
		return NULL;    
	}
        
	pWMI->pDispatchHead = NULL;
	pWMI->PoolHandle = pWmiConfig->PoolHandle;
  9045ee:	9a21      	s32i.n	a10, a2, 4
	pWMI->HtcHandle = pWmiConfig->HtcHandle;    
                                         
	BUF_Pool_create_pool(pWmiConfig->PoolHandle, POOL_ID_WMI_SVC_CMD_REPLY, 
  9045f0:	2b0a01        	movi	a11, 1
  9045f3:	2d0a70        	movi	a13, 112
  9045f6:	0b8000        	callx8	a8
			     pWmiConfig->MaxCmdReplyEvts, eventSize);
        
	BUF_Pool_create_pool(pWmiConfig->PoolHandle, POOL_ID_WMI_SVC_EVENT, 
  9045f9:	2832a0        	l32i	a8, a3, 0x280
  9045fc:	8a41      	l32i.n	a10, a4, 4
  9045fe:	8c43      	l32i.n	a12, a4, 12
  904600:	c0b2      	movi.n	a11, 2
  904602:	2d0a70        	movi	a13, 112
  904605:	0b8000        	callx8	a8
            
	/* NOTE: since RAM allocation is zero-initialized, there is nothing to do for the 
	 * direct event pool */
     
        /* register the WMI control service */
	pWMI->WMIControlService.ProcessRecvMsg = A_INDIR(wmi_svc_api._WMI_RecvMessageHandler);
  904608:	283298        	l32i	a8, a3, 0x260
         * in size.  Any WMI event that supplies a data buffer must insure that the space in the buffer
         * is at least this size. */
	pWMI->WMIControlService.TrailerSpcCheckLimit = WMI_SVC_MAX_BUFFERED_EVENT_SIZE; 
	pWMI->WMIControlService.ServiceID = WMI_CONTROL_SVC;
	pWMI->WMIControlService.ServiceCtx = pWMI;
	HTC_RegisterService(pWmiConfig->HtcHandle, &pWMI->WMIControlService);
  90460b:	8a40      	l32i.n	a10, a4, 0
            
	/* NOTE: since RAM allocation is zero-initialized, there is nothing to do for the 
	 * direct event pool */
     
        /* register the WMI control service */
	pWMI->WMIControlService.ProcessRecvMsg = A_INDIR(wmi_svc_api._WMI_RecvMessageHandler);
  90460d:	9824      	s32i.n	a8, a2, 16
	pWMI->WMIControlService.ProcessSendBufferComplete = A_INDIR(wmi_svc_api._WMI_SendCompleteHandler);
  90460f:	283295        	l32i	a8, a3, 0x254
         * in size.  Any WMI event that supplies a data buffer must insure that the space in the buffer
         * is at least this size. */
	pWMI->WMIControlService.TrailerSpcCheckLimit = WMI_SVC_MAX_BUFFERED_EVENT_SIZE; 
	pWMI->WMIControlService.ServiceID = WMI_CONTROL_SVC;
	pWMI->WMIControlService.ServiceCtx = pWMI;
	HTC_RegisterService(pWmiConfig->HtcHandle, &pWMI->WMIControlService);
  904612:	bc2b      	addi.n	a11, a2, 12
	/* NOTE: since RAM allocation is zero-initialized, there is nothing to do for the 
	 * direct event pool */
     
        /* register the WMI control service */
	pWMI->WMIControlService.ProcessRecvMsg = A_INDIR(wmi_svc_api._WMI_RecvMessageHandler);
	pWMI->WMIControlService.ProcessSendBufferComplete = A_INDIR(wmi_svc_api._WMI_SendCompleteHandler);
  904614:	9825      	s32i.n	a8, a2, 20
	pWMI->WMIControlService.ProcessConnect = A_INDIR(wmi_svc_api._WMI_ServiceConnect);
  904616:	283299        	l32i	a8, a3, 0x264
         * in size.  Any WMI event that supplies a data buffer must insure that the space in the buffer
         * is at least this size. */
	pWMI->WMIControlService.TrailerSpcCheckLimit = WMI_SVC_MAX_BUFFERED_EVENT_SIZE; 
	pWMI->WMIControlService.ServiceID = WMI_CONTROL_SVC;
	pWMI->WMIControlService.ServiceCtx = pWMI;
	HTC_RegisterService(pWmiConfig->HtcHandle, &pWMI->WMIControlService);
  904619:	233285        	l32i	a3, a3, 0x214
	 * direct event pool */
     
        /* register the WMI control service */
	pWMI->WMIControlService.ProcessRecvMsg = A_INDIR(wmi_svc_api._WMI_RecvMessageHandler);
	pWMI->WMIControlService.ProcessSendBufferComplete = A_INDIR(wmi_svc_api._WMI_SendCompleteHandler);
	pWMI->WMIControlService.ProcessConnect = A_INDIR(wmi_svc_api._WMI_ServiceConnect);
  90461c:	9826      	s32i.n	a8, a2, 24
	pWMI->WMIControlService.MaxSvcMsgSize = WMI_SVC_MSG_SIZE + sizeof(WMI_CMD_HDR);
  90461e:	286a04        	movi	a8, 0x604
  904621:	282510        	s16i	a8, a2, 32
        /* all buffers that are sent through the control endpoint are at least WMI_SVC_MAX_BUFFERED_EVENT_SIZE 
         * in size.  Any WMI event that supplies a data buffer must insure that the space in the buffer
         * is at least this size. */
	pWMI->WMIControlService.TrailerSpcCheckLimit = WMI_SVC_MAX_BUFFERED_EVENT_SIZE; 
  904624:	280a64        	movi	a8, 100
  904627:	282511        	s16i	a8, a2, 34
	pWMI->WMIControlService.ServiceID = WMI_CONTROL_SVC;
  90462a:	281a00        	movi	a8, 0x100
  90462d:	28250e        	s16i	a8, a2, 28
	pWMI->WMIControlService.ServiceCtx = pWMI;
  904630:	9229      	s32i.n	a2, a2, 36
	HTC_RegisterService(pWmiConfig->HtcHandle, &pWMI->WMIControlService);
  904632:	0b3000        	callx8	a3
    
	return pWMI;
}
  904635:	d10f      	retw.n
	...

00904638 <WMI_service_module_install>:

	adf_os_mem_free(pWMI);
}

void WMI_service_module_install(WMI_SVC_APIS *pTbl)
{
  904638:	6c1004        	entry	a1, 32
	pTbl->_WMI_Init                     = _WMI_Init;
  90463b:	1871fc        	l32r	a8, 8e0e2c <_bss_end+0x3d3624>
  90463e:	9820      	s32i.n	a8, a2, 0
	pTbl->_WMI_RegisterDispatchTable    = _WMI_RegisterDispatchTable;
  904640:	1871fd        	l32r	a8, 8e0e34 <_bss_end+0x3d362c>
  904643:	9821      	s32i.n	a8, a2, 4
	pTbl->_WMI_AllocEvent               = _WMI_AllocEvent;
  904645:	1871fe        	l32r	a8, 8e0e40 <_bss_end+0x3d3638>
  904648:	9822      	s32i.n	a8, a2, 8
	pTbl->_WMI_SendEvent                = _WMI_SendEvent;
  90464a:	1871ff        	l32r	a8, 8e0e48 <_bss_end+0x3d3640>
  90464d:	9823      	s32i.n	a8, a2, 12
	pTbl->_WMI_SendCompleteHandler      = _WMI_SendCompleteHandler;
  90464f:	187200        	l32r	a8, 8e0e50 <_bss_end+0x3d3648>
  904652:	9825      	s32i.n	a8, a2, 20
	pTbl->_WMI_GetPendingEventsCount    = _WMI_GetPendingEventsCount;
  904654:	187201        	l32r	a8, 8e0e58 <_bss_end+0x3d3650>
  904657:	9824      	s32i.n	a8, a2, 16
	pTbl->_WMI_GetControlEp             = _WMI_GetControlEp;
  904659:	187202        	l32r	a8, 8e0e64 <_bss_end+0x3d365c>
  90465c:	9826      	s32i.n	a8, a2, 24
	pTbl->_WMI_Shutdown                 = _WMI_Shutdown;
  90465e:	187203        	l32r	a8, 8e0e6c <_bss_end+0x3d3664>
  904661:	9827      	s32i.n	a8, a2, 28
	pTbl->_WMI_RecvMessageHandler       = WMIRecvMessageHandler;
  904663:	187204        	l32r	a8, 8e0e74 <_bss_end+0x3d366c>
  904666:	9828      	s32i.n	a8, a2, 32
	pTbl->_WMI_ServiceConnect           = WMIServiceConnect;
  904668:	187205        	l32r	a8, 8e0e7c <_bss_end+0x3d3674>
  90466b:	9829      	s32i.n	a8, a2, 36
  90466d:	d10f      	retw.n
	...

00904670 <_HIFusb_get_max_msg_len_patch>:

/*
 * -- support more than 64 bytes command on ep4 -- 
 */
int _HIFusb_get_max_msg_len_patch(hif_handle_t handle, int pipe)
{
  904670:	6c1004        	entry	a1, 32
  904673:	233cfd        	addi	a3, a3, -3
    switch(pipe) {
  904676:	222a00        	movi	a2, 0x200
  904679:	6e3202        	bltui	a3, 2, 90467f <_HIFusb_get_max_msg_len_patch+0xf>
  90467c:	226a40        	movi	a2, 0x640
            return 512;
            
        default:
            return 1600;
    }
}
  90467f:	d10f      	retw.n
  904681:	000000        	ill

00904684 <_HIFusb_isr_handler_patch>:

/*
 * -- move the usb_task to here --
 */
void _HIFusb_isr_handler_patch(hif_handle_t h)
{
  904684:	6c1004        	entry	a1, 32
    A_USB_FW_TASK();
  904687:	187184        	l32r	a8, 8e0c98 <_bss_end+0x3d3490>
  90468a:	28821d        	l32i	a8, a8, 116
  90468d:	0b8000        	callx8	a8

    _HIFusb_isr_handler();
  904690:	5b7931        	call8	8e2b58 <_HIFusb_isr_handler>
  904693:	d10f      	retw.n
  904695:	000000        	ill

00904698 <io8_rmw>:
	*(volatile uint32_t *) addr = b;
}

static inline void io8_rmw(volatile uint32_t addr,
			    const uint8_t set, const uint8_t clr)
{
  904698:	6c1006        	entry	a1, 48
  90469b:	0c0200        	memw
  90469e:	9210      	s32i.n	a2, a1, 0
	uint8_t val;

	val = ioread8(addr);
  9046a0:	0c0200        	memw
  9046a3:	8810      	l32i.n	a8, a1, 0
	val &= ~clr;
  9046a5:	c79f      	movi.n	a9, -1

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  9046a7:	288000        	l8ui	a8, a8, 0
			    const uint8_t set, const uint8_t clr)
{
	uint8_t val;

	val = ioread8(addr);
	val &= ~clr;
  9046aa:	049403        	xor	a4, a9, a4

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  9046ad:	080847        	extui	a8, a8, 0, 8
			    const uint8_t set, const uint8_t clr)
{
	uint8_t val;

	val = ioread8(addr);
	val &= ~clr;
  9046b0:	084801        	and	a8, a4, a8
	val |= set;
	iowrite8(addr, val);
  9046b3:	0c0200        	memw
  9046b6:	8a10      	l32i.n	a10, a1, 0
{
	uint8_t val;

	val = ioread8(addr);
	val &= ~clr;
	val |= set;
  9046b8:	038302        	or	a3, a8, a3
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  9046bb:	0c0200        	memw
  9046be:	23a400        	s8i	a3, a10, 0
  9046c1:	d10f      	retw.n
	...

009046c4 <io32_rmw$constprop$0>:
	val &= ~clr;
	val |= set;
	iowrite8(addr, val);
}

static inline void io32_rmw(volatile uint32_t addr,
  9046c4:	6c1006        	entry	a1, 48
  9046c7:	0c0200        	memw
  9046ca:	9210      	s32i.n	a2, a1, 0
			    const uint32_t set, const uint32_t clr)
{
	uint32_t val;

	val = ioread32(addr);
  9046cc:	0c0200        	memw
  9046cf:	8810      	l32i.n	a8, a1, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  9046d1:	0c0200        	memw
  9046d4:	8880      	l32i.n	a8, a8, 0
	uint32_t val;

	val = ioread32(addr);
	val &= ~clr;
	val |= set;
	iowrite32(addr, val);
  9046d6:	0c0200        	memw
  9046d9:	8910      	l32i.n	a9, a1, 0
{
	uint32_t val;

	val = ioread32(addr);
	val &= ~clr;
	val |= set;
  9046db:	083302        	or	a3, a3, a8
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  9046de:	0c0200        	memw
  9046e1:	9390      	s32i.n	a3, a9, 0
  9046e3:	d10f      	retw.n
  9046e5:	000000        	ill

009046e8 <_fw_usb_suspend_reboot>:
#if SYSTEM_MODULE_USB

#define CHECK_SOF_LOOP_CNT    50

void _fw_usb_suspend_reboot()
{
  9046e8:	6c1008        	entry	a1, 64
	volatile uint32_t gpio_in = 0;
  9046eb:	c020      	movi.n	a2, 0
  9046ed:	0c0200        	memw
  9046f0:	9214      	s32i.n	a2, a1, 16
	volatile uint32_t pupd = 0;
  9046f2:	0c0200        	memw
  9046f5:	9213      	s32i.n	a2, a1, 12
	volatile uint32_t t = 0;
  9046f7:	0c0200        	memw
  9046fa:	9212      	s32i.n	a2, a1, 8
	volatile uint32_t sof_no=0,sof_no_new=0;
	/* Set GO_TO_SUSPEND bit to USB main control register */
	io8_clr_usb(ZM_INTR_SOURCE_7_OFFSET, BIT2);
  9046fc:	1a7206        	l32r	a10, 8e0f14 <_bss_end+0x3d370c>
  9046ff:	db20      	mov.n	a11, a2
  904701:	c0c4      	movi.n	a12, 4
void _fw_usb_suspend_reboot()
{
	volatile uint32_t gpio_in = 0;
	volatile uint32_t pupd = 0;
	volatile uint32_t t = 0;
	volatile uint32_t sof_no=0,sof_no_new=0;
  904703:	0c0200        	memw
  904706:	9211      	s32i.n	a2, a1, 4
  904708:	0c0200        	memw
  90470b:	9210      	s32i.n	a2, a1, 0
	/* Set GO_TO_SUSPEND bit to USB main control register */
	io8_clr_usb(ZM_INTR_SOURCE_7_OFFSET, BIT2);
  90470d:	5bffe2        	call8	904698 <io8_rmw>
	A_PRINTF("!USB suspend\n\r");
  904710:	137184        	l32r	a3, 8e0d20 <_bss_end+0x3d3518>
  904713:	1a7207        	l32r	a10, 8e0f30 <_bss_end+0x3d3728>
  904716:	283212        	l32i	a8, a3, 72
  904719:	0b8000        	callx8	a8
  90471c:	197192        	l32r	a9, 8e0d64 <_bss_end+0x3d355c>
  90471f:	187189        	l32r	a8, 8e0d44 <_bss_end+0x3d353c>
  904722:	0c0200        	memw
  904725:	9980      	s32i.n	a9, a8, 0
#elif defined(PROJECT_K2)
	iowrite32(MAGPIE_REG_RST_STATUS_ADDR, SUS_MAGIC_PATTERN);
#endif /* #if defined(PROJECT_MAGPIE) */

	/* Reset USB FIFO */
	A_USB_RESET_FIFO();
  904727:	283229        	l32i	a8, a3, 164
  90472a:	0b8000        	callx8	a8

	/* Turn off power */
	A_USB_POWER_OFF();
  90472d:	233228        	l32i	a3, a3, 160
  904730:	0b3000        	callx8	a3

	DEBUG_SYSTEM_STATE = (DEBUG_SYSTEM_STATE&(~0xffff)) | 0x1000;
  904733:	137182        	l32r	a3, 8e0d3c <_bss_end+0x3d3534>
  904736:	187208        	l32r	a8, 8e0f58 <_bss_end+0x3d3750>
  904739:	0c0200        	memw
  90473c:	8930      	l32i.n	a9, a3, 0
  90473e:	089801        	and	a8, a9, a8
  904741:	197209        	l32r	a9, 8e0f68 <_bss_end+0x3d3760>
  904744:	098802        	or	a8, a8, a9
  904747:	0c0200        	memw
  90474a:	9830      	s32i.n	a8, a3, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90474c:	13720a        	l32r	a3, 8e0f74 <_bss_end+0x3d376c>
  90474f:	0c0200        	memw
  904752:	8830      	l32i.n	a8, a3, 0
	/* disable SPI */
	spi = ioread32(0x50040);
	iowrite32(0x50040, spi & ~BIT8);
#endif
	/* set all GPIO to input */
	gpio_in = ioread32(0x1000404c);
  904754:	0c0200        	memw
  904757:	9814      	s32i.n	a8, a1, 16
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  904759:	0c0200        	memw
  90475c:	9230      	s32i.n	a2, a3, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90475e:	13720b        	l32r	a3, 8e0f8c <_bss_end+0x3d3784>
  904761:	0c0200        	memw
  904764:	8830      	l32i.n	a8, a3, 0
	iowrite32(0x1000404c, 0x0);

	/* set PU/PD for all GPIO except two UART pins */
	pupd = ioread32(0x10004088);
  904766:	0c0200        	memw
  904769:	9813      	s32i.n	a8, a1, 12
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90476b:	18720c        	l32r	a8, 8e0f9c <_bss_end+0x3d3794>
  90476e:	0c0200        	memw
  904771:	9830      	s32i.n	a8, a3, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  904773:	13720d        	l32r	a3, 8e0fa8 <_bss_end+0x3d37a0>
  904776:	0c0200        	memw
  904779:	8330      	l32i.n	a3, a3, 0
	iowrite32(0x10004088, 0xA982AA6A);

	sof_no = ioread32(0x10004);
  90477b:	0c0200        	memw
  90477e:	9311      	s32i.n	a3, a1, 4
	for (t = 0; t < CHECK_SOF_LOOP_CNT; t++)
  904780:	0c0200        	memw
  904783:	9212      	s32i.n	a2, a1, 8
  904785:	c321      	movi.n	a2, 49
  904787:	600057        	j	9047e2 <_fw_usb_suspend_reboot+0xfa>
  90478a:	000013        	srai	a0, a0, 16
	{
		A_DELAY_USECS(1000);    /* delay 1ms */
  90478d:	71842a        	ball	a8, a1, 9047bb <_fw_usb_suspend_reboot+0xd3>
  904790:	3ae823        	excw
  904793:	323a0b        	excw
  904796:	300013        	excw
  904799:	720d0c        	bbs	a0, a2, 9047a9 <_fw_usb_suspend_reboot+0xc1>
  90479c:	020083        	excw
  90479f:	300c02        	excw
		sof_no_new = ioread32(0x10004);
  9047a2:	009310        	slli	a3, a9, 32

		if(sof_no_new == sof_no)
  9047a5:	0c0200        	memw
  9047a8:	8810      	l32i.n	a8, a1, 0
  9047aa:	0c0200        	memw
  9047ad:	8311      	l32i.n	a3, a1, 4
  9047af:	738919        	bne	a8, a3, 9047cc <_fw_usb_suspend_reboot+0xe4>
	 * Reset "printf" module patch point(RAM to ROM)
	 * when K2 warm start or suspend,
	 * which fixed the error issue cause by redownload
	 * another different firmware.
	 */
	_indir_tbl.cmnos.printf._printf = save_cmnos_printf;
  9047b2:	12718b        	l32r	a2, 8e0de0 <_bss_end+0x3d35d8>
  9047b5:	8320      	l32i.n	a3, a2, 0
  9047b7:	127184        	l32r	a2, 8e0dc8 <_bss_end+0x3d35c0>
  9047ba:	232612        	s32i	a3, a2, 72

	/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	 * setting the go suspend here, power down right away!!!
	 */
	if (t != CHECK_SOF_LOOP_CNT)   /* not time out */
  9047bd:	0c0200        	memw
  9047c0:	8312      	l32i.n	a3, a1, 8
  9047c2:	c322      	movi.n	a2, 50
  9047c4:	723925        	bne	a3, a2, 9047ed <_fw_usb_suspend_reboot+0x105>
  9047c7:	60002a        	j	9047f5 <_fw_usb_suspend_reboot+0x10d>
  9047ca:	00000c        	sub	a0, a0, a0
		A_DELAY_USECS(1000);    /* delay 1ms */
		sof_no_new = ioread32(0x10004);

		if(sof_no_new == sof_no)
			break;
		sof_no = sof_no_new;
  9047cd:	020083        	excw
  9047d0:	100c02        	l32r	a0, 8c77d8 <_bss_end+0x3b9fd0>
  9047d3:	009311        	slli	a3, a9, 16
	/* set PU/PD for all GPIO except two UART pins */
	pupd = ioread32(0x10004088);
	iowrite32(0x10004088, 0xA982AA6A);

	sof_no = ioread32(0x10004);
	for (t = 0; t < CHECK_SOF_LOOP_CNT; t++)
  9047d6:	0c0200        	memw
  9047d9:	8312      	l32i.n	a3, a1, 8
  9047db:	b133      	addi.n	a3, a3, 1
  9047dd:	0c0200        	memw
  9047e0:	9312      	s32i.n	a3, a1, 8
  9047e2:	0c0200        	memw
  9047e5:	8312      	l32i.n	a3, a1, 8
  9047e7:	732ba1        	bgeu	a2, a3, 90478c <_fw_usb_suspend_reboot+0xa4>
  9047ea:	63ffc4        	j	9047b2 <_fw_usb_suspend_reboot+0xca>

	/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	 * setting the go suspend here, power down right away!!!
	 */
	if (t != CHECK_SOF_LOOP_CNT)   /* not time out */
		io32_set(0x10000, BIT3);
  9047ed:	1a720e        	l32r	a10, 8e1028 <_bss_end+0x3d3820>
  9047f0:	c0b8      	movi.n	a11, 8
  9047f2:	5bffb4        	call8	9046c4 <io32_rmw$constprop$0>

	DEBUG_SYSTEM_STATE = (DEBUG_SYSTEM_STATE&(~0xffff)) | 0x1100;
  9047f5:	127182        	l32r	a2, 8e0e00 <_bss_end+0x3d35f8>
  9047f8:	137208        	l32r	a3, 8e1018 <_bss_end+0x3d3810>
  9047fb:	0c0200        	memw
  9047fe:	8820      	l32i.n	a8, a2, 0
  904800:	19720f        	l32r	a9, 8e103c <_bss_end+0x3d3834>
  904803:	038801        	and	a8, a8, a3
  904806:	098802        	or	a8, a8, a9
  904809:	0c0200        	memw
  90480c:	9820      	s32i.n	a8, a2, 0

	/* restore gpio setting */
	iowrite32(0x10004054, jtag);
	iowrite32(0x50040, spi);
#endif
	iowrite32(0x1000404c, gpio_in);
  90480e:	0c0200        	memw
  904811:	8914      	l32i.n	a9, a1, 16
  904813:	18720a        	l32r	a8, 8e103c <_bss_end+0x3d3834>
	/* since we still need to touch mac_base address after resuming back,
	 * so that reset mac can't be done in ResetFifo function,
	 * move to here... whole mac control reset.... (bit1)
	 */
	iowrite32(MAGPIE_REG_RST_PWDN_CTRL_ADDR, BIT1);
	io32_set(MAGPIE_REG_RST_PWDN_CTRL_ADDR, BIT0);
  904816:	c0b1      	movi.n	a11, 1
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  904818:	0c0200        	memw
  90481b:	9980      	s32i.n	a9, a8, 0
	/* restore gpio setting */
	iowrite32(0x10004054, jtag);
	iowrite32(0x50040, spi);
#endif
	iowrite32(0x1000404c, gpio_in);
	iowrite32(0x10004088, pupd);
  90481d:	0c0200        	memw
  904820:	8913      	l32i.n	a9, a1, 12
  904822:	18720b        	l32r	a8, 8e1050 <_bss_end+0x3d3848>
  904825:	0c0200        	memw
  904828:	9980      	s32i.n	a9, a8, 0

	DEBUG_SYSTEM_STATE = (DEBUG_SYSTEM_STATE&(~0xffff)) | 0x1200;
  90482a:	0c0200        	memw
  90482d:	8820      	l32i.n	a8, a2, 0
  90482f:	038301        	and	a3, a8, a3
  904832:	187210        	l32r	a8, 8e1074 <_bss_end+0x3d386c>
  904835:	083302        	or	a3, a3, a8
  904838:	0c0200        	memw
  90483b:	9320      	s32i.n	a3, a2, 0
  90483d:	137211        	l32r	a3, 8e1084 <_bss_end+0x3d387c>
  904840:	c082      	movi.n	a8, 2
  904842:	0c0200        	memw
  904845:	9830      	s32i.n	a8, a3, 0
	/* since we still need to touch mac_base address after resuming back,
	 * so that reset mac can't be done in ResetFifo function,
	 * move to here... whole mac control reset.... (bit1)
	 */
	iowrite32(MAGPIE_REG_RST_PWDN_CTRL_ADDR, BIT1);
	io32_set(MAGPIE_REG_RST_PWDN_CTRL_ADDR, BIT0);
  904847:	033a02        	or	a10, a3, a3
  90484a:	5bff9e        	call8	9046c4 <io32_rmw$constprop$0>
  90484d:	c080      	movi.n	a8, 0
  90484f:	0c0200        	memw
  904852:	9830      	s32i.n	a8, a3, 0
	iowrite32(MAGPIE_REG_RST_PWDN_CTRL_ADDR, 0);
	A_DELAY_USECS(1000);
  904854:	137184        	l32r	a3, 8e0e64 <_bss_end+0x3d365c>
  904857:	2a3ae8        	movi	a10, 0x3e8
  90485a:	28323a        	l32i	a8, a3, 232
  90485d:	0b8000        	callx8	a8

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  904860:	1871cd        	l32r	a8, 8e0f94 <_bss_end+0x3d378c>

	/* disable ep3 int enable, so that resume back won't
	 * send wdt magic pattern out!!! */
	mUSB_STATUS_IN_INT_DISABLE();
  904863:	2a0ac0        	movi	a10, 192
  904866:	298000        	l8ui	a9, a8, 0
  904869:	090947        	extui	a9, a9, 0, 8
  90486c:	0a9902        	or	a9, a9, a10
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  90486f:	0c0200        	memw
  904872:	298400        	s8i	a9, a8, 0

	MAGPIE_REG_USB_RX0_SWAP_DATA = 0x1;
  904875:	1971dc        	l32r	a9, 8e0fe8 <_bss_end+0x3d37e0>
  904878:	c081      	movi.n	a8, 1
  90487a:	0c0200        	memw
  90487d:	9890      	s32i.n	a8, a9, 0
	MAGPIE_REG_USB_TX0_SWAP_DATA = 0x1;
  90487f:	1971dd        	l32r	a9, 8e0ff4 <_bss_end+0x3d37ec>
  904882:	0c0200        	memw
  904885:	9890      	s32i.n	a8, a9, 0
	MAGPIE_REG_USB_RX1_SWAP_DATA = 0x1;
  904887:	1971de        	l32r	a9, 8e1000 <_bss_end+0x3d37f8>
  90488a:	0c0200        	memw
  90488d:	9890      	s32i.n	a8, a9, 0
	MAGPIE_REG_USB_RX2_SWAP_DATA = 0x1;
  90488f:	1971df        	l32r	a9, 8e100c <_bss_end+0x3d3804>
  904892:	0c0200        	memw
  904895:	9890      	s32i.n	a8, a9, 0

	if (((DEBUG_SYSTEM_STATE&~(0x0000ffff))>>16 == 0x5342)) {
  904897:	0c0200        	memw
  90489a:	8820      	l32i.n	a8, a2, 0
  90489c:	127183        	l32r	a2, 8e0ea8 <_bss_end+0x3d36a0>
  90489f:	08085f        	extui	a8, a8, 16, 16
  9048a2:	72890a        	bne	a8, a2, 9048b0 <_fw_usb_suspend_reboot+0x1c8>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  9048a5:	127212        	l32r	a2, 8e10f0 <_bss_end+0x3d38e8>
  9048a8:	283a00        	movi	a8, 0x300
  9048ab:	0c0200        	memw
  9048ae:	9820      	s32i.n	a8, a2, 0
		/* UART_SEL and SPI_SEL */
		iowrite32(0x50040, 0x300 | 0 | (1 >> 1) << 12);
	}

	/* Jump to boot code */
	A_USB_JUMP_BOOT();
  9048b0:	22322b        	l32i	a2, a3, 172
  9048b3:	0b2000        	callx8	a2
  9048b6:	d10f      	retw.n

009048b8 <_fw_usb_fw_task>:
 * usb zero length interrupt should not clear by s/w, h/w will handle that
 * complete suspend handle, configure gpio, turn off related function,
 * slow down the pll for stable issue
 */
void _fw_usb_fw_task(void)
{
  9048b8:	6c1004        	entry	a1, 32

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  9048bb:	127213        	l32r	a2, 8e1108 <_bss_end+0x3d3900>
  9048be:	232000        	l8ui	a3, a2, 0
  9048c1:	030347        	extui	a3, a3, 0, 8
	if (usb_interrupt_level1 & BIT5)
	{
		vUsb_Data_In();
	}
#endif
	if (usb_interrupt_level1 & BIT4) {
  9048c4:	7b3711        	bbci	a3, 27, 9048d9 <_fw_usb_fw_task+0x21>
  9048c7:	127214        	l32r	a2, 8e1118 <_bss_end+0x3d3910>
  9048ca:	222000        	l8ui	a2, a2, 0
		usb_interrupt_level2 =
			ioread8_usb(ZM_INTR_SOURCE_4_OFFSET);

		if(usb_interrupt_level2 & BIT6)
  9048cd:	792708        	bbci	a2, 25, 9048d9 <_fw_usb_fw_task+0x21>
			A_USB_REG_OUT(); /* vUsb_Reg_Out() */
  9048d0:	127184        	l32r	a2, 8e0ee0 <_bss_end+0x3d36d8>
  9048d3:	222232        	l32i	a2, a2, 200
  9048d6:	0b2000        	callx8	a2
	}

	if (usb_interrupt_level1 & BIT6) {
  9048d9:	c420      	movi.n	a2, 64
  9048db:	723014        	bnone	a3, a2, 9048f3 <_fw_usb_fw_task+0x3b>
  9048de:	187215        	l32r	a8, 8e1134 <_bss_end+0x3d392c>
  9048e1:	288000        	l8ui	a8, a8, 0
  9048e4:	080847        	extui	a8, a8, 0, 8
		/* zfGenWatchDogEvent(); ?? */
		usb_interrupt_level2 =
			ioread8_usb(ZM_INTR_SOURCE_6_OFFSET);
		if(usb_interrupt_level2 & BIT6)
  9048e7:	728008        	bnone	a8, a2, 9048f3 <_fw_usb_fw_task+0x3b>
			A_USB_STATUS_IN(); /* vUsb_Status_In() */
  9048ea:	127184        	l32r	a2, 8e0efc <_bss_end+0x3d36f4>
  9048ed:	222233        	l32i	a2, a2, 204
  9048f0:	0b2000        	callx8	a2
	}

	if (usb_interrupt_level1 & BIT0) {
  9048f3:	7f3f02        	bbsi	a3, 31, 9048f9 <_fw_usb_fw_task+0x41>
  9048f6:	60008e        	j	904988 <_fw_usb_fw_task+0xd0>
  9048f9:	1a7216        	l32r	a10, 8e1154 <_bss_end+0x3d394c>
  9048fc:	28a000        	l8ui	a8, a10, 0
			ioread8_usb(ZM_INTR_SOURCE_0_OFFSET);

		/* refer to FUSB200, p 48, offset:21H, bit7 description,
		 * should clear the command abort interrupt first!?
		 */
		if (usb_interrupt_level2 & BIT7) {
  9048ff:	080247        	extui	a2, a8, 0, 8
  904902:	788713        	bbci	a8, 24, 904919 <_fw_usb_fw_task+0x61>
			/* Handle command abort */
			io8_clr_usb(ZM_INTR_SOURCE_0_OFFSET, BIT7);
  904905:	c0b0      	movi.n	a11, 0
  904907:	2c0a80        	movi	a12, 128
  90490a:	5bff63        	call8	904698 <io8_rmw>
			A_PRINTF("![SOURCE_0] bit7 on\n\r");
  90490d:	187184        	l32r	a8, 8e0f20 <_bss_end+0x3d3718>
  904910:	1a7217        	l32r	a10, 8e116c <_bss_end+0x3d3964>
  904913:	288212        	l32i	a8, a8, 72
  904916:	0b8000        	callx8	a8
		}

		if (usb_interrupt_level2 & BIT1)
  904919:	7e2708        	bbci	a2, 30, 904925 <_fw_usb_fw_task+0x6d>
			A_USB_EP0_TX(); /* USB EP0 tx interrupt */
  90491c:	187184        	l32r	a8, 8e0f2c <_bss_end+0x3d3724>
  90491f:	288220        	l32i	a8, a8, 128
  904922:	0b8000        	callx8	a8

		if (usb_interrupt_level2 & BIT2)
  904925:	7d2708        	bbci	a2, 29, 904931 <_fw_usb_fw_task+0x79>
			A_USB_EP0_RX(); /* USB EP0 rx interrupt */
  904928:	187184        	l32r	a8, 8e0f38 <_bss_end+0x3d3730>
  90492b:	288221        	l32i	a8, a8, 132
  90492e:	0b8000        	callx8	a8

		if (usb_interrupt_level2 & BIT0) {
  904931:	7f2708        	bbci	a2, 31, 90493d <_fw_usb_fw_task+0x85>
			A_USB_EP0_SETUP();
  904934:	187184        	l32r	a8, 8e0f44 <_bss_end+0x3d373c>
  904937:	28821f        	l32i	a8, a8, 124
  90493a:	0b8000        	callx8	a8
			/* vWriteUSBFakeData() */
		}

		if (usb_interrupt_level2 & BIT3) {
  90493d:	7c2713        	bbci	a2, 28, 904954 <_fw_usb_fw_task+0x9c>
			/* vUsb_ep0end */
			eUsbCxCommand = CMD_VOID;
  904940:	187218        	l32r	a8, 8e11a0 <_bss_end+0x3d3998>
  904943:	c090      	movi.n	a9, 0
  904945:	298600        	s32i	a9, a8, 0
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  904948:	187219        	l32r	a8, 8e11ac <_bss_end+0x3d39a4>
  90494b:	290a01        	movi	a9, 1
  90494e:	0c0200        	memw
  904951:	298400        	s8i	a9, a8, 0
			iowrite8_usb(ZM_CX_CONFIG_STATUS_OFFSET, 0x01);
		}

		/* EP0 fail */
	        if (usb_interrupt_level2 & BIT4)
  904954:	7b270a        	bbci	a2, 27, 904962 <_fw_usb_fw_task+0xaa>
  904957:	127219        	l32r	a2, 8e11bc <_bss_end+0x3d39b4>
  90495a:	c084      	movi.n	a8, 4
  90495c:	0c0200        	memw
  90495f:	282400        	s8i	a8, a2, 0
			iowrite8_usb(ZM_CX_CONFIG_STATUS_OFFSET, 0x04);

		if (eUsbCxFinishAction == ACT_STALL) {
  904962:	1871db        	l32r	a8, 8e10d0 <_bss_end+0x3d38c8>
  904965:	8280      	l32i.n	a2, a8, 0
  904967:	69220d        	bnei	a2, 2, 904978 <_fw_usb_fw_task+0xc0>
  90496a:	127219        	l32r	a2, 8e11d0 <_bss_end+0x3d39c8>
  90496d:	c094      	movi.n	a9, 4
  90496f:	0c0200        	memw
  904972:	292400        	s8i	a9, a2, 0
  904975:	60000b        	j	904984 <_fw_usb_fw_task+0xcc>
			/* set CX_STL to stall Endpoint0 &
			 * will also clear FIFO0 */
			iowrite8_usb(ZM_CX_CONFIG_STATUS_OFFSET, 0x04);
		} else if (eUsbCxFinishAction == ACT_DONE) {
  904978:	692108        	bnei	a2, 1, 904984 <_fw_usb_fw_task+0xcc>
  90497b:	197219        	l32r	a9, 8e11e0 <_bss_end+0x3d39d8>
  90497e:	0c0200        	memw
  904981:	229400        	s8i	a2, a9, 0
			/* set CX_DONE to indicate the transmistion
			 * of control frame */
			iowrite8_usb(ZM_CX_CONFIG_STATUS_OFFSET, 0x01);
		}
		eUsbCxFinishAction = ACT_IDLE;
  904984:	c020      	movi.n	a2, 0
  904986:	9280      	s32i.n	a2, a8, 0
	}

	if (usb_interrupt_level1 & BIT7) {
  904988:	003332        	sext	a3, a3, 7
  90498b:	673045        	bgez	a3, 9049d4 <_fw_usb_fw_task+0x11c>

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  90498e:	1a7206        	l32r	a10, 8e11a8 <_bss_end+0x3d39a0>
  904991:	22a000        	l8ui	a2, a10, 0
  904994:	020247        	extui	a2, a2, 0, 8

	if (usb_interrupt_level2 & BIT6)
		vUsb_Data_In0Byte();
#endif

		if (usb_interrupt_level2 & BIT1) {
  904997:	7e271a        	bbci	a2, 30, 9049b5 <_fw_usb_fw_task+0xfd>
			io8_clr_usb(ZM_INTR_SOURCE_7_OFFSET, BIT1);
  90499a:	c0b0      	movi.n	a11, 0
  90499c:	c0c2      	movi.n	a12, 2
  90499e:	5bff3e        	call8	904698 <io8_rmw>
			UsbChirpFinish = FALSE;
  9049a1:	13721a        	l32r	a3, 8e120c <_bss_end+0x3d3a04>
  9049a4:	c080      	movi.n	a8, 0
  9049a6:	283500        	s16i	a8, a3, 0
			A_PRINTF("!USB reset\n\r");
  9049a9:	137184        	l32r	a3, 8e0fbc <_bss_end+0x3d37b4>
  9049ac:	1a721b        	l32r	a10, 8e1218 <_bss_end+0x3d3a10>
  9049af:	233212        	l32i	a3, a3, 72
  9049b2:	0b3000        	callx8	a3
		}
		if (usb_interrupt_level2 & BIT2) {
  9049b5:	7d2702        	bbci	a2, 29, 9049bb <_fw_usb_fw_task+0x103>
			/* TBD: the suspend resume code should put here,
			 * Ryan, 07/18
			 * issue, jump back to rom code and what peripherals
			 * should we reset here? */
			_fw_usb_suspend_reboot();
  9049b8:	5bff4b        	call8	9046e8 <_fw_usb_suspend_reboot>
		}
		if (usb_interrupt_level2 & BIT3) {
  9049bb:	7c2715        	bbci	a2, 28, 9049d4 <_fw_usb_fw_task+0x11c>
			io8_clr_usb(ZM_INTR_SOURCE_7_OFFSET, BIT3);
  9049be:	1a7206        	l32r	a10, 8e11d8 <_bss_end+0x3d39d0>
  9049c1:	c0b0      	movi.n	a11, 0
  9049c3:	c0c8      	movi.n	a12, 8
  9049c5:	5bff34        	call8	904698 <io8_rmw>
			A_PRINTF("!USB resume\n\r");
  9049c8:	127184        	l32r	a2, 8e0fd8 <_bss_end+0x3d37d0>
  9049cb:	1a721c        	l32r	a10, 8e123c <_bss_end+0x3d3a34>
  9049ce:	222212        	l32i	a2, a2, 72
  9049d1:	0b2000        	callx8	a2
  9049d4:	d10f      	retw.n
	...

009049d8 <_fw_usb_reset_fifo>:
	}
}


void _fw_usb_reset_fifo(void)
{
  9049d8:	6c1004        	entry	a1, 32
	io8_set(0x100ae, 0x10);
  9049db:	1a721d        	l32r	a10, 8e1250 <_bss_end+0x3d3a48>
  9049de:	c1b0      	movi.n	a11, 16
  9049e0:	c0c0      	movi.n	a12, 0
  9049e2:	5bff2d        	call8	904698 <io8_rmw>
	io8_set(0x100af, 0x10);
  9049e5:	1a721e        	l32r	a10, 8e1260 <_bss_end+0x3d3a58>
  9049e8:	c0c0      	movi.n	a12, 0
  9049ea:	2b0a10        	movi	a11, 16
  9049ed:	5bff2a        	call8	904698 <io8_rmw>
  9049f0:	1271cd        	l32r	a2, 8e1124 <_bss_end+0x3d391c>

	/* disable ep3 int enable, so that resume back won't
	 * send wdt magic pattern out!!!
	 */
	mUSB_STATUS_IN_INT_DISABLE();
  9049f3:	240ac0        	movi	a4, 192
  9049f6:	232000        	l8ui	a3, a2, 0
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  9049f9:	c084      	movi.n	a8, 4

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  9049fb:	030347        	extui	a3, a3, 0, 8
  9049fe:	043302        	or	a3, a3, a4
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  904a01:	0c0200        	memw
  904a04:	232400        	s8i	a3, a2, 0
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  904a07:	137192        	l32r	a3, 8e1050 <_bss_end+0x3d3848>
  904a0a:	127189        	l32r	a2, 8e1030 <_bss_end+0x3d3828>
  904a0d:	c040      	movi.n	a4, 0
  904a0f:	0c0200        	memw
  904a12:	9320      	s32i.n	a3, a2, 0
  904a14:	13721f        	l32r	a3, 8e1290 <_bss_end+0x3d3a88>
  904a17:	127211        	l32r	a2, 8e125c <_bss_end+0x3d3a54>
  904a1a:	0c0200        	memw
  904a1d:	9430      	s32i.n	a4, a3, 0
  904a1f:	0c0200        	memw
  904a22:	9820      	s32i.n	a8, a2, 0
	 */
	iowrite32_usb(ZM_SOC_USB_DMA_RESET_OFFSET, 0x0);

	/* reset both usb(bit2)/wlan(bit1) dma */
	iowrite32(MAGPIE_REG_RST_PWDN_CTRL_ADDR, BIT2);
	io32_set(MAGPIE_REG_RST_PWDN_CTRL_ADDR, BIT0);
  904a24:	022a02        	or	a10, a2, a2
  904a27:	2b0a01        	movi	a11, 1
  904a2a:	5bff26        	call8	9046c4 <io32_rmw$constprop$0>
  904a2d:	0c0200        	memw
  904a30:	9420      	s32i.n	a4, a2, 0
  904a32:	c021      	movi.n	a2, 1
  904a34:	0c0200        	memw
  904a37:	9230      	s32i.n	a2, a3, 0

	//*reg_data = 0x00000000;

	//while (*reg_data)   ;

	A_PRINTF("\n change clock to 22 and go to suspend now!");
  904a39:	127184        	l32r	a2, 8e104c <_bss_end+0x3d3844>
  904a3c:	1a7220        	l32r	a10, 8e12bc <_bss_end+0x3d3ab4>
  904a3f:	232212        	l32i	a3, a2, 72
  904a42:	242a00        	movi	a4, 0x200
  904a45:	0b3000        	callx8	a3
  904a48:	137212        	l32r	a3, 8e1290 <_bss_end+0x3d3a88>

	/* UART_SEL */
	iowrite32(0x50040, 0x200 | 0 | (1 >> 1) << 12);
	A_UART_HWINIT((22*1000*1000), 19200);
  904a4b:	22221a        	l32i	a2, a2, 104
  904a4e:	1a7221        	l32r	a10, 8e12d4 <_bss_end+0x3d3acc>
  904a51:	1b7222        	l32r	a11, 8e12dc <_bss_end+0x3d3ad4>
  904a54:	0c0200        	memw
  904a57:	9430      	s32i.n	a4, a3, 0
  904a59:	0b2000        	callx8	a2
  904a5c:	d10f      	retw.n
	...

00904a60 <cmnos_clock_init_patch>:
extern a_uint32_t cticks;

// clock change 
//
void cmnos_clock_init_patch(a_uint32_t refclk)
{
  904a60:	6c1004        	entry	a1, 32
    ref_clk = refclk;
  904a63:	187223        	l32r	a8, 8e12f0 <_bss_end+0x3d3ae8>
  904a66:	9280      	s32i.n	a2, a8, 0
  904a68:	d10f      	retw.n
	...

00904a6c <cmnos_refclk_speed_get_patch>:
}

// retrieve current clock setting
// 
a_uint32_t cmnos_refclk_speed_get_patch(void)
{
  904a6c:	6c1004        	entry	a1, 32
    return ref_clk;
}
  904a6f:	187223        	l32r	a8, 8e12fc <_bss_end+0x3d3af4>
  904a72:	8280      	l32i.n	a2, a8, 0
  904a74:	d10f      	retw.n
	...

00904a78 <cmnos_delay_us_patch>:


// software emulate delay function
//
void cmnos_delay_us_patch(int us)
{
  904a78:	6c1004        	entry	a1, 32
    a_uint32_t start_time = NOW();
  904a7b:	5b808c        	call8	8e4cac <xthal_get_ccount>
    unsigned int num_ticks = us*ref_clk; // system_freq == number of ticks per 1us
  904a7e:	187223        	l32r	a8, 8e130c <_bss_end+0x3d3b04>

// software emulate delay function
//
void cmnos_delay_us_patch(int us)
{
    a_uint32_t start_time = NOW();
  904a81:	d3a0      	mov.n	a3, a10
    unsigned int num_ticks = us*ref_clk; // system_freq == number of ticks per 1us
  904a83:	288200        	l32i	a8, a8, 0
  904a86:	082228        	mull	a2, a2, a8
    
    while ( (NOW() - start_time) < num_ticks) {
  904a89:	5b8088        	call8	8e4cac <xthal_get_ccount>
  904a8c:	03aa0c        	sub	a10, a10, a3
  904a8f:	72a3f6        	bltu	a10, a2, 904a89 <cmnos_delay_us_patch+0x11>
        /* busy spin */
        ;
    }
}
  904a92:	d10f      	retw.n

00904a94 <cmnos_tick_patch>:


// software emulate microsecond ticks
//
void cmnos_tick_patch(void)
{
  904a94:	6c1004        	entry	a1, 32
    static a_uint32_t last_tick = 0;
    a_uint32_t current_tick = NOW();
  904a97:	5b8085        	call8	8e4cac <xthal_get_ccount>
    a_uint32_t delta_tick;

    delta_tick = (A_UINT32 ) (current_tick - last_tick)/(ref_clk<<10);
  904a9a:	187223        	l32r	a8, 8e1328 <_bss_end+0x3d3b20>
  904a9d:	127224        	l32r	a2, 8e1330 <_bss_end+0x3d3b28>
// software emulate microsecond ticks
//
void cmnos_tick_patch(void)
{
    static a_uint32_t last_tick = 0;
    a_uint32_t current_tick = NOW();
  904aa0:	d3a0      	mov.n	a3, a10
    a_uint32_t delta_tick;

    delta_tick = (A_UINT32 ) (current_tick - last_tick)/(ref_clk<<10);
  904aa2:	8b80      	l32i.n	a11, a8, 0
  904aa4:	2a2200        	l32i	a10, a2, 0
  904aa7:	06bb11        	slli	a11, a11, 10
  904aaa:	0a3a0c        	sub	a10, a3, a10
  904aad:	5b80bc        	call8	8e4da0 <__udivsi3>

    if( delta_tick > 0 )
  904ab0:	c8a0      	beqz.n	a10, 904ab4 <cmnos_tick_patch+0x20>
        last_tick = current_tick;
  904ab2:	9320      	s32i.n	a3, a2, 0

    cticks += delta_tick;
  904ab4:	127225        	l32r	a2, 8e1348 <_bss_end+0x3d3b40>
  904ab7:	8320      	l32i.n	a3, a2, 0
  904ab9:	a3aa      	add.n	a10, a10, a3
  904abb:	9a20      	s32i.n	a10, a2, 0
  904abd:	d10f      	retw.n
	...

00904ac0 <cmnos_milliseconds_patch>:
}

// get current sysmem up time in milliseconds based
// 
a_uint32_t cmnos_milliseconds_patch(void)
{
  904ac0:	6c1004        	entry	a1, 32
    cmnos_tick_patch();
  904ac3:	5bfff4        	call8	904a94 <cmnos_tick_patch>
    
    return (cticks);
}
  904ac6:	187225        	l32r	a8, 8e135c <_bss_end+0x3d3b54>
  904ac9:	8280      	l32i.n	a2, a8, 0
  904acb:	d10f      	retw.n
  904acd:	000000        	ill

00904ad0 <_cvt>:
LOCAL void
(*_putc)(char c) = cmnos_write_char;

LOCAL int
_cvt(unsigned long val, char *buf, long radix, char *digits)
{
  904ad0:	6c100e        	entry	a1, 112
    char temp[80];
    char *cp = temp;
    int length = 0;

    if (val == 0) {
  904ad3:	cc2f      	bnez.n	a2, 904ae6 <_cvt+0x16>
        /* Special case */
        *cp++ = '0';
  904ad5:	c320      	movi.n	a2, 48
  904ad7:	221400        	s8i	a2, a1, 0
  904ada:	b116      	addi.n	a6, a1, 1

LOCAL void
(*_putc)(char c) = cmnos_write_char;

LOCAL int
_cvt(unsigned long val, char *buf, long radix, char *digits)
  904adc:	b014      	addi.n	a4, a1, -1
  904ade:	d260      	mov.n	a2, a6
  904ae0:	d830      	mov.n	a8, a3
  904ae2:	60002e        	j	904b14 <_cvt+0x44>
  904ae5:	00d610        	slli	a6, a13, 32
    if (val == 0) {
        /* Special case */
        *cp++ = '0';
    } else {
        while (val) {
            *cp++ = digits[val % radix];
  904ae8:	da20      	mov.n	a10, a2
  904aea:	044b02        	or	a11, a4, a4
  904aed:	5b80c0        	call8	8e4df0 <__umodsi3>
  904af0:	aa5a      	add.n	a10, a5, a10
  904af2:	28a000        	l8ui	a8, a10, 0
            val /= radix;
  904af5:	db40      	mov.n	a11, a4
    if (val == 0) {
        /* Special case */
        *cp++ = '0';
    } else {
        while (val) {
            *cp++ = digits[val % radix];
  904af7:	286400        	s8i	a8, a6, 0
            val /= radix;
  904afa:	022a02        	or	a10, a2, a2
  904afd:	5b80a8        	call8	8e4da0 <__udivsi3>
    if (val == 0) {
        /* Special case */
        *cp++ = '0';
    } else {
        while (val) {
            *cp++ = digits[val % radix];
  904b00:	b166      	addi.n	a6, a6, 1
            val /= radix;
  904b02:	d2a0      	mov.n	a2, a10

    if (val == 0) {
        /* Special case */
        *cp++ = '0';
    } else {
        while (val) {
  904b04:	65afe0        	bnez	a10, 904ae8 <_cvt+0x18>
  904b07:	63ffd1        	j	904adc <_cvt+0xc>
  904b0a:	000025        	excw
            *cp++ = digits[val % radix];
            val /= radix;
        }
    }
    while (cp != temp) {
        *buf++ = *--cp;
  904b0d:	200025        	l8ui	a0, a0, 37
  904b10:	8400      	l32i.n	a4, a0, 0
  904b12:	b188      	addi.n	a8, a8, 1
  904b14:	b022      	addi.n	a2, a2, -1
        while (val) {
            *cp++ = digits[val % radix];
            val /= radix;
        }
    }
    while (cp != temp) {
  904b16:	7429f2        	bne	a2, a4, 904b0c <_cvt+0x3c>

LOCAL void
(*_putc)(char c) = cmnos_write_char;

LOCAL int
_cvt(unsigned long val, char *buf, long radix, char *digits)
  904b19:	01620c        	sub	a2, a6, a1
    }
    while (cp != temp) {
        *buf++ = *--cp;
        length++;
    }
    *buf = '\0';
  904b1c:	a233      	add.n	a3, a3, a2
  904b1e:	c040      	movi.n	a4, 0
  904b20:	243400        	s8i	a4, a3, 0
    return (length);
}
  904b23:	d10f      	retw.n
  904b25:	000000        	ill

00904b28 <cmnos_write_char>:

#include <stdarg.h>

LOCAL void
cmnos_write_char(char c)
{
  904b28:	6c1004        	entry	a1, 32
  904b2b:	020247        	extui	a2, a2, 0, 8
    if (c == '\n') {
  904b2e:	69290e        	bnei	a2, 10, 904b40 <cmnos_write_char+0x18>
        A_PUTC('\r');
  904b31:	137184        	l32r	a3, 8e1144 <_bss_end+0x3d393c>
  904b34:	c0ad      	movi.n	a10, 13
  904b36:	283214        	l32i	a8, a3, 80
  904b39:	0b8000        	callx8	a8
  904b3c:	600008        	j	904b48 <cmnos_write_char+0x20>
  904b3f:	00c03d        	excw
        A_PUTC('\n');
    } else if (c == '\r') {
  904b42:	73210a        	beq	a2, a3, 904b50 <cmnos_write_char+0x28>
    } else {
      A_PUTC(c);
  904b45:	137184        	l32r	a3, 8e1158 <_bss_end+0x3d3950>
  904b48:	233214        	l32i	a3, a3, 80
  904b4b:	da20      	mov.n	a10, a2
  904b4d:	0b3000        	callx8	a3
  904b50:	d10f      	retw.n
	...

00904b54 <fw_cmnos_printf>:
    return (res);
}

int
fw_cmnos_printf(const char *fmt, ...)
{
  904b54:	6c1012        	entry	a1, 144
    va_list ap;
    int ret;

    va_start(ap, fmt);
  904b57:	931d      	s32i.n	a3, a1, 52
  904b59:	231c30        	addi	a3, a1, 48
    char buf[sizeof(long)*8];
    char c, sign, *cp=buf;
    int left_prec, right_prec, zero_fill, pad, pad_on_right,
        i, islong, islonglong;
    long val = 0;
    int res = 0, length = 0;
  904b5c:	c0b0      	movi.n	a11, 0
fw_cmnos_printf(const char *fmt, ...)
{
    va_list ap;
    int ret;

    va_start(ap, fmt);
  904b5e:	941e      	s32i.n	a4, a1, 56
  904b60:	9319      	s32i.n	a3, a1, 36
  904b62:	241c70        	addi	a4, a1, 112
  904b65:	c034      	movi.n	a3, 4
  904b67:	951f      	s32i.n	a5, a1, 60
  904b69:	9418      	s32i.n	a4, a1, 32
  904b6b:	261610        	s32i	a6, a1, 64
  904b6e:	271611        	s32i	a7, a1, 68
  904b71:	931a      	s32i.n	a3, a1, 40
    char buf[sizeof(long)*8];
    char c, sign, *cp=buf;
    int left_prec, right_prec, zero_fill, pad, pad_on_right,
        i, islong, islonglong;
    long val = 0;
    int res = 0, length = 0;
  904b73:	2b1614        	s32i	a11, a1, 80
{
    char buf[sizeof(long)*8];
    char c, sign, *cp=buf;
    int left_prec, right_prec, zero_fill, pad, pad_on_right,
        i, islong, islonglong;
    long val = 0;
  904b76:	d5b0      	mov.n	a5, a11

LOCAL
int cmnos_vprintf(void (*putc)(char c), const char *fmt, va_list ap)
{
    char buf[sizeof(long)*8];
    char c, sign, *cp=buf;
  904b78:	d410      	mov.n	a4, a1
  904b7a:	6003a6        	j	904f24 <fw_cmnos_printf+0x3d0>
        i, islong, islonglong;
    long val = 0;
    int res = 0, length = 0;

    while ((c = *fmt++) != '\0') {
        if (c == '%') {
  904b7d:	c265      	movi.n	a6, 37
  904b7f:	76a102        	beq	a10, a6, 904b85 <fw_cmnos_printf+0x31>
  904b82:	60038b        	j	904f11 <fw_cmnos_printf+0x3bd>
            c = *fmt++;
  904b85:	282001        	l8ui	a8, a2, 1
            left_prec = right_prec = pad_on_right = islong = islonglong = 0;
            if (c == '-') {
  904b88:	c26d      	movi.n	a6, 45
  904b8a:	76810a        	beq	a8, a6, 904b98 <fw_cmnos_printf+0x44>
    int res = 0, length = 0;

    while ((c = *fmt++) != '\0') {
        if (c == '%') {
            c = *fmt++;
            left_prec = right_prec = pad_on_right = islong = islonglong = 0;
  904b8d:	c090      	movi.n	a9, 0
    long val = 0;
    int res = 0, length = 0;

    while ((c = *fmt++) != '\0') {
        if (c == '%') {
            c = *fmt++;
  904b8f:	b222      	addi.n	a2, a2, 2
            left_prec = right_prec = pad_on_right = islong = islonglong = 0;
  904b91:	291616        	s32i	a9, a1, 88
  904b94:	60000a        	j	904ba2 <fw_cmnos_printf+0x4e>
  904b97:	00c061        	excw
            if (c == '-') {
                c = *fmt++;
  904b9a:	282002        	l8ui	a8, a2, 2
                pad_on_right++;
  904b9d:	261616        	s32i	a6, a1, 88
    while ((c = *fmt++) != '\0') {
        if (c == '%') {
            c = *fmt++;
            left_prec = right_prec = pad_on_right = islong = islonglong = 0;
            if (c == '-') {
                c = *fmt++;
  904ba0:	b322      	addi.n	a2, a2, 3
            }
            if (c == '0') {
                zero_fill = TRUE;
                c = *fmt++;
            } else {
                zero_fill = FALSE;
  904ba2:	c090      	movi.n	a9, 0
  904ba4:	291615        	s32i	a9, a1, 84
            left_prec = right_prec = pad_on_right = islong = islonglong = 0;
            if (c == '-') {
                c = *fmt++;
                pad_on_right++;
            }
            if (c == '0') {
  904ba7:	c360      	movi.n	a6, 48
  904ba9:	768909        	bne	a8, a6, 904bb6 <fw_cmnos_printf+0x62>
                zero_fill = TRUE;
  904bac:	c061      	movi.n	a6, 1
                c = *fmt++;
  904bae:	282000        	l8ui	a8, a2, 0
            if (c == '-') {
                c = *fmt++;
                pad_on_right++;
            }
            if (c == '0') {
                zero_fill = TRUE;
  904bb1:	261615        	s32i	a6, a1, 84
                c = *fmt++;
  904bb4:	b122      	addi.n	a2, a2, 1
            if (c == '-') {
                c = *fmt++;
                pad_on_right++;
            }
            if (c == '0') {
                zero_fill = TRUE;
  904bb6:	c060      	movi.n	a6, 0
                c = *fmt++;
            } else {
                zero_fill = FALSE;
            }
            while (is_digit(c)) {
  904bb8:	c0c9      	movi.n	a12, 9
  904bba:	60000a        	j	904bc8 <fw_cmnos_printf+0x74>
                left_prec = (left_prec * 10) + (c - '0');
  904bbd:	06660a        	addx4	a6, a6, a6
                c = *fmt++;
  904bc0:	282000        	l8ui	a8, a2, 0
                c = *fmt++;
            } else {
                zero_fill = FALSE;
            }
            while (is_digit(c)) {
                left_prec = (left_prec * 10) + (c - '0');
  904bc3:	076609        	addx2	a6, a6, a7
                c = *fmt++;
  904bc6:	b122      	addi.n	a2, a2, 1
                zero_fill = TRUE;
                c = *fmt++;
            } else {
                zero_fill = FALSE;
            }
            while (is_digit(c)) {
  904bc8:	278cd0        	addi	a7, a8, -48
  904bcb:	070a47        	extui	a10, a7, 0, 8
  904bce:	7acbeb        	bgeu	a12, a10, 904bbd <fw_cmnos_printf+0x69>
                left_prec = (left_prec * 10) + (c - '0');
                c = *fmt++;
            }
            if (c == '.') {
  904bd1:	c27e      	movi.n	a7, 46
  904bd3:	77891f        	bne	a8, a7, 904bf6 <fw_cmnos_printf+0xa2>
                c = *fmt++;
                zero_fill++;
  904bd6:	291215        	l32i	a9, a1, 84
            while (is_digit(c)) {
                left_prec = (left_prec * 10) + (c - '0');
                c = *fmt++;
            }
            if (c == '.') {
                c = *fmt++;
  904bd9:	282000        	l8ui	a8, a2, 0
                zero_fill++;
  904bdc:	b199      	addi.n	a9, a9, 1
            while (is_digit(c)) {
                left_prec = (left_prec * 10) + (c - '0');
                c = *fmt++;
            }
            if (c == '.') {
                c = *fmt++;
  904bde:	b122      	addi.n	a2, a2, 1
                zero_fill++;
  904be0:	291615        	s32i	a9, a1, 84
                while (is_digit(c)) {
  904be3:	c0a9      	movi.n	a10, 9
  904be5:	600004        	j	904bed <fw_cmnos_printf+0x99>
                    right_prec = (right_prec * 10) + (c - '0');
                    c = *fmt++;
  904be8:	282000        	l8ui	a8, a2, 0
  904beb:	b122      	addi.n	a2, a2, 1
                c = *fmt++;
            }
            if (c == '.') {
                c = *fmt++;
                zero_fill++;
                while (is_digit(c)) {
  904bed:	278cd0        	addi	a7, a8, -48
  904bf0:	070747        	extui	a7, a7, 0, 8
  904bf3:	77abf1        	bgeu	a10, a7, 904be8 <fw_cmnos_printf+0x94>
                }
            } else {
                right_prec = left_prec;
            }
            sign = '\0';
            if (c == 'l') {
  904bf6:	2c0a6c        	movi	a12, 108
  904bf9:	7c8910        	bne	a8, a12, 904c0d <fw_cmnos_printf+0xb9>
                // 'long' qualifier
                c = *fmt++;
  904bfc:	282000        	l8ui	a8, a2, 0
		islong = 1;
                if (c == 'l') {
  904bff:	7c8105        	beq	a8, a12, 904c08 <fw_cmnos_printf+0xb4>
                right_prec = left_prec;
            }
            sign = '\0';
            if (c == 'l') {
                // 'long' qualifier
                c = *fmt++;
  904c02:	b122      	addi.n	a2, a2, 1
  904c04:	600005        	j	904c0d <fw_cmnos_printf+0xb9>
  904c07:	002820        	excw
		islong = 1;
                if (c == 'l') {
                    // long long qualifier
                    c = *fmt++;
  904c0a:	01b222        	excw
                    islonglong = 1;
                }
            }
            // Fetch value [numeric descriptors only]
            switch (c) {
  904c0d:	2c0a62        	movi	a12, 98
  904c10:	7c813a        	beq	a8, a12, 904c4e <fw_cmnos_printf+0xfa>
  904c13:	78c319        	bltu	a12, a8, 904c30 <fw_cmnos_printf+0xdc>
  904c16:	c4c4      	movi.n	a12, 68
  904c18:	7c8132        	beq	a8, a12, 904c4e <fw_cmnos_printf+0xfa>
  904c1b:	78c305        	bltu	a12, a8, 904c24 <fw_cmnos_printf+0xd0>
  904c1e:	c4c2      	movi.n	a12, 66
  904c20:	600025        	j	904c49 <fw_cmnos_printf+0xf5>
  904c23:	00c5c5        	excw
  904c26:	7c8124        	beq	a8, a12, 904c4e <fw_cmnos_printf+0xfa>
  904c29:	c5c8      	movi.n	a12, 88
  904c2b:	60001a        	j	904c49 <fw_cmnos_printf+0xf5>
  904c2e:	00002c        	excw
  904c31:	0a707c        	excw
  904c34:	8117      	l32i.n	a1, a1, 28
  904c36:	78c306        	bltu	a12, a8, 904c40 <fw_cmnos_printf+0xec>
  904c39:	2c0a64        	movi	a12, 100
  904c3c:	600009        	j	904c49 <fw_cmnos_printf+0xf5>
  904c3f:	002c0a        	addx4	a12, a2, a0
  904c42:	757c81        	bnall	a7, a5, 904bc7 <fw_cmnos_printf+0x73>
  904c45:	072c0a        	addx4	a12, a2, a7
  904c48:	78c070        	bnone	a12, a8, 904cbc <fw_cmnos_printf+0x168>
  904c4b:	7c8932        	bne	a8, a12, 904c81 <fw_cmnos_printf+0x12d>
                if (islonglong) {
                    val = va_arg(ap, long);
	        } else if (islong) {
                    val = (long)va_arg(ap, long);
		} else{
                    val = (long)va_arg(ap, int);
  904c4e:	b437      	addi.n	a7, a3, 4
  904c50:	c1a8      	movi.n	a10, 24
  904c52:	251c30        	addi	a5, a1, 48
  904c55:	77aa07        	bge	a10, a7, 904c60 <fw_cmnos_printf+0x10c>
  904c58:	73a201        	blt	a10, a3, 904c5d <fw_cmnos_printf+0x109>
  904c5b:	c274      	movi.n	a7, 36
  904c5d:	251c70        	addi	a5, a1, 112
  904c60:	a755      	add.n	a5, a5, a7
                }
                if ((c == 'd') || (c == 'D')) {
  904c62:	2cfadf        	movi	a12, -33
                if (islonglong) {
                    val = va_arg(ap, long);
	        } else if (islong) {
                    val = (long)va_arg(ap, long);
		} else{
                    val = (long)va_arg(ap, int);
  904c65:	255cfc        	addi	a5, a5, -4
                }
                if ((c == 'd') || (c == 'D')) {
  904c68:	0c8c01        	and	a12, a8, a12
  904c6b:	c4a4      	movi.n	a10, 68
                if (islonglong) {
                    val = va_arg(ap, long);
	        } else if (islong) {
                    val = (long)va_arg(ap, long);
		} else{
                    val = (long)va_arg(ap, int);
  904c6d:	d370      	mov.n	a3, a7
  904c6f:	8550      	l32i.n	a5, a5, 0
                    c = *fmt++;
                }
            } else {
                right_prec = left_prec;
            }
            sign = '\0';
  904c71:	c070      	movi.n	a7, 0
	        } else if (islong) {
                    val = (long)va_arg(ap, long);
		} else{
                    val = (long)va_arg(ap, int);
                }
                if ((c == 'd') || (c == 'D')) {
  904c73:	7ac90a        	bne	a12, a10, 904c81 <fw_cmnos_printf+0x12d>
                    if (val < 0) {
  904c76:	775a07        	bge	a5, a7, 904c81 <fw_cmnos_printf+0x12d>
                        sign = '-';
                        val = -val;
  904c79:	050506        	neg	a5, a5
		} else{
                    val = (long)va_arg(ap, int);
                }
                if ((c == 'd') || (c == 'D')) {
                    if (val < 0) {
                        sign = '-';
  904c7c:	c27d      	movi.n	a7, 45
  904c7e:	63ffff        	j	904c81 <fw_cmnos_printf+0x12d>
                break;
            default:
                break;
            }
            // Process output
            switch (c) {
  904c81:	2a0a62        	movi	a10, 98
  904c84:	7a8902        	bne	a8, a10, 904c8a <fw_cmnos_printf+0x136>
  904c87:	600141        	j	904dcc <fw_cmnos_printf+0x278>
  904c8a:	78a32f        	bltu	a10, a8, 904cbd <fw_cmnos_printf+0x169>
  904c8d:	c4a4      	movi.n	a10, 68
  904c8f:	7a8176        	beq	a8, a10, 904d09 <fw_cmnos_printf+0x1b5>
  904c92:	78a318        	bltu	a10, a8, 904cae <fw_cmnos_printf+0x15a>
  904c95:	c4a2      	movi.n	a10, 66
  904c97:	7a8902        	bne	a8, a10, 904c9d <fw_cmnos_printf+0x149>
  904c9a:	60012e        	j	904dcc <fw_cmnos_printf+0x278>
  904c9d:	78ab02        	bgeu	a10, a8, 904ca3 <fw_cmnos_printf+0x14f>
  904ca0:	6000fa        	j	904d9e <fw_cmnos_printf+0x24a>
  904ca3:	c295      	movi.n	a9, 37
  904ca5:	798102        	beq	a8, a9, 904cab <fw_cmnos_printf+0x157>
  904ca8:	600159        	j	904e05 <fw_cmnos_printf+0x2b1>
  904cab:	600149        	j	904df8 <fw_cmnos_printf+0x2a4>
  904cae:	c5a5      	movi.n	a10, 85
  904cb0:	7a8155        	beq	a8, a10, 904d09 <fw_cmnos_printf+0x1b5>
  904cb3:	c5a8      	movi.n	a10, 88
  904cb5:	7a8150        	beq	a8, a10, 904d09 <fw_cmnos_printf+0x1b5>
  904cb8:	c5a3      	movi.n	a10, 83
  904cba:	60002d        	j	904ceb <fw_cmnos_printf+0x197>
  904cbd:	2a0a70        	movi	a10, 112
  904cc0:	7a8130        	beq	a8, a10, 904cf4 <fw_cmnos_printf+0x1a0>
  904cc3:	78a315        	bltu	a10, a8, 904cdc <fw_cmnos_printf+0x188>
  904cc6:	2a0a63        	movi	a10, 99
  904cc9:	7a8902        	bne	a8, a10, 904ccf <fw_cmnos_printf+0x17b>
  904ccc:	6000ce        	j	904d9e <fw_cmnos_printf+0x24a>
  904ccf:	2a0a64        	movi	a10, 100
  904cd2:	7a8102        	beq	a8, a10, 904cd8 <fw_cmnos_printf+0x184>
  904cd5:	60012c        	j	904e05 <fw_cmnos_printf+0x2b1>
  904cd8:	60002d        	j	904d09 <fw_cmnos_printf+0x1b5>
  904cdb:	002a0a        	addx4	a10, a2, a0
  904cde:	757a81        	bge	a7, a5, 904c63 <fw_cmnos_printf+0x10f>
  904ce1:	262a0a        	movi	a6, 0x20a
  904ce4:	787a81        	bge	a7, a8, 904c69 <fw_cmnos_printf+0x115>
  904ce7:	202a0a        	movi	a0, 0x20a
  904cea:	737a81        	bge	a7, a3, 904c6f <fw_cmnos_printf+0x11b>
  904ced:	026001        	and	a0, a6, a2
  904cf0:	136000        	l32r	a3, 8dccf0 <_bss_end+0x3cf4e8>
  904cf3:	75c3a0        	bltu	a12, a5, 904c97 <fw_cmnos_printf+0x143>
            case 'p':  // Pointer
                (*putc)('0');
  904cf6:	5bff8c        	call8	904b28 <cmnos_write_char>
                (*putc)('x');
  904cf9:	2a0a78        	movi	a10, 120
                zero_fill = TRUE;
  904cfc:	c041      	movi.n	a4, 1
            }
            // Process output
            switch (c) {
            case 'p':  // Pointer
                (*putc)('0');
                (*putc)('x');
  904cfe:	5bff8a        	call8	904b28 <cmnos_write_char>
                zero_fill = TRUE;
                left_prec = sizeof(unsigned long)*2;
  904d01:	c068      	movi.n	a6, 8
            // Process output
            switch (c) {
            case 'p':  // Pointer
                (*putc)('0');
                (*putc)('x');
                zero_fill = TRUE;
  904d03:	241615        	s32i	a4, a1, 84
  904d06:	600042        	j	904d4c <fw_cmnos_printf+0x1f8>
            case 'D':
            case 'u':
            case 'U':
            case 'x':
            case 'X':
                switch (c) {
  904d09:	240a64        	movi	a4, 100
  904d0c:	748130        	beq	a8, a4, 904d40 <fw_cmnos_printf+0x1ec>
  904d0f:	784315        	bltu	a4, a8, 904d28 <fw_cmnos_printf+0x1d4>
  904d12:	c545      	movi.n	a4, 85
  904d14:	748128        	beq	a8, a4, 904d40 <fw_cmnos_printf+0x1ec>
  904d17:	c548      	movi.n	a4, 88
  904d19:	74813b        	beq	a8, a4, 904d58 <fw_cmnos_printf+0x204>
  904d1c:	c444      	movi.n	a4, 68
  904d1e:	748102        	beq	a8, a4, 904d24 <fw_cmnos_printf+0x1d0>
  904d21:	600101        	j	904e26 <fw_cmnos_printf+0x2d2>
  904d24:	600018        	j	904d40 <fw_cmnos_printf+0x1ec>
  904d27:	00240a        	addx4	a4, a2, a0
  904d2a:	757481        	ball	a7, a5, 904caf <fw_cmnos_printf+0x15b>
  904d2d:	11240a        	l32r	a1, 8cdd58 <_bss_end+0x3c0550>
  904d30:	787481        	ball	a7, a8, 904cb5 <fw_cmnos_printf+0x161>
  904d33:	17240a        	l32r	a7, 8cdd5c <_bss_end+0x3c0554>
  904d36:	707481        	ball	a7, a0, 904cbb <fw_cmnos_printf+0x167>
  904d39:	026000        	ret
  904d3c:	e8          	.byte 0xe8
  904d3d:	60000b        	j	904d4c <fw_cmnos_printf+0x1f8>
                case 'd':
                case 'D':
                case 'u':
                case 'U':
                    length = _cvt(val, buf, 10, "0123456789");
  904d40:	da50      	mov.n	a10, a5
  904d42:	db10      	mov.n	a11, a1
  904d44:	c0ca      	movi.n	a12, 10
  904d46:	1d7227        	l32r	a13, 8e15e4 <athos_indirection_table_install+0x9c>
  904d49:	600014        	j	904d61 <fw_cmnos_printf+0x20d>
                    break;
                case 'p':
                case 'x':
                    length = _cvt(val, buf, 16, "0123456789abcdef");
  904d4c:	da50      	mov.n	a10, a5
  904d4e:	db10      	mov.n	a11, a1
  904d50:	c1c0      	movi.n	a12, 16
  904d52:	1d7228        	l32r	a13, 8e15f4 <athos_indirection_table_install+0xac>
  904d55:	600008        	j	904d61 <fw_cmnos_printf+0x20d>
                    break;
                case 'X':
                    length = _cvt(val, buf, 16, "0123456789ABCDEF");
  904d58:	1d7229        	l32r	a13, 8e15fc <athos_indirection_table_install+0xb4>
  904d5b:	da50      	mov.n	a10, a5
  904d5d:	db10      	mov.n	a11, a1
  904d5f:	c1c0      	movi.n	a12, 16
  904d61:	5bff5b        	call8	904ad0 <_cvt>
  904d64:	dba0      	mov.n	a11, a10
  904d66:	6000bc        	j	904e26 <fw_cmnos_printf+0x2d2>
  904d69:	00b438        	moveqz	a4, a11, a0
                }
                cp = buf;
                break;
            case 's':
            case 'S':
                cp = va_arg(ap, char *);
  904d6c:	c1a8      	movi.n	a10, 24
  904d6e:	241c30        	addi	a4, a1, 48
  904d71:	78aa07        	bge	a10, a8, 904d7c <fw_cmnos_printf+0x228>
  904d74:	73a201        	blt	a10, a3, 904d79 <fw_cmnos_printf+0x225>
  904d77:	c284      	movi.n	a8, 36
  904d79:	241c70        	addi	a4, a1, 112
  904d7c:	a844      	add.n	a4, a4, a8
  904d7e:	244cfc        	addi	a4, a4, -4
  904d81:	8440      	l32i.n	a4, a4, 0
                if (cp == NULL)  {
                    cp = "<null>";
  904d83:	137226        	l32r	a3, 8e161c <athos_indirection_table_install+0xd4>
                }
                length = 0;
  904d86:	c0b0      	movi.n	a11, 0
                break;
            case 's':
            case 'S':
                cp = va_arg(ap, char *);
                if (cp == NULL)  {
                    cp = "<null>";
  904d88:	043438        	moveqz	a4, a3, a4
  904d8b:	600001        	j	904d90 <fw_cmnos_printf+0x23c>
                }
                length = 0;
                while (cp[length] != '\0') length++;
  904d8e:	b1bb      	addi.n	a11, a11, 1
    }
    return (res);
}

int
fw_cmnos_printf(const char *fmt, ...)
  904d90:	ab43      	add.n	a3, a4, a11
                cp = va_arg(ap, char *);
                if (cp == NULL)  {
                    cp = "<null>";
                }
                length = 0;
                while (cp[length] != '\0') length++;
  904d92:	233000        	l8ui	a3, a3, 0
  904d95:	653ff5        	bnez	a3, 904d8e <fw_cmnos_printf+0x23a>
  904d98:	d380      	mov.n	a3, a8
  904d9a:	60008a        	j	904e28 <fw_cmnos_printf+0x2d4>
  904d9d:	00b436        	minu	a4, a11, a0
                break;
            case 'c':
            case 'C':
                c = va_arg(ap, int /*char*/);
  904da0:	c188      	movi.n	a8, 24
  904da2:	271c30        	addi	a7, a1, 48
  904da5:	768a07        	bge	a8, a6, 904db0 <fw_cmnos_printf+0x25c>
  904da8:	738201        	blt	a8, a3, 904dad <fw_cmnos_printf+0x259>
  904dab:	c264      	movi.n	a6, 36
  904dad:	271c70        	addi	a7, a1, 112
  904db0:	a677      	add.n	a7, a7, a6
  904db2:	277cfc        	addi	a7, a7, -4
                (*putc)(c);
  904db5:	2a7003        	l8ui	a10, a7, 3
  904db8:	2b1619        	s32i	a11, a1, 100
  904dbb:	5bff5b        	call8	904b28 <cmnos_write_char>
                res++;
  904dbe:	281214        	l32i	a8, a1, 80
  904dc1:	d360      	mov.n	a3, a6
  904dc3:	b188      	addi.n	a8, a8, 1
  904dc5:	281614        	s32i	a8, a1, 80
  904dc8:	600155        	j	904f21 <fw_cmnos_printf+0x3cd>
  904dcb:	00c2b0        	excw
                continue;
            case 'b':
            case 'B':
                length = left_prec;
                if (left_prec == 0) {
  904dce:	066b39        	movnez	a11, a6, a6
                    else if (islong)
                        length = sizeof(long)*8;
                    else
                        length = sizeof(int)*8;
                }
                for (i = 0;  i < length-1;  i++) {
  904dd1:	c040      	movi.n	a4, 0
  904dd3:	b0b8      	addi.n	a8, a11, -1
                    buf[i] = ((val & ((long)1<<i)) ? '1' : '.');
  904dd5:	c2ae      	movi.n	a10, 46
  904dd7:	c3c1      	movi.n	a12, 49
  904dd9:	600014        	j	904df1 <fw_cmnos_printf+0x29d>
  904ddc:	004004        	ssr	a4
  904ddf:	050e1b        	sra	a14, a5
  904de2:	0e0e40        	extui	a14, a14, 0, 1
  904de5:	d9c0      	mov.n	a9, a12
    }
    return (res);
}

int
fw_cmnos_printf(const char *fmt, ...)
  904de7:	a41d      	add.n	a13, a1, a4
                        length = sizeof(long)*8;
                    else
                        length = sizeof(int)*8;
                }
                for (i = 0;  i < length-1;  i++) {
                    buf[i] = ((val & ((long)1<<i)) ? '1' : '.');
  904de9:	0ea938        	moveqz	a9, a10, a14
  904dec:	29d400        	s8i	a9, a13, 0
                    else if (islong)
                        length = sizeof(long)*8;
                    else
                        length = sizeof(int)*8;
                }
                for (i = 0;  i < length-1;  i++) {
  904def:	b144      	addi.n	a4, a4, 1
  904df1:	7842e7        	blt	a4, a8, 904ddc <fw_cmnos_printf+0x288>
  904df4:	60002e        	j	904e26 <fw_cmnos_printf+0x2d2>
  904df7:	00c2a5        	excw
                    buf[i] = ((val & ((long)1<<i)) ? '1' : '.');
                }
                cp = buf;
                break;
            case '%':
                (*putc)('%');
  904dfa:	2b1619        	s32i	a11, a1, 100
  904dfd:	5bff4a        	call8	904b28 <cmnos_write_char>
  904e00:	60001c        	j	904e20 <fw_cmnos_printf+0x2cc>
  904e03:	0000c2        	excw
                break;
            default:
                (*putc)('%');
  904e06:	a528      	add.n	a8, a2, a5
  904e08:	16182b        	l32r	a6, 8caeb4 <_bss_end+0x3bd6ac>
  904e0b:	16195b        	l32r	a6, 8cb378 <_bss_end+0x3bdb70>
  904e0e:	ff          	.byte 0xff
  904e0f:	462812        	excw
                (*putc)(c);
  904e12:	18da80        	l32r	a8, 8fb814 <memset+0x16678>
  904e15:	5bff44        	call8	904b28 <cmnos_write_char>
                res += 2;
  904e18:	281214        	l32i	a8, a1, 80
  904e1b:	b288      	addi.n	a8, a8, 2
  904e1d:	281614        	s32i	a8, a1, 80
  904e20:	2b1219        	l32i	a11, a1, 100
  904e23:	600001        	j	904e28 <fw_cmnos_printf+0x2d4>
                    break;
                case 'X':
                    length = _cvt(val, buf, 16, "0123456789ABCDEF");
                    break;
                }
                cp = buf;
  904e26:	d410      	mov.n	a4, a1
            default:
                (*putc)('%');
                (*putc)(c);
                res += 2;
            }
            pad = left_prec - length;
  904e28:	0b660c        	sub	a6, a6, a11
            if (sign != '\0') {
  904e2b:	c87a      	beqz.n	a7, 904e39 <fw_cmnos_printf+0x2e5>
                pad--;
            }
            if (zero_fill) {
  904e2d:	291215        	l32i	a9, a1, 84
                (*putc)(c);
                res += 2;
            }
            pad = left_prec - length;
            if (sign != '\0') {
                pad--;
  904e30:	b066      	addi.n	a6, a6, -1
                    (*putc)(sign);
                    res++;
                    sign = '\0';
                }
            } else {
                c = ' ';
  904e32:	c280      	movi.n	a8, 32
            }
            pad = left_prec - length;
            if (sign != '\0') {
                pad--;
            }
            if (zero_fill) {
  904e34:	ca98      	beqz.n	a9, 904e60 <fw_cmnos_printf+0x30c>
  904e36:	60000f        	j	904e49 <fw_cmnos_printf+0x2f5>
                c = '0';
  904e39:	291215        	l32i	a9, a1, 84
  904e3c:	c380      	movi.n	a8, 48
  904e3e:	c2a0      	movi.n	a10, 32
  904e40:	09a838        	moveqz	a8, a10, a9
  904e43:	600019        	j	904e60 <fw_cmnos_printf+0x30c>
  904e46:	000000        	ill
                if (sign != '\0') {
                    (*putc)(sign);
  904e49:	da70      	mov.n	a10, a7
  904e4b:	2b1619        	s32i	a11, a1, 100
  904e4e:	5bff36        	call8	904b28 <cmnos_write_char>
                    res++;
  904e51:	281214        	l32i	a8, a1, 80
            pad = left_prec - length;
            if (sign != '\0') {
                pad--;
            }
            if (zero_fill) {
                c = '0';
  904e54:	2b1219        	l32i	a11, a1, 100
                if (sign != '\0') {
                    (*putc)(sign);
                    res++;
  904e57:	b188      	addi.n	a8, a8, 1
  904e59:	281614        	s32i	a8, a1, 80
                    sign = '\0';
  904e5c:	c070      	movi.n	a7, 0
            pad = left_prec - length;
            if (sign != '\0') {
                pad--;
            }
            if (zero_fill) {
                c = '0';
  904e5e:	c380      	movi.n	a8, 48
                    sign = '\0';
                }
            } else {
                c = ' ';
            }
            if (!pad_on_right) {
  904e60:	291216        	l32i	a9, a1, 88
  904e63:	dc60      	mov.n	a12, a6
  904e65:	c99b      	beqz.n	a9, 904e84 <fw_cmnos_printf+0x330>
  904e67:	60002e        	j	904e99 <fw_cmnos_printf+0x345>
                while (pad-- > 0) {
                    (*putc)(c);
  904e6a:	da80      	mov.n	a10, a8
  904e6c:	281618        	s32i	a8, a1, 96
  904e6f:	2b1619        	s32i	a11, a1, 100
  904e72:	2c1617        	s32i	a12, a1, 92
  904e75:	5bff2c        	call8	904b28 <cmnos_write_char>
  904e78:	2c1217        	l32i	a12, a1, 92
  904e7b:	2b1219        	l32i	a11, a1, 100
  904e7e:	281218        	l32i	a8, a1, 96
  904e81:	2cccff        	addi	a12, a12, -1
                }
            } else {
                c = ' ';
            }
            if (!pad_on_right) {
                while (pad-- > 0) {
  904e84:	6bc1e2        	bgei	a12, 1, 904e6a <fw_cmnos_printf+0x316>
  904e87:	291214        	l32i	a9, a1, 80
    }
    return (res);
}

int
fw_cmnos_printf(const char *fmt, ...)
  904e8a:	c080      	movi.n	a8, 0
  904e8c:	086835        	max	a8, a6, a8
  904e8f:	a899      	add.n	a9, a9, a8
  904e91:	b066      	addi.n	a6, a6, -1
  904e93:	291614        	s32i	a9, a1, 80
  904e96:	08660c        	sub	a6, a6, a8
                while (pad-- > 0) {
                    (*putc)(c);
                    res++;
                }
            }
            if (sign != '\0') {
  904e99:	647013        	beqz	a7, 904eb0 <fw_cmnos_printf+0x35c>
                (*putc)(sign);
  904e9c:	077a02        	or	a10, a7, a7
  904e9f:	2b1619        	s32i	a11, a1, 100
  904ea2:	5bff21        	call8	904b28 <cmnos_write_char>
                res++;
  904ea5:	281214        	l32i	a8, a1, 80
  904ea8:	2b1219        	l32i	a11, a1, 100
  904eab:	b188      	addi.n	a8, a8, 1
  904ead:	281614        	s32i	a8, a1, 80
                    (*putc)(sign);
                    res++;
                    sign = '\0';
                }
            } else {
                c = ' ';
  904eb0:	d740      	mov.n	a7, a4
    }
    return (res);
}

int
fw_cmnos_printf(const char *fmt, ...)
  904eb2:	ab48      	add.n	a8, a4, a11
  904eb4:	600014        	j	904ecc <fw_cmnos_printf+0x378>
  904eb7:	002a70        	excw
            if (sign != '\0') {
                (*putc)(sign);
                res++;
            }
            while (length-- > 0) {
                c = *cp++;
  904eba:	002816        	excw
                (*putc)(c);
  904ebd:	182b16        	l32r	a8, 8cfb18 <_bss_end+0x3c2310>
  904ec0:	195bff        	l32r	a9, 8dbebc <_bss_end+0x3ce6b4>
  904ec3:	192b12        	l32r	a9, 8cfb0c <_bss_end+0x3c2304>
  904ec6:	192812        	l32r	a9, 8cef10 <_bss_end+0x3c1708>
  904ec9:	18b177        	l32r	a8, 8f14a8 <memset+0xc30c>
    }
    return (res);
}

int
fw_cmnos_printf(const char *fmt, ...)
  904ecc:	078a0c        	sub	a10, a8, a7
            }
            if (sign != '\0') {
                (*putc)(sign);
                res++;
            }
            while (length-- > 0) {
  904ecf:	6ba1e5        	bgei	a10, 1, 904eb8 <fw_cmnos_printf+0x364>
  904ed2:	291214        	l32i	a9, a1, 80
    }
    return (res);
}

int
fw_cmnos_printf(const char *fmt, ...)
  904ed5:	c070      	movi.n	a7, 0
  904ed7:	07b735        	max	a7, a11, a7
  904eda:	a799      	add.n	a9, a9, a7
            while (length-- > 0) {
                c = *cp++;
                (*putc)(c);
                res++;
            }
            if (pad_on_right) {
  904edc:	281216        	l32i	a8, a1, 88
    }
    return (res);
}

int
fw_cmnos_printf(const char *fmt, ...)
  904edf:	b0bb      	addi.n	a11, a11, -1
  904ee1:	291614        	s32i	a9, a1, 80
  904ee4:	a744      	add.n	a4, a4, a7
  904ee6:	07bb0c        	sub	a11, a11, a7
            while (length-- > 0) {
                c = *cp++;
                (*putc)(c);
                res++;
            }
            if (pad_on_right) {
  904ee9:	cb87      	beqz.n	a8, 904f24 <fw_cmnos_printf+0x3d0>
  904eeb:	d760      	mov.n	a7, a6
  904eed:	60000c        	j	904efd <fw_cmnos_printf+0x3a9>
                while (pad-- > 0) {
                    (*putc)(' ');
  904ef0:	c2a0      	movi.n	a10, 32
  904ef2:	2b1619        	s32i	a11, a1, 100
  904ef5:	5bff0c        	call8	904b28 <cmnos_write_char>
  904ef8:	2b1219        	l32i	a11, a1, 100
  904efb:	b077      	addi.n	a7, a7, -1
                c = *cp++;
                (*putc)(c);
                res++;
            }
            if (pad_on_right) {
                while (pad-- > 0) {
  904efd:	6b71ef        	bgei	a7, 1, 904ef0 <fw_cmnos_printf+0x39c>
  904f00:	291214        	l32i	a9, a1, 80
    }
    return (res);
}

int
fw_cmnos_printf(const char *fmt, ...)
  904f03:	c070      	movi.n	a7, 0
  904f05:	076635        	max	a6, a6, a7
  904f08:	a699      	add.n	a9, a9, a6
  904f0a:	291614        	s32i	a9, a1, 80
  904f0d:	600013        	j	904f24 <fw_cmnos_printf+0x3d0>
  904f10:	002b16        	excw
                    (*putc)(' ');
                    res++;
                }
            }
        } else {
            (*putc)(c);
  904f13:	195bff        	l32r	a9, 8dbf10 <_bss_end+0x3ce708>
  904f16:	042612        	srai	a6, a4, 2
            res++;
  904f19:	14b122        	l32r	a4, 8f13a4 <memset+0xc208>
  904f1c:	b166      	addi.n	a6, a6, 1
  904f1e:	261614        	s32i	a6, a1, 80
  904f21:	2b1219        	l32i	a11, a1, 100
    int left_prec, right_prec, zero_fill, pad, pad_on_right,
        i, islong, islonglong;
    long val = 0;
    int res = 0, length = 0;

    while ((c = *fmt++) != '\0') {
  904f24:	2a2000        	l8ui	a10, a2, 0
  904f27:	65ac52        	bnez	a10, 904b7d <fw_cmnos_printf+0x29>
        ret = 0;
    }

    va_end(ap);
    return (ret);
}
  904f2a:	221214        	l32i	a2, a1, 80
  904f2d:	d10f      	retw.n
	...

00904f30 <ath_hal_attach_tgt>:

struct ath_hal*
ath_hal_attach_tgt(a_uint32_t devid,HAL_SOFTC sc,
		   adf_os_device_t dev,
		   a_uint32_t flags, HAL_STATUS *error)
{
  904f30:	6c1004        	entry	a1, 32
	struct ath_hal *ah = AH_NULL;

	ah = ar5416Attach(sc, dev, error);
  904f33:	da30      	mov.n	a10, a3
  904f35:	db40      	mov.n	a11, a4
  904f37:	dc60      	mov.n	a12, a6
  904f39:	5804e1        	call8	9062c0 <ar5416Attach>

	return ah;
}
  904f3c:	d2a0      	mov.n	a2, a10
  904f3e:	d10f      	retw.n

00904f40 <ath_hal_getcapability>:

HAL_STATUS
ath_hal_getcapability(struct ath_hal *ah, HAL_CAPABILITY_TYPE type)
{
  904f40:	6c1004        	entry	a1, 32
	const HAL_CAPABILITIES *pCap = &AH_PRIVATE(ah)->ah_caps;
	switch (type) {
  904f43:	68310d        	beqi	a3, 1, 904f54 <ath_hal_getcapability+0x14>
  904f46:	c93e      	beqz.n	a3, 904f68 <ath_hal_getcapability+0x28>
	case HAL_CAP_BSSIDMASK:
		return pCap->halBssIdMaskSupport ? HAL_OK : HAL_ENOTSUPP;
	case HAL_CAP_VEOL:
		return pCap->halVEOLSupport ? HAL_OK : HAL_ENOTSUPP;
	default:
		return HAL_EINVAL;
  904f48:	233cfe        	addi	a3, a3, -2
  904f4b:	c08d      	movi.n	a8, 13
  904f4d:	c02c      	movi.n	a2, 12
  904f4f:	038238        	moveqz	a2, a8, a3
  904f52:	d10f      	retw.n
	const HAL_CAPABILITIES *pCap = &AH_PRIVATE(ah)->ah_caps;
	switch (type) {
	case HAL_CAP_TSF_ADJUST:
		return HAL_ENOTSUPP;
	case HAL_CAP_BSSIDMASK:
		return pCap->halBssIdMaskSupport ? HAL_OK : HAL_ENOTSUPP;
  904f54:	28222b        	l32i	a8, a2, 172
  904f57:	12722a        	l32r	a2, 8e1800 <athos_indirection_table_install+0x2b8>
  904f5a:	c03d      	movi.n	a3, 13
  904f5c:	028801        	and	a8, a8, a2
  904f5f:	c020      	movi.n	a2, 0
  904f61:	083238        	moveqz	a2, a3, a8
  904f64:	d10f      	retw.n
  904f66:	000028        	mull	a0, a0, a0
	case HAL_CAP_VEOL:
		return pCap->halVEOLSupport ? HAL_OK : HAL_ENOTSUPP;
  904f69:	222b12        	l32ai	a2, a2, 72
  904f6c:	722b02        	bgeu	a2, a2, 904f72 <ath_hal_getcapability+0x32>
  904f6f:	8201      	l32i.n	a2, a0, 4
  904f71:	c08d      	movi.n	a8, 13
  904f73:	028338        	moveqz	a3, a8, a2
  904f76:	d230      	mov.n	a2, a3
	default:
		return HAL_EINVAL;
	}
}
  904f78:	d10f      	retw.n
	...

00904f7c <ath_hal_computetxtime>:

a_uint16_t
ath_hal_computetxtime(struct ath_hal *ah,
		      const HAL_RATE_TABLE *rates, a_uint32_t frameLen, a_uint16_t rateix,
		      HAL_BOOL shortPreamble)
{
  904f7c:	6c1004        	entry	a1, 32
  904f7f:	05054f        	extui	a5, a5, 0, 16
	a_uint32_t bitsPerSymbol, numBits, numSymbols, phyTime, txTime;
	a_uint32_t kbps;

	kbps = rates->info[rateix].rateKbps;
  904f82:	b252      	addi.n	a2, a5, 2
  904f84:	0c2211        	slli	a2, a2, 4
  904f87:	a233      	add.n	a3, a3, a2
  904f89:	8b33      	l32i.n	a11, a3, 12

	/*
	 * index can be invalid duting dynamic Turbo transitions.
	 */
	if(kbps == 0) return 0;
  904f8b:	c020      	movi.n	a2, 0
  904f8d:	72b150        	beq	a11, a2, 904fe1 <ath_hal_computetxtime+0x65>
	switch (rates->info[rateix].phy) {
  904f90:	283009        	l8ui	a8, a3, 9
  904f93:	728105        	beq	a8, a2, 904f9c <ath_hal_computetxtime+0x20>
  904f96:	698244        	bnei	a8, 2, 904fde <ath_hal_computetxtime+0x62>
  904f99:	600026        	j	904fc3 <ath_hal_computetxtime+0x47>

	case IEEE80211_T_CCK:
		phyTime = CCK_PREAMBLE_BITS + CCK_PLCP_BITS;
  904f9c:	220ac0        	movi	a2, 192
		if (shortPreamble && rates->info[rateix].shortPreamble)
  904f9f:	c867      	beqz.n	a6, 904faa <ath_hal_computetxtime+0x2e>
  904fa1:	263011        	l8ui	a6, a3, 17
	 */
	if(kbps == 0) return 0;
	switch (rates->info[rateix].phy) {

	case IEEE80211_T_CCK:
		phyTime = CCK_PREAMBLE_BITS + CCK_PLCP_BITS;
  904fa4:	230a60        	movi	a3, 96
  904fa7:	063239        	movnez	a2, a3, a6
		if (shortPreamble && rates->info[rateix].shortPreamble)
			phyTime >>= 1;
		numBits = frameLen << 3;
  904faa:	0d4311        	slli	a3, a4, 3
		txTime = phyTime + ((numBits * 1000)/kbps);
  904fad:	084411        	slli	a4, a4, 8
  904fb0:	03440c        	sub	a4, a4, a3
  904fb3:	034a0a        	addx4	a10, a4, a3
  904fb6:	0daa11        	slli	a10, a10, 3
  904fb9:	5b7f79        	call8	8e4da0 <__udivsi3>
  904fbc:	baaa      	addi.n	a10, a10, 10
		/* TODO: make sure the same value of txTime can use in all device */
		if (ath_hal_getcapability(ah, HAL_CAP_HT) != HAL_OK)
			txTime = txTime + CCK_SIFS_TIME;
  904fbe:	a2a2      	add.n	a2, a10, a2
  904fc0:	60001a        	j	904fde <ath_hal_computetxtime+0x62>
		break;
	case IEEE80211_T_OFDM:
		/* full rate channel */
		bitsPerSymbol   = (kbps * OFDM_SYMBOL_TIME) / 1000;
  904fc3:	12722c        	l32r	a2, 8e1874 <athos_indirection_table_install+0x32c>
  904fc6:	0ebb11        	slli	a11, a11, 2
  904fc9:	02bb2a        	muluh	a11, a11, a2
  904fcc:	0b6b14        	srli	a11, a11, 6
		HALASSERT(bitsPerSymbol != 0);

		numBits = OFDM_PLCP_BITS + (frameLen << 3);
		numSymbols = asf_howmany(numBits, bitsPerSymbol);
  904fcf:	2abc15        	addi	a10, a11, 21
  904fd2:	0a4a0b        	addx8	a10, a4, a10
  904fd5:	5b7f72        	call8	8e4da0 <__udivsi3>
		txTime = OFDM_PREAMBLE_TIME + (numSymbols * OFDM_SYMBOL_TIME);
  904fd8:	0eaa11        	slli	a10, a10, 2
		/* TODO: make sure the same value of txTime can use in all device */
		if (ath_hal_getcapability(ah, HAL_CAP_HT) != HAL_OK)
			txTime = txTime + OFDM_SIFS_TIME;
  904fdb:	22ac24        	addi	a2, a10, 36
		break;
	default:
		txTime = 0;
		break;
	}
	return txTime;
  904fde:	02024f        	extui	a2, a2, 0, 16
}
  904fe1:	d10f      	retw.n
	...

00904fe4 <ath_hal_wait>:

#endif

HAL_BOOL
ath_hal_wait(struct ath_hal *ah, a_uint32_t reg, a_uint32_t mask, a_uint32_t val)
{
  904fe4:	6c1004        	entry	a1, 32
				return AH_TRUE;
			OS_DELAY(10);
		}
	} else {
		for (i = 0; i < AH_TIMEOUT_11G; i++) {
			if ((ioread32_mac(reg) & mask) == val)
  904fe7:	18722d        	l32r	a8, 8e189c <athos_indirection_table_install+0x354>

#endif

HAL_BOOL
ath_hal_wait(struct ath_hal *ah, a_uint32_t reg, a_uint32_t mask, a_uint32_t val)
{
  904fea:	223ae8        	movi	a2, 0x3e8
				return AH_TRUE;
			OS_DELAY(10);
		}
	} else {
		for (i = 0; i < AH_TIMEOUT_11G; i++) {
			if ((ioread32_mac(reg) & mask) == val)
  904fed:	083308        	add	a3, a3, a8
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  904ff0:	0c0200        	memw
  904ff3:	8830      	l32i.n	a8, a3, 0
  904ff5:	084801        	and	a8, a4, a8
  904ff8:	75810d        	beq	a8, a5, 905009 <ath_hal_wait+0x25>
				return AH_TRUE;
			OS_DELAY(10);
  904ffb:	2a0a0a        	movi	a10, 10
  904ffe:	222cff        	addi	a2, a2, -1
  905001:	5bfaf4        	call8	903bd4 <ath_hal_delay>
			if ((ioread32_mac(reg) & mask) == val)
				return AH_TRUE;
			OS_DELAY(10);
		}
	} else {
		for (i = 0; i < AH_TIMEOUT_11G; i++) {
  905004:	652fe8        	bnez	a2, 904ff0 <ath_hal_wait+0xc>
  905007:	d10f      	retw.n
			if ((ioread32_mac(reg) & mask) == val)
				return AH_TRUE;
  905009:	c021      	movi.n	a2, 1
	}
	return AH_FALSE;

#undef AH_TIMEOUT_11N
#undef AH_TIMEOUT_11G
}
  90500b:	d10f      	retw.n
  90500d:	000000        	ill

00905010 <ar5416IsInterruptPending>:
/**********************/
/* Interrupt Handling */
/**********************/

HAL_BOOL ar5416IsInterruptPending(struct ath_hal *ah)
{
  905010:	6c1004        	entry	a1, 32
	a_uint32_t host_isr;

	A_DELAY_USECS(1);
  905013:	127184        	l32r	a2, 8e1624 <athos_indirection_table_install+0xdc>
  905016:	c0a1      	movi.n	a10, 1
  905018:	22223a        	l32i	a2, a2, 232
  90501b:	0b2000        	callx8	a2
  90501e:	12722e        	l32r	a2, 8e18d8 <athos_indirection_table_install+0x390>
  905021:	0c0200        	memw
  905024:	8820      	l32i.n	a8, a2, 0
	host_isr = ioread32_mac(AR_INTR_ASYNC_CAUSE);
	/*
	 * Some platforms trigger our ISR before applying power to
	 * the card, so make sure.
	 */
	return ((host_isr != AR_INTR_SPURIOUS) && (host_isr & AR_INTR_MAC_IRQ));
  905026:	c020      	movi.n	a2, 0
  905028:	081940        	extui	a9, a8, 1, 1
  90502b:	b188      	addi.n	a8, a8, 1
  90502d:	089239        	movnez	a2, a9, a8
}
  905030:	d10f      	retw.n
	...

00905034 <ar5416SetInterrupts>:
	return AH_TRUE;
}

HAL_INT
ar5416SetInterrupts(struct ath_hal *ah, HAL_INT ints)
{
  905034:	6c1004        	entry	a1, 32
  905037:	d920      	mov.n	a9, a2
	struct ath_hal_5416 *ahp = AH5416(ah);
	a_uint32_t omask = ahp->ah_maskReg;
  905039:	222235        	l32i	a2, a2, 212
	a_uint32_t mask;

	if (omask & HAL_INT_GLOBAL) {
  90503c:	672011        	bgez	a2, 905051 <ar5416SetInterrupts+0x1d>
  90503f:	18722f        	l32r	a8, 8e18fc <athos_indirection_table_install+0x3b4>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  905042:	2a0a00        	movi	a10, 0
  905045:	0c0200        	memw
  905048:	2a8600        	s32i	a10, a8, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90504b:	0c0200        	memw
  90504e:	288200        	l32i	a8, a8, 0
		iowrite32_mac(AR_IER, AR_IER_DISABLE);
		(void) ioread32_mac(AR_IER);
	}

	mask = ints & HAL_INT_COMMON;
  905051:	187230        	l32r	a8, 8e1914 <athos_indirection_table_install+0x3cc>
  905054:	083801        	and	a8, a3, a8
	if (ints & HAL_INT_TX) {
  905057:	793705        	bbci	a3, 25, 905060 <ar5416SetInterrupts+0x2c>
#else
		mask |= AR_IMR_TXOK;
		mask |= AR_IMR_TXDESC;
#endif
		mask |= AR_IMR_TXERR;
		mask |= AR_IMR_TXEOL;
  90505a:	2a5ac0        	movi	a10, 0x5c0
  90505d:	0a8802        	or	a8, a8, a10
	}
	if (ints & HAL_INT_RX) {
  905060:	7f3704        	bbci	a3, 31, 905068 <ar5416SetInterrupts+0x34>
		mask |= AR_IMR_RXERR;
#ifdef AR5416_INT_MITIGATION
		mask |=  AR_IMR_RXMINTR | AR_IMR_RXINTM;
#else
		mask |= AR_IMR_RXOK | AR_IMR_RXDESC;
  905063:	c0a7      	movi.n	a10, 7
  905065:	0a8802        	or	a8, a8, a10
#endif
	}

	if (ints & (HAL_INT_GTT | HAL_INT_CST)) {
  905068:	1a7231        	l32r	a10, 8e192c <athos_indirection_table_install+0x3e4>
  90506b:	7a3005        	bnone	a3, a10, 905074 <ar5416SetInterrupts+0x40>
		mask |= AR_IMR_BCNMISC;
  90506e:	1a7232        	l32r	a10, 8e1938 <athos_indirection_table_install+0x3f0>
  905071:	0a8802        	or	a8, a8, a10
  905074:	1a7233        	l32r	a10, 8e1940 <athos_indirection_table_install+0x3f8>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  905077:	0c0200        	memw
  90507a:	98a0      	s32i.n	a8, a10, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90507c:	0c0200        	memw
  90507f:	88a0      	l32i.n	a8, a10, 0
	}

	iowrite32_mac(AR_IMR, mask);
	(void) ioread32_mac(AR_IMR);
	ahp->ah_maskReg = ints;
  905081:	239635        	s32i	a3, a9, 212

	/* Re-enable interrupts if they were enabled before. */
	if (ints & HAL_INT_GLOBAL) {
  905084:	673010        	bgez	a3, 905098 <ar5416SetInterrupts+0x64>
  905087:	13722f        	l32r	a3, 8e1944 <athos_indirection_table_install+0x3fc>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90508a:	c081      	movi.n	a8, 1
  90508c:	0c0200        	memw
  90508f:	283600        	s32i	a8, a3, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  905092:	0c0200        	memw
  905095:	233200        	l32i	a3, a3, 0
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  905098:	187234        	l32r	a8, 8e1968 <athos_indirection_table_install+0x420>
  90509b:	c032      	movi.n	a3, 2
  90509d:	0c0200        	memw
  9050a0:	9380      	s32i.n	a3, a8, 0
  9050a2:	187235        	l32r	a8, 8e1978 <athos_indirection_table_install+0x430>
  9050a5:	0c0200        	memw
  9050a8:	9380      	s32i.n	a3, a8, 0
  9050aa:	187237        	l32r	a8, 8e1988 <athos_indirection_table_install+0x440>
  9050ad:	137236        	l32r	a3, 8e1988 <athos_indirection_table_install+0x440>
  9050b0:	0c0200        	memw
  9050b3:	9830      	s32i.n	a8, a3, 0
	iowrite32_mac(AR_INTR_ASYNC_ENABLE, AR_INTR_MAC_IRQ);
	iowrite32_mac(AR_INTR_ASYNC_MASK, AR_INTR_MAC_IRQ);
	iowrite32_mac(AR_INTR_SYNC_ENABLE, AR_INTR_SYNC_ALL);

	return omask;
}
  9050b5:	d10f      	retw.n
	...

009050b8 <ar5416GetTsf64>:
/****************/

#define ATH9K_HTC_MAX_TSF_READ 3

u_int64_t ar5416GetTsf64(struct ath_hal *ah)
{
  9050b8:	6c1004        	entry	a1, 32
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  9050bb:	187238        	l32r	a8, 8e199c <athos_indirection_table_install+0x454>
  9050be:	197239        	l32r	a9, 8e19a4 <athos_indirection_table_install+0x45c>
  9050c1:	0c0200        	memw
  9050c4:	8a80      	l32i.n	a10, a8, 0
  9050c6:	0c0200        	memw
  9050c9:	8390      	l32i.n	a3, a9, 0
  9050cb:	0c0200        	memw
  9050ce:	8280      	l32i.n	a2, a8, 0

	tsf_upper1 = ioread32_mac(AR_TSF_U32);
	for (i = 0; i < ATH9K_HTC_MAX_TSF_READ; i++) {
		tsf_lower = ioread32_mac(AR_TSF_L32);
		tsf_upper2 = ioread32_mac(AR_TSF_U32);
		if (tsf_upper2 == tsf_upper1)
  9050d0:	7a2116        	beq	a2, a10, 9050ea <ar5416GetTsf64+0x32>
  9050d3:	0c0200        	memw
  9050d6:	8390      	l32i.n	a3, a9, 0
  9050d8:	0c0200        	memw
  9050db:	8a80      	l32i.n	a10, a8, 0
  9050dd:	72a109        	beq	a10, a2, 9050ea <ar5416GetTsf64+0x32>
  9050e0:	0c0200        	memw
  9050e3:	8390      	l32i.n	a3, a9, 0
  9050e5:	0c0200        	memw
  9050e8:	8280      	l32i.n	a2, a8, 0
			break;
		tsf_upper1 = tsf_upper2;
	}

	return (((u_int64_t)tsf_upper2 << 32) | tsf_lower);
}
  9050ea:	d10f      	retw.n

009050ec <ar5416SetRxDP>:

/******/
/* RX */
/******/
void ar5416SetRxDP(struct ath_hal *ah, a_uint32_t rxdp)
{
  9050ec:	6c1004        	entry	a1, 32
  9050ef:	18723a        	l32r	a8, 8e19d8 <athos_indirection_table_install+0x490>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  9050f2:	0c0200        	memw
  9050f5:	9380      	s32i.n	a3, a8, 0
  9050f7:	d10f      	retw.n
  9050f9:	000000        	ill

009050fc <ar5416EnableReceive>:
			     & ~AR_RXCFG_ZLFDMA);
	}
}

void ar5416EnableReceive(struct ath_hal *ah)
{
  9050fc:	6c1004        	entry	a1, 32
  9050ff:	18723b        	l32r	a8, 8e19ec <athos_indirection_table_install+0x4a4>
  905102:	c094      	movi.n	a9, 4
  905104:	0c0200        	memw
  905107:	9980      	s32i.n	a9, a8, 0
  905109:	d10f      	retw.n
	...

0090510c <ar5416StopPcuReceive>:
	iowrite32_mac(AR_CR, AR_CR_RXE);
}

void ar5416StopPcuReceive(struct ath_hal *ah)
{
  90510c:	6c1004        	entry	a1, 32
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90510f:	18723c        	l32r	a8, 8e1a00 <athos_indirection_table_install+0x4b8>
	OS_REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_RX_DIS);
  905112:	c290      	movi.n	a9, 32
  905114:	0c0200        	memw
  905117:	8a80      	l32i.n	a10, a8, 0
  905119:	09a902        	or	a9, a10, a9
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90511c:	0c0200        	memw
  90511f:	9980      	s32i.n	a9, a8, 0
  905121:	d10f      	retw.n
	...

00905124 <ar5416SetupRxDesc_20>:
}

HAL_BOOL ar5416SetupRxDesc_20(struct ath_rx_desc *ds,
			      a_uint32_t size, a_uint32_t flags)
{
  905124:	6c1004        	entry	a1, 32
	struct ar5416_desc *ads = AR5416DESC(ds);

	HALASSERT((size &~ AR_BufLen) == 0);

	ads->ds_ctl1 = size & AR_BufLen;
  905127:	03084b        	extui	a8, a3, 0, 12
	if (flags & HAL_RXDESC_INTREQ)
  90512a:	7a4f16        	bbsi	a4, 26, 905144 <ar5416SetupRxDesc_20+0x20>
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	HALASSERT((size &~ AR_BufLen) == 0);

	ads->ds_ctl1 = size & AR_BufLen;
  90512d:	088957        	extui	a9, a8, 24, 8
  905130:	29240c        	s8i	a9, a2, 12
  905133:	088814        	srli	a8, a8, 8
  905136:	c090      	movi.n	a9, 0
  905138:	29240d        	s8i	a9, a2, 13
  90513b:	28240e        	s8i	a8, a2, 14
  90513e:	23240f        	s8i	a3, a2, 15
  905141:	60001a        	j	90515f <ar5416SetupRxDesc_20+0x3b>
	if (flags & HAL_RXDESC_INTREQ)
		ads->ds_ctl1 |= AR_RxIntrReq;
  905144:	13723d        	l32r	a3, 8e1a38 <athos_indirection_table_install+0x4f0>
  905147:	038802        	or	a8, a8, a3
  90514a:	088357        	extui	a3, a8, 24, 8
  90514d:	23240c        	s8i	a3, a2, 12
  905150:	080357        	extui	a3, a8, 16, 8
  905153:	23240d        	s8i	a3, a2, 13
  905156:	088347        	extui	a3, a8, 8, 8
  905159:	23240e        	s8i	a3, a2, 14
  90515c:	28240f        	s8i	a8, a2, 15

	/* this should be enough */
	ads->ds_rxstatus8 &= ~AR_RxDone;
  90515f:	292030        	l8ui	a9, a2, 48
  905162:	232031        	l8ui	a3, a2, 49
  905165:	282032        	l8ui	a8, a2, 50
  905168:	089910        	slli	a9, a9, 24
  90516b:	003311        	slli	a3, a3, 16
  90516e:	093302        	or	a3, a3, a9
  905171:	088811        	slli	a8, a8, 8
  905174:	038802        	or	a8, a8, a3
  905177:	232033        	l8ui	a3, a2, 51
  90517a:	083802        	or	a8, a3, a8
  90517d:	c73e      	movi.n	a3, -2
  90517f:	038801        	and	a8, a8, a3
  905182:	088357        	extui	a3, a8, 24, 8
  905185:	232430        	s8i	a3, a2, 48
  905188:	080357        	extui	a3, a8, 16, 8
  90518b:	232431        	s8i	a3, a2, 49
  90518e:	088347        	extui	a3, a8, 8, 8
  905191:	232432        	s8i	a3, a2, 50
  905194:	282433        	s8i	a8, a2, 51

	return AH_TRUE;
}
  905197:	c021      	movi.n	a2, 1
  905199:	d10f      	retw.n
	...

0090519c <ar5416ProcRxDescFast_20>:

HAL_STATUS ar5416ProcRxDescFast_20(struct ath_hal *ah, struct ath_rx_desc *ds,
				   a_uint32_t pa, struct ath_desc *nds,
				   struct ath_rx_status *rx_stats)
{
  90519c:	6c1004        	entry	a1, 32
	struct ar5416_desc ads;
	struct ar5416_desc *adsp = AR5416DESC(ds);
	struct ar5416_desc *ands = AR5416DESC(nds);

	if ((adsp->ds_rxstatus8 & AR_RxDone) == 0)
  90519f:	293030        	l8ui	a9, a3, 48
  9051a2:	223031        	l8ui	a2, a3, 49
  9051a5:	283032        	l8ui	a8, a3, 50
  9051a8:	089910        	slli	a9, a9, 24
  9051ab:	002211        	slli	a2, a2, 16
  9051ae:	092202        	or	a2, a2, a9
  9051b1:	088811        	slli	a8, a8, 8
  9051b4:	028802        	or	a8, a8, a2
  9051b7:	223033        	l8ui	a2, a3, 51
  9051ba:	082802        	or	a8, a2, a8
		return HAL_EINPROGRESS;
  9051bd:	c02f      	movi.n	a2, 15
{
	struct ar5416_desc ads;
	struct ar5416_desc *adsp = AR5416DESC(ds);
	struct ar5416_desc *ands = AR5416DESC(nds);

	if ((adsp->ds_rxstatus8 & AR_RxDone) == 0)
  9051bf:	7f8f02        	bbsi	a8, 31, 9051c5 <ar5416ProcRxDescFast_20+0x29>
  9051c2:	6001be        	j	905384 <ar5416ProcRxDescFast_20+0x1e8>
	/*
	 * Given the use of a self-linked tail be very sure that the hw is
	 * done with this descriptor; the hw may have done this descriptor
	 * once and picked it up again...make sure the hw has moved on.
	 */
	if ((ands->ds_rxstatus8 & AR_RxDone) == 0
  9051c5:	255033        	l8ui	a5, a5, 51
  9051c8:	7f5f0d        	bbsi	a5, 31, 9051d9 <ar5416ProcRxDescFast_20+0x3d>
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  9051cb:	15723a        	l32r	a5, 8e1ab4 <athos_indirection_table_install+0x56c>
  9051ce:	0c0200        	memw
  9051d1:	8550      	l32i.n	a5, a5, 0
	    && ioread32_mac(AR_RXDP) == pa)
  9051d3:	745902        	bne	a5, a4, 9051d9 <ar5416ProcRxDescFast_20+0x3d>
  9051d6:	6001aa        	j	905384 <ar5416ProcRxDescFast_20+0x1e8>
	 * Next we fill in all values in a caller passed stack variable.
	 * This reduces the number of uncached accesses.
	 * Do this copy here, after the check so that when the checks fail, we
	 * dont end up copying the entire stats uselessly.
	 */
	ads.u.rx = adsp->u.rx;
  9051d9:	243010        	l8ui	a4, a3, 16
  9051dc:	223011        	l8ui	a2, a3, 17
  9051df:	2a3012        	l8ui	a10, a3, 18
  9051e2:	084410        	slli	a4, a4, 24
  9051e5:	002211        	slli	a2, a2, 16
  9051e8:	042202        	or	a2, a2, a4
  9051eb:	08aa11        	slli	a10, a10, 8
  9051ee:	02aa02        	or	a10, a10, a2
  9051f1:	223013        	l8ui	a2, a3, 19
  9051f4:	243014        	l8ui	a4, a3, 20
  9051f7:	0a2a02        	or	a10, a2, a10
  9051fa:	223015        	l8ui	a2, a3, 21
  9051fd:	2b3016        	l8ui	a11, a3, 22
  905200:	084410        	slli	a4, a4, 24
  905203:	002211        	slli	a2, a2, 16
  905206:	042202        	or	a2, a2, a4
  905209:	08bb11        	slli	a11, a11, 8
  90520c:	02bb02        	or	a11, a11, a2
  90520f:	223017        	l8ui	a2, a3, 23
  905212:	243018        	l8ui	a4, a3, 24
  905215:	0b2b02        	or	a11, a2, a11
  905218:	223019        	l8ui	a2, a3, 25
  90521b:	2c301a        	l8ui	a12, a3, 26
  90521e:	084410        	slli	a4, a4, 24
  905221:	002211        	slli	a2, a2, 16
  905224:	042202        	or	a2, a2, a4
  905227:	08cc11        	slli	a12, a12, 8
  90522a:	02cc02        	or	a12, a12, a2
  90522d:	22301b        	l8ui	a2, a3, 27
  905230:	25301c        	l8ui	a5, a3, 28
  905233:	24301d        	l8ui	a4, a3, 29
  905236:	0c2c02        	or	a12, a2, a12
  905239:	22301e        	l8ui	a2, a3, 30
  90523c:	085510        	slli	a5, a5, 24
  90523f:	004411        	slli	a4, a4, 16
  905242:	054402        	or	a4, a4, a5
  905245:	082211        	slli	a2, a2, 8
  905248:	042202        	or	a2, a2, a4
  90524b:	24301f        	l8ui	a4, a3, 31
  90524e:	253020        	l8ui	a5, a3, 32
  905251:	024202        	or	a2, a4, a2
  905254:	243021        	l8ui	a4, a3, 33
  905257:	293022        	l8ui	a9, a3, 34
  90525a:	085510        	slli	a5, a5, 24
  90525d:	004411        	slli	a4, a4, 16
  905260:	054402        	or	a4, a4, a5
  905263:	089911        	slli	a9, a9, 8
  905266:	049902        	or	a9, a9, a4
  905269:	243023        	l8ui	a4, a3, 35
  90526c:	2d3024        	l8ui	a13, a3, 36
  90526f:	253025        	l8ui	a5, a3, 37
  905272:	094902        	or	a9, a4, a9
  905275:	243026        	l8ui	a4, a3, 38
  905278:	08dd10        	slli	a13, a13, 24
  90527b:	005511        	slli	a5, a5, 16
  90527e:	0d5502        	or	a5, a5, a13
  905281:	084411        	slli	a4, a4, 8
  905284:	054402        	or	a4, a4, a5
  905287:	253027        	l8ui	a5, a3, 39
  90528a:	2e3028        	l8ui	a14, a3, 40
  90528d:	2d3029        	l8ui	a13, a3, 41
  905290:	045402        	or	a4, a5, a4
  905293:	25302a        	l8ui	a5, a3, 42
  905296:	08ee10        	slli	a14, a14, 24
  905299:	00dd11        	slli	a13, a13, 16
  90529c:	23302b        	l8ui	a3, a3, 43
  90529f:	0edd02        	or	a13, a13, a14
  9052a2:	085511        	slli	a5, a5, 8
  9052a5:	0d5502        	or	a5, a5, a13
  9052a8:	053502        	or	a5, a3, a5

	rx_stats->rs_status = 0;
  9052ab:	c030      	movi.n	a3, 0
  9052ad:	23640a        	s8i	a3, a6, 10
	rx_stats->rs_flags = 0;
  9052b0:	23641a        	s8i	a3, a6, 26

	rx_stats->rs_datalen = ads.ds_rxstatus1 & AR_DataLen;
  9052b3:	0b034b        	extui	a3, a11, 0, 12
  9052b6:	236504        	s16i	a3, a6, 8
	rx_stats->rs_tstamp =  ads.AR_RcvTimestamp;
  9052b9:	c030      	movi.n	a3, 0
  9052bb:	9360      	s32i.n	a3, a6, 0
  9052bd:	9c61      	s32i.n	a12, a6, 4

	/* XXX what about KeyCacheMiss? */
	rx_stats->rs_rssi_combined = 
		MS(ads.ds_rxstatus4, AR_RxRSSICombined);
  9052bf:	098357        	extui	a3, a9, 24, 8

	rx_stats->rs_datalen = ads.ds_rxstatus1 & AR_DataLen;
	rx_stats->rs_tstamp =  ads.AR_RcvTimestamp;

	/* XXX what about KeyCacheMiss? */
	rx_stats->rs_rssi_combined = 
  9052c2:	23640c        	s8i	a3, a6, 12
		MS(ads.ds_rxstatus4, AR_RxRSSICombined);
	rx_stats->rs_rssi_ctl0 = MS(ads.ds_rxstatus0, AR_RxRSSIAnt00);
	rx_stats->rs_rssi_ctl1 = MS(ads.ds_rxstatus0, AR_RxRSSIAnt01);
  9052c5:	0a8347        	extui	a3, a10, 8, 8
  9052c8:	23640e        	s8i	a3, a6, 14
	rx_stats->rs_rssi_ctl2 = MS(ads.ds_rxstatus0, AR_RxRSSIAnt02);
  9052cb:	0a0357        	extui	a3, a10, 16, 8
  9052ce:	23640f        	s8i	a3, a6, 15
	rx_stats->rs_rssi_ext0 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt10);
	rx_stats->rs_rssi_ext1 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt11);
  9052d1:	098347        	extui	a3, a9, 8, 8
  9052d4:	236411        	s8i	a3, a6, 17
	rx_stats->rs_rssi_ext2 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt12);
  9052d7:	090357        	extui	a3, a9, 16, 8
  9052da:	236412        	s8i	a3, a6, 18
	rx_stats->rs_tstamp =  ads.AR_RcvTimestamp;

	/* XXX what about KeyCacheMiss? */
	rx_stats->rs_rssi_combined = 
		MS(ads.ds_rxstatus4, AR_RxRSSICombined);
	rx_stats->rs_rssi_ctl0 = MS(ads.ds_rxstatus0, AR_RxRSSIAnt00);
  9052dd:	2a640d        	s8i	a10, a6, 13
	rx_stats->rs_rssi_ctl1 = MS(ads.ds_rxstatus0, AR_RxRSSIAnt01);
	rx_stats->rs_rssi_ctl2 = MS(ads.ds_rxstatus0, AR_RxRSSIAnt02);
	rx_stats->rs_rssi_ext0 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt10);
  9052e0:	296410        	s8i	a9, a6, 16
	rx_stats->rs_rssi_ext1 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt11);
	rx_stats->rs_rssi_ext2 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt12);
	if (ads.ds_rxstatus8 & AR_RxKeyIdxValid)
		rx_stats->rs_keyix = MS(ads.ds_rxstatus8, AR_KeyIdx);
  9052e3:	089346        	extui	a3, a8, 9, 7
	rx_stats->rs_rssi_ctl1 = MS(ads.ds_rxstatus0, AR_RxRSSIAnt01);
	rx_stats->rs_rssi_ctl2 = MS(ads.ds_rxstatus0, AR_RxRSSIAnt02);
	rx_stats->rs_rssi_ext0 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt10);
	rx_stats->rs_rssi_ext1 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt11);
	rx_stats->rs_rssi_ext2 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt12);
	if (ads.ds_rxstatus8 & AR_RxKeyIdxValid)
  9052e6:	778f02        	bbsi	a8, 23, 9052ec <ar5416ProcRxDescFast_20+0x150>
		rx_stats->rs_keyix = MS(ads.ds_rxstatus8, AR_KeyIdx);
	else
		rx_stats->rs_keyix = HAL_RXKEYIX_INVALID;
  9052e9:	23faff        	movi	a3, -1
  9052ec:	236413        	s8i	a3, a6, 19
	/* NB: caller expected to do rate table mapping */
	rx_stats->rs_rate = RXSTATUS_RATE(ah, (&ads));
	rx_stats->rs_more = (ads.ds_rxstatus1 & AR_RxMore) ? 1 : 0;

	rx_stats->rs_isaggr = (ads.ds_rxstatus8 & AR_RxAggr) ? 1 : 0;
  9052ef:	081350        	extui	a3, a8, 17, 1
  9052f2:	236417        	s8i	a3, a6, 23
	rx_stats->rs_moreaggr = (ads.ds_rxstatus8 & AR_RxMoreAggr) ? 1 : 0;
  9052f5:	080350        	extui	a3, a8, 16, 1
	if (ads.ds_rxstatus8 & AR_RxKeyIdxValid)
		rx_stats->rs_keyix = MS(ads.ds_rxstatus8, AR_KeyIdx);
	else
		rx_stats->rs_keyix = HAL_RXKEYIX_INVALID;
	/* NB: caller expected to do rate table mapping */
	rx_stats->rs_rate = RXSTATUS_RATE(ah, (&ads));
  9052f8:	0a8a57        	extui	a10, a10, 24, 8
	rx_stats->rs_more = (ads.ds_rxstatus1 & AR_RxMore) ? 1 : 0;
  9052fb:	0bcb40        	extui	a11, a11, 12, 1

	rx_stats->rs_isaggr = (ads.ds_rxstatus8 & AR_RxAggr) ? 1 : 0;
	rx_stats->rs_moreaggr = (ads.ds_rxstatus8 & AR_RxMoreAggr) ? 1 : 0;
  9052fe:	236418        	s8i	a3, a6, 24
	rx_stats->rs_flags  |= (ads.ds_rxstatus3 & AR_GI) ? HAL_RX_GI : 0;
	rx_stats->rs_flags  |= (ads.ds_rxstatus3 & AR_2040) ? HAL_RX_2040 : 0;
  905301:	c032      	movi.n	a3, 2
	if (ads.ds_rxstatus8 & AR_RxKeyIdxValid)
		rx_stats->rs_keyix = MS(ads.ds_rxstatus8, AR_KeyIdx);
	else
		rx_stats->rs_keyix = HAL_RXKEYIX_INVALID;
	/* NB: caller expected to do rate table mapping */
	rx_stats->rs_rate = RXSTATUS_RATE(ah, (&ads));
  905303:	2a6414        	s8i	a10, a6, 20
	rx_stats->rs_more = (ads.ds_rxstatus1 & AR_RxMore) ? 1 : 0;
  905306:	2b6416        	s8i	a11, a6, 22

	rx_stats->rs_isaggr = (ads.ds_rxstatus8 & AR_RxAggr) ? 1 : 0;
	rx_stats->rs_moreaggr = (ads.ds_rxstatus8 & AR_RxMoreAggr) ? 1 : 0;
	rx_stats->rs_flags  |= (ads.ds_rxstatus3 & AR_GI) ? HAL_RX_GI : 0;
  905309:	020a40        	extui	a10, a2, 0, 1
	rx_stats->rs_flags  |= (ads.ds_rxstatus3 & AR_2040) ? HAL_RX_2040 : 0;
  90530c:	c0b0      	movi.n	a11, 0
  90530e:	032201        	and	a2, a2, a3
  905311:	c038      	movi.n	a3, 8
	rx_stats->rs_rate = RXSTATUS_RATE(ah, (&ads));
	rx_stats->rs_more = (ads.ds_rxstatus1 & AR_RxMore) ? 1 : 0;

	rx_stats->rs_isaggr = (ads.ds_rxstatus8 & AR_RxAggr) ? 1 : 0;
	rx_stats->rs_moreaggr = (ads.ds_rxstatus8 & AR_RxMoreAggr) ? 1 : 0;
	rx_stats->rs_flags  |= (ads.ds_rxstatus3 & AR_GI) ? HAL_RX_GI : 0;
  905313:	0eaa11        	slli	a10, a10, 2
	rx_stats->rs_flags  |= (ads.ds_rxstatus3 & AR_2040) ? HAL_RX_2040 : 0;
  905316:	02b338        	moveqz	a3, a11, a2
  905319:	0a3302        	or	a3, a3, a10

	if (ads.ds_rxstatus8 & AR_PreDelimCRCErr)
  90531c:	798f02        	bbsi	a8, 25, 905322 <ar5416ProcRxDescFast_20+0x186>
  90531f:	600004        	j	905327 <ar5416ProcRxDescFast_20+0x18b>
		rx_stats->rs_flags |= HAL_RX_DELIM_CRC_PRE;
  905322:	c120      	movi.n	a2, 16
  905324:	023302        	or	a3, a3, a2
  905327:	23641a        	s8i	a3, a6, 26
	if (ads.ds_rxstatus8 & AR_PostDelimCRCErr)
  90532a:	7d860a        	bbci	a8, 13, 905338 <ar5416ProcRxDescFast_20+0x19c>
		rx_stats->rs_flags |= HAL_RX_DELIM_CRC_POST;
  90532d:	23601a        	l8ui	a3, a6, 26
  905330:	c220      	movi.n	a2, 32
  905332:	023202        	or	a2, a3, a2
  905335:	22641a        	s8i	a2, a6, 26
	if (ads.ds_rxstatus8 & AR_DecryptBusyErr)
  905338:	71860a        	bbci	a8, 1, 905346 <ar5416ProcRxDescFast_20+0x1aa>
		rx_stats->rs_flags |= HAL_RX_DECRYPT_BUSY;
  90533b:	23601a        	l8ui	a3, a6, 26
  90533e:	c420      	movi.n	a2, 64
  905340:	023202        	or	a2, a3, a2
  905343:	22641a        	s8i	a2, a6, 26

	if ((ads.ds_rxstatus8 & AR_RxFrameOK) == 0) {
  905346:	c032      	movi.n	a3, 2
  905348:	73882f        	bany	a8, a3, 90537b <ar5416ProcRxDescFast_20+0x1df>
		 * when a CRC error is detected, but these are specious.
		 * Consequently we filter them out here so we don't
		 * confuse and/or complicate drivers.
		 */
		if (ads.ds_rxstatus8 & AR_CRCErr)
			rx_stats->rs_status |= HAL_RXERR_CRC;
  90534b:	c021      	movi.n	a2, 1
		 * indicates however that you can also get Michael errors
		 * when a CRC error is detected, but these are specious.
		 * Consequently we filter them out here so we don't
		 * confuse and/or complicate drivers.
		 */
		if (ads.ds_rxstatus8 & AR_CRCErr)
  90534d:	7d8f27        	bbsi	a8, 29, 905378 <ar5416ProcRxDescFast_20+0x1dc>
			rx_stats->rs_status |= HAL_RXERR_CRC;
		else if (ads.ds_rxstatus8 & AR_PHYErr) {
  905350:	c120      	movi.n	a2, 16
  905352:	728012        	bnone	a8, a2, 905368 <ar5416ProcRxDescFast_20+0x1cc>
			a_uint32_t phyerr;

			rx_stats->rs_status |= HAL_RXERR_PHY;
			phyerr = MS(ads.ds_rxstatus8, AR_PHYErrCode);
  905355:	12723e        	l32r	a2, 8e1c50 <athos_indirection_table_install+0x708>
		if (ads.ds_rxstatus8 & AR_CRCErr)
			rx_stats->rs_status |= HAL_RXERR_CRC;
		else if (ads.ds_rxstatus8 & AR_PHYErr) {
			a_uint32_t phyerr;

			rx_stats->rs_status |= HAL_RXERR_PHY;
  905358:	23640a        	s8i	a3, a6, 10
			phyerr = MS(ads.ds_rxstatus8, AR_PHYErrCode);
  90535b:	028801        	and	a8, a8, a2
  90535e:	088814        	srli	a8, a8, 8
			rx_stats->rs_phyerr = phyerr;
  905361:	28640b        	s8i	a8, a6, 11
  905364:	600013        	j	90537b <ar5416ProcRxDescFast_20+0x1df>
  905367:	00c038        	moveqz	a0, a12, a0
		} else if (ads.ds_rxstatus8 & AR_DecryptCRCErr)
  90536a:	738007        	bnone	a8, a3, 905375 <ar5416ProcRxDescFast_20+0x1d9>
			rx_stats->rs_status |= HAL_RXERR_DECRYPT;
  90536d:	23640a        	s8i	a3, a6, 10
  905370:	600007        	j	90537b <ar5416ProcRxDescFast_20+0x1df>
  905373:	00007a        	excw
		else if (ads.ds_rxstatus8 & AR_MichaelErr)
  905376:	8702      	l32i.n	a7, a0, 8
			rx_stats->rs_status |= HAL_RXERR_MIC;
  905378:	22640a        	s8i	a2, a6, 10
	}
	rx_stats->evm0=ads.AR_RxEVM0;
  90537b:	9967      	s32i.n	a9, a6, 28
	rx_stats->evm1=ads.AR_RxEVM1;
  90537d:	9468      	s32i.n	a4, a6, 32
	rx_stats->evm2=ads.AR_RxEVM2;
  90537f:	9569      	s32i.n	a5, a6, 36

	return HAL_OK;
  905381:	220a00        	movi	a2, 0
}
  905384:	d10f      	retw.n
	...

00905388 <ar5416UpdateTxTrigLevel>:
/******/
/* TX */
/******/

HAL_BOOL ar5416UpdateTxTrigLevel(struct ath_hal *ah, HAL_BOOL bIncTrigLevel)
{
  905388:	6c1004        	entry	a1, 32
        HAL_INT omask;

        /*
         * Disable interrupts while futzing with the fifo level.
         */
        omask = ar5416SetInterrupts(ah, ahp->ah_maskReg &~ HAL_INT_GLOBAL);
  90538b:	14723f        	l32r	a4, 8e1c88 <athos_indirection_table_install+0x740>
  90538e:	2b2235        	l32i	a11, a2, 212
  905391:	da20      	mov.n	a10, a2
  905393:	04bb01        	and	a11, a11, a4
  905396:	5bff27        	call8	905034 <ar5416SetInterrupts>
  905399:	147240        	l32r	a4, 8e1c9c <athos_indirection_table_install+0x754>
  90539c:	dba0      	mov.n	a11, a10
  90539e:	0c0200        	memw
  9053a1:	8840      	l32i.n	a8, a4, 0

	txcfg = ioread32_mac(AR_TXCFG);
        curLevel = MS(txcfg, AR_FTRIG);
  9053a3:	084445        	extui	a4, a8, 4, 6
        newLevel = curLevel;

        if (bIncTrigLevel)  {
  9053a6:	c83a      	beqz.n	a3, 9053b4 <ar5416UpdateTxTrigLevel+0x2c>
		if (curLevel < MAX_TX_FIFO_THRESHOLD)
  9053a8:	c39f      	movi.n	a9, 63
  9053aa:	d340      	mov.n	a3, a4
  9053ac:	794128        	beq	a4, a9, 9053d8 <ar5416UpdateTxTrigLevel+0x50>
			newLevel ++;
  9053af:	b143      	addi.n	a3, a4, 1
  9053b1:	600006        	j	9053bb <ar5416UpdateTxTrigLevel+0x33>
        } else if (curLevel > MIN_TX_FIFO_THRESHOLD)
  9053b4:	d340      	mov.n	a3, a4
  9053b6:	6e421e        	bltui	a4, 2, 9053d8 <ar5416UpdateTxTrigLevel+0x50>
                newLevel--;
  9053b9:	b043      	addi.n	a3, a4, -1
        if (newLevel != curLevel)
  9053bb:	743119        	beq	a3, a4, 9053d8 <ar5416UpdateTxTrigLevel+0x50>
		iowrite32_mac(AR_TXCFG,
  9053be:	0c3a11        	slli	a10, a3, 4
  9053c1:	293af0        	movi	a9, 0x3f0
  9053c4:	09a901        	and	a9, a10, a9
  9053c7:	2aca0f        	movi	a10, 0xfffffc0f
  9053ca:	0a8801        	and	a8, a8, a10
  9053cd:	089802        	or	a8, a9, a8
  9053d0:	197240        	l32r	a9, 8e1cd0 <athos_indirection_table_install+0x788>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  9053d3:	0c0200        	memw
  9053d6:	9890      	s32i.n	a8, a9, 0
			     (txcfg & ~AR_FTRIG) | SM(newLevel, AR_FTRIG));

        /* re-enable chip interrupts */
        ar5416SetInterrupts(ah, omask);
  9053d8:	da20      	mov.n	a10, a2
  9053da:	5bff16        	call8	905034 <ar5416SetInterrupts>

        return (newLevel != curLevel);
  9053dd:	04340c        	sub	a4, a3, a4
  9053e0:	c081      	movi.n	a8, 1
  9053e2:	c020      	movi.n	a2, 0
  9053e4:	048239        	movnez	a2, a8, a4
}
  9053e7:	d10f      	retw.n
  9053e9:	000000        	ill

009053ec <ar5416SetTxDP>:

HAL_BOOL ar5416SetTxDP(struct ath_hal *ah, a_uint32_t q, a_uint32_t txdp)
{
  9053ec:	6c1004        	entry	a1, 32
         * Make sure that TXE is deasserted before setting the TXDP.  If TXE
         * is still asserted, setting TXDP will have no effect.
         */
	HALASSERT((ioread32_mac(AR_Q_TXE) & (1 << q)) == 0);

	iowrite32_mac(AR_QTXDP(q), txdp);
  9053ef:	187241        	l32r	a8, 8e1cf4 <athos_indirection_table_install+0x7ac>

        return AH_TRUE;
}
  9053f2:	c021      	movi.n	a2, 1
         * Make sure that TXE is deasserted before setting the TXDP.  If TXE
         * is still asserted, setting TXDP will have no effect.
         */
	HALASSERT((ioread32_mac(AR_Q_TXE) & (1 << q)) == 0);

	iowrite32_mac(AR_QTXDP(q), txdp);
  9053f4:	08330a        	addx4	a3, a3, a8
  9053f7:	0c0200        	memw
  9053fa:	9430      	s32i.n	a4, a3, 0

        return AH_TRUE;
}
  9053fc:	d10f      	retw.n
	...

00905400 <ar5416StartTxDma>:

HAL_BOOL ar5416StartTxDma(struct ath_hal *ah, a_uint32_t q)
{
  905400:	6c1004        	entry	a1, 32
        HALASSERT(AH5416(ah)->ah_txq[q].tqi_type != HAL_TX_QUEUE_INACTIVE);

        /* Check to be sure we're not enabling a q that has its TXD bit set. */
	HALASSERT((ioread32_mac(AR_Q_TXD) & (1 << q)) == 0);

	iowrite32_mac(AR_Q_TXE, 1 << q);
  905403:	c021      	movi.n	a2, 1
  905405:	187242        	l32r	a8, 8e1d10 <athos_indirection_table_install+0x7c8>
  905408:	003104        	ssl	a3
  90540b:	00231a        	sll	a3, a2
  90540e:	0c0200        	memw
  905411:	9380      	s32i.n	a3, a8, 0

        return AH_TRUE;
}
  905413:	d10f      	retw.n
  905415:	000000        	ill

00905418 <ar5416NumTxPending>:

a_uint32_t ar5416NumTxPending(struct ath_hal *ah, a_uint32_t q)
{
  905418:	6c1004        	entry	a1, 32
        a_uint32_t npend;

        HALASSERT(q < AH_PRIVATE(ah)->ah_caps.halTotalQueues);
        HALASSERT(AH5416(ah)->ah_txq[q].tqi_type != HAL_TX_QUEUE_INACTIVE);

	npend = ioread32_mac(AR_QSTS(q))
  90541b:	127243        	l32r	a2, 8e1d28 <athos_indirection_table_install+0x7e0>
  90541e:	02320a        	addx4	a2, a3, a2
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  905421:	0c0200        	memw
  905424:	8220      	l32i.n	a2, a2, 0
  905426:	020241        	extui	a2, a2, 0, 2
		& AR_Q_STS_PEND_FR_CNT;
        if (npend == 0) {
  905429:	cd24      	bnez.n	a2, 905441 <ar5416NumTxPending+0x29>
  90542b:	187242        	l32r	a8, 8e1d34 <athos_indirection_table_install+0x7ec>
  90542e:	0c0200        	memw
  905431:	8980      	l32i.n	a9, a8, 0
                /*
                 * Pending frame count (PFC) can momentarily go to zero
                 * while TXE remains asserted.  In other words a PFC of
                 * zero is not sufficient to say that the queue has stopped.
                 */
		if (ioread32_mac(AR_Q_TXE) & (1 << q))
  905433:	c081      	movi.n	a8, 1
  905435:	003104        	ssl	a3
  905438:	00831a        	sll	a3, a8
  90543b:	093301        	and	a3, a3, a9
  90543e:	038239        	movnez	a2, a8, a3
			iowrite32_mac(AR_Q_RDYTIMESHDN, 1 << q);
                }
        }
#endif
        return npend;
}
  905441:	d10f      	retw.n
	...

00905444 <ar5416SetupTxDesc_20>:
			      a_uint32_t txRate0, a_uint32_t txTries0,
			      a_uint32_t keyIx,
			      a_uint32_t flags,
			      a_uint32_t rtsctsRate,
			      a_uint32_t rtsctsDuration)
{
  905444:	6c1004        	entry	a1, 32
  905447:	d820      	mov.n	a8, a2

        struct ar5416_desc *ads = AR5416DESC(ds);

        (void) hdrLen;

        ads->ds_txstatus9 &= ~AR_TxDone;
  905449:	2b205c        	l8ui	a11, a2, 92
  90544c:	22205d        	l8ui	a2, a2, 93
  90544f:	2a805e        	l8ui	a10, a8, 94
  905452:	08bb10        	slli	a11, a11, 24
  905455:	002211        	slli	a2, a2, 16
  905458:	0b2202        	or	a2, a2, a11
  90545b:	08aa11        	slli	a10, a10, 8
  90545e:	02aa02        	or	a10, a10, a2
  905461:	22805f        	l8ui	a2, a8, 95
			      a_uint32_t txRate0, a_uint32_t txTries0,
			      a_uint32_t keyIx,
			      a_uint32_t flags,
			      a_uint32_t rtsctsRate,
			      a_uint32_t rtsctsDuration)
{
  905464:	891a      	l32i.n	a9, a1, 40

        struct ar5416_desc *ads = AR5416DESC(ds);

        (void) hdrLen;

        ads->ds_txstatus9 &= ~AR_TxDone;
  905466:	0a2a02        	or	a10, a2, a10
  905469:	c72e      	movi.n	a2, -2
  90546b:	02aa01        	and	a10, a10, a2
  90546e:	0a8257        	extui	a2, a10, 24, 8
  905471:	22845c        	s8i	a2, a8, 92
  905474:	0a0257        	extui	a2, a10, 16, 8
  905477:	22845d        	s8i	a2, a8, 93
  90547a:	0a8247        	extui	a2, a10, 8, 8
  90547d:	22845e        	s8i	a2, a8, 94

        if (txPower > 63)
		txPower=63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
		| (txPower << AR_XmitPower_S)
  905480:	c32f      	movi.n	a2, 63
  905482:	026636        	minu	a6, a6, a2
        HALASSERT((flags & RTSCTS) != RTSCTS);

        if (txPower > 63)
		txPower=63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
  905485:	03034b        	extui	a3, a3, 0, 12
		| (txPower << AR_XmitPower_S)
  905488:	006211        	slli	a2, a6, 16
  90548b:	032202        	or	a2, a2, a3
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
  90548e:	c2b0      	movi.n	a11, 32
  905490:	137232        	l32r	a3, 8e1d58 <athos_indirection_table_install+0x810>

        struct ar5416_desc *ads = AR5416DESC(ds);

        (void) hdrLen;

        ads->ds_txstatus9 &= ~AR_TxDone;
  905493:	2a845f        	s8i	a10, a8, 95
        if (txPower > 63)
		txPower=63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
		| (txPower << AR_XmitPower_S)
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
  905496:	0b9b01        	and	a11, a9, a11
  905499:	c0a0      	movi.n	a10, 0
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
  90549b:	1e7244        	l32r	a14, 8e1dac <athos_indirection_table_install+0x864>
        if (txPower > 63)
		txPower=63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
		| (txPower << AR_XmitPower_S)
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
  90549e:	0ba338        	moveqz	a3, a10, a11
  9054a1:	032b02        	or	a11, a2, a3
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
  9054a4:	090340        	extui	a3, a9, 0, 1
  9054a7:	d2a0      	mov.n	a2, a10
  9054a9:	03e239        	movnez	a2, a14, a3
  9054ac:	02bb02        	or	a11, a11, a2
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0);
  9054af:	137245        	l32r	a3, 8e1dc4 <athos_indirection_table_install+0x87c>
  9054b2:	c120      	movi.n	a2, 16
  9054b4:	029c01        	and	a12, a9, a2
  9054b7:	0ca338        	moveqz	a3, a10, a12
  9054ba:	03bb02        	or	a11, a11, a3
        HALASSERT((flags & RTSCTS) != RTSCTS);

        if (txPower > 63)
		txPower=63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
  9054bd:	0b8357        	extui	a3, a11, 24, 8
  9054c0:	238408        	s8i	a3, a8, 8
  9054c3:	0b0357        	extui	a3, a11, 16, 8
  9054c6:	238409        	s8i	a3, a8, 9
  9054c9:	0b8347        	extui	a3, a11, 8, 8
  9054cc:	23840a        	s8i	a3, a8, 10
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0);

        ads->ds_ctl1 = (type << AR_FrameType_S)
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0);
  9054cf:	c032      	movi.n	a3, 2
  9054d1:	039c01        	and	a12, a9, a3
  9054d4:	0cae38        	moveqz	a14, a10, a12
		| (txPower << AR_XmitPower_S)
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0);

        ads->ds_ctl1 = (type << AR_FrameType_S)
  9054d7:	0c5510        	slli	a5, a5, 20
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0);
  9054da:	05ec02        	or	a12, a14, a5
		| (txPower << AR_XmitPower_S)
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0);

        ads->ds_ctl1 = (type << AR_FrameType_S)
  9054dd:	0c8457        	extui	a4, a12, 24, 8
  9054e0:	24840c        	s8i	a4, a8, 12
  9054e3:	0c0457        	extui	a4, a12, 16, 8
  9054e6:	24840d        	s8i	a4, a8, 13
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0);
        ads->ds_ctl2 = SM(txTries0, AR_XmitDataTries0);
  9054e9:	8e18      	l32i.n	a14, a1, 32
		| (txPower << AR_XmitPower_S)
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0);

        ads->ds_ctl1 = (type << AR_FrameType_S)
  9054eb:	0c8447        	extui	a4, a12, 8, 8
  9054ee:	24840e        	s8i	a4, a8, 14
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0);
        ads->ds_ctl2 = SM(txTries0, AR_XmitDataTries0);
  9054f1:	147248        	l32r	a4, 8e1e14 <athos_indirection_table_install+0x8cc>
  9054f4:	002104        	ssl	a2
  9054f7:	00ee1a        	sll	a14, a14
  9054fa:	04ee01        	and	a14, a14, a4
  9054fd:	0e8457        	extui	a4, a14, 24, 8
  905500:	248410        	s8i	a4, a8, 16
  905503:	0e0457        	extui	a4, a14, 16, 8
  905506:	248411        	s8i	a4, a8, 17
        ads->ds_ctl3 = (txRate0 << AR_XmitRate0_S);
  905509:	078457        	extui	a4, a7, 24, 8
  90550c:	248414        	s8i	a4, a8, 20
  90550f:	070457        	extui	a4, a7, 16, 8
  905512:	248415        	s8i	a4, a8, 21
  905515:	078447        	extui	a4, a7, 8, 8
        HALASSERT((flags & RTSCTS) != RTSCTS);

        if (txPower > 63)
		txPower=63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
  905518:	2b840b        	s8i	a11, a8, 11
		| (txPower << AR_XmitPower_S)
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0);

        ads->ds_ctl1 = (type << AR_FrameType_S)
  90551b:	2c840f        	s8i	a12, a8, 15
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0);
        ads->ds_ctl2 = SM(txTries0, AR_XmitDataTries0);
  90551e:	2a8412        	s8i	a10, a8, 18
  905521:	2a8413        	s8i	a10, a8, 19
        ads->ds_ctl3 = (txRate0 << AR_XmitRate0_S);
  905524:	248416        	s8i	a4, a8, 22
  905527:	278417        	s8i	a7, a8, 23

        ads->ds_ctl7 = SM(AR5416_LEGACY_CHAINMASK, AR_ChainSel0) 
  90552a:	2a8424        	s8i	a10, a8, 36
			      a_uint32_t txRate0, a_uint32_t txTries0,
			      a_uint32_t keyIx,
			      a_uint32_t flags,
			      a_uint32_t rtsctsRate,
			      a_uint32_t rtsctsDuration)
{
  90552d:	8f19      	l32i.n	a15, a1, 36
  90552f:	2d120b        	l32i	a13, a1, 44
        ads->ds_ctl1 = (type << AR_FrameType_S)
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0);
        ads->ds_ctl2 = SM(txTries0, AR_XmitDataTries0);
        ads->ds_ctl3 = (txRate0 << AR_XmitRate0_S);

        ads->ds_ctl7 = SM(AR5416_LEGACY_CHAINMASK, AR_ChainSel0) 
  905532:	238425        	s8i	a3, a8, 37
  905535:	228426        	s8i	a2, a8, 38
  905538:	22fa84        	movi	a2, -124
  90553b:	228427        	s8i	a2, a8, 39
		| SM(AR5416_LEGACY_CHAINMASK, AR_ChainSel1)
		| SM(AR5416_LEGACY_CHAINMASK, AR_ChainSel2) 
		| SM(AR5416_LEGACY_CHAINMASK, AR_ChainSel3);

        if (keyIx != HAL_TXKEYIX_INVALID) {
  90553e:	220aff        	movi	a2, 255
  905541:	72f13b        	beq	a15, a2, 905580 <ar5416SetupTxDesc_20+0x13c>
                /* XXX validate key index */
                ads->ds_ctl1 |= SM(keyIx, AR_DestIdx);
  905544:	127249        	l32r	a2, 8e1e68 <athos_indirection_table_install+0x920>
  905547:	03ff11        	slli	a15, a15, 13
  90554a:	02ff01        	and	a15, a15, a2
  90554d:	0fcc02        	or	a12, a12, a15
  905550:	0c8257        	extui	a2, a12, 24, 8
  905553:	22840c        	s8i	a2, a8, 12
  905556:	0c0257        	extui	a2, a12, 16, 8
  905559:	22840d        	s8i	a2, a8, 13
  90555c:	0c8247        	extui	a2, a12, 8, 8
  90555f:	22840e        	s8i	a2, a8, 14
                ads->ds_ctl0 |= AR_DestIdxValid;
  905562:	12724a        	l32r	a2, 8e1e8c <athos_indirection_table_install+0x944>
		| SM(AR5416_LEGACY_CHAINMASK, AR_ChainSel2) 
		| SM(AR5416_LEGACY_CHAINMASK, AR_ChainSel3);

        if (keyIx != HAL_TXKEYIX_INVALID) {
                /* XXX validate key index */
                ads->ds_ctl1 |= SM(keyIx, AR_DestIdx);
  905565:	2c840f        	s8i	a12, a8, 15
                ads->ds_ctl0 |= AR_DestIdxValid;
  905568:	02bb02        	or	a11, a11, a2
  90556b:	0b8257        	extui	a2, a11, 24, 8
  90556e:	228408        	s8i	a2, a8, 8
  905571:	0b0257        	extui	a2, a11, 16, 8
  905574:	228409        	s8i	a2, a8, 9
  905577:	0b8247        	extui	a2, a11, 8, 8
  90557a:	22840a        	s8i	a2, a8, 10
  90557d:	2b840b        	s8i	a11, a8, 11
        }

        if (flags & RTSCTS) {
  905580:	c03c      	movi.n	a3, 12
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
                ads->ds_ctl2 |= SM(rtsctsDuration, AR_BurstDur);
                ads->ds_ctl3 |= (rtsctsRate << AR_RTSCTSRate_S);
        }
        return AH_TRUE;
  905582:	c021      	movi.n	a2, 1
                /* XXX validate key index */
                ads->ds_ctl1 |= SM(keyIx, AR_DestIdx);
                ads->ds_ctl0 |= AR_DestIdxValid;
        }

        if (flags & RTSCTS) {
  905584:	739802        	bany	a9, a3, 90558a <ar5416SetupTxDesc_20+0x146>
  905587:	60009d        	j	905628 <ar5416SetupTxDesc_20+0x1e4>
                if (!isValidTxRate(rtsctsRate)) {
  90558a:	1a724b        	l32r	a10, 8e1eb8 <athos_indirection_table_install+0x970>
  90558d:	00d004        	ssr	a13
  905590:	0a0a1b        	sra	a10, a10
  905593:	02aa01        	and	a10, a10, a2
  905596:	64a08c        	beqz	a10, 905626 <ar5416SetupTxDesc_20+0x1e2>
                        return AH_FALSE;
                }
                /* XXX validate rtsctsDuration */
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
  905599:	2a8008        	l8ui	a10, a8, 8
  90559c:	2b8009        	l8ui	a11, a8, 9
  90559f:	23800a        	l8ui	a3, a8, 10
  9055a2:	08aa10        	slli	a10, a10, 24
  9055a5:	00bb11        	slli	a11, a11, 16
  9055a8:	0abb02        	or	a11, a11, a10
  9055ab:	083311        	slli	a3, a3, 8
  9055ae:	2a800b        	l8ui	a10, a8, 11
  9055b1:	0b3302        	or	a3, a3, a11
  9055b4:	03a302        	or	a3, a10, a3
  9055b7:	1c7246        	l32r	a12, 8e1ed0 <athos_indirection_table_install+0x988>
  9055ba:	c0a8      	movi.n	a10, 8
  9055bc:	0a9a01        	and	a10, a9, a10
  9055bf:	c0b0      	movi.n	a11, 0
  9055c1:	0abc38        	moveqz	a12, a11, a10
  9055c4:	dac0      	mov.n	a10, a12
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
  9055c6:	c0c4      	movi.n	a12, 4
  9055c8:	0c9901        	and	a9, a9, a12
  9055cb:	1c7247        	l32r	a12, 8e1ee8 <athos_indirection_table_install+0x9a0>
  9055ce:	03aa02        	or	a10, a10, a3
  9055d1:	09cb39        	movnez	a11, a12, a9
        if (flags & RTSCTS) {
                if (!isValidTxRate(rtsctsRate)) {
                        return AH_FALSE;
                }
                /* XXX validate rtsctsDuration */
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
  9055d4:	0baa02        	or	a10, a10, a11
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
                ads->ds_ctl2 |= SM(rtsctsDuration, AR_BurstDur);
  9055d7:	891c      	l32i.n	a9, a1, 48
        if (flags & RTSCTS) {
                if (!isValidTxRate(rtsctsRate)) {
                        return AH_FALSE;
                }
                /* XXX validate rtsctsDuration */
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
  9055d9:	0a8357        	extui	a3, a10, 24, 8
  9055dc:	238408        	s8i	a3, a8, 8
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
                ads->ds_ctl2 |= SM(rtsctsDuration, AR_BurstDur);
  9055df:	09094e        	extui	a9, a9, 0, 15
        if (flags & RTSCTS) {
                if (!isValidTxRate(rtsctsRate)) {
                        return AH_FALSE;
                }
                /* XXX validate rtsctsDuration */
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
  9055e2:	0a0357        	extui	a3, a10, 16, 8
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
                ads->ds_ctl2 |= SM(rtsctsDuration, AR_BurstDur);
  9055e5:	0e9902        	or	a9, a9, a14
        if (flags & RTSCTS) {
                if (!isValidTxRate(rtsctsRate)) {
                        return AH_FALSE;
                }
                /* XXX validate rtsctsDuration */
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
  9055e8:	238409        	s8i	a3, a8, 9
  9055eb:	0a8347        	extui	a3, a10, 8, 8
  9055ee:	23840a        	s8i	a3, a8, 10
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
                ads->ds_ctl2 |= SM(rtsctsDuration, AR_BurstDur);
  9055f1:	098357        	extui	a3, a9, 24, 8
  9055f4:	238410        	s8i	a3, a8, 16
                ads->ds_ctl3 |= (rtsctsRate << AR_RTSCTSRate_S);
  9055f7:	0cdd10        	slli	a13, a13, 20
                        return AH_FALSE;
                }
                /* XXX validate rtsctsDuration */
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
                ads->ds_ctl2 |= SM(rtsctsDuration, AR_BurstDur);
  9055fa:	090357        	extui	a3, a9, 16, 8
                ads->ds_ctl3 |= (rtsctsRate << AR_RTSCTSRate_S);
  9055fd:	07d702        	or	a7, a13, a7
                        return AH_FALSE;
                }
                /* XXX validate rtsctsDuration */
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
                ads->ds_ctl2 |= SM(rtsctsDuration, AR_BurstDur);
  905600:	238411        	s8i	a3, a8, 17
  905603:	098346        	extui	a3, a9, 8, 7
  905606:	238412        	s8i	a3, a8, 18
                ads->ds_ctl3 |= (rtsctsRate << AR_RTSCTSRate_S);
  905609:	078357        	extui	a3, a7, 24, 8
  90560c:	238414        	s8i	a3, a8, 20
  90560f:	070357        	extui	a3, a7, 16, 8
  905612:	238415        	s8i	a3, a8, 21
  905615:	078347        	extui	a3, a7, 8, 8
        if (flags & RTSCTS) {
                if (!isValidTxRate(rtsctsRate)) {
                        return AH_FALSE;
                }
                /* XXX validate rtsctsDuration */
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
  905618:	2a840b        	s8i	a10, a8, 11
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
                ads->ds_ctl2 |= SM(rtsctsDuration, AR_BurstDur);
  90561b:	298413        	s8i	a9, a8, 19
                ads->ds_ctl3 |= (rtsctsRate << AR_RTSCTSRate_S);
  90561e:	238416        	s8i	a3, a8, 22
  905621:	278417        	s8i	a7, a8, 23
  905624:	d10f      	retw.n
                ads->ds_ctl0 |= AR_DestIdxValid;
        }

        if (flags & RTSCTS) {
                if (!isValidTxRate(rtsctsRate)) {
                        return AH_FALSE;
  905626:	d2a0      	mov.n	a2, a10
                ads->ds_ctl3 |= (rtsctsRate << AR_RTSCTSRate_S);
        }
        return AH_TRUE;

#undef RTSCTS
}
  905628:	d10f      	retw.n
	...

0090562c <ar5416FillTxDesc_20>:

HAL_BOOL ar5416FillTxDesc_20(struct ath_tx_desc *ds,
			     a_uint32_t segLen, HAL_BOOL firstSeg, HAL_BOOL lastSeg,
			     const struct ath_tx_desc *ds0)
{
  90562c:	6c1004        	entry	a1, 32
        struct ar5416_desc *ads = AR5416DESC(ds);

        HALASSERT((segLen &~ AR_BufLen) == 0);

        if (firstSeg) {
  90562f:	644045        	beqz	a4, 905678 <ar5416FillTxDesc_20+0x4c>
                /*
                 * First descriptor, don't clobber xmit control data
                 * setup by ar5416SetupTxDesc.
                 */
                ads->ds_ctl1 |= segLen | (lastSeg ? 0 : AR_TxMore);
  905632:	28200c        	l8ui	a8, a2, 12
  905635:	24200d        	l8ui	a4, a2, 13
  905638:	26200e        	l8ui	a6, a2, 14
  90563b:	088810        	slli	a8, a8, 24
  90563e:	004411        	slli	a4, a4, 16
  905641:	084402        	or	a4, a4, a8
  905644:	086611        	slli	a6, a6, 8
  905647:	046602        	or	a6, a6, a4
  90564a:	24200f        	l8ui	a4, a2, 15
  90564d:	187209        	l32r	a8, 8e1e74 <athos_indirection_table_install+0x92c>
  905650:	064602        	or	a6, a4, a6
  905653:	c040      	movi.n	a4, 0
  905655:	058438        	moveqz	a4, a8, a5
  905658:	063302        	or	a3, a3, a6
  90565b:	043302        	or	a3, a3, a4
  90565e:	038457        	extui	a4, a3, 24, 8
  905661:	24240c        	s8i	a4, a2, 12
  905664:	030457        	extui	a4, a3, 16, 8
  905667:	24240d        	s8i	a4, a2, 13
  90566a:	038447        	extui	a4, a3, 8, 8
  90566d:	24240e        	s8i	a4, a2, 14
  905670:	23240f        	s8i	a3, a2, 15
  905673:	6000cd        	j	905744 <ar5416FillTxDesc_20+0x118>
  905676:	000064        	excw
        } else if (lastSeg) {
  905679:	508924        	call0	927b0c <_etext+0x1cc47>
                /*
                 * Last descriptor in a multi-descriptor frame,
                 * copy the multi-rate transmit parameters from
                 * the first frame for processing on completion.
                 */
                ads->ds_ctl0 = 0;
  90567c:	240824        	excw
  90567f:	240924        	l16si	a4, a0, 72
  905682:	240a24        	movi	a4, 36
  905685:	240b03        	l32ai	a4, a0, 12
                ads->ds_ctl1 = segLen;
  905688:	8457      	l32i.n	a4, a5, 28
  90568a:	24240c        	s8i	a4, a2, 12
  90568d:	030457        	extui	a4, a3, 16, 8
  905690:	24240d        	s8i	a4, a2, 13
  905693:	038447        	extui	a4, a3, 8, 8
  905696:	24240e        	s8i	a4, a2, 14
  905699:	23240f        	s8i	a3, a2, 15
                ads->ds_ctl2 = AR5416DESC_CONST(ds0)->ds_ctl2;
  90569c:	256010        	l8ui	a5, a6, 16
  90569f:	246011        	l8ui	a4, a6, 17
  9056a2:	236012        	l8ui	a3, a6, 18
  9056a5:	085510        	slli	a5, a5, 24
  9056a8:	004411        	slli	a4, a4, 16
  9056ab:	054402        	or	a4, a4, a5
  9056ae:	083311        	slli	a3, a3, 8
  9056b1:	043302        	or	a3, a3, a4
  9056b4:	246013        	l8ui	a4, a6, 19
  9056b7:	034302        	or	a3, a4, a3
  9056ba:	038457        	extui	a4, a3, 24, 8
  9056bd:	242410        	s8i	a4, a2, 16
  9056c0:	030457        	extui	a4, a3, 16, 8
  9056c3:	242411        	s8i	a4, a2, 17
  9056c6:	038447        	extui	a4, a3, 8, 8
  9056c9:	242412        	s8i	a4, a2, 18
  9056cc:	232413        	s8i	a3, a2, 19
                ads->ds_ctl3 = AR5416DESC_CONST(ds0)->ds_ctl3;
  9056cf:	256014        	l8ui	a5, a6, 20
  9056d2:	246015        	l8ui	a4, a6, 21
  9056d5:	236016        	l8ui	a3, a6, 22
  9056d8:	085510        	slli	a5, a5, 24
  9056db:	004411        	slli	a4, a4, 16
  9056de:	054402        	or	a4, a4, a5
  9056e1:	083311        	slli	a3, a3, 8
  9056e4:	043302        	or	a3, a3, a4
  9056e7:	246017        	l8ui	a4, a6, 23
  9056ea:	034302        	or	a3, a4, a3
  9056ed:	038457        	extui	a4, a3, 24, 8
  9056f0:	242414        	s8i	a4, a2, 20
  9056f3:	030457        	extui	a4, a3, 16, 8
  9056f6:	242415        	s8i	a4, a2, 21
  9056f9:	038447        	extui	a4, a3, 8, 8
  9056fc:	242416        	s8i	a4, a2, 22
  9056ff:	232417        	s8i	a3, a2, 23
  905702:	60003e        	j	905744 <ar5416FillTxDesc_20+0x118>
        } else {
                /*
                 * Intermediate descriptor in a multi-descriptor frame.
                 */
                ads->ds_ctl0 = 0;
                ads->ds_ctl1 = segLen | AR_TxMore;
  905705:	147209        	l32r	a4, 8e1f2c <athos_indirection_table_install+0x9e4>
                ads->ds_ctl3 = AR5416DESC_CONST(ds0)->ds_ctl3;
        } else {
                /*
                 * Intermediate descriptor in a multi-descriptor frame.
                 */
                ads->ds_ctl0 = 0;
  905708:	252408        	s8i	a5, a2, 8
                ads->ds_ctl1 = segLen | AR_TxMore;
  90570b:	043302        	or	a3, a3, a4
  90570e:	038457        	extui	a4, a3, 24, 8
  905711:	24240c        	s8i	a4, a2, 12
  905714:	030457        	extui	a4, a3, 16, 8
  905717:	24240d        	s8i	a4, a2, 13
  90571a:	038447        	extui	a4, a3, 8, 8
                ads->ds_ctl3 = AR5416DESC_CONST(ds0)->ds_ctl3;
        } else {
                /*
                 * Intermediate descriptor in a multi-descriptor frame.
                 */
                ads->ds_ctl0 = 0;
  90571d:	252409        	s8i	a5, a2, 9
  905720:	25240a        	s8i	a5, a2, 10
  905723:	25240b        	s8i	a5, a2, 11
                ads->ds_ctl1 = segLen | AR_TxMore;
  905726:	24240e        	s8i	a4, a2, 14
  905729:	23240f        	s8i	a3, a2, 15
                ads->ds_ctl2 = 0;
  90572c:	252410        	s8i	a5, a2, 16
  90572f:	252411        	s8i	a5, a2, 17
  905732:	252412        	s8i	a5, a2, 18
  905735:	252413        	s8i	a5, a2, 19
                ads->ds_ctl3 = 0;
  905738:	252414        	s8i	a5, a2, 20
  90573b:	252415        	s8i	a5, a2, 21
  90573e:	252416        	s8i	a5, a2, 22
  905741:	252417        	s8i	a5, a2, 23
        }
        ads->ds_txstatus0 = ads->ds_txstatus1 = 0;
  905744:	c050      	movi.n	a5, 0
  905746:	25243c        	s8i	a5, a2, 60
  905749:	25243d        	s8i	a5, a2, 61
  90574c:	25243e        	s8i	a5, a2, 62
  90574f:	25243f        	s8i	a5, a2, 63
  905752:	252438        	s8i	a5, a2, 56
  905755:	252439        	s8i	a5, a2, 57
  905758:	25243a        	s8i	a5, a2, 58
  90575b:	25243b        	s8i	a5, a2, 59

        return AH_TRUE;
}
  90575e:	c021      	movi.n	a2, 1
  905760:	d10f      	retw.n
	...

00905764 <ar5416FillKeyTxDesc_20>:

HAL_BOOL ar5416FillKeyTxDesc_20(struct ath_tx_desc *ds,
				HAL_KEY_TYPE keyType)
{
  905764:	6c1004        	entry	a1, 32
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl6 = SM(keyType, AR_EncrType);
  905767:	18724c        	l32r	a8, 8e2098 <athos_indirection_table_install+0xb50>
  90576a:	063310        	slli	a3, a3, 26
  90576d:	083801        	and	a8, a3, a8
  905770:	088857        	extui	a8, a8, 24, 8
  905773:	282420        	s8i	a8, a2, 32
  905776:	c080      	movi.n	a8, 0
  905778:	282421        	s8i	a8, a2, 33
  90577b:	282422        	s8i	a8, a2, 34
  90577e:	282423        	s8i	a8, a2, 35
	return AH_TRUE;
}
  905781:	c021      	movi.n	a2, 1
  905783:	d10f      	retw.n
  905785:	000000        	ill

00905788 <ar5416Set11nTxDesc_20>:

void ar5416Set11nTxDesc_20(struct ath_tx_desc *ds,
			   a_uint32_t pktLen, HAL_PKT_TYPE type, a_uint32_t txPower,
			   a_uint32_t keyIx, HAL_KEY_TYPE keyType,
			   a_uint32_t flags)
{
  905788:	6c1004        	entry	a1, 32
  90578b:	8818      	l32i.n	a8, a1, 32
  90578d:	c39f      	movi.n	a9, 63

	if (txPower > 63)
                txPower = 63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
		| (flags & HAL_TXDESC_VMF ? AR_VirtMoreFrag : 0)
  90578f:	2b1a00        	movi	a11, 0x100
  905792:	1a7209        	l32r	a10, 8e1fb8 <athos_indirection_table_install+0xa70>
  905795:	095536        	minu	a5, a5, a9
  905798:	0b8b01        	and	a11, a8, a11
  90579b:	c090      	movi.n	a9, 0
  90579d:	0b9a38        	moveqz	a10, a9, a11
  9057a0:	dba0      	mov.n	a11, a10
		| SM(txPower, AR_XmitPower)
  9057a2:	1a724e        	l32r	a10, 8e20dc <athos_indirection_table_install+0xb94>
  9057a5:	005511        	slli	a5, a5, 16
  9057a8:	0a5501        	and	a5, a5, a10
        HALASSERT(isValidKeyType(keyType));

	if (txPower > 63)
                txPower = 63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
  9057ab:	03034b        	extui	a3, a3, 0, 12
		| (flags & HAL_TXDESC_VMF ? AR_VirtMoreFrag : 0)
  9057ae:	035502        	or	a5, a5, a3
		| SM(txPower, AR_XmitPower)
  9057b1:	0b5502        	or	a5, a5, a11
		| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0)
  9057b4:	c0a4      	movi.n	a10, 4
  9057b6:	1b7247        	l32r	a11, 8e20d4 <athos_indirection_table_install+0xb8c>
  9057b9:	0a8a01        	and	a10, a8, a10
  9057bc:	0a9b38        	moveqz	a11, a9, a10
  9057bf:	0b5a02        	or	a10, a5, a11
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
  9057c2:	c250      	movi.n	a5, 32
  9057c4:	1b7232        	l32r	a11, 8e208c <athos_indirection_table_install+0xb44>
  9057c7:	058501        	and	a5, a8, a5
  9057ca:	059b38        	moveqz	a11, a9, a5
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
  9057cd:	157244        	l32r	a5, 8e20e0 <athos_indirection_table_install+0xb98>

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
		| (flags & HAL_TXDESC_VMF ? AR_VirtMoreFrag : 0)
		| SM(txPower, AR_XmitPower)
		| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0)
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
  9057d0:	0baa02        	or	a10, a10, a11
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
  9057d3:	080b40        	extui	a11, a8, 0, 1
  9057d6:	0b9538        	moveqz	a5, a9, a11
  9057d9:	05aa02        	or	a10, a10, a5
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0)
  9057dc:	1b7245        	l32r	a11, 8e20f0 <athos_indirection_table_install+0xba8>
  9057df:	c150      	movi.n	a5, 16
  9057e1:	058501        	and	a5, a8, a5
  9057e4:	059b38        	moveqz	a11, a9, a5
  9057e7:	0baa02        	or	a10, a10, a11
		| (keyIx != HAL_TXKEYIX_INVALID ? AR_DestIdxValid : 0)
  9057ea:	15724a        	l32r	a5, 8e2114 <athos_indirection_table_install+0xbcc>
  9057ed:	2b0aff        	movi	a11, 255
  9057f0:	0b6c0c        	sub	a12, a6, a11
  9057f3:	0c9538        	moveqz	a5, a9, a12
  9057f6:	05aa02        	or	a10, a10, a5
		| (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0);
  9057f9:	1c7246        	l32r	a12, 8e2114 <athos_indirection_table_install+0xbcc>
  9057fc:	c058      	movi.n	a5, 8
  9057fe:	058501        	and	a5, a8, a5
  905801:	059c38        	moveqz	a12, a9, a5
  905804:	0caa02        	or	a10, a10, a12
        HALASSERT(isValidKeyType(keyType));

	if (txPower > 63)
                txPower = 63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
  905807:	0a8557        	extui	a5, a10, 24, 8
  90580a:	252408        	s8i	a5, a2, 8
  90580d:	0a0557        	extui	a5, a10, 16, 8
  905810:	252409        	s8i	a5, a2, 9
  905813:	0a8547        	extui	a5, a10, 8, 8
  905816:	25240a        	s8i	a5, a2, 10
  905819:	2a240b        	s8i	a10, a2, 11
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0)
		| (keyIx != HAL_TXKEYIX_INVALID ? AR_DestIdxValid : 0)
		| (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0);

        ads->ds_ctl1 = (keyIx != HAL_TXKEYIX_INVALID ? SM(keyIx, AR_DestIdx) : 0)
  90581c:	7b6108        	beq	a6, a11, 905828 <ar5416Set11nTxDesc_20+0xa0>
  90581f:	157249        	l32r	a5, 8e2144 <athos_indirection_table_install+0xbfc>
  905822:	036911        	slli	a9, a6, 13
  905825:	059901        	and	a9, a9, a5
		| SM(type, AR_FrameType)
  905828:	15724f        	l32r	a5, 8e2164 <athos_indirection_table_install+0xc1c>
  90582b:	0c4410        	slli	a4, a4, 20
  90582e:	054401        	and	a4, a4, a5
  905831:	049902        	or	a9, a9, a4
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0)
  905834:	c052      	movi.n	a5, 2
  905836:	147244        	l32r	a4, 8e2148 <athos_indirection_table_install+0xc00>
  905839:	c0a0      	movi.n	a10, 0
  90583b:	058501        	and	a5, a8, a5
  90583e:	05a438        	moveqz	a4, a10, a5
  905841:	049902        	or	a9, a9, a4
		| (flags & HAL_TXDESC_EXT_ONLY ? AR_ExtOnly : 0)
  905844:	c450      	movi.n	a5, 64
  905846:	14724d        	l32r	a4, 8e217c <athos_indirection_table_install+0xc34>
  905849:	058501        	and	a5, a8, a5
  90584c:	05a438        	moveqz	a4, a10, a5
  90584f:	049902        	or	a9, a9, a4
  905852:	d540      	mov.n	a5, a4
		| (flags & HAL_TXDESC_EXT_AND_CTL ? AR_ExtAndCtl : 0);
  905854:	240a80        	movi	a4, 128
  905857:	048801        	and	a8, a8, a4
  90585a:	14722d        	l32r	a4, 8e2110 <athos_indirection_table_install+0xbc8>

        ads->ds_ctl6 = SM(keyType, AR_EncrType);
  90585d:	067710        	slli	a7, a7, 26

        ads->ds_ctl1 = (keyIx != HAL_TXKEYIX_INVALID ? SM(keyIx, AR_DestIdx) : 0)
		| SM(type, AR_FrameType)
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0)
		| (flags & HAL_TXDESC_EXT_ONLY ? AR_ExtOnly : 0)
		| (flags & HAL_TXDESC_EXT_AND_CTL ? AR_ExtAndCtl : 0);
  905860:	08a438        	moveqz	a4, a10, a8
  905863:	049802        	or	a8, a9, a4
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0)
		| (keyIx != HAL_TXKEYIX_INVALID ? AR_DestIdxValid : 0)
		| (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0);

        ads->ds_ctl1 = (keyIx != HAL_TXKEYIX_INVALID ? SM(keyIx, AR_DestIdx) : 0)
  905866:	088457        	extui	a4, a8, 24, 8
  905869:	24240c        	s8i	a4, a2, 12
  90586c:	080457        	extui	a4, a8, 16, 8
  90586f:	24240d        	s8i	a4, a2, 13
  905872:	088447        	extui	a4, a8, 8, 8
  905875:	24240e        	s8i	a4, a2, 14
		| SM(type, AR_FrameType)
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0)
		| (flags & HAL_TXDESC_EXT_ONLY ? AR_ExtOnly : 0)
		| (flags & HAL_TXDESC_EXT_AND_CTL ? AR_ExtAndCtl : 0);

        ads->ds_ctl6 = SM(keyType, AR_EncrType);
  905878:	14724c        	l32r	a4, 8e21a8 <athos_indirection_table_install+0xc60>
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0)
		| (keyIx != HAL_TXKEYIX_INVALID ? AR_DestIdxValid : 0)
		| (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0);

        ads->ds_ctl1 = (keyIx != HAL_TXKEYIX_INVALID ? SM(keyIx, AR_DestIdx) : 0)
  90587b:	28240f        	s8i	a8, a2, 15
		| SM(type, AR_FrameType)
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0)
		| (flags & HAL_TXDESC_EXT_ONLY ? AR_ExtOnly : 0)
		| (flags & HAL_TXDESC_EXT_AND_CTL ? AR_ExtAndCtl : 0);

        ads->ds_ctl6 = SM(keyType, AR_EncrType);
  90587e:	047701        	and	a7, a7, a4
  905881:	078757        	extui	a7, a7, 24, 8
  905884:	272420        	s8i	a7, a2, 32
  905887:	d4a0      	mov.n	a4, a10
  905889:	2a2421        	s8i	a10, a2, 33
  90588c:	2a2422        	s8i	a10, a2, 34
  90588f:	2a2423        	s8i	a10, a2, 35
  905892:	d10f      	retw.n

00905894 <ar5416Set11nRateScenario_20>:

void ar5416Set11nRateScenario_20(struct ath_tx_desc *ds,
				 a_uint32_t durUpdateEn, a_uint32_t rtsctsRate,
				 HAL_11N_RATE_SERIES series[], a_uint32_t nseries,
				 a_uint32_t flags)
{
  905894:	6c1008        	entry	a1, 64
	(void)nseries;

	/*
	* Rate control settings override
	*/
	ds_ctl0 = ads->ds_ctl0;
  905897:	282008        	l8ui	a8, a2, 8
  90589a:	262009        	l8ui	a6, a2, 9

void ar5416Set11nRateScenario_20(struct ath_tx_desc *ds,
				 a_uint32_t durUpdateEn, a_uint32_t rtsctsRate,
				 HAL_11N_RATE_SERIES series[], a_uint32_t nseries,
				 a_uint32_t flags)
{
  90589d:	9414      	s32i.n	a4, a1, 16
	(void)nseries;

	/*
	* Rate control settings override
	*/
	ds_ctl0 = ads->ds_ctl0;
  90589f:	24200a        	l8ui	a4, a2, 10
  9058a2:	088810        	slli	a8, a8, 24
  9058a5:	006611        	slli	a6, a6, 16
  9058a8:	086602        	or	a6, a6, a8
  9058ab:	084411        	slli	a4, a4, 8
  9058ae:	064402        	or	a4, a4, a6
  9058b1:	26200b        	l8ui	a6, a2, 11
  9058b4:	046402        	or	a4, a6, a4

	if (flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA)) {
  9058b7:	c06c      	movi.n	a6, 12
  9058b9:	76701f        	bnone	a7, a6, 9058dc <ar5416Set11nRateScenario_20+0x48>
		if (flags & HAL_TXDESC_RTSENA) {
  9058bc:	7d770c        	bbci	a7, 29, 9058cc <ar5416Set11nRateScenario_20+0x38>
			ds_ctl0 &= ~AR_CTSEnable;
  9058bf:	16723f        	l32r	a6, 8e21bc <athos_indirection_table_install+0xc74>
  9058c2:	064401        	and	a4, a4, a6
			ds_ctl0 |= AR_RTSEnable;
  9058c5:	167247        	l32r	a6, 8e21e4 <athos_indirection_table_install+0xc9c>
  9058c8:	600009        	j	9058d5 <ar5416Set11nRateScenario_20+0x41>
  9058cb:	001672        	excw
		} else {
			ds_ctl0 &= ~AR_RTSEnable;
  9058ce:	510644        	call0	9471e0 <_etext+0x3c31b>
  9058d1:	011672        	excw
			ds_ctl0 |= AR_CTSEnable;
  9058d4:	460644        	excw
  9058d7:	026000        	ret
  9058da:	060016        	xsr.lbeg	a6
		}
	} else {
		/* this line is only difference between merlin and k2
		 * Current one is for merlin */
		ds_ctl0 = (ds_ctl0 & ~(AR_RTSEnable | AR_CTSEnable));
  9058dd:	725206        	blt	a5, a2, 9058e7 <ar5416Set11nRateScenario_20+0x53>
  9058e0:	440104        	excw
	}

	ads->ds_ctl0 = ds_ctl0;
  9058e3:	8657      	l32i.n	a6, a5, 28
  9058e5:	262408        	s8i	a6, a2, 8
  9058e8:	040657        	extui	a6, a4, 16, 8
  9058eb:	262409        	s8i	a6, a2, 9
  9058ee:	048647        	extui	a6, a4, 8, 8
  9058f1:	26240a        	s8i	a6, a2, 10
  9058f4:	24240b        	s8i	a4, a2, 11

	ads->ds_ctl2 = set11nTries(series, 0)
  9058f7:	8650      	l32i.n	a6, a5, 0
  9058f9:	177248        	l32r	a7, 8e221c <athos_indirection_table_install+0xcd4>
				   | set11nTries(series, 1)
  9058fc:	8455      	l32i.n	a4, a5, 20
		ds_ctl0 = (ds_ctl0 & ~(AR_RTSEnable | AR_CTSEnable));
	}

	ads->ds_ctl0 = ds_ctl0;

	ads->ds_ctl2 = set11nTries(series, 0)
  9058fe:	006611        	slli	a6, a6, 16
  905901:	076601        	and	a6, a6, a7
				   | set11nTries(series, 1)
  905904:	17724f        	l32r	a7, 8e2240 <athos_indirection_table_install+0xcf8>
  905907:	0c4410        	slli	a4, a4, 20
  90590a:	074401        	and	a4, a4, a7
  90590d:	046402        	or	a4, a6, a4
				   | set11nTries(series, 2)
				   | set11nTries(series, 3)
  905910:	865f      	l32i.n	a6, a5, 60

	ads->ds_ctl0 = ds_ctl0;

	ads->ds_ctl2 = set11nTries(series, 0)
				   | set11nTries(series, 1)
				   | set11nTries(series, 2)
  905912:	177253        	l32r	a7, 8e2260 <athos_indirection_table_install+0xd18>
				   | set11nTries(series, 3)
  905915:	046610        	slli	a6, a6, 28

	ads->ds_ctl0 = ds_ctl0;

	ads->ds_ctl2 = set11nTries(series, 0)
				   | set11nTries(series, 1)
				   | set11nTries(series, 2)
  905918:	064402        	or	a4, a4, a6
  90591b:	865a      	l32i.n	a6, a5, 40
				   | set11nTries(series, 3)
				   | (durUpdateEn ? AR_DurUpdateEn : 0);
  90591d:	c080      	movi.n	a8, 0

	ads->ds_ctl0 = ds_ctl0;

	ads->ds_ctl2 = set11nTries(series, 0)
				   | set11nTries(series, 1)
				   | set11nTries(series, 2)
  90591f:	086610        	slli	a6, a6, 24
				   | set11nTries(series, 3)
				   | (durUpdateEn ? AR_DurUpdateEn : 0);
  905922:	1c722b        	l32r	a12, 8e21d0 <athos_indirection_table_install+0xc88>

	ads->ds_ctl0 = ds_ctl0;

	ads->ds_ctl2 = set11nTries(series, 0)
				   | set11nTries(series, 1)
				   | set11nTries(series, 2)
  905925:	076601        	and	a6, a6, a7
				   | set11nTries(series, 3)
  905928:	064402        	or	a4, a4, a6
				   | (durUpdateEn ? AR_DurUpdateEn : 0);
  90592b:	d680      	mov.n	a6, a8
  90592d:	03c639        	movnez	a6, a12, a3
  905930:	064302        	or	a3, a4, a6
		ds_ctl0 = (ds_ctl0 & ~(AR_RTSEnable | AR_CTSEnable));
	}

	ads->ds_ctl0 = ds_ctl0;

	ads->ds_ctl2 = set11nTries(series, 0)
  905933:	038457        	extui	a4, a3, 24, 8
  905936:	242410        	s8i	a4, a2, 16
  905939:	030457        	extui	a4, a3, 16, 8
  90593c:	242411        	s8i	a4, a2, 17
  90593f:	038447        	extui	a4, a3, 8, 8
  905942:	242412        	s8i	a4, a2, 18
  905945:	232413        	s8i	a3, a2, 19
				   | (durUpdateEn ? AR_DurUpdateEn : 0);

	ads->ds_ctl3 = set11nRate(series, 0)
				   | set11nRate(series, 1)
				   | set11nRate(series, 2)
				   | set11nRate(series, 3);
  905948:	235210        	l32i	a3, a5, 64
				   | set11nTries(series, 1)
				   | set11nTries(series, 2)
				   | set11nTries(series, 3)
				   | (durUpdateEn ? AR_DurUpdateEn : 0);

	ads->ds_ctl3 = set11nRate(series, 0)
  90594b:	245007        	l8ui	a4, a5, 7
				   | set11nRate(series, 1)
				   | set11nRate(series, 2)
				   | set11nRate(series, 3);
  90594e:	083310        	slli	a3, a3, 24
				   | set11nTries(series, 2)
				   | set11nTries(series, 3)
				   | (durUpdateEn ? AR_DurUpdateEn : 0);

	ads->ds_ctl3 = set11nRate(series, 0)
				   | set11nRate(series, 1)
  905951:	043302        	or	a3, a3, a4
  905954:	8456      	l32i.n	a4, a5, 24
				   | set11nRate(series, 2)
  905956:	167254        	l32r	a6, 8e22a8 <athos_indirection_table_install+0xd60>
				   | set11nTries(series, 2)
				   | set11nTries(series, 3)
				   | (durUpdateEn ? AR_DurUpdateEn : 0);

	ads->ds_ctl3 = set11nRate(series, 0)
				   | set11nRate(series, 1)
  905959:	084411        	slli	a4, a4, 8
  90595c:	04044f        	extui	a4, a4, 0, 16
				   | set11nRate(series, 2)
  90595f:	043302        	or	a3, a3, a4
  905962:	845b      	l32i.n	a4, a5, 44
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
				   | set11nPktDurRTSCTS(series, 1);
  905964:	177255        	l32r	a7, 8e22b8 <athos_indirection_table_install+0xd70>
				   | set11nTries(series, 3)
				   | (durUpdateEn ? AR_DurUpdateEn : 0);

	ads->ds_ctl3 = set11nRate(series, 0)
				   | set11nRate(series, 1)
				   | set11nRate(series, 2)
  905967:	004411        	slli	a4, a4, 16
  90596a:	064401        	and	a4, a4, a6
				   | set11nRate(series, 3);
  90596d:	043302        	or	a3, a3, a4
				   | set11nTries(series, 1)
				   | set11nTries(series, 2)
				   | set11nTries(series, 3)
				   | (durUpdateEn ? AR_DurUpdateEn : 0);

	ads->ds_ctl3 = set11nRate(series, 0)
  905970:	038457        	extui	a4, a3, 24, 8
  905973:	242414        	s8i	a4, a2, 20
  905976:	030457        	extui	a4, a3, 16, 8
  905979:	242415        	s8i	a4, a2, 21
  90597c:	038447        	extui	a4, a3, 8, 8
  90597f:	242416        	s8i	a4, a2, 22
  905982:	232417        	s8i	a3, a2, 23
				   | set11nRate(series, 1)
				   | set11nRate(series, 2)
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
				   | set11nPktDurRTSCTS(series, 1);
  905985:	8357      	l32i.n	a3, a5, 28
	ads->ds_ctl3 = set11nRate(series, 0)
				   | set11nRate(series, 1)
				   | set11nRate(series, 2)
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
  905987:	8e54      	l32i.n	a14, a5, 16
  905989:	8a52      	l32i.n	a10, a5, 8
				   | set11nPktDurRTSCTS(series, 1);
  90598b:	8459      	l32i.n	a4, a5, 36
  90598d:	003311        	slli	a3, a3, 16
	ads->ds_ctl3 = set11nRate(series, 0)
				   | set11nRate(series, 1)
				   | set11nRate(series, 2)
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
  905990:	0e0940        	extui	a9, a14, 0, 1
  905993:	0a0a4e        	extui	a10, a10, 0, 15
  905996:	db80      	mov.n	a11, a8
				   | set11nPktDurRTSCTS(series, 1);
  905998:	073301        	and	a3, a3, a7
  90599b:	1f7246        	l32r	a15, 8e22b4 <athos_indirection_table_install+0xd6c>
	ads->ds_ctl3 = set11nRate(series, 0)
				   | set11nRate(series, 1)
				   | set11nRate(series, 2)
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
  90599e:	09cb39        	movnez	a11, a12, a9
				   | set11nPktDurRTSCTS(series, 1);
  9059a1:	040640        	extui	a6, a4, 0, 1
	ads->ds_ctl3 = set11nRate(series, 0)
				   | set11nRate(series, 1)
				   | set11nRate(series, 2)
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
  9059a4:	0a3302        	or	a3, a3, a10
				   | set11nPktDurRTSCTS(series, 1);
  9059a7:	068f38        	moveqz	a15, a8, a6
  9059aa:	0b3302        	or	a3, a3, a11
  9059ad:	0f3302        	or	a3, a3, a15
	ads->ds_ctl3 = set11nRate(series, 0)
				   | set11nRate(series, 1)
				   | set11nRate(series, 2)
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
  9059b0:	038657        	extui	a6, a3, 24, 8
  9059b3:	262418        	s8i	a6, a2, 24
  9059b6:	030657        	extui	a6, a3, 16, 8
  9059b9:	262419        	s8i	a6, a2, 25
  9059bc:	038647        	extui	a6, a3, 8, 8
  9059bf:	26241a        	s8i	a6, a2, 26
  9059c2:	23241b        	s8i	a3, a2, 27
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
  9059c5:	835e      	l32i.n	a3, a5, 56
  9059c7:	d680      	mov.n	a6, a8
  9059c9:	030b40        	extui	a11, a3, 0, 1
  9059cc:	0bc639        	movnez	a6, a12, a11
  9059cf:	db60      	mov.n	a11, a6
				   | set11nPktDurRTSCTS(series, 3);
  9059d1:	265211        	l32i	a6, a5, 68
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
  9059d4:	8d5c      	l32i.n	a13, a5, 48
				   | set11nPktDurRTSCTS(series, 3);
  9059d6:	2a5213        	l32i	a10, a5, 76
  9059d9:	006611        	slli	a6, a6, 16
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
  9059dc:	0d0d4e        	extui	a13, a13, 0, 15
				   | set11nPktDurRTSCTS(series, 3);
  9059df:	076601        	and	a6, a6, a7
  9059e2:	1f7246        	l32r	a15, 8e22fc <athos_indirection_table_install+0xdb4>
  9059e5:	0a0940        	extui	a9, a10, 0, 1
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
  9059e8:	0d6602        	or	a6, a6, a13
				   | set11nPktDurRTSCTS(series, 3);
  9059eb:	098f38        	moveqz	a15, a8, a9
  9059ee:	0b6602        	or	a6, a6, a11
  9059f1:	0f6602        	or	a6, a6, a15
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
  9059f4:	068757        	extui	a7, a6, 24, 8
  9059f7:	27241c        	s8i	a7, a2, 28
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
  9059fa:	c0d2      	movi.n	a13, 2
  9059fc:	c0b4      	movi.n	a11, 4
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
  9059fe:	060757        	extui	a7, a6, 16, 8
  905a01:	27241d        	s8i	a7, a2, 29
  905a04:	26241f        	s8i	a6, a2, 31
  905a07:	068747        	extui	a7, a6, 8, 8
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
  905a0a:	d9d0      	mov.n	a9, a13
  905a0c:	0be601        	and	a6, a14, a11
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
  905a0f:	27241e        	s8i	a7, a2, 30
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
  905a12:	068938        	moveqz	a9, a8, a6
  905a15:	0e1740        	extui	a7, a14, 1, 1
  905a18:	079602        	or	a6, a9, a7
  905a1b:	c098      	movi.n	a9, 8
  905a1d:	17722d        	l32r	a7, 8e22d4 <athos_indirection_table_install+0xd8c>
  905a20:	09ee01        	and	a14, a14, a9
  905a23:	0e8738        	moveqz	a7, a8, a14
  905a26:	076602        	or	a6, a6, a7
  905a29:	8753      	l32i.n	a7, a5, 12
  905a2b:	9612      	s32i.n	a6, a1, 8
  905a2d:	00d104        	ssl	a13
  905a30:	00771a        	sll	a7, a7
  905a33:	c16c      	movi.n	a6, 28
  905a35:	067601        	and	a6, a7, a6
  905a38:	9613      	s32i.n	a6, a1, 12
				   | set11nRateFlags(series, 1)
  905a3a:	c2f0      	movi.n	a15, 32
  905a3c:	0d4601        	and	a6, a4, a13
  905a3f:	068f38        	moveqz	a15, a8, a6
  905a42:	c4e0      	movi.n	a14, 64
  905a44:	0b4601        	and	a6, a4, a11
  905a47:	068e38        	moveqz	a14, a8, a6
  905a4a:	8758      	l32i.n	a7, a5, 32
  905a4c:	167245        	l32r	a6, 8e2360 <athos_indirection_table_install+0xe18>
  905a4f:	094401        	and	a4, a4, a9
  905a52:	048638        	moveqz	a6, a8, a4
  905a55:	097711        	slli	a7, a7, 7
  905a58:	243a80        	movi	a4, 0x380
  905a5b:	9e10      	s32i.n	a14, a1, 0
  905a5d:	047701        	and	a7, a7, a4
				   | set11nRateFlags(series, 2)
  905a60:	2e4a00        	movi	a14, 0x400
  905a63:	0d3401        	and	a4, a3, a13
  905a66:	048e38        	moveqz	a14, a8, a4
  905a69:	147250        	l32r	a4, 8e23ac <athos_indirection_table_install+0xe64>

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
				   | set11nRateFlags(series, 1)
  905a6c:	9611      	s32i.n	a6, a1, 4
				   | set11nRateFlags(series, 2)
  905a6e:	0b3601        	and	a6, a3, a11
  905a71:	068438        	moveqz	a4, a8, a6
  905a74:	16724a        	l32r	a6, 8e239c <athos_indirection_table_install+0xe54>
  905a77:	093301        	and	a3, a3, a9
  905a7a:	038638        	moveqz	a6, a8, a3
  905a7d:	d360      	mov.n	a3, a6
  905a7f:	865d      	l32i.n	a6, a5, 52
  905a81:	9415      	s32i.n	a4, a1, 20
  905a83:	147256        	l32r	a4, 8e23dc <athos_indirection_table_install+0xe94>
  905a86:	046611        	slli	a6, a6, 12
  905a89:	046601        	and	a6, a6, a4
				   | set11nRateFlags(series, 3)
  905a8c:	147246        	l32r	a4, 8e23a4 <athos_indirection_table_install+0xe5c>
  905a8f:	09a901        	and	a9, a10, a9
  905a92:	098438        	moveqz	a4, a8, a9
  905a95:	d940      	mov.n	a9, a4
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
  905a97:	8413      	l32i.n	a4, a1, 12
				   | set11nRateFlags(series, 1)
				   | set11nRateFlags(series, 2)
				   | set11nRateFlags(series, 3)
  905a99:	0dad01        	and	a13, a10, a13
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
  905a9c:	047702        	or	a7, a7, a4
				   | set11nRateFlags(series, 1)
  905a9f:	067602        	or	a6, a7, a6
				   | set11nRateFlags(series, 2)
				   | set11nRateFlags(series, 3)
  905aa2:	275212        	l32i	a7, a5, 72
  905aa5:	157257        	l32r	a5, 8e2404 <athos_indirection_table_install+0xebc>
  905aa8:	0f7710        	slli	a7, a7, 17
  905aab:	0d8c38        	moveqz	a12, a8, a13
				   | SM(rtsctsRate, AR_RTSCTSRate);
  905aae:	8414      	l32i.n	a4, a1, 16
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
				   | set11nRateFlags(series, 1)
				   | set11nRateFlags(series, 2)
				   | set11nRateFlags(series, 3)
  905ab0:	1d720e        	l32r	a13, 8e22e8 <athos_indirection_table_install+0xda0>
  905ab3:	057501        	and	a5, a7, a5
  905ab6:	0bab01        	and	a11, a10, a11

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
				   | set11nRateFlags(series, 1)
  905ab9:	056602        	or	a6, a6, a5
				   | set11nRateFlags(series, 2)
				   | set11nRateFlags(series, 3)
				   | SM(rtsctsRate, AR_RTSCTSRate);
  905abc:	157258        	l32r	a5, 8e241c <athos_indirection_table_install+0xed4>
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
				   | set11nRateFlags(series, 1)
				   | set11nRateFlags(series, 2)
				   | set11nRateFlags(series, 3)
  905abf:	0b8d38        	moveqz	a13, a8, a11
				   | SM(rtsctsRate, AR_RTSCTSRate);
  905ac2:	0c4810        	slli	a8, a4, 20
  905ac5:	058801        	and	a8, a8, a5

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
				   | set11nRateFlags(series, 1)
  905ac8:	8512      	l32i.n	a5, a1, 8
  905aca:	086602        	or	a6, a6, a8
  905acd:	056602        	or	a6, a6, a5
				   | set11nRateFlags(series, 2)
  905ad0:	0f6f02        	or	a15, a6, a15
  905ad3:	8610      	l32i.n	a6, a1, 0
  905ad5:	8411      	l32i.n	a4, a1, 4
  905ad7:	06ff02        	or	a15, a15, a6
  905ada:	04ff02        	or	a15, a15, a4
				   | set11nRateFlags(series, 3)
  905add:	8515      	l32i.n	a5, a1, 20
	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
				   | set11nRateFlags(series, 1)
				   | set11nRateFlags(series, 2)
  905adf:	0efe02        	or	a14, a15, a14
				   | set11nRateFlags(series, 3)
  905ae2:	05e402        	or	a4, a14, a5
  905ae5:	034302        	or	a3, a4, a3
  905ae8:	0c3c02        	or	a12, a3, a12
  905aeb:	0dcb02        	or	a11, a12, a13
				   | SM(rtsctsRate, AR_RTSCTSRate);
  905aee:	09b902        	or	a9, a11, a9
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
  905af1:	098357        	extui	a3, a9, 24, 8
  905af4:	232424        	s8i	a3, a2, 36
  905af7:	090357        	extui	a3, a9, 16, 8
  905afa:	232425        	s8i	a3, a2, 37
  905afd:	098347        	extui	a3, a9, 8, 8
  905b00:	232426        	s8i	a3, a2, 38
  905b03:	292427        	s8i	a9, a2, 39
  905b06:	d10f      	retw.n

00905b08 <ar5416Set11nAggrFirst_20>:
				   | SM(rtsctsRate, AR_RTSCTSRate);
}

void ar5416Set11nAggrFirst_20(struct ath_tx_desc *ds, a_uint32_t aggrLen,
			      a_uint32_t numDelims)
{
  905b08:	6c1004        	entry	a1, 32
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);
  905b0b:	2a200c        	l8ui	a10, a2, 12
  905b0e:	29200d        	l8ui	a9, a2, 13
  905b11:	28200e        	l8ui	a8, a2, 14
  905b14:	08aa10        	slli	a10, a10, 24
  905b17:	009911        	slli	a9, a9, 16
  905b1a:	0a9902        	or	a9, a9, a10
  905b1d:	088811        	slli	a8, a8, 8
  905b20:	098802        	or	a8, a8, a9
  905b23:	29200f        	l8ui	a9, a2, 15

	ads->ds_ctl6 &= ~(AR_AggrLen | AR_PadDelim);
  905b26:	2a2020        	l8ui	a10, a2, 32
void ar5416Set11nAggrFirst_20(struct ath_tx_desc *ds, a_uint32_t aggrLen,
			      a_uint32_t numDelims)
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);
  905b29:	089802        	or	a8, a9, a8
  905b2c:	197259        	l32r	a9, 8e2490 <athos_indirection_table_install+0xf48>

	ads->ds_ctl6 &= ~(AR_AggrLen | AR_PadDelim);
  905b2f:	08aa10        	slli	a10, a10, 24
void ar5416Set11nAggrFirst_20(struct ath_tx_desc *ds, a_uint32_t aggrLen,
			      a_uint32_t numDelims)
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);
  905b32:	098802        	or	a8, a8, a9
  905b35:	088957        	extui	a9, a8, 24, 8
  905b38:	29240c        	s8i	a9, a2, 12
  905b3b:	080957        	extui	a9, a8, 16, 8
  905b3e:	29240d        	s8i	a9, a2, 13
  905b41:	28240f        	s8i	a8, a2, 15
  905b44:	088947        	extui	a9, a8, 8, 8

	ads->ds_ctl6 &= ~(AR_AggrLen | AR_PadDelim);
  905b47:	282021        	l8ui	a8, a2, 33
void ar5416Set11nAggrFirst_20(struct ath_tx_desc *ds, a_uint32_t aggrLen,
			      a_uint32_t numDelims)
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);
  905b4a:	29240e        	s8i	a9, a2, 14

	ads->ds_ctl6 &= ~(AR_AggrLen | AR_PadDelim);
  905b4d:	292022        	l8ui	a9, a2, 34
  905b50:	008811        	slli	a8, a8, 16
  905b53:	0a8802        	or	a8, a8, a10
  905b56:	089911        	slli	a9, a9, 8
  905b59:	089902        	or	a9, a9, a8
  905b5c:	282023        	l8ui	a8, a2, 35
	ads->ds_ctl6 |= SM(aggrLen, AR_AggrLen) |
  905b5f:	03034f        	extui	a3, a3, 0, 16
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);

	ads->ds_ctl6 &= ~(AR_AggrLen | AR_PadDelim);
  905b62:	098902        	or	a9, a8, a9
  905b65:	18725a        	l32r	a8, 8e24d0 <athos_indirection_table_install+0xf88>
	ads->ds_ctl6 |= SM(aggrLen, AR_AggrLen) |
		SM(numDelims, AR_PadDelim);
  905b68:	0e4410        	slli	a4, a4, 18
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);

	ads->ds_ctl6 &= ~(AR_AggrLen | AR_PadDelim);
  905b6b:	089901        	and	a9, a9, a8
	ads->ds_ctl6 |= SM(aggrLen, AR_AggrLen) |
  905b6e:	093902        	or	a9, a3, a9
		SM(numDelims, AR_PadDelim);
  905b71:	13725b        	l32r	a3, 8e24e0 <athos_indirection_table_install+0xf98>
  905b74:	034801        	and	a8, a4, a3
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);

	ads->ds_ctl6 &= ~(AR_AggrLen | AR_PadDelim);
	ads->ds_ctl6 |= SM(aggrLen, AR_AggrLen) |
  905b77:	089802        	or	a8, a9, a8
  905b7a:	088357        	extui	a3, a8, 24, 8
  905b7d:	232420        	s8i	a3, a2, 32
  905b80:	080357        	extui	a3, a8, 16, 8
  905b83:	232421        	s8i	a3, a2, 33
  905b86:	088347        	extui	a3, a8, 8, 8
  905b89:	232422        	s8i	a3, a2, 34
  905b8c:	282423        	s8i	a8, a2, 35
  905b8f:	d10f      	retw.n
  905b91:	000000        	ill

00905b94 <ar5416Set11nAggrMiddle_20>:
		SM(numDelims, AR_PadDelim);
}

void ar5416Set11nAggrMiddle_20(struct ath_tx_desc *ds, a_uint32_t numDelims)
{
  905b94:	6c1004        	entry	a1, 32
	struct ar5416_desc *ads = AR5416DESC(ds);
	a_uint32_t ctl6;

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);
  905b97:	2a200c        	l8ui	a10, a2, 12
  905b9a:	29200d        	l8ui	a9, a2, 13
  905b9d:	28200e        	l8ui	a8, a2, 14
  905ba0:	08aa10        	slli	a10, a10, 24
  905ba3:	009911        	slli	a9, a9, 16
  905ba6:	0a9902        	or	a9, a9, a10
  905ba9:	088811        	slli	a8, a8, 8
  905bac:	098802        	or	a8, a8, a9
  905baf:	29200f        	l8ui	a9, a2, 15

	/*
	 * We use a stack variable to manipulate ctl6 to reduce uncached 
	 * read modify, modfiy, write.
	 */
	ctl6 = ads->ds_ctl6;
  905bb2:	2a2020        	l8ui	a10, a2, 32
void ar5416Set11nAggrMiddle_20(struct ath_tx_desc *ds, a_uint32_t numDelims)
{
	struct ar5416_desc *ads = AR5416DESC(ds);
	a_uint32_t ctl6;

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);
  905bb5:	089802        	or	a8, a9, a8
  905bb8:	197259        	l32r	a9, 8e251c <athos_indirection_table_install+0xfd4>

	/*
	 * We use a stack variable to manipulate ctl6 to reduce uncached 
	 * read modify, modfiy, write.
	 */
	ctl6 = ads->ds_ctl6;
  905bbb:	08aa10        	slli	a10, a10, 24
void ar5416Set11nAggrMiddle_20(struct ath_tx_desc *ds, a_uint32_t numDelims)
{
	struct ar5416_desc *ads = AR5416DESC(ds);
	a_uint32_t ctl6;

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);
  905bbe:	098802        	or	a8, a8, a9
  905bc1:	088957        	extui	a9, a8, 24, 8
  905bc4:	29240c        	s8i	a9, a2, 12
  905bc7:	080957        	extui	a9, a8, 16, 8
  905bca:	29240d        	s8i	a9, a2, 13
  905bcd:	28240f        	s8i	a8, a2, 15
  905bd0:	088947        	extui	a9, a8, 8, 8

	/*
	 * We use a stack variable to manipulate ctl6 to reduce uncached 
	 * read modify, modfiy, write.
	 */
	ctl6 = ads->ds_ctl6;
  905bd3:	282021        	l8ui	a8, a2, 33
void ar5416Set11nAggrMiddle_20(struct ath_tx_desc *ds, a_uint32_t numDelims)
{
	struct ar5416_desc *ads = AR5416DESC(ds);
	a_uint32_t ctl6;

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);
  905bd6:	29240e        	s8i	a9, a2, 14

	/*
	 * We use a stack variable to manipulate ctl6 to reduce uncached 
	 * read modify, modfiy, write.
	 */
	ctl6 = ads->ds_ctl6;
  905bd9:	292022        	l8ui	a9, a2, 34
  905bdc:	008811        	slli	a8, a8, 16
  905bdf:	0a8802        	or	a8, a8, a10
  905be2:	089911        	slli	a9, a9, 8
  905be5:	089902        	or	a9, a9, a8
  905be8:	282023        	l8ui	a8, a2, 35
	ctl6 &= ~AR_PadDelim;
  905beb:	1a725c        	l32r	a10, 8e255c <athos_indirection_table_install+0x1014>

	/*
	 * We use a stack variable to manipulate ctl6 to reduce uncached 
	 * read modify, modfiy, write.
	 */
	ctl6 = ads->ds_ctl6;
  905bee:	098902        	or	a9, a8, a9
	ctl6 &= ~AR_PadDelim;
	ctl6 |= SM(numDelims, AR_PadDelim);
  905bf1:	18725b        	l32r	a8, 8e2560 <athos_indirection_table_install+0x1018>
  905bf4:	0e3310        	slli	a3, a3, 18
	/*
	 * We use a stack variable to manipulate ctl6 to reduce uncached 
	 * read modify, modfiy, write.
	 */
	ctl6 = ads->ds_ctl6;
	ctl6 &= ~AR_PadDelim;
  905bf7:	0a9901        	and	a9, a9, a10
	ctl6 |= SM(numDelims, AR_PadDelim);
  905bfa:	083801        	and	a8, a3, a8
  905bfd:	098802        	or	a8, a8, a9
	ads->ds_ctl6 = ctl6;
  905c00:	088957        	extui	a9, a8, 24, 8
  905c03:	292420        	s8i	a9, a2, 32
  905c06:	080957        	extui	a9, a8, 16, 8
  905c09:	292421        	s8i	a9, a2, 33
  905c0c:	088947        	extui	a9, a8, 8, 8
  905c0f:	292422        	s8i	a9, a2, 34
  905c12:	282423        	s8i	a8, a2, 35
  905c15:	d10f      	retw.n
	...

00905c18 <ar5416Set11nAggrLast_20>:
}

void ar5416Set11nAggrLast_20(struct ath_tx_desc *ds)
{
  905c18:	6c1004        	entry	a1, 32
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= AR_IsAggr;
  905c1b:	2a200c        	l8ui	a10, a2, 12
  905c1e:	29200d        	l8ui	a9, a2, 13
  905c21:	28200e        	l8ui	a8, a2, 14
  905c24:	08aa10        	slli	a10, a10, 24
  905c27:	009911        	slli	a9, a9, 16
  905c2a:	0a9902        	or	a9, a9, a10
  905c2d:	088811        	slli	a8, a8, 8
  905c30:	098802        	or	a8, a8, a9
  905c33:	29200f        	l8ui	a9, a2, 15
	ads->ds_ctl1 &= ~AR_MoreAggr;
	ads->ds_ctl6 &= ~AR_PadDelim;
  905c36:	2a2020        	l8ui	a10, a2, 32

void ar5416Set11nAggrLast_20(struct ath_tx_desc *ds)
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= AR_IsAggr;
  905c39:	089802        	or	a8, a9, a8
	ads->ds_ctl1 &= ~AR_MoreAggr;
  905c3c:	19725d        	l32r	a9, 8e25b0 <athos_indirection_table_install+0x1068>
	ads->ds_ctl6 &= ~AR_PadDelim;
  905c3f:	08aa10        	slli	a10, a10, 24
void ar5416Set11nAggrLast_20(struct ath_tx_desc *ds)
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= AR_IsAggr;
	ads->ds_ctl1 &= ~AR_MoreAggr;
  905c42:	098801        	and	a8, a8, a9
  905c45:	19724a        	l32r	a9, 8e2570 <athos_indirection_table_install+0x1028>
  905c48:	098802        	or	a8, a8, a9
  905c4b:	088957        	extui	a9, a8, 24, 8
  905c4e:	29240c        	s8i	a9, a2, 12
  905c51:	080957        	extui	a9, a8, 16, 8
  905c54:	29240d        	s8i	a9, a2, 13
  905c57:	28240f        	s8i	a8, a2, 15
  905c5a:	088947        	extui	a9, a8, 8, 8
	ads->ds_ctl6 &= ~AR_PadDelim;
  905c5d:	282021        	l8ui	a8, a2, 33
void ar5416Set11nAggrLast_20(struct ath_tx_desc *ds)
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= AR_IsAggr;
	ads->ds_ctl1 &= ~AR_MoreAggr;
  905c60:	29240e        	s8i	a9, a2, 14
	ads->ds_ctl6 &= ~AR_PadDelim;
  905c63:	292022        	l8ui	a9, a2, 34
  905c66:	008811        	slli	a8, a8, 16
  905c69:	0a8802        	or	a8, a8, a10
  905c6c:	089911        	slli	a9, a9, 8
  905c6f:	089902        	or	a9, a9, a8
  905c72:	282023        	l8ui	a8, a2, 35
  905c75:	098902        	or	a9, a8, a9
  905c78:	18725c        	l32r	a8, 8e25e8 <athos_indirection_table_install+0x10a0>
  905c7b:	292423        	s8i	a9, a2, 35
  905c7e:	089801        	and	a8, a9, a8
  905c81:	088a57        	extui	a10, a8, 24, 8
  905c84:	2a2420        	s8i	a10, a2, 32
  905c87:	080a57        	extui	a10, a8, 16, 8
  905c8a:	088847        	extui	a8, a8, 8, 8
  905c8d:	2a2421        	s8i	a10, a2, 33
  905c90:	282422        	s8i	a8, a2, 34
  905c93:	d10f      	retw.n
  905c95:	000000        	ill

00905c98 <ar5416Clr11nAggr_20>:
}

void ar5416Clr11nAggr_20(struct ath_tx_desc *ds)
{
  905c98:	6c1004        	entry	a1, 32
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 &= (~AR_IsAggr & ~AR_MoreAggr);
  905c9b:	2a200c        	l8ui	a10, a2, 12
  905c9e:	28200d        	l8ui	a8, a2, 13
  905ca1:	29200e        	l8ui	a9, a2, 14
  905ca4:	08aa10        	slli	a10, a10, 24
  905ca7:	008811        	slli	a8, a8, 16
  905caa:	0a8802        	or	a8, a8, a10
  905cad:	089911        	slli	a9, a9, 8
  905cb0:	089902        	or	a9, a9, a8
  905cb3:	28200f        	l8ui	a8, a2, 15
  905cb6:	098902        	or	a9, a8, a9
  905cb9:	18725e        	l32r	a8, 8e2634 <athos_indirection_table_install+0x10ec>
  905cbc:	29240f        	s8i	a9, a2, 15
  905cbf:	089801        	and	a8, a9, a8
  905cc2:	088a57        	extui	a10, a8, 24, 8
  905cc5:	2a240c        	s8i	a10, a2, 12
  905cc8:	080a57        	extui	a10, a8, 16, 8
  905ccb:	088847        	extui	a8, a8, 8, 8
  905cce:	2a240d        	s8i	a10, a2, 13
  905cd1:	28240e        	s8i	a8, a2, 14
  905cd4:	d10f      	retw.n
	...

00905cd8 <ar5416Set11nBurstDuration_20>:
}

void ar5416Set11nBurstDuration_20(struct ath_tx_desc *ds,
				  a_uint32_t burstDuration)
{
  905cd8:	6c1004        	entry	a1, 32
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl2 &= ~AR_BurstDur;
  905cdb:	2a2010        	l8ui	a10, a2, 16
  905cde:	292011        	l8ui	a9, a2, 17
  905ce1:	282012        	l8ui	a8, a2, 18
  905ce4:	08aa10        	slli	a10, a10, 24
  905ce7:	009911        	slli	a9, a9, 16
  905cea:	0a9902        	or	a9, a9, a10
  905ced:	088811        	slli	a8, a8, 8
  905cf0:	098802        	or	a8, a8, a9
  905cf3:	292013        	l8ui	a9, a2, 19
	ads->ds_ctl2 |= SM(burstDuration, AR_BurstDur);
  905cf6:	03034e        	extui	a3, a3, 0, 15
void ar5416Set11nBurstDuration_20(struct ath_tx_desc *ds,
				  a_uint32_t burstDuration)
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl2 &= ~AR_BurstDur;
  905cf9:	089802        	or	a8, a9, a8
  905cfc:	19725f        	l32r	a9, 8e2678 <athos_indirection_table_install+0x1130>
  905cff:	098801        	and	a8, a8, a9
	ads->ds_ctl2 |= SM(burstDuration, AR_BurstDur);
  905d02:	083802        	or	a8, a3, a8
  905d05:	088957        	extui	a9, a8, 24, 8
  905d08:	292410        	s8i	a9, a2, 16
  905d0b:	080957        	extui	a9, a8, 16, 8
  905d0e:	292411        	s8i	a9, a2, 17
  905d11:	088947        	extui	a9, a8, 8, 8
  905d14:	292412        	s8i	a9, a2, 18
  905d17:	282413        	s8i	a8, a2, 19
  905d1a:	d10f      	retw.n

00905d1c <ar5416Set11nVirtualMoreFrag_20>:
}

void ar5416Set11nVirtualMoreFrag_20(struct ath_tx_desc *ds,
				    a_uint32_t vmf)
{
  905d1c:	6c1004        	entry	a1, 32
  905d1f:	282008        	l8ui	a8, a2, 8
  905d22:	292009        	l8ui	a9, a2, 9
	struct ar5416_desc *ads = AR5416DESC(ds);

	if (vmf) {
		ads->ds_ctl0 |= AR_VirtMoreFrag;
  905d25:	088810        	slli	a8, a8, 24
  905d28:	009911        	slli	a9, a9, 16
void ar5416Set11nVirtualMoreFrag_20(struct ath_tx_desc *ds,
				    a_uint32_t vmf)
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	if (vmf) {
  905d2b:	ca3d      	beqz.n	a3, 905d5c <ar5416Set11nVirtualMoreFrag_20+0x40>
		ads->ds_ctl0 |= AR_VirtMoreFrag;
  905d2d:	089902        	or	a9, a9, a8
  905d30:	28200a        	l8ui	a8, a2, 10
  905d33:	1a7209        	l32r	a10, 8e2558 <athos_indirection_table_install+0x1010>
  905d36:	088811        	slli	a8, a8, 8
  905d39:	098802        	or	a8, a8, a9
  905d3c:	29200b        	l8ui	a9, a2, 11
  905d3f:	089802        	or	a8, a9, a8
  905d42:	0a8802        	or	a8, a8, a10
  905d45:	088957        	extui	a9, a8, 24, 8
  905d48:	292408        	s8i	a9, a2, 8
  905d4b:	080957        	extui	a9, a8, 16, 8
  905d4e:	292409        	s8i	a9, a2, 9
  905d51:	088947        	extui	a9, a8, 8, 8
  905d54:	29240a        	s8i	a9, a2, 10
  905d57:	28240b        	s8i	a8, a2, 11
  905d5a:	d10f      	retw.n
	} else {
		ads->ds_ctl0 &= ~AR_VirtMoreFrag;
  905d5c:	089802        	or	a8, a9, a8
  905d5f:	29200a        	l8ui	a9, a2, 10
  905d62:	089911        	slli	a9, a9, 8
  905d65:	089902        	or	a9, a9, a8
  905d68:	28200b        	l8ui	a8, a2, 11
  905d6b:	098902        	or	a9, a8, a9
  905d6e:	187260        	l32r	a8, 8e26f0 <athos_indirection_table_install+0x11a8>
  905d71:	29240b        	s8i	a9, a2, 11
  905d74:	089801        	and	a8, a9, a8
  905d77:	088a57        	extui	a10, a8, 24, 8
  905d7a:	2a2408        	s8i	a10, a2, 8
  905d7d:	080a57        	extui	a10, a8, 16, 8
  905d80:	088847        	extui	a8, a8, 8, 8
  905d83:	2a2409        	s8i	a10, a2, 9
  905d86:	28240a        	s8i	a8, a2, 10
  905d89:	d10f      	retw.n
	...

00905d8c <ar5416StopTxDma>:

	return AH_TRUE;
}

HAL_BOOL ar5416StopTxDma(struct ath_hal*ah, a_uint32_t q)
{
  905d8c:	6c1004        	entry	a1, 32
  905d8f:	147261        	l32r	a4, 8e2714 <athos_indirection_table_install+0x11cc>
	
        HALASSERT(q < AH_PRIVATE(ah)->ah_caps.halTotalQueues);

        HALASSERT(AH5416(ah)->ah_txq[q].tqi_type != HAL_TX_QUEUE_INACTIVE);

	iowrite32_mac(AR_Q_TXD, 1 << q);
  905d92:	c081      	movi.n	a8, 1
  905d94:	003104        	ssl	a3
  905d97:	00881a        	sll	a8, a8
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  905d9a:	0c0200        	memw
  905d9d:	9840      	s32i.n	a8, a4, 0
        for (i = 1000; i != 0; i--) {
  905d9f:	243ae8        	movi	a4, 0x3e8
                if (ar5416NumTxPending(ah, q) == 0)
  905da2:	da20      	mov.n	a10, a2
  905da4:	033b02        	or	a11, a3, a3
  905da7:	5bfd9c        	call8	905418 <ar5416NumTxPending>
  905daa:	c8aa      	beqz.n	a10, 905db8 <ar5416StopTxDma+0x2c>
                        break;
                OS_DELAY(100);        /* XXX get actual value */
  905dac:	2a0a64        	movi	a10, 100
        HALASSERT(q < AH_PRIVATE(ah)->ah_caps.halTotalQueues);

        HALASSERT(AH5416(ah)->ah_txq[q].tqi_type != HAL_TX_QUEUE_INACTIVE);

	iowrite32_mac(AR_Q_TXD, 1 << q);
        for (i = 1000; i != 0; i--) {
  905daf:	244cff        	addi	a4, a4, -1
                if (ar5416NumTxPending(ah, q) == 0)
                        break;
                OS_DELAY(100);        /* XXX get actual value */
  905db2:	5bf788        	call8	903bd4 <ath_hal_delay>
        HALASSERT(q < AH_PRIVATE(ah)->ah_caps.halTotalQueues);

        HALASSERT(AH5416(ah)->ah_txq[q].tqi_type != HAL_TX_QUEUE_INACTIVE);

	iowrite32_mac(AR_Q_TXD, 1 << q);
        for (i = 1000; i != 0; i--) {
  905db5:	654fe9        	bnez	a4, 905da2 <ar5416StopTxDma+0x16>
  905db8:	127261        	l32r	a2, 8e273c <athos_indirection_table_install+0x11f4>
  905dbb:	c030      	movi.n	a3, 0
  905dbd:	0c0200        	memw
  905dc0:	9320      	s32i.n	a3, a2, 0
                        break;
                OS_DELAY(100);        /* XXX get actual value */
        }

	iowrite32_mac(AR_Q_TXD, 0);
        return (i != 0);
  905dc2:	c021      	movi.n	a2, 1
  905dc4:	043238        	moveqz	a2, a3, a4
}
  905dc7:	d10f      	retw.n
  905dc9:	000000        	ill

00905dcc <ar5416AbortTxDma>:
#endif
        return npend;
}

HAL_BOOL ar5416AbortTxDma(struct ath_hal *ah)
{
  905dcc:	6c1004        	entry	a1, 32
  905dcf:	137261        	l32r	a3, 8e2754 <athos_indirection_table_install+0x120c>
  905dd2:	243aff        	movi	a4, 0x3ff
  905dd5:	0c0200        	memw
  905dd8:	9430      	s32i.n	a4, a3, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  905dda:	137262        	l32r	a3, 8e2764 <athos_indirection_table_install+0x121c>
	iowrite32_mac(AR_Q_TXD, AR_Q_TXD_M);

	/*
	 * set tx abort bits
	 */
	OS_REG_SET_BIT(ah, AR_PCU_MISC, (AR_PCU_FORCE_QUIET_COLL | AR_PCU_CLEAR_VMF));
  905ddd:	147263        	l32r	a4, 8e276c <athos_indirection_table_install+0x1224>
  905de0:	0c0200        	memw
  905de3:	8830      	l32i.n	a8, a3, 0
  905de5:	048402        	or	a4, a8, a4
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  905de8:	0c0200        	memw
  905deb:	9430      	s32i.n	a4, a3, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  905ded:	13723c        	l32r	a3, 8e26e0 <athos_indirection_table_install+0x1198>
	OS_REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_FORCE_CH_IDLE_HIGH);
  905df0:	147247        	l32r	a4, 8e270c <athos_indirection_table_install+0x11c4>
  905df3:	0c0200        	memw
  905df6:	8830      	l32i.n	a8, a3, 0
  905df8:	048402        	or	a4, a8, a4
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  905dfb:	0c0200        	memw
  905dfe:	9430      	s32i.n	a4, a3, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  905e00:	137264        	l32r	a3, 8e2790 <athos_indirection_table_install+0x1248>
	OS_REG_SET_BIT(ah, AR_D_GBL_IFS_MISC, AR_D_GBL_IFS_MISC_IGNORE_BACKOFF);
  905e03:	14722d        	l32r	a4, 8e26b8 <athos_indirection_table_install+0x1170>
  905e06:	0c0200        	memw
  905e09:	8830      	l32i.n	a8, a3, 0
  905e0b:	048402        	or	a4, a8, a4
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  905e0e:	0c0200        	memw
  905e11:	9430      	s32i.n	a4, a3, 0

	/*
	 * wait on all tx queues
	 */
	for (q = 0; q < AR_NUM_QCU; q++) {
  905e13:	c030      	movi.n	a3, 0
  905e15:	60001b        	j	905e34 <ar5416AbortTxDma+0x68>
  905e18:	00da20        	excw
		for (i = 0; i < AR5416_ABORT_LOOPS; i++) {
			if (!ar5416NumTxPending(ah, q))
  905e1b:	db30      	mov.n	a11, a3
  905e1d:	5bfd7e        	call8	905418 <ar5416NumTxPending>
  905e20:	64a05c        	beqz	a10, 905e80 <ar5416AbortTxDma+0xb4>
				break;

			OS_DELAY(AR5416_ABORT_WAIT);
  905e23:	2a0a05        	movi	a10, 5
  905e26:	244cff        	addi	a4, a4, -1
  905e29:	5bf76a        	call8	903bd4 <ath_hal_delay>

	/*
	 * wait on all tx queues
	 */
	for (q = 0; q < AR_NUM_QCU; q++) {
		for (i = 0; i < AR5416_ABORT_LOOPS; i++) {
  905e2c:	654fe9        	bnez	a4, 905e19 <ar5416AbortTxDma+0x4d>
				break;

			OS_DELAY(AR5416_ABORT_WAIT);
		}
		if (i == AR5416_ABORT_LOOPS) {
			return AH_FALSE;
  905e2f:	d240      	mov.n	a2, a4
  905e31:	d10f      	retw.n
  905e33:	00243a        	movltz	a4, a2, a0
#endif
        return npend;
}

HAL_BOOL ar5416AbortTxDma(struct ath_hal *ah)
{
  905e36:	e8          	.byte 0xe8
  905e37:	63ffde        	j	905e19 <ar5416AbortTxDma+0x4d>
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  905e3a:	127262        	l32r	a2, 8e27c4 <athos_indirection_table_install+0x127c>
	}

	/*
	 * clear tx abort bits
	 */
	OS_REG_CLR_BIT(ah, AR_PCU_MISC, (AR_PCU_FORCE_QUIET_COLL | AR_PCU_CLEAR_VMF));
  905e3d:	137265        	l32r	a3, 8e27d4 <athos_indirection_table_install+0x128c>
  905e40:	0c0200        	memw
  905e43:	8420      	l32i.n	a4, a2, 0
  905e45:	034301        	and	a3, a4, a3
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  905e48:	0c0200        	memw
  905e4b:	9320      	s32i.n	a3, a2, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  905e4d:	12723c        	l32r	a2, 8e2740 <athos_indirection_table_install+0x11f8>
	OS_REG_CLR_BIT(ah, AR_DIAG_SW, AR_DIAG_FORCE_CH_IDLE_HIGH);
  905e50:	137251        	l32r	a3, 8e2794 <athos_indirection_table_install+0x124c>
  905e53:	0c0200        	memw
  905e56:	8420      	l32i.n	a4, a2, 0
  905e58:	034301        	and	a3, a4, a3
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  905e5b:	0c0200        	memw
  905e5e:	9320      	s32i.n	a3, a2, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  905e60:	127264        	l32r	a2, 8e27f0 <athos_indirection_table_install+0x12a8>
	OS_REG_CLR_BIT(ah, AR_D_GBL_IFS_MISC, AR_D_GBL_IFS_MISC_IGNORE_BACKOFF);
  905e63:	137266        	l32r	a3, 8e27fc <athos_indirection_table_install+0x12b4>
  905e66:	0c0200        	memw
  905e69:	8420      	l32i.n	a4, a2, 0
  905e6b:	034301        	and	a3, a4, a3
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  905e6e:	0c0200        	memw
  905e71:	9320      	s32i.n	a3, a2, 0
  905e73:	127261        	l32r	a2, 8e27f8 <athos_indirection_table_install+0x12b0>
  905e76:	0c0200        	memw
  905e79:	9a20      	s32i.n	a10, a2, 0
	/*
	 * clear txd
	 */
	iowrite32_mac(AR_Q_TXD, 0);

	return AH_TRUE;
  905e7b:	c021      	movi.n	a2, 1
  905e7d:	d10f      	retw.n
  905e7f:	00b133        	excw
	OS_REG_SET_BIT(ah, AR_D_GBL_IFS_MISC, AR_D_GBL_IFS_MISC_IGNORE_BACKOFF);

	/*
	 * wait on all tx queues
	 */
	for (q = 0; q < AR_NUM_QCU; q++) {
  905e82:	6939ae        	bnei	a3, 10, 905e34 <ar5416AbortTxDma+0x68>
  905e85:	63ffb1        	j	905e3a <ar5416AbortTxDma+0x6e>

00905e88 <ar5416StopDmaReceive>:
	iowrite32_mac(AR_RXDP, rxdp);
	HALASSERT(ioread32_mac(AR_RXDP) == rxdp);
}

HAL_BOOL ar5416StopDmaReceive(struct ath_hal *ah)
{
  905e88:	6c1004        	entry	a1, 32
  905e8b:	18723b        	l32r	a8, 8e2778 <athos_indirection_table_install+0x1230>
  905e8e:	c290      	movi.n	a9, 32
  905e90:	0c0200        	memw
  905e93:	9980      	s32i.n	a9, a8, 0
	iowrite32_mac(AR_CR, AR_CR_RXD); /* Set receive disable bit */
	if (!ath_hal_wait(ah, AR_CR, AR_CR_RXE, 0)) {
  905e95:	da20      	mov.n	a10, a2
  905e97:	c0b8      	movi.n	a11, 8
  905e99:	c0c4      	movi.n	a12, 4
  905e9b:	c0d0      	movi.n	a13, 0
  905e9d:	5bfc51        	call8	904fe4 <ath_hal_wait>
  905ea0:	c081      	movi.n	a8, 1
  905ea2:	c020      	movi.n	a2, 0
  905ea4:	0a8239        	movnez	a2, a8, a10
		return AH_FALSE;
	} else {
		return AH_TRUE;
	}
}
  905ea7:	d10f      	retw.n
  905ea9:	000000        	ill

00905eac <ar5416Detach>:
		.ah_setInterrupts        = ar5416SetInterrupts,
	},
};

void ar5416Detach(struct ath_hal *ah)
{
  905eac:	6c1004        	entry	a1, 32
	HALASSERT(ah != AH_NULL);
	ath_hal_free(ah);
  905eaf:	da20      	mov.n	a10, a2
  905eb1:	5bf755        	call8	903c08 <ath_hal_free>
  905eb4:	d10f      	retw.n
	...

00905eb8 <ar5416GetPendingInterrupts>:
	 */
	return ((host_isr != AR_INTR_SPURIOUS) && (host_isr & AR_INTR_MAC_IRQ));
}

HAL_BOOL ar5416GetPendingInterrupts(struct ath_hal *ah, HAL_INT *masked)
{
  905eb8:	6c1004        	entry	a1, 32
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  905ebb:	18722e        	l32r	a8, 8e2774 <athos_indirection_table_install+0x122c>
  905ebe:	0c0200        	memw
  905ec1:	8980      	l32i.n	a9, a8, 0
#ifndef AR9100
	HAL_BOOL fatal_int = AH_FALSE;
	a_uint32_t sync_cause;

	if (ioread32_mac(AR_INTR_ASYNC_CAUSE)
			& AR_INTR_MAC_IRQ) {
  905ec3:	c082      	movi.n	a8, 2
  905ec5:	089801        	and	a8, a9, a8
	a_uint32_t isr;
#ifndef AR9100
	HAL_BOOL fatal_int = AH_FALSE;
	a_uint32_t sync_cause;

	if (ioread32_mac(AR_INTR_ASYNC_CAUSE)
  905ec8:	c980      	beqz.n	a8, 905edc <ar5416GetPendingInterrupts+0x24>
  905eca:	187267        	l32r	a8, 8e2868 <athos_indirection_table_install+0x1320>
  905ecd:	0c0200        	memw
  905ed0:	8880      	l32i.n	a8, a8, 0
			& AR_INTR_MAC_IRQ) {
		if ((ioread32_mac(AR_RTC_STATUS)
				& AR_RTC_STATUS_M) != AR_RTC_STATUS_ON) {
  905ed2:	080843        	extui	a8, a8, 0, 4
	HAL_BOOL fatal_int = AH_FALSE;
	a_uint32_t sync_cause;

	if (ioread32_mac(AR_INTR_ASYNC_CAUSE)
			& AR_INTR_MAC_IRQ) {
		if ((ioread32_mac(AR_RTC_STATUS)
  905ed5:	68820b        	beqi	a8, 2, 905ee4 <ar5416GetPendingInterrupts+0x2c>
  905ed8:	600013        	j	905eef <ar5416GetPendingInterrupts+0x37>
  905edb:	009830        	excw
			*masked = 0;
			return AH_FALSE;
		}
	} else {
		*masked = 0;
		return AH_FALSE;
  905ede:	d280      	mov.n	a2, a8
  905ee0:	d10f      	retw.n
  905ee2:	000018        	src	a0, a0, a0
  905ee5:	72680c        	bany	a6, a2, 905ef5 <ar5416GetPendingInterrupts+0x3d>
  905ee8:	020088        	excw
  905eeb:	8069      	l32i.n	a0, a6, 36
	}
#endif
	isr = ioread32_mac(AR_ISR_RAC);
	if (isr == 0xffffffff) {
  905eed:	8005      	l32i.n	a0, a0, 20
		*masked = 0;
  905eef:	c020      	movi.n	a2, 0
  905ef1:	9230      	s32i.n	a2, a3, 0
  905ef3:	d10f      	retw.n
		return AH_FALSE;
	}

	*masked = isr & HAL_INT_COMMON;
  905ef5:	1a7230        	l32r	a10, 8e27b8 <athos_indirection_table_install+0x1270>
	if (isr & (AR_ISR_TXMINTR | AR_ISR_TXINTM)) {
		*masked |= HAL_INT_TX;
	}
#endif

	if (isr & AR_ISR_BCNMISC) {
  905ef8:	1b7232        	l32r	a11, 8e27c0 <athos_indirection_table_install+0x1278>
	if (isr == 0xffffffff) {
		*masked = 0;
		return AH_FALSE;
	}

	*masked = isr & HAL_INT_COMMON;
  905efb:	0a8a01        	and	a10, a8, a10
  905efe:	2a3600        	s32i	a10, a3, 0
	if (isr & (AR_ISR_TXMINTR | AR_ISR_TXINTM)) {
		*masked |= HAL_INT_TX;
	}
#endif

	if (isr & AR_ISR_BCNMISC) {
  905f01:	7b8021        	bnone	a8, a11, 905f26 <ar5416GetPendingInterrupts+0x6e>
  905f04:	197269        	l32r	a9, 8e28a8 <athos_indirection_table_install+0x1360>
  905f07:	0c0200        	memw
  905f0a:	8990      	l32i.n	a9, a9, 0
		a_uint32_t s2_s;

		s2_s = ioread32_mac(AR_ISR_S2_S);

		if (s2_s & AR_ISR_S2_GTT) {
  905f0c:	7b9008        	bnone	a9, a11, 905f18 <ar5416GetPendingInterrupts+0x60>
			*masked |= HAL_INT_GTT;
  905f0f:	1b7245        	l32r	a11, 8e2824 <athos_indirection_table_install+0x12dc>
  905f12:	0baa02        	or	a10, a10, a11
  905f15:	2a3600        	s32i	a10, a3, 0
		}

		if (s2_s & AR_ISR_S2_CST) {
  905f18:	79960a        	bbci	a9, 9, 905f26 <ar5416GetPendingInterrupts+0x6e>
			*masked |= HAL_INT_CST;
  905f1b:	8a30      	l32i.n	a10, a3, 0
  905f1d:	19726a        	l32r	a9, 8e28c8 <athos_indirection_table_install+0x1380>
  905f20:	09a902        	or	a9, a10, a9
  905f23:	293600        	s32i	a9, a3, 0
		}
	}

	if (isr & (AR_ISR_RXOK | AR_ISR_RXERR))
  905f26:	c095      	movi.n	a9, 5
  905f28:	798009        	bnone	a8, a9, 905f35 <ar5416GetPendingInterrupts+0x7d>
		*masked |= HAL_INT_RX;
  905f2b:	8a30      	l32i.n	a10, a3, 0
  905f2d:	c091      	movi.n	a9, 1
  905f2f:	09a902        	or	a9, a10, a9
  905f32:	293600        	s32i	a9, a3, 0
	if (isr & (AR_ISR_TXOK | AR_ISR_TXDESC | AR_ISR_TXERR | AR_ISR_TXEOL)) {
  905f35:	295ac0        	movi	a9, 0x5c0
  905f38:	79803c        	bnone	a8, a9, 905f78 <ar5416GetPendingInterrupts+0xc0>
		struct ath_hal_5416 *ahp = AH5416(ah);
		a_uint32_t           s0_s, s1_s;

		*masked |= HAL_INT_TX;
  905f3b:	8930      	l32i.n	a9, a3, 0
  905f3d:	c480      	movi.n	a8, 64
  905f3f:	089802        	or	a8, a9, a8
  905f42:	9830      	s32i.n	a8, a3, 0
  905f44:	13726b        	l32r	a3, 8e28f0 <athos_indirection_table_install+0x13a8>
  905f47:	0c0200        	memw
  905f4a:	8930      	l32i.n	a9, a3, 0
  905f4c:	13726c        	l32r	a3, 8e28fc <athos_indirection_table_install+0x13b4>
  905f4f:	0c0200        	memw
  905f52:	8830      	l32i.n	a8, a3, 0
		s0_s = ioread32_mac(AR_ISR_S0_S);
		s1_s = ioread32_mac(AR_ISR_S1_S);
		ahp->ah_intrTxqs |= MS(s0_s, AR_ISR_S0_QCU_TXOK);
		ahp->ah_intrTxqs |= MS(s0_s, AR_ISR_S0_QCU_TXDESC);
  905f54:	232238        	l32i	a3, a2, 224
		ahp->ah_intrTxqs |= MS(s1_s, AR_ISR_S1_QCU_TXERR);
  905f57:	098a02        	or	a10, a8, a9
		a_uint32_t           s0_s, s1_s;

		*masked |= HAL_INT_TX;
		s0_s = ioread32_mac(AR_ISR_S0_S);
		s1_s = ioread32_mac(AR_ISR_S1_S);
		ahp->ah_intrTxqs |= MS(s0_s, AR_ISR_S0_QCU_TXOK);
  905f5a:	0a0a49        	extui	a10, a10, 0, 10
		ahp->ah_intrTxqs |= MS(s0_s, AR_ISR_S0_QCU_TXDESC);
  905f5d:	03aa02        	or	a10, a10, a3
  905f60:	13726d        	l32r	a3, 8e2914 <athos_indirection_table_install+0x13cc>
  905f63:	039901        	and	a9, a9, a3
		ahp->ah_intrTxqs |= MS(s1_s, AR_ISR_S1_QCU_TXERR);
		ahp->ah_intrTxqs |= MS(s1_s, AR_ISR_S1_QCU_TXEOL);
  905f66:	038801        	and	a8, a8, a3

		*masked |= HAL_INT_TX;
		s0_s = ioread32_mac(AR_ISR_S0_S);
		s1_s = ioread32_mac(AR_ISR_S1_S);
		ahp->ah_intrTxqs |= MS(s0_s, AR_ISR_S0_QCU_TXOK);
		ahp->ah_intrTxqs |= MS(s0_s, AR_ISR_S0_QCU_TXDESC);
  905f69:	09095f        	extui	a9, a9, 16, 16
		ahp->ah_intrTxqs |= MS(s1_s, AR_ISR_S1_QCU_TXERR);
  905f6c:	09a902        	or	a9, a10, a9
		ahp->ah_intrTxqs |= MS(s1_s, AR_ISR_S1_QCU_TXEOL);
  905f6f:	08085f        	extui	a8, a8, 16, 16
  905f72:	089302        	or	a3, a9, a8
  905f75:	232638        	s32i	a3, a2, 224
  905f78:	13726e        	l32r	a3, 8e2930 <athos_indirection_table_install+0x13e8>
	if (AH_TRUE == fatal_int) {
		iowrite32_mac(AR_INTR_SYNC_CAUSE_CLR, sync_cause);
		(void) ioread32_mac(AR_INTR_SYNC_CAUSE_CLR);
	}
#endif
	return AH_TRUE;
  905f7b:	c021      	movi.n	a2, 1
  905f7d:	0c0200        	memw
  905f80:	8830      	l32i.n	a8, a3, 0

#ifndef AR9100
	sync_cause = ioread32_mac(AR_INTR_SYNC_CAUSE);
	fatal_int = ((sync_cause != AR_INTR_SPURIOUS) &&
		     (sync_cause & (AR_INTR_SYNC_HOST1_FATAL
		      | AR_INTR_SYNC_HOST1_PERR))) ? AH_TRUE : AH_FALSE;
  905f82:	68800f        	beqi	a8, -1, 905f95 <ar5416GetPendingInterrupts+0xdd>
  905f85:	290a60        	movi	a9, 96
  905f88:	798009        	bnone	a8, a9, 905f95 <ar5416GetPendingInterrupts+0xdd>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  905f8b:	0c0200        	memw
  905f8e:	9830      	s32i.n	a8, a3, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  905f90:	0c0200        	memw
  905f93:	8330      	l32i.n	a3, a3, 0
		iowrite32_mac(AR_INTR_SYNC_CAUSE_CLR, sync_cause);
		(void) ioread32_mac(AR_INTR_SYNC_CAUSE_CLR);
	}
#endif
	return AH_TRUE;
}
  905f95:	d10f      	retw.n
	...

00905f98 <ar5416SetRxFilter>:
		return AH_TRUE;
	}
}

void ar5416SetRxFilter(struct ath_hal *ah, a_uint32_t bits)
{
  905f98:	6c1004        	entry	a1, 32
	a_uint32_t phybits;
    
	iowrite32_mac(AR_RX_FILTER, (bits & 0xff) | AR_RX_COMPR_BAR);
  905f9b:	284a00        	movi	a8, 0x400
  905f9e:	030947        	extui	a9, a3, 0, 8
  905fa1:	089902        	or	a9, a9, a8
  905fa4:	18726f        	l32r	a8, 8e2960 <athos_indirection_table_install+0x1418>
	phybits = 0;
	if (bits & HAL_RX_FILTER_PHYRADAR)
  905fa7:	2a2a00        	movi	a10, 0x200
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  905faa:	0c0200        	memw
  905fad:	9980      	s32i.n	a9, a8, 0
  905faf:	0a3a01        	and	a10, a3, a10
		phybits |= AR_PHY_ERR_RADAR;
  905fb2:	280a20        	movi	a8, 32
  905fb5:	290a00        	movi	a9, 0
  905fb8:	0a9838        	moveqz	a8, a9, a10
	if (bits & HAL_RX_FILTER_PHYERR)
  905fbb:	773705        	bbci	a3, 23, 905fc4 <ar5416SetRxFilter+0x2c>
		phybits |= AR_PHY_ERR_OFDM_TIMING | AR_PHY_ERR_CCK_TIMING;
  905fbe:	137270        	l32r	a3, 8e2980 <athos_indirection_table_install+0x1438>
  905fc1:	038802        	or	a8, a8, a3
  905fc4:	137271        	l32r	a3, 8e2988 <athos_indirection_table_install+0x1440>
  905fc7:	197272        	l32r	a9, 8e2990 <athos_indirection_table_install+0x1448>
  905fca:	0c0200        	memw
  905fcd:	9830      	s32i.n	a8, a3, 0
	iowrite32_mac(AR_PHY_ERR, phybits);
	if (phybits) {
  905fcf:	c88d      	beqz.n	a8, 905fe0 <ar5416SetRxFilter+0x48>
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  905fd1:	0c0200        	memw
  905fd4:	8890      	l32i.n	a8, a9, 0
		iowrite32_mac(AR_RXCFG,
  905fd6:	c130      	movi.n	a3, 16
  905fd8:	038302        	or	a3, a8, a3
  905fdb:	60000b        	j	905fea <ar5416SetRxFilter+0x52>
  905fde:	00000c        	sub	a0, a0, a0
  905fe1:	020088        	excw
  905fe4:	90c6      	s32i.n	a0, a12, 24
			     ioread32_mac(AR_RXCFG)
			     | AR_RXCFG_ZLFDMA);
	} else {
		iowrite32_mac(AR_RXCFG,
  905fe6:	3f0383        	excw
  905fe9:	010c02        	or	a12, a0, a1
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  905fec:	009390        	l32e	a0, a9, -52
  905fef:	d10f      	retw.n
  905ff1:	000000        	ill

00905ff4 <ar5416ProcTxDesc_20>:
	ads->ds_ctl6 = SM(keyType, AR_EncrType);
	return AH_TRUE;
}

HAL_STATUS ar5416ProcTxDesc_20(struct ath_hal *ah, struct ath_tx_desc *gds)
{
  905ff4:	6c1004        	entry	a1, 32
        struct ar5416_desc *ads = AR5416DESC(gds);
        struct ath_tx_desc *ds = (struct ath_tx_desc *)gds;
        
        if ((ads->ds_txstatus9 & AR_TxDone) == 0)
  905ff7:	2a305c        	l8ui	a10, a3, 92
  905ffa:	28305d        	l8ui	a8, a3, 93
  905ffd:	29305e        	l8ui	a9, a3, 94
  906000:	08aa10        	slli	a10, a10, 24
  906003:	008811        	slli	a8, a8, 16
  906006:	0a8802        	or	a8, a8, a10
  906009:	089911        	slli	a9, a9, 8
  90600c:	089902        	or	a9, a9, a8
  90600f:	28305f        	l8ui	a8, a3, 95
  906012:	098902        	or	a9, a8, a9
                return HAL_EINPROGRESS;
  906015:	c08f      	movi.n	a8, 15
HAL_STATUS ar5416ProcTxDesc_20(struct ath_hal *ah, struct ath_tx_desc *gds)
{
        struct ar5416_desc *ads = AR5416DESC(gds);
        struct ath_tx_desc *ds = (struct ath_tx_desc *)gds;
        
        if ((ads->ds_txstatus9 & AR_TxDone) == 0)
  906017:	7f9f02        	bbsi	a9, 31, 90601d <ar5416ProcTxDesc_20+0x29>
  90601a:	60029b        	j	9062b9 <ar5416ProcTxDesc_20+0x2c5>
                return HAL_EINPROGRESS;

        ads->ds_txstatus9 &= ~AR_TxDone;
  90601d:	c78e      	movi.n	a8, -2
  90601f:	089801        	and	a8, a9, a8
  906022:	088b57        	extui	a11, a8, 24, 8
  906025:	2b345c        	s8i	a11, a3, 92
  906028:	080b57        	extui	a11, a8, 16, 8
  90602b:	2b345d        	s8i	a11, a3, 93
  90602e:	28345f        	s8i	a8, a3, 95
  906031:	088b47        	extui	a11, a8, 8, 8

        /* Update software copies of the HW status */
        ds->ds_txstat.ts_seqnum = MS(ads->ds_txstatus9, AR_SeqNum);
  906034:	09184b        	extui	a8, a9, 1, 12
        struct ath_tx_desc *ds = (struct ath_tx_desc *)gds;
        
        if ((ads->ds_txstatus9 & AR_TxDone) == 0)
                return HAL_EINPROGRESS;

        ads->ds_txstatus9 &= ~AR_TxDone;
  906037:	2b345e        	s8i	a11, a3, 94

        /* Update software copies of the HW status */
        ds->ds_txstat.ts_seqnum = MS(ads->ds_txstatus9, AR_SeqNum);
  90603a:	088b14        	srli	a11, a8, 8
  90603d:	2b3464        	s8i	a11, a3, 100
        ds->ds_txstat.ts_tstamp = ads->AR_SendTimestamp;
  906040:	2c3040        	l8ui	a12, a3, 64
  906043:	2b3041        	l8ui	a11, a3, 65
                return HAL_EINPROGRESS;

        ads->ds_txstatus9 &= ~AR_TxDone;

        /* Update software copies of the HW status */
        ds->ds_txstat.ts_seqnum = MS(ads->ds_txstatus9, AR_SeqNum);
  906046:	283465        	s8i	a8, a3, 101
        ds->ds_txstat.ts_tstamp = ads->AR_SendTimestamp;
  906049:	283042        	l8ui	a8, a3, 66
  90604c:	08cc10        	slli	a12, a12, 24
  90604f:	00bb11        	slli	a11, a11, 16
  906052:	0cbb02        	or	a11, a11, a12
  906055:	088811        	slli	a8, a8, 8
  906058:	0b8802        	or	a8, a8, a11
  90605b:	2b3043        	l8ui	a11, a3, 67
        struct ath_tx_desc *ds = (struct ath_tx_desc *)gds;
        
        if ((ads->ds_txstatus9 & AR_TxDone) == 0)
                return HAL_EINPROGRESS;

        ads->ds_txstatus9 &= ~AR_TxDone;
  90605e:	c0a0      	movi.n	a10, 0

        /* Update software copies of the HW status */
        ds->ds_txstat.ts_seqnum = MS(ads->ds_txstatus9, AR_SeqNum);
        ds->ds_txstat.ts_tstamp = ads->AR_SendTimestamp;
  906060:	08b802        	or	a8, a11, a8
  906063:	088b57        	extui	a11, a8, 24, 8
  906066:	2b3460        	s8i	a11, a3, 96
  906069:	080b57        	extui	a11, a8, 16, 8
  90606c:	2b3461        	s8i	a11, a3, 97
  90606f:	088b47        	extui	a11, a8, 8, 8
  906072:	2b3462        	s8i	a11, a3, 98
        ds->ds_txstat.ts_status = 0;
  906075:	2a3466        	s8i	a10, a3, 102
        ds->ds_txstat.ts_flags  = 0;
  906078:	2a3467        	s8i	a10, a3, 103

        if (ads->ds_txstatus1 & AR_ExcessiveRetries)
  90607b:	2b303c        	l8ui	a11, a3, 60
  90607e:	2a303d        	l8ui	a10, a3, 61

        ads->ds_txstatus9 &= ~AR_TxDone;

        /* Update software copies of the HW status */
        ds->ds_txstat.ts_seqnum = MS(ads->ds_txstatus9, AR_SeqNum);
        ds->ds_txstat.ts_tstamp = ads->AR_SendTimestamp;
  906081:	283463        	s8i	a8, a3, 99
        ds->ds_txstat.ts_status = 0;
        ds->ds_txstat.ts_flags  = 0;

        if (ads->ds_txstatus1 & AR_ExcessiveRetries)
  906084:	28303e        	l8ui	a8, a3, 62
  906087:	08bb10        	slli	a11, a11, 24
  90608a:	00aa11        	slli	a10, a10, 16
  90608d:	0baa02        	or	a10, a10, a11
  906090:	088811        	slli	a8, a8, 8
  906093:	0a8802        	or	a8, a8, a10
  906096:	2a303f        	l8ui	a10, a3, 63
  906099:	08a802        	or	a8, a10, a8
  90609c:	7e8704        	bbci	a8, 30, 9060a4 <ar5416ProcTxDesc_20+0xb0>
                ds->ds_txstat.ts_status |= HAL_TXERR_XRETRY;
  90609f:	c0a1      	movi.n	a10, 1
  9060a1:	2a3466        	s8i	a10, a3, 102
        if (ads->ds_txstatus1 & AR_Filtered)
  9060a4:	7c870a        	bbci	a8, 28, 9060b2 <ar5416ProcTxDesc_20+0xbe>
                ds->ds_txstat.ts_status |= HAL_TXERR_FILT;
  9060a7:	2b3066        	l8ui	a11, a3, 102
  9060aa:	c0a2      	movi.n	a10, 2
  9060ac:	0aba02        	or	a10, a11, a10
  9060af:	2a3466        	s8i	a10, a3, 102
        if (ads->ds_txstatus1 & AR_FIFOUnderrun)
  9060b2:	c0a4      	movi.n	a10, 4
  9060b4:	7a8008        	bnone	a8, a10, 9060c0 <ar5416ProcTxDesc_20+0xcc>
                ds->ds_txstat.ts_status |= HAL_TXERR_FIFO;
  9060b7:	2b3066        	l8ui	a11, a3, 102
  9060ba:	0aba02        	or	a10, a11, a10
  9060bd:	2a3466        	s8i	a10, a3, 102
        if (ads->ds_txstatus9 & AR_TxOpExceeded)
  9060c0:	7e960a        	bbci	a9, 14, 9060ce <ar5416ProcTxDesc_20+0xda>
		ds->ds_txstat.ts_status |= HAL_TXERR_XTXOP;
  9060c3:	2a3066        	l8ui	a10, a3, 102
  9060c6:	c098      	movi.n	a9, 8
  9060c8:	09a902        	or	a9, a10, a9
  9060cb:	293466        	s8i	a9, a3, 102
        if (ads->ds_txstatus1 & AR_TxTimerExpired)
  9060ce:	7c860a        	bbci	a8, 12, 9060dc <ar5416ProcTxDesc_20+0xe8>
		ds->ds_txstat.ts_status |= HAL_TXERR_TIMER_EXPIRED;
  9060d1:	2a3066        	l8ui	a10, a3, 102
  9060d4:	c190      	movi.n	a9, 16
  9060d6:	09a902        	or	a9, a10, a9
  9060d9:	293466        	s8i	a9, a3, 102

        if (ads->ds_txstatus1 & AR_DescCfgErr)
  9060dc:	7d8604        	bbci	a8, 13, 9060e4 <ar5416ProcTxDesc_20+0xf0>
		ds->ds_txstat.ts_flags |= HAL_TX_DESC_CFG_ERR;
  9060df:	c094      	movi.n	a9, 4
  9060e1:	293467        	s8i	a9, a3, 103
        if (ads->ds_txstatus1 & AR_TxDataUnderrun) {
  9060e4:	7e8611        	bbci	a8, 14, 9060f9 <ar5416ProcTxDesc_20+0x105>
		ds->ds_txstat.ts_flags |= HAL_TX_DATA_UNDERRUN;
  9060e7:	293067        	l8ui	a9, a3, 103
  9060ea:	c088      	movi.n	a8, 8
  9060ec:	089802        	or	a8, a9, a8
  9060ef:	283467        	s8i	a8, a3, 103
		ar5416UpdateTxTrigLevel(ah, AH_TRUE);
  9060f2:	da20      	mov.n	a10, a2
  9060f4:	c0b1      	movi.n	a11, 1
  9060f6:	5bfca4        	call8	905388 <ar5416UpdateTxTrigLevel>
	}
        if (ads->ds_txstatus1 & AR_TxDelimUnderrun) {
  9060f9:	28303d        	l8ui	a8, a3, 61
  9060fc:	7f8711        	bbci	a8, 31, 906111 <ar5416ProcTxDesc_20+0x11d>
		ds->ds_txstat.ts_flags |= HAL_TX_DELIM_UNDERRUN;
  9060ff:	293067        	l8ui	a9, a3, 103
  906102:	c180      	movi.n	a8, 16
  906104:	089802        	or	a8, a9, a8
  906107:	283467        	s8i	a8, a3, 103
		ar5416UpdateTxTrigLevel(ah, AH_TRUE);
  90610a:	da20      	mov.n	a10, a2
  90610c:	c0b1      	movi.n	a11, 1
  90610e:	5bfc9e        	call8	905388 <ar5416UpdateTxTrigLevel>
	}
        if (ads->ds_txstatus0 & AR_TxBaStatus) {
  906111:	283038        	l8ui	a8, a3, 56
  906114:	223039        	l8ui	a2, a3, 57
  906117:	29303a        	l8ui	a9, a3, 58
  90611a:	088810        	slli	a8, a8, 24
  90611d:	002211        	slli	a2, a2, 16
  906120:	082202        	or	a2, a2, a8
  906123:	089911        	slli	a9, a9, 8
  906126:	029902        	or	a9, a9, a2
  906129:	22303b        	l8ui	a2, a3, 59
  90612c:	092902        	or	a9, a2, a9
  90612f:	719671        	bbci	a9, 1, 9061a4 <ar5416ProcTxDesc_20+0x1b0>
		ds->ds_txstat.ts_flags |= HAL_TX_BA;
  906132:	283067        	l8ui	a8, a3, 103
  906135:	220a01        	movi	a2, 1
  906138:	028202        	or	a2, a8, a2
  90613b:	223467        	s8i	a2, a3, 103
		ds->ds_txstat.ba_low = ads->AR_BaBitmapLow;
  90613e:	2a3044        	l8ui	a10, a3, 68
  906141:	223045        	l8ui	a2, a3, 69
  906144:	283046        	l8ui	a8, a3, 70
  906147:	08aa10        	slli	a10, a10, 24
  90614a:	002211        	slli	a2, a2, 16
  90614d:	0a2202        	or	a2, a2, a10
  906150:	088811        	slli	a8, a8, 8
  906153:	028802        	or	a8, a8, a2
  906156:	223047        	l8ui	a2, a3, 71
		ds->ds_txstat.ba_high = ads->AR_BaBitmapHigh;
  906159:	2a3048        	l8ui	a10, a3, 72
		ds->ds_txstat.ts_flags |= HAL_TX_DELIM_UNDERRUN;
		ar5416UpdateTxTrigLevel(ah, AH_TRUE);
	}
        if (ads->ds_txstatus0 & AR_TxBaStatus) {
		ds->ds_txstat.ts_flags |= HAL_TX_BA;
		ds->ds_txstat.ba_low = ads->AR_BaBitmapLow;
  90615c:	082802        	or	a8, a2, a8
  90615f:	088257        	extui	a2, a8, 24, 8
  906162:	223474        	s8i	a2, a3, 116
  906165:	080257        	extui	a2, a8, 16, 8
  906168:	223475        	s8i	a2, a3, 117
  90616b:	088247        	extui	a2, a8, 8, 8
  90616e:	223476        	s8i	a2, a3, 118
		ds->ds_txstat.ba_high = ads->AR_BaBitmapHigh;
  906171:	223049        	l8ui	a2, a3, 73
		ds->ds_txstat.ts_flags |= HAL_TX_DELIM_UNDERRUN;
		ar5416UpdateTxTrigLevel(ah, AH_TRUE);
	}
        if (ads->ds_txstatus0 & AR_TxBaStatus) {
		ds->ds_txstat.ts_flags |= HAL_TX_BA;
		ds->ds_txstat.ba_low = ads->AR_BaBitmapLow;
  906174:	283477        	s8i	a8, a3, 119
		ds->ds_txstat.ba_high = ads->AR_BaBitmapHigh;
  906177:	28304a        	l8ui	a8, a3, 74
  90617a:	08aa10        	slli	a10, a10, 24
  90617d:	002211        	slli	a2, a2, 16
  906180:	0a2202        	or	a2, a2, a10
  906183:	088811        	slli	a8, a8, 8
  906186:	028802        	or	a8, a8, a2
  906189:	22304b        	l8ui	a2, a3, 75
  90618c:	082802        	or	a8, a2, a8
  90618f:	088257        	extui	a2, a8, 24, 8
  906192:	223478        	s8i	a2, a3, 120
  906195:	080257        	extui	a2, a8, 16, 8
  906198:	223479        	s8i	a2, a3, 121
  90619b:	088247        	extui	a2, a8, 8, 8
  90619e:	22347a        	s8i	a2, a3, 122
  9061a1:	28347b        	s8i	a8, a3, 123

        /*
         * Extract the transmit rate used and mark the rate as
         * ``alternate'' if it wasn't the series 0 rate.
         */
        ds->ds_txstat.ts_rate = MS(ads->ds_txstatus9, AR_FinalTxIdx);
  9061a4:	28305c        	l8ui	a8, a3, 92
  9061a7:	22305d        	l8ui	a2, a3, 93
  9061aa:	088810        	slli	a8, a8, 24
  9061ad:	002211        	slli	a2, a2, 16
  9061b0:	082202        	or	a2, a2, a8
  9061b3:	187273        	l32r	a8, 8e2b80 <_HIFusb_isr_handler+0x28>
        ds->ds_txstat.ts_rssi_combined = 
		MS(ads->ds_txstatus5, AR_TxRSSICombined);
  9061b6:	2a304c        	l8ui	a10, a3, 76

        /*
         * Extract the transmit rate used and mark the rate as
         * ``alternate'' if it wasn't the series 0 rate.
         */
        ds->ds_txstat.ts_rate = MS(ads->ds_txstatus9, AR_FinalTxIdx);
  9061b9:	082201        	and	a2, a2, a8
  9061bc:	02525a        	extui	a2, a2, 21, 11
  9061bf:	223468        	s8i	a2, a3, 104
        ds->ds_txstat.ts_rssi_combined = 
		MS(ads->ds_txstatus5, AR_TxRSSICombined);
  9061c2:	22304d        	l8ui	a2, a3, 77
  9061c5:	08aa10        	slli	a10, a10, 24
  9061c8:	28304e        	l8ui	a8, a3, 78
  9061cb:	002211        	slli	a2, a2, 16
  9061ce:	0a2202        	or	a2, a2, a10
        ds->ds_txstat.ts_rssi_ctl0 = MS(ads->ds_txstatus0, AR_TxRSSIAnt00);
        ds->ds_txstat.ts_rssi_ctl1 = MS(ads->ds_txstatus0, AR_TxRSSIAnt01);
  9061d1:	098a47        	extui	a10, a9, 8, 8
  9061d4:	2a346b        	s8i	a10, a3, 107
         * Extract the transmit rate used and mark the rate as
         * ``alternate'' if it wasn't the series 0 rate.
         */
        ds->ds_txstat.ts_rate = MS(ads->ds_txstatus9, AR_FinalTxIdx);
        ds->ds_txstat.ts_rssi_combined = 
		MS(ads->ds_txstatus5, AR_TxRSSICombined);
  9061d7:	088811        	slli	a8, a8, 8
        ds->ds_txstat.ts_rssi_ctl0 = MS(ads->ds_txstatus0, AR_TxRSSIAnt00);
        ds->ds_txstat.ts_rssi_ctl1 = MS(ads->ds_txstatus0, AR_TxRSSIAnt01);
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
  9061da:	1a7254        	l32r	a10, 8e2b2c <athos_indirection_table_install+0x15e4>
         * Extract the transmit rate used and mark the rate as
         * ``alternate'' if it wasn't the series 0 rate.
         */
        ds->ds_txstat.ts_rate = MS(ads->ds_txstatus9, AR_FinalTxIdx);
        ds->ds_txstat.ts_rssi_combined = 
		MS(ads->ds_txstatus5, AR_TxRSSICombined);
  9061dd:	028802        	or	a8, a8, a2
  9061e0:	22304f        	l8ui	a2, a3, 79
        ds->ds_txstat.ts_rssi_ctl0 = MS(ads->ds_txstatus0, AR_TxRSSIAnt00);
  9061e3:	29346a        	s8i	a9, a3, 106
        ds->ds_txstat.ts_rssi_ctl1 = MS(ads->ds_txstatus0, AR_TxRSSIAnt01);
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
  9061e6:	0a9901        	and	a9, a9, a10
         * Extract the transmit rate used and mark the rate as
         * ``alternate'' if it wasn't the series 0 rate.
         */
        ds->ds_txstat.ts_rate = MS(ads->ds_txstatus9, AR_FinalTxIdx);
        ds->ds_txstat.ts_rssi_combined = 
		MS(ads->ds_txstatus5, AR_TxRSSICombined);
  9061e9:	082802        	or	a8, a2, a8
        ds->ds_txstat.ts_rssi_ctl0 = MS(ads->ds_txstatus0, AR_TxRSSIAnt00);
        ds->ds_txstat.ts_rssi_ctl1 = MS(ads->ds_txstatus0, AR_TxRSSIAnt01);
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
  9061ec:	09095f        	extui	a9, a9, 16, 16
         * Extract the transmit rate used and mark the rate as
         * ``alternate'' if it wasn't the series 0 rate.
         */
        ds->ds_txstat.ts_rate = MS(ads->ds_txstatus9, AR_FinalTxIdx);
        ds->ds_txstat.ts_rssi_combined = 
		MS(ads->ds_txstatus5, AR_TxRSSICombined);
  9061ef:	088257        	extui	a2, a8, 24, 8
        ds->ds_txstat.ts_rssi_ctl0 = MS(ads->ds_txstatus0, AR_TxRSSIAnt00);
        ds->ds_txstat.ts_rssi_ctl1 = MS(ads->ds_txstatus0, AR_TxRSSIAnt01);
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
  9061f2:	29346c        	s8i	a9, a3, 108
        ds->ds_txstat.ts_rssi_ext0 = MS(ads->ds_txstatus5, AR_TxRSSIAnt10);
        ds->ds_txstat.ts_rssi_ext1 = MS(ads->ds_txstatus5, AR_TxRSSIAnt11);
  9061f5:	088947        	extui	a9, a8, 8, 8
        /*
         * Extract the transmit rate used and mark the rate as
         * ``alternate'' if it wasn't the series 0 rate.
         */
        ds->ds_txstat.ts_rate = MS(ads->ds_txstatus9, AR_FinalTxIdx);
        ds->ds_txstat.ts_rssi_combined = 
  9061f8:	223469        	s8i	a2, a3, 105
		MS(ads->ds_txstatus5, AR_TxRSSICombined);
        ds->ds_txstat.ts_rssi_ctl0 = MS(ads->ds_txstatus0, AR_TxRSSIAnt00);
        ds->ds_txstat.ts_rssi_ctl1 = MS(ads->ds_txstatus0, AR_TxRSSIAnt01);
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
        ds->ds_txstat.ts_rssi_ext0 = MS(ads->ds_txstatus5, AR_TxRSSIAnt10);
        ds->ds_txstat.ts_rssi_ext1 = MS(ads->ds_txstatus5, AR_TxRSSIAnt11);
  9061fb:	29346e        	s8i	a9, a3, 110
        ds->ds_txstat.ts_rssi_ext2 = MS(ads->ds_txstatus5, AR_TxRSSIAnt12);
        ds->ds_txstat.evm0 = ads->AR_TxEVM0;
  9061fe:	22347c        	s8i	a2, a3, 124
        ds->ds_txstat.ts_rssi_ctl0 = MS(ads->ds_txstatus0, AR_TxRSSIAnt00);
        ds->ds_txstat.ts_rssi_ctl1 = MS(ads->ds_txstatus0, AR_TxRSSIAnt01);
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
        ds->ds_txstat.ts_rssi_ext0 = MS(ads->ds_txstatus5, AR_TxRSSIAnt10);
        ds->ds_txstat.ts_rssi_ext1 = MS(ads->ds_txstatus5, AR_TxRSSIAnt11);
        ds->ds_txstat.ts_rssi_ext2 = MS(ads->ds_txstatus5, AR_TxRSSIAnt12);
  906201:	080957        	extui	a9, a8, 16, 8
        ds->ds_txstat.evm0 = ads->AR_TxEVM0;
  906204:	088247        	extui	a2, a8, 8, 8
        ds->ds_txstat.ts_rssi_ctl0 = MS(ads->ds_txstatus0, AR_TxRSSIAnt00);
        ds->ds_txstat.ts_rssi_ctl1 = MS(ads->ds_txstatus0, AR_TxRSSIAnt01);
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
        ds->ds_txstat.ts_rssi_ext0 = MS(ads->ds_txstatus5, AR_TxRSSIAnt10);
        ds->ds_txstat.ts_rssi_ext1 = MS(ads->ds_txstatus5, AR_TxRSSIAnt11);
        ds->ds_txstat.ts_rssi_ext2 = MS(ads->ds_txstatus5, AR_TxRSSIAnt12);
  906207:	29346f        	s8i	a9, a3, 111
        ds->ds_txstat.evm0 = ads->AR_TxEVM0;
  90620a:	29347d        	s8i	a9, a3, 125
  90620d:	22347e        	s8i	a2, a3, 126
        ds->ds_txstat.evm1 = ads->AR_TxEVM1;
  906210:	293050        	l8ui	a9, a3, 80
  906213:	223051        	l8ui	a2, a3, 81
        ds->ds_txstat.ts_rssi_combined = 
		MS(ads->ds_txstatus5, AR_TxRSSICombined);
        ds->ds_txstat.ts_rssi_ctl0 = MS(ads->ds_txstatus0, AR_TxRSSIAnt00);
        ds->ds_txstat.ts_rssi_ctl1 = MS(ads->ds_txstatus0, AR_TxRSSIAnt01);
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
        ds->ds_txstat.ts_rssi_ext0 = MS(ads->ds_txstatus5, AR_TxRSSIAnt10);
  906216:	28346d        	s8i	a8, a3, 109
        ds->ds_txstat.ts_rssi_ext1 = MS(ads->ds_txstatus5, AR_TxRSSIAnt11);
        ds->ds_txstat.ts_rssi_ext2 = MS(ads->ds_txstatus5, AR_TxRSSIAnt12);
        ds->ds_txstat.evm0 = ads->AR_TxEVM0;
  906219:	28347f        	s8i	a8, a3, 127
        ds->ds_txstat.evm1 = ads->AR_TxEVM1;
  90621c:	283052        	l8ui	a8, a3, 82
  90621f:	089910        	slli	a9, a9, 24
  906222:	002211        	slli	a2, a2, 16
  906225:	092202        	or	a2, a2, a9
  906228:	088811        	slli	a8, a8, 8
  90622b:	028802        	or	a8, a8, a2
  90622e:	223053        	l8ui	a2, a3, 83
        ds->ds_txstat.evm2 = ads->AR_TxEVM2;
  906231:	293054        	l8ui	a9, a3, 84
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
        ds->ds_txstat.ts_rssi_ext0 = MS(ads->ds_txstatus5, AR_TxRSSIAnt10);
        ds->ds_txstat.ts_rssi_ext1 = MS(ads->ds_txstatus5, AR_TxRSSIAnt11);
        ds->ds_txstat.ts_rssi_ext2 = MS(ads->ds_txstatus5, AR_TxRSSIAnt12);
        ds->ds_txstat.evm0 = ads->AR_TxEVM0;
        ds->ds_txstat.evm1 = ads->AR_TxEVM1;
  906234:	082802        	or	a8, a2, a8
  906237:	088257        	extui	a2, a8, 24, 8
  90623a:	223480        	s8i	a2, a3, 128
  90623d:	080257        	extui	a2, a8, 16, 8
  906240:	223481        	s8i	a2, a3, 129
  906243:	088247        	extui	a2, a8, 8, 8
  906246:	223482        	s8i	a2, a3, 130
        ds->ds_txstat.evm2 = ads->AR_TxEVM2;
  906249:	223055        	l8ui	a2, a3, 85
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
        ds->ds_txstat.ts_rssi_ext0 = MS(ads->ds_txstatus5, AR_TxRSSIAnt10);
        ds->ds_txstat.ts_rssi_ext1 = MS(ads->ds_txstatus5, AR_TxRSSIAnt11);
        ds->ds_txstat.ts_rssi_ext2 = MS(ads->ds_txstatus5, AR_TxRSSIAnt12);
        ds->ds_txstat.evm0 = ads->AR_TxEVM0;
        ds->ds_txstat.evm1 = ads->AR_TxEVM1;
  90624c:	283483        	s8i	a8, a3, 131
        ds->ds_txstat.evm2 = ads->AR_TxEVM2;
  90624f:	283056        	l8ui	a8, a3, 86
  906252:	089910        	slli	a9, a9, 24
  906255:	002211        	slli	a2, a2, 16
  906258:	092202        	or	a2, a2, a9
  90625b:	088811        	slli	a8, a8, 8
  90625e:	028802        	or	a8, a8, a2
  906261:	223057        	l8ui	a2, a3, 87
  906264:	082802        	or	a8, a2, a8
  906267:	088257        	extui	a2, a8, 24, 8
  90626a:	223484        	s8i	a2, a3, 132
  90626d:	080257        	extui	a2, a8, 16, 8
  906270:	223485        	s8i	a2, a3, 133
  906273:	088247        	extui	a2, a8, 8, 8
  906276:	223486        	s8i	a2, a3, 134
        ds->ds_txstat.ts_shortretry = MS(ads->ds_txstatus1, AR_RTSFailCnt);
  906279:	29303c        	l8ui	a9, a3, 60
  90627c:	22303d        	l8ui	a2, a3, 61
        ds->ds_txstat.ts_rssi_ext0 = MS(ads->ds_txstatus5, AR_TxRSSIAnt10);
        ds->ds_txstat.ts_rssi_ext1 = MS(ads->ds_txstatus5, AR_TxRSSIAnt11);
        ds->ds_txstat.ts_rssi_ext2 = MS(ads->ds_txstatus5, AR_TxRSSIAnt12);
        ds->ds_txstat.evm0 = ads->AR_TxEVM0;
        ds->ds_txstat.evm1 = ads->AR_TxEVM1;
        ds->ds_txstat.evm2 = ads->AR_TxEVM2;
  90627f:	283487        	s8i	a8, a3, 135
        ds->ds_txstat.ts_shortretry = MS(ads->ds_txstatus1, AR_RTSFailCnt);
  906282:	28303e        	l8ui	a8, a3, 62
  906285:	089910        	slli	a9, a9, 24
  906288:	002211        	slli	a2, a2, 16
  90628b:	092202        	or	a2, a2, a9
  90628e:	088811        	slli	a8, a8, 8
  906291:	028802        	or	a8, a8, a2
  906294:	22303f        	l8ui	a2, a3, 63
  906297:	082802        	or	a8, a2, a8
  90629a:	084243        	extui	a2, a8, 4, 4
  90629d:	223470        	s8i	a2, a3, 112
        ds->ds_txstat.ts_longretry = MS(ads->ds_txstatus1, AR_DataFailCnt);
  9062a0:	088243        	extui	a2, a8, 8, 4
  9062a3:	223471        	s8i	a2, a3, 113
        ds->ds_txstat.ts_virtcol = MS(ads->ds_txstatus1, AR_VirtRetryCnt);
  9062a6:	127274        	l32r	a2, 8e2c78 <hif_module_install+0xa4>
  9062a9:	028801        	and	a8, a8, a2
  9062ac:	08c814        	srli	a8, a8, 12
        ds->ds_txstat.ts_antenna = 0;		/* ignored for owl */
  9062af:	c020      	movi.n	a2, 0
        ds->ds_txstat.evm0 = ads->AR_TxEVM0;
        ds->ds_txstat.evm1 = ads->AR_TxEVM1;
        ds->ds_txstat.evm2 = ads->AR_TxEVM2;
        ds->ds_txstat.ts_shortretry = MS(ads->ds_txstatus1, AR_RTSFailCnt);
        ds->ds_txstat.ts_longretry = MS(ads->ds_txstatus1, AR_DataFailCnt);
        ds->ds_txstat.ts_virtcol = MS(ads->ds_txstatus1, AR_VirtRetryCnt);
  9062b1:	283472        	s8i	a8, a3, 114
        ds->ds_txstat.ts_antenna = 0;		/* ignored for owl */
  9062b4:	223473        	s8i	a2, a3, 115
  9062b7:	c080      	movi.n	a8, 0

        return HAL_OK;
}
  9062b9:	d280      	mov.n	a2, a8
  9062bb:	d10f      	retw.n
  9062bd:	000000        	ill

009062c0 <ar5416Attach>:
	ath_hal_free(ah);
}

struct ath_hal *
ar5416Attach(HAL_SOFTC sc, adf_os_device_t dev, HAL_STATUS *status)
{
  9062c0:	6c1004        	entry	a1, 32
	struct ath_hal_5416 *ahp;
	struct ath_hal *ah;

	ahp = ath_hal_malloc(sizeof (struct ath_hal_5416));
  9062c3:	2a1a30        	movi	a10, 0x130
  9062c6:	5bf647        	call8	903be4 <ath_hal_malloc>
	ath_hal_free(ah);
}

struct ath_hal *
ar5416Attach(HAL_SOFTC sc, adf_os_device_t dev, HAL_STATUS *status)
{
  9062c9:	d520      	mov.n	a5, a2
	struct ath_hal_5416 *ahp;
	struct ath_hal *ah;

	ahp = ath_hal_malloc(sizeof (struct ath_hal_5416));
  9062cb:	d2a0      	mov.n	a2, a10
	if (ahp == AH_NULL) {
  9062cd:	cca4      	bnez.n	a10, 9062d5 <ar5416Attach+0x15>
		*status = HAL_ENOMEM;
  9062cf:	c032      	movi.n	a3, 2
  9062d1:	9340      	s32i.n	a3, a4, 0
		return AH_NULL;
  9062d3:	d10f      	retw.n
	}
	ah = &ahp->ah_priv.h;

	OS_MEMCPY(&ahp->ah_priv, &ar5416hal_10, sizeof(struct ath_hal_private));
  9062d5:	1b7275        	l32r	a11, 8e2cac <hif_module_install+0xd8>
  9062d8:	2c0ad0        	movi	a12, 208
  9062db:	5bf64d        	call8	903c10 <ath_hal_memcpy>

	ah->ah_dev = dev;
  9062de:	9322      	s32i.n	a3, a2, 8
	ah->ah_sc = sc;

	ah->ah_set11nTxDesc        = ar5416Set11nTxDesc_20;
  9062e0:	137276        	l32r	a3, 8e2cb8 <hif_module_install+0xe4>
	ah = &ahp->ah_priv.h;

	OS_MEMCPY(&ahp->ah_priv, &ar5416hal_10, sizeof(struct ath_hal_private));

	ah->ah_dev = dev;
	ah->ah_sc = sc;
  9062e3:	9521      	s32i.n	a5, a2, 4

	ah->ah_set11nTxDesc        = ar5416Set11nTxDesc_20;
  9062e5:	932f      	s32i.n	a3, a2, 60
	ah->ah_set11nRateScenario  = ar5416Set11nRateScenario_20;
  9062e7:	137277        	l32r	a3, 8e2cc4 <hif_module_install+0xf0>
  9062ea:	232610        	s32i	a3, a2, 64
	ah->ah_set11nAggrFirst     = ar5416Set11nAggrFirst_20;
  9062ed:	137278        	l32r	a3, 8e2cd0 <hif_module_install+0xfc>
  9062f0:	232611        	s32i	a3, a2, 68
	ah->ah_set11nAggrMiddle    = ar5416Set11nAggrMiddle_20;
  9062f3:	137279        	l32r	a3, 8e2cd8 <hif_module_install+0x104>
  9062f6:	232612        	s32i	a3, a2, 72
	ah->ah_set11nAggrLast      = ar5416Set11nAggrLast_20;
  9062f9:	13727a        	l32r	a3, 8e2ce4 <hif_module_install+0x110>
  9062fc:	232613        	s32i	a3, a2, 76
	ah->ah_clr11nAggr          = ar5416Clr11nAggr_20;
  9062ff:	13727b        	l32r	a3, 8e2cec <hif_module_install+0x118>
  906302:	232614        	s32i	a3, a2, 80
	ah->ah_set11nBurstDuration = ar5416Set11nBurstDuration_20;
  906305:	13727c        	l32r	a3, 8e2cf8 <hif_module_install+0x124>
  906308:	232615        	s32i	a3, a2, 84
	ah->ah_setupRxDesc         = ar5416SetupRxDesc_20;
  90630b:	13727d        	l32r	a3, 8e2d00 <hif_module_install+0x12c>
  90630e:	232620        	s32i	a3, a2, 128
	ah->ah_procRxDescFast      = ar5416ProcRxDescFast_20;
  906311:	13727e        	l32r	a3, 8e2d0c <hif_module_install+0x138>
  906314:	232622        	s32i	a3, a2, 136
	ah->ah_setupTxDesc         = ar5416SetupTxDesc_20;
  906317:	13727f        	l32r	a3, 8e2d14 <hif_module_install+0x140>
  90631a:	232617        	s32i	a3, a2, 92
	ah->ah_fillTxDesc          = ar5416FillTxDesc_20;
  90631d:	137280        	l32r	a3, 8e2d20 <hif_module_install+0x14c>
  906320:	232618        	s32i	a3, a2, 96
	ah->ah_fillKeyTxDesc       = ar5416FillKeyTxDesc_20;
  906323:	137281        	l32r	a3, 8e2d28 <hif_module_install+0x154>
  906326:	232619        	s32i	a3, a2, 100
	ah->ah_procTxDesc          = ar5416ProcTxDesc_20;
  906329:	137282        	l32r	a3, 8e2d34 <hif_module_install+0x160>
  90632c:	23261a        	s32i	a3, a2, 104
	ah->ah_set11nVirtualMoreFrag = ar5416Set11nVirtualMoreFrag_20;
  90632f:	137283        	l32r	a3, 8e2d3c <hif_module_install+0x168>
  906332:	232616        	s32i	a3, a2, 88

	return ah;
}
  906335:	d10f      	retw.n
	...

00906338 <ar5416GetRateTable>:
#undef	HT
#undef	HT_HGI

const HAL_RATE_TABLE *
ar5416GetRateTable(struct ath_hal *ah, a_uint32_t mode)
{
  906338:	6c1004        	entry	a1, 32
  90633b:	187284        	l32r	a8, 8e2d4c <hif_module_install+0x178>
  90633e:	233dc0        	addmi	a3, a3, 0xffffc000
  906341:	c020      	movi.n	a2, 0
  906343:	038238        	moveqz	a2, a8, a3
	default:
		return AH_NULL;
	}

	return rt;
}
  906346:	d10f      	retw.n

00906348 <ath_pci_suspend>:
	adf_os_free_intr(sc->sc_dev);
}

static void
ath_pci_suspend(adf_drv_handle_t hdl, adf_os_pm_t pm)
{
  906348:	6c1004        	entry	a1, 32
  90634b:	d10f      	retw.n
  90634d:	000000        	ill

00906350 <ath_pci_resume>:
}

static void
ath_pci_resume(adf_drv_handle_t hdl)
{
  906350:	6c1004        	entry	a1, 32
  906353:	d10f      	retw.n
  906355:	000000        	ill

00906358 <ath_pci_remove>:
	return NULL;
}

static void
ath_pci_remove(adf_drv_handle_t hdl)
{
  906358:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = hdl;

	ath_detach((struct ath_softc_tgt *)hdl);
  90635b:	da20      	mov.n	a10, a2
  90635d:	5807d9        	call8	9082c4 <ath_detach>
}

static inline void
adf_os_free_intr(adf_os_device_t osdev)
{
    __adf_os_free_intr(osdev);
  906360:	2a2246        	l32i	a10, a2, 0x118
  906363:	58002b        	call8	906410 <__adf_os_free_intr>
  906366:	d10f      	retw.n

00906368 <init_ath_pci>:

static adf_drv_info_t ath_drv_info = adf_os_pci_set_drv_info(ath_pci_tgt,&ath_pci_id_table[0], ath_pci_probe, ath_pci_remove, ath_pci_suspend, ath_pci_resume);

a_int32_t
init_ath_pci(void)
{
  906368:	6c1004        	entry	a1, 32
 * @return status of operation
 */
static inline a_status_t 
adf_net_register_drv(adf_drv_info_t *drv)
{
    return(__adf_net_register_drv(drv));
  90636b:	1a7285        	l32r	a10, 8e2d80 <hif_module_install+0x1ac>
  90636e:	5812a2        	call8	90adf8 <__adf_net_register_drv>
	return adf_net_register_drv( &ath_drv_info );
}
  906371:	d2a0      	mov.n	a2, a10
  906373:	d10f      	retw.n
  906375:	000000        	ill

00906378 <ath_pci_probe>:
a_int32_t init_ath_pci(void);

static adf_drv_handle_t
ath_pci_probe(adf_os_resource_t *res,a_int32_t count, adf_os_attach_data_t *data,
	      adf_os_device_t osdev)
{
  906378:	6c1004        	entry	a1, 32
}

static inline int 
__adf_os_pci_config_write8(adf_os_device_t osdev, int offset, a_uint8_t val)
{
    wlan_pci_config_write(offset, val, 1);
  90637b:	c2b0      	movi.n	a11, 32
  90637d:	c0c1      	movi.n	a12, 1
  90637f:	c0ac      	movi.n	a10, 12
  906381:	5bf650        	call8	903cc4 <wlan_pci_config_write>
  906384:	2b0aa8        	movi	a11, 168
  906387:	2c0a01        	movi	a12, 1
  90638a:	2a0a0d        	movi	a10, 13
  90638d:	5bf64d        	call8	903cc4 <wlan_pci_config_write>
  906390:	167184        	l32r	a6, 8e29a0 <athos_indirection_table_install+0x1458>
  906393:	137286        	l32r	a3, 8e2dac <hif_module_install+0x1d8>
  906396:	226252        	l32i	a2, a6, 0x148
  906399:	c0a0      	movi.n	a10, 0
  90639b:	db30      	mov.n	a11, a3
  90639d:	0b2000        	callx8	a2
  9063a0:	d2a0      	mov.n	a2, a10
	adf_os_pci_config_write8(osdev, ATH_PCI_CACHE_LINE_SIZE, csz);
	adf_os_pci_config_write8(osdev, ATH_PCI_LATENCY_TIMER, 0xa8);

	sc = adf_os_mem_alloc(sizeof(struct ath_pci_softc));

	if (sc == NULL) {
  9063a2:	ccaa      	bnez.n	a10, 9063b0 <ath_pci_probe+0x38>
		adf_os_print("ath_pci: no memory for device state\n");
  9063a4:	236212        	l32i	a3, a6, 72
  9063a7:	1a7287        	l32r	a10, 8e2dc4 <hif_module_install+0x1f0>
  9063aa:	0b3000        	callx8	a3
  9063ad:	d10f      	retw.n
  9063af:	008864        	excw

/* set a memory buffer */
static inline void
__adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
{
	A_MEMSET(buf, b, size);
  9063b2:	dc30      	mov.n	a12, a3
  9063b4:	c0b0      	movi.n	a11, 0
  9063b6:	0b8000        	callx8	a8

	/*
	 * Mark the device as detached to avoid processing
	 * interrupts until setup is complete.
	 */
	sc->aps_sc.sc_invalid = 1;
  9063b9:	232d01        	addmi	a3, a2, 0x100
  9063bc:	293024        	l8ui	a9, a3, 36
  9063bf:	28fa80        	movi	a8, -128
  9063c2:	089802        	or	a8, a9, a8
  9063c5:	283424        	s8i	a8, a3, 36

	adf_os_print("ath_pci_probe %x\n",id->device);
  9063c8:	2b4201        	l32i	a11, a4, 4
  9063cb:	266212        	l32i	a6, a6, 72
  9063ce:	1a7288        	l32r	a10, 8e2df0 <hif_module_install+0x21c>
  9063d1:	0b6000        	callx8	a6

	if (ath_tgt_attach(id->device, &sc->aps_sc, osdev) != 0)
  9063d4:	8a41      	l32i.n	a10, a4, 4
  9063d6:	db20      	mov.n	a11, a2
  9063d8:	dc50      	mov.n	a12, a5
  9063da:	5806ad        	call8	907e90 <ath_tgt_attach>
  9063dd:	cda1      	bnez.n	a10, 9063f2 <ath_pci_probe+0x7a>
		goto bad3;

	/* ready to process interrupts */
	sc->aps_sc.sc_invalid = 0;
  9063df:	243024        	l8ui	a4, a3, 36
#include <adf_os_irq_pvt.h>

static inline int
adf_os_setup_intr(adf_os_device_t  osdev, adf_os_drv_intr fn)
{
    return __adf_os_setup_intr(osdev, fn);
  9063e2:	1b7289        	l32r	a11, 8e2e08 <hif_module_install+0x234>
  9063e5:	040446        	extui	a4, a4, 0, 7
  9063e8:	243424        	s8i	a4, a3, 36
  9063eb:	da50      	mov.n	a10, a5
  9063ed:	580005        	call8	906404 <__adf_os_setup_intr>
  9063f0:	d10f      	retw.n
	adf_os_setup_intr(osdev, ath_intr);
	return (adf_drv_handle_t)sc;
bad3:
bad2:
	return NULL;
  9063f2:	c020      	movi.n	a2, 0
}
  9063f4:	d10f      	retw.n
	...

009063f8 <exit_ath_pci>:
	return adf_net_register_drv( &ath_drv_info );
}

void
exit_ath_pci(void)
{
  9063f8:	6c1004        	entry	a1, 32
 * @see adf_net_register_drv()
 */
static inline void
adf_net_unregister_drv(a_uint8_t *drv_name)
{
    __adf_net_unregister_drv(drv_name);
  9063fb:	1a728a        	l32r	a10, 8e2e24 <hif_module_install+0x250>
  9063fe:	581281        	call8	90ae04 <__adf_net_unregister_drv>
  906401:	d10f      	retw.n
	...

00906404 <__adf_os_setup_intr>:
 * @return int
 */

int
__adf_os_setup_intr(__adf_os_device_t  osdev, adf_os_drv_intr fn)
{
  906404:	6c1004        	entry	a1, 32
    g_wlan_intr = fn;
  906407:	1871ef        	l32r	a8, 8e2bc4 <_HIFusb_isr_handler+0x6c>
    
    return 0;    
}
  90640a:	c020      	movi.n	a2, 0
 */

int
__adf_os_setup_intr(__adf_os_device_t  osdev, adf_os_drv_intr fn)
{
    g_wlan_intr = fn;
  90640c:	9380      	s32i.n	a3, a8, 0
    
    return 0;    
}
  90640e:	d10f      	retw.n

00906410 <__adf_os_free_intr>:
 * @param[in] dev
 * @param[in] sc
 */
void
__adf_os_free_intr(__adf_os_device_t osdev)
{
  906410:	6c1004        	entry	a1, 32
    g_wlan_intr = NULL;  
  906413:	1871ef        	l32r	a8, 8e2bd0 <_HIFusb_isr_handler+0x78>
  906416:	c090      	movi.n	a9, 0
  906418:	9980      	s32i.n	a9, a8, 0
  90641a:	d10f      	retw.n

0090641c <__adf_os_mem_alloc>:

#include "cmnos_api.h"
#include "Magpie_api.h"

static inline void *	__adf_os_mem_alloc(adf_os_size_t size)
{
  90641c:	6c1004        	entry	a1, 32
//    return (malloc(size,M_DEVBUF,M_DONTWAIT | M_ZERO));
    return A_ALLOCRAM(size);
  90641f:	187184        	l32r	a8, 8e2a30 <athos_indirection_table_install+0x14e8>
  906422:	db20      	mov.n	a11, a2
  906424:	288252        	l32i	a8, a8, 0x148
  906427:	c0a0      	movi.n	a10, 0
  906429:	0b8000        	callx8	a8
}
  90642c:	d2a0      	mov.n	a2, a10
  90642e:	d10f      	retw.n

00906430 <__adf_os_mem_copy>:
    //free(buf,M_DEVBUF);
}

/* move a memory buffer */
static inline void 		__adf_os_mem_copy(void *dst, const void *src, adf_os_size_t size)
{
  906430:	6c1004        	entry	a1, 32
    A_MEMCPY(dst,src,size);    
  906433:	187184        	l32r	a8, 8e2a44 <athos_indirection_table_install+0x14fc>
  906436:	da20      	mov.n	a10, a2
  906438:	8885      	l32i.n	a8, a8, 20
  90643a:	db30      	mov.n	a11, a3
  90643c:	dc40      	mov.n	a12, a4
  90643e:	0b8000        	callx8	a8
  906441:	d10f      	retw.n
	...

00906444 <__adf_os_mem_set>:
}

/* set a memory buffer */
static inline void
__adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
{
  906444:	6c1004        	entry	a1, 32
	A_MEMSET(buf, b, size);
  906447:	187184        	l32r	a8, 8e2a58 <athos_indirection_table_install+0x1510>
  90644a:	da20      	mov.n	a10, a2
  90644c:	8884      	l32i.n	a8, a8, 16
  90644e:	db30      	mov.n	a11, a3
  906450:	dc40      	mov.n	a12, a4
  906452:	0b8000        	callx8	a8
  906455:	d10f      	retw.n
	...

00906458 <tgt_HTCRecv_uapsdhandler>:
	ath_tgt_send_beacon(sc, hdr_buf, buf, EndPt);
}

static void tgt_HTCRecv_uapsdhandler(HTC_ENDPOINT_ID EndPt, adf_nbuf_t hdr_buf,
				     adf_nbuf_t buf, void *ServiceCtx)
{
  906458:	6c1004        	entry	a1, 32
  90645b:	d10f      	retw.n
  90645d:	000000        	ill

00906460 <dispatch_magpie_sys_cmds>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void dispatch_magpie_sys_cmds(void *pContext, A_UINT16 Command,
				     A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
  906460:	6c1004        	entry	a1, 32
  906463:	63fffc        	j	906463 <dispatch_magpie_sys_cmds+0x3>
	...

00906468 <htc_setup_comp>:
/*****************/
/* Init / Deinit */
/*****************/

static void htc_setup_comp(void)
{
  906468:	6c1004        	entry	a1, 32
  90646b:	d10f      	retw.n
  90646d:	000000        	ill

00906470 <tgt_ServiceConnect>:
				  HTC_ENDPOINT_ID eid,
				  A_UINT8 *pDataIn,
				  a_int32_t LengthIn,
				  A_UINT8 *pDataOut,
				  a_int32_t *pLengthOut)
{
  906470:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)pService->ServiceCtx;
  906473:	8826      	l32i.n	a8, a2, 24

	switch(pService->ServiceID) {
  906475:	222108        	l16ui	a2, a2, 16
  906478:	c098      	movi.n	a9, 8
  90647a:	222dff        	addmi	a2, a2, 0xffffff00
  90647d:	02024f        	extui	a2, a2, 0, 16
  906480:	729340        	bltu	a9, a2, 9064c4 <tgt_ServiceConnect+0x54>
  906483:	19728b        	l32r	a9, 8e2eb0 <hif_module_install+0x2dc>
  906486:	09220a        	addx4	a2, a2, a9
  906489:	8220      	l32i.n	a2, a2, 0
  90648b:	0a2000        	jx	a2
	case WMI_CONTROL_SVC:
		sc->wmi_command_ep= eid;
  90648e:	23863c        	s32i	a3, a8, 240
		break;
  906491:	600032        	j	9064c7 <tgt_ServiceConnect+0x57>
	case WMI_BEACON_SVC:
		sc->beacon_ep= eid;
  906494:	23863d        	s32i	a3, a8, 244
		break;
  906497:	60002c        	j	9064c7 <tgt_ServiceConnect+0x57>
	case WMI_CAB_SVC:
		sc->cab_ep= eid;
  90649a:	23863e        	s32i	a3, a8, 248
		break;
  90649d:	600026        	j	9064c7 <tgt_ServiceConnect+0x57>
	case WMI_UAPSD_SVC:
		sc->uapsd_ep= eid;
  9064a0:	23863f        	s32i	a3, a8, 252
		break;
  9064a3:	600020        	j	9064c7 <tgt_ServiceConnect+0x57>
	case WMI_MGMT_SVC:
		sc->mgmt_ep= eid;
  9064a6:	238640        	s32i	a3, a8, 0x100
		break;
  9064a9:	60001a        	j	9064c7 <tgt_ServiceConnect+0x57>
	case WMI_DATA_VO_SVC:
		sc->data_VO_ep = eid;
  9064ac:	238641        	s32i	a3, a8, 0x104
		break;
  9064af:	600014        	j	9064c7 <tgt_ServiceConnect+0x57>
	case WMI_DATA_VI_SVC:
		sc->data_VI_ep = eid;
  9064b2:	238642        	s32i	a3, a8, 0x108
		break;
  9064b5:	60000e        	j	9064c7 <tgt_ServiceConnect+0x57>
	case WMI_DATA_BE_SVC:
		sc->data_BE_ep = eid;
  9064b8:	238643        	s32i	a3, a8, 0x10c
		break;
  9064bb:	600008        	j	9064c7 <tgt_ServiceConnect+0x57>
	case WMI_DATA_BK_SVC:
		sc->data_BK_ep = eid;
  9064be:	238644        	s32i	a3, a8, 0x110
		break;
  9064c1:	600002        	j	9064c7 <tgt_ServiceConnect+0x57>
  9064c4:	63fffc        	j	9064c4 <tgt_ServiceConnect+0x54>
	default:
		adf_os_assert(0);
	}

	return HTC_SERVICE_SUCCESS;
}
  9064c7:	c020      	movi.n	a2, 0
  9064c9:	d10f      	retw.n
	...

009064cc <tgt_reg_service>:

static void tgt_reg_service(struct ath_softc_tgt *sc, HTC_SERVICE *svc,
			    int svcId, HTC_SERVICE_ProcessRecvMsg recvMsg)
{
  9064cc:	6c1004        	entry	a1, 32
	svc->ProcessRecvMsg = recvMsg;
	svc->ProcessSendBufferComplete = tgt_HTCSendCompleteHandler;
  9064cf:	18728c        	l32r	a8, 8e2f00 <bGet_descriptor+0x3c>
	svc->ProcessConnect = tgt_ServiceConnect;
	svc->MaxSvcMsgSize = 1600;
	svc->TrailerSpcCheckLimit = 0;
	svc->ServiceID = svcId;
	svc->ServiceCtx = sc;
	HTC_RegisterService(sc->tgt_htc_handle, svc);
  9064d2:	8a22      	l32i.n	a10, a2, 8

static void tgt_reg_service(struct ath_softc_tgt *sc, HTC_SERVICE *svc,
			    int svcId, HTC_SERVICE_ProcessRecvMsg recvMsg)
{
	svc->ProcessRecvMsg = recvMsg;
	svc->ProcessSendBufferComplete = tgt_HTCSendCompleteHandler;
  9064d4:	9832      	s32i.n	a8, a3, 8
	svc->ProcessConnect = tgt_ServiceConnect;
  9064d6:	18728d        	l32r	a8, 8e2f0c <bGet_descriptor+0x48>
	return HTC_SERVICE_SUCCESS;
}

static void tgt_reg_service(struct ath_softc_tgt *sc, HTC_SERVICE *svc,
			    int svcId, HTC_SERVICE_ProcessRecvMsg recvMsg)
{
  9064d9:	db30      	mov.n	a11, a3
	svc->ProcessRecvMsg = recvMsg;
	svc->ProcessSendBufferComplete = tgt_HTCSendCompleteHandler;
	svc->ProcessConnect = tgt_ServiceConnect;
  9064db:	9833      	s32i.n	a8, a3, 12
	svc->MaxSvcMsgSize = 1600;
  9064dd:	286a40        	movi	a8, 0x640
  9064e0:	28350a        	s16i	a8, a3, 20
	svc->TrailerSpcCheckLimit = 0;
  9064e3:	c080      	movi.n	a8, 0
  9064e5:	28350b        	s16i	a8, a3, 22
	svc->ServiceID = svcId;
	svc->ServiceCtx = sc;
	HTC_RegisterService(sc->tgt_htc_handle, svc);
  9064e8:	187184        	l32r	a8, 8e2af8 <athos_indirection_table_install+0x15b0>
}

static void tgt_reg_service(struct ath_softc_tgt *sc, HTC_SERVICE *svc,
			    int svcId, HTC_SERVICE_ProcessRecvMsg recvMsg)
{
	svc->ProcessRecvMsg = recvMsg;
  9064eb:	9531      	s32i.n	a5, a3, 4
	svc->ProcessConnect = tgt_ServiceConnect;
	svc->MaxSvcMsgSize = 1600;
	svc->TrailerSpcCheckLimit = 0;
	svc->ServiceID = svcId;
	svc->ServiceCtx = sc;
	HTC_RegisterService(sc->tgt_htc_handle, svc);
  9064ed:	288285        	l32i	a8, a8, 0x214
	svc->ProcessRecvMsg = recvMsg;
	svc->ProcessSendBufferComplete = tgt_HTCSendCompleteHandler;
	svc->ProcessConnect = tgt_ServiceConnect;
	svc->MaxSvcMsgSize = 1600;
	svc->TrailerSpcCheckLimit = 0;
	svc->ServiceID = svcId;
  9064f0:	243508        	s16i	a4, a3, 16
	svc->ServiceCtx = sc;
  9064f3:	9236      	s32i.n	a2, a3, 24
	HTC_RegisterService(sc->tgt_htc_handle, svc);
  9064f5:	0b8000        	callx8	a8
  9064f8:	d10f      	retw.n
	...

009064fc <tgt_HTCRecv_mgmthandler>:
{
}

static void tgt_HTCRecv_mgmthandler(HTC_ENDPOINT_ID EndPt, adf_nbuf_t hdr_buf,
				    adf_nbuf_t buf, void *ServiceCtx)
{
  9064fc:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)ServiceCtx;

	ath_tgt_send_mgt(sc,hdr_buf,buf,EndPt);
  9064ff:	da50      	mov.n	a10, a5
  906501:	db30      	mov.n	a11, a3
  906503:	dc40      	mov.n	a12, a4
  906505:	dd20      	mov.n	a13, a2
  906507:	580e3f        	call8	909e04 <ath_tgt_send_mgt>
  90650a:	d10f      	retw.n

0090650c <ath_tgt_rx_tasklet>:

	return 0;
}

static void ath_tgt_rx_tasklet(TQUEUE_ARG data)
{
  90650c:	6c1006        	entry	a1, 48
	struct ath_softc_tgt *sc  = (struct ath_softc_tgt *)data;
	struct ath_rx_buf *bf = NULL;
	struct ath_hal *ah = sc->sc_ah;
  90650f:	232d05        	addmi	a3, a2, 0x500
  906512:	863b      	l32i.n	a6, a3, 44
			continue;
		}

		asf_tailq_remove(&sc->sc_rxbuf, bf, bf_list);

		bf->bf_skb = NULL;
  906514:	c070      	movi.n	a7, 0
	struct rx_frame_header *rxhdr;
	struct ath_rx_status *rxstats;
	adf_nbuf_t skb = ADF_NBUF_NULL;

	do {
		bf = asf_tailq_first(&sc->sc_rxbuf);
  906516:	2322d5        	l32i	a3, a2, 0x354
		if (bf == NULL) {
  906519:	643090        	beqz	a3, 9065ad <ath_tgt_rx_tasklet+0xa1>
			break;
		}

		if (!(bf->bf_status & ATH_BUFSTATUS_DONE)) {
  90651c:	843f      	l32i.n	a4, a3, 60
  90651e:	7f4f02        	bbsi	a4, 31, 906524 <ath_tgt_rx_tasklet+0x18>
  906521:	600088        	j	9065ad <ath_tgt_rx_tasklet+0xa1>
			break;
		}

		skb = bf->bf_skb;
  906524:	8538      	l32i.n	a5, a3, 32
		if (skb == NULL) {
  906526:	645ff2        	beqz	a5, 90651c <ath_tgt_rx_tasklet+0x10>
			continue;
		}

		asf_tailq_remove(&sc->sc_rxbuf, bf, bf_list);
  906529:	8439      	l32i.n	a4, a3, 36
  90652b:	883a      	l32i.n	a8, a3, 40
  90652d:	c843      	beqz.n	a4, 906534 <ath_tgt_rx_tasklet+0x28>
  90652f:	984a      	s32i.n	a8, a4, 40
  906531:	600002        	j	906537 <ath_tgt_rx_tasklet+0x2b>
  906534:	2826d6        	s32i	a8, a2, 0x358
  906537:	883a      	l32i.n	a8, a3, 40
  906539:	c2b8      	movi.n	a11, 40
  90653b:	9480      	s32i.n	a4, a8, 0

		bf->bf_skb = NULL;
  90653d:	273608        	s32i	a7, a3, 32
  906540:	055a02        	or	a10, a5, a5
  906543:	5bf3a4        	call8	9033d4 <__adf_nbuf_push_head>
 * @param[in] size    buffer size
 */
static inline void
adf_os_mem_copy(void *dst, const void *src, adf_os_size_t size)
{
    __adf_os_mem_copy(dst, src, size);
  906546:	c2c8      	movi.n	a12, 40
  906548:	2b3c40        	addi	a11, a3, 64
  90654b:	0aa402        	or	a4, a10, a10
  90654e:	5bffb8        	call8	906430 <__adf_os_mem_copy>
 * extend(0x00000012fffffffc, 0xfffffffa) == 0x00000012fffffffa
 * extend(0x00000012fffffffc, 0x00000002) == 0x0000001300000002  ! tsfhigh++
 */
static u_int64_t ath_extend_tsf(struct ath_softc_tgt *sc, u_int32_t rstamp)
{
	struct ath_hal *ah = sc->sc_ah;
  906551:	292d05        	addmi	a9, a2, 0x500
  906554:	8a9b      	l32i.n	a10, a9, 44
						     sizeof(struct rx_frame_header));
		rxstats = (struct ath_rx_status *)(&rxhdr->rx_stats[0]);
		adf_os_mem_copy(rxstats, &(bf->bf_rx_status),
				sizeof(struct ath_rx_status));

		rxstats->rs_tstamp = ath_extend_tsf(sc, (u_int32_t)rxstats->rs_tstamp);
  906556:	8841      	l32i.n	a8, a4, 4
	struct ath_hal *ah = sc->sc_ah;
	u_int64_t tsf;
	u_int32_t tsf_low;
	a_int64_t tsf_delta;  /* signed int64 */

	tsf = ah->ah_getTsf64(ah);
  906558:	29a21e        	l32i	a9, a10, 120
  90655b:	9810      	s32i.n	a8, a1, 0
  90655d:	0b9000        	callx8	a9
	tsf_low = tsf & 0xffffffffUL;

	tsf_delta = (a_int32_t)((rstamp - tsf_low) & 0xffffffffUL);
  906560:	8810      	l32i.n	a8, a1, 0

	return (tsf + (u_int64_t)tsf_delta);
  906562:	c091      	movi.n	a9, 1
	a_int64_t tsf_delta;  /* signed int64 */

	tsf = ah->ah_getTsf64(ah);
	tsf_low = tsf & 0xffffffffUL;

	tsf_delta = (a_int32_t)((rstamp - tsf_low) & 0xffffffffUL);
  906564:	0b880c        	sub	a8, a8, a11

	return (tsf + (u_int64_t)tsf_delta);
  906567:	ab8b      	add.n	a11, a8, a11
  906569:	08fc13        	srai	a12, a8, 31
  90656c:	78b301        	bltu	a11, a8, 906571 <ath_tgt_rx_tasklet+0x65>
  90656f:	c090      	movi.n	a9, 0
  906571:	aaca      	add.n	a10, a12, a10
  906573:	aa99      	add.n	a9, a9, a10
						     sizeof(struct rx_frame_header));
		rxstats = (struct ath_rx_status *)(&rxhdr->rx_stats[0]);
		adf_os_mem_copy(rxstats, &(bf->bf_rx_status),
				sizeof(struct ath_rx_status));

		rxstats->rs_tstamp = ath_extend_tsf(sc, (u_int32_t)rxstats->rs_tstamp);
  906575:	9b41      	s32i.n	a11, a4, 4
  906577:	9940      	s32i.n	a9, a4, 0

		HTC_SendMsg(sc->tgt_htc_handle, RX_ENDPOINT_ID, skb);
  906579:	147184        	l32r	a4, 8e2b8c <_HIFusb_isr_handler+0x34>
  90657c:	8a22      	l32i.n	a10, a2, 8
  90657e:	244289        	l32i	a4, a4, 0x224
  906581:	dc50      	mov.n	a12, a5
  906583:	c0b3      	movi.n	a11, 3
  906585:	0b4000        	callx8	a4
		sc->sc_rx_stats.ast_rx_send++;
  906588:	24227d        	l32i	a4, a2, 0x1f4

		bf->bf_status &= ~ATH_BUFSTATUS_DONE;
  90658b:	853f      	l32i.n	a5, a3, 60
				sizeof(struct ath_rx_status));

		rxstats->rs_tstamp = ath_extend_tsf(sc, (u_int32_t)rxstats->rs_tstamp);

		HTC_SendMsg(sc->tgt_htc_handle, RX_ENDPOINT_ID, skb);
		sc->sc_rx_stats.ast_rx_send++;
  90658d:	b144      	addi.n	a4, a4, 1
  90658f:	24267d        	s32i	a4, a2, 0x1f4

		bf->bf_status &= ~ATH_BUFSTATUS_DONE;
  906592:	c74e      	movi.n	a4, -2
  906594:	045401        	and	a4, a5, a4
  906597:	943f      	s32i.n	a4, a3, 60
		asf_tailq_insert_tail(&sc->sc_rxbuf, bf, bf_list);
  906599:	2422d6        	l32i	a4, a2, 0x358
  90659c:	9739      	s32i.n	a7, a3, 36
  90659e:	943a      	s32i.n	a4, a3, 40
  9065a0:	9340      	s32i.n	a3, a4, 0
  9065a2:	233c24        	addi	a3, a3, 36
  9065a5:	2326d6        	s32i	a3, a2, 0x358
  9065a8:	63ff6a        	j	906516 <ath_tgt_rx_tasklet+0xa>
  9065ab:	000023        	excw

	} while(1);

	sc->sc_imask |= HAL_INT_RX;
  9065ae:	22c4c0        	s8i	a2, a12, 192
  9065b1:	b103      	addi.n	a3, a0, 1
  9065b3:	bb02      	addi.n	a2, a0, 11
  9065b5:	2b26c4        	s32i	a11, a2, 0x310
	ah->ah_setInterrupts(ah, sc->sc_imask);
  9065b8:	226228        	l32i	a2, a6, 160
  9065bb:	da60      	mov.n	a10, a6
  9065bd:	0b2000        	callx8	a2
  9065c0:	d10f      	retw.n
	...

009065c4 <ath_descdma_cleanup>:
}

static void ath_descdma_cleanup(struct ath_softc_tgt *sc,
				struct ath_descdma *dd,
				ath_bufhead *head, a_int32_t dir)
{
  9065c4:	6c1006        	entry	a1, 48
	struct ath_buf *bf;
	struct ieee80211_node_target *ni;

	asf_tailq_foreach(bf, head, bf_list) {
  9065c7:	8740      	l32i.n	a7, a4, 0
  9065c9:	60007d        	j	90664a <ath_descdma_cleanup+0x86>
		if (adf_nbuf_queue_len(&bf->bf_skbhead) != 0) {
  9065cc:	267c14        	addi	a6, a7, 20
 * @return length of the queue
 */
static inline a_uint32_t
adf_nbuf_queue_len(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_len(head);
  9065cf:	da60      	mov.n	a10, a6
  9065d1:	5bf43d        	call8	9036c8 <__adf_nbuf_queue_len>
  9065d4:	d9a0      	mov.n	a9, a10
  9065d6:	cbac      	beqz.n	a10, 906616 <ath_descdma_cleanup+0x52>
static inline void
adf_nbuf_unmap(adf_os_device_t      osdev, 
               adf_os_dma_map_t     bmap, 
               adf_os_dma_dir_t     dir)
{
    __adf_nbuf_unmap(osdev, bmap, dir);
  9065d8:	2a2246        	l32i	a10, a2, 0x118
  9065db:	2b7200        	l32i	a11, a7, 0
  9065de:	055c02        	or	a12, a5, a5
  9065e1:	5bf3c1        	call8	9034e8 <__adf_nbuf_unmap>
  9065e4:	600021        	j	906609 <ath_descdma_cleanup+0x45>
  9065e7:	000018        	src	a0, a0, a0
			adf_nbuf_unmap(sc->sc_dev, bf->bf_dmamap, dir);
			while(adf_nbuf_queue_len(&bf->bf_skbhead) != 0) {
				ath_free_rx_skb(sc,
  9065ea:	71848b        	ball	a8, a1, 906579 <ath_tgt_rx_tasklet+0x6d>
  9065ed:	202982        	l16si	a0, a2, 0x104
  9065f0:	a3da      	add.n	a10, a13, a3
 * @return The head buf in the buf queue.
 */
static inline adf_nbuf_t
adf_nbuf_queue_remove(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_remove(head);
  9065f2:	609911        	j	90ff07 <_etext+0x5042>
  9065f5:	9b10      	s32i.n	a11, a1, 0
  9065f7:	5bf3a8        	call8	903498 <__adf_nbuf_queue_remove>
  9065fa:	8b10      	l32i.n	a11, a1, 0
  9065fc:	8911      	l32i.n	a9, a1, 4
  9065fe:	0aac02        	or	a12, a10, a10
  906601:	0bba02        	or	a10, a11, a11
  906604:	c0b3      	movi.n	a11, 3
  906606:	0b9000        	callx8	a9
 * @return length of the queue
 */
static inline a_uint32_t
adf_nbuf_queue_len(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_len(head);
  906609:	da60      	mov.n	a10, a6
  90660b:	5bf42f        	call8	9036c8 <__adf_nbuf_queue_len>
	struct ieee80211_node_target *ni;

	asf_tailq_foreach(bf, head, bf_list) {
		if (adf_nbuf_queue_len(&bf->bf_skbhead) != 0) {
			adf_nbuf_unmap(sc->sc_dev, bf->bf_dmamap, dir);
			while(adf_nbuf_queue_len(&bf->bf_skbhead) != 0) {
  90660e:	65afd7        	bnez	a10, 9065e9 <ath_descdma_cleanup+0x25>
				ath_free_rx_skb(sc,
					adf_nbuf_queue_remove(&bf->bf_skbhead));
			}
			bf->bf_skb = NULL;
  906611:	9a78      	s32i.n	a10, a7, 32
  906613:	600025        	j	90663c <ath_descdma_cleanup+0x78>
		} else if (bf->bf_skb != NULL) {
  906616:	8678      	l32i.n	a6, a7, 32
  906618:	ca60      	beqz.n	a6, 90663c <ath_descdma_cleanup+0x78>
static inline void
adf_nbuf_unmap(adf_os_device_t      osdev, 
               adf_os_dma_map_t     bmap, 
               adf_os_dma_dir_t     dir)
{
    __adf_nbuf_unmap(osdev, bmap, dir);
  90661a:	2b7200        	l32i	a11, a7, 0
  90661d:	2a2246        	l32i	a10, a2, 0x118
  906620:	055c02        	or	a12, a5, a5
  906623:	291601        	s32i	a9, a1, 4
  906626:	5bf3b0        	call8	9034e8 <__adf_nbuf_unmap>
			adf_nbuf_unmap(sc->sc_dev,bf->bf_dmamap, dir);
			ath_free_rx_skb(sc, bf->bf_skb);
  906629:	187184        	l32r	a8, 8e2c3c <hif_module_install+0x68>
  90662c:	8a20      	l32i.n	a10, a2, 0
  90662e:	2682a3        	l32i	a6, a8, 0x28c
  906631:	8c78      	l32i.n	a12, a7, 32
  906633:	c0b3      	movi.n	a11, 3
  906635:	0b6000        	callx8	a6
			bf->bf_skb = NULL;
  906638:	8911      	l32i.n	a9, a1, 4
  90663a:	9978      	s32i.n	a9, a7, 32
 * @param[in] dmap
 */
static inline void
adf_nbuf_dmamap_destroy(adf_os_device_t osdev, adf_os_dma_map_t dmap)
{
    __adf_nbuf_dmamap_destroy(osdev, dmap);
  90663c:	8b70      	l32i.n	a11, a7, 0
  90663e:	2a2246        	l32i	a10, a2, 0x118
		}

		adf_nbuf_dmamap_destroy(sc->sc_dev, bf->bf_dmamap);

		ni = bf->bf_node;
		bf->bf_node = NULL;
  906641:	c060      	movi.n	a6, 0
  906643:	5bf3ac        	call8	9034f4 <__adf_nbuf_dmamap_destroy>
  906646:	9674      	s32i.n	a6, a7, 16
				ath_bufhead *head, a_int32_t dir)
{
	struct ath_buf *bf;
	struct ieee80211_node_target *ni;

	asf_tailq_foreach(bf, head, bf_list) {
  906648:	8779      	l32i.n	a7, a7, 36
  90664a:	657f7e        	bnez	a7, 9065cc <ath_descdma_cleanup+0x8>
	}

	adf_os_dmamem_free(sc->sc_dev, dd->dd_desc_len,
			   1, dd->dd_desc, dd->dd_desc_dmamap);

	asf_tailq_init(head);
  90664d:	9740      	s32i.n	a7, a4, 0
  90664f:	9441      	s32i.n	a4, a4, 4
 * @param[in] size  buffer size
 */
static inline void
adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
{
    __adf_os_mem_set(buf, b, size);
  906651:	da30      	mov.n	a10, a3
  906653:	db70      	mov.n	a11, a7
  906655:	c1c8      	movi.n	a12, 24
  906657:	5bff7b        	call8	906444 <__adf_os_mem_set>
  90665a:	d10f      	retw.n

0090665c <__adf_os_init_bh$isra$4>:
									  void 				*arg)
{
	__adf_os_init_defer(work, func, arg);
}

static inline void	__adf_os_init_bh(adf_os_handle_t  hdl,
  90665c:	6c1004        	entry	a1, 32
									 __adf_os_bh_t		*bh,
									 adf_os_defer_fn_t	func,
									 void				*arg)
{
	//__adf_os_init_defer(bh, func, arg);
	A_TASKLET_INIT_TASK(func, arg, bh);
  90665f:	187184        	l32r	a8, 8e2c70 <hif_module_install+0x9c>
  906662:	da30      	mov.n	a10, a3
  906664:	28826a        	l32i	a8, a8, 0x1a8
  906667:	db40      	mov.n	a11, a4
  906669:	dc20      	mov.n	a12, a2
  90666b:	0b8000        	callx8	a8
  90666e:	d10f      	retw.n

00906670 <__adf_os_sched_bh$isra$5>:
                                         __adf_os_work_t  * work)
{
    //taskqueue_drain(taskqueue_thread, &work->tsk);
}

static inline void __adf_os_sched_bh(adf_os_handle_t  hdl, 
  906670:	6c1004        	entry	a1, 32
                                       __adf_os_bh_t  * bh)
{
    A_TASKLET_SCHEDULE(bh);
  906673:	187184        	l32r	a8, 8e2c84 <hif_module_install+0xb0>
  906676:	da20      	mov.n	a10, a2
  906678:	28826c        	l32i	a8, a8, 0x1b0
  90667b:	0b8000        	callx8	a8
  90667e:	d10f      	retw.n

00906680 <ath_hal_reg_write_filter$isra$10>:
#endif
		reset_pll = 1;
	}
}

static void ath_hal_reg_write_filter(struct ath_hal *ah,
  906680:	6c1004        	entry	a1, 32
			a_uint32_t reg, a_uint32_t val)
{
	if(reg > 0xffff) {
  906683:	18728e        	l32r	a8, 8e30bc <bSet_configuration+0x140>
  906686:	728b32        	bgeu	a8, a2, 9066bc <ath_hal_reg_write_filter$isra$10+0x3c>
  906689:	0c0200        	memw
  90668c:	9320      	s32i.n	a3, a2, 0
		iowrite32(reg, val);
#if defined(PROJECT_K2)
		if(reg == 0x50040) {
  90668e:	137212        	l32r	a3, 8e2ed8 <bGet_descriptor+0x14>
  906691:	732977        	bne	a2, a3, 90670c <ath_hal_reg_write_filter$isra$10+0x8c>
			static uint8_t flg=0;

			if(flg == 0) {
  906694:	12728f        	l32r	a2, 8e30d0 <bSet_configuration+0x154>
  906697:	232000        	l8ui	a3, a2, 0
  90669a:	65306e        	bnez	a3, 90670c <ath_hal_reg_write_filter$isra$10+0x8c>
				/* reinit clock and uart.
				 * TODO: Independent on what host will
				 * here set. We do our own decision. Why? */
				A_CLOCK_INIT(117);
  90669d:	137184        	l32r	a3, 8e2cb0 <hif_module_install+0xdc>
  9066a0:	2a0a75        	movi	a10, 117
  9066a3:	283237        	l32i	a8, a3, 220
  9066a6:	0b8000        	callx8	a8
				A_UART_HWINIT(117*1000*1000, 19200);
  9066a9:	1a7290        	l32r	a10, 8e30ec <bSet_configuration+0x170>
  9066ac:	23321a        	l32i	a3, a3, 104
  9066af:	1b7222        	l32r	a11, 8e2f38 <bGet_descriptor+0x74>
  9066b2:	0b3000        	callx8	a3
				flg = 1;
  9066b5:	c031      	movi.n	a3, 1
  9066b7:	232400        	s8i	a3, a2, 0
  9066ba:	d10f      	retw.n
			}
		}
#endif
	} else {
		if(reg == 0x7014)
  9066bc:	187291        	l32r	a8, 8e3100 <bSet_configuration+0x184>
  9066bf:	78293e        	bne	a2, a8, 906701 <ath_hal_reg_write_filter$isra$10+0x81>

static void ath_pll_reset_ones(struct ath_hal *ah)
{
	static uint8_t reset_pll = 0;

	if(reset_pll == 0) {
  9066c2:	197292        	l32r	a9, 8e310c <bSet_configuration+0x190>
  9066c5:	289000        	l8ui	a8, a9, 0
  9066c8:	cf85      	bnez.n	a8, 906701 <ath_hal_reg_write_filter$isra$10+0x81>
  9066ca:	1a7211        	l32r	a10, 8e2f10 <bGet_descriptor+0x4c>
#if defined(PROJECT_K2)
		/* here we write to core register */
		iowrite32(MAGPIE_REG_RST_PWDN_CTRL_ADDR, 0x0);
		/* and here to mac register */
		iowrite32_mac(0x786c,
  9066cd:	1b7294        	l32r	a11, 8e3120 <bSet_configuration+0x1a4>
  9066d0:	0c0200        	memw
  9066d3:	98a0      	s32i.n	a8, a10, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  9066d5:	187293        	l32r	a8, 8e3124 <bSet_configuration+0x1a8>
  9066d8:	0c0200        	memw
  9066db:	8c80      	l32i.n	a12, a8, 0
  9066dd:	0bcb02        	or	a11, a12, a11
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  9066e0:	0c0200        	memw
  9066e3:	9b80      	s32i.n	a11, a8, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  9066e5:	0c0200        	memw
  9066e8:	8c80      	l32i.n	a12, a8, 0
			 ioread32_mac(0x786c) | 0x6000000);
		iowrite32_mac(0x786c,
  9066ea:	1b7295        	l32r	a11, 8e3140 <bSet_configuration+0x1c4>
  9066ed:	0bcb01        	and	a11, a12, a11
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  9066f0:	0c0200        	memw
  9066f3:	9b80      	s32i.n	a11, a8, 0
  9066f5:	c280      	movi.n	a8, 32
  9066f7:	0c0200        	memw
  9066fa:	98a0      	s32i.n	a8, a10, 0
		iowrite32_mac(0x7890,
			 ioread32_mac(0x7890) | 0x1800000);
		iowrite32_mac(0x7890,
			 ioread32_mac(0x7890) & (~0x1800000));
#endif
		reset_pll = 1;
  9066fc:	c081      	movi.n	a8, 1
  9066fe:	289400        	s8i	a8, a9, 0
#endif
	} else {
		if(reg == 0x7014)
			ath_pll_reset_ones(ah);

		iowrite32_mac(reg, val);
  906701:	18722d        	l32r	a8, 8e2fb8 <bSet_configuration+0x3c>
  906704:	a822      	add.n	a2, a2, a8
  906706:	0c0200        	memw
  906709:	232600        	s32i	a3, a2, 0
  90670c:	d10f      	retw.n
	...

00906710 <ath_reg_read_filter>:

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static a_int32_t ath_reg_read_filter(struct ath_hal *ah, a_int32_t addr)
{
  906710:	6c1004        	entry	a1, 32
	if ((addr & 0xffffe000) == 0x2000) {
  906713:	197296        	l32r	a9, 8e316c <bSet_configuration+0x1f0>
  906716:	18723d        	l32r	a8, 8e300c <bSet_configuration+0x90>
  906719:	093901        	and	a9, a3, a9
  90671c:	789935        	bne	a9, a8, 906755 <ath_reg_read_filter+0x45>
		/* SEEPROM registers */
		ioread32_mac(addr);
  90671f:	18722d        	l32r	a8, 8e2fd4 <bSet_configuration+0x58>
		if (!ath_hal_wait(ah, 0x407c, 0x00030000, 0))
  906722:	1b7297        	l32r	a11, 8e3180 <bSet_configuration+0x204>

static a_int32_t ath_reg_read_filter(struct ath_hal *ah, a_int32_t addr)
{
	if ((addr & 0xffffe000) == 0x2000) {
		/* SEEPROM registers */
		ioread32_mac(addr);
  906725:	a838      	add.n	a8, a3, a8
		if (!ath_hal_wait(ah, 0x407c, 0x00030000, 0))
  906727:	1c7298        	l32r	a12, 8e3188 <bSet_configuration+0x20c>
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90672a:	0c0200        	memw
  90672d:	8880      	l32i.n	a8, a8, 0
  90672f:	022a02        	or	a10, a2, a2
  906732:	2d0a00        	movi	a13, 0
  906735:	5bfa2b        	call8	904fe4 <ath_hal_wait>
  906738:	ccac      	bnez.n	a10, 906748 <ath_reg_read_filter+0x38>
			adf_os_print("SEEPROM Read fail: 0x%08x\n", addr);
  90673a:	127184        	l32r	a2, 8e2d4c <hif_module_install+0x178>
  90673d:	1a7299        	l32r	a10, 8e31a4 <bSet_configuration+0x228>
  906740:	222212        	l32i	a2, a2, 72
  906743:	db30      	mov.n	a11, a3
  906745:	0b2000        	callx8	a2
  906748:	12729a        	l32r	a2, 8e31b0 <bSet_configuration+0x234>
  90674b:	0c0200        	memw
  90674e:	8220      	l32i.n	a2, a2, 0

		return ioread32_mac(0x407c) & 0x0000ffff;
  906750:	02024f        	extui	a2, a2, 0, 16
  906753:	d10f      	retw.n
	} else if (addr > 0xffff)
  906755:	12728e        	l32r	a2, 8e3190 <bSet_configuration+0x214>
  906758:	732a04        	bge	a2, a3, 906760 <ath_reg_read_filter+0x50>
  90675b:	600006        	j	906765 <ath_reg_read_filter+0x55>
  90675e:	000012        	srai	a0, a0, 0
		/* SoC registers */
		return ioread32(addr);
	else
		/* MAC registers */
		return ioread32_mac(addr);
  906761:	722da2        	bbs	a2, a2, 906707 <ath_hal_reg_write_filter$isra$10+0x87>
  906764:	330c02        	excw
  906767:	008230        	excw
}
  90676a:	d10f      	retw.n

0090676c <ath_desc_free>:

#undef DS2PHYS
}

static void ath_desc_free(struct ath_softc_tgt *sc)
{
  90676c:	6c1004        	entry	a1, 32
	asf_tailq_insert_tail(&sc->sc_txbuf, sc->sc_txbuf_held, bf_list);
  90676f:	2822dc        	l32i	a8, a2, 0x370
  906772:	2922f1        	l32i	a9, a2, 0x3c4
  906775:	c0d0      	movi.n	a13, 0
  906777:	9d89      	s32i.n	a13, a8, 36
  906779:	998a      	s32i.n	a9, a8, 40
  90677b:	9890      	s32i.n	a8, a9, 0
  90677d:	2822dc        	l32i	a8, a2, 0x370

	sc->sc_txbuf_held = NULL;
  906780:	2d26dc        	s32i	a13, a2, 0x370
#undef DS2PHYS
}

static void ath_desc_free(struct ath_softc_tgt *sc)
{
	asf_tailq_insert_tail(&sc->sc_txbuf, sc->sc_txbuf_held, bf_list);
  906783:	288c24        	addi	a8, a8, 36
  906786:	2826f1        	s32i	a8, a2, 0x3c4

	sc->sc_txbuf_held = NULL;

	if (sc->sc_txdma.dd_desc_len != 0)
  906789:	2822e7        	l32i	a8, a2, 0x39c
  90678c:	7d8110        	beq	a8, a13, 9067a0 <ath_desc_free+0x34>
		ath_descdma_cleanup(sc, &sc->sc_txdma, (ath_bufhead *)&sc->sc_txbuf,
  90678f:	2b3a8c        	movi	a11, 0x38c
  906792:	2c3ac0        	movi	a12, 0x3c0
  906795:	da20      	mov.n	a10, a2
  906797:	0b2b08        	add	a11, a2, a11
  90679a:	0c2c08        	add	a12, a2, a12
  90679d:	5bff89        	call8	9065c4 <ath_descdma_cleanup>
				    ADF_OS_DMA_TO_DEVICE);
	if (sc->sc_rxdma.dd_desc_len != 0)
  9067a0:	2822e1        	l32i	a8, a2, 0x384
  9067a3:	c88f      	beqz.n	a8, 9067b6 <ath_desc_free+0x4a>
		ath_descdma_cleanup(sc, &sc->sc_rxdma, (ath_bufhead *)&sc->sc_rxbuf,
  9067a5:	2b3a74        	movi	a11, 0x374
  9067a8:	2c3a54        	movi	a12, 0x354
  9067ab:	da20      	mov.n	a10, a2
  9067ad:	ab2b      	add.n	a11, a2, a11
  9067af:	ac2c      	add.n	a12, a2, a12
  9067b1:	c0d1      	movi.n	a13, 1
  9067b3:	5bff84        	call8	9065c4 <ath_descdma_cleanup>
  9067b6:	d10f      	retw.n

009067b8 <ath_descdma_setup$constprop$20>:

/***********************/
/* Descriptor Handling */
/***********************/

static a_int32_t ath_descdma_setup(struct ath_softc_tgt *sc,
  9067b8:	6c1006        	entry	a1, 48
  9067bb:	9210      	s32i.n	a2, a1, 0
	a_int32_t i, bsize, error;
	a_uint8_t *bf_addr;
	a_uint8_t *ds_addr;

	dd->dd_name = name;
	dd->dd_desc_len = descSize * nbuf * ndesc;
  9067bd:	821c      	l32i.n	a2, a1, 48
adf_os_dmamem_alloc(adf_os_device_t     osdev, 
                    adf_os_size_t       size, 
                    a_bool_t            coherent, 
                    adf_os_dma_map_t   *dmap)
{
    return __adf_os_dmamem_alloc(osdev, size, coherent, dmap);
  9067bf:	8810      	l32i.n	a8, a1, 0
  9067c1:	062b28        	mull	a11, a2, a6
  9067c4:	2a8246        	l32i	a10, a8, 0x118
	struct ath_buf *bf;
	a_int32_t i, bsize, error;
	a_uint8_t *bf_addr;
	a_uint8_t *ds_addr;

	dd->dd_name = name;
  9067c7:	9530      	s32i.n	a5, a3, 0
	dd->dd_desc_len = descSize * nbuf * ndesc;
  9067c9:	9b34      	s32i.n	a11, a3, 16
  9067cb:	c0c1      	movi.n	a12, 1
  9067cd:	b83d      	addi.n	a13, a3, 8

/***********************/
/* Descriptor Handling */
/***********************/

static a_int32_t ath_descdma_setup(struct ath_softc_tgt *sc,
  9067cf:	271601        	s32i	a7, a1, 4
  9067d2:	5806c6        	call8	9082ec <__adf_os_dmamem_alloc>
 * @return the (bus) address
 */
static inline adf_os_dma_addr_t
adf_os_dmamem_map2addr(adf_os_dma_map_t dmap)
{
    return(__adf_os_dmamem_map2addr(dmap));
  9067d5:	8532      	l32i.n	a5, a3, 8
	a_uint8_t *ds_addr;

	dd->dd_name = name;
	dd->dd_desc_len = descSize * nbuf * ndesc;

	dd->dd_desc = adf_os_dmamem_alloc(sc->sc_dev,
  9067d7:	9a31      	s32i.n	a10, a3, 4
				  dd->dd_desc_len, 1, &dd->dd_desc_dmamap);
	dd->dd_desc_paddr = adf_os_dmamem_map2addr(dd->dd_desc_dmamap);
  9067d9:	8551      	l32i.n	a5, a5, 4
  9067db:	9533      	s32i.n	a5, a3, 12
adf_os_dmamem_alloc(adf_os_device_t     osdev, 
                    adf_os_size_t       size, 
                    a_bool_t            coherent, 
                    adf_os_dma_map_t   *dmap)
{
    return __adf_os_dmamem_alloc(osdev, size, coherent, dmap);
  9067dd:	d2a0      	mov.n	a2, a10
	if (dd->dd_desc == NULL) {
  9067df:	64a05e        	beqz	a10, 906841 <ath_descdma_setup$constprop$20+0x89>
		error = -ENOMEM;
		goto fail;
	}
	ds = dd->dd_desc;

	bsize = bfSize * nbuf;
  9067e2:	8811      	l32i.n	a8, a1, 4
  9067e4:	068728        	mull	a7, a8, a6
 * @return Buffer pointer or NULL if there's not enough memory.
 */
static inline void *
adf_os_mem_alloc(adf_os_size_t size)
{
    return __adf_os_mem_alloc(size);
  9067e7:	da70      	mov.n	a10, a7
  9067e9:	5bff0c        	call8	90641c <__adf_os_mem_alloc>
  9067ec:	d5a0      	mov.n	a5, a10
	bf = adf_os_mem_alloc(bsize);
	if (bf == NULL) {
  9067ee:	64a04f        	beqz	a10, 906841 <ath_descdma_setup$constprop$20+0x89>
 * @param[in] size  buffer size
 */
static inline void
adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
{
    __adf_os_mem_set(buf, b, size);
  9067f1:	dc70      	mov.n	a12, a7
  9067f3:	c0b0      	movi.n	a11, 0
  9067f5:	5bff13        	call8	906444 <__adf_os_mem_set>
	dd->dd_bufptr = bf;

	bf_addr = (a_uint8_t *)bf;
	ds_addr = (a_uint8_t *)ds;

	asf_tailq_init(head);
  9067f8:	c090      	movi.n	a9, 0
	if (bf == NULL) {
		error = -ENOMEM;
		goto fail2;
	}
	adf_os_mem_set(bf, 0, bsize);
	dd->dd_bufptr = bf;
  9067fa:	9535      	s32i.n	a5, a3, 20

	bf_addr = (a_uint8_t *)bf;
	ds_addr = (a_uint8_t *)ds;

	asf_tailq_init(head);
  9067fc:	9940      	s32i.n	a9, a4, 0
  9067fe:	9441      	s32i.n	a4, a4, 4

	for (i = 0; i < nbuf; i++) {
  906800:	d790      	mov.n	a7, a9
  906802:	600035        	j	90683b <ath_descdma_setup$constprop$20+0x83>
  906805:	008810        	slli	a8, a8, 32
 */
static inline a_status_t
adf_nbuf_dmamap_create(adf_os_device_t osdev,
                       adf_os_dma_map_t *dmap)
{
    return (__adf_nbuf_dmamap_create(osdev, dmap));
  906808:	db50      	mov.n	a11, a5
  90680a:	2a8246        	l32i	a10, a8, 0x118
  90680d:	5bf32c        	call8	9034c0 <__adf_nbuf_dmamap_create>
  906810:	dba0      	mov.n	a11, a10
		a_int32_t j;

		if (adf_nbuf_dmamap_create( sc->sc_dev, &bf->bf_dmamap) != A_STATUS_OK) {
  906812:	ceab      	bnez.n	a10, 906841 <ath_descdma_setup$constprop$20+0x89>
			goto fail2;
		}

		bf->bf_desc = bf->bf_descarr = bf->bf_lastds = ds;
  906814:	925c      	s32i.n	a2, a5, 48
  906816:	925e      	s32i.n	a2, a5, 56
  906818:	925d      	s32i.n	a2, a5, 52
 * @param[in] head  buf queue head
 */
static inline void
adf_nbuf_queue_init(adf_nbuf_queue_t *head)
{
    __adf_nbuf_queue_init(head);
  90681a:	2a5c14        	addi	a10, a5, 20
  90681d:	9b12      	s32i.n	a11, a1, 8
  90681f:	5bf3a6        	call8	9036b8 <__adf_nbuf_queue_init>
			ATH_BUF_SET_DESC_PHY_ADDR_WITH_IDX(bf, j, (ds_addr + (j*descSize)));

		ATH_BUF_SET_DESC_PHY_ADDR(bf, ATH_BUF_GET_DESC_PHY_ADDR_WITH_IDX(bf, 0));

		adf_nbuf_queue_init(&bf->bf_skbhead);
		asf_tailq_insert_tail(head, bf, bf_list);
  906822:	8a41      	l32i.n	a10, a4, 4
  906824:	8b12      	l32i.n	a11, a1, 8

		bf_addr += bfSize;
  906826:	8811      	l32i.n	a8, a1, 4
			ATH_BUF_SET_DESC_PHY_ADDR_WITH_IDX(bf, j, (ds_addr + (j*descSize)));

		ATH_BUF_SET_DESC_PHY_ADDR(bf, ATH_BUF_GET_DESC_PHY_ADDR_WITH_IDX(bf, 0));

		adf_nbuf_queue_init(&bf->bf_skbhead);
		asf_tailq_insert_tail(head, bf, bf_list);
  906828:	9a5a      	s32i.n	a10, a5, 40
  90682a:	9b59      	s32i.n	a11, a5, 36
  90682c:	95a0      	s32i.n	a5, a10, 0
  90682e:	2a5c24        	addi	a10, a5, 36

		bf_addr += bfSize;
  906831:	a855      	add.n	a5, a5, a8
		ds_addr += (ndesc * descSize);
  906833:	881c      	l32i.n	a8, a1, 48
			ATH_BUF_SET_DESC_PHY_ADDR_WITH_IDX(bf, j, (ds_addr + (j*descSize)));

		ATH_BUF_SET_DESC_PHY_ADDR(bf, ATH_BUF_GET_DESC_PHY_ADDR_WITH_IDX(bf, 0));

		adf_nbuf_queue_init(&bf->bf_skbhead);
		asf_tailq_insert_tail(head, bf, bf_list);
  906835:	9a41      	s32i.n	a10, a4, 4

		bf_addr += bfSize;
		ds_addr += (ndesc * descSize);
  906837:	a822      	add.n	a2, a2, a8
	bf_addr = (a_uint8_t *)bf;
	ds_addr = (a_uint8_t *)ds;

	asf_tailq_init(head);

	for (i = 0; i < nbuf; i++) {
  906839:	b177      	addi.n	a7, a7, 1
  90683b:	7672c7        	blt	a7, a6, 906806 <ath_descdma_setup$constprop$20+0x4e>
  90683e:	60000d        	j	90684f <ath_descdma_setup$constprop$20+0x97>
  906841:	da30      	mov.n	a10, a3
  906843:	2b0a00        	movi	a11, 0
  906846:	2c0a18        	movi	a12, 24
  906849:	5bfefe        	call8	906444 <__adf_os_mem_set>
  90684c:	63fffc        	j	90684c <ath_descdma_setup$constprop$20+0x94>
	adf_os_mem_set(dd, 0, sizeof(*dd));
	adf_os_assert(0);
	return error;

#undef DS2PHYS
}
  90684f:	c020      	movi.n	a2, 0
  906851:	d10f      	retw.n
	...

00906854 <tgt_HTCRecvMessageHandler>:
}

static void tgt_HTCRecvMessageHandler(HTC_ENDPOINT_ID EndPt,
				      adf_nbuf_t hdr_buf, adf_nbuf_t buf,
				      void *ServiceCtx)
{
  906854:	6c1006        	entry	a1, 48
	a_uint32_t len;
	ath_data_hdr_t *dh;
	struct ath_node_target *an;
	struct ath_atx_tid *tid;

	if (!hdr_buf) {
  906857:	cd31      	bnez.n	a3, 90686c <tgt_HTCRecvMessageHandler+0x18>
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  906859:	da40      	mov.n	a10, a4
  90685b:	b41b      	addi.n	a11, a1, 4
  90685d:	dc10      	mov.n	a12, a1
  90685f:	5bf390        	call8	9036a0 <__adf_nbuf_peek_header>
 *         or NULL if there is not sufficient data to pull.
 */
static inline a_uint8_t *
adf_nbuf_pull_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_pull_head(buf, size);
  906862:	da40      	mov.n	a10, a4
  906864:	c0bc      	movi.n	a11, 12
  906866:	5bf2e6        	call8	903400 <__adf_nbuf_pull_head>
  906869:	600008        	j	906875 <tgt_HTCRecvMessageHandler+0x21>
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  90686c:	da30      	mov.n	a10, a3
  90686e:	b41b      	addi.n	a11, a1, 4
  906870:	dc10      	mov.n	a12, a1
  906872:	5bf38b        	call8	9036a0 <__adf_nbuf_peek_header>
		adf_nbuf_pull_head(buf, sizeof(ath_data_hdr_t));
	} else {
		adf_nbuf_peek_header(hdr_buf, &data, &len);
	}

	adf_os_assert(len >= sizeof(ath_data_hdr_t));
  906875:	8310      	l32i.n	a3, a1, 0
  906877:	c06b      	movi.n	a6, 11
  906879:	736305        	bltu	a6, a3, 906882 <tgt_HTCRecvMessageHandler+0x2e>
  90687c:	63fffc        	j	90687c <tgt_HTCRecvMessageHandler+0x28>
  90687f:	000000        	ill
	dh = (ath_data_hdr_t *)data;
  906882:	8311      	l32i.n	a3, a1, 4
	an = &sc->sc_sta[dh->ni_index];
	tid = ATH_AN_2_TID(an, dh->tidno);

	sc->sc_tx_stats.tx_tgt++;

	bf = ath_tgt_tx_prepare(sc, buf, dh);
  906884:	db40      	mov.n	a11, a4
	}

	adf_os_assert(len >= sizeof(ath_data_hdr_t));
	dh = (ath_data_hdr_t *)data;

	an = &sc->sc_sta[dh->ni_index];
  906886:	283001        	l8ui	a8, a3, 1
	tid = ATH_AN_2_TID(an, dh->tidno);
  906889:	293003        	l8ui	a9, a3, 3
	}

	adf_os_assert(len >= sizeof(ath_data_hdr_t));
	dh = (ath_data_hdr_t *)data;

	an = &sc->sc_sta[dh->ni_index];
  90688c:	0a8611        	slli	a6, a8, 6
  90688f:	a866      	add.n	a6, a6, a8
  906891:	086809        	addx2	a8, a6, a8
  906894:	265a30        	movi	a6, 0x530
  906897:	06880a        	addx4	a8, a8, a6
	tid = ATH_AN_2_TID(an, dh->tidno);
  90689a:	0c9611        	slli	a6, a9, 4
	}

	adf_os_assert(len >= sizeof(ath_data_hdr_t));
	dh = (ath_data_hdr_t *)data;

	an = &sc->sc_sta[dh->ni_index];
  90689d:	a858      	add.n	a8, a5, a8
	tid = ATH_AN_2_TID(an, dh->tidno);
  90689f:	09660c        	sub	a6, a6, a9
  9068a2:	08660a        	addx4	a6, a6, a8

	sc->sc_tx_stats.tx_tgt++;
  9068a5:	28525b        	l32i	a8, a5, 0x16c

	bf = ath_tgt_tx_prepare(sc, buf, dh);
  9068a8:	da50      	mov.n	a10, a5
	dh = (ath_data_hdr_t *)data;

	an = &sc->sc_sta[dh->ni_index];
	tid = ATH_AN_2_TID(an, dh->tidno);

	sc->sc_tx_stats.tx_tgt++;
  9068aa:	b188      	addi.n	a8, a8, 1
  9068ac:	28565b        	s32i	a8, a5, 0x16c

	bf = ath_tgt_tx_prepare(sc, buf, dh);
  9068af:	dc30      	mov.n	a12, a3
  9068b1:	580ca2        	call8	909b3c <ath_tgt_tx_prepare>

	adf_os_assert(len >= sizeof(ath_data_hdr_t));
	dh = (ath_data_hdr_t *)data;

	an = &sc->sc_sta[dh->ni_index];
	tid = ATH_AN_2_TID(an, dh->tidno);
  9068b4:	266c2c        	addi	a6, a6, 44

	sc->sc_tx_stats.tx_tgt++;

	bf = ath_tgt_tx_prepare(sc, buf, dh);
  9068b7:	dba0      	mov.n	a11, a10
	if (!bf) {
  9068b9:	ccaf      	bnez.n	a10, 9068cc <tgt_HTCRecvMessageHandler+0x78>
		ath_free_tx_skb(sc->tgt_htc_handle,EndPt,buf);
  9068bb:	137184        	l32r	a3, 8e2ecc <bGet_descriptor+0x8>
  9068be:	8a52      	l32i.n	a10, a5, 8
  9068c0:	233287        	l32i	a3, a3, 0x21c
  9068c3:	db20      	mov.n	a11, a2
  9068c5:	dc40      	mov.n	a12, a4
  9068c7:	0b3000        	callx8	a3
  9068ca:	d10f      	retw.n
		return;
	}

	bf->bf_endpt = EndPt;
  9068cc:	22a623        	s32i	a2, a10, 140
	bf->bf_cookie = dh->cookie;
  9068cf:	22300a        	l8ui	a2, a3, 10
  9068d2:	22a492        	s8i	a2, a10, 146

	if (tid->flag & TID_AGGR_ENABLED)
  9068d5:	226036        	l8ui	a2, a6, 54
		ath_tgt_handle_aggr(sc, bf);
  9068d8:	da50      	mov.n	a10, a5
	}

	bf->bf_endpt = EndPt;
	bf->bf_cookie = dh->cookie;

	if (tid->flag & TID_AGGR_ENABLED)
  9068da:	7e2707        	bbci	a2, 30, 9068e5 <tgt_HTCRecvMessageHandler+0x91>
		ath_tgt_handle_aggr(sc, bf);
  9068dd:	5810b1        	call8	90aba4 <ath_tgt_handle_aggr>
  9068e0:	d10f      	retw.n
  9068e2:	000000        	ill
	else
		ath_tgt_handle_normal(sc, bf);
  9068e5:	580e33        	call8	90a1b4 <ath_tgt_handle_normal>
  9068e8:	d10f      	retw.n
	...

009068ec <tgt_HTCRecv_cabhandler>:
}

static void tgt_HTCRecv_cabhandler(HTC_ENDPOINT_ID EndPt, adf_nbuf_t hdr_buf,
				   adf_nbuf_t buf, void *ServiceCtx)
{
  9068ec:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)ServiceCtx;
	struct ath_hal *ah = sc->sc_ah;
  9068ef:	285d05        	addmi	a8, a5, 0x500
  9068f2:	8a8b      	l32i.n	a10, a8, 44
	a_uint64_t tsf;
	a_uint32_t tmp;

#ifdef ATH_ENABLE_CABQ
	tsf = ah->ah_getTsf64(ah);
  9068f4:	28a21e        	l32i	a8, a10, 120
  9068f7:	0b8000        	callx8	a8
	tmp = tsf - sc->sc_swba_tsf;
  9068fa:	285d16        	addmi	a8, a5, 0x1600
  9068fd:	888d      	l32i.n	a8, a8, 52

	if ( tmp > ATH_CABQ_HANDLING_THRESHOLD ) {
  9068ff:	19729b        	l32r	a9, 8e336c <bStandardCommand+0xe0>
	a_uint64_t tsf;
	a_uint32_t tmp;

#ifdef ATH_ENABLE_CABQ
	tsf = ah->ah_getTsf64(ah);
	tmp = tsf - sc->sc_swba_tsf;
  906902:	08bb0c        	sub	a11, a11, a8

	if ( tmp > ATH_CABQ_HANDLING_THRESHOLD ) {
  906905:	7b9b11        	bgeu	a9, a11, 90691a <tgt_HTCRecv_cabhandler+0x2e>
		HTC_ReturnBuffers(sc->tgt_htc_handle, EndPt, buf);
  906908:	137184        	l32r	a3, 8e2f18 <bGet_descriptor+0x54>
  90690b:	8a52      	l32i.n	a10, a5, 8
  90690d:	233287        	l32i	a3, a3, 0x21c
  906910:	db20      	mov.n	a11, a2
  906912:	044c02        	or	a12, a4, a4
  906915:	0b3000        	callx8	a3
  906918:	d10f      	retw.n
		return;
	}

	tgt_HTCRecvMessageHandler(EndPt, hdr_buf, buf, ServiceCtx);
  90691a:	da20      	mov.n	a10, a2
  90691c:	db30      	mov.n	a11, a3
  90691e:	dc40      	mov.n	a12, a4
  906920:	dd50      	mov.n	a13, a5
  906922:	5bffcc        	call8	906854 <tgt_HTCRecvMessageHandler>
  906925:	d10f      	retw.n
	...

00906928 <ath_rxdesc_init>:
				       RX_HEADER_SPACE, align);
	return skb;
}

static a_int32_t ath_rxdesc_init(struct ath_softc_tgt *sc, struct ath_rx_desc *ds)
{
  906928:	6c1006        	entry	a1, 48
	struct ath_hal *ah = sc->sc_ah;
  90692b:	242d05        	addmi	a4, a2, 0x500
  90692e:	854b      	l32i.n	a5, a4, 44
	struct ath_rx_desc *ds_held;
	a_uint8_t *anbdata;
	a_uint32_t anblen;

	if (!sc->sc_rxdesc_held) {
  906930:	2422db        	l32i	a4, a2, 0x36c
		sc->sc_rxdesc_held = ds;
  906933:	2326db        	s32i	a3, a2, 0x36c
	struct ath_hal *ah = sc->sc_ah;
	struct ath_rx_desc *ds_held;
	a_uint8_t *anbdata;
	a_uint32_t anblen;

	if (!sc->sc_rxdesc_held) {
  906936:	cc43      	bnez.n	a4, 90693d <ath_rxdesc_init+0x15>
  906938:	60017c        	j	906ab8 <ath_rxdesc_init+0x190>
  90693b:	000029        	excw

	ds_held = sc->sc_rxdesc_held;
	sc->sc_rxdesc_held = ds;
	ds = ds_held;

	if (ds->ds_nbuf == ADF_NBUF_NULL) {
  90693e:	403428        	excw
  906941:	403523        	excw
  906944:	403608        	excw
  906947:	9910      	s32i.n	a9, a1, 0
  906949:	008811        	slli	a8, a8, 16
  90694c:	098802        	or	a8, a8, a9
  90694f:	083311        	slli	a3, a3, 8
  906952:	083302        	or	a3, a3, a8
  906955:	284037        	l8ui	a8, a4, 55
  906958:	038302        	or	a3, a8, a3
  90695b:	6530b6        	bnez	a3, 906a15 <ath_rxdesc_init+0xed>
static adf_nbuf_t ath_alloc_skb_align(struct ath_softc_tgt *sc,
				      a_uint32_t size, a_uint32_t align)
{
	adf_nbuf_t skb;

	skb = BUF_Pool_alloc_buf_align(sc->pool_handle, POOL_ID_WLAN_RX_BUF,
  90695e:	137184        	l32r	a3, 8e2f70 <bGet_descriptor+0xac>
  906961:	8a20      	l32i.n	a10, a2, 0
  906963:	2332a2        	l32i	a3, a3, 0x288
  906966:	2d2196        	l16ui	a13, a2, 0x12c
  906969:	c3c0      	movi.n	a12, 48
  90696b:	c0b3      	movi.n	a11, 3
  90696d:	0b3000        	callx8	a3
	ds_held = sc->sc_rxdesc_held;
	sc->sc_rxdesc_held = ds;
	ds = ds_held;

	if (ds->ds_nbuf == ADF_NBUF_NULL) {
		ds->ds_nbuf = ath_alloc_skb_align(sc, sc->sc_rxbufsize, sc->sc_cachelsz);
  906970:	0a8357        	extui	a3, a10, 24, 8
  906973:	234434        	s8i	a3, a4, 52
  906976:	0a0357        	extui	a3, a10, 16, 8
  906979:	234435        	s8i	a3, a4, 53
  90697c:	0a8347        	extui	a3, a10, 8, 8
  90697f:	234436        	s8i	a3, a4, 54
  906982:	2a4437        	s8i	a10, a4, 55
static adf_nbuf_t ath_alloc_skb_align(struct ath_softc_tgt *sc,
				      a_uint32_t size, a_uint32_t align)
{
	adf_nbuf_t skb;

	skb = BUF_Pool_alloc_buf_align(sc->pool_handle, POOL_ID_WLAN_RX_BUF,
  906985:	dca0      	mov.n	a12, a10
	sc->sc_rxdesc_held = ds;
	ds = ds_held;

	if (ds->ds_nbuf == ADF_NBUF_NULL) {
		ds->ds_nbuf = ath_alloc_skb_align(sc, sc->sc_rxbufsize, sc->sc_cachelsz);
		if (ds->ds_nbuf == ADF_NBUF_NULL) {
  906987:	ccad      	bnez.n	a10, 906998 <ath_rxdesc_init+0x70>
			sc->sc_rxdesc_held = ds;
			sc->sc_rx_stats.ast_rx_nobuf++;
  906989:	23227c        	l32i	a3, a2, 0x1f0
	ds = ds_held;

	if (ds->ds_nbuf == ADF_NBUF_NULL) {
		ds->ds_nbuf = ath_alloc_skb_align(sc, sc->sc_rxbufsize, sc->sc_cachelsz);
		if (ds->ds_nbuf == ADF_NBUF_NULL) {
			sc->sc_rxdesc_held = ds;
  90698c:	2426db        	s32i	a4, a2, 0x36c
			sc->sc_rx_stats.ast_rx_nobuf++;
  90698f:	b133      	addi.n	a3, a3, 1
  906991:	23267c        	s32i	a3, a2, 0x1f0
			return ENOMEM;
  906994:	c72f      	movi.n	a2, -1
  906996:	d10f      	retw.n
		}
		adf_nbuf_map(sc->sc_dev, ds->ds_dmap, ds->ds_nbuf, ADF_OS_DMA_FROM_DEVICE);
  906998:	294038        	l8ui	a9, a4, 56
  90699b:	284039        	l8ui	a8, a4, 57
  90699e:	23403a        	l8ui	a3, a4, 58
  9069a1:	089910        	slli	a9, a9, 24
  9069a4:	008811        	slli	a8, a8, 16
  9069a7:	098802        	or	a8, a8, a9
  9069aa:	2b403b        	l8ui	a11, a4, 59
  9069ad:	083311        	slli	a3, a3, 8
  9069b0:	083302        	or	a3, a3, a8
adf_nbuf_map(adf_os_device_t        osdev, 
             adf_os_dma_map_t       bmap, 
             adf_nbuf_t             buf, 
             adf_os_dma_dir_t       dir)
{
    return __adf_nbuf_map(osdev, bmap, buf, dir);
  9069b3:	2a2246        	l32i	a10, a2, 0x118
  9069b6:	03bb02        	or	a11, a11, a3
  9069b9:	c0d1      	movi.n	a13, 1
  9069bb:	5bf2c8        	call8	9034dc <__adf_nbuf_map>
		adf_nbuf_dmamap_info(ds->ds_dmap, &ds->ds_dmap_info);
  9069be:	294038        	l8ui	a9, a4, 56
  9069c1:	284039        	l8ui	a8, a4, 57
  9069c4:	23403a        	l8ui	a3, a4, 58
  9069c7:	089910        	slli	a9, a9, 24
  9069ca:	008811        	slli	a8, a8, 16
  9069cd:	098802        	or	a8, a8, a9
  9069d0:	2a403b        	l8ui	a10, a4, 59
  9069d3:	083311        	slli	a3, a3, 8
  9069d6:	083302        	or	a3, a3, a8
 * @param[out] sg   map info
 */
static inline void
adf_nbuf_dmamap_info(adf_os_dma_map_t bmap, adf_os_dmamap_info_t *sg)
{
    __adf_nbuf_dmamap_info(bmap, sg);
  9069d9:	03aa02        	or	a10, a10, a3
  9069dc:	2b4c3c        	addi	a11, a4, 60
  9069df:	5bf2c7        	call8	9034fc <__adf_nbuf_dmamap_info>
		ds->ds_data = ds->ds_dmap_info.dma_segs[0].paddr;
  9069e2:	294040        	l8ui	a9, a4, 64
  9069e5:	234041        	l8ui	a3, a4, 65
  9069e8:	284042        	l8ui	a8, a4, 66
  9069eb:	089910        	slli	a9, a9, 24
  9069ee:	003311        	slli	a3, a3, 16
  9069f1:	093302        	or	a3, a3, a9
  9069f4:	088811        	slli	a8, a8, 8
  9069f7:	038802        	or	a8, a8, a3
  9069fa:	234043        	l8ui	a3, a4, 67
  9069fd:	083802        	or	a8, a3, a8
  906a00:	088357        	extui	a3, a8, 24, 8
  906a03:	234404        	s8i	a3, a4, 4
  906a06:	080357        	extui	a3, a8, 16, 8
  906a09:	234405        	s8i	a3, a4, 5
  906a0c:	088347        	extui	a3, a8, 8, 8
  906a0f:	234406        	s8i	a3, a4, 6
  906a12:	284407        	s8i	a8, a4, 7
	}

	ds->ds_link = 0;
  906a15:	c080      	movi.n	a8, 0
  906a17:	284400        	s8i	a8, a4, 0
  906a1a:	284401        	s8i	a8, a4, 1
  906a1d:	284402        	s8i	a8, a4, 2
  906a20:	284403        	s8i	a8, a4, 3
	adf_nbuf_peek_header(ds->ds_nbuf, &anbdata, &anblen);
  906a23:	294034        	l8ui	a9, a4, 52
  906a26:	284035        	l8ui	a8, a4, 53
  906a29:	234036        	l8ui	a3, a4, 54
  906a2c:	089910        	slli	a9, a9, 24
  906a2f:	008811        	slli	a8, a8, 16
  906a32:	098802        	or	a8, a8, a9
  906a35:	2a4037        	l8ui	a10, a4, 55
  906a38:	083311        	slli	a3, a3, 8
  906a3b:	083302        	or	a3, a3, a8
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  906a3e:	03aa02        	or	a10, a10, a3
  906a41:	b41b      	addi.n	a11, a1, 4
  906a43:	dc10      	mov.n	a12, a1
  906a45:	5bf316        	call8	9036a0 <__adf_nbuf_peek_header>

	ah->ah_setupRxDesc(ds, adf_nbuf_tailroom(ds->ds_nbuf), 0);
  906a48:	2a4034        	l8ui	a10, a4, 52
  906a4b:	294035        	l8ui	a9, a4, 53
  906a4e:	284036        	l8ui	a8, a4, 54
  906a51:	08aa10        	slli	a10, a10, 24
  906a54:	009911        	slli	a9, a9, 16
  906a57:	0a9902        	or	a9, a9, a10
  906a5a:	088811        	slli	a8, a8, 8
  906a5d:	2a4037        	l8ui	a10, a4, 55
  906a60:	098802        	or	a8, a8, a9
 * @return amount of tail room 
 */
static inline a_uint32_t
adf_nbuf_tailroom(adf_nbuf_t buf)
{
    return (__adf_nbuf_tailroom(buf));
  906a63:	08aa02        	or	a10, a10, a8
  906a66:	235220        	l32i	a3, a5, 128
  906a69:	5bf2fe        	call8	903664 <__adf_nbuf_tailroom>
  906a6c:	dba0      	mov.n	a11, a10
  906a6e:	c0c0      	movi.n	a12, 0
  906a70:	da40      	mov.n	a10, a4
  906a72:	0b3000        	callx8	a3
  906a75:	2a4048        	l8ui	a10, a4, 72
  906a78:	294049        	l8ui	a9, a4, 73

	if (sc->sc_rxlink == NULL) {
		ah->ah_setRxDP(ah, ds->ds_daddr);
  906a7b:	08aa10        	slli	a10, a10, 24
  906a7e:	009911        	slli	a9, a9, 16
  906a81:	0a9a02        	or	a10, a9, a10
  906a84:	29404a        	l8ui	a9, a4, 74
	ds->ds_link = 0;
	adf_nbuf_peek_header(ds->ds_nbuf, &anbdata, &anblen);

	ah->ah_setupRxDesc(ds, adf_nbuf_tailroom(ds->ds_nbuf), 0);

	if (sc->sc_rxlink == NULL) {
  906a87:	2822ef        	l32i	a8, a2, 0x3bc
		ah->ah_setRxDP(ah, ds->ds_daddr);
  906a8a:	089911        	slli	a9, a9, 8
  906a8d:	0a9902        	or	a9, a9, a10
	ds->ds_link = 0;
	adf_nbuf_peek_header(ds->ds_nbuf, &anbdata, &anblen);

	ah->ah_setupRxDesc(ds, adf_nbuf_tailroom(ds->ds_nbuf), 0);

	if (sc->sc_rxlink == NULL) {
  906a90:	cd81      	bnez.n	a8, 906aa5 <ath_rxdesc_init+0x17d>
		ah->ah_setRxDP(ah, ds->ds_daddr);
  906a92:	2b404b        	l8ui	a11, a4, 75
  906a95:	23521f        	l32i	a3, a5, 124
  906a98:	da50      	mov.n	a10, a5
  906a9a:	09bb02        	or	a11, a11, a9
  906a9d:	0b3000        	callx8	a3
  906aa0:	600009        	j	906aad <ath_rxdesc_init+0x185>
  906aa3:	000023        	excw
	}
	else {
		*sc->sc_rxlink = ds->ds_daddr;
  906aa6:	404b09        	excw
  906aa9:	390299        	excw
  906aac:	8024      	l32i.n	a0, a2, 16
	}
	sc->sc_rxlink = &ds->ds_link;
  906aae:	26ef22        	s32ri	a6, a14, 136
	ah->ah_enableReceive(ah);
  906ab1:	5225da        	call0	89021c <_bss_end+0x382a14>
  906ab4:	500b20        	call0	909738 <ath_tx_freebuf+0x20>
  906ab7:	00c020        	excw

	return 0;
}
  906aba:	d10f      	retw.n

00906abc <tgt_HTCSendCompleteHandler>:
		asf_tailq_insert_tail(&sc->sc_rxdesc, ds_tmp, ds_list);
	}
}

static void tgt_HTCSendCompleteHandler(HTC_ENDPOINT_ID Endpt, adf_nbuf_t buf, void *ServiceCtx)
{
  906abc:	6c1006        	entry	a1, 48
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)ServiceCtx;

	if (Endpt == RX_ENDPOINT_ID) {
  906abf:	682302        	beqi	a2, 3, 906ac5 <tgt_HTCSendCompleteHandler+0x9>
  906ac2:	600124        	j	906bea <tgt_HTCSendCompleteHandler+0x12e>
		sc->sc_rx_stats.ast_rx_done++;
  906ac5:	22427e        	l32i	a2, a4, 0x1f8
}

static inline void
adf_nbuf_split_to_frag(adf_nbuf_t buf, adf_nbuf_queue_t *qhead)
{
    return __adf_nbuf_split_to_frag(buf, qhead);
  906ac8:	da30      	mov.n	a10, a3
  906aca:	b122      	addi.n	a2, a2, 1
  906acc:	22467e        	s32i	a2, a4, 0x1f8
  906acf:	db10      	mov.n	a11, a1
  906ad1:	5bf2b6        	call8	9035ac <__adf_nbuf_split_to_frag>
	struct ath_rx_desc *ds;
	adf_nbuf_t buf_tmp;
	adf_nbuf_queue_t nbuf_head;

	adf_nbuf_split_to_frag(buf, &nbuf_head);
	ds = asf_tailq_first(&sc->sc_rxdesc_idle);
  906ad4:	2242d7        	l32i	a2, a4, 0x35c

		if (buf_tmp == NULL) {
			break;
		}

		BUF_Pool_free_buf(sc->pool_handle, POOL_ID_WLAN_RX_BUF, buf_tmp);
  906ad7:	137184        	l32r	a3, 8e30e8 <bSet_configuration+0x16c>
  906ada:	600109        	j	906be7 <tgt_HTCSendCompleteHandler+0x12b>
 * @return The head buf in the buf queue.
 */
static inline adf_nbuf_t
adf_nbuf_queue_remove(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_remove(head);
  906add:	da10      	mov.n	a10, a1
  906adf:	5bf26e        	call8	903498 <__adf_nbuf_queue_remove>
  906ae2:	dca0      	mov.n	a12, a10

	while (ds) {
		struct ath_rx_desc *ds_tmp;
		buf_tmp = adf_nbuf_queue_remove(&nbuf_head);

		if (buf_tmp == NULL) {
  906ae4:	64a102        	beqz	a10, 906bea <tgt_HTCSendCompleteHandler+0x12e>
			break;
		}

		BUF_Pool_free_buf(sc->pool_handle, POOL_ID_WLAN_RX_BUF, buf_tmp);
  906ae7:	2832a3        	l32i	a8, a3, 0x28c
  906aea:	8a40      	l32i.n	a10, a4, 0
  906aec:	c0b3      	movi.n	a11, 3
  906aee:	0b8000        	callx8	a8

		ds_tmp = ds;
		ds = asf_tailq_next(ds, ds_list);
  906af1:	29204c        	l8ui	a9, a2, 76
  906af4:	28204d        	l8ui	a8, a2, 77
  906af7:	25204e        	l8ui	a5, a2, 78
  906afa:	089910        	slli	a9, a9, 24
  906afd:	008811        	slli	a8, a8, 16
  906b00:	098802        	or	a8, a8, a9
  906b03:	085511        	slli	a5, a5, 8
  906b06:	085502        	or	a5, a5, a8
  906b09:	28204f        	l8ui	a8, a2, 79

		ath_rxdesc_init(sc, ds_tmp);
  906b0c:	044a02        	or	a10, a4, a4
  906b0f:	022b02        	or	a11, a2, a2
		}

		BUF_Pool_free_buf(sc->pool_handle, POOL_ID_WLAN_RX_BUF, buf_tmp);

		ds_tmp = ds;
		ds = asf_tailq_next(ds, ds_list);
  906b12:	058502        	or	a5, a8, a5

		ath_rxdesc_init(sc, ds_tmp);
  906b15:	5bff84        	call8	906928 <ath_rxdesc_init>

		asf_tailq_remove(&sc->sc_rxdesc_idle, ds_tmp, ds_list);
  906b18:	2a204c        	l8ui	a10, a2, 76
  906b1b:	29204d        	l8ui	a9, a2, 77
  906b1e:	28204e        	l8ui	a8, a2, 78
  906b21:	08aa10        	slli	a10, a10, 24
  906b24:	009911        	slli	a9, a9, 16
  906b27:	0a9902        	or	a9, a9, a10
  906b2a:	088811        	slli	a8, a8, 8
  906b2d:	098802        	or	a8, a8, a9
  906b30:	29204f        	l8ui	a9, a2, 79
  906b33:	2a2051        	l8ui	a10, a2, 81
  906b36:	089802        	or	a8, a9, a8
  906b39:	292050        	l8ui	a9, a2, 80
  906b3c:	00aa11        	slli	a10, a10, 16
  906b3f:	089910        	slli	a9, a9, 24
  906b42:	09aa02        	or	a10, a10, a9
  906b45:	292052        	l8ui	a9, a2, 82
  906b48:	089911        	slli	a9, a9, 8
  906b4b:	0a9902        	or	a9, a9, a10
  906b4e:	c98e      	beqz.n	a8, 906b70 <tgt_HTCSendCompleteHandler+0xb4>
  906b50:	2a2053        	l8ui	a10, a2, 83
  906b53:	09a902        	or	a9, a10, a9
  906b56:	098a57        	extui	a10, a9, 24, 8
  906b59:	2a8450        	s8i	a10, a8, 80
  906b5c:	090a57        	extui	a10, a9, 16, 8
  906b5f:	2a8451        	s8i	a10, a8, 81
  906b62:	098a47        	extui	a10, a9, 8, 8
  906b65:	2a8452        	s8i	a10, a8, 82
  906b68:	298453        	s8i	a9, a8, 83
  906b6b:	60000a        	j	906b79 <tgt_HTCSendCompleteHandler+0xbd>
  906b6e:	000028        	mull	a0, a0, a0
  906b71:	205309        	excw
  906b74:	8902      	l32i.n	a9, a0, 8
  906b76:	2946d8        	s32i	a9, a4, 0x360
  906b79:	2a2050        	l8ui	a10, a2, 80
  906b7c:	292051        	l8ui	a9, a2, 81
  906b7f:	282052        	l8ui	a8, a2, 82
  906b82:	08aa10        	slli	a10, a10, 24
  906b85:	009911        	slli	a9, a9, 16
  906b88:	0a9902        	or	a9, a9, a10
  906b8b:	088811        	slli	a8, a8, 8
  906b8e:	098802        	or	a8, a8, a9
  906b91:	292053        	l8ui	a9, a2, 83
  906b94:	2b204c        	l8ui	a11, a2, 76
  906b97:	2a204d        	l8ui	a10, a2, 77
  906b9a:	089802        	or	a8, a9, a8
  906b9d:	29204e        	l8ui	a9, a2, 78
  906ba0:	08bb10        	slli	a11, a11, 24
  906ba3:	00aa11        	slli	a10, a10, 16
  906ba6:	0baa02        	or	a10, a10, a11
  906ba9:	089911        	slli	a9, a9, 8
  906bac:	0a9902        	or	a9, a9, a10
  906baf:	2a204f        	l8ui	a10, a2, 79
  906bb2:	09a902        	or	a9, a10, a9
  906bb5:	9980      	s32i.n	a9, a8, 0
		asf_tailq_insert_tail(&sc->sc_rxdesc, ds_tmp, ds_list);
  906bb7:	c080      	movi.n	a8, 0
  906bb9:	28244c        	s8i	a8, a2, 76
  906bbc:	28244d        	s8i	a8, a2, 77
  906bbf:	28244e        	s8i	a8, a2, 78
  906bc2:	28244f        	s8i	a8, a2, 79
  906bc5:	2842da        	l32i	a8, a4, 0x368
  906bc8:	088957        	extui	a9, a8, 24, 8
  906bcb:	292450        	s8i	a9, a2, 80
  906bce:	080957        	extui	a9, a8, 16, 8
  906bd1:	292451        	s8i	a9, a2, 81
  906bd4:	088947        	extui	a9, a8, 8, 8
  906bd7:	292452        	s8i	a9, a2, 82
  906bda:	282453        	s8i	a8, a2, 83
  906bdd:	9280      	s32i.n	a2, a8, 0
  906bdf:	222c4c        	addi	a2, a2, 76
  906be2:	2246da        	s32i	a2, a4, 0x368
		}

		BUF_Pool_free_buf(sc->pool_handle, POOL_ID_WLAN_RX_BUF, buf_tmp);

		ds_tmp = ds;
		ds = asf_tailq_next(ds, ds_list);
  906be5:	d250      	mov.n	a2, a5
	adf_nbuf_queue_t nbuf_head;

	adf_nbuf_split_to_frag(buf, &nbuf_head);
	ds = asf_tailq_first(&sc->sc_rxdesc_idle);

	while (ds) {
  906be7:	652ef2        	bnez	a2, 906add <tgt_HTCSendCompleteHandler+0x21>
  906bea:	d10f      	retw.n

00906bec <wmi_event>:

}

void wmi_event(wmi_handle_t handle, WMI_EVENT_ID evt_id,
	       void *buffer, a_int32_t Length)
{
  906bec:	6c1004        	entry	a1, 32
	adf_nbuf_t netbuf = ADF_NBUF_NULL;
	a_uint8_t *pData;

	netbuf = WMI_AllocEvent(handle, WMI_EVT_CLASS_CMD_EVENT,
  906bef:	177184        	l32r	a7, 8e3200 <bSet_configuration+0x284>
  906bf2:	da20      	mov.n	a10, a2
  906bf4:	267292        	l32i	a6, a7, 0x248
  906bf7:	c0b0      	movi.n	a11, 0
  906bf9:	b45c      	addi.n	a12, a5, 4
  906bfb:	0b6000        	callx8	a6
  906bfe:	d6a0      	mov.n	a6, a10
				sizeof(WMI_CMD_HDR) + Length);

	if (netbuf == ADF_NBUF_NULL) {
  906c00:	65a00a        	bnez	a10, 906c0e <wmi_event+0x22>
		adf_os_print("Buf null\n");
  906c03:	227212        	l32i	a2, a7, 72
  906c06:	1a729c        	l32r	a10, 8e3678 <bStandardCommand+0x3ec>
  906c09:	0b2000        	callx8	a2
  906c0c:	d10f      	retw.n
		return;
	}

	if (buffer != NULL && Length != 0 && Length < WMI_SVC_MAX_BUFFERED_EVENT_SIZE) {
  906c0e:	c952      	beqz.n	a5, 906c24 <wmi_event+0x38>
  906c10:	c940      	beqz.n	a4, 906c24 <wmi_event+0x38>
  906c12:	270a63        	movi	a7, 99
  906c15:	75720b        	blt	a7, a5, 906c24 <wmi_event+0x38>
 *         put, or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_put_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_put_tail(buf, size);
  906c18:	db50      	mov.n	a11, a5
  906c1a:	5bf285        	call8	903630 <__adf_nbuf_put_tail>
 * @param[in] size    buffer size
 */
static inline void
adf_os_mem_copy(void *dst, const void *src, adf_os_size_t size)
{
    __adf_os_mem_copy(dst, src, size);
  906c1d:	db40      	mov.n	a11, a4
  906c1f:	dc50      	mov.n	a12, a5
  906c21:	5bfe03        	call8	906430 <__adf_os_mem_copy>
		pData = adf_nbuf_put_tail(netbuf, Length);
		adf_os_mem_copy(pData, buffer, Length);
	}

	WMI_SendEvent(handle, netbuf, evt_id, 0, Length);
  906c24:	147184        	l32r	a4, 8e3234 <bSet_configuration+0x2b8>
  906c27:	da20      	mov.n	a10, a2
  906c29:	244293        	l32i	a4, a4, 0x24c
  906c2c:	db60      	mov.n	a11, a6
  906c2e:	030c4f        	extui	a12, a3, 0, 16
  906c31:	c0d0      	movi.n	a13, 0
  906c33:	de50      	mov.n	a14, a5
  906c35:	0b4000        	callx8	a4
  906c38:	d10f      	retw.n
	...

00906c3c <ath_fatal_tasklet>:

	return ADF_OS_IRQ_HANDLED;
}

static void ath_fatal_tasklet(TQUEUE_ARG data )
{
  906c3c:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)data;

	wmi_event(sc->tgt_wmi_handle, WMI_FATAL_EVENTID, NULL, 0);
  906c3f:	c0c0      	movi.n	a12, 0
  906c41:	8a23      	l32i.n	a10, a2, 12
  906c43:	1b729d        	l32r	a11, 8e36b8 <bStandardCommand+0x42c>
  906c46:	0ccd02        	or	a13, a12, a12
  906c49:	5bffe8        	call8	906bec <wmi_event>
  906c4c:	d10f      	retw.n
	...

00906c50 <ath_bmiss_tasklet>:
}

static void ath_bmiss_tasklet(TQUEUE_ARG data)
{
  906c50:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)data;

	wmi_event(sc->tgt_wmi_handle, WMI_BMISS_EVENTID, NULL, 0);
  906c53:	c0c0      	movi.n	a12, 0
  906c55:	8a23      	l32i.n	a10, a2, 12
  906c57:	1b729e        	l32r	a11, 8e36d0 <bStandardCommand+0x444>
  906c5a:	0ccd02        	or	a13, a12, a12
  906c5d:	5bffe3        	call8	906bec <wmi_event>
  906c60:	d10f      	retw.n
	...

00906c64 <ath_intr>:
/**********************/
/* Interrupt Handling */
/**********************/

adf_os_irq_resp_t ath_intr(adf_drv_handle_t hdl)
{
  906c64:	6c100a        	entry	a1, 80
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)hdl;
	struct ath_hal *ah = sc->sc_ah;
  906c67:	232d05        	addmi	a3, a2, 0x500
  906c6a:	843b      	l32i.n	a4, a3, 44
	HAL_INT status;

	if (sc->sc_invalid)
  906c6c:	252249        	l32i	a5, a2, 0x124
  906c6f:	137246        	l32r	a3, 8e3588 <bStandardCommand+0x2fc>
  906c72:	035501        	and	a5, a5, a3
  906c75:	645004        	beqz	a5, 906c7d <ath_intr+0x19>
		return ADF_OS_IRQ_NONE;
  906c78:	c030      	movi.n	a3, 0
  906c7a:	6006d2        	j	907350 <ath_intr+0x6ec>

	if (!ah->ah_isInterruptPending(ah))
  906c7d:	234226        	l32i	a3, a4, 152
  906c80:	da40      	mov.n	a10, a4
  906c82:	0b3000        	callx8	a3
  906c85:	64afef        	beqz	a10, 906c78 <ath_intr+0x14>
		return ADF_OS_IRQ_NONE;

	ah->ah_getPendingInterrupts(ah, &status);
  906c88:	234227        	l32i	a3, a4, 156
  906c8b:	044a02        	or	a10, a4, a4
  906c8e:	2b1c18        	addi	a11, a1, 24
  906c91:	0b3000        	callx8	a3

	status &= sc->sc_imask;
  906c94:	8316      	l32i.n	a3, a1, 24
  906c96:	2622c4        	l32i	a6, a2, 0x310
  906c99:	036301        	and	a3, a6, a3
  906c9c:	9316      	s32i.n	a3, a1, 24

	if (status & HAL_INT_FATAL) {
  906c9e:	713617        	bbci	a3, 1, 906cb9 <ath_intr+0x55>
		ah->ah_setInterrupts(ah, 0);
  906ca1:	234228        	l32i	a3, a4, 160
  906ca4:	db50      	mov.n	a11, a5
  906ca6:	044a02        	or	a10, a4, a4
  906ca9:	0b3000        	callx8	a3
 * @param[in] bh    bottom instance
 */
static inline void 
adf_os_sched_bh(adf_os_handle_t hdl, adf_os_bh_t *bh)
{
    __adf_os_sched_bh(hdl, bh);
  906cac:	2a3a44        	movi	a10, 0x344
  906caf:	aa2a      	add.n	a10, a2, a10
  906cb1:	5bfe6f        	call8	906670 <__adf_os_sched_bh$isra$5>

		if (status & HAL_INT_CST)
			sc->sc_int_stats.ast_cst++;
	}

	return ADF_OS_IRQ_HANDLED;
  906cb4:	c031      	movi.n	a3, 1
  906cb6:	600696        	j	907350 <ath_intr+0x6ec>

	if (status & HAL_INT_FATAL) {
		ah->ah_setInterrupts(ah, 0);
		ATH_SCHEDULE_TQUEUE(sc->sc_dev, &sc->sc_fataltq);
	} else {
		if (status & HAL_INT_SWBA) {
  906cb9:	7f3643        	bbci	a3, 15, 906d00 <ath_intr+0x9c>
			WMI_SWBA_EVENT swbaEvt;
			struct ath_txq *txq = ATH_TXQ(sc, 8);

			swbaEvt.tsf = ah->ah_getTsf64(ah);
  906cbc:	23421e        	l32i	a3, a4, 120
  906cbf:	da40      	mov.n	a10, a4
  906cc1:	0b3000        	callx8	a3
  906cc4:	9a13      	s32i.n	a10, a1, 12
  906cc6:	9b14      	s32i.n	a11, a1, 16
			swbaEvt.beaconPendingCount = ah->ah_numTxPending(ah, sc->sc_bhalq);
  906cc8:	252d01        	addmi	a5, a2, 0x100
  906ccb:	834b      	l32i.n	a3, a4, 44
  906ccd:	2b501c        	l8ui	a11, a5, 28
  906cd0:	da40      	mov.n	a10, a4
  906cd2:	0b3000        	callx8	a3
			sc->sc_swba_tsf = ah->ah_getTsf64(ah);
  906cd5:	23421e        	l32i	a3, a4, 120
		if (status & HAL_INT_SWBA) {
			WMI_SWBA_EVENT swbaEvt;
			struct ath_txq *txq = ATH_TXQ(sc, 8);

			swbaEvt.tsf = ah->ah_getTsf64(ah);
			swbaEvt.beaconPendingCount = ah->ah_numTxPending(ah, sc->sc_bhalq);
  906cd8:	2a1414        	s8i	a10, a1, 20
			sc->sc_swba_tsf = ah->ah_getTsf64(ah);
  906cdb:	044a02        	or	a10, a4, a4
  906cde:	0b3000        	callx8	a3
  906ce1:	232d16        	addmi	a3, a2, 0x1600
  906ce4:	9a3c      	s32i.n	a10, a3, 48
  906ce6:	9b3d      	s32i.n	a11, a3, 52

			wmi_event(sc->tgt_wmi_handle,
  906ce8:	8a23      	l32i.n	a10, a2, 12
  906cea:	1b729f        	l32r	a11, 8e3768 <bStandardCommand+0x4dc>
  906ced:	bc1c      	addi.n	a12, a1, 12
  906cef:	c0d9      	movi.n	a13, 9
  906cf1:	5bffbe        	call8	906bec <wmi_event>
	ah->ah_stopTxDma(ah, txq->axq_qnum);
}

static void owltgt_txq_drain(struct ath_softc_tgt *sc, struct ath_txq *txq)
{
	owltgt_tx_processq(sc, txq, OWL_TXQ_STOPPED);
  906cf4:	2b4acc        	movi	a11, 0x4cc
  906cf7:	da20      	mov.n	a10, a2
  906cf9:	ab2b      	add.n	a11, a2, a11
  906cfb:	c0c1      	movi.n	a12, 1
  906cfd:	580f66        	call8	90aa98 <owltgt_tx_processq>
				  sizeof(WMI_SWBA_EVENT));

			ath_tx_draintxq(sc, txq);
		}

		if (status & HAL_INT_RXORN)
  906d00:	8316      	l32i.n	a3, a1, 24
  906d02:	7a3707        	bbci	a3, 26, 906d0d <ath_intr+0xa9>
			sc->sc_int_stats.ast_rxorn++;
  906d05:	25224d        	l32i	a5, a2, 0x134
  906d08:	b155      	addi.n	a5, a5, 1
  906d0a:	25264d        	s32i	a5, a2, 0x134

		if (status & HAL_INT_RXEOL)
  906d0d:	7b3708        	bbci	a3, 27, 906d19 <ath_intr+0xb5>
			sc->sc_int_stats.ast_rxeol++;
  906d10:	25224e        	l32i	a5, a2, 0x138
  906d13:	255c01        	addi	a5, a5, 1
  906d16:	25264e        	s32i	a5, a2, 0x138

		if (status & (HAL_INT_RX | HAL_INT_RXEOL | HAL_INT_RXORN)) {
  906d19:	c351      	movi.n	a5, 49
  906d1b:	753802        	bany	a3, a5, 906d21 <ath_intr+0xbd>
  906d1e:	6005e8        	j	90730a <ath_intr+0x6a6>
			if (status & HAL_INT_RX)
  906d21:	7f3708        	bbci	a3, 31, 906d2d <ath_intr+0xc9>
				sc->sc_int_stats.ast_rx++;
  906d24:	23224c        	l32i	a3, a2, 0x130
  906d27:	233c01        	addi	a3, a3, 1
  906d2a:	23264c        	s32i	a3, a2, 0x130
	}
}

static void ath_uapsd_processtriggers(struct ath_softc_tgt *sc)
{
	struct ath_hal *ah = sc->sc_ah;
  906d2d:	232d05        	addmi	a3, a2, 0x500
  906d30:	833b      	l32i.n	a3, a3, 44
  906d32:	9318      	s32i.n	a3, a1, 32

#define	PA2DESC(_sc, _pa)						\
	((struct ath_desc *)((caddr_t)(_sc)->sc_rxdma.dd_desc +		\
			     ((_pa) - (_sc)->sc_rxdma.dd_desc_paddr)))

	tsf = ah->ah_getTsf64(ah);
  906d34:	8a18      	l32i.n	a10, a1, 32
  906d36:	23321e        	l32i	a3, a3, 120
  906d39:	0b3000        	callx8	a3
	bf = asf_tailq_first(&sc->sc_rxbuf);

	ds = asf_tailq_first(&sc->sc_rxdesc);
  906d3c:	2822d9        	l32i	a8, a2, 0x364
#define	PA2DESC(_sc, _pa)						\
	((struct ath_desc *)((caddr_t)(_sc)->sc_rxdma.dd_desc +		\
			     ((_pa) - (_sc)->sc_rxdma.dd_desc_paddr)))

	tsf = ah->ah_getTsf64(ah);
	bf = asf_tailq_first(&sc->sc_rxbuf);
  906d3f:	2622d5        	l32i	a6, a2, 0x354

	ds = asf_tailq_first(&sc->sc_rxdesc);
	ds_head = ds;
  906d42:	d380      	mov.n	a3, a8
  906d44:	600371        	j	9070b9 <ath_intr+0x455>
  906d47:	001972        	excw

	while(ds) {
		++cnt;

		if (cnt == ath_numrxbufs - 1) {
  906d4a:	a0b1      	add.n	a1, a11, a0

	ds = asf_tailq_first(&sc->sc_rxdesc);
	ds_head = ds;

	while(ds) {
		++cnt;
  906d4c:	778a90        	bge	a8, a7, 906ce0 <ath_intr+0x7c>

		if (cnt == ath_numrxbufs - 1) {
  906d4f:	b0aa      	addi.n	a10, a10, -1
  906d51:	7a7102        	beq	a7, a10, 906d57 <ath_intr+0xf3>
  906d54:	600251        	j	906fa9 <ath_intr+0x345>
			adf_os_print("VERY LONG PACKET!!!!!\n");
  906d57:	177184        	l32r	a7, 8e3368 <bStandardCommand+0xdc>
  906d5a:	1a72a1        	l32r	a10, 8e37e0 <bStandardCommand+0x554>
  906d5d:	257212        	l32i	a5, a7, 72
  906d60:	981b      	s32i.n	a8, a1, 44
  906d62:	0b5000        	callx8	a5
			ds_tail = ds;
			ds_tmp = ds_head;
			while (ds_tmp) {
  906d65:	881b      	l32i.n	a8, a1, 44
  906d67:	cd3e      	bnez.n	a3, 906d89 <ath_intr+0x125>
			if (status & HAL_INT_RX)
				sc->sc_int_stats.ast_rx++;

			ath_uapsd_processtriggers(sc);

			sc->sc_imask &= ~HAL_INT_RX;
  906d69:	2322c4        	l32i	a3, a2, 0x310
  906d6c:	c7be      	movi.n	a11, -2
  906d6e:	03bb01        	and	a11, a11, a3
			ah->ah_setInterrupts(ah, sc->sc_imask);
  906d71:	234228        	l32i	a3, a4, 160
			if (status & HAL_INT_RX)
				sc->sc_int_stats.ast_rx++;

			ath_uapsd_processtriggers(sc);

			sc->sc_imask &= ~HAL_INT_RX;
  906d74:	2b26c4        	s32i	a11, a2, 0x310
			ah->ah_setInterrupts(ah, sc->sc_imask);
  906d77:	da40      	mov.n	a10, a4
  906d79:	0b3000        	callx8	a3
  906d7c:	2a3a14        	movi	a10, 0x314
  906d7f:	aa2a      	add.n	a10, a2, a10
  906d81:	5bfe3b        	call8	906670 <__adf_os_sched_bh$isra$5>
  906d84:	600582        	j	90730a <ath_intr+0x6a6>
  906d87:	000029        	excw
			adf_os_print("VERY LONG PACKET!!!!!\n");
			ds_tail = ds;
			ds_tmp = ds_head;
			while (ds_tmp) {
				struct ath_rx_desc *ds_rmv;
				adf_nbuf_unmap(sc->sc_dev, ds_tmp->ds_dmap, ADF_OS_DMA_FROM_DEVICE);
  906d8a:	303826        	excw
  906d8d:	303925        	excw
  906d90:	303a08        	excw
  906d93:	9910      	s32i.n	a9, a1, 0
  906d95:	006611        	slli	a6, a6, 16
  906d98:	096602        	or	a6, a6, a9
  906d9b:	2b303b        	l8ui	a11, a3, 59
  906d9e:	085511        	slli	a5, a5, 8
  906da1:	065502        	or	a5, a5, a6
static inline void
adf_nbuf_unmap(adf_os_device_t      osdev, 
               adf_os_dma_map_t     bmap, 
               adf_os_dma_dir_t     dir)
{
    __adf_nbuf_unmap(osdev, bmap, dir);
  906da4:	2a2246        	l32i	a10, a2, 0x118
  906da7:	05bb02        	or	a11, a11, a5
  906daa:	c0c1      	movi.n	a12, 1
  906dac:	981b      	s32i.n	a8, a1, 44
  906dae:	5bf1ce        	call8	9034e8 <__adf_nbuf_unmap>
				ds_rmv = ds_tmp;
				ds_tmp = asf_tailq_next(ds_tmp, ds_list);
  906db1:	29304c        	l8ui	a9, a3, 76
  906db4:	25304d        	l8ui	a5, a3, 77
  906db7:	26304e        	l8ui	a6, a3, 78
  906dba:	089910        	slli	a9, a9, 24
  906dbd:	005511        	slli	a5, a5, 16
  906dc0:	095502        	or	a5, a5, a9
  906dc3:	086611        	slli	a6, a6, 8
  906dc6:	056602        	or	a6, a6, a5
  906dc9:	25304f        	l8ui	a5, a3, 79

				if (ds_tmp == NULL) {
  906dcc:	881b      	l32i.n	a8, a1, 44
			ds_tmp = ds_head;
			while (ds_tmp) {
				struct ath_rx_desc *ds_rmv;
				adf_nbuf_unmap(sc->sc_dev, ds_tmp->ds_dmap, ADF_OS_DMA_FROM_DEVICE);
				ds_rmv = ds_tmp;
				ds_tmp = asf_tailq_next(ds_tmp, ds_list);
  906dce:	065602        	or	a6, a5, a6

				if (ds_tmp == NULL) {
  906dd1:	cc6b      	bnez.n	a6, 906de0 <ath_intr+0x17c>
					adf_os_print("ds_tmp is NULL\n");
  906dd3:	227212        	l32i	a2, a7, 72
  906dd6:	1a72a2        	l32r	a10, 8e3860 <bStandardCommand+0x5d4>
  906dd9:	0b2000        	callx8	a2
  906ddc:	63fffc        	j	906ddc <ath_intr+0x178>
  906ddf:	002a30        	excw
					adf_os_assert(0);
				}

				BUF_Pool_free_buf(sc->pool_handle, POOL_ID_WLAN_RX_BUF, ds_rmv->ds_nbuf);
  906de2:	342530        	excw
  906de5:	352930        	excw
  906de8:	3608aa        	excw
  906deb:	100055        	l32r	a0, 8c6f40 <_bss_end+0x3b9738>
  906dee:	110a55        	l32r	a1, 8c9744 <_bss_end+0x3bbf3c>
  906df1:	022c30        	excw
  906df4:	370899        	excw
  906df7:	110599        	l32r	a1, 8c845c <_bss_end+0x3bac54>
  906dfa:	028a20        	excw
  906dfd:	2572a3        	l32i	a5, a7, 0x28c
  906e00:	09cc02        	or	a12, a12, a9
  906e03:	981b      	s32i.n	a8, a1, 44
  906e05:	c0b3      	movi.n	a11, 3
  906e07:	0b5000        	callx8	a5
				ds_rmv->ds_nbuf = ADF_NBUF_NULL;
  906e0a:	c050      	movi.n	a5, 0
  906e0c:	253434        	s8i	a5, a3, 52
  906e0f:	253435        	s8i	a5, a3, 53
  906e12:	253436        	s8i	a5, a3, 54
  906e15:	253437        	s8i	a5, a3, 55

				if (ath_rxdesc_init(sc, ds_rmv) == 0) {
  906e18:	da20      	mov.n	a10, a2
  906e1a:	033b02        	or	a11, a3, a3
  906e1d:	5bfec2        	call8	906928 <ath_rxdesc_init>
  906e20:	29304d        	l8ui	a9, a3, 77
  906e23:	25304c        	l8ui	a5, a3, 76
					asf_tailq_remove(&sc->sc_rxdesc, ds_rmv, ds_list);
  906e26:	009911        	slli	a9, a9, 16
  906e29:	085510        	slli	a5, a5, 24
  906e2c:	059902        	or	a9, a9, a5
  906e2f:	25304e        	l8ui	a5, a3, 78
				}

				BUF_Pool_free_buf(sc->pool_handle, POOL_ID_WLAN_RX_BUF, ds_rmv->ds_nbuf);
				ds_rmv->ds_nbuf = ADF_NBUF_NULL;

				if (ath_rxdesc_init(sc, ds_rmv) == 0) {
  906e32:	881b      	l32i.n	a8, a1, 44
					asf_tailq_remove(&sc->sc_rxdesc, ds_rmv, ds_list);
  906e34:	085511        	slli	a5, a5, 8
  906e37:	095502        	or	a5, a5, a9
  906e3a:	29304f        	l8ui	a9, a3, 79
  906e3d:	059502        	or	a5, a9, a5
  906e40:	293050        	l8ui	a9, a3, 80
				}

				BUF_Pool_free_buf(sc->pool_handle, POOL_ID_WLAN_RX_BUF, ds_rmv->ds_nbuf);
				ds_rmv->ds_nbuf = ADF_NBUF_NULL;

				if (ath_rxdesc_init(sc, ds_rmv) == 0) {
  906e43:	65a0ad        	bnez	a10, 906ef4 <ath_intr+0x290>
  906e46:	2a3051        	l8ui	a10, a3, 81
					asf_tailq_remove(&sc->sc_rxdesc, ds_rmv, ds_list);
  906e49:	089910        	slli	a9, a9, 24
  906e4c:	00aa11        	slli	a10, a10, 16
  906e4f:	09aa02        	or	a10, a10, a9
  906e52:	293052        	l8ui	a9, a3, 82
  906e55:	089911        	slli	a9, a9, 8
  906e58:	0a9902        	or	a9, a9, a10
  906e5b:	c95d      	beqz.n	a5, 906e7c <ath_intr+0x218>
  906e5d:	2a3053        	l8ui	a10, a3, 83
  906e60:	09a902        	or	a9, a10, a9
  906e63:	098a57        	extui	a10, a9, 24, 8
  906e66:	2a5450        	s8i	a10, a5, 80
  906e69:	090a57        	extui	a10, a9, 16, 8
  906e6c:	2a5451        	s8i	a10, a5, 81
  906e6f:	098a47        	extui	a10, a9, 8, 8
  906e72:	2a5452        	s8i	a10, a5, 82
  906e75:	295453        	s8i	a9, a5, 83
  906e78:	600009        	j	906e85 <ath_intr+0x221>
  906e7b:	002530        	excw
  906e7e:	530959        	call0	8c93e4 <_bss_end+0x3bbbdc>
  906e81:	022926        	excw
  906e84:	da2a      	excw
  906e86:	305029        	excw
  906e89:	305125        	excw
  906e8c:	305208        	excw
  906e8f:	aa10      	add.n	a0, a1, a10
  906e91:	009911        	slli	a9, a9, 16
  906e94:	0a9902        	or	a9, a9, a10
  906e97:	085511        	slli	a5, a5, 8
  906e9a:	095502        	or	a5, a5, a9
  906e9d:	293053        	l8ui	a9, a3, 83
  906ea0:	2b304c        	l8ui	a11, a3, 76
  906ea3:	2a304d        	l8ui	a10, a3, 77
  906ea6:	059502        	or	a5, a9, a5
  906ea9:	29304e        	l8ui	a9, a3, 78
  906eac:	08bb10        	slli	a11, a11, 24
  906eaf:	00aa11        	slli	a10, a10, 16
  906eb2:	0baa02        	or	a10, a10, a11
  906eb5:	089911        	slli	a9, a9, 8
  906eb8:	0a9902        	or	a9, a9, a10
  906ebb:	2a304f        	l8ui	a10, a3, 79
  906ebe:	09a902        	or	a9, a10, a9
  906ec1:	9950      	s32i.n	a9, a5, 0
					asf_tailq_insert_tail(&sc->sc_rxdesc, ds_rmv, ds_list);
  906ec3:	c050      	movi.n	a5, 0
  906ec5:	25344c        	s8i	a5, a3, 76
  906ec8:	25344d        	s8i	a5, a3, 77
  906ecb:	25344e        	s8i	a5, a3, 78
  906ece:	25344f        	s8i	a5, a3, 79
  906ed1:	2522da        	l32i	a5, a2, 0x368
  906ed4:	058957        	extui	a9, a5, 24, 8
  906ed7:	293450        	s8i	a9, a3, 80
  906eda:	050957        	extui	a9, a5, 16, 8
  906edd:	293451        	s8i	a9, a3, 81
  906ee0:	058947        	extui	a9, a5, 8, 8
  906ee3:	253453        	s8i	a5, a3, 83
  906ee6:	293452        	s8i	a9, a3, 82
  906ee9:	9350      	s32i.n	a3, a5, 0
  906eeb:	253c4c        	addi	a5, a3, 76
  906eee:	2526da        	s32i	a5, a2, 0x368
  906ef1:	6000a9        	j	906f9e <ath_intr+0x33a>
  906ef4:	2a3051        	l8ui	a10, a3, 81
				}
				else {
					asf_tailq_remove(&sc->sc_rxdesc, ds_rmv, ds_list);
  906ef7:	089910        	slli	a9, a9, 24
  906efa:	00aa11        	slli	a10, a10, 16
  906efd:	09aa02        	or	a10, a10, a9
  906f00:	293052        	l8ui	a9, a3, 82
  906f03:	089911        	slli	a9, a9, 8
  906f06:	0a9902        	or	a9, a9, a10
  906f09:	c95c      	beqz.n	a5, 906f29 <ath_intr+0x2c5>
  906f0b:	2a3053        	l8ui	a10, a3, 83
  906f0e:	09a902        	or	a9, a10, a9
  906f11:	098a57        	extui	a10, a9, 24, 8
  906f14:	2a5450        	s8i	a10, a5, 80
  906f17:	090a57        	extui	a10, a9, 16, 8
  906f1a:	2a5451        	s8i	a10, a5, 81
  906f1d:	098a47        	extui	a10, a9, 8, 8
  906f20:	2a5452        	s8i	a10, a5, 82
  906f23:	295453        	s8i	a9, a5, 83
  906f26:	600008        	j	906f32 <ath_intr+0x2ce>
  906f29:	253053        	l8ui	a5, a3, 83
  906f2c:	095902        	or	a9, a5, a9
  906f2f:	2926da        	s32i	a9, a2, 0x368
  906f32:	2a3050        	l8ui	a10, a3, 80
  906f35:	293051        	l8ui	a9, a3, 81
  906f38:	253052        	l8ui	a5, a3, 82
  906f3b:	08aa10        	slli	a10, a10, 24
  906f3e:	009911        	slli	a9, a9, 16
  906f41:	0a9902        	or	a9, a9, a10
  906f44:	085511        	slli	a5, a5, 8
  906f47:	095502        	or	a5, a5, a9
  906f4a:	293053        	l8ui	a9, a3, 83
  906f4d:	2b304c        	l8ui	a11, a3, 76
  906f50:	2a304d        	l8ui	a10, a3, 77
  906f53:	059502        	or	a5, a9, a5
  906f56:	29304e        	l8ui	a9, a3, 78
  906f59:	08bb10        	slli	a11, a11, 24
  906f5c:	00aa11        	slli	a10, a10, 16
  906f5f:	0baa02        	or	a10, a10, a11
  906f62:	089911        	slli	a9, a9, 8
  906f65:	0a9902        	or	a9, a9, a10
  906f68:	2a304f        	l8ui	a10, a3, 79
  906f6b:	09a902        	or	a9, a10, a9
  906f6e:	9950      	s32i.n	a9, a5, 0
					asf_tailq_insert_tail(&sc->sc_rxdesc_idle, ds_rmv, ds_list);
  906f70:	c050      	movi.n	a5, 0
  906f72:	25344c        	s8i	a5, a3, 76
  906f75:	25344d        	s8i	a5, a3, 77
  906f78:	25344e        	s8i	a5, a3, 78
  906f7b:	25344f        	s8i	a5, a3, 79
  906f7e:	2522d8        	l32i	a5, a2, 0x360
  906f81:	058957        	extui	a9, a5, 24, 8
  906f84:	293450        	s8i	a9, a3, 80
  906f87:	050957        	extui	a9, a5, 16, 8
  906f8a:	293451        	s8i	a9, a3, 81
  906f8d:	058947        	extui	a9, a5, 8, 8
  906f90:	253453        	s8i	a5, a3, 83
  906f93:	293452        	s8i	a9, a3, 82
  906f96:	9350      	s32i.n	a3, a5, 0
  906f98:	253c4c        	addi	a5, a3, 76
  906f9b:	2526d8        	s32i	a5, a2, 0x360
				}

				if (ds_rmv == ds_tail) {
  906f9e:	783902        	bne	a3, a8, 906fa4 <ath_intr+0x340>
  906fa1:	63fdc4        	j	906d69 <ath_intr+0x105>
			ds_tmp = ds_head;
			while (ds_tmp) {
				struct ath_rx_desc *ds_rmv;
				adf_nbuf_unmap(sc->sc_dev, ds_tmp->ds_dmap, ADF_OS_DMA_FROM_DEVICE);
				ds_rmv = ds_tmp;
				ds_tmp = asf_tailq_next(ds_tmp, ds_list);
  906fa4:	d360      	mov.n	a3, a6
  906fa6:	63fddf        	j	906d89 <ath_intr+0x125>
				}
			}
			break;
		}

		if (ds->ds_link == 0) {
  906fa9:	2b8000        	l8ui	a11, a8, 0
  906fac:	2a8001        	l8ui	a10, a8, 1
  906faf:	2e8002        	l8ui	a14, a8, 2
  906fb2:	08bb10        	slli	a11, a11, 24
  906fb5:	00aa11        	slli	a10, a10, 16
  906fb8:	0baa02        	or	a10, a10, a11
  906fbb:	08ee11        	slli	a14, a14, 8
  906fbe:	0aee02        	or	a14, a14, a10
  906fc1:	2a8003        	l8ui	a10, a8, 3
  906fc4:	0eae02        	or	a14, a10, a14
  906fc7:	64ed9e        	beqz	a14, 906d69 <ath_intr+0x105>
			break;
		}

		if (bf->bf_status & ATH_BUFSTATUS_DONE) {
  906fca:	8a6f      	l32i.n	a10, a6, 60
  906fcc:	7fa702        	bbci	a10, 31, 906fd2 <ath_intr+0x36e>
  906fcf:	60032f        	j	907302 <ath_intr+0x69e>
			continue;
		}

		retval = ah->ah_procRxDescFast(ah, ds, ds->ds_daddr,
  906fd2:	2b8048        	l8ui	a11, a8, 72
  906fd5:	2a8049        	l8ui	a10, a8, 73
  906fd8:	08bb10        	slli	a11, a11, 24
  906fdb:	00aa11        	slli	a10, a10, 16
  906fde:	0baa02        	or	a10, a10, a11
  906fe1:	2b804a        	l8ui	a11, a8, 74
						PA2DESC(sc, ds->ds_link), &bf->bf_rx_status);
  906fe4:	2d22de        	l32i	a13, a2, 0x378

		if (bf->bf_status & ATH_BUFSTATUS_DONE) {
			continue;
		}

		retval = ah->ah_procRxDescFast(ah, ds, ds->ds_daddr,
  906fe7:	08bb11        	slli	a11, a11, 8
  906fea:	0ab902        	or	a9, a11, a10
						PA2DESC(sc, ds->ds_link), &bf->bf_rx_status);
  906fed:	2a22e0        	l32i	a10, a2, 0x380

		if (bf->bf_status & ATH_BUFSTATUS_DONE) {
			continue;
		}

		retval = ah->ah_procRxDescFast(ah, ds, ds->ds_daddr,
  906ff0:	2c804b        	l8ui	a12, a8, 75
						PA2DESC(sc, ds->ds_link), &bf->bf_rx_status);
  906ff3:	0add0c        	sub	a13, a13, a10

		if (bf->bf_status & ATH_BUFSTATUS_DONE) {
			continue;
		}

		retval = ah->ah_procRxDescFast(ah, ds, ds->ds_daddr,
  906ff6:	8a18      	l32i.n	a10, a1, 32
  906ff8:	db80      	mov.n	a11, a8
  906ffa:	2fa222        	l32i	a15, a10, 136
  906ffd:	aedd      	add.n	a13, a13, a14
  906fff:	981b      	s32i.n	a8, a1, 44
  907001:	09cc02        	or	a12, a12, a9
  907004:	2e6c40        	addi	a14, a6, 64
  907007:	0bf000        	callx8	a15
						PA2DESC(sc, ds->ds_link), &bf->bf_rx_status);
		if (HAL_EINPROGRESS == retval) {
  90700a:	c0bf      	movi.n	a11, 15
  90700c:	881b      	l32i.n	a8, a1, 44
  90700e:	7ba902        	bne	a10, a11, 907014 <ath_intr+0x3b0>
  907011:	63fd54        	j	906d69 <ath_intr+0x105>
			break;
		}

		if (adf_nbuf_len(ds->ds_nbuf) == 0) {
  907014:	2c8034        	l8ui	a12, a8, 52
  907017:	2b8035        	l8ui	a11, a8, 53
  90701a:	2a8036        	l8ui	a10, a8, 54
  90701d:	08cc10        	slli	a12, a12, 24
  907020:	00bb11        	slli	a11, a11, 16
  907023:	0cbb02        	or	a11, a11, a12
  907026:	08aa11        	slli	a10, a10, 8
  907029:	0baa02        	or	a10, a10, a11
  90702c:	2b8037        	l8ui	a11, a8, 55
 * @return The total length of this buf.
 */
static inline adf_os_size_t
adf_nbuf_len(adf_nbuf_t buf)
{
    return (__adf_nbuf_len(buf));
  90702f:	0aba02        	or	a10, a11, a10
  907032:	5bf193        	call8	903680 <__adf_nbuf_len>
  907035:	881b      	l32i.n	a8, a1, 44
  907037:	cea5      	bnez.n	a10, 907060 <ath_intr+0x3fc>
			adf_nbuf_put_tail(ds->ds_nbuf, bf->bf_rx_status.rs_datalen);
  907039:	2c8034        	l8ui	a12, a8, 52
  90703c:	2b8035        	l8ui	a11, a8, 53
  90703f:	2a8036        	l8ui	a10, a8, 54
  907042:	08cc10        	slli	a12, a12, 24
  907045:	00bb11        	slli	a11, a11, 16
  907048:	0cbb02        	or	a11, a11, a12
  90704b:	08aa11        	slli	a10, a10, 8
  90704e:	0baa02        	or	a10, a10, a11
  907051:	2b8037        	l8ui	a11, a8, 55
 *         put, or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_put_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_put_tail(buf, size);
  907054:	0aba02        	or	a10, a11, a10
  907057:	2b6124        	l16ui	a11, a6, 72
  90705a:	5bf175        	call8	903630 <__adf_nbuf_put_tail>
  90705d:	28120b        	l32i	a8, a1, 44
		}

		frame_len += bf->bf_rx_status.rs_datalen;
  907060:	2a6124        	l16ui	a10, a6, 72

		if (bf->bf_rx_status.rs_more == 0) {
  907063:	2d6056        	l8ui	a13, a6, 86

		if (adf_nbuf_len(ds->ds_nbuf) == 0) {
			adf_nbuf_put_tail(ds->ds_nbuf, bf->bf_rx_status.rs_datalen);
		}

		frame_len += bf->bf_rx_status.rs_datalen;
  907066:	aa55      	add.n	a5, a5, a10
  907068:	05054f        	extui	a5, a5, 0, 16

		if (bf->bf_rx_status.rs_more == 0) {
  90706b:	65d275        	bnez	a13, 9072e4 <ath_intr+0x680>
 * @param[in] head  buf queue head
 */
static inline void
adf_nbuf_queue_init(adf_nbuf_queue_t *head)
{
    __adf_nbuf_queue_init(head);
  90706e:	da10      	mov.n	a10, a1
  907070:	981b      	s32i.n	a8, a1, 44
  907072:	2d160a        	s32i	a13, a1, 40
  907075:	5bf190        	call8	9036b8 <__adf_nbuf_queue_init>
			adf_nbuf_queue_init(&nbuf_head);

			cnt = 0;

			ds_tail = ds;
			ds = asf_tailq_next(ds, ds_list);
  907078:	881b      	l32i.n	a8, a1, 44
			while (ds_tmp) {
				struct ath_rx_desc *ds_rmv;

				adf_nbuf_unmap(sc->sc_dev, ds_tmp->ds_dmap, ADF_OS_DMA_FROM_DEVICE);
				adf_nbuf_queue_add(&nbuf_head, ds_tmp->ds_nbuf);
				ds_tmp->ds_nbuf = ADF_NBUF_NULL;
  90707a:	8d1a      	l32i.n	a13, a1, 40
			adf_nbuf_queue_init(&nbuf_head);

			cnt = 0;

			ds_tail = ds;
			ds = asf_tailq_next(ds, ds_list);
  90707c:	2b804c        	l8ui	a11, a8, 76
  90707f:	2a804d        	l8ui	a10, a8, 77
  907082:	27804e        	l8ui	a7, a8, 78
  907085:	08bb10        	slli	a11, a11, 24
  907088:	00aa11        	slli	a10, a10, 16
  90708b:	0baa02        	or	a10, a10, a11
  90708e:	087711        	slli	a7, a7, 8
  907091:	0a7702        	or	a7, a7, a10
  907094:	2a804f        	l8ui	a10, a8, 79
  907097:	07aa02        	or	a10, a10, a7
  90709a:	9a19      	s32i.n	a10, a1, 36
			while (ds_tmp) {
				struct ath_rx_desc *ds_rmv;

				adf_nbuf_unmap(sc->sc_dev, ds_tmp->ds_dmap, ADF_OS_DMA_FROM_DEVICE);
				adf_nbuf_queue_add(&nbuf_head, ds_tmp->ds_nbuf);
				ds_tmp->ds_nbuf = ADF_NBUF_NULL;
  90709c:	d7d0      	mov.n	a7, a13
			ds = asf_tailq_next(ds, ds_list);

			ds_tmp = ds_head;
			ds_head = asf_tailq_next(ds_tail, ds_list);

			while (ds_tmp) {
  90709e:	cd3f      	bnez.n	a3, 9070c1 <ath_intr+0x45d>
					break;
				}
			}


			bf->bf_rx_status.rs_datalen = frame_len;
  9070a0:	256524        	s16i	a5, a6, 72
}

static inline adf_nbuf_t
adf_nbuf_create_frm_frag(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_create_frm_frag(head);
  9070a3:	da10      	mov.n	a10, a1
  9070a5:	5bf124        	call8	903538 <__adf_nbuf_create_frm_frag>
			frame_len = 0;

			bf->bf_skb = adf_nbuf_create_frm_frag(&nbuf_head);

			bf->bf_status |= ATH_BUFSTATUS_DONE;
  9070a8:	856f      	l32i.n	a5, a6, 60
  9070aa:	c031      	movi.n	a3, 1
  9070ac:	035302        	or	a3, a5, a3
  9070af:	936f      	s32i.n	a3, a6, 60

			ds_tail = ds;
			ds = asf_tailq_next(ds, ds_list);

			ds_tmp = ds_head;
			ds_head = asf_tailq_next(ds_tail, ds_list);
  9070b1:	8319      	l32i.n	a3, a1, 36


			bf->bf_rx_status.rs_datalen = frame_len;
			frame_len = 0;

			bf->bf_skb = adf_nbuf_create_frm_frag(&nbuf_head);
  9070b3:	9a68      	s32i.n	a10, a6, 32

			bf->bf_status |= ATH_BUFSTATUS_DONE;

			bf = (struct ath_rx_buf *)asf_tailq_next(bf, bf_list);
  9070b5:	8669      	l32i.n	a6, a6, 36
			adf_nbuf_queue_init(&nbuf_head);

			cnt = 0;

			ds_tail = ds;
			ds = asf_tailq_next(ds, ds_list);
  9070b7:	d830      	mov.n	a8, a3
				}
			}


			bf->bf_rx_status.rs_datalen = frame_len;
			frame_len = 0;
  9070b9:	c050      	movi.n	a5, 0

		if (bf->bf_rx_status.rs_more == 0) {
			adf_nbuf_queue_t nbuf_head;
			adf_nbuf_queue_init(&nbuf_head);

			cnt = 0;
  9070bb:	d750      	mov.n	a7, a5
  9070bd:	600241        	j	907302 <ath_intr+0x69e>
  9070c0:	002c30        	excw
			ds_head = asf_tailq_next(ds_tail, ds_list);

			while (ds_tmp) {
				struct ath_rx_desc *ds_rmv;

				adf_nbuf_unmap(sc->sc_dev, ds_tmp->ds_dmap, ADF_OS_DMA_FROM_DEVICE);
  9070c3:	382a30        	excw
  9070c6:	392b30        	excw
  9070c9:	3a08cc        	excw
  9070cc:	1000aa        	l32r	a0, 8c7374 <_bss_end+0x3b9b6c>
  9070cf:	110caa        	l32r	a1, 8ca378 <_bss_end+0x3bcb70>
  9070d2:	0208bb        	excw
  9070d5:	112c30        	l32r	a1, 8d2198 <_bss_end+0x3c4990>
  9070d8:	3b0abb        	excw
  9070db:	022a22        	excw
static inline void
adf_nbuf_unmap(adf_os_device_t      osdev, 
               adf_os_dma_map_t     bmap, 
               adf_os_dma_dir_t     dir)
{
    __adf_nbuf_unmap(osdev, bmap, dir);
  9070de:	460bcb        	excw
  9070e1:	02c0c1        	excw
  9070e4:	981b      	s32i.n	a8, a1, 44
  9070e6:	5bf100        	call8	9034e8 <__adf_nbuf_unmap>
				adf_nbuf_queue_add(&nbuf_head, ds_tmp->ds_nbuf);
  9070e9:	2c3034        	l8ui	a12, a3, 52
  9070ec:	2a3035        	l8ui	a10, a3, 53
  9070ef:	2b3036        	l8ui	a11, a3, 54
  9070f2:	08cc10        	slli	a12, a12, 24
  9070f5:	00aa11        	slli	a10, a10, 16
  9070f8:	0caa02        	or	a10, a10, a12
  9070fb:	08bb11        	slli	a11, a11, 8
  9070fe:	2c3037        	l8ui	a12, a3, 55
  907101:	0abb02        	or	a11, a11, a10
 * @param[in] buf   buf
 */
static inline void
adf_nbuf_queue_add(adf_nbuf_queue_t *head, adf_nbuf_t buf)
{
    __adf_nbuf_queue_add(head, buf);
  907104:	0bcb02        	or	a11, a12, a11
  907107:	da10      	mov.n	a10, a1
  907109:	5bf0db        	call8	903478 <__adf_nbuf_queue_add>
				ds_tmp->ds_nbuf = ADF_NBUF_NULL;

				ds_rmv = ds_tmp;
				ds_tmp = asf_tailq_next(ds_tmp, ds_list);
  90710c:	2b304c        	l8ui	a11, a3, 76
  90710f:	2a304d        	l8ui	a10, a3, 77
  907112:	2c304e        	l8ui	a12, a3, 78
  907115:	08bb10        	slli	a11, a11, 24
  907118:	00aa11        	slli	a10, a10, 16
  90711b:	0baa02        	or	a10, a10, a11
  90711e:	08cc11        	slli	a12, a12, 8
  907121:	0acc02        	or	a12, a12, a10
  907124:	2a304f        	l8ui	a10, a3, 79
			while (ds_tmp) {
				struct ath_rx_desc *ds_rmv;

				adf_nbuf_unmap(sc->sc_dev, ds_tmp->ds_dmap, ADF_OS_DMA_FROM_DEVICE);
				adf_nbuf_queue_add(&nbuf_head, ds_tmp->ds_nbuf);
				ds_tmp->ds_nbuf = ADF_NBUF_NULL;
  907127:	273434        	s8i	a7, a3, 52
  90712a:	273435        	s8i	a7, a3, 53
  90712d:	273436        	s8i	a7, a3, 54
  907130:	273437        	s8i	a7, a3, 55

				ds_rmv = ds_tmp;
				ds_tmp = asf_tailq_next(ds_tmp, ds_list);
  907133:	0cac02        	or	a12, a10, a12
				if (ds_tmp == NULL) {
  907136:	881b      	l32i.n	a8, a1, 44
  907138:	ccc1      	bnez.n	a12, 90713d <ath_intr+0x4d9>
  90713a:	63fffc        	j	90713a <ath_intr+0x4d6>
					adf_os_assert(0);
				}

				if (ath_rxdesc_init(sc, ds_rmv) == 0) {
  90713d:	db30      	mov.n	a11, a3
  90713f:	da20      	mov.n	a10, a2
  907141:	981b      	s32i.n	a8, a1, 44
  907143:	9c1a      	s32i.n	a12, a1, 40
  907145:	5bfdf8        	call8	906928 <ath_rxdesc_init>
  907148:	2e304c        	l8ui	a14, a3, 76
  90714b:	2b304d        	l8ui	a11, a3, 77
					asf_tailq_remove(&sc->sc_rxdesc, ds_rmv, ds_list);
  90714e:	08ee10        	slli	a14, a14, 24
  907151:	00bb11        	slli	a11, a11, 16
				ds_tmp = asf_tailq_next(ds_tmp, ds_list);
				if (ds_tmp == NULL) {
					adf_os_assert(0);
				}

				if (ath_rxdesc_init(sc, ds_rmv) == 0) {
  907154:	881b      	l32i.n	a8, a1, 44
  907156:	8c1a      	l32i.n	a12, a1, 40
					asf_tailq_remove(&sc->sc_rxdesc, ds_rmv, ds_list);
  907158:	0ebb02        	or	a11, a11, a14
				ds_tmp = asf_tailq_next(ds_tmp, ds_list);
				if (ds_tmp == NULL) {
					adf_os_assert(0);
				}

				if (ath_rxdesc_init(sc, ds_rmv) == 0) {
  90715b:	65a0bd        	bnez	a10, 90721c <ath_intr+0x5b8>
					asf_tailq_remove(&sc->sc_rxdesc, ds_rmv, ds_list);
  90715e:	2a304e        	l8ui	a10, a3, 78
  907161:	2e3051        	l8ui	a14, a3, 81
  907164:	08aa11        	slli	a10, a10, 8
  907167:	0baa02        	or	a10, a10, a11
  90716a:	2b304f        	l8ui	a11, a3, 79
  90716d:	00ee11        	slli	a14, a14, 16
  907170:	0aba02        	or	a10, a11, a10
  907173:	2b3050        	l8ui	a11, a3, 80
  907176:	08bb10        	slli	a11, a11, 24
  907179:	0bee02        	or	a14, a14, a11
  90717c:	2b3052        	l8ui	a11, a3, 82
  90717f:	08bb11        	slli	a11, a11, 8
  907182:	0ebb02        	or	a11, a11, a14
  907185:	c9ac      	beqz.n	a10, 9071a5 <ath_intr+0x541>
  907187:	2e3053        	l8ui	a14, a3, 83
  90718a:	0beb02        	or	a11, a14, a11
  90718d:	0b8e57        	extui	a14, a11, 24, 8
  907190:	2ea450        	s8i	a14, a10, 80
  907193:	0b0e57        	extui	a14, a11, 16, 8
  907196:	2ea451        	s8i	a14, a10, 81
  907199:	0b8e47        	extui	a14, a11, 8, 8
  90719c:	2ea452        	s8i	a14, a10, 82
  90719f:	2ba453        	s8i	a11, a10, 83
  9071a2:	600008        	j	9071ae <ath_intr+0x54a>
  9071a5:	2a3053        	l8ui	a10, a3, 83
  9071a8:	0bab02        	or	a11, a10, a11
  9071ab:	2b26da        	s32i	a11, a2, 0x368
  9071ae:	2e3050        	l8ui	a14, a3, 80
  9071b1:	2b3051        	l8ui	a11, a3, 81
  9071b4:	2a3052        	l8ui	a10, a3, 82
  9071b7:	08ee10        	slli	a14, a14, 24
  9071ba:	00bb11        	slli	a11, a11, 16
  9071bd:	0ebb02        	or	a11, a11, a14
  9071c0:	08aa11        	slli	a10, a10, 8
  9071c3:	0baa02        	or	a10, a10, a11
  9071c6:	2b3053        	l8ui	a11, a3, 83
  9071c9:	2f304c        	l8ui	a15, a3, 76
  9071cc:	2e304d        	l8ui	a14, a3, 77
  9071cf:	0aba02        	or	a10, a11, a10
  9071d2:	2b304e        	l8ui	a11, a3, 78
  9071d5:	08ff10        	slli	a15, a15, 24
  9071d8:	00ee11        	slli	a14, a14, 16
  9071db:	0fee02        	or	a14, a14, a15
  9071de:	08bb11        	slli	a11, a11, 8
  9071e1:	0ebb02        	or	a11, a11, a14
  9071e4:	2e304f        	l8ui	a14, a3, 79
  9071e7:	0beb02        	or	a11, a14, a11
  9071ea:	9ba0      	s32i.n	a11, a10, 0
					asf_tailq_insert_tail(&sc->sc_rxdesc, ds_rmv, ds_list);
  9071ec:	27344c        	s8i	a7, a3, 76
  9071ef:	27344d        	s8i	a7, a3, 77
  9071f2:	27344e        	s8i	a7, a3, 78
  9071f5:	27344f        	s8i	a7, a3, 79
  9071f8:	2a22da        	l32i	a10, a2, 0x368
  9071fb:	0a8b57        	extui	a11, a10, 24, 8
  9071fe:	2b3450        	s8i	a11, a3, 80
  907201:	0a0b57        	extui	a11, a10, 16, 8
  907204:	2b3451        	s8i	a11, a3, 81
  907207:	0a8b47        	extui	a11, a10, 8, 8
  90720a:	2a3453        	s8i	a10, a3, 83
  90720d:	2b3452        	s8i	a11, a3, 82
  907210:	93a0      	s32i.n	a3, a10, 0
  907212:	2a3c4c        	addi	a10, a3, 76
  907215:	2a26da        	s32i	a10, a2, 0x368
  907218:	6000bb        	j	9072d7 <ath_intr+0x673>
  90721b:	002a30        	excw
				}  else {
					asf_tailq_remove(&sc->sc_rxdesc, ds_rmv, ds_list);
  90721e:	4e2e30        	excw
  907221:	5108aa        	call0	9494cc <_etext+0x3e607>
  907224:	110baa        	l32r	a1, 8ca0cc <_bss_end+0x3bc8c4>
  907227:	022b30        	excw
  90722a:	4f00ee        	excw
  90722d:	110aba        	l32r	a1, 8c9d18 <_bss_end+0x3bc510>
  907230:	022b30        	excw
  907233:	5008bb        	call0	909520 <ath_buf_toggle+0x70>
  907236:	100bee        	l32r	a0, 8ca1f0 <_bss_end+0x3bc9e8>
  907239:	022b30        	excw
  90723c:	5208bb        	call0	88952c <_bss_end+0x37bd24>
  90723f:	110ebb        	l32r	a1, 8cad2c <_bss_end+0x3bd524>
  907242:	02c9ad        	excw
  907245:	2e3053        	l8ui	a14, a3, 83
  907248:	0beb02        	or	a11, a14, a11
  90724b:	0b8e57        	extui	a14, a11, 24, 8
  90724e:	2ea450        	s8i	a14, a10, 80
  907251:	0b0e57        	extui	a14, a11, 16, 8
  907254:	2ea451        	s8i	a14, a10, 81
  907257:	0b8e47        	extui	a14, a11, 8, 8
  90725a:	2ea452        	s8i	a14, a10, 82
  90725d:	2ba453        	s8i	a11, a10, 83
  907260:	600009        	j	90726d <ath_intr+0x609>
  907263:	002a30        	excw
  907266:	530bab        	call0	8ca114 <_bss_end+0x3bc90c>
  907269:	022b26        	excw
  90726c:	da2e      	excw
  90726e:	30502b        	excw
  907271:	30512a        	excw
  907274:	305208        	excw
  907277:	ee          	.byte 0xee
  907278:	1000bb        	l32r	a0, 8c7564 <_bss_end+0x3b9d5c>
  90727b:	110ebb        	l32r	a1, 8cad68 <_bss_end+0x3bd560>
  90727e:	0208aa        	excw
  907281:	110baa        	l32r	a1, 8ca12c <_bss_end+0x3bc924>
  907284:	022b30        	excw
  907287:	532f30        	call0	8d2f48 <_bss_end+0x3c5740>
  90728a:	4c2e30        	excw
  90728d:	4d0aba        	excw
  907290:	022b30        	excw
  907293:	4e08ff        	excw
  907296:	1000ee        	l32r	a0, 8c7650 <_bss_end+0x3b9e48>
  907299:	110fee        	l32r	a1, 8cb254 <_bss_end+0x3bda4c>
  90729c:	0208bb        	excw
  90729f:	110ebb        	l32r	a1, 8cad8c <_bss_end+0x3bd584>
  9072a2:	022e30        	excw
  9072a5:	4f0beb        	excw
  9072a8:	029ba0        	excw
					asf_tailq_insert_tail(&sc->sc_rxdesc_idle, ds_rmv, ds_list);
  9072ab:	27344c        	s8i	a7, a3, 76
  9072ae:	27344d        	s8i	a7, a3, 77
  9072b1:	27344e        	s8i	a7, a3, 78
  9072b4:	27344f        	s8i	a7, a3, 79
  9072b7:	2a22d8        	l32i	a10, a2, 0x360
  9072ba:	0a8b57        	extui	a11, a10, 24, 8
  9072bd:	2b3450        	s8i	a11, a3, 80
  9072c0:	0a0b57        	extui	a11, a10, 16, 8
  9072c3:	2b3451        	s8i	a11, a3, 81
  9072c6:	0a8b47        	extui	a11, a10, 8, 8
  9072c9:	2a3453        	s8i	a10, a3, 83
  9072cc:	2b3452        	s8i	a11, a3, 82
  9072cf:	93a0      	s32i.n	a3, a10, 0
  9072d1:	2a3c4c        	addi	a10, a3, 76
  9072d4:	2a26d8        	s32i	a10, a2, 0x360
				}

				if (ds_rmv == ds_tail) {
  9072d7:	783902        	bne	a3, a8, 9072dd <ath_intr+0x679>
  9072da:	63fdc2        	j	9070a0 <ath_intr+0x43c>
				adf_nbuf_unmap(sc->sc_dev, ds_tmp->ds_dmap, ADF_OS_DMA_FROM_DEVICE);
				adf_nbuf_queue_add(&nbuf_head, ds_tmp->ds_nbuf);
				ds_tmp->ds_nbuf = ADF_NBUF_NULL;

				ds_rmv = ds_tmp;
				ds_tmp = asf_tailq_next(ds_tmp, ds_list);
  9072dd:	d3c0      	mov.n	a3, a12
  9072df:	63fdde        	j	9070c1 <ath_intr+0x45d>
  9072e2:	00002c        	excw
			bf->bf_status |= ATH_BUFSTATUS_DONE;

			bf = (struct ath_rx_buf *)asf_tailq_next(bf, bf_list);
		}
		else {
			ds = asf_tailq_next(ds, ds_list);
  9072e5:	804c      	l32i.n	a0, a4, 48
  9072e7:	2b804d        	l8ui	a11, a8, 77
  9072ea:	2a804e        	l8ui	a10, a8, 78
  9072ed:	08cc10        	slli	a12, a12, 24
  9072f0:	00bb11        	slli	a11, a11, 16
  9072f3:	0cbb02        	or	a11, a11, a12
  9072f6:	08aa11        	slli	a10, a10, 8
  9072f9:	28804f        	l8ui	a8, a8, 79
  9072fc:	0baa02        	or	a10, a10, a11
  9072ff:	0a8802        	or	a8, a8, a10
	bf = asf_tailq_first(&sc->sc_rxbuf);

	ds = asf_tailq_first(&sc->sc_rxdesc);
	ds_head = ds;

	while(ds) {
  907302:	658a42        	bnez	a8, 906d48 <ath_intr+0xe4>
  907305:	63fa60        	j	906d69 <ath_intr+0x105>
  907308:	000083        	excw
			ah->ah_setInterrupts(ah, sc->sc_imask);

			ATH_SCHEDULE_TQUEUE(sc->sc_dev, &sc->sc_rxtq);
		}

		if (status & HAL_INT_TXURN) {
  90730b:	167437        	l32r	a6, 8e43e8 <vdesc_module_install+0x2ac>
  90730e:	102322        	l32r	a0, 8cff98 <_bss_end+0x3c2790>
			sc->sc_int_stats.ast_txurn++;
  907311:	4fda40        	excw
  907314:	b133      	addi.n	a3, a3, 1
  907316:	23264f        	s32i	a3, a2, 0x13c
			ah->ah_updateTxTrigLevel(ah, AH_TRUE);
  907319:	8347      	l32i.n	a3, a4, 28
  90731b:	c0b1      	movi.n	a11, 1
  90731d:	0b3000        	callx8	a3
  907320:	2a5a1c        	movi	a10, 0x51c
  907323:	aa2a      	add.n	a10, a2, a10
  907325:	5bfcd2        	call8	906670 <__adf_os_sched_bh$isra$5>
		}

		ATH_SCHEDULE_TQUEUE(sc->sc_dev, &sc->sc_txtq);

		if (status & HAL_INT_BMISS) {
  907328:	8316      	l32i.n	a3, a1, 24
  90732a:	7d3607        	bbci	a3, 13, 907335 <ath_intr+0x6d1>
  90732d:	2a3a24        	movi	a10, 0x324
  907330:	aa2a      	add.n	a10, a2, a10
  907332:	5bfccf        	call8	906670 <__adf_os_sched_bh$isra$5>
			ATH_SCHEDULE_TQUEUE(sc->sc_dev, &sc->sc_bmisstq);
		}

		if (status & HAL_INT_GTT)
  907335:	8416      	l32i.n	a4, a1, 24
  907337:	724607        	bbci	a4, 2, 907342 <ath_intr+0x6de>
			sc->sc_int_stats.ast_txto++;
  90733a:	232250        	l32i	a3, a2, 0x140
  90733d:	b133      	addi.n	a3, a3, 1
  90733f:	232650        	s32i	a3, a2, 0x140

		if (status & HAL_INT_CST)
			sc->sc_int_stats.ast_cst++;
	}

	return ADF_OS_IRQ_HANDLED;
  907342:	c031      	movi.n	a3, 1
		}

		if (status & HAL_INT_GTT)
			sc->sc_int_stats.ast_txto++;

		if (status & HAL_INT_CST)
  907344:	764608        	bbci	a4, 6, 907350 <ath_intr+0x6ec>
			sc->sc_int_stats.ast_cst++;
  907347:	242251        	l32i	a4, a2, 0x144
  90734a:	034408        	add	a4, a4, a3
  90734d:	242651        	s32i	a4, a2, 0x144
	}

	return ADF_OS_IRQ_HANDLED;
}
  907350:	d230      	mov.n	a2, a3
  907352:	d10f      	retw.n

00907354 <wmi_cmd_rsp>:
	WMI_SendEvent(handle, netbuf, evt_id, 0, Length);
}

void wmi_cmd_rsp(void *pContext, WMI_COMMAND_ID cmd_id, A_UINT16 SeqNo,
		 void *buffer, a_int32_t Length)
{
  907354:	6c1004        	entry	a1, 32
	adf_nbuf_t netbuf = ADF_NBUF_NULL;
	A_UINT8 *pData;

	netbuf = WMI_AllocEvent(pContext, WMI_EVT_CLASS_CMD_REPLY,
  907357:	177184        	l32r	a7, 8e3968 <bStandardCommand+0x6dc>
  90735a:	da20      	mov.n	a10, a2
  90735c:	277292        	l32i	a7, a7, 0x248
  90735f:	2b0a01        	movi	a11, 1
  907362:	2c6c04        	addi	a12, a6, 4
  907365:	0b7000        	callx8	a7
	WMI_SendEvent(handle, netbuf, evt_id, 0, Length);
}

void wmi_cmd_rsp(void *pContext, WMI_COMMAND_ID cmd_id, A_UINT16 SeqNo,
		 void *buffer, a_int32_t Length)
{
  907368:	04044f        	extui	a4, a4, 0, 16
	adf_nbuf_t netbuf = ADF_NBUF_NULL;
	A_UINT8 *pData;

	netbuf = WMI_AllocEvent(pContext, WMI_EVT_CLASS_CMD_REPLY,
  90736b:	d7a0      	mov.n	a7, a10
				sizeof(WMI_CMD_HDR) + Length);

	if (netbuf == ADF_NBUF_NULL) {
  90736d:	cca1      	bnez.n	a10, 907372 <wmi_cmd_rsp+0x1e>
  90736f:	63fffc        	j	90736f <wmi_cmd_rsp+0x1b>
		adf_os_assert(0);
		return;
	}

	if (Length != 0 && buffer != NULL) {
  907372:	c86e      	beqz.n	a6, 907384 <wmi_cmd_rsp+0x30>
  907374:	c85c      	beqz.n	a5, 907384 <wmi_cmd_rsp+0x30>
 *         put, or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_put_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_put_tail(buf, size);
  907376:	066b02        	or	a11, a6, a6
  907379:	5bf0ad        	call8	903630 <__adf_nbuf_put_tail>
  90737c:	db50      	mov.n	a11, a5
  90737e:	066c02        	or	a12, a6, a6
  907381:	5bfc2b        	call8	906430 <__adf_os_mem_copy>
		pData = (A_UINT8 *)adf_nbuf_put_tail(netbuf, Length);
		adf_os_mem_copy(pData, buffer, Length);
	}

	WMI_SendEvent(pContext, netbuf, cmd_id, SeqNo, Length);
  907384:	157184        	l32r	a5, 8e3994 <bStandardCommand+0x708>
  907387:	da20      	mov.n	a10, a2
  907389:	255293        	l32i	a5, a5, 0x24c
  90738c:	db70      	mov.n	a11, a7
  90738e:	030c4f        	extui	a12, a3, 0, 16
  907391:	dd40      	mov.n	a13, a4
  907393:	de60      	mov.n	a14, a6
  907395:	0b5000        	callx8	a5
  907398:	d10f      	retw.n
	...

0090739c <ath_hal_reg_rmw_tgt>:
}

static void ath_hal_reg_rmw_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data,
				a_int32_t datalen)
{
  90739c:	6c1006        	entry	a1, 48
  90739f:	03084f        	extui	a8, a3, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  9073a2:	232d05        	addmi	a3, a2, 0x500
  9073a5:	893b      	l32i.n	a9, a3, 44
}

static void ath_hal_reg_rmw_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data,
				a_int32_t datalen)
{
  9073a7:	04044f        	extui	a4, a4, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
	struct register_rmw *buf = (struct register_rmw *)data;
	int i;

	for (i = 0; i < datalen;
  9073aa:	d750      	mov.n	a7, a5
	     i += sizeof(struct register_rmw)) {
		a_uint32_t val;
		buf = (struct register_rmw *)(data + i);

		val = ath_reg_read_filter(ah, buf->reg);
		val &= ~buf->clr;
  9073ac:	c73f      	movi.n	a3, -1
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
	struct register_rmw *buf = (struct register_rmw *)data;
	int i;

	for (i = 0; i < datalen;
  9073ae:	600022        	j	9073d4 <ath_hal_reg_rmw_tgt+0x38>
	     i += sizeof(struct register_rmw)) {
		a_uint32_t val;
		buf = (struct register_rmw *)(data + i);

		val = ath_reg_read_filter(ah, buf->reg);
  9073b1:	8b70      	l32i.n	a11, a7, 0
  9073b3:	da90      	mov.n	a10, a9
  9073b5:	9811      	s32i.n	a8, a1, 4
  9073b7:	9910      	s32i.n	a9, a1, 0
  9073b9:	5bfcd5        	call8	906710 <ath_reg_read_filter>
		val &= ~buf->clr;
  9073bc:	8c72      	l32i.n	a12, a7, 8
		val |= buf->set;
  9073be:	8b71      	l32i.n	a11, a7, 4
	     i += sizeof(struct register_rmw)) {
		a_uint32_t val;
		buf = (struct register_rmw *)(data + i);

		val = ath_reg_read_filter(ah, buf->reg);
		val &= ~buf->clr;
  9073c0:	0c3c03        	xor	a12, a3, a12
  9073c3:	0cac01        	and	a12, a10, a12
		val |= buf->set;
		ath_hal_reg_write_filter(ah, buf->reg, val);
  9073c6:	8a70      	l32i.n	a10, a7, 0
  9073c8:	0bcb02        	or	a11, a12, a11
  9073cb:	5bfcad        	call8	906680 <ath_hal_reg_write_filter$isra$10>
  9073ce:	8910      	l32i.n	a9, a1, 0
  9073d0:	8811      	l32i.n	a8, a1, 4
  9073d2:	bc77      	addi.n	a7, a7, 12
	}

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_hal_reg_rmw_tgt(void *Context, A_UINT16 Command,
  9073d4:	057a0c        	sub	a10, a7, a5
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
	struct register_rmw *buf = (struct register_rmw *)data;
	int i;

	for (i = 0; i < datalen;
  9073d7:	76a2d6        	blt	a10, a6, 9073b1 <ath_hal_reg_rmw_tgt+0x15>
		val = ath_reg_read_filter(ah, buf->reg);
		val &= ~buf->clr;
		val |= buf->set;
		ath_hal_reg_write_filter(ah, buf->reg, val);
	}
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  9073da:	c0d0      	movi.n	a13, 0
  9073dc:	8a23      	l32i.n	a10, a2, 12
  9073de:	db80      	mov.n	a11, a8
  9073e0:	dc40      	mov.n	a12, a4
  9073e2:	0dde02        	or	a14, a13, a13
  9073e5:	5bffdb        	call8	907354 <wmi_cmd_rsp>
  9073e8:	d10f      	retw.n
	...

009073ec <ath_rc_mask_tgt>:
	adf_os_assert(0);
}

static void ath_rc_mask_tgt(void *Context, A_UINT16 Command,
			    A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
  9073ec:	6c1004        	entry	a1, 32
	int idx, band, i;

	idx = wmi_data->vap_index;
	band = wmi_data->band;

	sc->sc_vap[idx].av_rate_mask[band] = adf_os_ntohl(wmi_data->mask);
  9073ef:	2e5002        	l8ui	a14, a5, 2
  9073f2:	2d5003        	l8ui	a13, a5, 3
  9073f5:	285004        	l8ui	a8, a5, 4
  9073f8:	08ee10        	slli	a14, a14, 24
  9073fb:	00dd11        	slli	a13, a13, 16
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_rate_mask_cmd *wmi_data = (struct wmi_rc_rate_mask_cmd *)buffer;
	int idx, band, i;

	idx = wmi_data->vap_index;
  9073fe:	295000        	l8ui	a9, a5, 0
	band = wmi_data->band;
  907401:	2a5001        	l8ui	a10, a5, 1

	sc->sc_vap[idx].av_rate_mask[band] = adf_os_ntohl(wmi_data->mask);
  907404:	0edd02        	or	a13, a13, a14
  907407:	255005        	l8ui	a5, a5, 5
  90740a:	088811        	slli	a8, a8, 8
  90740d:	0d8802        	or	a8, a8, a13
  907410:	085802        	or	a8, a5, a8
  907413:	0c9511        	slli	a5, a9, 4
  907416:	a955      	add.n	a5, a5, a9
  907418:	aa5e      	add.n	a14, a5, a10
  90741a:	2d5a70        	movi	a13, 0x570
  90741d:	aded      	add.n	a13, a14, a13
  90741f:	02dd0a        	addx4	a13, a13, a2
  907422:	98d4      	s32i.n	a8, a13, 16
	adf_os_assert(0);
}

static void ath_rc_mask_tgt(void *Context, A_UINT16 Command,
			    A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
  907424:	030b4f        	extui	a11, a3, 0, 16
  907427:	040c4f        	extui	a12, a4, 0, 16
	idx = wmi_data->vap_index;
	band = wmi_data->band;

	sc->sc_vap[idx].av_rate_mask[band] = adf_os_ntohl(wmi_data->mask);

	if (sc->sc_vap[idx].av_rate_mask[band]) {
  90742a:	ca8a      	beqz.n	a8, 907458 <ath_rc_mask_tgt+0x6c>
  90742c:	c050      	movi.n	a5, 0
		for (i = 0; i < RATE_TABLE_SIZE; i++) {
			if ((1 << i) & sc->sc_vap[idx].av_rate_mask[band]) {
  90742e:	c0d1      	movi.n	a13, 1
  907430:	005104        	ssl	a5
  907433:	00de1a        	sll	a14, a13
  907436:	78e014        	bnone	a14, a8, 90744e <ath_rc_mask_tgt+0x62>
				sc->sc_vap[idx].av_minrateidx[band] = i;
  907439:	0c9811        	slli	a8, a9, 4
  90743c:	a989      	add.n	a9, a8, a9
  90743e:	02990a        	addx4	a9, a9, a2
  907441:	1872a3        	l32r	a8, 8e3ed0 <mUsbEPinHighBandSet+0x1c0>
  907444:	aa9a      	add.n	a10, a9, a10
  907446:	a8aa      	add.n	a10, a10, a8
  907448:	25a408        	s8i	a5, a10, 8
				break;
  90744b:	600016        	j	907465 <ath_rc_mask_tgt+0x79>
	band = wmi_data->band;

	sc->sc_vap[idx].av_rate_mask[band] = adf_os_ntohl(wmi_data->mask);

	if (sc->sc_vap[idx].av_rate_mask[band]) {
		for (i = 0; i < RATE_TABLE_SIZE; i++) {
  90744e:	b155      	addi.n	a5, a5, 1
  907450:	695cdc        	bnei	a5, 32, 907430 <ath_rc_mask_tgt+0x44>
  907453:	60000e        	j	907465 <ath_rc_mask_tgt+0x79>
  907456:	000002        	or	a0, a0, a0
				sc->sc_vap[idx].av_minrateidx[band] = i;
				break;
			}
		}
	} else {
		sc->sc_vap[idx].av_minrateidx[band] = 0;
  907459:	550a19        	call4	949cc0 <_etext+0x3edfb>
  90745c:	72a3aa        	bltu	a10, a2, 90740a <ath_rc_mask_tgt+0x1e>
  90745f:	5aa9aa        	call8	8b1b08 <_bss_end+0x3a4300>
  907462:	28a408        	s8i	a8, a10, 8
	}

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  907465:	c0d0      	movi.n	a13, 0
  907467:	8a23      	l32i.n	a10, a2, 12
  907469:	ded0      	mov.n	a14, a13
  90746b:	5bffba        	call8	907354 <wmi_cmd_rsp>
  90746e:	d10f      	retw.n

00907470 <ath_rx_stats_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
}

static void ath_rx_stats_tgt(void *Context,A_UINT16 Command, A_UINT16 SeqNo,
			     A_UINT8 *data, a_int32_t datalen)
{
  907470:	6c1006        	entry	a1, 48
		a_uint32_t   ast_rx_done;
	};

	struct fusion_stats stats;

	stats.ast_rx_nobuf = sc->sc_rx_stats.ast_rx_nobuf;
  907473:	28227c        	l32i	a8, a2, 0x1f0
	stats.ast_rx_send = sc->sc_rx_stats.ast_rx_send;
	stats.ast_rx_done = sc->sc_rx_stats.ast_rx_done;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  907476:	8a23      	l32i.n	a10, a2, 12
		a_uint32_t   ast_rx_done;
	};

	struct fusion_stats stats;

	stats.ast_rx_nobuf = sc->sc_rx_stats.ast_rx_nobuf;
  907478:	9810      	s32i.n	a8, a1, 0
	stats.ast_rx_send = sc->sc_rx_stats.ast_rx_send;
  90747a:	28227d        	l32i	a8, a2, 0x1f4
	stats.ast_rx_done = sc->sc_rx_stats.ast_rx_done;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  90747d:	030b4f        	extui	a11, a3, 0, 16
	};

	struct fusion_stats stats;

	stats.ast_rx_nobuf = sc->sc_rx_stats.ast_rx_nobuf;
	stats.ast_rx_send = sc->sc_rx_stats.ast_rx_send;
  907480:	9811      	s32i.n	a8, a1, 4
	stats.ast_rx_done = sc->sc_rx_stats.ast_rx_done;
  907482:	28227e        	l32i	a8, a2, 0x1f8

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  907485:	040c4f        	extui	a12, a4, 0, 16
  907488:	dd10      	mov.n	a13, a1
  90748a:	c0ec      	movi.n	a14, 12

	struct fusion_stats stats;

	stats.ast_rx_nobuf = sc->sc_rx_stats.ast_rx_nobuf;
	stats.ast_rx_send = sc->sc_rx_stats.ast_rx_send;
	stats.ast_rx_done = sc->sc_rx_stats.ast_rx_done;
  90748c:	9812      	s32i.n	a8, a1, 8

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  90748e:	5bffb1        	call8	907354 <wmi_cmd_rsp>
  907491:	d10f      	retw.n
	...

00907494 <ath_tx_stats_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
}

static void ath_tx_stats_tgt(void *Context,A_UINT16 Command, A_UINT16 SeqNo,
			     A_UINT8 *data, a_int32_t datalen)
{
  907494:	6c100a        	entry	a1, 80
		a_uint32_t   tx_nobufs;
	};

	struct fusion_stats stats;

	stats.ast_tx_xretries = sc->sc_tx_stats.ast_tx_xretries;
  907497:	282252        	l32i	a8, a2, 0x148
	stats.ast_tx_longretry = sc->sc_tx_stats.ast_tx_longretry;
	stats.tx_qnull = sc->sc_tx_stats.tx_qnull;
	stats.tx_noskbs = sc->sc_tx_stats.tx_noskbs;
	stats.tx_nobufs = sc->sc_tx_stats.tx_nobufs;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  90749a:	8a23      	l32i.n	a10, a2, 12
		a_uint32_t   tx_nobufs;
	};

	struct fusion_stats stats;

	stats.ast_tx_xretries = sc->sc_tx_stats.ast_tx_xretries;
  90749c:	9810      	s32i.n	a8, a1, 0
	stats.ast_tx_fifoerr = sc->sc_tx_stats.ast_tx_fifoerr;
  90749e:	282253        	l32i	a8, a2, 0x14c
	stats.ast_tx_longretry = sc->sc_tx_stats.ast_tx_longretry;
	stats.tx_qnull = sc->sc_tx_stats.tx_qnull;
	stats.tx_noskbs = sc->sc_tx_stats.tx_noskbs;
	stats.tx_nobufs = sc->sc_tx_stats.tx_nobufs;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  9074a1:	030b4f        	extui	a11, a3, 0, 16
	};

	struct fusion_stats stats;

	stats.ast_tx_xretries = sc->sc_tx_stats.ast_tx_xretries;
	stats.ast_tx_fifoerr = sc->sc_tx_stats.ast_tx_fifoerr;
  9074a4:	9811      	s32i.n	a8, a1, 4
	stats.ast_tx_filtered = sc->sc_tx_stats.ast_tx_filtered;
  9074a6:	282254        	l32i	a8, a2, 0x150
	stats.ast_tx_longretry = sc->sc_tx_stats.ast_tx_longretry;
	stats.tx_qnull = sc->sc_tx_stats.tx_qnull;
	stats.tx_noskbs = sc->sc_tx_stats.tx_noskbs;
	stats.tx_nobufs = sc->sc_tx_stats.tx_nobufs;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  9074a9:	040c4f        	extui	a12, a4, 0, 16

	struct fusion_stats stats;

	stats.ast_tx_xretries = sc->sc_tx_stats.ast_tx_xretries;
	stats.ast_tx_fifoerr = sc->sc_tx_stats.ast_tx_fifoerr;
	stats.ast_tx_filtered = sc->sc_tx_stats.ast_tx_filtered;
  9074ac:	9812      	s32i.n	a8, a1, 8
	stats.ast_tx_timer_exp = sc->sc_tx_stats.ast_tx_timer_exp;
  9074ae:	282255        	l32i	a8, a2, 0x154
	stats.ast_tx_longretry = sc->sc_tx_stats.ast_tx_longretry;
	stats.tx_qnull = sc->sc_tx_stats.tx_qnull;
	stats.tx_noskbs = sc->sc_tx_stats.tx_noskbs;
	stats.tx_nobufs = sc->sc_tx_stats.tx_nobufs;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  9074b1:	dd10      	mov.n	a13, a1
	struct fusion_stats stats;

	stats.ast_tx_xretries = sc->sc_tx_stats.ast_tx_xretries;
	stats.ast_tx_fifoerr = sc->sc_tx_stats.ast_tx_fifoerr;
	stats.ast_tx_filtered = sc->sc_tx_stats.ast_tx_filtered;
	stats.ast_tx_timer_exp = sc->sc_tx_stats.ast_tx_timer_exp;
  9074b3:	9813      	s32i.n	a8, a1, 12
	stats.ast_tx_shortretry = sc->sc_tx_stats.ast_tx_shortretry;
  9074b5:	282256        	l32i	a8, a2, 0x158
	stats.ast_tx_longretry = sc->sc_tx_stats.ast_tx_longretry;
	stats.tx_qnull = sc->sc_tx_stats.tx_qnull;
	stats.tx_noskbs = sc->sc_tx_stats.tx_noskbs;
	stats.tx_nobufs = sc->sc_tx_stats.tx_nobufs;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  9074b8:	c2e4      	movi.n	a14, 36

	stats.ast_tx_xretries = sc->sc_tx_stats.ast_tx_xretries;
	stats.ast_tx_fifoerr = sc->sc_tx_stats.ast_tx_fifoerr;
	stats.ast_tx_filtered = sc->sc_tx_stats.ast_tx_filtered;
	stats.ast_tx_timer_exp = sc->sc_tx_stats.ast_tx_timer_exp;
	stats.ast_tx_shortretry = sc->sc_tx_stats.ast_tx_shortretry;
  9074ba:	9814      	s32i.n	a8, a1, 16
	stats.ast_tx_longretry = sc->sc_tx_stats.ast_tx_longretry;
  9074bc:	282257        	l32i	a8, a2, 0x15c
  9074bf:	9815      	s32i.n	a8, a1, 20
	stats.tx_qnull = sc->sc_tx_stats.tx_qnull;
  9074c1:	28225c        	l32i	a8, a2, 0x170
  9074c4:	9816      	s32i.n	a8, a1, 24
	stats.tx_noskbs = sc->sc_tx_stats.tx_noskbs;
  9074c6:	282276        	l32i	a8, a2, 0x1d8
  9074c9:	9817      	s32i.n	a8, a1, 28
	stats.tx_nobufs = sc->sc_tx_stats.tx_nobufs;
  9074cb:	282277        	l32i	a8, a2, 0x1dc
  9074ce:	281608        	s32i	a8, a1, 32

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  9074d1:	5bffa0        	call8	907354 <wmi_cmd_rsp>
  9074d4:	d10f      	retw.n
	...

009074d8 <ath_int_stats_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_int_stats_tgt(void *Context,A_UINT16 Command, A_UINT16 SeqNo,
			      A_UINT8 *data, a_int32_t datalen)
{
  9074d8:	6c1008        	entry	a1, 64
		a_uint32_t ast_cst;
	};

	struct fusion_stats stats;

	stats.ast_rx = sc->sc_int_stats.ast_rx;
  9074db:	28224c        	l32i	a8, a2, 0x130
	stats.ast_rxeol = sc->sc_int_stats.ast_rxeol;
	stats.ast_txurn = sc->sc_int_stats.ast_txurn;
	stats.ast_txto = sc->sc_int_stats.ast_txto;
	stats.ast_cst = sc->sc_int_stats.ast_cst;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  9074de:	8a23      	l32i.n	a10, a2, 12
		a_uint32_t ast_cst;
	};

	struct fusion_stats stats;

	stats.ast_rx = sc->sc_int_stats.ast_rx;
  9074e0:	9810      	s32i.n	a8, a1, 0
	stats.ast_rxorn = sc->sc_int_stats.ast_rxorn;
  9074e2:	28224d        	l32i	a8, a2, 0x134
	stats.ast_rxeol = sc->sc_int_stats.ast_rxeol;
	stats.ast_txurn = sc->sc_int_stats.ast_txurn;
	stats.ast_txto = sc->sc_int_stats.ast_txto;
	stats.ast_cst = sc->sc_int_stats.ast_cst;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  9074e5:	030b4f        	extui	a11, a3, 0, 16
	};

	struct fusion_stats stats;

	stats.ast_rx = sc->sc_int_stats.ast_rx;
	stats.ast_rxorn = sc->sc_int_stats.ast_rxorn;
  9074e8:	9811      	s32i.n	a8, a1, 4
	stats.ast_rxeol = sc->sc_int_stats.ast_rxeol;
  9074ea:	28224e        	l32i	a8, a2, 0x138
	stats.ast_txurn = sc->sc_int_stats.ast_txurn;
	stats.ast_txto = sc->sc_int_stats.ast_txto;
	stats.ast_cst = sc->sc_int_stats.ast_cst;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  9074ed:	040c4f        	extui	a12, a4, 0, 16

	struct fusion_stats stats;

	stats.ast_rx = sc->sc_int_stats.ast_rx;
	stats.ast_rxorn = sc->sc_int_stats.ast_rxorn;
	stats.ast_rxeol = sc->sc_int_stats.ast_rxeol;
  9074f0:	9812      	s32i.n	a8, a1, 8
	stats.ast_txurn = sc->sc_int_stats.ast_txurn;
  9074f2:	28224f        	l32i	a8, a2, 0x13c
	stats.ast_txto = sc->sc_int_stats.ast_txto;
	stats.ast_cst = sc->sc_int_stats.ast_cst;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  9074f5:	dd10      	mov.n	a13, a1
	struct fusion_stats stats;

	stats.ast_rx = sc->sc_int_stats.ast_rx;
	stats.ast_rxorn = sc->sc_int_stats.ast_rxorn;
	stats.ast_rxeol = sc->sc_int_stats.ast_rxeol;
	stats.ast_txurn = sc->sc_int_stats.ast_txurn;
  9074f7:	9813      	s32i.n	a8, a1, 12
	stats.ast_txto = sc->sc_int_stats.ast_txto;
  9074f9:	282250        	l32i	a8, a2, 0x140
	stats.ast_cst = sc->sc_int_stats.ast_cst;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  9074fc:	c1e8      	movi.n	a14, 24

	stats.ast_rx = sc->sc_int_stats.ast_rx;
	stats.ast_rxorn = sc->sc_int_stats.ast_rxorn;
	stats.ast_rxeol = sc->sc_int_stats.ast_rxeol;
	stats.ast_txurn = sc->sc_int_stats.ast_txurn;
	stats.ast_txto = sc->sc_int_stats.ast_txto;
  9074fe:	9814      	s32i.n	a8, a1, 16
	stats.ast_cst = sc->sc_int_stats.ast_cst;
  907500:	282251        	l32i	a8, a2, 0x144
  907503:	9815      	s32i.n	a8, a1, 20

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  907505:	5bff93        	call8	907354 <wmi_cmd_rsp>
  907508:	d10f      	retw.n
	...

0090750c <ath_node_update_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_node_update_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  90750c:	6c1004        	entry	a1, 32

	node->ni_htcap = adf_os_ntohs(node->ni_htcap);
	node->ni_flags = adf_os_ntohs(node->ni_flags);
	node->ni_maxampdu = adf_os_ntohs(node->ni_maxampdu);

	adf_os_mem_copy(&(sc->sc_sta[node_index].ni), node,
  90750f:	29500c        	l8ui	a9, a5, 12
  907512:	265a30        	movi	a6, 0x530
  907515:	0a9711        	slli	a7, a9, 6
  907518:	a977      	add.n	a7, a7, a9
  90751a:	097909        	addx2	a9, a7, a9
  90751d:	0e9711        	slli	a7, a9, 2
  907520:	a67a      	add.n	a10, a7, a6
  907522:	aa2a      	add.n	a10, a2, a10
  907524:	db50      	mov.n	a11, a5
  907526:	b8aa      	addi.n	a10, a10, 8
  907528:	c1c6      	movi.n	a12, 22
  90752a:	5bfbc1        	call8	906430 <__adf_os_mem_copy>
			NODE_TARGET_SIZE);

	vap_index = sc->sc_sta[node_index].ni.ni_vapindex;
	sc->sc_sta[node_index].ni.ni_vap = &(sc->sc_vap[vap_index].av_vap);
  90752d:	a728      	add.n	a8, a2, a7
	node->ni_maxampdu = adf_os_ntohs(node->ni_maxampdu);

	adf_os_mem_copy(&(sc->sc_sta[node_index].ni), node,
			NODE_TARGET_SIZE);

	vap_index = sc->sc_sta[node_index].ni.ni_vapindex;
  90752f:	a686      	add.n	a6, a8, a6
	sc->sc_sta[node_index].ni.ni_vap = &(sc->sc_vap[vap_index].av_vap);
  907531:	256015        	l8ui	a5, a6, 21
  907534:	275a50        	movi	a7, 0x550
  907537:	0c5611        	slli	a6, a5, 4
  90753a:	a565      	add.n	a5, a6, a5
  90753c:	1672a4        	l32r	a6, 8e3fcc <mUsbEPinHighBandSet+0x2bc>
  90753f:	a787      	add.n	a7, a8, a7
  907541:	06550a        	addx4	a5, a5, a6
  907544:	a525      	add.n	a5, a2, a5
  907546:	b855      	addi.n	a5, a5, 8
  907548:	9572      	s32i.n	a5, a7, 8

	sc->sc_sta[node_index].ni.ni_txseqmgmt = 0;
  90754a:	255a40        	movi	a5, 0x540
  90754d:	a588      	add.n	a8, a8, a5
	sc->sc_sta[node_index].ni.ni_iv16 = 0;
	sc->sc_sta[node_index].ni.ni_iv32 = 0;
  90754f:	c0e0      	movi.n	a14, 0
			NODE_TARGET_SIZE);

	vap_index = sc->sc_sta[node_index].ni.ni_vapindex;
	sc->sc_sta[node_index].ni.ni_vap = &(sc->sc_vap[vap_index].av_vap);

	sc->sc_sta[node_index].ni.ni_txseqmgmt = 0;
  907551:	c050      	movi.n	a5, 0
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_node_update_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907553:	03034f        	extui	a3, a3, 0, 16
  907556:	04044f        	extui	a4, a4, 0, 16

	sc->sc_sta[node_index].ni.ni_txseqmgmt = 0;
	sc->sc_sta[node_index].ni.ni_iv16 = 0;
	sc->sc_sta[node_index].ni.ni_iv32 = 0;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  907559:	8a23      	l32i.n	a10, a2, 12
			NODE_TARGET_SIZE);

	vap_index = sc->sc_sta[node_index].ni.ni_vapindex;
	sc->sc_sta[node_index].ni.ni_vap = &(sc->sc_vap[vap_index].av_vap);

	sc->sc_sta[node_index].ni.ni_txseqmgmt = 0;
  90755b:	258508        	s16i	a5, a8, 16
	sc->sc_sta[node_index].ni.ni_iv16 = 0;
  90755e:	258509        	s16i	a5, a8, 18
	sc->sc_sta[node_index].ni.ni_iv32 = 0;
  907561:	9e85      	s32i.n	a14, a8, 20

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  907563:	db30      	mov.n	a11, a3
  907565:	dc40      	mov.n	a12, a4
  907567:	dde0      	mov.n	a13, a14
  907569:	5bff7a        	call8	907354 <wmi_cmd_rsp>
  90756c:	d10f      	retw.n
	...

00907570 <ath_detach_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_detach_tgt(void *Context, A_UINT16 Command, A_UINT16 SeqNo,
				 A_UINT8 *data, a_int32_t datalen)
{
  907570:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  907573:	252d05        	addmi	a5, a2, 0x500
  907576:	855b      	l32i.n	a5, a5, 44

	ath_desc_free(sc);
  907578:	022a02        	or	a10, a2, a2
  90757b:	5bfc7c        	call8	90676c <ath_desc_free>
	ah->ah_detach(ah);
  90757e:	8856      	l32i.n	a8, a5, 24
  907580:	da50      	mov.n	a10, a5
  907582:	0b8000        	callx8	a8
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_detach_tgt(void *Context, A_UINT16 Command, A_UINT16 SeqNo,
				 A_UINT8 *data, a_int32_t datalen)
{
  907585:	03034f        	extui	a3, a3, 0, 16
  907588:	04044f        	extui	a4, a4, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;

	ath_desc_free(sc);
	ah->ah_detach(ah);
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  90758b:	c0d0      	movi.n	a13, 0
  90758d:	8a23      	l32i.n	a10, a2, 12
  90758f:	db30      	mov.n	a11, a3
  907591:	dc40      	mov.n	a12, a4
  907593:	ded0      	mov.n	a14, a13
  907595:	5bff6f        	call8	907354 <wmi_cmd_rsp>
  907598:	d10f      	retw.n
	...

0090759c <ath_enable_aggr_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &ver, sizeof(ver));
}

static void ath_enable_aggr_tgt(void *Context,A_UINT16 Command, A_UINT16 SeqNo,
				A_UINT8 *data, a_int32_t datalen)
{
  90759c:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_aggr_info *aggr = (struct ath_aggr_info *)data;
	a_uint8_t nodeindex = aggr->nodeindex;
  90759f:	2d5000        	l8ui	a13, a5, 0
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &ver, sizeof(ver));
}

static void ath_enable_aggr_tgt(void *Context,A_UINT16 Command, A_UINT16 SeqNo,
				A_UINT8 *data, a_int32_t datalen)
{
  9075a2:	03034f        	extui	a3, a3, 0, 16
  9075a5:	04044f        	extui	a4, a4, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_aggr_info *aggr = (struct ath_aggr_info *)data;
	a_uint8_t nodeindex = aggr->nodeindex;
	a_uint8_t tidno = aggr->tidno;
  9075a8:	285001        	l8ui	a8, a5, 1
	struct ath_node_target *an = NULL ;
	struct ath_atx_tid  *tid = NULL;

	if (nodeindex >= TARGET_NODE_MAX) {
  9075ab:	6fd866        	bgeui	a13, 8, 907615 <ath_enable_aggr_tgt+0x79>
		goto done;
	}

	an = &sc->sc_sta[nodeindex];
  9075ae:	0adb11        	slli	a11, a13, 6
  9075b1:	adbb      	add.n	a11, a11, a13
  9075b3:	295a30        	movi	a9, 0x530
  9075b6:	0dbb09        	addx2	a11, a11, a13
  9075b9:	09bb0a        	addx4	a11, a11, a9
  9075bc:	ab2b      	add.n	a11, a2, a11
  9075be:	b8bb      	addi.n	a11, a11, 8
	if (!an->an_valid) {
  9075c0:	29bd02        	addmi	a9, a11, 0x200
  9075c3:	299004        	l8ui	a9, a9, 4
  9075c6:	64904b        	beqz	a9, 907615 <ath_enable_aggr_tgt+0x79>
		goto done;
	}

	if (tidno >= WME_NUM_TID) {
  9075c9:	6e8813        	bltui	a8, 8, 9075e0 <ath_enable_aggr_tgt+0x44>
		adf_os_print("[%s] enable_aggr with invalid tid %d(node = %d)\n",
  9075cc:	157184        	l32r	a5, 8e3bdc <bStandardCommand+0x950>
  9075cf:	1b72a6        	l32r	a11, 8e4068 <mUsbEPinHighBandSet+0x358>
  9075d2:	255212        	l32i	a5, a5, 72
  9075d5:	1a72a5        	l32r	a10, 8e406c <mUsbEPinHighBandSet+0x35c>
  9075d8:	dc80      	mov.n	a12, a8
  9075da:	0b5000        	callx8	a5
			     __FUNCTION__, tidno, nodeindex);
		goto done;
  9075dd:	600034        	j	907615 <ath_enable_aggr_tgt+0x79>
	}

	tid = ATH_AN_2_TID(an, tidno);
  9075e0:	0c8c11        	slli	a12, a8, 4
  9075e3:	08cc0c        	sub	a12, a12, a8

	if (aggr->aggr_enable) {
  9075e6:	255002        	l8ui	a5, a5, 2
		adf_os_print("[%s] enable_aggr with invalid tid %d(node = %d)\n",
			     __FUNCTION__, tidno, nodeindex);
		goto done;
	}

	tid = ATH_AN_2_TID(an, tidno);
  9075e9:	0bcc0a        	addx4	a12, a12, a11
  9075ec:	2ccc24        	addi	a12, a12, 36
  9075ef:	c082      	movi.n	a8, 2

	if (aggr->aggr_enable) {
  9075f1:	c85b      	beqz.n	a5, 907600 <ath_enable_aggr_tgt+0x64>
		tid->flag |= TID_AGGR_ENABLED;
  9075f3:	25c036        	l8ui	a5, a12, 54
  9075f6:	085802        	or	a8, a5, a8
  9075f9:	28c436        	s8i	a8, a12, 54
  9075fc:	600015        	j	907615 <ath_enable_aggr_tgt+0x79>
  9075ff:	0025c0        	excw
	} else if ( tid->flag & TID_AGGR_ENABLED ) {
  907602:	367850        	excw
  907605:	0ec78d        	excw
		tid->flag &= ~TID_AGGR_ENABLED;
  907608:	085501        	and	a5, a5, a8
  90760b:	25c436        	s8i	a5, a12, 54
		ath_tgt_tx_cleanup(sc, an, tid, 1);
  90760e:	da20      	mov.n	a10, a2
  907610:	c0d1      	movi.n	a13, 1
  907612:	580d81        	call8	90ac18 <ath_tgt_tx_cleanup>
	}
done:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  907615:	c0d0      	movi.n	a13, 0
  907617:	8a23      	l32i.n	a10, a2, 12
  907619:	db30      	mov.n	a11, a3
  90761b:	dc40      	mov.n	a12, a4
  90761d:	ded0      	mov.n	a14, a13
  90761f:	5bff4d        	call8	907354 <wmi_cmd_rsp>
  907622:	d10f      	retw.n

00907624 <ath_ic_update_tgt>:
}

static void ath_ic_update_tgt(void *Context,A_UINT16 Command, A_UINT16 SeqNo,
			      A_UINT8 *data, a_int32_t datalen)
{
  907624:	6c1004        	entry	a1, 32
  907627:	1a72a7        	l32r	a10, 8e40c4 <vbuf_module_install+0x38>
  90762a:	db50      	mov.n	a11, a5
  90762c:	0a2a08        	add	a10, a2, a10
  90762f:	c0c8      	movi.n	a12, 8
  907631:	5bfb7f        	call8	906430 <__adf_os_mem_copy>
	struct ieee80211com_target *ic = (struct ieee80211com_target * )data;
	struct ieee80211com_target *ictgt = &sc->sc_ic ;

	adf_os_mem_copy(ictgt, ic, sizeof(struct  ieee80211com_target));

	ictgt->ic_ampdu_limit         = adf_os_ntohl(ic->ic_ampdu_limit);
  907634:	8850      	l32i.n	a8, a5, 0
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_ic_update_tgt(void *Context,A_UINT16 Command, A_UINT16 SeqNo,
			      A_UINT8 *data, a_int32_t datalen)
{
  907636:	03034f        	extui	a3, a3, 0, 16
  907639:	04044f        	extui	a4, a4, 0, 16
	struct ieee80211com_target *ic = (struct ieee80211com_target * )data;
	struct ieee80211com_target *ictgt = &sc->sc_ic ;

	adf_os_mem_copy(ictgt, ic, sizeof(struct  ieee80211com_target));

	ictgt->ic_ampdu_limit         = adf_os_ntohl(ic->ic_ampdu_limit);
  90763c:	252d16        	addmi	a5, a2, 0x1600

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  90763f:	c0d0      	movi.n	a13, 0
  907641:	8a23      	l32i.n	a10, a2, 12
	struct ieee80211com_target *ic = (struct ieee80211com_target * )data;
	struct ieee80211com_target *ictgt = &sc->sc_ic ;

	adf_os_mem_copy(ictgt, ic, sizeof(struct  ieee80211com_target));

	ictgt->ic_ampdu_limit         = adf_os_ntohl(ic->ic_ampdu_limit);
  907643:	9858      	s32i.n	a8, a5, 32

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  907645:	db30      	mov.n	a11, a3
  907647:	dc40      	mov.n	a12, a4
  907649:	ded0      	mov.n	a14, a13
  90764b:	5bff42        	call8	907354 <wmi_cmd_rsp>
  90764e:	d10f      	retw.n

00907650 <handle_rc_rate_update_cmd>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void handle_rc_rate_update_cmd(void *Context, A_UINT16 Command,
				      A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
  907650:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_rate_update_cmd *wmi_data = (struct wmi_rc_rate_update_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);

	ath_rate_node_update(sc, &sc->sc_sta[wmi_data->node_index],
  907653:	285000        	l8ui	a8, a5, 0
				      A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_rate_update_cmd *wmi_data = (struct wmi_rc_rate_update_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);
  907656:	2a5004        	l8ui	a10, a5, 4

	ath_rate_node_update(sc, &sc->sc_sta[wmi_data->node_index],
  907659:	0a8b11        	slli	a11, a8, 6
  90765c:	a8bb      	add.n	a11, a11, a8
  90765e:	08bb09        	addx2	a11, a11, a8
  907661:	295a30        	movi	a9, 0x530
				      A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_rate_update_cmd *wmi_data = (struct wmi_rc_rate_update_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);
  907664:	285005        	l8ui	a8, a5, 5

	ath_rate_node_update(sc, &sc->sc_sta[wmi_data->node_index],
  907667:	09bb0a        	addx4	a11, a11, a9
				      A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_rate_update_cmd *wmi_data = (struct wmi_rc_rate_update_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);
  90766a:	295006        	l8ui	a9, a5, 6
  90766d:	08aa10        	slli	a10, a10, 24
  907670:	008811        	slli	a8, a8, 16
  907673:	0a8802        	or	a8, a8, a10
  907676:	2d5007        	l8ui	a13, a5, 7
  907679:	089911        	slli	a9, a9, 8
  90767c:	089902        	or	a9, a9, a8

	ath_rate_node_update(sc, &sc->sc_sta[wmi_data->node_index],
  90767f:	2c5001        	l8ui	a12, a5, 1
  907682:	ab2b      	add.n	a11, a2, a11
  907684:	09dd02        	or	a13, a13, a9
  907687:	b85e      	addi.n	a14, a5, 8
  907689:	da20      	mov.n	a10, a2
  90768b:	2bbc08        	addi	a11, a11, 8
  90768e:	580600        	call8	908e90 <ath_rate_node_update>
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void handle_rc_rate_update_cmd(void *Context, A_UINT16 Command,
				      A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
  907691:	03034f        	extui	a3, a3, 0, 16
  907694:	04044f        	extui	a4, a4, 0, 16
	ath_rate_node_update(sc, &sc->sc_sta[wmi_data->node_index],
			     wmi_data->isNew,
			     capflag,
			     &wmi_data->rs);

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  907697:	c0d0      	movi.n	a13, 0
  907699:	8a23      	l32i.n	a10, a2, 12
  90769b:	db30      	mov.n	a11, a3
  90769d:	dc40      	mov.n	a12, a4
  90769f:	ded0      	mov.n	a14, a13
  9076a1:	5bff2c        	call8	907354 <wmi_cmd_rsp>
  9076a4:	d10f      	retw.n
	...

009076a8 <handle_rc_state_change_cmd>:
}

static void handle_rc_state_change_cmd(void *Context, A_UINT16 Command,
				       A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)

{
  9076a8:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_state_change_cmd *wmi_data = (struct wmi_rc_state_change_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);

	ath_rate_newstate(sc, &sc->sc_vap[wmi_data->vap_index].av_vap,
  9076ab:	285000        	l8ui	a8, a5, 0
  9076ae:	1972a4        	l32r	a9, 8e4140 <vdesc_module_install+0x4>
  9076b1:	0c8b11        	slli	a11, a8, 4

{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_state_change_cmd *wmi_data = (struct wmi_rc_state_change_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);
  9076b4:	2a5004        	l8ui	a10, a5, 4

	ath_rate_newstate(sc, &sc->sc_vap[wmi_data->vap_index].av_vap,
  9076b7:	a8bb      	add.n	a11, a11, a8

{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_state_change_cmd *wmi_data = (struct wmi_rc_state_change_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);
  9076b9:	285005        	l8ui	a8, a5, 5

	ath_rate_newstate(sc, &sc->sc_vap[wmi_data->vap_index].av_vap,
  9076bc:	09bb0a        	addx4	a11, a11, a9

{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_state_change_cmd *wmi_data = (struct wmi_rc_state_change_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);
  9076bf:	295006        	l8ui	a9, a5, 6
  9076c2:	08aa10        	slli	a10, a10, 24
  9076c5:	008811        	slli	a8, a8, 16
  9076c8:	0a8802        	or	a8, a8, a10
  9076cb:	2d5007        	l8ui	a13, a5, 7
  9076ce:	089911        	slli	a9, a9, 8
  9076d1:	089902        	or	a9, a9, a8

	ath_rate_newstate(sc, &sc->sc_vap[wmi_data->vap_index].av_vap,
  9076d4:	2c5001        	l8ui	a12, a5, 1
  9076d7:	ab2b      	add.n	a11, a2, a11
  9076d9:	09dd02        	or	a13, a13, a9
  9076dc:	b85e      	addi.n	a14, a5, 8
  9076de:	da20      	mov.n	a10, a2
  9076e0:	b8bb      	addi.n	a11, a11, 8
  9076e2:	5805f0        	call8	908ea4 <ath_rate_newstate>
}

static void handle_rc_state_change_cmd(void *Context, A_UINT16 Command,
				       A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)

{
  9076e5:	03034f        	extui	a3, a3, 0, 16
  9076e8:	04044f        	extui	a4, a4, 0, 16
	ath_rate_newstate(sc, &sc->sc_vap[wmi_data->vap_index].av_vap,
			  wmi_data->vap_state,
			  capflag,
			  &wmi_data->rs);

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  9076eb:	c0d0      	movi.n	a13, 0
  9076ed:	8a23      	l32i.n	a10, a2, 12
  9076ef:	db30      	mov.n	a11, a3
  9076f1:	dc40      	mov.n	a12, a4
  9076f3:	ded0      	mov.n	a14, a13
  9076f5:	5bff17        	call8	907354 <wmi_cmd_rsp>
  9076f8:	d10f      	retw.n
	...

009076fc <ath_hal_reg_write_tgt>:
	}
}

static void ath_hal_reg_write_tgt(void *Context, A_UINT16 Command,
				  A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  9076fc:	6c1004        	entry	a1, 32
  9076ff:	03034f        	extui	a3, a3, 0, 16
  907702:	04044f        	extui	a4, a4, 0, 16
	struct registerWrite {
		a_uint32_t reg;
		a_uint32_t val;
	}*t;

	for (i = 0; i < datalen; i += sizeof(struct registerWrite)) {
  907705:	d750      	mov.n	a7, a5
  907707:	600009        	j	907714 <ath_hal_reg_write_tgt+0x18>
		t = (struct registerWrite *)(data+i);

		ath_hal_reg_write_filter(ah, t->reg, t->val);
  90770a:	8a70      	l32i.n	a10, a7, 0
  90770c:	8b71      	l32i.n	a11, a7, 4
  90770e:	277c08        	addi	a7, a7, 8
  907711:	5bfbdb        	call8	906680 <ath_hal_reg_write_filter$isra$10>

		iowrite32_mac(reg, val);
	}
}

static void ath_hal_reg_write_tgt(void *Context, A_UINT16 Command,
  907714:	05780c        	sub	a8, a7, a5
	struct registerWrite {
		a_uint32_t reg;
		a_uint32_t val;
	}*t;

	for (i = 0; i < datalen; i += sizeof(struct registerWrite)) {
  907717:	7682ef        	blt	a8, a6, 90770a <ath_hal_reg_write_tgt+0xe>
		t = (struct registerWrite *)(data+i);

		ath_hal_reg_write_filter(ah, t->reg, t->val);
	}

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  90771a:	c0d0      	movi.n	a13, 0
  90771c:	8a23      	l32i.n	a10, a2, 12
  90771e:	db30      	mov.n	a11, a3
  907720:	dc40      	mov.n	a12, a4
  907722:	0dde02        	or	a14, a13, a13
  907725:	5bff0b        	call8	907354 <wmi_cmd_rsp>
  907728:	d10f      	retw.n
	...

0090772c <ath_hal_reg_read_tgt>:
		return ioread32_mac(addr);
}

static void ath_hal_reg_read_tgt(void *Context, A_UINT16 Command,
				 A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  90772c:	6c1016        	entry	a1, 176
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  90772f:	272d05        	addmi	a7, a2, 0x500
  907732:	887b      	l32i.n	a8, a7, 44
		return ioread32_mac(addr);
}

static void ath_hal_reg_read_tgt(void *Context, A_UINT16 Command,
				 A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907734:	03034f        	extui	a3, a3, 0, 16
  907737:	04044f        	extui	a4, a4, 0, 16
	struct ath_hal *ah = sc->sc_ah;
	a_uint32_t addr;
	a_uint32_t val[32];
	int i;

	for (i = 0; i < datalen; i += sizeof(a_int32_t)) {
  90773a:	c070      	movi.n	a7, 0
  90773c:	600019        	j	907759 <ath_hal_reg_read_tgt+0x2d>
  90773f:	00a759        	extui	a7, a0, 26, 10
		addr = *(a_uint32_t *)(data + i);
		addr = adf_os_ntohl(addr);

		val[i/sizeof(a_int32_t)] =
			adf_os_ntohl(ath_reg_read_filter(ah, addr));
  907742:	8b90      	l32i.n	a11, a9, 0
  907744:	da80      	mov.n	a10, a8
  907746:	281620        	s32i	a8, a1, 128
  907749:	5bfbf1        	call8	906710 <ath_reg_read_filter>

	for (i = 0; i < datalen; i += sizeof(a_int32_t)) {
		addr = *(a_uint32_t *)(data + i);
		addr = adf_os_ntohl(addr);

		val[i/sizeof(a_int32_t)] =
  90774c:	072914        	srli	a9, a7, 2
  90774f:	01990a        	addx4	a9, a9, a1
	else
		/* MAC registers */
		return ioread32_mac(addr);
}

static void ath_hal_reg_read_tgt(void *Context, A_UINT16 Command,
  907752:	281220        	l32i	a8, a1, 128

	for (i = 0; i < datalen; i += sizeof(a_int32_t)) {
		addr = *(a_uint32_t *)(data + i);
		addr = adf_os_ntohl(addr);

		val[i/sizeof(a_int32_t)] =
  907755:	9a90      	s32i.n	a10, a9, 0
	else
		/* MAC registers */
		return ioread32_mac(addr);
}

static void ath_hal_reg_read_tgt(void *Context, A_UINT16 Command,
  907757:	b477      	addi.n	a7, a7, 4
	struct ath_hal *ah = sc->sc_ah;
	a_uint32_t addr;
	a_uint32_t val[32];
	int i;

	for (i = 0; i < datalen; i += sizeof(a_int32_t)) {
  907759:	7672e3        	blt	a7, a6, 907740 <ath_hal_reg_read_tgt+0x14>

		val[i/sizeof(a_int32_t)] =
			adf_os_ntohl(ath_reg_read_filter(ah, addr));
	}

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &val[0], datalen);
  90775c:	8a23      	l32i.n	a10, a2, 12
  90775e:	db30      	mov.n	a11, a3
  907760:	dc40      	mov.n	a12, a4
  907762:	dd10      	mov.n	a13, a1
  907764:	de60      	mov.n	a14, a6
  907766:	5bfefb        	call8	907354 <wmi_cmd_rsp>
  907769:	d10f      	retw.n
	...

0090776c <ath_vap_create_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_vap_create_tgt(void *Context, A_UINT16 Command, A_UINT16 SeqNo,
			       A_UINT8 *data, a_int32_t datalen)
{
  90776c:	6c1006        	entry	a1, 48
	vap->iv_rtsthreshold    = adf_os_ntohs(vap->iv_rtsthreshold);
	vap->iv_opmode          = adf_os_ntohl(vap->iv_opmode);

	vap_index = vap->iv_vapindex;

	adf_os_assert(sc->sc_vap[vap_index].av_valid == 0);
  90776f:	265000        	l8ui	a6, a5, 0
  907772:	1772a3        	l32r	a7, 8e4200 <vdesc_module_install+0xc4>
  907775:	0c6811        	slli	a8, a6, 4
  907778:	a688      	add.n	a8, a8, a6
  90777a:	0e8811        	slli	a8, a8, 2
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_vap_create_tgt(void *Context, A_UINT16 Command, A_UINT16 SeqNo,
			       A_UINT8 *data, a_int32_t datalen)
{
  90777d:	03094f        	extui	a9, a3, 0, 16
	vap->iv_rtsthreshold    = adf_os_ntohs(vap->iv_rtsthreshold);
	vap->iv_opmode          = adf_os_ntohl(vap->iv_opmode);

	vap_index = vap->iv_vapindex;

	adf_os_assert(sc->sc_vap[vap_index].av_valid == 0);
  907780:	a823      	add.n	a3, a2, a8
  907782:	a737      	add.n	a7, a3, a7
  907784:	26700a        	l8ui	a6, a7, 10
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_vap_create_tgt(void *Context, A_UINT16 Command, A_UINT16 SeqNo,
			       A_UINT8 *data, a_int32_t datalen)
{
  907787:	04044f        	extui	a4, a4, 0, 16
	vap->iv_rtsthreshold    = adf_os_ntohs(vap->iv_rtsthreshold);
	vap->iv_opmode          = adf_os_ntohl(vap->iv_opmode);

	vap_index = vap->iv_vapindex;

	adf_os_assert(sc->sc_vap[vap_index].av_valid == 0);
  90778a:	006632        	sext	a6, a6, 7
  90778d:	c863      	beqz.n	a6, 907794 <ath_vap_create_tgt+0x28>
  90778f:	63fffc        	j	90778f <ath_vap_create_tgt+0x23>
  907792:	00001a        	sll	a0, a0

	adf_os_mem_copy(&(sc->sc_vap[vap_index].av_vap), vap,
  907795:	72a4db        	ball	a10, a2, 907774 <ath_vap_create_tgt+0x8>
  907798:	50aa88        	call0	9321bc <_etext+0x272f7>
  90779b:	a82a      	add.n	a10, a2, a8
  90779d:	b8aa      	addi.n	a10, a10, 8
  90779f:	2c0a0c        	movi	a12, 12
  9077a2:	291600        	s32i	a9, a1, 0
  9077a5:	5bfb22        	call8	906430 <__adf_os_mem_copy>
			VAP_TARGET_SIZE);

	sc->sc_vap[vap_index].av_bcbuf = asf_tailq_first(&(sc->sc_bbuf));
  9077a8:	1572a8        	l32r	a5, 8e4248 <vdesc_module_install+0x10c>
	sc->sc_vap[vap_index].av_valid = 1;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  9077ab:	dc40      	mov.n	a12, a4
	adf_os_assert(sc->sc_vap[vap_index].av_valid == 0);

	adf_os_mem_copy(&(sc->sc_vap[vap_index].av_vap), vap,
			VAP_TARGET_SIZE);

	sc->sc_vap[vap_index].av_bcbuf = asf_tailq_first(&(sc->sc_bbuf));
  9077ad:	a533      	add.n	a3, a3, a5
  9077af:	252d16        	addmi	a5, a2, 0x1600
  9077b2:	855a      	l32i.n	a5, a5, 40
	sc->sc_vap[vap_index].av_valid = 1;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  9077b4:	dd60      	mov.n	a13, a6
	adf_os_assert(sc->sc_vap[vap_index].av_valid == 0);

	adf_os_mem_copy(&(sc->sc_vap[vap_index].av_vap), vap,
			VAP_TARGET_SIZE);

	sc->sc_vap[vap_index].av_bcbuf = asf_tailq_first(&(sc->sc_bbuf));
  9077b6:	9533      	s32i.n	a5, a3, 12
	sc->sc_vap[vap_index].av_valid = 1;
  9077b8:	c031      	movi.n	a3, 1
  9077ba:	23740a        	s8i	a3, a7, 10

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  9077bd:	8910      	l32i.n	a9, a1, 0
  9077bf:	8a23      	l32i.n	a10, a2, 12
  9077c1:	db90      	mov.n	a11, a9
  9077c3:	de60      	mov.n	a14, a6
  9077c5:	5bfee3        	call8	907354 <wmi_cmd_rsp>
  9077c8:	d10f      	retw.n
	...

009077cc <ath_vap_delete_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_vap_delete_tgt(void *Context, A_UINT16 Command,
			       A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  9077cc:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	a_uint8_t vap_index;

	vap_index = *(a_uint8_t *)data;
  9077cf:	295000        	l8ui	a9, a5, 0
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_vap_delete_tgt(void *Context, A_UINT16 Command,
			       A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  9077d2:	030b4f        	extui	a11, a3, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	a_uint8_t vap_index;

	vap_index = *(a_uint8_t *)data;

	sc->sc_vap[vap_index].av_valid = 0;
  9077d5:	0c9811        	slli	a8, a9, 4
  9077d8:	a988      	add.n	a8, a8, a9
  9077da:	1372a3        	l32r	a3, 8e4268 <vdesc_module_install+0x12c>
  9077dd:	02880a        	addx4	a8, a8, a2
  9077e0:	a383      	add.n	a3, a8, a3
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_vap_delete_tgt(void *Context, A_UINT16 Command,
			       A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  9077e2:	040c4f        	extui	a12, a4, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	a_uint8_t vap_index;

	vap_index = *(a_uint8_t *)data;

	sc->sc_vap[vap_index].av_valid = 0;
  9077e5:	c040      	movi.n	a4, 0
  9077e7:	24340a        	s8i	a4, a3, 10
	sc->sc_vap[vap_index].av_bcbuf = NULL;
  9077ea:	1372a8        	l32r	a3, 8e428c <vdesc_module_install+0x150>

static void ath_node_vdelete_tgt(struct ath_softc_tgt *sc, a_uint8_t vap_index)
{
	a_int32_t i;

	for (i = 0; i < TARGET_NODE_MAX; i++) {
  9077ed:	1d72a9        	l32r	a13, 8e4294 <vdesc_module_install+0x158>
	a_uint8_t vap_index;

	vap_index = *(a_uint8_t *)data;

	sc->sc_vap[vap_index].av_valid = 0;
	sc->sc_vap[vap_index].av_bcbuf = NULL;
  9077f0:	a383      	add.n	a3, a8, a3
  9077f2:	c080      	movi.n	a8, 0
  9077f4:	9833      	s32i.n	a8, a3, 12
		ath_hal_reg_write_filter(ah, buf->reg, val);
	}
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_vap_delete_tgt(void *Context, A_UINT16 Command,
  9077f6:	2f5a45        	movi	a15, 0x545
  9077f9:	237a3c        	movi	a3, 0x73c
{
	a_int32_t i;

	for (i = 0; i < TARGET_NODE_MAX; i++) {
		if(sc->sc_sta[i].ni.ni_vapindex == vap_index)
			sc->sc_sta[i].an_valid = 0;
  9077fc:	d480      	mov.n	a4, a8
  9077fe:	2e2a0c        	movi	a14, 0x20c
		ath_hal_reg_write_filter(ah, buf->reg, val);
	}
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_vap_delete_tgt(void *Context, A_UINT16 Command,
  907801:	a82a      	add.n	a10, a2, a8
  907803:	afa5      	add.n	a5, a10, a15
static void ath_node_vdelete_tgt(struct ath_softc_tgt *sc, a_uint8_t vap_index)
{
	a_int32_t i;

	for (i = 0; i < TARGET_NODE_MAX; i++) {
		if(sc->sc_sta[i].ni.ni_vapindex == vap_index)
  907805:	255000        	l8ui	a5, a5, 0
  907808:	795904        	bne	a5, a9, 907810 <ath_vap_delete_tgt+0x44>
		ath_hal_reg_write_filter(ah, buf->reg, val);
	}
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_vap_delete_tgt(void *Context, A_UINT16 Command,
  90780b:	a3aa      	add.n	a10, a10, a3
{
	a_int32_t i;

	for (i = 0; i < TARGET_NODE_MAX; i++) {
		if(sc->sc_sta[i].ni.ni_vapindex == vap_index)
			sc->sc_sta[i].an_valid = 0;
  90780d:	24a400        	s8i	a4, a10, 0
  907810:	ae88      	add.n	a8, a8, a14

static void ath_node_vdelete_tgt(struct ath_softc_tgt *sc, a_uint8_t vap_index)
{
	a_int32_t i;

	for (i = 0; i < TARGET_NODE_MAX; i++) {
  907812:	7d89eb        	bne	a8, a13, 907801 <ath_vap_delete_tgt+0x35>
	vap_index = *(a_uint8_t *)data;

	sc->sc_vap[vap_index].av_valid = 0;
	sc->sc_vap[vap_index].av_bcbuf = NULL;
	ath_node_vdelete_tgt(sc, vap_index);
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  907815:	c0d0      	movi.n	a13, 0
  907817:	8a23      	l32i.n	a10, a2, 12
  907819:	ded0      	mov.n	a14, a13
  90781b:	5bfece        	call8	907354 <wmi_cmd_rsp>
  90781e:	d10f      	retw.n

00907820 <ath_node_cleanup_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_node_cleanup_tgt(void *Context, A_UINT16 Command,
				 A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907820:	6c1004        	entry	a1, 32
	a_uint8_t node_index;
	a_uint8_t *nodedata;

	nodedata = (a_uint8_t *)data;
	node_index = *nodedata;
	sc->sc_sta[node_index].an_valid = 0;
  907823:	285000        	l8ui	a8, a5, 0

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  907826:	c0d0      	movi.n	a13, 0
	a_uint8_t node_index;
	a_uint8_t *nodedata;

	nodedata = (a_uint8_t *)data;
	node_index = *nodedata;
	sc->sc_sta[node_index].an_valid = 0;
  907828:	0a8911        	slli	a9, a8, 6
  90782b:	a899      	add.n	a9, a9, a8
  90782d:	089809        	addx2	a8, a9, a8
  907830:	02880a        	addx4	a8, a8, a2
  907833:	297a30        	movi	a9, 0x730
  907836:	a988      	add.n	a8, a8, a9
  907838:	c090      	movi.n	a9, 0
  90783a:	29840c        	s8i	a9, a8, 12

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  90783d:	8a23      	l32i.n	a10, a2, 12
  90783f:	030b4f        	extui	a11, a3, 0, 16
  907842:	040c4f        	extui	a12, a4, 0, 16
  907845:	ded0      	mov.n	a14, a13
  907847:	5bfec3        	call8	907354 <wmi_cmd_rsp>
  90784a:	d10f      	retw.n

0090784c <ath_node_create_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_node_create_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  90784c:	6c1004        	entry	a1, 32
	a_uint8_t vap_index;
	a_uint8_t node_index;

	node = (struct ieee80211_node_target *)data;

	node_index = node->ni_nodeindex;
  90784f:	26500c        	l8ui	a6, a5, 12
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_node_create_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907852:	db50      	mov.n	a11, a5

	node->ni_htcap = adf_os_ntohs(node->ni_htcap);
	node->ni_flags = adf_os_ntohs(node->ni_flags);
	node->ni_maxampdu = adf_os_ntohs(node->ni_maxampdu);

	adf_os_mem_copy(&(sc->sc_sta[node_index].ni), node,
  907854:	0a6511        	slli	a5, a6, 6
  907857:	a655      	add.n	a5, a5, a6
  907859:	065509        	addx2	a5, a5, a6
  90785c:	0e5511        	slli	a5, a5, 2
  90785f:	275a30        	movi	a7, 0x530
  907862:	a75a      	add.n	a10, a5, a7
  907864:	aa2a      	add.n	a10, a2, a10
  907866:	b8aa      	addi.n	a10, a10, 8
			NODE_TARGET_SIZE);

    	vap_index = sc->sc_sta[node_index].ni.ni_vapindex;
  907868:	a525      	add.n	a5, a2, a5
  90786a:	2c0a16        	movi	a12, 22
  90786d:	5bfaf0        	call8	906430 <__adf_os_mem_copy>
  907870:	a757      	add.n	a7, a5, a7
	sc->sc_sta[node_index].ni.ni_vap = &(sc->sc_vap[vap_index].av_vap);
  907872:	287015        	l8ui	a8, a7, 21
  907875:	295a50        	movi	a9, 0x550
  907878:	a955      	add.n	a5, a5, a9
  90787a:	0c8911        	slli	a9, a8, 4
  90787d:	a899      	add.n	a9, a9, a8
  90787f:	1872a4        	l32r	a8, 8e4310 <vdesc_module_install+0x1d4>
  907882:	0e9911        	slli	a9, a9, 2
  907885:	a89a      	add.n	a10, a9, a8
  907887:	aa2a      	add.n	a10, a2, a10
  907889:	b8aa      	addi.n	a10, a10, 8
  90788b:	9a52      	s32i.n	a10, a5, 8
	if(sc->sc_sta[node_index].ni.ni_is_vapnode == 1)
  90788d:	257016        	l8ui	a5, a7, 22
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_node_create_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907890:	03034f        	extui	a3, a3, 0, 16
  907893:	04044f        	extui	a4, a4, 0, 16
	adf_os_mem_copy(&(sc->sc_sta[node_index].ni), node,
			NODE_TARGET_SIZE);

    	vap_index = sc->sc_sta[node_index].ni.ni_vapindex;
	sc->sc_sta[node_index].ni.ni_vap = &(sc->sc_vap[vap_index].av_vap);
	if(sc->sc_sta[node_index].ni.ni_is_vapnode == 1)
  907896:	695106        	bnei	a5, 1, 9078a0 <ath_node_create_tgt+0x54>
		sc->sc_vap[vap_index].av_vap.iv_nodeindex = node_index;
  907899:	a929      	add.n	a9, a2, a9
  90789b:	a898      	add.n	a8, a9, a8
  90789d:	268415        	s8i	a6, a8, 21

	sc->sc_sta[node_index].an_valid = 1;
  9078a0:	0a6511        	slli	a5, a6, 6
  9078a3:	a655      	add.n	a5, a5, a6
  9078a5:	065609        	addx2	a6, a5, a6
  9078a8:	0e6611        	slli	a6, a6, 2
  9078ab:	a625      	add.n	a5, a2, a6
  9078ad:	277a30        	movi	a7, 0x730
  9078b0:	a757      	add.n	a7, a5, a7
  9078b2:	c081      	movi.n	a8, 1
  9078b4:	28740c        	s8i	a8, a7, 12
	sc->sc_sta[node_index].ni.ni_txseqmgmt = 0;
	sc->sc_sta[node_index].ni.ni_iv16 = 0;
	sc->sc_sta[node_index].ni.ni_iv32 = 0;

	owl_tgt_node_init(&sc->sc_sta[node_index]);
  9078b7:	2a5a30        	movi	a10, 0x530
	sc->sc_sta[node_index].ni.ni_vap = &(sc->sc_vap[vap_index].av_vap);
	if(sc->sc_sta[node_index].ni.ni_is_vapnode == 1)
		sc->sc_vap[vap_index].av_vap.iv_nodeindex = node_index;

	sc->sc_sta[node_index].an_valid = 1;
	sc->sc_sta[node_index].ni.ni_txseqmgmt = 0;
  9078ba:	285a40        	movi	a8, 0x540
  9078bd:	a858      	add.n	a8, a5, a8
	sc->sc_sta[node_index].ni.ni_iv16 = 0;
	sc->sc_sta[node_index].ni.ni_iv32 = 0;

	owl_tgt_node_init(&sc->sc_sta[node_index]);
  9078bf:	aa66      	add.n	a6, a6, a10
	sc->sc_sta[node_index].ni.ni_vap = &(sc->sc_vap[vap_index].av_vap);
	if(sc->sc_sta[node_index].ni.ni_is_vapnode == 1)
		sc->sc_vap[vap_index].av_vap.iv_nodeindex = node_index;

	sc->sc_sta[node_index].an_valid = 1;
	sc->sc_sta[node_index].ni.ni_txseqmgmt = 0;
  9078c1:	c050      	movi.n	a5, 0
  9078c3:	258508        	s16i	a5, a8, 16
	sc->sc_sta[node_index].ni.ni_iv16 = 0;
  9078c6:	258509        	s16i	a5, a8, 18
	sc->sc_sta[node_index].ni.ni_iv32 = 0;

	owl_tgt_node_init(&sc->sc_sta[node_index]);
  9078c9:	a62a      	add.n	a10, a2, a6
		sc->sc_vap[vap_index].av_vap.iv_nodeindex = node_index;

	sc->sc_sta[node_index].an_valid = 1;
	sc->sc_sta[node_index].ni.ni_txseqmgmt = 0;
	sc->sc_sta[node_index].ni.ni_iv16 = 0;
	sc->sc_sta[node_index].ni.ni_iv32 = 0;
  9078cb:	c050      	movi.n	a5, 0
  9078cd:	9585      	s32i.n	a5, a8, 20

	owl_tgt_node_init(&sc->sc_sta[node_index]);
  9078cf:	b8aa      	addi.n	a10, a10, 8
  9078d1:	5807c4        	call8	9097e4 <owl_tgt_node_init>

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  9078d4:	8a23      	l32i.n	a10, a2, 12
  9078d6:	db30      	mov.n	a11, a3
  9078d8:	dc40      	mov.n	a12, a4
  9078da:	dd50      	mov.n	a13, a5
  9078dc:	de50      	mov.n	a14, a5
  9078de:	5bfe9d        	call8	907354 <wmi_cmd_rsp>
  9078e1:	d10f      	retw.n
	...

009078e4 <ath_setcurmode_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_setcurmode_tgt(void *Context, A_UINT16 Command,
			       A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  9078e4:	6c1004        	entry	a1, 32
 * @param[in] size  buffer size
 */
static inline void
adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
{
    __adf_os_mem_set(buf, b, size);
  9078e7:	2a2a08        	movi	a10, 0x208
	a_uint16_t mode;

	mode= *((a_uint16_t *)data);
	mode = adf_os_ntohs(mode);

	ath_setcurmode(sc, mode);
  9078ea:	255100        	l16ui	a5, a5, 0
  9078ed:	aa2a      	add.n	a10, a2, a10
  9078ef:	2b0aff        	movi	a11, 255
  9078f2:	2c1a00        	movi	a12, 0x100
  9078f5:	5bfad3        	call8	906444 <__adf_os_mem_set>
	const HAL_RATE_TABLE *rt;
	a_int32_t i;

	adf_os_mem_set(sc->sc_rixmap, 0xff, sizeof(sc->sc_rixmap));

	rt = sc->sc_rates[mode];
  9078f8:	02580a        	addx4	a8, a5, a2
  9078fb:	28827f        	l32i	a8, a8, 0x1fc
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_setcurmode_tgt(void *Context, A_UINT16 Command,
			       A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  9078fe:	03034f        	extui	a3, a3, 0, 16
  907901:	04044f        	extui	a4, a4, 0, 16
	a_int32_t i;

	adf_os_mem_set(sc->sc_rixmap, 0xff, sizeof(sc->sc_rixmap));

	rt = sc->sc_rates[mode];
	adf_os_assert(rt != NULL);
  907904:	c885      	beqz.n	a8, 90790d <ath_setcurmode_tgt+0x29>
  907906:	da80      	mov.n	a10, a8
  907908:	c090      	movi.n	a9, 0
  90790a:	60000f        	j	90791d <ath_setcurmode_tgt+0x39>
  90790d:	63fffc        	j	90790d <ath_setcurmode_tgt+0x29>

	for (i = 0; i < rt->rateCount; i++) {
		sc->sc_rixmap[rt->info[i].rateCode] = i;
  907910:	2ba020        	l8ui	a11, a10, 32
  907913:	ab2b      	add.n	a11, a2, a11
  907915:	2bbd02        	addmi	a11, a11, 0x200
  907918:	29b408        	s8i	a9, a11, 8
	adf_os_mem_set(sc->sc_rixmap, 0xff, sizeof(sc->sc_rixmap));

	rt = sc->sc_rates[mode];
	adf_os_assert(rt != NULL);

	for (i = 0; i < rt->rateCount; i++) {
  90791b:	b199      	addi.n	a9, a9, 1
  90791d:	8b80      	l32i.n	a11, a8, 0
  90791f:	2aac10        	addi	a10, a10, 16
  907922:	7b92ea        	blt	a9, a11, 907910 <ath_setcurmode_tgt+0x2c>
		sc->sc_rixmap[rt->info[i].rateCode] = i;
	}

	sc->sc_currates = rt;
	sc->sc_curmode = mode;
	sc->sc_protrix = ((mode == IEEE80211_MODE_11NG) ? 3 : 0);
  907925:	c0e0      	movi.n	a14, 0

	for (i = 0; i < rt->rateCount; i++) {
		sc->sc_rixmap[rt->info[i].rateCode] = i;
	}

	sc->sc_currates = rt;
  907927:	282681        	s32i	a8, a2, 0x204
	sc->sc_curmode = mode;
  90792a:	2526c2        	s32i	a5, a2, 0x308
	sc->sc_protrix = ((mode == IEEE80211_MODE_11NG) ? 3 : 0);
  90792d:	c083      	movi.n	a8, 3
  90792f:	b055      	addi.n	a5, a5, -1
  907931:	05e839        	movnez	a8, a14, a5
	mode= *((a_uint16_t *)data);
	mode = adf_os_ntohs(mode);

	ath_setcurmode(sc, mode);

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  907934:	8a23      	l32i.n	a10, a2, 12
		sc->sc_rixmap[rt->info[i].rateCode] = i;
	}

	sc->sc_currates = rt;
	sc->sc_curmode = mode;
	sc->sc_protrix = ((mode == IEEE80211_MODE_11NG) ? 3 : 0);
  907936:	252d03        	addmi	a5, a2, 0x300
  907939:	28540c        	s8i	a8, a5, 12
	mode= *((a_uint16_t *)data);
	mode = adf_os_ntohs(mode);

	ath_setcurmode(sc, mode);

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  90793c:	db30      	mov.n	a11, a3
  90793e:	dc40      	mov.n	a12, a4
  907940:	dde0      	mov.n	a13, a14
  907942:	5bfe84        	call8	907354 <wmi_cmd_rsp>
  907945:	d10f      	retw.n
	...

00907948 <ath_flushrecv_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo,NULL, 0);
}

static void ath_flushrecv_tgt(void *Context, A_UINT16 Command,
			      A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907948:	6c1004        	entry	a1, 32
  90794b:	03034f        	extui	a3, a3, 0, 16
  90794e:	04044f        	extui	a4, a4, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_rx_buf *bf;

	asf_tailq_foreach(bf, &sc->sc_rxbuf, bf_list)
  907951:	2522d5        	l32i	a5, a2, 0x354
  907954:	60002e        	j	907986 <ath_flushrecv_tgt+0x3e>
  907957:	000000        	ill
		if (bf->bf_skb != NULL) {
  90795a:	8658      	l32i.n	a6, a5, 32
  90795c:	ca64      	beqz.n	a6, 907984 <ath_flushrecv_tgt+0x3c>
static inline void
adf_nbuf_unmap(adf_os_device_t      osdev, 
               adf_os_dma_map_t     bmap, 
               adf_os_dma_dir_t     dir)
{
    __adf_nbuf_unmap(osdev, bmap, dir);
  90795e:	8b50      	l32i.n	a11, a5, 0
  907960:	2a2246        	l32i	a10, a2, 0x118
  907963:	c0c1      	movi.n	a12, 1
  907965:	5beee0        	call8	9034e8 <__adf_nbuf_unmap>
			adf_nbuf_unmap(sc->sc_dev, bf->bf_dmamap,
				       ADF_OS_DMA_FROM_DEVICE);
			ath_free_rx_skb(sc, adf_nbuf_queue_remove(&bf->bf_skbhead));
  907968:	187184        	l32r	a8, 8e3f78 <mUsbEPinHighBandSet+0x268>
  90796b:	8720      	l32i.n	a7, a2, 0
 * @return The head buf in the buf queue.
 */
static inline adf_nbuf_t
adf_nbuf_queue_remove(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_remove(head);
  90796d:	2a5c14        	addi	a10, a5, 20
  907970:	2682a3        	l32i	a6, a8, 0x28c
  907973:	5beec9        	call8	903498 <__adf_nbuf_queue_remove>
  907976:	dca0      	mov.n	a12, a10
  907978:	2b0a03        	movi	a11, 3
  90797b:	da70      	mov.n	a10, a7
  90797d:	0b6000        	callx8	a6
			bf->bf_skb = NULL;
  907980:	c060      	movi.n	a6, 0
  907982:	9658      	s32i.n	a6, a5, 32
			      A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_rx_buf *bf;

	asf_tailq_foreach(bf, &sc->sc_rxbuf, bf_list)
  907984:	8559      	l32i.n	a5, a5, 36
  907986:	655fd0        	bnez	a5, 90795a <ath_flushrecv_tgt+0x12>
				       ADF_OS_DMA_FROM_DEVICE);
			ath_free_rx_skb(sc, adf_nbuf_queue_remove(&bf->bf_skbhead));
			bf->bf_skb = NULL;
		}

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  907989:	8a23      	l32i.n	a10, a2, 12
  90798b:	db30      	mov.n	a11, a3
  90798d:	dc40      	mov.n	a12, a4
  90798f:	dd50      	mov.n	a13, a5
  907991:	de50      	mov.n	a14, a5
  907993:	5bfe70        	call8	907354 <wmi_cmd_rsp>
  907996:	d10f      	retw.n

00907998 <ath_stoprecv_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_stoprecv_tgt(void *Context, A_UINT16 Command,
			     A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907998:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  90799b:	252d05        	addmi	a5, a2, 0x500
  90799e:	855b      	l32i.n	a5, a5, 44
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_stoprecv_tgt(void *Context, A_UINT16 Command,
			     A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  9079a0:	03034f        	extui	a3, a3, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;

	ah->ah_stopPcuReceive(ah);
  9079a3:	285224        	l32i	a8, a5, 144
  9079a6:	055a02        	or	a10, a5, a5
  9079a9:	0b8000        	callx8	a8
	ah->ah_setRxFilter(ah, 0);
  9079ac:	8859      	l32i.n	a8, a5, 36
  9079ae:	da50      	mov.n	a10, a5
  9079b0:	c0b0      	movi.n	a11, 0
  9079b2:	0b8000        	callx8	a8
	ah->ah_stopDmaReceive(ah);
  9079b5:	285223        	l32i	a8, a5, 140
  9079b8:	da50      	mov.n	a10, a5
  9079ba:	0b8000        	callx8	a8

	sc->sc_rxlink = NULL;
  9079bd:	c0e0      	movi.n	a14, 0
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_stoprecv_tgt(void *Context, A_UINT16 Command,
			     A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  9079bf:	04044f        	extui	a4, a4, 0, 16
	ah->ah_stopPcuReceive(ah);
	ah->ah_setRxFilter(ah, 0);
	ah->ah_stopDmaReceive(ah);

	sc->sc_rxlink = NULL;
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  9079c2:	8a23      	l32i.n	a10, a2, 12

	ah->ah_stopPcuReceive(ah);
	ah->ah_setRxFilter(ah, 0);
	ah->ah_stopDmaReceive(ah);

	sc->sc_rxlink = NULL;
  9079c4:	2e26ef        	s32i	a14, a2, 0x3bc
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  9079c7:	db30      	mov.n	a11, a3
  9079c9:	dc40      	mov.n	a12, a4
  9079cb:	dde0      	mov.n	a13, a14
  9079cd:	5bfe61        	call8	907354 <wmi_cmd_rsp>
  9079d0:	d10f      	retw.n
	...

009079d4 <ath_startrecv_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_startrecv_tgt(void *Context, A_UINT16 Command,
			      A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  9079d4:	6c1004        	entry	a1, 32
#undef PA2DESC
}

static a_int32_t ath_startrecv(struct ath_softc_tgt *sc)
{
	struct ath_hal *ah = sc->sc_ah;
  9079d7:	252d05        	addmi	a5, a2, 0x500
  9079da:	865b      	l32i.n	a6, a5, 44
	struct ath_rx_desc *ds;

	sc->sc_rxbufsize = 1024+512+128;
  9079dc:	256a80        	movi	a5, 0x680
  9079df:	25264a        	s32i	a5, a2, 0x128
	sc->sc_rxlink = NULL;
  9079e2:	c050      	movi.n	a5, 0
  9079e4:	2526ef        	s32i	a5, a2, 0x3bc

	sc->sc_rxdesc_held = NULL;
  9079e7:	2526db        	s32i	a5, a2, 0x36c
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_startrecv_tgt(void *Context, A_UINT16 Command,
			      A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  9079ea:	03034f        	extui	a3, a3, 0, 16
  9079ed:	04044f        	extui	a4, a4, 0, 16
	sc->sc_rxbufsize = 1024+512+128;
	sc->sc_rxlink = NULL;

	sc->sc_rxdesc_held = NULL;

	asf_tailq_foreach(ds, &sc->sc_rxdesc, ds_list) {
  9079f0:	2522d9        	l32i	a5, a2, 0x364
  9079f3:	600027        	j	907a1e <ath_startrecv_tgt+0x4a>
		a_int32_t error = ath_rxdesc_init(sc, ds);
  9079f6:	da20      	mov.n	a10, a2
  9079f8:	db50      	mov.n	a11, a5
  9079fa:	5bfbcb        	call8	906928 <ath_rxdesc_init>
		if (error != 0) {
  9079fd:	65a049        	bnez	a10, 907a4a <ath_startrecv_tgt+0x76>
	sc->sc_rxbufsize = 1024+512+128;
	sc->sc_rxlink = NULL;

	sc->sc_rxdesc_held = NULL;

	asf_tailq_foreach(ds, &sc->sc_rxdesc, ds_list) {
  907a00:	2a504c        	l8ui	a10, a5, 76
  907a03:	29504d        	l8ui	a9, a5, 77
  907a06:	28504e        	l8ui	a8, a5, 78
  907a09:	08aa10        	slli	a10, a10, 24
  907a0c:	009911        	slli	a9, a9, 16
  907a0f:	0a9902        	or	a9, a9, a10
  907a12:	088811        	slli	a8, a8, 8
  907a15:	25504f        	l8ui	a5, a5, 79
  907a18:	098802        	or	a8, a8, a9
  907a1b:	085502        	or	a5, a5, a8
  907a1e:	655fd4        	bnez	a5, 9079f6 <ath_startrecv_tgt+0x22>
			return error;
		}
	}

	ds = asf_tailq_first(&sc->sc_rxdesc);
	ah->ah_setRxDP(ah, ds->ds_daddr);
  907a21:	2522d9        	l32i	a5, a2, 0x364
  907a24:	2a5048        	l8ui	a10, a5, 72
  907a27:	295049        	l8ui	a9, a5, 73
  907a2a:	28504a        	l8ui	a8, a5, 74
  907a2d:	08aa10        	slli	a10, a10, 24
  907a30:	009911        	slli	a9, a9, 16
  907a33:	0a9902        	or	a9, a9, a10
  907a36:	2b504b        	l8ui	a11, a5, 75
  907a39:	088811        	slli	a8, a8, 8
  907a3c:	098802        	or	a8, a8, a9
  907a3f:	25621f        	l32i	a5, a6, 124
  907a42:	da60      	mov.n	a10, a6
  907a44:	08bb02        	or	a11, a11, a8
  907a47:	0b5000        	callx8	a5
{

	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;

	ath_startrecv(sc);
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  907a4a:	c0d0      	movi.n	a13, 0
  907a4c:	8a23      	l32i.n	a10, a2, 12
  907a4e:	db30      	mov.n	a11, a3
  907a50:	dc40      	mov.n	a12, a4
  907a52:	0dde02        	or	a14, a13, a13
  907a55:	5bfe3f        	call8	907354 <wmi_cmd_rsp>
  907a58:	d10f      	retw.n
	...

00907a5c <ath_draintxq_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_draintxq_tgt(void *Context, A_UINT16 Command,
			     A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907a5c:	6c1004        	entry	a1, 32
	owltgt_txq_drain(sc, txq);
}

static void ath_draintxq(struct ath_softc_tgt *sc, HAL_BOOL drain_softq)
{
	struct ath_hal *ah = sc->sc_ah;
  907a5f:	262d05        	addmi	a6, a2, 0x500
	a_uint16_t i;
	struct ath_txq *txq = NULL;
	struct ath_atx_tid *tid = NULL;

	ath_tx_status_clear(sc);
  907a62:	da20      	mov.n	a10, a2
	sc->sc_tx_draining = 1;
  907a64:	252d01        	addmi	a5, a2, 0x100
	owltgt_txq_drain(sc, txq);
}

static void ath_draintxq(struct ath_softc_tgt *sc, HAL_BOOL drain_softq)
{
	struct ath_hal *ah = sc->sc_ah;
  907a67:	27620b        	l32i	a7, a6, 44
	a_uint16_t i;
	struct ath_txq *txq = NULL;
	struct ath_atx_tid *tid = NULL;

	ath_tx_status_clear(sc);
  907a6a:	58076f        	call8	909828 <ath_tx_status_clear>
	sc->sc_tx_draining = 1;
  907a6d:	295024        	l8ui	a9, a5, 36
  907a70:	c480      	movi.n	a8, 64
  907a72:	089802        	or	a8, a9, a8
  907a75:	285424        	s8i	a8, a5, 36

	ah->ah_stopTxDma(ah, sc->sc_bhalq);
  907a78:	2b501c        	l8ui	a11, a5, 28
  907a7b:	28720d        	l32i	a8, a7, 52
  907a7e:	077a02        	or	a10, a7, a7
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_draintxq_tgt(void *Context, A_UINT16 Command,
			     A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907a81:	03034f        	extui	a3, a3, 0, 16
  907a84:	04044f        	extui	a4, a4, 0, 16
	struct ath_atx_tid *tid = NULL;

	ath_tx_status_clear(sc);
	sc->sc_tx_draining = 1;

	ah->ah_stopTxDma(ah, sc->sc_bhalq);
  907a87:	0b8000        	callx8	a8
  907a8a:	c050      	movi.n	a5, 0

	for (i = 0; i < HAL_NUM_TX_QUEUES; i++)
		if (ATH_TXQ_SETUP(sc, i))
  907a8c:	272d03        	addmi	a7, a2, 0x300
  907a8f:	2770c8        	l8ui	a7, a7, 200
  907a92:	005004        	ssr	a5
  907a95:	07071b        	sra	a7, a7
  907a98:	7f7710        	bbci	a7, 31, 907aac <ath_draintxq_tgt+0x50>
			ath_tx_stopdma(sc, ATH_TXQ(sc, i));
  907a9b:	285c1e        	addi	a8, a5, 30
/* TX */
/******/

static void ath_tx_stopdma(struct ath_softc_tgt *sc, struct ath_txq *txq)
{
	struct ath_hal *ah = sc->sc_ah;
  907a9e:	8a6b      	l32i.n	a10, a6, 44

	ah->ah_stopTxDma(ah, sc->sc_bhalq);

	for (i = 0; i < HAL_NUM_TX_QUEUES; i++)
		if (ATH_TXQ_SETUP(sc, i))
			ath_tx_stopdma(sc, ATH_TXQ(sc, i));
  907aa0:	0b8811        	slli	a8, a8, 5

static void ath_tx_stopdma(struct ath_softc_tgt *sc, struct ath_txq *txq)
{
	struct ath_hal *ah = sc->sc_ah;

	ah->ah_stopTxDma(ah, txq->axq_qnum);
  907aa3:	a828      	add.n	a8, a2, a8
  907aa5:	87ad      	l32i.n	a7, a10, 52
  907aa7:	8b83      	l32i.n	a11, a8, 12
  907aa9:	0b7000        	callx8	a7
  907aac:	b155      	addi.n	a5, a5, 1
	ath_tx_status_clear(sc);
	sc->sc_tx_draining = 1;

	ah->ah_stopTxDma(ah, sc->sc_bhalq);

	for (i = 0; i < HAL_NUM_TX_QUEUES; i++)
  907aae:	6959da        	bnei	a5, 10, 907a8c <ath_draintxq_tgt+0x30>
  907ab1:	c050      	movi.n	a5, 0
			txq = ATH_TXQ(sc,i);
			while (!asf_tailq_empty(&txq->axq_tidq)){
				TAILQ_DEQ(&txq->axq_tidq, tid, tid_qelem);
				if(tid == NULL)
					break;
				tid->sched = AH_FALSE;
  907ab3:	d650      	mov.n	a6, a5
	for (i = 0; i < HAL_NUM_TX_QUEUES; i++)
		if (ATH_TXQ_SETUP(sc, i))
			ath_tx_stopdma(sc, ATH_TXQ(sc, i));

	for (i = 0; i < HAL_NUM_TX_QUEUES; i++)
		if (ATH_TXQ_SETUP(sc, i)) {
  907ab5:	272d03        	addmi	a7, a2, 0x300
  907ab8:	2770c8        	l8ui	a7, a7, 200
  907abb:	005004        	ssr	a5
  907abe:	07071b        	sra	a7, a7
  907ac1:	7f7f08        	bbsi	a7, 31, 907acd <ath_draintxq_tgt+0x71>
  907ac4:	b155      	addi.n	a5, a5, 1

	for (i = 0; i < HAL_NUM_TX_QUEUES; i++)
		if (ATH_TXQ_SETUP(sc, i))
			ath_tx_stopdma(sc, ATH_TXQ(sc, i));

	for (i = 0; i < HAL_NUM_TX_QUEUES; i++)
  907ac6:	6959eb        	bnei	a5, 10, 907ab5 <ath_draintxq_tgt+0x59>
  907ac9:	600039        	j	907b06 <ath_draintxq_tgt+0xaa>
  907acc:	00275c        	extui	a7, a0, 18, 13
		if (ATH_TXQ_SETUP(sc, i)) {
			owltgt_tx_processq(sc, ATH_TXQ(sc,i), OWL_TXQ_STOPPED);
  907acf:	1e0b77        	l32r	a14, 8ca8ac <_bss_end+0x3bd0a4>
  907ad2:	11a727        	l32r	a1, 8f1770 <memset+0xc5d4>
  907ad5:	bc77      	addi.n	a7, a7, 12
  907ad7:	da20      	mov.n	a10, a2
  907ad9:	db70      	mov.n	a11, a7
  907adb:	c0c1      	movi.n	a12, 1
  907add:	580bee        	call8	90aa98 <owltgt_tx_processq>
  907ae0:	60001a        	j	907afe <ath_draintxq_tgt+0xa2>
  907ae3:	0089b9        	excw

			txq = ATH_TXQ(sc,i);
			while (!asf_tailq_empty(&txq->axq_tidq)){
				TAILQ_DEQ(&txq->axq_tidq, tid, tid_qelem);
  907ae6:	8aba      	l32i.n	a10, a11, 40
  907ae8:	c894      	beqz.n	a9, 907af0 <ath_draintxq_tgt+0x94>
  907aea:	9a9a      	s32i.n	a10, a9, 40
  907aec:	600002        	j	907af2 <ath_draintxq_tgt+0x96>
  907aef:	009a77        	excw
  907af2:	8aba      	l32i.n	a10, a11, 40
  907af4:	99a0      	s32i.n	a9, a10, 0
				if(tid == NULL)
					break;
				tid->sched = AH_FALSE;
  907af6:	26b435        	s8i	a6, a11, 53
				ath_tgt_tid_drain(sc,tid);
  907af9:	da20      	mov.n	a10, a2
  907afb:	580804        	call8	909b0c <ath_tgt_tid_drain>
	for (i = 0; i < HAL_NUM_TX_QUEUES; i++)
		if (ATH_TXQ_SETUP(sc, i)) {
			owltgt_tx_processq(sc, ATH_TXQ(sc,i), OWL_TXQ_STOPPED);

			txq = ATH_TXQ(sc,i);
			while (!asf_tailq_empty(&txq->axq_tidq)){
  907afe:	8b76      	l32i.n	a11, a7, 24
  907b00:	65bfe0        	bnez	a11, 907ae4 <ath_draintxq_tgt+0x88>
  907b03:	63ffbd        	j	907ac4 <ath_draintxq_tgt+0x68>
				tid->sched = AH_FALSE;
				ath_tgt_tid_drain(sc,tid);
			}
		}

	sc->sc_tx_draining = 0;
  907b06:	252d01        	addmi	a5, a2, 0x100
  907b09:	275024        	l8ui	a7, a5, 36
  907b0c:	26fabf        	movi	a6, -65
  907b0f:	067601        	and	a6, a7, a6
  907b12:	265424        	s8i	a6, a5, 36
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	HAL_BOOL b = (HAL_BOOL) *(a_int32_t *)data;

	ath_draintxq(Context, b);
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  907b15:	c0d0      	movi.n	a13, 0
  907b17:	8a23      	l32i.n	a10, a2, 12
  907b19:	db30      	mov.n	a11, a3
  907b1b:	dc40      	mov.n	a12, a4
  907b1d:	ded0      	mov.n	a14, a13
  907b1f:	5bfe0d        	call8	907354 <wmi_cmd_rsp>
  907b22:	d10f      	retw.n

00907b24 <ath_tx_draintxq_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_tx_draintxq_tgt(void *Context, A_UINT16 Command, A_UINT16 SeqNo,
				A_UINT8 *data, a_int32_t datalen)
{
  907b24:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	a_uint32_t q = *(a_uint32_t *)data;
	struct ath_txq *txq = NULL;

	q = adf_os_ntohl(q);
	txq = ATH_TXQ(sc, q);
  907b27:	8b50      	l32i.n	a11, a5, 0
	ah->ah_stopTxDma(ah, txq->axq_qnum);
}

static void owltgt_txq_drain(struct ath_softc_tgt *sc, struct ath_txq *txq)
{
	owltgt_tx_processq(sc, txq, OWL_TXQ_STOPPED);
  907b29:	da20      	mov.n	a10, a2
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	a_uint32_t q = *(a_uint32_t *)data;
	struct ath_txq *txq = NULL;

	q = adf_os_ntohl(q);
	txq = ATH_TXQ(sc, q);
  907b2b:	2bbc1e        	addi	a11, a11, 30
  907b2e:	0bbb11        	slli	a11, a11, 5
  907b31:	ab2b      	add.n	a11, a2, a11
	ah->ah_stopTxDma(ah, txq->axq_qnum);
}

static void owltgt_txq_drain(struct ath_softc_tgt *sc, struct ath_txq *txq)
{
	owltgt_tx_processq(sc, txq, OWL_TXQ_STOPPED);
  907b33:	2bbc0c        	addi	a11, a11, 12
  907b36:	2c0a01        	movi	a12, 1
  907b39:	580bd7        	call8	90aa98 <owltgt_tx_processq>
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_tx_draintxq_tgt(void *Context, A_UINT16 Command, A_UINT16 SeqNo,
				A_UINT8 *data, a_int32_t datalen)
{
  907b3c:	03034f        	extui	a3, a3, 0, 16
  907b3f:	04044f        	extui	a4, a4, 0, 16

	q = adf_os_ntohl(q);
	txq = ATH_TXQ(sc, q);

	ath_tx_draintxq(sc, txq);
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  907b42:	c0d0      	movi.n	a13, 0
  907b44:	8a23      	l32i.n	a10, a2, 12
  907b46:	db30      	mov.n	a11, a3
  907b48:	dc40      	mov.n	a12, a4
  907b4a:	0dde02        	or	a14, a13, a13
  907b4d:	5bfe01        	call8	907354 <wmi_cmd_rsp>
  907b50:	d10f      	retw.n
	...

00907b54 <ath_aborttx_dma_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_aborttx_dma_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907b54:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  907b57:	282d05        	addmi	a8, a2, 0x500
  907b5a:	8a8b      	l32i.n	a10, a8, 44
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_aborttx_dma_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907b5c:	03034f        	extui	a3, a3, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;

	ah->ah_abortTxDma(sc->sc_ah);
  907b5f:	28a20e        	l32i	a8, a10, 56
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_aborttx_dma_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907b62:	04044f        	extui	a4, a4, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;

	ah->ah_abortTxDma(sc->sc_ah);
  907b65:	0b8000        	callx8	a8
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  907b68:	c0d0      	movi.n	a13, 0
  907b6a:	8a23      	l32i.n	a10, a2, 12
  907b6c:	db30      	mov.n	a11, a3
  907b6e:	dc40      	mov.n	a12, a4
  907b70:	ded0      	mov.n	a14, a13
  907b72:	5bfdf8        	call8	907354 <wmi_cmd_rsp>
  907b75:	d10f      	retw.n
	...

00907b78 <ath_stop_tx_dma_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_stop_tx_dma_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907b78:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  907b7b:	292d05        	addmi	a9, a2, 0x500
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_stop_tx_dma_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907b7e:	03034f        	extui	a3, a3, 0, 16
  907b81:	04044f        	extui	a4, a4, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  907b84:	8a9b      	l32i.n	a10, a9, 44
	a_uint32_t q;

	if (data)
  907b86:	c850      	beqz.n	a5, 907b8a <ath_stop_tx_dma_tgt+0x12>
		q = *(a_uint32_t *)data;
  907b88:	8b50      	l32i.n	a11, a5, 0

	q = adf_os_ntohl(q);
	ah->ah_stopTxDma(ah, q);
  907b8a:	85ad      	l32i.n	a5, a10, 52
  907b8c:	0b5000        	callx8	a5
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  907b8f:	c0d0      	movi.n	a13, 0
  907b91:	8a23      	l32i.n	a10, a2, 12
  907b93:	db30      	mov.n	a11, a3
  907b95:	dc40      	mov.n	a12, a4
  907b97:	ded0      	mov.n	a14, a13
  907b99:	5bfdee        	call8	907354 <wmi_cmd_rsp>
  907b9c:	d10f      	retw.n
	...

00907ba0 <ath_aborttxq_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_aborttxq_tgt(void *Context, A_UINT16 Command,
			     A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907ba0:	6c1004        	entry	a1, 32
  907ba3:	03034f        	extui	a3, a3, 0, 16
  907ba6:	04044f        	extui	a4, a4, 0, 16
  907ba9:	250a00        	movi	a5, 0

	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	a_uint16_t i;

	for (i = 0; i < HAL_NUM_TX_QUEUES; i++) {
		if (ATH_TXQ_SETUP(sc, i))
  907bac:	282d03        	addmi	a8, a2, 0x300
  907baf:	2880c8        	l8ui	a8, a8, 200
  907bb2:	005004        	ssr	a5
  907bb5:	08081b        	sra	a8, a8
  907bb8:	7f8710        	bbci	a8, 31, 907bcc <ath_aborttxq_tgt+0x2c>
			ath_tx_draintxq(sc, ATH_TXQ(sc,i));
  907bbb:	2b5c1e        	addi	a11, a5, 30
  907bbe:	0bbb11        	slli	a11, a11, 5
  907bc1:	ab2b      	add.n	a11, a2, a11
	ah->ah_stopTxDma(ah, txq->axq_qnum);
}

static void owltgt_txq_drain(struct ath_softc_tgt *sc, struct ath_txq *txq)
{
	owltgt_tx_processq(sc, txq, OWL_TXQ_STOPPED);
  907bc3:	da20      	mov.n	a10, a2
  907bc5:	bcbb      	addi.n	a11, a11, 12
  907bc7:	c0c1      	movi.n	a12, 1
  907bc9:	580bb3        	call8	90aa98 <owltgt_tx_processq>
  907bcc:	b155      	addi.n	a5, a5, 1
{

	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	a_uint16_t i;

	for (i = 0; i < HAL_NUM_TX_QUEUES; i++) {
  907bce:	6959da        	bnei	a5, 10, 907bac <ath_aborttxq_tgt+0xc>
		if (ATH_TXQ_SETUP(sc, i))
			ath_tx_draintxq(sc, ATH_TXQ(sc,i));
	}

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  907bd1:	c0d0      	movi.n	a13, 0
  907bd3:	8a23      	l32i.n	a10, a2, 12
  907bd5:	db30      	mov.n	a11, a3
  907bd7:	dc40      	mov.n	a12, a4
  907bd9:	ded0      	mov.n	a14, a13
  907bdb:	5bfdde        	call8	907354 <wmi_cmd_rsp>
  907bde:	d10f      	retw.n

00907be0 <ath_init_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo,NULL, 0);
}

static void ath_init_tgt(void *Context, A_UINT16 Command,
			 A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907be0:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  907be3:	252d05        	addmi	a5, a2, 0x500
  907be6:	855b      	l32i.n	a5, a5, 44

	sc->sc_imask = HAL_INT_RX | HAL_INT_TX
		| HAL_INT_RXEOL | HAL_INT_RXORN
		| HAL_INT_FATAL | HAL_INT_GLOBAL;

	sc->sc_imask |= HAL_INT_GTT;
  907be8:	1872aa        	l32r	a8, 8e4690 <vdesc_module_install+0x554>

	if (ath_hal_getcapability(ah, HAL_CAP_HT))
  907beb:	055a02        	or	a10, a5, a5

	sc->sc_imask = HAL_INT_RX | HAL_INT_TX
		| HAL_INT_RXEOL | HAL_INT_RXORN
		| HAL_INT_FATAL | HAL_INT_GLOBAL;

	sc->sc_imask |= HAL_INT_GTT;
  907bee:	2826c4        	s32i	a8, a2, 0x310

	if (ath_hal_getcapability(ah, HAL_CAP_HT))
  907bf1:	c0b5      	movi.n	a11, 5
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo,NULL, 0);
}

static void ath_init_tgt(void *Context, A_UINT16 Command,
			 A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907bf3:	03034f        	extui	a3, a3, 0, 16
  907bf6:	04044f        	extui	a4, a4, 0, 16
		| HAL_INT_RXEOL | HAL_INT_RXORN
		| HAL_INT_FATAL | HAL_INT_GLOBAL;

	sc->sc_imask |= HAL_INT_GTT;

	if (ath_hal_getcapability(ah, HAL_CAP_HT))
  907bf9:	5bf4d1        	call8	904f40 <ath_hal_getcapability>
  907bfc:	c8aa      	beqz.n	a10, 907c0a <ath_init_tgt+0x2a>
		sc->sc_imask |= HAL_INT_CST;
  907bfe:	2922c4        	l32i	a9, a2, 0x310
  907c01:	18726a        	l32r	a8, 8e45ac <vdesc_module_install+0x470>
  907c04:	089802        	or	a8, a9, a8
  907c07:	2826c4        	s32i	a8, a2, 0x310
  907c0a:	2a2246        	l32i	a10, a2, 0x118
  907c0d:	1b7289        	l32r	a11, 8e4634 <vdesc_module_install+0x4f8>
  907c10:	5bf9fc        	call8	906404 <__adf_os_setup_intr>

	adf_os_setup_intr(sc->sc_dev, ath_intr);
	ah->ah_setInterrupts(ah, sc->sc_imask);
  907c13:	2b22c4        	l32i	a11, a2, 0x310
  907c16:	285228        	l32i	a8, a5, 160
  907c19:	da50      	mov.n	a10, a5
  907c1b:	0b8000        	callx8	a8

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  907c1e:	c0d0      	movi.n	a13, 0
  907c20:	8a23      	l32i.n	a10, a2, 12
  907c22:	db30      	mov.n	a11, a3
  907c24:	dc40      	mov.n	a12, a4
  907c26:	0dde02        	or	a14, a13, a13
  907c29:	5bfdca        	call8	907354 <wmi_cmd_rsp>
  907c2c:	d10f      	retw.n
	...

00907c30 <ath_enable_intr_tgt>:
/* WMI Commands */
/****************/

static void ath_enable_intr_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907c30:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  907c33:	292d05        	addmi	a9, a2, 0x500
/* WMI Commands */
/****************/

static void ath_enable_intr_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907c36:	03034f        	extui	a3, a3, 0, 16
  907c39:	04044f        	extui	a4, a4, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  907c3c:	8a9b      	l32i.n	a10, a9, 44
	a_uint32_t intr;

	if (data)
  907c3e:	645002        	beqz	a5, 907c44 <ath_enable_intr_tgt+0x14>
		intr = (*(a_uint32_t *)data);
  907c41:	285200        	l32i	a8, a5, 0

	intr = adf_os_ntohl(intr);

	if (intr & HAL_INT_SWBA) {
  907c44:	19720e        	l32r	a9, 8e447c <vdesc_module_install+0x340>
  907c47:	2522c4        	l32i	a5, a2, 0x310
  907c4a:	798006        	bnone	a8, a9, 907c54 <ath_enable_intr_tgt+0x24>
		sc->sc_imask |= HAL_INT_SWBA;
  907c4d:	095502        	or	a5, a5, a9
  907c50:	600006        	j	907c5a <ath_enable_intr_tgt+0x2a>
  907c53:	001972        	excw
	} else {
		sc->sc_imask &= ~HAL_INT_SWBA;
  907c56:	ab09      	add.n	a9, a0, a11
  907c58:	550125        	call4	9480f0 <_etext+0x3d22b>
  907c5b:	26c415        	s8i	a6, a12, 21
	}

	if (intr & HAL_INT_BMISS) {
  907c5e:	72ac75        	bnall	a10, a2, 907cd7 <handle_echo_command+0xb>
  907c61:	8008      	l32i.n	a0, a0, 32
		sc->sc_imask |= HAL_INT_BMISS;
  907c63:	2822c4        	l32i	a8, a2, 0x310
  907c66:	058502        	or	a5, a8, a5
  907c69:	2526c4        	s32i	a5, a2, 0x310
	}

	ah->ah_setInterrupts(ah, sc->sc_imask);
  907c6c:	2b22c4        	l32i	a11, a2, 0x310
  907c6f:	25a228        	l32i	a5, a10, 160
  907c72:	0b5000        	callx8	a5
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo,NULL, 0);
  907c75:	c0d0      	movi.n	a13, 0
  907c77:	8a23      	l32i.n	a10, a2, 12
  907c79:	db30      	mov.n	a11, a3
  907c7b:	dc40      	mov.n	a12, a4
  907c7d:	ded0      	mov.n	a14, a13
  907c7f:	5bfdb5        	call8	907354 <wmi_cmd_rsp>
  907c82:	d10f      	retw.n

00907c84 <ath_disable_intr_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_disable_intr_tgt(void *Context, A_UINT16 Command,
				 A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907c84:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  907c87:	282d05        	addmi	a8, a2, 0x500
  907c8a:	8a8b      	l32i.n	a10, a8, 44

	ah->ah_setInterrupts(ah, 0);
  907c8c:	2b0a00        	movi	a11, 0
  907c8f:	28a228        	l32i	a8, a10, 160
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_disable_intr_tgt(void *Context, A_UINT16 Command,
				 A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907c92:	03034f        	extui	a3, a3, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;

	ah->ah_setInterrupts(ah, 0);
  907c95:	0b8000        	callx8	a8
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_disable_intr_tgt(void *Context, A_UINT16 Command,
				 A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  907c98:	04044f        	extui	a4, a4, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;

	ah->ah_setInterrupts(ah, 0);
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo,NULL, 0);
  907c9b:	c0d0      	movi.n	a13, 0
  907c9d:	8a23      	l32i.n	a10, a2, 12
  907c9f:	db30      	mov.n	a11, a3
  907ca1:	dc40      	mov.n	a12, a4
  907ca3:	ded0      	mov.n	a14, a13
  907ca5:	5bfdab        	call8	907354 <wmi_cmd_rsp>
  907ca8:	d10f      	retw.n
	...

00907cac <ath_get_tgt_version>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
}

static void ath_get_tgt_version(void *Context,A_UINT16 Command, A_UINT16 SeqNo,
				A_UINT8 *data, a_int32_t datalen)
{
  907cac:	6c1006        	entry	a1, 48
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_fw_version ver;

	ver.major = ATH_VERSION_MAJOR;
  907caf:	c081      	movi.n	a8, 1
	ver.minor = ATH_VERSION_MINOR;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &ver, sizeof(ver));
  907cb1:	8a23      	l32i.n	a10, a2, 12
				A_UINT8 *data, a_int32_t datalen)
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_fw_version ver;

	ver.major = ATH_VERSION_MAJOR;
  907cb3:	281500        	s16i	a8, a1, 0
	ver.minor = ATH_VERSION_MINOR;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &ver, sizeof(ver));
  907cb6:	030b4f        	extui	a11, a3, 0, 16
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_fw_version ver;

	ver.major = ATH_VERSION_MAJOR;
	ver.minor = ATH_VERSION_MINOR;
  907cb9:	c084      	movi.n	a8, 4

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &ver, sizeof(ver));
  907cbb:	040c4f        	extui	a12, a4, 0, 16
  907cbe:	dd10      	mov.n	a13, a1
  907cc0:	c0e4      	movi.n	a14, 4
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_fw_version ver;

	ver.major = ATH_VERSION_MAJOR;
	ver.minor = ATH_VERSION_MINOR;
  907cc2:	281501        	s16i	a8, a1, 2

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &ver, sizeof(ver));
  907cc5:	5bfda3        	call8	907354 <wmi_cmd_rsp>
  907cc8:	d10f      	retw.n
	...

00907ccc <handle_echo_command>:
	adf_os_mem_free(sc);
}

static void handle_echo_command(void *pContext, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
  907ccc:	6c1004        	entry	a1, 32
	wmi_cmd_rsp(pContext, WMI_ECHO_CMDID, SeqNo, buffer, Length);
  907ccf:	da20      	mov.n	a10, a2
  907cd1:	c0b1      	movi.n	a11, 1
  907cd3:	040c4f        	extui	a12, a4, 0, 16
  907cd6:	dd50      	mov.n	a13, a5
  907cd8:	de60      	mov.n	a14, a6
  907cda:	5bfd9e        	call8	907354 <wmi_cmd_rsp>
  907cdd:	d10f      	retw.n
	...

00907ce0 <ath_get_minrateidx>:
			sc->sc_sta[i].an_valid = 0;
	}
}

a_uint8_t ath_get_minrateidx(struct ath_softc_tgt *sc, struct ath_vap_target *avp)
{
  907ce0:	6c1004        	entry	a1, 32
	if (sc->sc_curmode == IEEE80211_MODE_11NG)
  907ce3:	2822c2        	l32i	a8, a2, 0x308
  907ce6:	698104        	bnei	a8, 1, 907cee <ath_get_minrateidx+0xe>
		return avp->av_minrateidx[0];
  907ce9:	223040        	l8ui	a2, a3, 64
  907cec:	d10f      	retw.n
	else if (sc->sc_curmode == IEEE80211_MODE_11NA)
		return avp->av_minrateidx[1];

	return 0;
  907cee:	c020      	movi.n	a2, 0

a_uint8_t ath_get_minrateidx(struct ath_softc_tgt *sc, struct ath_vap_target *avp)
{
	if (sc->sc_curmode == IEEE80211_MODE_11NG)
		return avp->av_minrateidx[0];
	else if (sc->sc_curmode == IEEE80211_MODE_11NA)
  907cf0:	728902        	bne	a8, a2, 907cf6 <ath_get_minrateidx+0x16>
		return avp->av_minrateidx[1];
  907cf3:	223041        	l8ui	a2, a3, 65

	return 0;
}
  907cf6:	d10f      	retw.n

00907cf8 <tgt_HTCRecv_beaconhandler>:
#undef N
}

static void tgt_HTCRecv_beaconhandler(HTC_ENDPOINT_ID EndPt, adf_nbuf_t hdr_buf,
				      adf_nbuf_t buf, void *ServiceCtx)
{
  907cf8:	6c1018        	entry	a1, 192
}

static void ath_tgt_send_beacon(struct ath_softc_tgt *sc, adf_nbuf_t bc_hdr,
				adf_nbuf_t nbuf, HTC_ENDPOINT_ID EndPt)
{
	struct ath_hal *ah = sc->sc_ah;
  907cfb:	265d05        	addmi	a6, a5, 0x500
  907cfe:	866b      	l32i.n	a6, a6, 44
	ath_beacon_hdr_t *bhdr;
	struct ieee80211vap_target  *vap;
	a_uint32_t anblen;
	struct ieee80211_frame *wh;

	if (!bc_hdr) {
  907d00:	cd30      	bnez.n	a3, 907d14 <tgt_HTCRecv_beaconhandler+0x1c>
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  907d02:	da40      	mov.n	a10, a4
  907d04:	2b1c74        	addi	a11, a1, 116
  907d07:	2c1c70        	addi	a12, a1, 112
  907d0a:	5bee65        	call8	9036a0 <__adf_nbuf_peek_header>
		adf_nbuf_peek_header(nbuf, &anbdata, &anblen);
		bhdr = (ath_beacon_hdr_t *)anbdata;
  907d0d:	27121d        	l32i	a7, a1, 116
  907d10:	60000e        	j	907d22 <tgt_HTCRecv_beaconhandler+0x2a>
  907d13:	001871        	excw
	} else {
		adf_os_print("found bc_hdr! 0x%x\n", bc_hdr);
  907d16:	841a      	l32i.n	a4, a1, 40
  907d18:	72ad28        	bbs	a10, a2, 907d44 <tgt_HTCRecv_beaconhandler+0x4c>
  907d1b:	8212      	l32i.n	a2, a1, 8
  907d1d:	db30      	mov.n	a11, a3
  907d1f:	0b8000        	callx8	a8
	}

	vap_index = bhdr->vap_index;
  907d22:	277000        	l8ui	a7, a7, 0
	adf_os_assert(vap_index < TARGET_VAP_MAX);
  907d25:	6e7204        	bltui	a7, 2, 907d2d <tgt_HTCRecv_beaconhandler+0x35>
  907d28:	63fffc        	j	907d28 <tgt_HTCRecv_beaconhandler+0x30>
  907d2b:	0000da        	excw
 *         or NULL if there is not sufficient data to pull.
 */
static inline a_uint8_t *
adf_nbuf_pull_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_pull_head(buf, size);
  907d2e:	40c0b4        	excw
  907d31:	5bedb3        	call8	903400 <__adf_nbuf_pull_head>
	vap = &sc->sc_vap[vap_index].av_vap;

	wh = (struct ieee80211_frame *)adf_nbuf_pull_head(nbuf,
						  sizeof(ath_beacon_hdr_t));

	bf = sc->sc_vap[vap_index].av_bcbuf;
  907d34:	0c7311        	slli	a3, a7, 4
  907d37:	a733      	add.n	a3, a3, a7
  907d39:	1872a8        	l32r	a8, 8e47dc <vdesc_module_install+0x6a0>
  907d3c:	05330a        	addx4	a3, a3, a5
  907d3f:	a833      	add.n	a3, a3, a8
  907d41:	8333      	l32i.n	a3, a3, 12
	adf_os_assert(bf);
  907d43:	cc31      	bnez.n	a3, 907d48 <tgt_HTCRecv_beaconhandler+0x50>
  907d45:	63fffc        	j	907d45 <tgt_HTCRecv_beaconhandler+0x4d>
	bf->bf_endpt = EndPt;
  907d48:	223623        	s32i	a2, a3, 140

	if (bf->bf_skb) {
  907d4b:	8238      	l32i.n	a2, a3, 32
  907d4d:	c92f      	beqz.n	a2, 907d70 <tgt_HTCRecv_beaconhandler+0x78>
static inline void
adf_nbuf_unmap(adf_os_device_t      osdev, 
               adf_os_dma_map_t     bmap, 
               adf_os_dma_dir_t     dir)
{
    __adf_nbuf_unmap(osdev, bmap, dir);
  907d4f:	2a5246        	l32i	a10, a5, 0x118
  907d52:	8b30      	l32i.n	a11, a3, 0
  907d54:	c0c0      	movi.n	a12, 0
  907d56:	5bede4        	call8	9034e8 <__adf_nbuf_unmap>
 *         or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_push_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_push_head(buf, size);
  907d59:	8a38      	l32i.n	a10, a3, 32
  907d5b:	c0b4      	movi.n	a11, 4
  907d5d:	5bed9d        	call8	9033d4 <__adf_nbuf_push_head>
		adf_nbuf_unmap(sc->sc_dev, bf->bf_dmamap, ADF_OS_DMA_TO_DEVICE);
		adf_nbuf_push_head(bf->bf_skb, sizeof(ath_beacon_hdr_t));
		ath_free_tx_skb(sc->tgt_htc_handle, bf->bf_endpt, bf->bf_skb);
  907d60:	127184        	l32r	a2, 8e4370 <vdesc_module_install+0x234>
  907d63:	8a52      	l32i.n	a10, a5, 8
  907d65:	222287        	l32i	a2, a2, 0x21c
  907d68:	2b3223        	l32i	a11, a3, 140
  907d6b:	8c38      	l32i.n	a12, a3, 32
  907d6d:	0b2000        	callx8	a2
adf_nbuf_map(adf_os_device_t        osdev, 
             adf_os_dma_map_t       bmap, 
             adf_nbuf_t             buf, 
             adf_os_dma_dir_t       dir)
{
    return __adf_nbuf_map(osdev, bmap, buf, dir);
  907d70:	8b30      	l32i.n	a11, a3, 0
  907d72:	2a5246        	l32i	a10, a5, 0x118
  907d75:	c0d0      	movi.n	a13, 0
  907d77:	dc40      	mov.n	a12, a4
	}

	bf->bf_skb = nbuf;
  907d79:	9438      	s32i.n	a4, a3, 32
  907d7b:	5bedd8        	call8	9034dc <__adf_nbuf_map>
 * @param[out] sg   map info
 */
static inline void
adf_nbuf_dmamap_info(adf_os_dma_map_t bmap, adf_os_dmamap_info_t *sg)
{
    __adf_nbuf_dmamap_info(bmap, sg);
  907d7e:	8a30      	l32i.n	a10, a3, 0
  907d80:	b43b      	addi.n	a11, a3, 4
  907d82:	5bedde        	call8	9034fc <__adf_nbuf_dmamap_info>
 */
static void ath_beacon_setup(struct ath_softc_tgt *sc,
			     struct ath_tx_buf *bf,
			     struct ath_vap_target *avp)
{
	adf_nbuf_t skb = bf->bf_skb;
  907d85:	8238      	l32i.n	a2, a3, 32
	struct ath_hal *ah = sc->sc_ah;
	struct ath_tx_desc *ds;
	a_int32_t flags;
	const HAL_RATE_TABLE *rt;
	a_uint8_t rix, rate;
	HAL_11N_RATE_SERIES series[4] = {{ 0 }};
  907d87:	c5c0      	movi.n	a12, 80
 */
static void ath_beacon_setup(struct ath_softc_tgt *sc,
			     struct ath_tx_buf *bf,
			     struct ath_vap_target *avp)
{
	adf_nbuf_t skb = bf->bf_skb;
  907d89:	221620        	s32i	a2, a1, 128
	struct ath_hal *ah = sc->sc_ah;
	struct ath_tx_desc *ds;
	a_int32_t flags;
	const HAL_RATE_TABLE *rt;
	a_uint8_t rix, rate;
	HAL_11N_RATE_SERIES series[4] = {{ 0 }};
  907d8c:	2a1c20        	addi	a10, a1, 32
static void ath_beacon_setup(struct ath_softc_tgt *sc,
			     struct ath_tx_buf *bf,
			     struct ath_vap_target *avp)
{
	adf_nbuf_t skb = bf->bf_skb;
	struct ath_hal *ah = sc->sc_ah;
  907d8f:	225d05        	addmi	a2, a5, 0x500
	struct ath_tx_desc *ds;
	a_int32_t flags;
	const HAL_RATE_TABLE *rt;
	a_uint8_t rix, rate;
	HAL_11N_RATE_SERIES series[4] = {{ 0 }};
  907d92:	c0b0      	movi.n	a11, 0
static void ath_beacon_setup(struct ath_softc_tgt *sc,
			     struct ath_tx_buf *bf,
			     struct ath_vap_target *avp)
{
	adf_nbuf_t skb = bf->bf_skb;
	struct ath_hal *ah = sc->sc_ah;
  907d94:	842b      	l32i.n	a4, a2, 44
	struct ath_tx_desc *ds;
	a_int32_t flags;
	const HAL_RATE_TABLE *rt;
	a_uint8_t rix, rate;
	HAL_11N_RATE_SERIES series[4] = {{ 0 }};
  907d96:	5b7501        	call8	8e519c <memset>

	flags = HAL_TXDESC_NOACK;

	ds = bf->bf_desc;
  907d99:	823c      	l32i.n	a2, a3, 48
	ds->ds_link = 0;
  907d9b:	c080      	movi.n	a8, 0
  907d9d:	c0a0      	movi.n	a10, 0
  907d9f:	282400        	s8i	a8, a2, 0
  907da2:	2a2401        	s8i	a10, a2, 1
  907da5:	2a2402        	s8i	a10, a2, 2
  907da8:	2a2403        	s8i	a10, a2, 3
	ds->ds_data = bf->bf_dmamap_info.dma_segs[0].paddr;
  907dab:	2a3008        	l8ui	a10, a3, 8
	bf->bf_skb = nbuf;

	adf_nbuf_map(sc->sc_dev, bf->bf_dmamap, nbuf, ADF_OS_DMA_TO_DEVICE);
	adf_nbuf_dmamap_info(bf->bf_dmamap,&bf->bf_dmamap_info);

	ath_beacon_setup(sc, bf, &sc->sc_vap[vap_index]);
  907dae:	0c7b11        	slli	a11, a7, 4

	flags = HAL_TXDESC_NOACK;

	ds = bf->bf_desc;
	ds->ds_link = 0;
	ds->ds_data = bf->bf_dmamap_info.dma_segs[0].paddr;
  907db1:	2a2404        	s8i	a10, a2, 4
  907db4:	2a3009        	l8ui	a10, a3, 9
	bf->bf_skb = nbuf;

	adf_nbuf_map(sc->sc_dev, bf->bf_dmamap, nbuf, ADF_OS_DMA_TO_DEVICE);
	adf_nbuf_dmamap_info(bf->bf_dmamap,&bf->bf_dmamap_info);

	ath_beacon_setup(sc, bf, &sc->sc_vap[vap_index]);
  907db7:	a7bb      	add.n	a11, a11, a7

	flags = HAL_TXDESC_NOACK;

	ds = bf->bf_desc;
	ds->ds_link = 0;
	ds->ds_data = bf->bf_dmamap_info.dma_segs[0].paddr;
  907db9:	2a2405        	s8i	a10, a2, 5
  907dbc:	2a300a        	l8ui	a10, a3, 10

	rix = ath_get_minrateidx(sc, avp);
	rt  = sc->sc_currates;
	rate = rt->info[rix].rateCode;

	ah->ah_setupTxDesc(ds
  907dbf:	c071      	movi.n	a7, 1

	flags = HAL_TXDESC_NOACK;

	ds = bf->bf_desc;
	ds->ds_link = 0;
	ds->ds_data = bf->bf_dmamap_info.dma_segs[0].paddr;
  907dc1:	2a2406        	s8i	a10, a2, 6
  907dc4:	2a300b        	l8ui	a10, a3, 11
  907dc7:	2a2407        	s8i	a10, a2, 7
	bf->bf_skb = nbuf;

	adf_nbuf_map(sc->sc_dev, bf->bf_dmamap, nbuf, ADF_OS_DMA_TO_DEVICE);
	adf_nbuf_dmamap_info(bf->bf_dmamap,&bf->bf_dmamap_info);

	ath_beacon_setup(sc, bf, &sc->sc_vap[vap_index]);
  907dca:	1a72a4        	l32r	a10, 8e485c <vdesc_module_install+0x720>

	ds = bf->bf_desc;
	ds->ds_link = 0;
	ds->ds_data = bf->bf_dmamap_info.dma_segs[0].paddr;

	rix = ath_get_minrateidx(sc, avp);
  907dcd:	281624        	s32i	a8, a1, 144
	bf->bf_skb = nbuf;

	adf_nbuf_map(sc->sc_dev, bf->bf_dmamap, nbuf, ADF_OS_DMA_TO_DEVICE);
	adf_nbuf_dmamap_info(bf->bf_dmamap,&bf->bf_dmamap_info);

	ath_beacon_setup(sc, bf, &sc->sc_vap[vap_index]);
  907dd0:	0abb0a        	addx4	a11, a11, a10
  907dd3:	ab5b      	add.n	a11, a5, a11

	ds = bf->bf_desc;
	ds->ds_link = 0;
	ds->ds_data = bf->bf_dmamap_info.dma_segs[0].paddr;

	rix = ath_get_minrateidx(sc, avp);
  907dd5:	b8bb      	addi.n	a11, a11, 8
  907dd7:	da50      	mov.n	a10, a5
  907dd9:	5bffc1        	call8	907ce0 <ath_get_minrateidx>
	rt  = sc->sc_currates;
	rate = rt->info[rix].rateCode;
  907ddc:	295281        	l32i	a9, a5, 0x204
  907ddf:	b2aa      	addi.n	a10, a10, 2
  907de1:	0caa11        	slli	a10, a10, 4
  907de4:	aa99      	add.n	a9, a9, a10
  907de6:	299010        	l8ui	a9, a9, 16
 * @return The total length of this buf.
 */
static inline adf_os_size_t
adf_nbuf_len(adf_nbuf_t buf)
{
    return (__adf_nbuf_len(buf));
  907de9:	2a1220        	l32i	a10, a1, 128
  907dec:	291621        	s32i	a9, a1, 132

	ah->ah_setupTxDesc(ds
  907def:	294217        	l32i	a9, a4, 92
  907df2:	291622        	s32i	a9, a1, 136
  907df5:	5bee22        	call8	903680 <__adf_nbuf_len>
  907df8:	281224        	l32i	a8, a1, 144
  907dfb:	b4ab      	addi.n	a11, a10, 4
  907dfd:	2a0aff        	movi	a10, 255
  907e00:	291222        	l32i	a9, a1, 136
  907e03:	9a11      	s32i.n	a10, a1, 4
  907e05:	2f1221        	l32i	a15, a1, 132
  907e08:	c0a2      	movi.n	a10, 2
  907e0a:	9813      	s32i.n	a8, a1, 12
  907e0c:	9814      	s32i.n	a8, a1, 16
  907e0e:	9710      	s32i.n	a7, a1, 0
  907e10:	9a12      	s32i.n	a10, a1, 8
  907e12:	c1c8      	movi.n	a12, 24
  907e14:	c0d3      	movi.n	a13, 3
  907e16:	c3ef      	movi.n	a14, 63
  907e18:	da20      	mov.n	a10, a2
  907e1a:	0b9000        	callx8	a9
			    , HAL_TXKEYIX_INVALID
			    , flags
			    , 0
			    , 0);

	ah->ah_fillTxDesc(ds
  907e1d:	2f4218        	l32i	a15, a4, 96
  907e20:	2a1220        	l32i	a10, a1, 128
  907e23:	2f1623        	s32i	a15, a1, 140
  907e26:	5bee16        	call8	903680 <__adf_nbuf_len>
			   , asf_roundup(adf_nbuf_len(skb), 4)
  907e29:	b3aa      	addi.n	a10, a10, 3
			    , HAL_TXKEYIX_INVALID
			    , flags
			    , 0
			    , 0);

	ah->ah_fillTxDesc(ds
  907e2b:	2f1223        	l32i	a15, a1, 140
			   , asf_roundup(adf_nbuf_len(skb), 4)
  907e2e:	0a2b14        	srli	a11, a10, 2
			    , HAL_TXKEYIX_INVALID
			    , flags
			    , 0
			    , 0);

	ah->ah_fillTxDesc(ds
  907e31:	dc70      	mov.n	a12, a7
  907e33:	dd70      	mov.n	a13, a7
  907e35:	de20      	mov.n	a14, a2
  907e37:	022a02        	or	a10, a2, a2
  907e3a:	0ebb11        	slli	a11, a11, 2
  907e3d:	0bf000        	callx8	a15
			   , asf_roundup(adf_nbuf_len(skb), 4)
			   , AH_TRUE
			   , AH_TRUE
			   , ds);

	series[0].Tries = 1;
  907e40:	9718      	s32i.n	a7, a1, 32
	series[0].Rate = rate;
	series[0].ChSel = sc->sc_ic.ic_tx_chainmask;
  907e42:	275d16        	addmi	a7, a5, 0x1600
	series[0].RateFlags = 0;
  907e45:	281224        	l32i	a8, a1, 144
			   , AH_TRUE
			   , AH_TRUE
			   , ds);

	series[0].Tries = 1;
	series[0].Rate = rate;
  907e48:	291221        	l32i	a9, a1, 132
	series[0].ChSel = sc->sc_ic.ic_tx_chainmask;
  907e4b:	277026        	l8ui	a7, a7, 38
	series[0].RateFlags = 0;
	ah->ah_set11nRateScenario(ds, 0, 0, series, 4, 0);
  907e4e:	244210        	l32i	a4, a4, 64
  907e51:	db80      	mov.n	a11, a8
  907e53:	dc80      	mov.n	a12, a8
			   , AH_TRUE
			   , AH_TRUE
			   , ds);

	series[0].Tries = 1;
	series[0].Rate = rate;
  907e55:	9919      	s32i.n	a9, a1, 36
	series[0].ChSel = sc->sc_ic.ic_tx_chainmask;
	series[0].RateFlags = 0;
  907e57:	981c      	s32i.n	a8, a1, 48
	ah->ah_set11nRateScenario(ds, 0, 0, series, 4, 0);
  907e59:	2d1c20        	addi	a13, a1, 32
  907e5c:	c0e4      	movi.n	a14, 4
  907e5e:	df80      	mov.n	a15, a8
  907e60:	da20      	mov.n	a10, a2
			   , AH_TRUE
			   , ds);

	series[0].Tries = 1;
	series[0].Rate = rate;
	series[0].ChSel = sc->sc_ic.ic_tx_chainmask;
  907e62:	27160b        	s32i	a7, a1, 44
	series[0].RateFlags = 0;
	ah->ah_set11nRateScenario(ds, 0, 0, series, 4, 0);
  907e65:	0b4000        	callx8	a4

	adf_nbuf_map(sc->sc_dev, bf->bf_dmamap, nbuf, ADF_OS_DMA_TO_DEVICE);
	adf_nbuf_dmamap_info(bf->bf_dmamap,&bf->bf_dmamap_info);

	ath_beacon_setup(sc, bf, &sc->sc_vap[vap_index]);
	ah->ah_stopTxDma(ah, sc->sc_bhalq);
  907e68:	255d01        	addmi	a5, a5, 0x100
  907e6b:	826d      	l32i.n	a2, a6, 52
  907e6d:	2b501c        	l8ui	a11, a5, 28
  907e70:	da60      	mov.n	a10, a6
  907e72:	0b2000        	callx8	a2
	ah->ah_setTxDP(ah, sc->sc_bhalq, ATH_BUF_GET_DESC_PHY_ADDR(bf));
  907e75:	2b501c        	l8ui	a11, a5, 28
  907e78:	826a      	l32i.n	a2, a6, 40
  907e7a:	8c3c      	l32i.n	a12, a3, 48
  907e7c:	da60      	mov.n	a10, a6
  907e7e:	0b2000        	callx8	a2
	ah->ah_startTxDma(ah, sc->sc_bhalq);
  907e81:	2b501c        	l8ui	a11, a5, 28
  907e84:	826c      	l32i.n	a2, a6, 48
  907e86:	066a02        	or	a10, a6, a6
  907e89:	0b2000        	callx8	a2
  907e8c:	d10f      	retw.n
	...

00907e90 <ath_tgt_attach>:
	/* Start HTC messages exchange */
	HTC_Ready(sc->tgt_htc_handle);
}

a_int32_t ath_tgt_attach(a_uint32_t devid, struct ath_softc_tgt *sc, adf_os_device_t osdev)
{
  907e90:	6c100e        	entry	a1, 112
 * @return int
 */
static inline int 
__adf_os_pci_config_read8(adf_os_device_t osdev, int offset, a_uint8_t *val)
{
    (*val) = wlan_pci_config_read(offset, 1);
  907e93:	2b0a01        	movi	a11, 1
  907e96:	2a0a0c        	movi	a10, 12
  907e99:	5bef8c        	call8	903ccc <wlan_pci_config_read>
  907e9c:	0a0a47        	extui	a10, a10, 0, 8
	a_uint8_t csz;

	adf_os_pci_config_read8(osdev, ATH_PCI_CACHE_LINE_SIZE, &csz);

	if (csz == 0)
		csz = 16;
  907e9f:	c160      	movi.n	a6, 16
  907ea1:	0a6a38        	moveqz	a10, a6, a10
	sc->sc_cachelsz = csz << 2;
  907ea4:	0ea511        	slli	a5, a10, 2
 */
static inline void 
adf_os_init_bh(adf_os_handle_t  hdl, adf_os_bh_t  *bh,
               adf_os_defer_fn_t  func,void  *arg)
{
    __adf_os_init_bh(hdl, bh, func, arg);
  907ea7:	1b72ae        	l32r	a11, 8e4960 <vdesc_module_install+0x824>
  907eaa:	2a3a14        	movi	a10, 0x314

	sc->sc_dev = osdev;
  907ead:	243646        	s32i	a4, a3, 0x118
	sc->sc_hdl = osdev;
  907eb0:	243645        	s32i	a4, a3, 0x114
  907eb3:	aa3a      	add.n	a10, a3, a10
  907eb5:	dc30      	mov.n	a12, a3

	adf_os_pci_config_read8(osdev, ATH_PCI_CACHE_LINE_SIZE, &csz);

	if (csz == 0)
		csz = 16;
	sc->sc_cachelsz = csz << 2;
  907eb7:	253596        	s16i	a5, a3, 0x12c
  907eba:	5bf9e8        	call8	90665c <__adf_os_init_bh$isra$4>
  907ebd:	1b72af        	l32r	a11, 8e497c <vdesc_module_install+0x840>
  907ec0:	2a5a1c        	movi	a10, 0x51c
  907ec3:	0a3a08        	add	a10, a3, a10
  907ec6:	033c02        	or	a12, a3, a3
  907ec9:	5bf9e4        	call8	90665c <__adf_os_init_bh$isra$4>
  907ecc:	1b72b0        	l32r	a11, 8e498c <vdesc_module_install+0x850>
  907ecf:	2a3a24        	movi	a10, 0x324
  907ed2:	aa3a      	add.n	a10, a3, a10
  907ed4:	dc30      	mov.n	a12, a3
  907ed6:	5bf9e1        	call8	90665c <__adf_os_init_bh$isra$4>
  907ed9:	1b72b1        	l32r	a11, 8e49a0 <vdesc_module_install+0x864>
  907edc:	2a3a44        	movi	a10, 0x344
  907edf:	0a3a08        	add	a10, a3, a10
  907ee2:	033c02        	or	a12, a3, a3
  907ee5:	5bf9dd        	call8	90665c <__adf_os_init_bh$isra$4>
	ATH_INIT_TQUEUE(sc->sc_dev, &sc->sc_txtq, owl_tgt_tx_tasklet, sc);
	ATH_INIT_TQUEUE(sc->sc_dev, &sc->sc_bmisstq, ath_bmiss_tasklet, sc);
	ATH_INIT_TQUEUE(sc->sc_dev, &sc->sc_fataltq, ath_fatal_tasklet, sc);

	flags |= AH_USE_EEPROM;
	ah = _ath_hal_attach_tgt(devid, sc, sc->sc_dev, flags, &status);
  907ee8:	2c3246        	l32i	a12, a3, 0x118
  907eeb:	da20      	mov.n	a10, a2
  907eed:	033b02        	or	a11, a3, a3
  907ef0:	c0d1      	movi.n	a13, 1
  907ef2:	2e1c34        	addi	a14, a1, 52
  907ef5:	5bef2d        	call8	903bac <_ath_hal_attach_tgt>
  907ef8:	0aa402        	or	a4, a10, a10
	if (ah == NULL) {
  907efb:	64a3b3        	beqz	a10, 9082b2 <ath_tgt_attach+0x422>
	HTC_CONFIG htc_conf;
	WMI_SVC_CONFIG wmiConfig;
	WMI_DISPATCH_TABLE *Magpie_Sys_Commands_Tbl;

	/* Init dynamic buf pool */
	sc->pool_handle = BUF_Pool_init(sc->sc_hdl);
  907efe:	127184        	l32r	a2, 8e4510 <vdesc_module_install+0x3d4>
	ah = _ath_hal_attach_tgt(devid, sc, sc->sc_dev, flags, &status);
	if (ah == NULL) {
		error = ENXIO;
		goto bad;
	}
	sc->sc_ah = ah;
  907f01:	273d05        	addmi	a7, a3, 0x500
	HTC_CONFIG htc_conf;
	WMI_SVC_CONFIG wmiConfig;
	WMI_DISPATCH_TABLE *Magpie_Sys_Commands_Tbl;

	/* Init dynamic buf pool */
	sc->pool_handle = BUF_Pool_init(sc->sc_hdl);
  907f04:	25229e        	l32i	a5, a2, 0x278
	ah = _ath_hal_attach_tgt(devid, sc, sc->sc_dev, flags, &status);
	if (ah == NULL) {
		error = ENXIO;
		goto bad;
	}
	sc->sc_ah = ah;
  907f07:	2a760b        	s32i	a10, a7, 44
	HTC_CONFIG htc_conf;
	WMI_SVC_CONFIG wmiConfig;
	WMI_DISPATCH_TABLE *Magpie_Sys_Commands_Tbl;

	/* Init dynamic buf pool */
	sc->pool_handle = BUF_Pool_init(sc->sc_hdl);
  907f0a:	2a3245        	l32i	a10, a3, 0x114
  907f0d:	0b5000        	callx8	a5

	/* Init target-side HIF */
	sc->tgt_hif_handle = HIF_init(0);
  907f10:	252275        	l32i	a5, a2, 0x1d4
	HTC_CONFIG htc_conf;
	WMI_SVC_CONFIG wmiConfig;
	WMI_DISPATCH_TABLE *Magpie_Sys_Commands_Tbl;

	/* Init dynamic buf pool */
	sc->pool_handle = BUF_Pool_init(sc->sc_hdl);
  907f13:	2a3600        	s32i	a10, a3, 0

	/* Init target-side HIF */
	sc->tgt_hif_handle = HIF_init(0);
  907f16:	2a0a00        	movi	a10, 0
  907f19:	0b5000        	callx8	a5

	/* Init target-side HTC */
	htc_conf.HIFHandle = sc->tgt_hif_handle;
	htc_conf.CreditSize = 320;
  907f1c:	251a40        	movi	a5, 0x140
  907f1f:	9514      	s32i.n	a5, a1, 16
	htc_conf.CreditNumber = ATH_TXBUF;
  907f21:	c251      	movi.n	a5, 33
  907f23:	9515      	s32i.n	a5, a1, 20
	htc_conf.OSHandle = sc->sc_hdl;
  907f25:	253245        	l32i	a5, a3, 0x114

	/* Init dynamic buf pool */
	sc->pool_handle = BUF_Pool_init(sc->sc_hdl);

	/* Init target-side HIF */
	sc->tgt_hif_handle = HIF_init(0);
  907f28:	9a31      	s32i.n	a10, a3, 4

	/* Init target-side HTC */
	htc_conf.HIFHandle = sc->tgt_hif_handle;
	htc_conf.CreditSize = 320;
	htc_conf.CreditNumber = ATH_TXBUF;
	htc_conf.OSHandle = sc->sc_hdl;
  907f2a:	9516      	s32i.n	a5, a1, 24
	htc_conf.PoolHandle = sc->pool_handle;
  907f2c:	8530      	l32i.n	a5, a3, 0

	/* Init target-side HIF */
	sc->tgt_hif_handle = HIF_init(0);

	/* Init target-side HTC */
	htc_conf.HIFHandle = sc->tgt_hif_handle;
  907f2e:	9a17      	s32i.n	a10, a1, 28
	htc_conf.CreditSize = 320;
	htc_conf.CreditNumber = ATH_TXBUF;
	htc_conf.OSHandle = sc->sc_hdl;
	htc_conf.PoolHandle = sc->pool_handle;
  907f30:	9518      	s32i.n	a5, a1, 32
	sc->tgt_htc_handle = HTC_init(htc_setup_comp, &htc_conf);
  907f32:	1a72b2        	l32r	a10, 8e49fc <vdesc_module_install+0x8c0>
  907f35:	252283        	l32i	a5, a2, 0x20c
  907f38:	a61b      	add.n	a11, a1, a6
  907f3a:	0b5000        	callx8	a5
#if defined(PROJECT_MAGPIE)
	init_htc_handle = sc->tgt_htc_handle;
#endif

	tgt_reg_service(sc, &sc->htc_beacon_service, WMI_BEACON_SVC, tgt_HTCRecv_beaconhandler);
  907f3d:	1d72b3        	l32r	a13, 8e4a0c <vdesc_module_install+0x8d0>
  907f40:	a63b      	add.n	a11, a3, a6
	htc_conf.HIFHandle = sc->tgt_hif_handle;
	htc_conf.CreditSize = 320;
	htc_conf.CreditNumber = ATH_TXBUF;
	htc_conf.OSHandle = sc->sc_hdl;
	htc_conf.PoolHandle = sc->pool_handle;
	sc->tgt_htc_handle = HTC_init(htc_setup_comp, &htc_conf);
  907f42:	9a32      	s32i.n	a10, a3, 8
#if defined(PROJECT_MAGPIE)
	init_htc_handle = sc->tgt_htc_handle;
#endif

	tgt_reg_service(sc, &sc->htc_beacon_service, WMI_BEACON_SVC, tgt_HTCRecv_beaconhandler);
  907f44:	2c1a01        	movi	a12, 0x101
  907f47:	da30      	mov.n	a10, a3
  907f49:	5bf960        	call8	9064cc <tgt_reg_service>
	tgt_reg_service(sc, &sc->htc_cab_service, WMI_CAB_SVC, tgt_HTCRecv_cabhandler);
  907f4c:	1d72b4        	l32r	a13, 8e4a1c <vdesc_module_install+0x8e0>
  907f4f:	da30      	mov.n	a10, a3
  907f51:	2b3c2c        	addi	a11, a3, 44
  907f54:	2c1a02        	movi	a12, 0x102
  907f57:	5bf95d        	call8	9064cc <tgt_reg_service>
	tgt_reg_service(sc, &sc->htc_uapsd_service, WMI_UAPSD_SVC, tgt_HTCRecv_uapsdhandler);
  907f5a:	1d72b5        	l32r	a13, 8e4a30 <vdesc_module_install+0x8f4>
  907f5d:	da30      	mov.n	a10, a3
  907f5f:	2b3c48        	addi	a11, a3, 72
  907f62:	2c1a03        	movi	a12, 0x103
  907f65:	5bf959        	call8	9064cc <tgt_reg_service>
	tgt_reg_service(sc, &sc->htc_mgmt_service, WMI_MGMT_SVC, tgt_HTCRecv_mgmthandler);
  907f68:	1d72b6        	l32r	a13, 8e4a40 <vdesc_module_install+0x904>
  907f6b:	da30      	mov.n	a10, a3
  907f6d:	2b3c64        	addi	a11, a3, 100
  907f70:	2c1a04        	movi	a12, 0x104
  907f73:	5bf956        	call8	9064cc <tgt_reg_service>
	tgt_reg_service(sc, &sc->htc_data_BE_service, WMI_DATA_BE_SVC, tgt_HTCRecvMessageHandler);
  907f76:	1572b7        	l32r	a5, 8e4a54 <vdesc_module_install+0x918>
  907f79:	2b0ab8        	movi	a11, 184
  907f7c:	dd50      	mov.n	a13, a5
  907f7e:	da30      	mov.n	a10, a3
  907f80:	0b3b08        	add	a11, a3, a11
  907f83:	2c1a07        	movi	a12, 0x107
  907f86:	5bf951        	call8	9064cc <tgt_reg_service>
	tgt_reg_service(sc, &sc->htc_data_BK_service, WMI_DATA_BK_SVC, tgt_HTCRecvMessageHandler);
  907f89:	2b0ad4        	movi	a11, 212
  907f8c:	dd50      	mov.n	a13, a5
  907f8e:	da30      	mov.n	a10, a3
  907f90:	0b3b08        	add	a11, a3, a11
  907f93:	2c1a08        	movi	a12, 0x108
  907f96:	5bf94d        	call8	9064cc <tgt_reg_service>
	tgt_reg_service(sc, &sc->htc_data_VI_service, WMI_DATA_VI_SVC, tgt_HTCRecvMessageHandler);
  907f99:	2b0a9c        	movi	a11, 156
  907f9c:	dd50      	mov.n	a13, a5
  907f9e:	da30      	mov.n	a10, a3
  907fa0:	0b3b08        	add	a11, a3, a11
  907fa3:	2c1a06        	movi	a12, 0x106
  907fa6:	5bf949        	call8	9064cc <tgt_reg_service>
	tgt_reg_service(sc, &sc->htc_data_VO_service, WMI_DATA_VO_SVC, tgt_HTCRecvMessageHandler);
  907fa9:	2b0a80        	movi	a11, 128
  907fac:	dd50      	mov.n	a13, a5
  907fae:	ab3b      	add.n	a11, a3, a11
  907fb0:	2c1a05        	movi	a12, 0x105
  907fb3:	da30      	mov.n	a10, a3
  907fb5:	5bf945        	call8	9064cc <tgt_reg_service>
 * @return Buffer pointer or NULL if there's not enough memory.
 */
static inline void *
adf_os_mem_alloc(adf_os_size_t size)
{
    return __adf_os_mem_alloc(size);
  907fb8:	da60      	mov.n	a10, a6
  907fba:	5bf918        	call8	90641c <__adf_os_mem_alloc>
}
/* zero a memory buffer */
static inline void
__adf_os_mem_zero(void *buf, adf_os_size_t size)
{
    A_MEMZERO(buf,size);
  907fbd:	8824      	l32i.n	a8, a2, 16
  907fbf:	dc60      	mov.n	a12, a6
  907fc1:	c0b0      	movi.n	a11, 0
  907fc3:	d5a0      	mov.n	a5, a10
  907fc5:	0b8000        	callx8	a8

	/* Init target-side WMI */
	Magpie_Sys_Commands_Tbl = (WMI_DISPATCH_TABLE *)adf_os_mem_alloc(sizeof(WMI_DISPATCH_TABLE));
	adf_os_mem_zero(Magpie_Sys_Commands_Tbl, sizeof(WMI_DISPATCH_TABLE));
	Magpie_Sys_Commands_Tbl->NumberOfEntries = WMI_DISPATCH_ENTRY_COUNT(Magpie_Sys_DispatchEntries);
  907fc8:	c280      	movi.n	a8, 32
  907fca:	9852      	s32i.n	a8, a5, 8
	Magpie_Sys_Commands_Tbl->pTable = Magpie_Sys_DispatchEntries;
  907fcc:	1872b8        	l32r	a8, 8e4aac <vdesc_module_install+0x970>
  907fcf:	dc60      	mov.n	a12, a6
  907fd1:	9853      	s32i.n	a8, a5, 12
  907fd3:	8824      	l32i.n	a8, a2, 16
  907fd5:	c0b0      	movi.n	a11, 0
  907fd7:	2a1c24        	addi	a10, a1, 36
  907fda:	0b8000        	callx8	a8

	adf_os_mem_zero(&wmiConfig, sizeof(WMI_SVC_CONFIG));
	wmiConfig.HtcHandle = sc->tgt_htc_handle;
  907fdd:	8632      	l32i.n	a6, a3, 8
	wmiConfig.PoolHandle = sc->pool_handle;
	wmiConfig.MaxCmdReplyEvts = ATH_WMI_MAX_CMD_REPLY;
	wmiConfig.MaxEventEvts = ATH_WMI_MAX_EVENTS;

	sc->tgt_wmi_handle = WMI_Init(&wmiConfig);
  907fdf:	2a1c24        	addi	a10, a1, 36
	adf_os_mem_zero(Magpie_Sys_Commands_Tbl, sizeof(WMI_DISPATCH_TABLE));
	Magpie_Sys_Commands_Tbl->NumberOfEntries = WMI_DISPATCH_ENTRY_COUNT(Magpie_Sys_DispatchEntries);
	Magpie_Sys_Commands_Tbl->pTable = Magpie_Sys_DispatchEntries;

	adf_os_mem_zero(&wmiConfig, sizeof(WMI_SVC_CONFIG));
	wmiConfig.HtcHandle = sc->tgt_htc_handle;
  907fe2:	9619      	s32i.n	a6, a1, 36
	wmiConfig.PoolHandle = sc->pool_handle;
  907fe4:	8630      	l32i.n	a6, a3, 0
  907fe6:	961a      	s32i.n	a6, a1, 40
	wmiConfig.MaxCmdReplyEvts = ATH_WMI_MAX_CMD_REPLY;
  907fe8:	c062      	movi.n	a6, 2
  907fea:	961b      	s32i.n	a6, a1, 44
	wmiConfig.MaxEventEvts = ATH_WMI_MAX_EVENTS;
  907fec:	c068      	movi.n	a6, 8
  907fee:	961c      	s32i.n	a6, a1, 48

	sc->tgt_wmi_handle = WMI_Init(&wmiConfig);
  907ff0:	262290        	l32i	a6, a2, 0x240
  907ff3:	0b6000        	callx8	a6
  907ff6:	9a33      	s32i.n	a10, a3, 12
	Magpie_Sys_Commands_Tbl->pContext = sc;
	WMI_RegisterDispatchTable(sc->tgt_wmi_handle, Magpie_Sys_Commands_Tbl);
  907ff8:	262291        	l32i	a6, a2, 0x244
  907ffb:	db50      	mov.n	a11, a5
	wmiConfig.PoolHandle = sc->pool_handle;
	wmiConfig.MaxCmdReplyEvts = ATH_WMI_MAX_CMD_REPLY;
	wmiConfig.MaxEventEvts = ATH_WMI_MAX_EVENTS;

	sc->tgt_wmi_handle = WMI_Init(&wmiConfig);
	Magpie_Sys_Commands_Tbl->pContext = sc;
  907ffd:	9351      	s32i.n	a3, a5, 4
	WMI_RegisterDispatchTable(sc->tgt_wmi_handle, Magpie_Sys_Commands_Tbl);
  907fff:	0b6000        	callx8	a6

	HTC_NotifyTargetInserted(sc->tgt_htc_handle);

	/* Start HTC messages exchange */
	HTC_Ready(sc->tgt_htc_handle);
  908002:	8a32      	l32i.n	a10, a3, 8
  908004:	222286        	l32i	a2, a2, 0x218
	}
	sc->sc_ah = ah;

	tgt_hif_htc_wmi_init(sc);

	sc->sc_bhalq = HAL_NUM_TX_QUEUES - 1;
  908007:	c059      	movi.n	a5, 9
	WMI_RegisterDispatchTable(sc->tgt_wmi_handle, Magpie_Sys_Commands_Tbl);

	HTC_NotifyTargetInserted(sc->tgt_htc_handle);

	/* Start HTC messages exchange */
	HTC_Ready(sc->tgt_htc_handle);
  908009:	0b2000        	callx8	a2
	return (tsf + (u_int64_t)tsf_delta);
}

static a_int32_t ath_rate_setup(struct ath_softc_tgt *sc, a_uint32_t mode)
{
	struct ath_hal *ah = sc->sc_ah;
  90800c:	8a7b      	l32i.n	a10, a7, 44
	}
	sc->sc_ah = ah;

	tgt_hif_htc_wmi_init(sc);

	sc->sc_bhalq = HAL_NUM_TX_QUEUES - 1;
  90800e:	223d01        	addmi	a2, a3, 0x100
  908011:	25241c        	s8i	a5, a2, 28
	struct ath_hal *ah = sc->sc_ah;
	const HAL_RATE_TABLE *rt;

	switch (mode) {
	case IEEE80211_MODE_11NA:
		sc->sc_rates[mode] = ah->ah_getRateTable(ah, HAL_MODE_11NA);
  908014:	82a5      	l32i.n	a2, a10, 20
  908016:	1b722b        	l32r	a11, 8e48c4 <vdesc_module_install+0x788>
  908019:	0b2000        	callx8	a2
  90801c:	2a367f        	s32i	a10, a3, 0x1fc
	return (tsf + (u_int64_t)tsf_delta);
}

static a_int32_t ath_rate_setup(struct ath_softc_tgt *sc, a_uint32_t mode)
{
	struct ath_hal *ah = sc->sc_ah;
  90801f:	8a7b      	l32i.n	a10, a7, 44
	switch (mode) {
	case IEEE80211_MODE_11NA:
		sc->sc_rates[mode] = ah->ah_getRateTable(ah, HAL_MODE_11NA);
		break;
	case IEEE80211_MODE_11NG:
		sc->sc_rates[mode] = ah->ah_getRateTable(ah, HAL_MODE_11NG);
  908021:	1b722a        	l32r	a11, 8e48cc <vdesc_module_install+0x790>
  908024:	82a5      	l32i.n	a2, a10, 20
  908026:	0b2000        	callx8	a2
  908029:	2a3680        	s32i	a10, a3, 0x200
	sc->sc_bhalq = HAL_NUM_TX_QUEUES - 1;

	ath_rate_setup(sc, IEEE80211_MODE_11NA);
	ath_rate_setup(sc, IEEE80211_MODE_11NG);

	sc->sc_rc = ath_rate_attach(sc);
  90802c:	da30      	mov.n	a10, a3
  90802e:	58036e        	call8	908de8 <ath_rate_attach>
  908031:	2a3648        	s32i	a10, a3, 0x120
	if (sc->sc_rc == NULL) {
  908034:	64a27a        	beqz	a10, 9082b2 <ath_tgt_attach+0x422>

	/* Start HTC messages exchange */
	HTC_Ready(sc->tgt_htc_handle);
}

a_int32_t ath_tgt_attach(a_uint32_t devid, struct ath_softc_tgt *sc, adf_os_device_t osdev)
  908037:	1572a9        	l32r	a5, 8e4adc <vdesc_module_install+0x9a0>
  90803a:	d230      	mov.n	a2, a3
  90803c:	a535      	add.n	a5, a3, a5
  90803e:	277a40        	movi	a7, 0x740
		error = EIO;
		goto bad2;
	}

	for (i=0; i < TARGET_NODE_MAX; i++) {
		sc->sc_sta[i].an_rcnode = adf_os_mem_alloc(sc->sc_rc->arc_space);
  908041:	263248        	l32i	a6, a3, 0x120
  908044:	2a6200        	l32i	a10, a6, 0

	/* Start HTC messages exchange */
	HTC_Ready(sc->tgt_htc_handle);
}

a_int32_t ath_tgt_attach(a_uint32_t devid, struct ath_softc_tgt *sc, adf_os_device_t osdev)
  908047:	a726      	add.n	a6, a2, a7
  908049:	5bf8f4        	call8	90641c <__adf_os_mem_alloc>
		error = EIO;
		goto bad2;
	}

	for (i=0; i < TARGET_NODE_MAX; i++) {
		sc->sc_sta[i].an_rcnode = adf_os_mem_alloc(sc->sc_rc->arc_space);
  90804c:	9a60      	s32i.n	a10, a6, 0
  90804e:	262a0c        	movi	a6, 0x20c
  908051:	a622      	add.n	a2, a2, a6
	if (sc->sc_rc == NULL) {
		error = EIO;
		goto bad2;
	}

	for (i=0; i < TARGET_NODE_MAX; i++) {
  908053:	7529ea        	bne	a2, a5, 908041 <ath_tgt_attach+0x1b1>
	((_dd)->dd_desc_paddr + ((caddr_t)(_ds) - (caddr_t)(_dd)->dd_desc))

	a_int32_t error;
	struct ath_tx_buf *bf;

	if(ath_numrxbufs == -1)
  908056:	1272a0        	l32r	a2, 8e4ad8 <vdesc_module_install+0x99c>
  908059:	8520      	l32i.n	a5, a2, 0
  90805b:	695005        	bnei	a5, -1, 908064 <ath_tgt_attach+0x1d4>
		ath_numrxbufs = ATH_RXBUF;
  90805e:	250a0b        	movi	a5, 11
  908061:	252600        	s32i	a5, a2, 0

	if (ath_numrxdescs == -1)
  908064:	1272b9        	l32r	a2, 8e4b48 <vdesc_module_install+0xa0c>
  908067:	8520      	l32i.n	a5, a2, 0
  908069:	695003        	bnei	a5, -1, 908070 <ath_tgt_attach+0x1e0>
		ath_numrxdescs = ATH_RXDESC;
  90806c:	c05b      	movi.n	a5, 11
  90806e:	9520      	s32i.n	a5, a2, 0

	error = ath_descdma_setup(sc, &sc->sc_rxdma, (ath_bufhead *)&sc->sc_rxbuf,
  908070:	1772b9        	l32r	a7, 8e4b54 <vdesc_module_install+0xa18>
  908073:	c524      	movi.n	a2, 84
  908075:	263a74        	movi	a6, 0x374
  908078:	253a54        	movi	a5, 0x354
  90807b:	9210      	s32i.n	a2, a1, 0
  90807d:	a636      	add.n	a6, a3, a6
  90807f:	a535      	add.n	a5, a3, a5
  908081:	1d72ba        	l32r	a13, 8e4b6c <vdesc_module_install+0xa30>
  908084:	8e70      	l32i.n	a14, a7, 0
  908086:	da30      	mov.n	a10, a3
  908088:	066b02        	or	a11, a6, a6
  90808b:	055c02        	or	a12, a5, a5
  90808e:	2f0a68        	movi	a15, 104
  908091:	5bf9c9        	call8	9067b8 <ath_descdma_setup$constprop$20>
				  "rx", ath_numrxdescs, 1,
				  sizeof(struct ath_rx_buf),
				  sizeof(struct ath_rx_desc));
	if (error != 0)
  908094:	65a21a        	bnez	a10, 9082b2 <ath_tgt_attach+0x422>
	a_uint32_t i;
	struct ath_descdma *dd = &sc->sc_rxdma;
	struct ath_rx_desc *ds = (struct ath_rx_desc *)dd->dd_desc;
	struct ath_rx_desc *ds_prev = NULL;

	asf_tailq_init(&sc->sc_rxdesc);
  908097:	283a64        	movi	a8, 0x364
  90809a:	a838      	add.n	a8, a3, a8
  90809c:	2836da        	s32i	a8, a3, 0x368
	asf_tailq_init(&sc->sc_rxdesc_idle);
  90809f:	283a5c        	movi	a8, 0x35c
  9080a2:	a838      	add.n	a8, a3, a8
  9080a4:	2836d8        	s32i	a8, a3, 0x360
	if (error != 0)
		return error;

	a_uint32_t i;
	struct ath_descdma *dd = &sc->sc_rxdma;
	struct ath_rx_desc *ds = (struct ath_rx_desc *)dd->dd_desc;
  9080a7:	2232de        	l32i	a2, a3, 0x378
	struct ath_rx_desc *ds_prev = NULL;

	asf_tailq_init(&sc->sc_rxdesc);
  9080aa:	2a36d9        	s32i	a10, a3, 0x364
	asf_tailq_init(&sc->sc_rxdesc_idle);
  9080ad:	2a36d7        	s32i	a10, a3, 0x35c
		return error;

	a_uint32_t i;
	struct ath_descdma *dd = &sc->sc_rxdma;
	struct ath_rx_desc *ds = (struct ath_rx_desc *)dd->dd_desc;
	struct ath_rx_desc *ds_prev = NULL;
  9080b0:	d8a0      	mov.n	a8, a10

	asf_tailq_init(&sc->sc_rxdesc);
	asf_tailq_init(&sc->sc_rxdesc_idle);

	for (i = 0; i < ath_numrxdescs; i++, ds++) {
  9080b2:	dca0      	mov.n	a12, a10
  9080b4:	6000be        	j	908176 <ath_tgt_attach+0x2e6>
  9080b7:	00002b        	mulsh	a0, a0, a0

		if (ds->ds_nbuf != ADF_NBUF_NULL) {
  9080ba:	20342a        	s8i	a0, a3, 42
  9080bd:	203529        	s16i	a0, a3, 82
  9080c0:	203608        	s32i	a0, a3, 32
  9080c3:	bb10      	addi.n	a0, a1, 11
  9080c5:	00aa11        	slli	a10, a10, 16
  9080c8:	0baa02        	or	a10, a10, a11
  9080cb:	089911        	slli	a9, a9, 8
  9080ce:	0a9902        	or	a9, a9, a10
  9080d1:	2a2037        	l8ui	a10, a2, 55
  9080d4:	09a902        	or	a9, a10, a9
  9080d7:	c89d      	beqz.n	a9, 9080e8 <ath_tgt_attach+0x258>
			ds->ds_nbuf = ADF_NBUF_NULL;
  9080d9:	290a00        	movi	a9, 0
  9080dc:	292434        	s8i	a9, a2, 52
  9080df:	292435        	s8i	a9, a2, 53
  9080e2:	292436        	s8i	a9, a2, 54
  9080e5:	292437        	s8i	a9, a2, 55
 */
static inline a_status_t
adf_nbuf_dmamap_create(adf_os_device_t osdev,
                       adf_os_dma_map_t *dmap)
{
    return (__adf_nbuf_dmamap_create(osdev, dmap));
  9080e8:	2a3246        	l32i	a10, a3, 0x118
  9080eb:	2b2c38        	addi	a11, a2, 56
  9080ee:	281611        	s32i	a8, a1, 68
  9080f1:	2c1610        	s32i	a12, a1, 64
  9080f4:	5becf2        	call8	9034c0 <__adf_nbuf_dmamap_create>
		}

		if (adf_nbuf_dmamap_create(sc->sc_dev, &ds->ds_dmap) != A_STATUS_OK) {
  9080f7:	281211        	l32i	a8, a1, 68
  9080fa:	2c1210        	l32i	a12, a1, 64
  9080fd:	c8a3      	beqz.n	a10, 908104 <ath_tgt_attach+0x274>
  9080ff:	63fffc        	j	9080ff <ath_tgt_attach+0x26f>
  908102:	000029        	excw
			adf_os_assert(0);
		}

		ds->ds_daddr = DS2PHYS(&sc->sc_rxdma, ds);
  908105:	32de2a        	excw
  908108:	32e009        	excw
  90810b:	290caa        	addi	a9, a0, -86
  90810e:	9909      	s32i.n	a9, a0, 36
  908110:	8d57      	l32i.n	a13, a5, 28
  908112:	090b57        	extui	a11, a9, 16, 8
  908115:	098a47        	extui	a10, a9, 8, 8
  908118:	090947        	extui	a9, a9, 0, 8
  90811b:	2d2448        	s8i	a13, a2, 72
  90811e:	2b2449        	s8i	a11, a2, 73
  908121:	2a244a        	s8i	a10, a2, 74
  908124:	29244b        	s8i	a9, a2, 75

		if (ds_prev) {
  908127:	c88a      	beqz.n	a8, 908135 <ath_tgt_attach+0x2a5>
			ds_prev->ds_link = ds->ds_daddr;
  908129:	2d8400        	s8i	a13, a8, 0
  90812c:	2b8401        	s8i	a11, a8, 1
  90812f:	2a8402        	s8i	a10, a8, 2
  908132:	298403        	s8i	a9, a8, 3
		}

		ds->ds_link = 0;
  908135:	c080      	movi.n	a8, 0
  908137:	282400        	s8i	a8, a2, 0
  90813a:	282401        	s8i	a8, a2, 1
  90813d:	282402        	s8i	a8, a2, 2
  908140:	282403        	s8i	a8, a2, 3
		ds_prev = ds;

		asf_tailq_insert_tail(&sc->sc_rxdesc, ds, ds_list);
  908143:	28244c        	s8i	a8, a2, 76
  908146:	28244d        	s8i	a8, a2, 77
  908149:	28244e        	s8i	a8, a2, 78
  90814c:	28244f        	s8i	a8, a2, 79
  90814f:	2832da        	l32i	a8, a3, 0x368
	struct ath_rx_desc *ds_prev = NULL;

	asf_tailq_init(&sc->sc_rxdesc);
	asf_tailq_init(&sc->sc_rxdesc_idle);

	for (i = 0; i < ath_numrxdescs; i++, ds++) {
  908152:	b1cc      	addi.n	a12, a12, 1
		}

		ds->ds_link = 0;
		ds_prev = ds;

		asf_tailq_insert_tail(&sc->sc_rxdesc, ds, ds_list);
  908154:	088957        	extui	a9, a8, 24, 8
  908157:	292450        	s8i	a9, a2, 80
  90815a:	080957        	extui	a9, a8, 16, 8
  90815d:	292451        	s8i	a9, a2, 81
  908160:	088947        	extui	a9, a8, 8, 8
  908163:	282453        	s8i	a8, a2, 83
  908166:	292452        	s8i	a9, a2, 82
  908169:	9280      	s32i.n	a2, a8, 0
  90816b:	282c4c        	addi	a8, a2, 76
  90816e:	2836da        	s32i	a8, a3, 0x368
	struct ath_rx_desc *ds_prev = NULL;

	asf_tailq_init(&sc->sc_rxdesc);
	asf_tailq_init(&sc->sc_rxdesc_idle);

	for (i = 0; i < ath_numrxdescs; i++, ds++) {
  908171:	d820      	mov.n	a8, a2
  908173:	222c54        	addi	a2, a2, 84
  908176:	8970      	l32i.n	a9, a7, 0
  908178:	79cb02        	bgeu	a12, a9, 90817e <ath_tgt_attach+0x2ee>
  90817b:	63ff3a        	j	9080b9 <ath_tgt_attach+0x229>
		ds_prev = ds;

		asf_tailq_insert_tail(&sc->sc_rxdesc, ds, ds_list);
	}

	error = ath_descdma_setup(sc, &sc->sc_txdma, (ath_bufhead *)&sc->sc_txbuf,
  90817e:	273a8c        	movi	a7, 0x38c
  908181:	223ac0        	movi	a2, 0x3c0
  908184:	290a88        	movi	a9, 136
  908187:	a737      	add.n	a7, a3, a7
  908189:	a232      	add.n	a2, a3, a2
  90818b:	1d72bb        	l32r	a13, 8e4c78 <vdesc_module_install+0xb3c>
  90818e:	9910      	s32i.n	a9, a1, 0
  908190:	da30      	mov.n	a10, a3
  908192:	db70      	mov.n	a11, a7
  908194:	dc20      	mov.n	a12, a2
  908196:	c2e2      	movi.n	a14, 34
  908198:	2f0a94        	movi	a15, 148
  90819b:	291610        	s32i	a9, a1, 64
  90819e:	5bf986        	call8	9067b8 <ath_descdma_setup$constprop$20>
  9081a1:	d8a0      	mov.n	a8, a10
				  "tx", ATH_TXBUF + 1, ATH_TXDESC,
				  sizeof(struct ath_tx_buf),
				  sizeof(struct ath_tx_desc));
	if (error != 0) {
  9081a3:	291210        	l32i	a9, a1, 64
  9081a6:	c8a3      	beqz.n	a10, 9081ad <ath_tgt_attach+0x31d>
  9081a8:	60002d        	j	9081d9 <ath_tgt_attach+0x349>
  9081ab:	00001c        	mul16u	a0, a0, a0
		ath_descdma_cleanup(sc, &sc->sc_rxdma, (ath_bufhead *)&sc->sc_rxbuf,
				    ADF_OS_DMA_FROM_DEVICE);
		return error;
	}

	error = ath_descdma_setup(sc, &sc->sc_bdma, (ath_bufhead *)&sc->sc_bbuf,
  9081ae:	72bc2b        	bnall	a11, a2, 9081dd <ath_tgt_attach+0x34d>
  9081b1:	3aa41d        	excw
  9081b4:	72bd99        	bbs	a11, a2, 908151 <ath_tgt_attach+0x2c1>
  9081b7:	10da30        	l32r	a0, 8fea78 <memset+0x198dc>
  9081ba:	ab3b      	add.n	a11, a3, a11
  9081bc:	ac3c      	add.n	a12, a3, a12
  9081be:	c0e1      	movi.n	a14, 1
  9081c0:	2f0a94        	movi	a15, 148
  9081c3:	281611        	s32i	a8, a1, 68
  9081c6:	5bf97c        	call8	9067b8 <ath_descdma_setup$constprop$20>
				  "beacon", ATH_BCBUF, 1,
				  sizeof(struct ath_tx_buf),
				  sizeof(struct ath_tx_desc));
	if (error != 0) {
  9081c9:	281211        	l32i	a8, a1, 68
  9081cc:	c9a8      	beqz.n	a10, 9081e8 <ath_tgt_attach+0x358>
		ath_descdma_cleanup(sc, &sc->sc_txdma, (ath_bufhead *)&sc->sc_txbuf,
  9081ce:	da30      	mov.n	a10, a3
  9081d0:	db70      	mov.n	a11, a7
  9081d2:	dc20      	mov.n	a12, a2
  9081d4:	dd80      	mov.n	a13, a8
  9081d6:	5bf8fb        	call8	9065c4 <ath_descdma_cleanup>
				    ADF_OS_DMA_TO_DEVICE);
		ath_descdma_cleanup(sc, &sc->sc_rxdma, (ath_bufhead *)&sc->sc_rxbuf,
  9081d9:	da30      	mov.n	a10, a3
  9081db:	db60      	mov.n	a11, a6
  9081dd:	dc50      	mov.n	a12, a5
  9081df:	c0d1      	movi.n	a13, 1
  9081e1:	5bf8f8        	call8	9065c4 <ath_descdma_cleanup>
  9081e4:	6000ca        	j	9082b2 <ath_tgt_attach+0x422>
  9081e7:	002232        	sext	a2, a2, 7
				    ADF_OS_DMA_FROM_DEVICE);
		return error;
	}

	bf = asf_tailq_first(&sc->sc_txbuf);
  9081ea:	f0          	.byte 0xf0
	bf->bf_isaggr = bf->bf_isretried = bf->bf_retries = 0;
  9081eb:	c65f      	movi.n	a5, -17
  9081ed:	262087        	l8ui	a6, a2, 135
  9081f0:	2a2486        	s8i	a10, a2, 134
  9081f3:	056501        	and	a5, a6, a5
  9081f6:	26fadf        	movi	a6, -33
  9081f9:	065501        	and	a5, a5, a6
  9081fc:	252487        	s8i	a5, a2, 135
	asf_tailq_remove(&sc->sc_txbuf, bf, bf_list);
  9081ff:	8529      	l32i.n	a5, a2, 36
  908201:	862a      	l32i.n	a6, a2, 40
  908203:	c856      	beqz.n	a5, 90820d <ath_tgt_attach+0x37d>
  908205:	965a      	s32i.n	a6, a5, 40
  908207:	600005        	j	908210 <ath_tgt_attach+0x380>
  90820a:	000000        	ill
  90820d:	2636f1        	s32i	a6, a3, 0x3c4
  908210:	862a      	l32i.n	a6, a2, 40
	error = ath_desc_alloc(sc);
	if (error != 0) {
		goto bad;
	}

	BUF_Pool_create_pool(sc->pool_handle, POOL_ID_WLAN_RX_BUF, ath_numrxdescs, 1664);
  908212:	c0b3      	movi.n	a11, 3
		return error;
	}

	bf = asf_tailq_first(&sc->sc_txbuf);
	bf->bf_isaggr = bf->bf_isretried = bf->bf_retries = 0;
	asf_tailq_remove(&sc->sc_txbuf, bf, bf_list);
  908214:	9560      	s32i.n	a5, a6, 0

	sc->sc_txbuf_held = bf;
  908216:	2236dc        	s32i	a2, a3, 0x370
	error = ath_desc_alloc(sc);
	if (error != 0) {
		goto bad;
	}

	BUF_Pool_create_pool(sc->pool_handle, POOL_ID_WLAN_RX_BUF, ath_numrxdescs, 1664);
  908219:	1572b9        	l32r	a5, 8e4d00 <__divsi3+0x14>
  90821c:	127184        	l32r	a2, 8e482c <vdesc_module_install+0x6f0>
  90821f:	2a3200        	l32i	a10, a3, 0
  908222:	2222a0        	l32i	a2, a2, 0x280
  908225:	2c5200        	l32i	a12, a5, 0
  908228:	2d6a80        	movi	a13, 0x680
  90822b:	0b2000        	callx8	a2
static void ath_tgt_txq_setup(struct ath_softc_tgt *sc)
{
	a_int32_t qnum;
	struct ath_txq *txq;

	sc->sc_txqsetup=0;
  90822e:	c050      	movi.n	a5, 0
  908230:	223d03        	addmi	a2, a3, 0x300
  908233:	2524c8        	s8i	a5, a2, 200

	for (qnum=0;qnum<HAL_NUM_TX_QUEUES;qnum++) {
  908236:	c050      	movi.n	a5, 0
		txq= &sc->sc_txq[qnum];
		txq->axq_qnum = qnum;
		txq->axq_link = NULL;
  908238:	d750      	mov.n	a7, a5
		asf_tailq_init(&txq->axq_q);
		txq->axq_depth = 0;
		txq->axq_linkbuf = NULL;
		asf_tailq_init(&txq->axq_tidq);
		sc->sc_txqsetup |= 1<<qnum;
  90823a:	2a0a01        	movi	a10, 1
	struct ath_txq *txq;

	sc->sc_txqsetup=0;

	for (qnum=0;qnum<HAL_NUM_TX_QUEUES;qnum++) {
		txq= &sc->sc_txq[qnum];
  90823d:	285c1e        	addi	a8, a5, 30
  908240:	0b8811        	slli	a8, a8, 5
  908243:	a838      	add.n	a8, a3, a8
		txq->axq_qnum = qnum;
		txq->axq_link = NULL;
		asf_tailq_init(&txq->axq_q);
  908245:	298c14        	addi	a9, a8, 20

	sc->sc_txqsetup=0;

	for (qnum=0;qnum<HAL_NUM_TX_QUEUES;qnum++) {
		txq= &sc->sc_txq[qnum];
		txq->axq_qnum = qnum;
  908248:	9583      	s32i.n	a5, a8, 12
		txq->axq_link = NULL;
		asf_tailq_init(&txq->axq_q);
  90824a:	9986      	s32i.n	a9, a8, 24
	struct ath_txq *txq;

	sc->sc_txqsetup=0;

	for (qnum=0;qnum<HAL_NUM_TX_QUEUES;qnum++) {
		txq= &sc->sc_txq[qnum];
  90824c:	bc86      	addi.n	a6, a8, 12
		txq->axq_qnum = qnum;
		txq->axq_link = NULL;
  90824e:	9784      	s32i.n	a7, a8, 16
		asf_tailq_init(&txq->axq_q);
  908250:	9785      	s32i.n	a7, a8, 20
		txq->axq_depth = 0;
  908252:	9787      	s32i.n	a7, a8, 28
		txq->axq_linkbuf = NULL;
  908254:	9788      	s32i.n	a7, a8, 32
		asf_tailq_init(&txq->axq_tidq);
  908256:	9789      	s32i.n	a7, a8, 36
  908258:	288c24        	addi	a8, a8, 36
  90825b:	9867      	s32i.n	a8, a6, 28
		sc->sc_txqsetup |= 1<<qnum;
  90825d:	263d03        	addmi	a6, a3, 0x300
  908260:	2860c8        	l8ui	a8, a6, 200
  908263:	005104        	ssl	a5
  908266:	00a91a        	sll	a9, a10
  908269:	089802        	or	a8, a9, a8
  90826c:	2864c8        	s8i	a8, a6, 200
	a_int32_t qnum;
	struct ath_txq *txq;

	sc->sc_txqsetup=0;

	for (qnum=0;qnum<HAL_NUM_TX_QUEUES;qnum++) {
  90826f:	b155      	addi.n	a5, a5, 1
		txq= &sc->sc_txq[qnum];
		txq->axq_qnum = qnum;
		txq->axq_link = NULL;
  908271:	c020      	movi.n	a2, 0
	a_int32_t qnum;
	struct ath_txq *txq;

	sc->sc_txqsetup=0;

	for (qnum=0;qnum<HAL_NUM_TX_QUEUES;qnum++) {
  908273:	6959c6        	bnei	a5, 10, 90823d <ath_tgt_attach+0x3ad>
		txq->axq_linkbuf = NULL;
		asf_tailq_init(&txq->axq_tidq);
		sc->sc_txqsetup |= 1<<qnum;
	}

	sc->sc_uapsdq  = &sc->sc_txq[UAPSDQ_NUM];
  908276:	264aec        	movi	a6, 0x4ec
  908279:	253d05        	addmi	a5, a3, 0x500
  90827c:	a636      	add.n	a6, a3, a6
  90827e:	965d      	s32i.n	a6, a5, 52
	sc->sc_cabq    = &sc->sc_txq[CABQ_NUM];
  908280:	264acc        	movi	a6, 0x4cc
  908283:	a636      	add.n	a6, a3, a6
  908285:	965c      	s32i.n	a6, a5, 48

	sc->sc_ac2q[WME_AC_BE]  = &sc->sc_txq[0];
  908287:	263acc        	movi	a6, 0x3cc
  90828a:	a636      	add.n	a6, a3, a6
  90828c:	9653      	s32i.n	a6, a5, 12
	sc->sc_ac2q[WME_AC_BK]  = &sc->sc_txq[1];
  90828e:	263aec        	movi	a6, 0x3ec
  908291:	a636      	add.n	a6, a3, a6
  908293:	9654      	s32i.n	a6, a5, 16
	sc->sc_ac2q[WME_AC_VI]  = &sc->sc_txq[2];
  908295:	264a0c        	movi	a6, 0x40c
  908298:	a636      	add.n	a6, a3, a6
  90829a:	9655      	s32i.n	a6, a5, 20
	sc->sc_ac2q[WME_AC_VO]  = &sc->sc_txq[3];
  90829c:	264a2c        	movi	a6, 0x42c
  90829f:	a636      	add.n	a6, a3, a6
	}

	BUF_Pool_create_pool(sc->pool_handle, POOL_ID_WLAN_RX_BUF, ath_numrxdescs, 1664);

	ath_tgt_txq_setup(sc);
	sc->sc_imask =0;
  9082a1:	2236c4        	s32i	a2, a3, 0x310
	ah->ah_setInterrupts(ah, 0);
  9082a4:	234228        	l32i	a3, a4, 160
	sc->sc_cabq    = &sc->sc_txq[CABQ_NUM];

	sc->sc_ac2q[WME_AC_BE]  = &sc->sc_txq[0];
	sc->sc_ac2q[WME_AC_BK]  = &sc->sc_txq[1];
	sc->sc_ac2q[WME_AC_VI]  = &sc->sc_txq[2];
	sc->sc_ac2q[WME_AC_VO]  = &sc->sc_txq[3];
  9082a7:	9656      	s32i.n	a6, a5, 24

	BUF_Pool_create_pool(sc->pool_handle, POOL_ID_WLAN_RX_BUF, ath_numrxdescs, 1664);

	ath_tgt_txq_setup(sc);
	sc->sc_imask =0;
	ah->ah_setInterrupts(ah, 0);
  9082a9:	da40      	mov.n	a10, a4
  9082ab:	db20      	mov.n	a11, a2
  9082ad:	0b3000        	callx8	a3
  9082b0:	d10f      	retw.n

	return 0;
bad:
bad2:
	ath_desc_free(sc);
  9082b2:	da30      	mov.n	a10, a3
  9082b4:	5bf92d        	call8	90676c <ath_desc_free>
	if (ah)
  9082b7:	c845      	beqz.n	a4, 9082c0 <ath_tgt_attach+0x430>
		ah->ah_detach(ah);
  9082b9:	8246      	l32i.n	a2, a4, 24
  9082bb:	da40      	mov.n	a10, a4
  9082bd:	0b2000        	callx8	a2
}
  9082c0:	d10f      	retw.n
	...

009082c4 <ath_detach>:
	HIF_shutdown(sc->tgt_hif_handle);
	BUF_Pool_shutdown(sc->pool_handle);
}

a_int32_t ath_detach(struct ath_softc_tgt *sc)
{
  9082c4:	6c1004        	entry	a1, 32

static void tgt_hif_htc_wmi_shutdown(struct ath_softc_tgt *sc)
{
	HTC_NotifyTargetDetached(sc->tgt_htc_handle);

	WMI_Shutdown(sc->tgt_wmi_handle);
  9082c7:	137184        	l32r	a3, 8e48d8 <vdesc_module_install+0x79c>
  9082ca:	8a23      	l32i.n	a10, a2, 12
  9082cc:	283297        	l32i	a8, a3, 0x25c
  9082cf:	0b8000        	callx8	a8
	HTC_Shutdown(sc->tgt_htc_handle);
  9082d2:	8a22      	l32i.n	a10, a2, 8
  9082d4:	283284        	l32i	a8, a3, 0x210
  9082d7:	0b8000        	callx8	a8
	HIF_shutdown(sc->tgt_hif_handle);
  9082da:	8a21      	l32i.n	a10, a2, 4
  9082dc:	283276        	l32i	a8, a3, 0x1d8
  9082df:	0b8000        	callx8	a8
	BUF_Pool_shutdown(sc->pool_handle);
  9082e2:	8a20      	l32i.n	a10, a2, 0
  9082e4:	23329f        	l32i	a3, a3, 0x27c
  9082e7:	0b3000        	callx8	a3
}

a_int32_t ath_detach(struct ath_softc_tgt *sc)
{
	tgt_hif_htc_wmi_shutdown(sc);
}
  9082ea:	d10f      	retw.n

009082ec <__adf_os_dmamem_alloc>:
 * @return void* (Virtual address)
 */
inline void*
__adf_os_dmamem_alloc(__adf_os_device_t osdev, adf_os_size_t size, 
                      a_bool_t coherent, __adf_os_dma_map_t *dmap)
{    
  9082ec:	6c1004        	entry	a1, 32
    (*dmap) = A_ALLOCRAM(sizeof(struct __adf_dma_map));
  9082ef:	147184        	l32r	a4, 8e4900 <vdesc_module_install+0x7c4>
  9082f2:	c0a0      	movi.n	a10, 0
  9082f4:	224252        	l32i	a2, a4, 0x148
  9082f7:	c0bc      	movi.n	a11, 12
  9082f9:	0b2000        	callx8	a2
  9082fc:	9a50      	s32i.n	a10, a5, 0
  9082fe:	d2a0      	mov.n	a2, a10
    
	if((*dmap) == NULL){
  908300:	c9a1      	beqz.n	a10, 908315 <__adf_os_dmamem_alloc+0x29>
		goto fail_malloc;
	}
	    
    (*dmap)->ds_addr = A_ALLOCRAM(size);
  908302:	244252        	l32i	a4, a4, 0x148
  908305:	c0a0      	movi.n	a10, 0
  908307:	db30      	mov.n	a11, a3
  908309:	0b4000        	callx8	a4
  90830c:	9a21      	s32i.n	a10, a2, 4
    (*dmap)->ds_len = size;
  90830e:	8250      	l32i.n	a2, a5, 0
  908310:	232504        	s16i	a3, a2, 8
    
    return (*dmap)->ds_addr;
  908313:	8221      	l32i.n	a2, a2, 4
    
fail_malloc: 
    return NULL;            
}
  908315:	d10f      	retw.n
	...

00908318 <rcIsValidPhyRate>:

/* Return true only for single stream */

static A_BOOL
rcIsValidPhyRate(A_UINT32 phy, A_UINT32 capflag, A_BOOL ignoreCW)
{
  908318:	6c1004        	entry	a1, 32
  90831b:	d820      	mov.n	a8, a2
	if (WLAN_RC_PHY_HT(phy) && !(capflag & WLAN_RC_HT_FLAG)) {
  90831d:	6e2404        	bltui	a2, 4, 908325 <rcIsValidPhyRate+0xd>
		return FALSE;
  908320:	c020      	movi.n	a2, 0
/* Return true only for single stream */

static A_BOOL
rcIsValidPhyRate(A_UINT32 phy, A_UINT32 capflag, A_BOOL ignoreCW)
{
	if (WLAN_RC_PHY_HT(phy) && !(capflag & WLAN_RC_HT_FLAG)) {
  908322:	7c3764        	bbci	a3, 28, 90838a <rcIsValidPhyRate+0x72>
		return FALSE;
	}

	if (WLAN_RC_PHY_DS(phy) && !(capflag & WLAN_RC_DS_FLAG))  {
  908325:	c72d      	movi.n	a2, -3
  908327:	028201        	and	a2, a8, a2
  90832a:	682504        	beqi	a2, 5, 908332 <rcIsValidPhyRate+0x1a>
  90832d:	c099      	movi.n	a9, 9
  90832f:	792904        	bne	a2, a9, 908337 <rcIsValidPhyRate+0x1f>

static A_BOOL
rcIsValidPhyRate(A_UINT32 phy, A_UINT32 capflag, A_BOOL ignoreCW)
{
	if (WLAN_RC_PHY_HT(phy) && !(capflag & WLAN_RC_HT_FLAG)) {
		return FALSE;
  908332:	c020      	movi.n	a2, 0
	}

	if (WLAN_RC_PHY_DS(phy) && !(capflag & WLAN_RC_DS_FLAG))  {
  908334:	7f3752        	bbci	a3, 31, 90838a <rcIsValidPhyRate+0x72>
		return FALSE;
	}
	if (WLAN_RC_PHY_SGI(phy) && !(capflag & WLAN_RC_HT40_SGI_FLAG)) {
  908337:	228cf8        	addi	a2, a8, -8
  90833a:	6f2404        	bgeui	a2, 4, 908342 <rcIsValidPhyRate+0x2a>

static A_BOOL
rcIsValidPhyRate(A_UINT32 phy, A_UINT32 capflag, A_BOOL ignoreCW)
{
	if (WLAN_RC_PHY_HT(phy) && !(capflag & WLAN_RC_HT_FLAG)) {
		return FALSE;
  90833d:	c020      	movi.n	a2, 0
	}

	if (WLAN_RC_PHY_DS(phy) && !(capflag & WLAN_RC_DS_FLAG))  {
		return FALSE;
	}
	if (WLAN_RC_PHY_SGI(phy) && !(capflag & WLAN_RC_HT40_SGI_FLAG)) {
  90833f:	7d3747        	bbci	a3, 29, 90838a <rcIsValidPhyRate+0x72>
		return FALSE;
	}

	if (!ignoreCW && WLAN_RC_PHY_HT(phy)) {
  908342:	c020      	movi.n	a2, 0
  908344:	c0a1      	movi.n	a10, 1
  908346:	d520      	mov.n	a5, a2
  908348:	04a538        	moveqz	a5, a10, a4
  90834b:	d450      	mov.n	a4, a5
  90834d:	725135        	beq	a5, a2, 908386 <rcIsValidPhyRate+0x6e>
  908350:	6e8432        	bltui	a8, 4, 908386 <rcIsValidPhyRate+0x6e>
		if (WLAN_RC_PHY_40(phy) && !(capflag & WLAN_RC_40_FLAG)) {
  908353:	298cfa        	addi	a9, a8, -6
  908356:	6e920c        	bltui	a9, 2, 908366 <rcIsValidPhyRate+0x4e>
  908359:	2b8cf6        	addi	a11, a8, -10
  90835c:	0ba238        	moveqz	a2, a10, a11
  90835f:	cc23      	bnez.n	a2, 908366 <rcIsValidPhyRate+0x4e>
  908361:	c02b      	movi.n	a2, 11
  908363:	728904        	bne	a8, a2, 90836b <rcIsValidPhyRate+0x53>
			return FALSE;
  908366:	c020      	movi.n	a2, 0
	if (WLAN_RC_PHY_SGI(phy) && !(capflag & WLAN_RC_HT40_SGI_FLAG)) {
		return FALSE;
	}

	if (!ignoreCW && WLAN_RC_PHY_HT(phy)) {
		if (WLAN_RC_PHY_40(phy) && !(capflag & WLAN_RC_40_FLAG)) {
  908368:	7e371e        	bbci	a3, 30, 90838a <rcIsValidPhyRate+0x72>
		if (!WLAN_RC_PHY_40(phy) && (capflag & WLAN_RC_40_FLAG)) {
			return FALSE;
		}
	}
    
	return TRUE;
  90836b:	c021      	movi.n	a2, 1
	if (!ignoreCW && WLAN_RC_PHY_HT(phy)) {
		if (WLAN_RC_PHY_40(phy) && !(capflag & WLAN_RC_40_FLAG)) {
			return FALSE;
		}

		if (!WLAN_RC_PHY_40(phy) && (capflag & WLAN_RC_40_FLAG)) {
  90836d:	6e9219        	bltui	a9, 2, 90838a <rcIsValidPhyRate+0x72>
  908370:	688916        	beqi	a8, 10, 90838a <rcIsValidPhyRate+0x72>
  908373:	c09b      	movi.n	a9, 11
  908375:	798111        	beq	a8, a9, 90838a <rcIsValidPhyRate+0x72>
  908378:	002004        	ssr	a2
  90837b:	030319        	srl	a3, a3
  90837e:	023203        	xor	a2, a3, a2
  908381:	020240        	extui	a2, a2, 0, 1
  908384:	d10f      	retw.n
			return FALSE;
		}
	}
    
	return TRUE;
  908386:	c021      	movi.n	a2, 1
  908388:	d10f      	retw.n
}
  90838a:	d10f      	retw.n

0090838c <rcRateSetseries$isra$5>:

	return rate;
}

static void
rcRateSetseries(const RATE_TABLE_11N *pRateTable ,
  90838c:	6c1004        	entry	a1, 32
                struct ath_rc_series *series,
		A_UINT8 tries, A_UINT8 rix,
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
	series->tries = tries;
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
  90838f:	c0b0      	movi.n	a11, 0
  908391:	c190      	movi.n	a9, 16
  908393:	06b938        	moveqz	a9, a11, a6
		(WLAN_RC_PHY_DS(pRateTable->info[rix].phy) ? ATH_RC_DS_FLAG : 0) | 
  908396:	05560a        	addx4	a6, a5, a5
  908399:	02660b        	addx8	a6, a6, a2
rcRateSetseries(const RATE_TABLE_11N *pRateTable ,
                struct ath_rc_series *series,
		A_UINT8 tries, A_UINT8 rix,
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
	series->tries = tries;
  90839c:	243401        	s8i	a4, a3, 1
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
		(WLAN_RC_PHY_DS(pRateTable->info[rix].phy) ? ATH_RC_DS_FLAG : 0) | 
  90839f:	28600c        	l8ui	a8, a6, 12
  9083a2:	c76d      	movi.n	a6, -3
  9083a4:	068601        	and	a6, a8, a6
  9083a7:	c0a1      	movi.n	a10, 1
  9083a9:	68650b        	beqi	a6, 5, 9083b8 <rcRateSetseries$isra$5+0x2c>
  9083ac:	260a09        	movi	a6, 9
  9083af:	768105        	beq	a8, a6, 9083b8 <rcRateSetseries$isra$5+0x2c>
  9083b2:	268cf5        	addi	a6, a8, -11
  9083b5:	06ba39        	movnez	a10, a11, a6
		(WLAN_RC_PHY_40(pRateTable->info[rix].phy) ? ATH_RC_CW40_FLAG : 0) | 
  9083b8:	268cfa        	addi	a6, a8, -6
  9083bb:	060647        	extui	a6, a6, 0, 8
                struct ath_rc_series *series,
		A_UINT8 tries, A_UINT8 rix,
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
	series->tries = tries;
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
  9083be:	09ab02        	or	a11, a10, a9
		(WLAN_RC_PHY_DS(pRateTable->info[rix].phy) ? ATH_RC_DS_FLAG : 0) | 
		(WLAN_RC_PHY_40(pRateTable->info[rix].phy) ? ATH_RC_CW40_FLAG : 0) | 
  9083c1:	6e6219        	bltui	a6, 2, 9083de <rcRateSetseries$isra$5+0x52>
  9083c4:	c0a0      	movi.n	a10, 0
  9083c6:	298cf6        	addi	a9, a8, -10
  9083c9:	c061      	movi.n	a6, 1
  9083cb:	096a38        	moveqz	a10, a6, a9
                struct ath_rc_series *series,
		A_UINT8 tries, A_UINT8 rix,
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
	series->tries = tries;
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
  9083ce:	ccac      	bnez.n	a10, 9083de <rcRateSetseries$isra$5+0x52>
  9083d0:	c092      	movi.n	a9, 2
  9083d2:	268cf5        	addi	a6, a8, -11
  9083d5:	06a939        	movnez	a9, a10, a6
  9083d8:	600004        	j	9083e0 <rcRateSetseries$isra$5+0x54>
  9083db:	000000        	ill
  9083de:	c092      	movi.n	a9, 2
		(WLAN_RC_PHY_DS(pRateTable->info[rix].phy) ? ATH_RC_DS_FLAG : 0) | 
		(WLAN_RC_PHY_40(pRateTable->info[rix].phy) ? ATH_RC_CW40_FLAG : 0) | 
		(WLAN_RC_PHY_SGI(pRateTable->info[rix].phy) ? ATH_RC_HT40_SGI_FLAG : 0);
  9083e0:	288cf8        	addi	a8, a8, -8
                struct ath_rc_series *series,
		A_UINT8 tries, A_UINT8 rix,
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
	series->tries = tries;
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
  9083e3:	080847        	extui	a8, a8, 0, 8
  9083e6:	09b902        	or	a9, a11, a9
  9083e9:	c0b0      	movi.n	a11, 0
  9083eb:	6f8401        	bgeui	a8, 4, 9083f0 <rcRateSetseries$isra$5+0x64>
  9083ee:	c0b4      	movi.n	a11, 4
  9083f0:	0b9b02        	or	a11, a9, a11
		{
			series->flags |= ATH_RC_TX_STBC_FLAG;
		}
	}
#endif
	series->rix = pRateTable->info[rix].baseIndex;
  9083f3:	05550a        	addx4	a5, a5, a5
                struct ath_rc_series *series,
		A_UINT8 tries, A_UINT8 rix,
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
	series->tries = tries;
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
  9083f6:	2b3403        	s8i	a11, a3, 3
		{
			series->flags |= ATH_RC_TX_STBC_FLAG;
		}
	}
#endif
	series->rix = pRateTable->info[rix].baseIndex;
  9083f9:	02550b        	addx8	a5, a5, a2
  9083fc:	22501e        	l8ui	a2, a5, 30
  9083ff:	223400        	s8i	a2, a3, 0
	series->max4msframelen = pRateTable->info[rix].max4msframelen;
  908402:	8259      	l32i.n	a2, a5, 36
  908404:	9231      	s32i.n	a2, a3, 4
	series->txrateKbps = pRateTable->info[rix].rateKbps;
  908406:	8254      	l32i.n	a2, a5, 16
  908408:	9232      	s32i.n	a2, a3, 8
	else if(chainmask == 1) 
		series->tx_chainmask = 1;
	else 
		series->tx_chainmask = pRateTable->info[rix].txChainMask_2ch;  /*Chainmask is 3 or 5*/
#else
	series->tx_chainmask = 1;
  90840a:	c021      	movi.n	a2, 1
  90840c:	223402        	s8i	a2, a3, 2
  90840f:	d10f      	retw.n
  908411:	000000        	ill

00908414 <rcUpdate_ht$isra$7>:
		}
	}
}

static void
rcUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an, int txRate, 
  908414:	6c1006        	entry	a1, 48
  908417:	2c1119        	l16ui	a12, a1, 50
  90841a:	07094f        	extui	a9, a7, 0, 16
            A_BOOL Xretries, int retries, A_UINT8 curTxAnt, 
            A_UINT16 nFrames, A_UINT16 nBad)
{
	TX_RATE_CTRL *pRc;
	A_UINT32 nowMsec = A_MS_TICKGET();
  90841d:	c0a0      	movi.n	a10, 0
  90841f:	9912      	s32i.n	a9, a1, 8
  908421:	9510      	s32i.n	a5, a1, 0
  908423:	9c13      	s32i.n	a12, a1, 12
  908425:	5beddd        	call8	903b9c <ath_hal_getuptime>
	A_UINT8 lastPer;
	int rate,count;
	struct atheros_node *pSib = ATH_NODE_ATHEROS(an);
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  908428:	252248        	l32i	a5, a2, 0x120
  90842b:	2222c2        	l32i	a2, a2, 0x308
{
	TX_RATE_CTRL *pRc;
	A_UINT32 nowMsec = A_MS_TICKGET();
	A_UINT8 lastPer;
	int rate,count;
	struct atheros_node *pSib = ATH_NODE_ATHEROS(an);
  90842e:	233282        	l32i	a3, a3, 0x208
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  908431:	05220a        	addx4	a2, a2, a5
rcUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an, int txRate, 
            A_BOOL Xretries, int retries, A_UINT8 curTxAnt, 
            A_UINT16 nFrames, A_UINT16 nBad)
{
	TX_RATE_CTRL *pRc;
	A_UINT32 nowMsec = A_MS_TICKGET();
  908434:	d8a0      	mov.n	a8, a10
	A_UINT8 lastPer;
	int rate,count;
	struct atheros_node *pSib = ATH_NODE_ATHEROS(an);
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  908436:	8521      	l32i.n	a5, a2, 4
		100 * 7 / 8,    // 87.5
		100 * 8 / 9,    // 88.8
		100 * 9 / 10    // 90
	};

	if (!pSib)
  908438:	8912      	l32i.n	a9, a1, 8
  90843a:	8b10      	l32i.n	a11, a1, 0
  90843c:	8c13      	l32i.n	a12, a1, 12
  90843e:	6431c6        	beqz	a3, 908608 <rcUpdate_ht$isra$7+0x1f4>
	pRc = (TX_RATE_CTRL *)(pSib);

	ASSERT(retries >= 0 && retries < MAX_TX_RETRIES);
	ASSERT(txRate >= 0);
    
	if (txRate < 0) {
  908441:	6641c3        	bltz	a4, 908608 <rcUpdate_ht$isra$7+0x1f4>
		return;
	}

	lastPer = pRc->state[txRate].per;
  908444:	a437      	add.n	a7, a3, a4
  908446:	227000        	l8ui	a2, a7, 0

	if (Xretries) {
  908449:	cbb0      	beqz.n	a11, 90847d <rcUpdate_ht$isra$7+0x69>
		/* Update the PER. */
		if (Xretries == 1) {
  90844b:	69b111        	bnei	a11, 1, 908460 <rcUpdate_ht$isra$7+0x4c>
			pRc->state[txRate].per += 30;
  90844e:	292c1e        	addi	a9, a2, 30
  908451:	090947        	extui	a9, a9, 0, 8
			if (pRc->state[txRate].per > 100) {
  908454:	260a64        	movi	a6, 100
  908457:	79630d        	bltu	a6, a9, 908468 <rcUpdate_ht$isra$7+0x54>
	lastPer = pRc->state[txRate].per;

	if (Xretries) {
		/* Update the PER. */
		if (Xretries == 1) {
			pRc->state[txRate].per += 30;
  90845a:	297400        	s8i	a9, a7, 0
  90845d:	60000a        	j	90846b <rcUpdate_ht$isra$7+0x57>
			if (retries >= count) {
				retries = count - 1;
			}

			/* new_PER = 7/8*old_PER + 1/8*(currentPER) */
			pRc->state[txRate].per = (A_UINT8)(pRc->state[txRate].per - 
  908460:	bc29      	addi.n	a9, a2, 12
  908462:	023614        	srli	a6, a2, 3
  908465:	06960c        	sub	a6, a9, a6
  908468:	267400        	s8i	a6, a7, 0
						   (pRc->state[txRate].per / 8) + ((100) / 8));
		}

		/* Xretries == 1 or 2 */

		if (pRc->probeRate == txRate)
  90846b:	263037        	l8ui	a6, a3, 55
  90846e:	746102        	beq	a6, a4, 908474 <rcUpdate_ht$isra$7+0x60>
  908471:	6000c3        	j	908538 <rcUpdate_ht$isra$7+0x124>
			pRc->probeRate = 0;
  908474:	c060      	movi.n	a6, 0
  908476:	263437        	s8i	a6, a3, 55
  908479:	6000bb        	j	908538 <rcUpdate_ht$isra$7+0x124>
  90847c:	00c0a9        	excw
  90847f:	0a6634        	min	a6, a6, a10
		count = sizeof(nRetry2PerLookup) / sizeof(nRetry2PerLookup[0]);
		if (retries >= count) {
			retries = count - 1;
		}

		if (nBad) {
  908482:	64c03f        	beqz	a12, 9084c5 <rcUpdate_ht$isra$7+0xb1>
			 * that part is 100 * nBad / nFrames, and it contributes
			 * 100 * nBad / (nFrames * (retries+1)) to the above
			 * PER.  The expression below is a simplified version
			 * of the sum of these two terms.
			 */
			if (nFrames > 0)
  908485:	649053        	beqz	a9, 9084dc <rcUpdate_ht$isra$7+0xc8>
				pRc->state[txRate].per = (A_UINT8)(pRc->state[txRate].per - 
					   (pRc->state[txRate].per / 8) + 
					   ((100*(retries*nFrames + nBad)/(nFrames*(retries+1))) / 8));
  908488:	096a28        	mull	a10, a6, a9
  90848b:	b16b      	addi.n	a11, a6, 1
  90848d:	acaa      	add.n	a10, a10, a12
  90848f:	0aaa0a        	addx4	a10, a10, a10
  908492:	0b9b28        	mull	a11, a9, a11
			 * 100 * nBad / (nFrames * (retries+1)) to the above
			 * PER.  The expression below is a simplified version
			 * of the sum of these two terms.
			 */
			if (nFrames > 0)
				pRc->state[txRate].per = (A_UINT8)(pRc->state[txRate].per - 
  908495:	023d14        	srli	a13, a2, 3
					   (pRc->state[txRate].per / 8) + 
					   ((100*(retries*nFrames + nBad)/(nFrames*(retries+1))) / 8));
  908498:	0aaa0a        	addx4	a10, a10, a10
			 * 100 * nBad / (nFrames * (retries+1)) to the above
			 * PER.  The expression below is a simplified version
			 * of the sum of these two terms.
			 */
			if (nFrames > 0)
				pRc->state[txRate].per = (A_UINT8)(pRc->state[txRate].per - 
  90849b:	0d2d0c        	sub	a13, a2, a13
					   (pRc->state[txRate].per / 8) + 
					   ((100*(retries*nFrames + nBad)/(nFrames*(retries+1))) / 8));
  90849e:	0eaa11        	slli	a10, a10, 2
  9084a1:	9810      	s32i.n	a8, a1, 0
  9084a3:	9912      	s32i.n	a9, a1, 8
  9084a5:	9c13      	s32i.n	a12, a1, 12
  9084a7:	9d11      	s32i.n	a13, a1, 4
  9084a9:	5b7210        	call8	8e4cec <__divsi3>
  9084ac:	b7ab      	addi.n	a11, a10, 7
			 * 100 * nBad / (nFrames * (retries+1)) to the above
			 * PER.  The expression below is a simplified version
			 * of the sum of these two terms.
			 */
			if (nFrames > 0)
				pRc->state[txRate].per = (A_UINT8)(pRc->state[txRate].per - 
  9084ae:	8d11      	l32i.n	a13, a1, 4
					   (pRc->state[txRate].per / 8) + 
					   ((100*(retries*nFrames + nBad)/(nFrames*(retries+1))) / 8));
  9084b0:	0aba3a        	movltz	a10, a11, a10
  9084b3:	0a3a12        	srai	a10, a10, 3
			 * 100 * nBad / (nFrames * (retries+1)) to the above
			 * PER.  The expression below is a simplified version
			 * of the sum of these two terms.
			 */
			if (nFrames > 0)
				pRc->state[txRate].per = (A_UINT8)(pRc->state[txRate].per - 
  9084b6:	aadd      	add.n	a13, a13, a10
  9084b8:	2d7400        	s8i	a13, a7, 0
  9084bb:	8810      	l32i.n	a8, a1, 0
  9084bd:	8912      	l32i.n	a9, a1, 8
  9084bf:	8c13      	l32i.n	a12, a1, 12
  9084c1:	600017        	j	9084dc <rcUpdate_ht$isra$7+0xc8>
  9084c4:	001a72        	excw
					   ((100*(retries*nFrames + nBad)/(nFrames*(retries+1))) / 8));
		} else {
			/* new_PER = 7/8*old_PER + 1/8*(currentPER) */

			pRc->state[txRate].per = (A_UINT8)(pRc->state[txRate].per - 
				   (pRc->state[txRate].per / 8) + (nRetry2PerLookup[retries] / 8));
  9084c7:	be02      	addi.n	a2, a0, 14
					   (pRc->state[txRate].per / 8) + 
					   ((100*(retries*nFrames + nBad)/(nFrames*(retries+1))) / 8));
		} else {
			/* new_PER = 7/8*old_PER + 1/8*(currentPER) */

			pRc->state[txRate].per = (A_UINT8)(pRc->state[txRate].per - 
  9084c9:	3b140a        	excw
				   (pRc->state[txRate].per / 8) + (nRetry2PerLookup[retries] / 8));
  9084cc:	6a0a8a        	blti	a0, 12, 90845a <rcUpdate_ht$isra$7+0x46>
  9084cf:	a00b      	add.n	a11, a0, a0
					   (pRc->state[txRate].per / 8) + 
					   ((100*(retries*nFrames + nBad)/(nFrames*(retries+1))) / 8));
		} else {
			/* new_PER = 7/8*old_PER + 1/8*(currentPER) */

			pRc->state[txRate].per = (A_UINT8)(pRc->state[txRate].per - 
  9084d1:	2b0c0a        	addi	a11, a0, 10
				   (pRc->state[txRate].per / 8) + (nRetry2PerLookup[retries] / 8));
  9084d4:	3a140a        	excw
					   (pRc->state[txRate].per / 8) + 
					   ((100*(retries*nFrames + nBad)/(nFrames*(retries+1))) / 8));
		} else {
			/* new_PER = 7/8*old_PER + 1/8*(currentPER) */

			pRc->state[txRate].per = (A_UINT8)(pRc->state[txRate].per - 
  9084d7:	ba08      	addi.n	a8, a0, 10
  9084d9:	2a7400        	s8i	a10, a7, 0
		/*
		 * If we got at most one retry then increase the max rate if
		 * this was a probe.  Otherwise, ignore the probe.
		 */

		if (pRc->probeRate && pRc->probeRate == txRate) {
  9084dc:	273037        	l8ui	a7, a3, 55
  9084df:	cb79      	beqz.n	a7, 90851c <rcUpdate_ht$isra$7+0x108>
  9084e1:	747937        	bne	a7, a4, 90851c <rcUpdate_ht$isra$7+0x108>
			if (retries > 0 || 2 * nBad > nFrames) {
  9084e4:	6b6105        	bgei	a6, 1, 9084ed <rcUpdate_ht$isra$7+0xd9>
  9084e7:	0fcc11        	slli	a12, a12, 1
  9084ea:	7c9a07        	bge	a9, a12, 9084f5 <rcUpdate_ht$isra$7+0xe1>
				 * any retries means the probe failed.  Also,
				 * if the attempt worked, but more than half
				 * the subframes were bad then also consider
				 * the probe a failure.
				 */
				pRc->probeRate = 0;
  9084ed:	c070      	movi.n	a7, 0
  9084ef:	273437        	s8i	a7, a3, 55
  9084f2:	600026        	j	90851c <rcUpdate_ht$isra$7+0x108>
			} else {
				pRc->rateMaxPhy = pRc->probeRate;
  9084f5:	24347d        	s8i	a4, a3, 125

				if (pRc->state[pRc->probeRate].per > 30) {
  9084f8:	a436      	add.n	a6, a3, a4
  9084fa:	276000        	l8ui	a7, a6, 0
  9084fd:	c19e      	movi.n	a9, 30
  9084ff:	779b05        	bgeu	a9, a7, 908508 <rcUpdate_ht$isra$7+0xf4>
					pRc->state[pRc->probeRate].per = 20;
  908502:	270a14        	movi	a7, 20
  908505:	276400        	s8i	a7, a6, 0
				}

				pRc->probeRate = 0;
  908508:	c060      	movi.n	a6, 0
  90850a:	263437        	s8i	a6, a3, 55
				/*
				 * Since this probe succeeded, we allow the next probe
				 * twice as soon.  This allows the maxRate to move up
				 * faster if the probes are succesful.
				 */
				pRc->probeTime = nowMsec - pRateTable->probeInterval / 2;
  90850d:	265001        	l8ui	a6, a5, 1
  908510:	061614        	srli	a6, a6, 1
  908513:	06860c        	sub	a6, a8, a6
  908516:	963f      	s32i.n	a6, a3, 60
  908518:	600008        	j	908524 <rcUpdate_ht$isra$7+0x110>
  90851b:	006a61        	excw
			}
		}

		if (retries > 0) {
  90851e:	04c060        	excw
			 *
			 * Later: if rssiAck is close to pRc->state[txRate].rssiThres
			 * and we see lots of retries, then we could increase
			 * pRc->state[txRate].rssiThres.
			 */
			pRc->hwMaxRetryPktCnt = 0;
  908521:	600010        	j	908535 <rcUpdate_ht$isra$7+0x121>
		} else {
			/*
			 * It worked with no retries.  First ignore bogus (small)
			 * rssiAck values.
			 */
			if (txRate == pRc->rateMaxPhy && pRc->hwMaxRetryPktCnt < 255) {
  908524:	26307d        	l8ui	a6, a3, 125
  908527:	76490d        	bne	a4, a6, 908538 <rcUpdate_ht$isra$7+0x124>
  90852a:	263040        	l8ui	a6, a3, 64
  90852d:	270aff        	movi	a7, 255
  908530:	776104        	beq	a6, a7, 908538 <rcUpdate_ht$isra$7+0x124>
				pRc->hwMaxRetryPktCnt++;
  908533:	b166      	addi.n	a6, a6, 1
  908535:	263440        	s8i	a6, a3, 64
    
	/*
	 * If this rate looks bad (high PER) then stop using it for
	 * a while (except if we are probing).
	 */
	if (pRc->state[txRate].per >= 55 && txRate > 0 &&
  908538:	a436      	add.n	a6, a3, a4
  90853a:	296000        	l8ui	a9, a6, 0
  90853d:	c366      	movi.n	a6, 54
  90853f:	796b42        	bgeu	a6, a9, 908585 <rcUpdate_ht$isra$7+0x171>
  908542:	cb4f      	beqz.n	a4, 908585 <rcUpdate_ht$isra$7+0x171>
	    pRateTable->info[txRate].rateKbps <= 
            pRateTable->info[pRc->rateMaxPhy].rateKbps)
  908544:	26307d        	l8ui	a6, a3, 125
	/*
	 * If this rate looks bad (high PER) then stop using it for
	 * a while (except if we are probing).
	 */
	if (pRc->state[txRate].per >= 55 && txRate > 0 &&
	    pRateTable->info[txRate].rateKbps <= 
  908547:	04470a        	addx4	a7, a4, a4
            pRateTable->info[pRc->rateMaxPhy].rateKbps)
  90854a:	06660a        	addx4	a6, a6, a6
	/*
	 * If this rate looks bad (high PER) then stop using it for
	 * a while (except if we are probing).
	 */
	if (pRc->state[txRate].per >= 55 && txRate > 0 &&
	    pRateTable->info[txRate].rateKbps <= 
  90854d:	05770b        	addx8	a7, a7, a5
            pRateTable->info[pRc->rateMaxPhy].rateKbps)
  908550:	05660b        	addx8	a6, a6, a5
    
	/*
	 * If this rate looks bad (high PER) then stop using it for
	 * a while (except if we are probing).
	 */
	if (pRc->state[txRate].per >= 55 && txRate > 0 &&
  908553:	8774      	l32i.n	a7, a7, 16
  908555:	8664      	l32i.n	a6, a6, 16
  908557:	77632a        	bltu	a6, a7, 908585 <rcUpdate_ht$isra$7+0x171>
  90855a:	040c47        	extui	a12, a4, 0, 8
rcGetNextLowerValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc,  
                          A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_INT8 i;

	for (i = 1; i < pRc->maxValidRate ; i++) {
  90855d:	2a3041        	l8ui	a10, a3, 65
  908560:	d730      	mov.n	a7, a3
  908562:	c061      	movi.n	a6, 1
  908564:	600016        	j	90857e <rcUpdate_ht$isra$7+0x16a>
  908567:	002d70        	excw
		if (pRc->validRateIndex[i] == curValidTxRate) {
  90856a:	43b166        	excw
  90856d:	b177      	addi.n	a7, a7, 1
  90856f:	7cd90b        	bne	a13, a12, 90857e <rcUpdate_ht$isra$7+0x16a>
			*pNextIndex = pRc->validRateIndex[i-1];
  908572:	ab3b      	add.n	a11, a3, a11
  908574:	26b041        	l8ui	a6, a11, 65
  908577:	26347d        	s8i	a6, a3, 125
  90857a:	600005        	j	908583 <rcUpdate_ht$isra$7+0x16f>
  90857d:	00db60        	excw
rcGetNextLowerValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc,  
                          A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_INT8 i;

	for (i = 1; i < pRc->maxValidRate ; i++) {
  908580:	7a62e4        	blt	a6, a10, 908568 <rcUpdate_ht$isra$7+0x154>
	{
		rcGetNextLowerValidTxRate(pRateTable, pRc, (A_UINT8) txRate, 
					  &pRc->rateMaxPhy);

		/* Don't probe for a little while. */
		pRc->probeTime = nowMsec;
  908583:	983f      	s32i.n	a8, a3, 60
	}

	/* Make sure the rates below this have lower PER */
	/* Monotonicity is kept only for rates below the current rate. */
	if (pRc->state[txRate].per < lastPer) {
  908585:	729307        	bltu	a9, a2, 908590 <rcUpdate_ht$isra$7+0x17c>
			}
		}
	}

	/* Maintain monotonicity for rates above the current rate*/
	for (rate = txRate; rate < pRc->rateTableSize - 1; rate++) {
  908588:	263036        	l8ui	a6, a3, 54
  90858b:	b069      	addi.n	a9, a6, -1
  90858d:	60004b        	j	9085dc <rcUpdate_ht$isra$7+0x1c8>
		}
	}
}

static void
rcUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an, int txRate, 
  908590:	04490a        	addx4	a9, a4, a4
  908593:	05990b        	addx8	a9, a9, a5
	}

	/* Make sure the rates below this have lower PER */
	/* Monotonicity is kept only for rates below the current rate. */
	if (pRc->state[txRate].per < lastPer) {
		for (rate = txRate - 1; rate >= 0; rate--) {
  908596:	b042      	addi.n	a2, a4, -1
		}
	}
}

static void
rcUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an, int txRate, 
  908598:	c060      	movi.n	a6, 0

	/* Make sure the rates below this have lower PER */
	/* Monotonicity is kept only for rates below the current rate. */
	if (pRc->state[txRate].per < lastPer) {
		for (rate = txRate - 1; rate >= 0; rate--) {
			if (pRateTable->info[rate].phy != pRateTable->info[txRate].phy) {
  90859a:	db90      	mov.n	a11, a9
  90859c:	600021        	j	9085c1 <rcUpdate_ht$isra$7+0x1ad>
  90859f:	00a697        	excw
		}
	}
}

static void
rcUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an, int txRate, 
  9085a2:	277ce4        	addi	a7, a7, -28

	/* Make sure the rates below this have lower PER */
	/* Monotonicity is kept only for rates below the current rate. */
	if (pRc->state[txRate].per < lastPer) {
		for (rate = txRate - 1; rate >= 0; rate--) {
			if (pRateTable->info[rate].phy != pRateTable->info[txRate].phy) {
  9085a5:	2a7000        	l8ui	a10, a7, 0
  9085a8:	27b00c        	l8ui	a7, a11, 12
  9085ab:	77a9d9        	bne	a10, a7, 908588 <rcUpdate_ht$isra$7+0x174>
		}
	}
}

static void
rcUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an, int txRate, 
  9085ae:	a237      	add.n	a7, a3, a2
		for (rate = txRate - 1; rate >= 0; rate--) {
			if (pRateTable->info[rate].phy != pRateTable->info[txRate].phy) {
				break;
			}

			if (pRc->state[rate].per > pRc->state[rate+1].per) {
  9085b0:	2a7001        	l8ui	a10, a7, 1
  9085b3:	2c7000        	l8ui	a12, a7, 0
  9085b6:	7cab02        	bgeu	a10, a12, 9085bc <rcUpdate_ht$isra$7+0x1a8>
				pRc->state[rate].per = pRc->state[rate+1].per;
  9085b9:	2a7400        	s8i	a10, a7, 0
	}

	/* Make sure the rates below this have lower PER */
	/* Monotonicity is kept only for rates below the current rate. */
	if (pRc->state[txRate].per < lastPer) {
		for (rate = txRate - 1; rate >= 0; rate--) {
  9085bc:	b022      	addi.n	a2, a2, -1
  9085be:	266cd8        	addi	a6, a6, -40
  9085c1:	6920db        	bnei	a2, -1, 9085a0 <rcUpdate_ht$isra$7+0x18c>
  9085c4:	63ffc0        	j	908588 <rcUpdate_ht$isra$7+0x174>
  9085c7:	000000        	ill
		}
	}

	/* Maintain monotonicity for rates above the current rate*/
	for (rate = txRate; rate < pRc->rateTableSize - 1; rate++) {
		if (pRc->state[rate+1].per < pRc->state[rate].per) {
  9085ca:	b144      	addi.n	a4, a4, 1
		}
	}
}

static void
rcUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an, int txRate, 
  9085cc:	a432      	add.n	a2, a3, a4
  9085ce:	b027      	addi.n	a7, a2, -1
		}
	}

	/* Maintain monotonicity for rates above the current rate*/
	for (rate = txRate; rate < pRc->rateTableSize - 1; rate++) {
		if (pRc->state[rate+1].per < pRc->state[rate].per) {
  9085d0:	277000        	l8ui	a7, a7, 0
  9085d3:	2a2000        	l8ui	a10, a2, 0
  9085d6:	77ab02        	bgeu	a10, a7, 9085dc <rcUpdate_ht$isra$7+0x1c8>
			pRc->state[rate+1].per = pRc->state[rate].per;
  9085d9:	272400        	s8i	a7, a2, 0
			}
		}
	}

	/* Maintain monotonicity for rates above the current rate*/
	for (rate = txRate; rate < pRc->rateTableSize - 1; rate++) {
  9085dc:	7942ea        	blt	a4, a9, 9085ca <rcUpdate_ht$isra$7+0x1b6>
			pRc->state[rate+1].per = pRc->state[rate].per;
		}
	}

	/* Every so often, we reduce the thresholds and PER (different for CCK and OFDM). */
	if (nowMsec - pRc->perDownTime >= pRateTable->rssiReduceInterval) {
  9085df:	24321e        	l32i	a4, a3, 120
  9085e2:	225002        	l8ui	a2, a5, 2
  9085e5:	04840c        	sub	a4, a8, a4
  9085e8:	72431c        	bltu	a4, a2, 908608 <rcUpdate_ht$isra$7+0x1f4>
  9085eb:	d230      	mov.n	a2, a3
  9085ed:	60000e        	j	9085ff <rcUpdate_ht$isra$7+0x1eb>
  9085f0:	002420        	excw
		for (rate = 0; rate < pRc->rateTableSize; rate++) {
			pRc->state[rate].per = 7*pRc->state[rate].per/8;
  9085f3:	000444        	extui	a4, a0, 0, 5
  9085f6:	0f0434        	min	a4, a0, a15
  9085f9:	122424        	l32r	a2, 8d168c <_bss_end+0x3c3e84>
  9085fc:	00b122        	excw
		}
	}
}

static void
rcUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an, int txRate, 
  9085ff:	03240c        	sub	a4, a2, a3
		}
	}

	/* Every so often, we reduce the thresholds and PER (different for CCK and OFDM). */
	if (nowMsec - pRc->perDownTime >= pRateTable->rssiReduceInterval) {
		for (rate = 0; rate < pRc->rateTableSize; rate++) {
  908602:	7642eb        	blt	a4, a6, 9085f1 <rcUpdate_ht$isra$7+0x1dd>
			pRc->state[rate].per = 7*pRc->state[rate].per/8;
		}

		pRc->perDownTime = nowMsec;
  908605:	28361e        	s32i	a8, a3, 120
  908608:	d10f      	retw.n
	...

0090860c <rcSibUpdate_ht$constprop$9>:
 *  (e.g. SME operation, wireless mode change)
 *
 *  It will determine which rates are valid for use.
 */
static void
rcSibUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an,
  90860c:	6c105e        	entry	a1, 0x2f0
	TX_RATE_CTRL *pRc = (TX_RATE_CTRL *)(pSib);
	PHY_STATE_CTRL mPhyCtrlState;  

	A_UINT8 i, j, k, hi = 0, htHi = 0;

	pRateTable = (RATE_TABLE_11N*)asc->hwRateTable[sc->sc_curmode];
  90860f:	262248        	l32i	a6, a2, 0x120
  908612:	2222c2        	l32i	a2, a2, 0x308
static void
rcSibUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an,
	       A_UINT32 capflag, A_BOOL keepState, struct ieee80211_rate  *pRateSet)
{
	RATE_TABLE_11N *pRateTable = 0;
	struct atheros_node *pSib = ATH_NODE_ATHEROS(an);
  908615:	233282        	l32i	a3, a3, 0x208
	TX_RATE_CTRL *pRc = (TX_RATE_CTRL *)(pSib);
	PHY_STATE_CTRL mPhyCtrlState;  

	A_UINT8 i, j, k, hi = 0, htHi = 0;

	pRateTable = (RATE_TABLE_11N*)asc->hwRateTable[sc->sc_curmode];
  908618:	06220a        	addx4	a2, a2, a6

	/* Initial rate table size. Will change depending on the working rate set */
	pRc->rateTableSize = MAX_TX_RATE_TBL;
  90861b:	c366      	movi.n	a6, 54
	TX_RATE_CTRL *pRc = (TX_RATE_CTRL *)(pSib);
	PHY_STATE_CTRL mPhyCtrlState;  

	A_UINT8 i, j, k, hi = 0, htHi = 0;

	pRateTable = (RATE_TABLE_11N*)asc->hwRateTable[sc->sc_curmode];
  90861d:	8221      	l32i.n	a2, a2, 4

	/* Initial rate table size. Will change depending on the working rate set */
	pRc->rateTableSize = MAX_TX_RATE_TBL;
  90861f:	263436        	s8i	a6, a3, 54
  908622:	c060      	movi.n	a6, 0

	/* Initialize thresholds according to the global rate table */
	for (i = 0 ; (i < pRc->rateTableSize) && (!keepState); i++) {
		pRc->state[i].per       = 0;
  908624:	d960      	mov.n	a9, a6

	/* Initial rate table size. Will change depending on the working rate set */
	pRc->rateTableSize = MAX_TX_RATE_TBL;

	/* Initialize thresholds according to the global rate table */
	for (i = 0 ; (i < pRc->rateTableSize) && (!keepState); i++) {
  908626:	c376      	movi.n	a7, 54
 *  (e.g. SME operation, wireless mode change)
 *
 *  It will determine which rates are valid for use.
 */
static void
rcSibUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an,
  908628:	a638      	add.n	a8, a3, a6
	/* Initial rate table size. Will change depending on the working rate set */
	pRc->rateTableSize = MAX_TX_RATE_TBL;

	/* Initialize thresholds according to the global rate table */
	for (i = 0 ; (i < pRc->rateTableSize) && (!keepState); i++) {
		pRc->state[i].per       = 0;
  90862a:	298400        	s8i	a9, a8, 0
  90862d:	b166      	addi.n	a6, a6, 1

	/* Initial rate table size. Will change depending on the working rate set */
	pRc->rateTableSize = MAX_TX_RATE_TBL;

	/* Initialize thresholds according to the global rate table */
	for (i = 0 ; (i < pRc->rateTableSize) && (!keepState); i++) {
  90862f:	7769f5        	bne	a6, a7, 908628 <rcSibUpdate_ht$constprop$9+0x1c>
  908632:	d730      	mov.n	a7, a3
rcInitValidTxMask(TX_RATE_CTRL *pRc)
{
	A_UINT8 i;

	for (i = 0; i < pRc->rateTableSize; i++) {
		pRc->validRateIndex[i] = FALSE;
  908634:	c080      	movi.n	a8, 0
  908636:	b066      	addi.n	a6, a6, -1
  908638:	287442        	s8i	a8, a7, 66
  90863b:	060647        	extui	a6, a6, 0, 8
  90863e:	b177      	addi.n	a7, a7, 1
static void
rcInitValidTxMask(TX_RATE_CTRL *pRc)
{
	A_UINT8 i;

	for (i = 0; i < pRc->rateTableSize; i++) {
  908640:	656ff2        	bnez	a6, 908636 <rcSibUpdate_ht$constprop$9+0x2a>
  908643:	2116aa        	s32i	a1, a1, 0x2a8
  908646:	d810      	mov.n	a8, a1
	/* Determine the valid rates */
	rcInitValidTxMask(pRc);

	for (i = 0; i < WLAN_RC_PHY_MAX; i++) {
		for (j = 0; j < MAX_TX_RATE_TBL; j++) {
			mPhyCtrlState.validPhyRateIndex[i][j] = 0;
  908648:	d960      	mov.n	a9, a6

	/* Determine the valid rates */
	rcInitValidTxMask(pRc);

	for (i = 0; i < WLAN_RC_PHY_MAX; i++) {
		for (j = 0; j < MAX_TX_RATE_TBL; j++) {
  90864a:	c3a6      	movi.n	a10, 54
			mPhyCtrlState.validPhyRateIndex[i][j] = 0;
  90864c:	db60      	mov.n	a11, a6
  90864e:	600016        	j	908668 <rcSibUpdate_ht$constprop$9+0x5c>
 *  (e.g. SME operation, wireless mode change)
 *
 *  It will determine which rates are valid for use.
 */
static void
rcSibUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an,
  908651:	a78c      	add.n	a12, a8, a7
	/* Determine the valid rates */
	rcInitValidTxMask(pRc);

	for (i = 0; i < WLAN_RC_PHY_MAX; i++) {
		for (j = 0; j < MAX_TX_RATE_TBL; j++) {
			mPhyCtrlState.validPhyRateIndex[i][j] = 0;
  908653:	29c40c        	s8i	a9, a12, 12
  908656:	b177      	addi.n	a7, a7, 1

	/* Determine the valid rates */
	rcInitValidTxMask(pRc);

	for (i = 0; i < WLAN_RC_PHY_MAX; i++) {
		for (j = 0; j < MAX_TX_RATE_TBL; j++) {
  908658:	7a79f5        	bne	a7, a10, 908651 <rcSibUpdate_ht$constprop$9+0x45>
 *  (e.g. SME operation, wireless mode change)
 *
 *  It will determine which rates are valid for use.
 */
static void
rcSibUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an,
  90865b:	a617      	add.n	a7, a1, a6

	for (i = 0; i < WLAN_RC_PHY_MAX; i++) {
		for (j = 0; j < MAX_TX_RATE_TBL; j++) {
			mPhyCtrlState.validPhyRateIndex[i][j] = 0;
		}   
		mPhyCtrlState.validPhyRateCount[i] = 0;
  90865d:	2b7400        	s8i	a11, a7, 0
  908660:	b166      	addi.n	a6, a6, 1
  908662:	288c36        	addi	a8, a8, 54
	}

	/* Determine the valid rates */
	rcInitValidTxMask(pRc);

	for (i = 0; i < WLAN_RC_PHY_MAX; i++) {
  908665:	686a04        	beqi	a6, 12, 90866d <rcSibUpdate_ht$constprop$9+0x61>

	/* Initial rate table size. Will change depending on the working rate set */
	pRc->rateTableSize = MAX_TX_RATE_TBL;

	/* Initialize thresholds according to the global rate table */
	for (i = 0 ; (i < pRc->rateTableSize) && (!keepState); i++) {
  908668:	c070      	movi.n	a7, 0
  90866a:	63ffe3        	j	908651 <rcSibUpdate_ht$constprop$9+0x45>
			mPhyCtrlState.validPhyRateIndex[i][j] = 0;
		}   
		mPhyCtrlState.validPhyRateCount[i] = 0;
	}

	pRc->rcPhyMode = (capflag & WLAN_RC_40_FLAG);
  90866d:	c062      	movi.n	a6, 2
  90866f:	064801        	and	a8, a4, a6
  908672:	040f40        	extui	a15, a4, 0, 1
  908675:	2816a8        	s32i	a8, a1, 0x2a0
  908678:	28347c        	s8i	a8, a3, 124
  90867b:	2f16ab        	s32i	a15, a1, 0x2ac

	if (pRateSet == NULL || !pRateSet->rates.rs_nrates) {
  90867e:	c854      	beqz.n	a5, 908686 <rcSibUpdate_ht$constprop$9+0x7a>
  908680:	275000        	l8ui	a7, a5, 0
  908683:	657069        	bnez	a7, 9086f0 <rcSibUpdate_ht$constprop$9+0xe4>
static A_UINT8 rcSibInitValidRates(const RATE_TABLE_11N *pRateTable,
				   TX_RATE_CTRL *pRc,
				   A_UINT32 capflag,
				   PHY_STATE_CTRL *pPhyStateCtrl)
{
	A_UINT8 i, hi = 0;
  908686:	c060      	movi.n	a6, 0
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT8 valid;
    
	for (i = 0; i < pRateTable->rateCount; i++) {
  908688:	d560      	mov.n	a5, a6
  90868a:	600058        	j	9086e6 <rcSibUpdate_ht$constprop$9+0xda>
  90868d:	0e5711        	slli	a7, a5, 2
		if (singleStream) {
  908690:	2812ab        	l32i	a8, a1, 0x2ac
			valid = pRateTable->info[i].validSingleStream;
  908693:	a577      	add.n	a7, a7, a5
  908695:	02770b        	addx8	a7, a7, a2
	A_UINT8 i, hi = 0;
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT8 valid;
    
	for (i = 0; i < pRateTable->rateCount; i++) {
		if (singleStream) {
  908698:	cc85      	bnez.n	a8, 9086a1 <rcSibUpdate_ht$constprop$9+0x95>
			valid = pRateTable->info[i].validSingleStream;
  90869a:	28700b        	l8ui	a8, a7, 11
  90869d:	600003        	j	9086a4 <rcSibUpdate_ht$constprop$9+0x98>
  9086a0:	002870        	excw
		} else {
			valid = pRateTable->info[i].valid;
  9086a3:	076981        	excw
		}
            
		if (valid == TRUE) {
  9086a6:	390557        	excw
			A_UINT32 phy = pRateTable->info[i].phy;
  9086a9:	0a0277        	excw
  9086ac:	0b2770        	excw
  9086af:	0cdb40        	extui	a11, a12, 13, 1

			if (!rcIsValidPhyRate(phy, capflag, FALSE)) 
  9086b2:	da70      	mov.n	a10, a7
  9086b4:	c0c0      	movi.n	a12, 0
  9086b6:	2816b1        	s32i	a8, a1, 0x2c4
  9086b9:	5bff17        	call8	908318 <rcIsValidPhyRate>
  9086bc:	2812b1        	l32i	a8, a1, 0x2c4
  9086bf:	c9ae      	beqz.n	a10, 9086e1 <rcSibUpdate_ht$constprop$9+0xd5>
				continue;

			pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = i;
  9086c1:	a719      	add.n	a9, a1, a7
  9086c3:	2a9000        	l8ui	a10, a9, 0
  9086c6:	077709        	addx2	a7, a7, a7
  9086c9:	07770b        	addx8	a7, a7, a7
  9086cc:	0a7709        	addx2	a7, a7, a10
  9086cf:	a717      	add.n	a7, a1, a7
  9086d1:	25740c        	s8i	a5, a7, 12
			pPhyStateCtrl->validPhyRateCount[phy] += 1;
  9086d4:	b1aa      	addi.n	a10, a10, 1

static INLINE void
rcSetValidTxMask(TX_RATE_CTRL *pRc, A_UINT8 index, A_BOOL validTxRate)
{
	ASSERT(index < pRc->rateTableSize);
	pRc->validRateIndex[index] = validTxRate ? TRUE : FALSE;
  9086d6:	a537      	add.n	a7, a3, a5

			if (!rcIsValidPhyRate(phy, capflag, FALSE)) 
				continue;

			pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = i;
			pPhyStateCtrl->validPhyRateCount[phy] += 1;
  9086d8:	2a9400        	s8i	a10, a9, 0

static INLINE void
rcSetValidTxMask(TX_RATE_CTRL *pRc, A_UINT8 index, A_BOOL validTxRate)
{
	ASSERT(index < pRc->rateTableSize);
	pRc->validRateIndex[index] = validTxRate ? TRUE : FALSE;
  9086db:	287442        	s8i	a8, a7, 66
			pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = i;
			pPhyStateCtrl->validPhyRateCount[phy] += 1;

			rcSetValidTxMask(pRc, i, TRUE);

			hi = A_MAX(hi, i);
  9086de:	056637        	maxu	a6, a6, a5
{
	A_UINT8 i, hi = 0;
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT8 valid;
    
	for (i = 0; i < pRateTable->rateCount; i++) {
  9086e1:	b155      	addi.n	a5, a5, 1
  9086e3:	050547        	extui	a5, a5, 0, 8
  9086e6:	272000        	l8ui	a7, a2, 0
  9086e9:	7753a0        	bltu	a5, a7, 90868d <rcSibUpdate_ht$constprop$9+0x81>
  9086ec:	6001aa        	j	90889a <rcSibUpdate_ht$constprop$9+0x28e>
  9086ef:	00c0f0        	excw
                   struct ieee80211_rateset *pRateSet,
		   A_UINT32 capflag,
		   struct ath_node_target *an,
		   PHY_STATE_CTRL *pPhyStateCtrl)
{
	A_UINT8 i, j, hi = 0;
  9086f2:	2f16a9        	s32i	a15, a1, 0x2a4
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT32 valid;
       
	/* Use intersection of working rates and valid rates */
	for (i = 0; i < pRateSet->rs_nrates; i++) {
  9086f5:	d8f0      	mov.n	a8, a15
			 * the validity (TRUE/TRUE_20/TRUE_40) flags
			 */

			if (((pRateSet->rs_rates[i] & 0x7F) == 
			     (pRateTable->info[j].dot11Rate & 0x7F))
			    && ((valid & WLAN_RC_CAP_MODE(capflag)) == 
  9086f7:	2f12a8        	l32i	a15, a1, 0x2a0
  9086fa:	c0d8      	movi.n	a13, 8
  9086fc:	c094      	movi.n	a9, 4
  9086fe:	0d4d01        	and	a13, a4, a13

static INLINE void
rcSetValidTxMask(TX_RATE_CTRL *pRc, A_UINT8 index, A_BOOL validTxRate)
{
	ASSERT(index < pRc->rateTableSize);
	pRc->validRateIndex[index] = validTxRate ? TRUE : FALSE;
  908701:	c0e1      	movi.n	a14, 1
			 * the validity (TRUE/TRUE_20/TRUE_40) flags
			 */

			if (((pRateSet->rs_rates[i] & 0x7F) == 
			     (pRateTable->info[j].dot11Rate & 0x7F))
			    && ((valid & WLAN_RC_CAP_MODE(capflag)) == 
  908703:	0f6938        	moveqz	a9, a6, a15
  908706:	6000aa        	j	9087b4 <rcSibUpdate_ht$constprop$9+0x1a8>
	A_UINT32 valid;
       
	/* Use intersection of working rates and valid rates */
	for (i = 0; i < pRateSet->rs_nrates; i++) {
		for (j = 0; j < pRateTable->rateCount; j++) {
			A_UINT32 phy = pRateTable->info[j].phy;
  908709:	066a0a        	addx4	a10, a6, a6

			if (pSib->stbc) {
				valid = pRateTable->info[j].validSTBC;
			} else if (singleStream) {
#else
			if (singleStream) {
  90870c:	2b12ab        	l32i	a11, a1, 0x2ac
	A_UINT32 valid;
       
	/* Use intersection of working rates and valid rates */
	for (i = 0; i < pRateSet->rs_nrates; i++) {
		for (j = 0; j < pRateTable->rateCount; j++) {
			A_UINT32 phy = pRateTable->info[j].phy;
  90870f:	02aa0b        	addx8	a10, a10, a2
  908712:	27a00c        	l8ui	a7, a10, 12

			if (pSib->stbc) {
				valid = pRateTable->info[j].validSTBC;
			} else if (singleStream) {
#else
			if (singleStream) {
  908715:	ccb5      	bnez.n	a11, 90871e <rcSibUpdate_ht$constprop$9+0x112>
#endif            
				valid = pRateTable->info[j].validSingleStream;
  908717:	8ba2      	l32i.n	a11, a10, 8
  908719:	600003        	j	908720 <rcSibUpdate_ht$constprop$9+0x114>
  90871c:	00008b        	excw
			} else {
				valid = pRateTable->info[j].valid;
  90871f:	a106      	add.n	a6, a0, a1
			 * We allow a rate only if its valid and the capflag matches one of
			 * the validity (TRUE/TRUE_20/TRUE_40) flags
			 */

			if (((pRateSet->rs_rates[i] & 0x7F) == 
			     (pRateTable->info[j].dot11Rate & 0x7F))
  908721:	6a0a02        	blti	a0, 12, 908727 <rcSibUpdate_ht$constprop$9+0x11b>
  908724:	aa0b      	add.n	a11, a0, a10
			/*
			 * We allow a rate only if its valid and the capflag matches one of
			 * the validity (TRUE/TRUE_20/TRUE_40) flags
			 */

			if (((pRateSet->rs_rates[i] & 0x7F) == 
  908726:	2cf000        	l8ui	a12, a15, 0
  908729:	2aa01a        	l8ui	a10, a10, 26
  90872c:	0aca03        	xor	a10, a12, a10
  90872f:	0a0a46        	extui	a10, a10, 0, 7
  908732:	65a062        	bnez	a10, 908798 <rcSibUpdate_ht$constprop$9+0x18c>
			     (pRateTable->info[j].dot11Rate & 0x7F))
			    && ((valid & WLAN_RC_CAP_MODE(capflag)) == 
  908735:	c0a1      	movi.n	a10, 1
  908737:	0d9a39        	movnez	a10, a9, a13
  90873a:	0bab01        	and	a11, a10, a11
  90873d:	c0a1      	movi.n	a10, 1
  90873f:	0d9a39        	movnez	a10, a9, a13
  908742:	7ab952        	bne	a11, a10, 908798 <rcSibUpdate_ht$constprop$9+0x18c>
				WLAN_RC_CAP_MODE(capflag)) && !WLAN_RC_PHY_HT(phy)) {
  908745:	6f744f        	bgeui	a7, 4, 908798 <rcSibUpdate_ht$constprop$9+0x18c>
				if (!rcIsValidPhyRate(phy, capflag, FALSE)) 
  908748:	da70      	mov.n	a10, a7
  90874a:	db40      	mov.n	a11, a4
  90874c:	2c0a00        	movi	a12, 0
  90874f:	2816b1        	s32i	a8, a1, 0x2c4
  908752:	2916b0        	s32i	a9, a1, 0x2c0
  908755:	2d16ae        	s32i	a13, a1, 0x2b8
  908758:	2e16af        	s32i	a14, a1, 0x2bc
  90875b:	2f16ad        	s32i	a15, a1, 0x2b4
  90875e:	5bfeee        	call8	908318 <rcIsValidPhyRate>
  908761:	2812b1        	l32i	a8, a1, 0x2c4
  908764:	2912b0        	l32i	a9, a1, 0x2c0
  908767:	2d12ae        	l32i	a13, a1, 0x2b8
  90876a:	2e12af        	l32i	a14, a1, 0x2bc
  90876d:	2f12ad        	l32i	a15, a1, 0x2b4
  908770:	caa4      	beqz.n	a10, 908798 <rcSibUpdate_ht$constprop$9+0x18c>
					continue;

				pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = j;
  908772:	a71a      	add.n	a10, a1, a7
  908774:	2ba000        	l8ui	a11, a10, 0
  908777:	077709        	addx2	a7, a7, a7
  90877a:	07770b        	addx8	a7, a7, a7
  90877d:	0b7709        	addx2	a7, a7, a11
				pPhyStateCtrl->validPhyRateCount[phy] += 1;
  908780:	b1bb      	addi.n	a11, a11, 1
  908782:	2ba400        	s8i	a11, a10, 0

				rcSetValidTxMask(pRc, j, TRUE);
				hi = A_MAX(hi, j);
  908785:	2a12a9        	l32i	a10, a1, 0x2a4
			    && ((valid & WLAN_RC_CAP_MODE(capflag)) == 
				WLAN_RC_CAP_MODE(capflag)) && !WLAN_RC_PHY_HT(phy)) {
				if (!rcIsValidPhyRate(phy, capflag, FALSE)) 
					continue;

				pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = j;
  908788:	a717      	add.n	a7, a1, a7
  90878a:	26740c        	s8i	a6, a7, 12
				pPhyStateCtrl->validPhyRateCount[phy] += 1;

				rcSetValidTxMask(pRc, j, TRUE);
				hi = A_MAX(hi, j);
  90878d:	06aa37        	maxu	a10, a10, a6

static INLINE void
rcSetValidTxMask(TX_RATE_CTRL *pRc, A_UINT8 index, A_BOOL validTxRate)
{
	ASSERT(index < pRc->rateTableSize);
	pRc->validRateIndex[index] = validTxRate ? TRUE : FALSE;
  908790:	a637      	add.n	a7, a3, a6
  908792:	2e7442        	s8i	a14, a7, 66

				pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = j;
				pPhyStateCtrl->validPhyRateCount[phy] += 1;

				rcSetValidTxMask(pRc, j, TRUE);
				hi = A_MAX(hi, j);
  908795:	2a16a9        	s32i	a10, a1, 0x2a4
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT32 valid;
       
	/* Use intersection of working rates and valid rates */
	for (i = 0; i < pRateSet->rs_nrates; i++) {
		for (j = 0; j < pRateTable->rateCount; j++) {
  908798:	b166      	addi.n	a6, a6, 1
  90879a:	060647        	extui	a6, a6, 0, 8
  90879d:	600005        	j	9087a6 <rcSibUpdate_ht$constprop$9+0x19a>
			/*
			 * We allow a rate only if its valid and the capflag matches one of
			 * the validity (TRUE/TRUE_20/TRUE_40) flags
			 */

			if (((pRateSet->rs_rates[i] & 0x7F) == 
  9087a0:	a85f      	add.n	a15, a5, a8
	A_UINT8 i, j, hi = 0;
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT32 valid;
       
	/* Use intersection of working rates and valid rates */
	for (i = 0; i < pRateSet->rs_nrates; i++) {
  9087a2:	c060      	movi.n	a6, 0
			/*
			 * We allow a rate only if its valid and the capflag matches one of
			 * the validity (TRUE/TRUE_20/TRUE_40) flags
			 */

			if (((pRateSet->rs_rates[i] & 0x7F) == 
  9087a4:	b1ff      	addi.n	a15, a15, 1
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT32 valid;
       
	/* Use intersection of working rates and valid rates */
	for (i = 0; i < pRateSet->rs_nrates; i++) {
		for (j = 0; j < pRateTable->rateCount; j++) {
  9087a6:	272000        	l8ui	a7, a2, 0
  9087a9:	776b02        	bgeu	a6, a7, 9087af <rcSibUpdate_ht$constprop$9+0x1a3>
  9087ac:	63ff59        	j	908709 <rcSibUpdate_ht$constprop$9+0xfd>
	A_UINT8 i, j, hi = 0;
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT32 valid;
       
	/* Use intersection of working rates and valid rates */
	for (i = 0; i < pRateSet->rs_nrates; i++) {
  9087af:	b188      	addi.n	a8, a8, 1
  9087b1:	080847        	extui	a8, a8, 0, 8
  9087b4:	265000        	l8ui	a6, a5, 0
  9087b7:	7683e5        	bltu	a8, a6, 9087a0 <rcSibUpdate_ht$constprop$9+0x194>
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	A_UINT8 *phtMcs = (A_UINT8*)&pRateSet->htrates;
	TX_RATE_CTRL *pRc = (TX_RATE_CTRL *)(pSib);
	PHY_STATE_CTRL mPhyCtrlState;  

	A_UINT8 i, j, k, hi = 0, htHi = 0;
  9087ba:	c080      	movi.n	a8, 0
	} else {
		/* Use intersection of working rates and valid rates */
		hi = rcSibSetValidRates(pRateTable, pRc, &(pRateSet->rates),
					capflag, an, &mPhyCtrlState);

		if (capflag & WLAN_RC_HT_FLAG) {
  9087bc:	7c4f02        	bbsi	a4, 28, 9087c2 <rcSibUpdate_ht$constprop$9+0x1b6>
  9087bf:	6000d1        	j	908894 <rcSibUpdate_ht$constprop$9+0x288>
	       A_UINT32 capflag, A_BOOL keepState, struct ieee80211_rate  *pRateSet)
{
	RATE_TABLE_11N *pRateTable = 0;
	struct atheros_node *pSib = ATH_NODE_ATHEROS(an);
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	A_UINT8 *phtMcs = (A_UINT8*)&pRateSet->htrates;
  9087c2:	2e5c1f        	addi	a14, a5, 31
			     != (pRateTable->info[j].dot11Rate & 0x7F)) 
			    || !WLAN_RC_PHY_HT(phy) 
			    || !WLAN_RC_PHY_HT_VALID(valid, capflag)
			    || ((pRateTable->info[j].dot11Rate == 15) && 
				(valid & TRUE_20) && 
				(capflag & WLAN_RC_WEP_TKIP_FLAG)) )
  9087c5:	251a00        	movi	a5, 0x100
  9087c8:	054501        	and	a5, a4, a5
	       A_UINT32 capflag, A_BOOL keepState, struct ieee80211_rate  *pRateSet)
{
	RATE_TABLE_11N *pRateTable = 0;
	struct atheros_node *pSib = ATH_NODE_ATHEROS(an);
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	A_UINT8 *phtMcs = (A_UINT8*)&pRateSet->htrates;
  9087cb:	d780      	mov.n	a7, a8
			     != (pRateTable->info[j].dot11Rate & 0x7F)) 
			    || !WLAN_RC_PHY_HT(phy) 
			    || !WLAN_RC_PHY_HT_VALID(valid, capflag)
			    || ((pRateTable->info[j].dot11Rate == 15) && 
				(valid & TRUE_20) && 
				(capflag & WLAN_RC_WEP_TKIP_FLAG)) )
  9087cd:	2516ac        	s32i	a5, a1, 0x2b0
                           
			if (((((struct ieee80211_rateset *)pMcsSet)->rs_rates[i] & 0x7F) 
			     != (pRateTable->info[j].dot11Rate & 0x7F)) 
			    || !WLAN_RC_PHY_HT(phy) 
			    || !WLAN_RC_PHY_HT_VALID(valid, capflag)
			    || ((pRateTable->info[j].dot11Rate == 15) && 
  9087d0:	c09f      	movi.n	a9, 15
  9087d2:	6000b8        	j	90888e <rcSibUpdate_ht$constprop$9+0x282>
	A_UINT8 valid;
    
	/* Use intersection of working rates and valid rates */
	for (i = 0; i <  ((struct ieee80211_rateset *)pMcsSet)->rs_nrates; i++) {
		for (j = 0; j < pRateTable->rateCount; j++) {
			A_UINT32 phy = pRateTable->info[j].phy;
  9087d5:	0e5c11        	slli	a12, a5, 2
  9087d8:	a5ca      	add.n	a10, a12, a5

			if (pSib->stbc) {
				valid = pRateTable->info[j].validSTBC;
			} else if (singleStream) {
#else
			if (singleStream) {
  9087da:	2f12ab        	l32i	a15, a1, 0x2ac
	A_UINT8 valid;
    
	/* Use intersection of working rates and valid rates */
	for (i = 0; i <  ((struct ieee80211_rateset *)pMcsSet)->rs_nrates; i++) {
		for (j = 0; j < pRateTable->rateCount; j++) {
			A_UINT32 phy = pRateTable->info[j].phy;
  9087dd:	02aa0b        	addx8	a10, a10, a2
  9087e0:	26a00c        	l8ui	a6, a10, 12

			if (pSib->stbc) {
				valid = pRateTable->info[j].validSTBC;
			} else if (singleStream) {
#else
			if (singleStream) {
  9087e3:	ccf6      	bnez.n	a15, 9087ed <rcSibUpdate_ht$constprop$9+0x1e1>
#endif
				valid = pRateTable->info[j].validSingleStream;
  9087e5:	2ba00b        	l8ui	a11, a10, 11
  9087e8:	600004        	j	9087f0 <rcSibUpdate_ht$constprop$9+0x1e4>
  9087eb:	00002b        	mulsh	a0, a0, a0
			} else {
				valid = pRateTable->info[j].valid;
  9087ee:	a007      	add.n	a7, a0, a0
			}
                           
			if (((((struct ieee80211_rateset *)pMcsSet)->rs_rates[i] & 0x7F) 
			     != (pRateTable->info[j].dot11Rate & 0x7F)) 
  9087f0:	a5cc      	add.n	a12, a12, a5
  9087f2:	02cc0b        	addx8	a12, a12, a2
  9087f5:	2ac01a        	l8ui	a10, a12, 26
  9087f8:	2cd000        	l8ui	a12, a13, 0
  9087fb:	0cac03        	xor	a12, a10, a12
				valid = pRateTable->info[j].validSingleStream;
			} else {
				valid = pRateTable->info[j].valid;
			}
                           
			if (((((struct ieee80211_rateset *)pMcsSet)->rs_rates[i] & 0x7F) 
  9087fe:	0c0c46        	extui	a12, a12, 0, 7
  908801:	65c06b        	bnez	a12, 908870 <rcSibUpdate_ht$constprop$9+0x264>
			     != (pRateTable->info[j].dot11Rate & 0x7F)) 
			    || !WLAN_RC_PHY_HT(phy) 
  908804:	6e6468        	bltui	a6, 4, 908870 <rcSibUpdate_ht$constprop$9+0x264>
			    || !WLAN_RC_PHY_HT_VALID(valid, capflag)
  908807:	c0f2      	movi.n	a15, 2
  908809:	0fbc01        	and	a12, a11, a15
  90880c:	c8c4      	beqz.n	a12, 908814 <rcSibUpdate_ht$constprop$9+0x208>
  90880e:	2f12a8        	l32i	a15, a1, 0x2a0
  908811:	64f13f        	beqz	a15, 908954 <rcSibUpdate_ht$constprop$9+0x348>
  908814:	c0f4      	movi.n	a15, 4
  908816:	7fb056        	bnone	a11, a15, 908870 <rcSibUpdate_ht$constprop$9+0x264>
  908819:	2f12a8        	l32i	a15, a1, 0x2a0
  90881c:	64f050        	beqz	a15, 908870 <rcSibUpdate_ht$constprop$9+0x264>
			    || ((pRateTable->info[j].dot11Rate == 15) && 
  90881f:	79a907        	bne	a10, a9, 90882a <rcSibUpdate_ht$constprop$9+0x21e>
  908822:	c8c4      	beqz.n	a12, 90882a <rcSibUpdate_ht$constprop$9+0x21e>
				(valid & TRUE_20) && 
  908824:	2f12ac        	l32i	a15, a1, 0x2b0
  908827:	65f045        	bnez	a15, 908870 <rcSibUpdate_ht$constprop$9+0x264>
				(capflag & WLAN_RC_WEP_TKIP_FLAG)) )
			{
				continue;
			}
    
			if (!rcIsValidPhyRate(phy, capflag, FALSE)) 
  90882a:	da60      	mov.n	a10, a6
  90882c:	db40      	mov.n	a11, a4
  90882e:	2c0a00        	movi	a12, 0
  908831:	2816b1        	s32i	a8, a1, 0x2c4
  908834:	2916b0        	s32i	a9, a1, 0x2c0
  908837:	2d16ae        	s32i	a13, a1, 0x2b8
  90883a:	2e16af        	s32i	a14, a1, 0x2bc
  90883d:	5bfeb6        	call8	908318 <rcIsValidPhyRate>
  908840:	2812b1        	l32i	a8, a1, 0x2c4
  908843:	2912b0        	l32i	a9, a1, 0x2c0
  908846:	2d12ae        	l32i	a13, a1, 0x2b8
  908849:	2e12af        	l32i	a14, a1, 0x2bc
  90884c:	caa0      	beqz.n	a10, 908870 <rcSibUpdate_ht$constprop$9+0x264>
				continue;
    
			pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = j;
  90884e:	a61a      	add.n	a10, a1, a6
  908850:	2ba000        	l8ui	a11, a10, 0
  908853:	066609        	addx2	a6, a6, a6
  908856:	06660b        	addx8	a6, a6, a6
  908859:	0b6609        	addx2	a6, a6, a11
  90885c:	a616      	add.n	a6, a1, a6
			pPhyStateCtrl->validPhyRateCount[phy] += 1;
  90885e:	b1bb      	addi.n	a11, a11, 1
			}
    
			if (!rcIsValidPhyRate(phy, capflag, FALSE)) 
				continue;
    
			pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = j;
  908860:	25640c        	s8i	a5, a6, 12
			pPhyStateCtrl->validPhyRateCount[phy] += 1;
  908863:	2ba400        	s8i	a11, a10, 0

static INLINE void
rcSetValidTxMask(TX_RATE_CTRL *pRc, A_UINT8 index, A_BOOL validTxRate)
{
	ASSERT(index < pRc->rateTableSize);
	pRc->validRateIndex[index] = validTxRate ? TRUE : FALSE;
  908866:	a536      	add.n	a6, a3, a5
  908868:	c0a1      	movi.n	a10, 1
  90886a:	2a6442        	s8i	a10, a6, 66
    
			pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = j;
			pPhyStateCtrl->validPhyRateCount[phy] += 1;

			rcSetValidTxMask(pRc, j, TRUE);
			hi = A_MAX(hi, j);
  90886d:	058837        	maxu	a8, a8, a5
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT8 valid;
    
	/* Use intersection of working rates and valid rates */
	for (i = 0; i <  ((struct ieee80211_rateset *)pMcsSet)->rs_nrates; i++) {
		for (j = 0; j < pRateTable->rateCount; j++) {
  908870:	b155      	addi.n	a5, a5, 1
  908872:	050547        	extui	a5, a5, 0, 8
  908875:	600007        	j	908880 <rcSibUpdate_ht$constprop$9+0x274>
  908878:	0000a7        	excw
				valid = pRateTable->info[j].validSingleStream;
			} else {
				valid = pRateTable->info[j].valid;
			}
                           
			if (((((struct ieee80211_rateset *)pMcsSet)->rs_rates[i] & 0x7F) 
  90887b:	ed          	.byte 0xed
	A_UINT8 i, j, hi = 0;
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT8 valid;
    
	/* Use intersection of working rates and valid rates */
	for (i = 0; i <  ((struct ieee80211_rateset *)pMcsSet)->rs_nrates; i++) {
  90887c:	c050      	movi.n	a5, 0
				valid = pRateTable->info[j].validSingleStream;
			} else {
				valid = pRateTable->info[j].valid;
			}
                           
			if (((((struct ieee80211_rateset *)pMcsSet)->rs_rates[i] & 0x7F) 
  90887e:	b1dd      	addi.n	a13, a13, 1
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT8 valid;
    
	/* Use intersection of working rates and valid rates */
	for (i = 0; i <  ((struct ieee80211_rateset *)pMcsSet)->rs_nrates; i++) {
		for (j = 0; j < pRateTable->rateCount; j++) {
  908880:	262000        	l8ui	a6, a2, 0
  908883:	765b02        	bgeu	a5, a6, 908889 <rcSibUpdate_ht$constprop$9+0x27d>
  908886:	63ff4b        	j	9087d5 <rcSibUpdate_ht$constprop$9+0x1c9>
	A_UINT8 i, j, hi = 0;
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT8 valid;
    
	/* Use intersection of working rates and valid rates */
	for (i = 0; i <  ((struct ieee80211_rateset *)pMcsSet)->rs_nrates; i++) {
  908889:	b177      	addi.n	a7, a7, 1
  90888b:	070747        	extui	a7, a7, 0, 8
  90888e:	25e000        	l8ui	a5, a14, 0
  908891:	7573e5        	bltu	a7, a5, 90887a <rcSibUpdate_ht$constprop$9+0x26e>
		if (capflag & WLAN_RC_HT_FLAG) {
			htHi = rcSibSetValidHtRates(pRateTable, pRc, phtMcs,
						    capflag, an, &mPhyCtrlState);
		}

		hi = A_MAX(hi, htHi);
  908894:	2f12a9        	l32i	a15, a1, 0x2a4
  908897:	0f8637        	maxu	a6, a8, a15
	}

	pRc->rateTableSize = hi + 1;
	pRc->rateMaxPhy    = 0;
  90889a:	c040      	movi.n	a4, 0
		}

		hi = A_MAX(hi, htHi);
	}

	pRc->rateTableSize = hi + 1;
  90889c:	b166      	addi.n	a6, a6, 1
	pRc->rateMaxPhy    = 0;
  90889e:	24347d        	s8i	a4, a3, 125
  9088a1:	c040      	movi.n	a4, 0
		}

		hi = A_MAX(hi, htHi);
	}

	pRc->rateTableSize = hi + 1;
  9088a3:	263436        	s8i	a6, a3, 54
	pRc->rateMaxPhy    = 0;
    
	ASSERT(pRc->rateTableSize <= MAX_TX_RATE_TBL);

	for (i = 0, k = 0; i < WLAN_RC_PHY_MAX; i++) {
  9088a6:	d540      	mov.n	a5, a4
  9088a8:	60004e        	j	9088fa <rcSibUpdate_ht$constprop$9+0x2ee>
  9088ab:	002f12        	srai	a15, a0, 2
 *  (e.g. SME operation, wireless mode change)
 *
 *  It will determine which rates are valid for use.
 */
static void
rcSibUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an,
  9088ae:	aaa9      	add.n	a9, a10, a10
    
	ASSERT(pRc->rateTableSize <= MAX_TX_RATE_TBL);

	for (i = 0, k = 0; i < WLAN_RC_PHY_MAX; i++) {
		for (j = 0; j < mPhyCtrlState.validPhyRateCount[i]; j++) {
			pRc->validRateIndex[k++] = mPhyCtrlState.validPhyRateIndex[i][j];
  9088b0:	39a7f8        	excw
  9088b3:	28800c        	l8ui	a8, a8, 12
  9088b6:	b177      	addi.n	a7, a7, 1
  9088b8:	289442        	s8i	a8, a9, 66
 *  (e.g. SME operation, wireless mode change)
 *
 *  It will determine which rates are valid for use.
 */
static void
rcSibUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an,
  9088bb:	070847        	extui	a8, a7, 0, 8
  9088be:	a589      	add.n	a9, a8, a5
  9088c0:	090947        	extui	a9, a9, 0, 8
	pRc->rateMaxPhy    = 0;
    
	ASSERT(pRc->rateTableSize <= MAX_TX_RATE_TBL);

	for (i = 0, k = 0; i < WLAN_RC_PHY_MAX; i++) {
		for (j = 0; j < mPhyCtrlState.validPhyRateCount[i]; j++) {
  9088c3:	7683e5        	bltu	a8, a6, 9088ac <rcSibUpdate_ht$constprop$9+0x2a0>
			pRc->validRateIndex[k++] = mPhyCtrlState.validPhyRateIndex[i][j];
		}   

		if (!rcIsValidPhyRate(i, pRateTable->initialRateMax, TRUE) ||
  9088c6:	2b2003        	l8ui	a11, a2, 3
  9088c9:	a565      	add.n	a5, a6, a5
  9088cb:	da40      	mov.n	a10, a4
  9088cd:	c0c1      	movi.n	a12, 1
  9088cf:	050547        	extui	a5, a5, 0, 8
  9088d2:	5bfe91        	call8	908318 <rcIsValidPhyRate>
  9088d5:	c9a3      	beqz.n	a10, 9088ec <rcSibUpdate_ht$constprop$9+0x2e0>
  9088d7:	646011        	beqz	a6, 9088ec <rcSibUpdate_ht$constprop$9+0x2e0>
		    !mPhyCtrlState.validPhyRateCount[i]) 
			continue;

		pRc->rateMaxPhy = mPhyCtrlState.validPhyRateIndex[i][j-1];	
  9088da:	044709        	addx2	a7, a4, a4
  9088dd:	07770b        	addx8	a7, a7, a7
  9088e0:	017709        	addx2	a7, a7, a1
  9088e3:	067608        	add	a6, a7, a6
  9088e6:	26600b        	l8ui	a6, a6, 11
  9088e9:	26347d        	s8i	a6, a3, 125
  9088ec:	2612aa        	l32i	a6, a1, 0x2a8
  9088ef:	b144      	addi.n	a4, a4, 1
  9088f1:	266c36        	addi	a6, a6, 54
  9088f4:	2616aa        	s32i	a6, a1, 0x2a8
	pRc->rateTableSize = hi + 1;
	pRc->rateMaxPhy    = 0;
    
	ASSERT(pRc->rateTableSize <= MAX_TX_RATE_TBL);

	for (i = 0, k = 0; i < WLAN_RC_PHY_MAX; i++) {
  9088f7:	684a09        	beqi	a4, 12, 908904 <rcSibUpdate_ht$constprop$9+0x2f8>
 *  (e.g. SME operation, wireless mode change)
 *
 *  It will determine which rates are valid for use.
 */
static void
rcSibUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an,
  9088fa:	a416      	add.n	a6, a1, a4
	pRc->rateMaxPhy    = 0;
    
	ASSERT(pRc->rateTableSize <= MAX_TX_RATE_TBL);

	for (i = 0, k = 0; i < WLAN_RC_PHY_MAX; i++) {
		for (j = 0; j < mPhyCtrlState.validPhyRateCount[i]; j++) {
  9088fc:	266000        	l8ui	a6, a6, 0
  9088ff:	c070      	movi.n	a7, 0
  908901:	63ffb6        	j	9088bb <rcSibUpdate_ht$constprop$9+0x2af>
	}
    
	ASSERT(pRc->rateTableSize <= MAX_TX_RATE_TBL);
	ASSERT(k <= MAX_TX_RATE_TBL);

	pRc->rateMaxPhy = pRc->validRateIndex[k-4];
  908904:	a534      	add.n	a4, a3, a5
  908906:	24403e        	l8ui	a4, a4, 62
	pRc->maxValidRate = k;
  908909:	253441        	s8i	a5, a3, 65
	}
    
	ASSERT(pRc->rateTableSize <= MAX_TX_RATE_TBL);
	ASSERT(k <= MAX_TX_RATE_TBL);

	pRc->rateMaxPhy = pRc->validRateIndex[k-4];
  90890c:	24347d        	s8i	a4, a3, 125
  90890f:	600036        	j	908949 <rcSibUpdate_ht$constprop$9+0x33d>
#ifdef MAGPIE_MERLIN      
			if (pRateTable->info[pRc->validRateIndex[j]].rateKbps >
			    pRateTable->info[pRc->validRateIndex[j+1]].rateKbps)
#else
				// K2
				if (pRateTable->info[pRc->validRateIndex[j]].userRateKbps >
  908912:	a439      	add.n	a9, a3, a4
				    pRateTable->info[pRc->validRateIndex[j+1]].userRateKbps)
  908914:	b144      	addi.n	a4, a4, 1
  908916:	a438      	add.n	a8, a3, a4
#ifdef MAGPIE_MERLIN      
			if (pRateTable->info[pRc->validRateIndex[j]].rateKbps >
			    pRateTable->info[pRc->validRateIndex[j+1]].rateKbps)
#else
				// K2
				if (pRateTable->info[pRc->validRateIndex[j]].userRateKbps >
  908918:	269042        	l8ui	a6, a9, 66
				    pRateTable->info[pRc->validRateIndex[j+1]].userRateKbps)
  90891b:	278042        	l8ui	a7, a8, 66
#ifdef MAGPIE_MERLIN      
			if (pRateTable->info[pRc->validRateIndex[j]].rateKbps >
			    pRateTable->info[pRc->validRateIndex[j+1]].rateKbps)
#else
				// K2
				if (pRateTable->info[pRc->validRateIndex[j]].userRateKbps >
  90891e:	066a0a        	addx4	a10, a6, a6
				    pRateTable->info[pRc->validRateIndex[j+1]].userRateKbps)
  908921:	077b0a        	addx4	a11, a7, a7
#ifdef MAGPIE_MERLIN      
			if (pRateTable->info[pRc->validRateIndex[j]].rateKbps >
			    pRateTable->info[pRc->validRateIndex[j+1]].rateKbps)
#else
				// K2
				if (pRateTable->info[pRc->validRateIndex[j]].userRateKbps >
  908924:	02aa0b        	addx8	a10, a10, a2
				    pRateTable->info[pRc->validRateIndex[j+1]].userRateKbps)
  908927:	02bb0b        	addx8	a11, a11, a2
#ifdef MAGPIE_MERLIN      
			if (pRateTable->info[pRc->validRateIndex[j]].rateKbps >
			    pRateTable->info[pRc->validRateIndex[j+1]].rateKbps)
#else
				// K2
				if (pRateTable->info[pRc->validRateIndex[j]].userRateKbps >
  90892a:	8aa5      	l32i.n	a10, a10, 20
  90892c:	8bb5      	l32i.n	a11, a11, 20
  90892e:	299c40        	addi	a9, a9, 64
				    pRateTable->info[pRc->validRateIndex[j+1]].userRateKbps)
  908931:	288c40        	addi	a8, a8, 64
#ifdef MAGPIE_MERLIN      
			if (pRateTable->info[pRc->validRateIndex[j]].rateKbps >
			    pRateTable->info[pRc->validRateIndex[j+1]].rateKbps)
#else
				// K2
				if (pRateTable->info[pRc->validRateIndex[j]].userRateKbps >
  908934:	7abb05        	bgeu	a11, a10, 90893d <rcSibUpdate_ht$constprop$9+0x331>
				    pRateTable->info[pRc->validRateIndex[j+1]].userRateKbps)
#endif
				{
					A_UINT8 tmp=0;
					tmp = pRc->validRateIndex[j];
					pRc->validRateIndex[j] = pRc->validRateIndex[j+1];
  908937:	279402        	s8i	a7, a9, 2
					pRc->validRateIndex[j+1] = tmp;
  90893a:	268402        	s8i	a6, a8, 2
rcSortValidRates(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc)
{
	A_UINT8 i,j;

	for (i=pRc->maxValidRate-1; i > 0; i--) {
		for (j=0; j <= i-1; j++) {
  90893d:	040447        	extui	a4, a4, 0, 8
  908940:	600002        	j	908946 <rcSibUpdate_ht$constprop$9+0x33a>
  908943:	00c040        	extui	a0, a0, 12, 1
  908946:	7542c8        	blt	a4, a5, 908912 <rcSibUpdate_ht$constprop$9+0x306>
static void
rcSortValidRates(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc)
{
	A_UINT8 i,j;

	for (i=pRc->maxValidRate-1; i > 0; i--) {
  908949:	b055      	addi.n	a5, a5, -1
  90894b:	050547        	extui	a5, a5, 0, 8
  90894e:	655ff2        	bnez	a5, 908944 <rcSibUpdate_ht$constprop$9+0x338>
  908951:	d10f      	retw.n
  908953:	0079a1        	excw
                           
			if (((((struct ieee80211_rateset *)pMcsSet)->rs_rates[i] & 0x7F) 
			     != (pRateTable->info[j].dot11Rate & 0x7F)) 
			    || !WLAN_RC_PHY_HT(phy) 
			    || !WLAN_RC_PHY_HT_VALID(valid, capflag)
			    || ((pRateTable->info[j].dot11Rate == 15) && 
  908956:	0263fe        	excw
  908959:	cf63      	bnez.n	a6, 908990 <rcRateFind_11n+0x30>
  90895b:	fe          	.byte 0xfe
  90895c:	c600      	movi.n	a0, -32
	...

00908960 <rcRateFind_11n>:
}

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
		    int numTries, int numRates, int stepDnInc,
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
  908960:	6c100a        	entry	a1, 80
  908963:	9313      	s32i.n	a3, a1, 12
  908965:	9616      	s32i.n	a6, a1, 24
	A_UINT8 i = 0; 
	A_UINT8 tryPerRate  = 0;
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  908967:	232248        	l32i	a3, a2, 0x120
  90896a:	2622c2        	l32i	a6, a2, 0x308
}

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
		    int numTries, int numRates, int stepDnInc,
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
  90896d:	9715      	s32i.n	a7, a1, 20
	A_UINT8 i = 0; 
	A_UINT8 tryPerRate  = 0;
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  90896f:	03630a        	addx4	a3, a6, a3
  908972:	8331      	l32i.n	a3, a3, 4
	struct atheros_node *asn = ATH_NODE_ATHEROS(an);
  908974:	8813      	l32i.n	a8, a1, 12
}

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
		    int numTries, int numRates, int stepDnInc,
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
  908976:	9514      	s32i.n	a5, a1, 16
  908978:	251215        	l32i	a5, a1, 84
	A_INT8               index;
	TX_RATE_CTRL         *pRc = NULL;

	pRc = (TX_RATE_CTRL *)(pSib ? (pSib) : NULL);

	*isProbing = FALSE;
  90897b:	c070      	movi.n	a7, 0
	struct atheros_node *asn = ATH_NODE_ATHEROS(an);
	A_UINT8 rix, nrix;
	A_UINT8 dot11Rate;
	WLAN_PHY phy;

	rix = rcRateFind_ht(sc, asn, pRateTable, (rcflag & ATH_RC_PROBE_ALLOWED) ? 1 : 0, 
  90897d:	8915      	l32i.n	a9, a1, 20
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
	A_UINT8 i = 0; 
	A_UINT8 tryPerRate  = 0;
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  90897f:	9310      	s32i.n	a3, a1, 0
	 *   0msec   <= dt <= 25msec:   don't derate
	 *   25msec  <= dt <= 185msec:  derate linearly from 0 to 10dB
	 *   185msec <= dt:             derate by 10dB
	 */

	nowMsec = A_MS_TICKGET();
  908981:	da70      	mov.n	a10, a7
{
	A_UINT8 i = 0; 
	A_UINT8 tryPerRate  = 0;
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
	struct atheros_node *asn = ATH_NODE_ATHEROS(an);
  908983:	238282        	l32i	a3, a8, 0x208
	A_INT8               index;
	TX_RATE_CTRL         *pRc = NULL;

	pRc = (TX_RATE_CTRL *)(pSib ? (pSib) : NULL);

	*isProbing = FALSE;
  908986:	9750      	s32i.n	a7, a5, 0
}

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
		    int numTries, int numRates, int stepDnInc,
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
  908988:	241602        	s32i	a4, a1, 8
	struct atheros_node *asn = ATH_NODE_ATHEROS(an);
	A_UINT8 rix, nrix;
	A_UINT8 dot11Rate;
	WLAN_PHY phy;

	rix = rcRateFind_ht(sc, asn, pRateTable, (rcflag & ATH_RC_PROBE_ALLOWED) ? 1 : 0, 
  90898b:	090640        	extui	a6, a9, 0, 1
}

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
		    int numTries, int numRates, int stepDnInc,
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
  90898e:	241214        	l32i	a4, a1, 80
	 *   0msec   <= dt <= 25msec:   don't derate
	 *   25msec  <= dt <= 185msec:  derate linearly from 0 to 10dB
	 *   185msec <= dt:             derate by 10dB
	 */

	nowMsec = A_MS_TICKGET();
  908991:	5bec82        	call8	903b9c <ath_hal_getuptime>
	 * Now look up the rate in the rssi table and return it.
	 * If no rates match then we return 0 (lowest rate)
	 */

	bestThruput = 0;
	maxIndex = pRc->maxValidRate-1;
  908994:	2c3041        	l8ui	a12, a3, 65
    
	/*
	 * Try the higher rate first. It will reduce memory moving time
	 * if we have very good channel characteristics.
	 */
	for (index = maxIndex; index >= minIndex ; index--) {
  908997:	d870      	mov.n	a8, a7
	 * Now look up the rate in the rssi table and return it.
	 * If no rates match then we return 0 (lowest rate)
	 */

	bestThruput = 0;
	maxIndex = pRc->maxValidRate-1;
  908999:	b0cf      	addi.n	a15, a12, -1
  90899b:	0f0f47        	extui	a15, a15, 0, 8
  90899e:	9c18      	s32i.n	a12, a1, 32

	minIndex = 0;
	bestRate = minIndex;
  9089a0:	db70      	mov.n	a11, a7
	/*
	 * Now look up the rate in the rssi table and return it.
	 * If no rates match then we return 0 (lowest rate)
	 */

	bestThruput = 0;
  9089a2:	dc70      	mov.n	a12, a7
	}

	return rix;
}

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
  9089a4:	00f732        	sext	a7, a15, 7
  9089a7:	a73d      	add.n	a13, a3, a7
  9089a9:	9d11      	s32i.n	a13, a1, 4
  9089ab:	600040        	j	9089ef <rcRateFind_11n+0x8f>
  9089ae:	8e11      	l32i.n	a14, a1, 4
  9089b0:	a8e7      	add.n	a7, a14, a8
	 * if we have very good channel characteristics.
	 */
	for (index = maxIndex; index >= minIndex ; index--) {
		A_UINT8 perThres;
    
		rate = pRc->validRateIndex[index];
  9089b2:	297042        	l8ui	a9, a7, 66
		if (rate > pRc->rateMaxPhy) {
  9089b5:	27307d        	l8ui	a7, a3, 125
  9089b8:	797331        	bltu	a7, a9, 9089ed <rcRateFind_11n+0x8d>
		}

		/* if the best throughput is already larger than the userRateKbps..
		 * then we could skip of rest of calculation.. 
		 */
		if( bestThruput >= pRateTable->info[rate].userRateKbps)
  9089bb:	8d10      	l32i.n	a13, a1, 0
  9089bd:	09970a        	addx4	a7, a9, a9
  9089c0:	0d770b        	addx8	a7, a7, a13
  9089c3:	8775      	l32i.n	a7, a7, 20
  9089c5:	77c308        	bltu	a12, a7, 9089d1 <rcRateFind_11n+0x71>
	/*
	 * Must check the actual rate (rateKbps) to account for non-monoticity of
	 * 11g's rate table
	 */

	if (rate >= pRc->rateMaxPhy && probeAllowed) {
  9089c8:	27307d        	l8ui	a7, a3, 125
  9089cb:	77bb29        	bgeu	a11, a7, 9089f8 <rcRateFind_11n+0x98>
  9089ce:	600028        	j	9089fa <rcRateFind_11n+0x9a>
		 * rate whose PER has decayed close to 0.  If we
		 * used to next lower rate, its PER would grow to
		 * 10-15 and we would be worse off then staying
		 * at the current rate.
		 */
		perThres = pRc->state[rate].per;
  9089d1:	a93d      	add.n	a13, a3, a9
  9089d3:	2dd000        	l8ui	a13, a13, 0
		if ( perThres < 12 ) {
  9089d6:	c0eb      	movi.n	a14, 11
  9089d8:	7de301        	bltu	a14, a13, 9089dd <rcRateFind_11n+0x7d>
			perThres = 12;
  9089db:	c0dc      	movi.n	a13, 12
		}

		thisThruput = pRateTable->info[rate].userRateKbps * (100 - perThres);
  9089dd:	2e0a64        	movi	a14, 100
  9089e0:	0ded0c        	sub	a13, a14, a13
  9089e3:	07dd28        	mull	a13, a13, a7
		if (bestThruput <= thisThruput) {
  9089e6:	7cd303        	bltu	a13, a12, 9089ed <rcRateFind_11n+0x8d>
  9089e9:	db90      	mov.n	a11, a9
  9089eb:	dcd0      	mov.n	a12, a13
  9089ed:	b088      	addi.n	a8, a8, -1
	}

	return rix;
}

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
  9089ef:	a8f7      	add.n	a7, a15, a8
    
	/*
	 * Try the higher rate first. It will reduce memory moving time
	 * if we have very good channel characteristics.
	 */
	for (index = maxIndex; index >= minIndex ; index--) {
  9089f1:	7877b9        	bbci	a7, 24, 9089ae <rcRateFind_11n+0x4e>
  9089f4:	63ffd0        	j	9089c8 <rcRateFind_11n+0x68>
  9089f7:	00ce68        	excw
	/*
	 * Must check the actual rate (rateKbps) to account for non-monoticity of
	 * 11g's rate table
	 */

	if (rate >= pRc->rateMaxPhy && probeAllowed) {
  9089fa:	d7b0      	mov.n	a7, a11
  9089fc:	600045        	j	908a45 <rcRateFind_11n+0xe5>
  9089ff:	00a839        	movnez	a8, a10, a0
                     A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_UINT8 i;

	for (i = 0; i < pRc->maxValidRate-1; i++) {
		if (pRc->validRateIndex[i] == curValidTxRate) {
  908a02:	2b9042        	l8ui	a11, a9, 66
  908a05:	77b913        	bne	a11, a7, 908a1c <rcRateFind_11n+0xbc>
		rate = pRc->rateMaxPhy;

		/* Probe the next allowed phy state */
		/* FIXME: Check to make sure ratMax is checked properly */
		if (rcGetNextValidTxRate( pRateTable, pRc, rate, &nextRate) && 
		    (nowMsec - pRc->probeTime > pRateTable->probeInterval) &&
  908a08:	8c10      	l32i.n	a12, a1, 0
{
	A_UINT8 i;

	for (i = 0; i < pRc->maxValidRate-1; i++) {
		if (pRc->validRateIndex[i] == curValidTxRate) {
			*pNextIndex = pRc->validRateIndex[i+1];
  908a0a:	289043        	l8ui	a8, a9, 67
		rate = pRc->rateMaxPhy;

		/* Probe the next allowed phy state */
		/* FIXME: Check to make sure ratMax is checked properly */
		if (rcGetNextValidTxRate( pRateTable, pRc, rate, &nextRate) && 
		    (nowMsec - pRc->probeTime > pRateTable->probeInterval) &&
  908a0d:	893f      	l32i.n	a9, a3, 60
  908a0f:	2bc001        	l8ui	a11, a12, 1
  908a12:	09a90c        	sub	a9, a10, a9
	if (rate >= pRc->rateMaxPhy && probeAllowed) {
		rate = pRc->rateMaxPhy;

		/* Probe the next allowed phy state */
		/* FIXME: Check to make sure ratMax is checked properly */
		if (rcGetNextValidTxRate( pRateTable, pRc, rate, &nextRate) && 
  908a15:	79b317        	bltu	a11, a9, 908a30 <rcRateFind_11n+0xd0>
  908a18:	600029        	j	908a45 <rcRateFind_11n+0xe5>
  908a1b:	00b188        	excw
rcGetNextValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc, 
                     A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_UINT8 i;

	for (i = 0; i < pRc->maxValidRate-1; i++) {
  908a1e:	080847        	extui	a8, a8, 0, 8
  908a21:	600005        	j	908a2a <rcRateFind_11n+0xca>
  908a24:	8d18      	l32i.n	a13, a1, 32
	/*
	 * Must check the actual rate (rateKbps) to account for non-monoticity of
	 * 11g's rate table
	 */

	if (rate >= pRc->rateMaxPhy && probeAllowed) {
  908a26:	c080      	movi.n	a8, 0
rcGetNextValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc, 
                     A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_UINT8 i;

	for (i = 0; i < pRc->maxValidRate-1; i++) {
  908a28:	b0de      	addi.n	a14, a13, -1
  908a2a:	7e82d2        	blt	a8, a14, 908a00 <rcRateFind_11n+0xa0>
  908a2d:	600014        	j	908a45 <rcRateFind_11n+0xe5>
		rate = pRc->rateMaxPhy;

		/* Probe the next allowed phy state */
		/* FIXME: Check to make sure ratMax is checked properly */
		if (rcGetNextValidTxRate( pRateTable, pRc, rate, &nextRate) && 
		    (nowMsec - pRc->probeTime > pRateTable->probeInterval) &&
  908a30:	293040        	l8ui	a9, a3, 64
  908a33:	c89e      	beqz.n	a9, 908a45 <rcRateFind_11n+0xe5>
		    (pRc->hwMaxRetryPktCnt >= 1))
		{
			rate                  = nextRate;
			pRc->probeRate        = rate;
			pRc->probeTime        = nowMsec;
			pRc->hwMaxRetryPktCnt = 0;
  908a35:	c070      	movi.n	a7, 0
  908a37:	273440        	s8i	a7, a3, 64
		if (rcGetNextValidTxRate( pRateTable, pRc, rate, &nextRate) && 
		    (nowMsec - pRc->probeTime > pRateTable->probeInterval) &&
		    (pRc->hwMaxRetryPktCnt >= 1))
		{
			rate                  = nextRate;
			pRc->probeRate        = rate;
  908a3a:	283437        	s8i	a8, a3, 55
			pRc->probeTime        = nowMsec;
			pRc->hwMaxRetryPktCnt = 0;
			*isProbing            = TRUE;
  908a3d:	c071      	movi.n	a7, 1
		    (nowMsec - pRc->probeTime > pRateTable->probeInterval) &&
		    (pRc->hwMaxRetryPktCnt >= 1))
		{
			rate                  = nextRate;
			pRc->probeRate        = rate;
			pRc->probeTime        = nowMsec;
  908a3f:	9a3f      	s32i.n	a10, a3, 60
			pRc->hwMaxRetryPktCnt = 0;
			*isProbing            = TRUE;
  908a41:	9750      	s32i.n	a7, a5, 0
{
	A_UINT8 i;

	for (i = 0; i < pRc->maxValidRate-1; i++) {
		if (pRc->validRateIndex[i] == curValidTxRate) {
			*pNextIndex = pRc->validRateIndex[i+1];
  908a43:	d780      	mov.n	a7, a8
	 * Make sure rate is not higher than the allowed maximum.
	 * We should also enforce the min, but I suspect the min is
	 * normally 1 rather than 0 because of the rate 9 vs 6 issue
	 * in the old code.
	 */
	if (rate > (pRc->rateTableSize - 1)) {
  908a45:	283036        	l8ui	a8, a3, 54
  908a48:	787205        	blt	a7, a8, 908a51 <rcRateFind_11n+0xf1>
		rate = pRc->rateTableSize - 1;
  908a4b:	278cff        	addi	a7, a8, -1
  908a4e:	070747        	extui	a7, a7, 0, 8
	}

	/* record selected rate, which is used to decide if we want to do fast frame */
	if (!(*isProbing) && pSib) {
  908a51:	8850      	l32i.n	a8, a5, 0
  908a53:	cd82      	bnez.n	a8, 908a69 <rcRateFind_11n+0x109>
		pSib->lastRateKbps = pRateTable->info[rate].rateKbps;
  908a55:	8910      	l32i.n	a9, a1, 0
  908a57:	07780a        	addx4	a8, a7, a7
  908a5a:	09880b        	addx8	a8, a8, a9
  908a5d:	8884      	l32i.n	a8, a8, 16
  908a5f:	283620        	s32i	a8, a3, 128
		((struct atheros_softc*)sc->sc_rc)->currentTxRateKbps = pSib->lastRateKbps;
  908a62:	232248        	l32i	a3, a2, 0x120
  908a65:	9834      	s32i.n	a8, a3, 16
		((struct atheros_softc*)sc->sc_rc)->currentTxRateIndex = rate;
  908a67:	9735      	s32i.n	a7, a3, 20

	rix = rcRateFind_ht(sc, asn, pRateTable, (rcflag & ATH_RC_PROBE_ALLOWED) ? 1 : 0, 
			    isProbe);
	nrix = rix;

	if ((rcflag & ATH_RC_PROBE_ALLOWED) && (*isProbe)) {
  908a69:	646041        	beqz	a6, 908aae <rcRateFind_11n+0x14e>
  908a6c:	8350      	l32i.n	a3, a5, 0

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
		    int numTries, int numRates, int stepDnInc,
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
	A_UINT8 i = 0; 
  908a6e:	c0e0      	movi.n	a14, 0

	rix = rcRateFind_ht(sc, asn, pRateTable, (rcflag & ATH_RC_PROBE_ALLOWED) ? 1 : 0, 
			    isProbe);
	nrix = rix;

	if ((rcflag & ATH_RC_PROBE_ALLOWED) && (*isProbe)) {
  908a70:	d570      	mov.n	a5, a7
  908a72:	7e313c        	beq	a3, a14, 908ab2 <rcRateFind_11n+0x152>
		/* set one try for probe rates. For the probes don't enable rts */
		rcRateSetseries(pRateTable, &series[i++], 1, nrix,
  908a75:	8a10      	l32i.n	a10, a1, 0
  908a77:	db40      	mov.n	a11, a4
  908a79:	c0c1      	movi.n	a12, 1
  908a7b:	dd70      	mov.n	a13, a7
  908a7d:	5bfe43        	call8	90838c <rcRateSetseries$isra$5>
               const RATE_TABLE_11N *pRateTable , 
               A_UINT8 rix, A_UINT16 stepDown, A_UINT16 minRate)
{
	A_UINT32                j;
	A_UINT8                 nextIndex;
	struct atheros_node     *pSib = ATH_NODE_ATHEROS(an);
  908a80:	8313      	l32i.n	a3, a1, 12
  908a82:	253282        	l32i	a5, a3, 0x208
rcGetNextLowerValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc,  
                          A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_INT8 i;

	for (i = 1; i < pRc->maxValidRate ; i++) {
  908a85:	c031      	movi.n	a3, 1
  908a87:	285041        	l8ui	a8, a5, 65
  908a8a:	d650      	mov.n	a6, a5
  908a8c:	600012        	j	908aa2 <rcRateFind_11n+0x142>
  908a8f:	002a60        	excw
		if (pRc->validRateIndex[i] == curValidTxRate) {
  908a92:	43b133        	excw
  908a95:	b166      	addi.n	a6, a6, 1
  908a97:	77a907        	bne	a10, a7, 908aa2 <rcRateFind_11n+0x142>
			*pNextIndex = pRc->validRateIndex[i-1];
  908a9a:	a955      	add.n	a5, a5, a9
  908a9c:	255041        	l8ui	a5, a5, 65
  908a9f:	600006        	j	908aa9 <rcRateFind_11n+0x149>
rcGetNextLowerValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc,  
                          A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_INT8 i;

	for (i = 1; i < pRc->maxValidRate ; i++) {
  908aa2:	d930      	mov.n	a9, a3
  908aa4:	7832e8        	blt	a3, a8, 908a90 <rcRateFind_11n+0x130>
  908aa7:	d570      	mov.n	a5, a7
			    isProbe);
	nrix = rix;

	if ((rcflag & ATH_RC_PROBE_ALLOWED) && (*isProbe)) {
		/* set one try for probe rates. For the probes don't enable rts */
		rcRateSetseries(pRateTable, &series[i++], 1, nrix,
  908aa9:	c0e1      	movi.n	a14, 1
  908aab:	600003        	j	908ab2 <rcRateFind_11n+0x152>

	rix = rcRateFind_ht(sc, asn, pRateTable, (rcflag & ATH_RC_PROBE_ALLOWED) ? 1 : 0, 
			    isProbe);
	nrix = rix;

	if ((rcflag & ATH_RC_PROBE_ALLOWED) && (*isProbe)) {
  908aae:	d570      	mov.n	a5, a7

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
		    int numTries, int numRates, int stepDnInc,
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
	A_UINT8 i = 0; 
  908ab0:	de60      	mov.n	a14, a6
		 * after the probe rate
		 */
		nrix = rcRateGetIndex( sc, an, pRateTable, nrix, 1, FALSE);
	}

	tryPerRate = (numTries/numRates);
  908ab2:	8b14      	l32i.n	a11, a1, 16
  908ab4:	2a1202        	l32i	a10, a1, 8
  908ab7:	2e1607        	s32i	a14, a1, 28
  908aba:	5b708c        	call8	8e4cec <__divsi3>

	/* Set the choosen rate. No RTS for first series entry. */
	rcRateSetseries(pRateTable, &series[i++], tryPerRate,
  908abd:	8e17      	l32i.n	a14, a1, 28
		 * after the probe rate
		 */
		nrix = rcRateGetIndex( sc, an, pRateTable, nrix, 1, FALSE);
	}

	tryPerRate = (numTries/numRates);
  908abf:	0a0847        	extui	a8, a10, 0, 8
  908ac2:	9811      	s32i.n	a8, a1, 4

	/* Set the choosen rate. No RTS for first series entry. */
	rcRateSetseries(pRateTable, &series[i++], tryPerRate,
  908ac4:	0fe811        	slli	a8, a14, 1
		 * after the probe rate
		 */
		nrix = rcRateGetIndex( sc, an, pRateTable, nrix, 1, FALSE);
	}

	tryPerRate = (numTries/numRates);
  908ac7:	d6a0      	mov.n	a6, a10

	/* Set the choosen rate. No RTS for first series entry. */
	rcRateSetseries(pRateTable, &series[i++], tryPerRate,
  908ac9:	ae8b      	add.n	a11, a8, a14
  908acb:	8a10      	l32i.n	a10, a1, 0
  908acd:	b1e3      	addi.n	a3, a14, 1
  908acf:	060c47        	extui	a12, a6, 0, 8
  908ad2:	04bb0a        	addx4	a11, a11, a4
  908ad5:	dd50      	mov.n	a13, a5
  908ad7:	c0e0      	movi.n	a14, 0
  908ad9:	5bfe2c        	call8	90838c <rcRateSetseries$isra$5>
  908adc:	030347        	extui	a3, a3, 0, 8
	}

	return rix;
}

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
  908adf:	063f1c        	mul16u	a15, a3, a6
  908ae2:	8912      	l32i.n	a9, a1, 8
	for (; i < numRates; i++) {
		A_UINT8 tryNum;
		A_UINT8 minRate;

		tryNum  = ((i + 1) == numRates) ? numTries - (tryPerRate * i) : tryPerRate ;
		minRate = (((i + 1) == numRates) && (rcflag & ATH_RC_MINRATE_LASTRATE)) ? 1 : 0;
  908ae4:	8815      	l32i.n	a8, a1, 20
  908ae6:	c062      	movi.n	a6, 2
  908ae8:	0f9f0c        	sub	a15, a9, a15
  908aeb:	068601        	and	a6, a8, a6
  908aee:	0f0f47        	extui	a15, a15, 0, 8
  908af1:	9612      	s32i.n	a6, a1, 8
	/* Set the choosen rate. No RTS for first series entry. */
	rcRateSetseries(pRateTable, &series[i++], tryPerRate,
			nrix, FALSE, asc->tx_chainmask, asn->stbc);

	/* Fill in the other rates for multirate retry */
	for (; i < numRates; i++) {
  908af3:	600099        	j	908b90 <rcRateFind_11n+0x230>
		A_UINT8 tryNum;
		A_UINT8 minRate;

		tryNum  = ((i + 1) == numRates) ? numTries - (tryPerRate * i) : tryPerRate ;
  908af6:	8914      	l32i.n	a9, a1, 16
  908af8:	b136      	addi.n	a6, a3, 1
  908afa:	8c11      	l32i.n	a12, a1, 4
		minRate = (((i + 1) == numRates) && (rcflag & ATH_RC_MINRATE_LASTRATE)) ? 1 : 0;
  908afc:	c080      	movi.n	a8, 0
	/* Fill in the other rates for multirate retry */
	for (; i < numRates; i++) {
		A_UINT8 tryNum;
		A_UINT8 minRate;

		tryNum  = ((i + 1) == numRates) ? numTries - (tryPerRate * i) : tryPerRate ;
  908afe:	79690a        	bne	a6, a9, 908b0c <rcRateFind_11n+0x1ac>
		minRate = (((i + 1) == numRates) && (rcflag & ATH_RC_MINRATE_LASTRATE)) ? 1 : 0;
  908b01:	8612      	l32i.n	a6, a1, 8
  908b03:	c081      	movi.n	a8, 1
  908b05:	c090      	movi.n	a9, 0
  908b07:	dcf0      	mov.n	a12, a15
  908b09:	069838        	moveqz	a8, a9, a6
               const RATE_TABLE_11N *pRateTable , 
               A_UINT8 rix, A_UINT16 stepDown, A_UINT16 minRate)
{
	A_UINT32                j;
	A_UINT8                 nextIndex;
	struct atheros_node     *pSib = ATH_NODE_ATHEROS(an);
  908b0c:	8913      	l32i.n	a9, a1, 12
  908b0e:	269282        	l32i	a6, a9, 0x208
	TX_RATE_CTRL            *pRc = (TX_RATE_CTRL *)(pSib);
    
	if (minRate) {
  908b11:	ca8b      	beqz.n	a8, 908b40 <rcRateFind_11n+0x1e0>
rcGetNextLowerValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc,  
                          A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_INT8 i;

	for (i = 1; i < pRc->maxValidRate ; i++) {
  908b13:	2b6041        	l8ui	a11, a6, 65
  908b16:	c3a6      	movi.n	a10, 54
  908b18:	d960      	mov.n	a9, a6
  908b1a:	c081      	movi.n	a8, 1
  908b1c:	600018        	j	908b38 <rcRateFind_11n+0x1d8>
  908b1f:	002e90        	l32e	a0, a2, -8
		if (pRc->validRateIndex[i] == curValidTxRate) {
  908b22:	43b188        	excw
  908b25:	b199      	addi.n	a9, a9, 1
  908b27:	75e90d        	bne	a14, a5, 908b38 <rcRateFind_11n+0x1d8>
			*pNextIndex = pRc->validRateIndex[i-1];
  908b2a:	ad6d      	add.n	a13, a6, a13
  908b2c:	b0aa      	addi.n	a10, a10, -1
  908b2e:	25d041        	l8ui	a5, a13, 65
	A_UINT8                 nextIndex;
	struct atheros_node     *pSib = ATH_NODE_ATHEROS(an);
	TX_RATE_CTRL            *pRc = (TX_RATE_CTRL *)(pSib);
    
	if (minRate) {
		for (j = RATE_TABLE_11N_SIZE; j > 0; j-- ) {
  908b31:	65afe3        	bnez	a10, 908b18 <rcRateFind_11n+0x1b8>
  908b34:	600038        	j	908b70 <rcRateFind_11n+0x210>
  908b37:	00dd80        	excw
rcGetNextLowerValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc,  
                          A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_INT8 i;

	for (i = 1; i < pRc->maxValidRate ; i++) {
  908b3a:	7b82e2        	blt	a8, a11, 908b20 <rcRateFind_11n+0x1c0>
  908b3d:	60002f        	j	908b70 <rcRateFind_11n+0x210>
		A_UINT8 minRate;

		tryNum  = ((i + 1) == numRates) ? numTries - (tryPerRate * i) : tryPerRate ;
		minRate = (((i + 1) == numRates) && (rcflag & ATH_RC_MINRATE_LASTRATE)) ? 1 : 0;

		nrix = rcRateGetIndex(sc, an, pRateTable, nrix, stepDnInc, minRate);
  908b40:	8816      	l32i.n	a8, a1, 24
  908b42:	080a4f        	extui	a10, a8, 0, 16
  908b45:	60001b        	j	908b64 <rcRateFind_11n+0x204>
                          A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_INT8 i;

	for (i = 1; i < pRc->maxValidRate ; i++) {
		if (pRc->validRateIndex[i] == curValidTxRate) {
  908b48:	2e9043        	l8ui	a14, a9, 67
  908b4b:	b188      	addi.n	a8, a8, 1
  908b4d:	b199      	addi.n	a9, a9, 1
  908b4f:	75e909        	bne	a14, a5, 908b5c <rcRateFind_11n+0x1fc>
			*pNextIndex = pRc->validRateIndex[i-1];
  908b52:	ad6d      	add.n	a13, a6, a13
  908b54:	25d041        	l8ui	a5, a13, 65
			} else {
				break;
			}
		}
	} else {
		for (j = stepDown; j > 0; j-- ) {
  908b57:	b0aa      	addi.n	a10, a10, -1
  908b59:	600007        	j	908b64 <rcRateFind_11n+0x204>
rcGetNextLowerValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc,  
                          A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_INT8 i;

	for (i = 1; i < pRc->maxValidRate ; i++) {
  908b5c:	dd80      	mov.n	a13, a8
  908b5e:	7b82e6        	blt	a8, a11, 908b48 <rcRateFind_11n+0x1e8>
  908b61:	60000b        	j	908b70 <rcRateFind_11n+0x210>
			} else {
				break;
			}
		}
	} else {
		for (j = stepDown; j > 0; j-- ) {
  908b64:	c8a8      	beqz.n	a10, 908b70 <rcRateFind_11n+0x210>
rcGetNextLowerValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc,  
                          A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_INT8 i;

	for (i = 1; i < pRc->maxValidRate ; i++) {
  908b66:	2b6041        	l8ui	a11, a6, 65
  908b69:	d960      	mov.n	a9, a6
  908b6b:	c081      	movi.n	a8, 1
  908b6d:	63ffeb        	j	908b5c <rcRateFind_11n+0x1fc>
		minRate = (((i + 1) == numRates) && (rcflag & ATH_RC_MINRATE_LASTRATE)) ? 1 : 0;

		nrix = rcRateGetIndex(sc, an, pRateTable, nrix, stepDnInc, minRate);

		/* All other rates in the series have RTS enabled */
		rcRateSetseries(pRateTable, &series[i], tryNum,
  908b70:	033b09        	addx2	a11, a3, a3
  908b73:	8a10      	l32i.n	a10, a1, 0
  908b75:	04bb0a        	addx4	a11, a11, a4
  908b78:	dd50      	mov.n	a13, a5
  908b7a:	c0e1      	movi.n	a14, 1
  908b7c:	9f17      	s32i.n	a15, a1, 28
  908b7e:	5bfe03        	call8	90838c <rcRateSetseries$isra$5>
  908b81:	8f17      	l32i.n	a15, a1, 28
  908b83:	8911      	l32i.n	a9, a1, 4
	/* Set the choosen rate. No RTS for first series entry. */
	rcRateSetseries(pRateTable, &series[i++], tryPerRate,
			nrix, FALSE, asc->tx_chainmask, asn->stbc);

	/* Fill in the other rates for multirate retry */
	for (; i < numRates; i++) {
  908b85:	b133      	addi.n	a3, a3, 1
  908b87:	09ff0c        	sub	a15, a15, a9
  908b8a:	030347        	extui	a3, a3, 0, 8
  908b8d:	0f0f47        	extui	a15, a15, 0, 8
  908b90:	8814      	l32i.n	a8, a1, 16
  908b92:	783a02        	bge	a3, a8, 908b98 <rcRateFind_11n+0x238>
  908b95:	63ff5d        	j	908af6 <rcRateFind_11n+0x196>
	 *    {MCS2, MCS1, MCS0, MCS0}.
	 * When first rate in series is MCS3 in HT20 @ 2.4GHz, series should look like:
	 *    {MCS3, MCS2, MCS1, MCS1}
	 * So, set fourth rate in series to be same as third one for above conditions.
	 */
	if (sc->sc_curmode == IEEE80211_MODE_11NG) {
  908b98:	2522c2        	l32i	a5, a2, 0x308
  908b9b:	695152        	bnei	a5, 1, 908bf1 <rcRateFind_11n+0x291>
		dot11Rate = pRateTable->info[rix].dot11Rate;
  908b9e:	8910      	l32i.n	a9, a1, 0
  908ba0:	07780a        	addx4	a8, a7, a7
  908ba3:	09880b        	addx8	a8, a8, a9
  908ba6:	26801a        	l8ui	a6, a8, 26
		phy = pRateTable->info[rix].phy;
  908ba9:	28800c        	l8ui	a8, a8, 12
		if (i == 4 &&
  908bac:	693441        	bnei	a3, 4, 908bf1 <rcRateFind_11n+0x291>
		    ((dot11Rate == 2 && phy == WLAN_RC_PHY_HT_40_SS) || 
  908baf:	c030      	movi.n	a3, 0
  908bb1:	298cfa        	addi	a9, a8, -6
  908bb4:	da30      	mov.n	a10, a3
  908bb6:	095a38        	moveqz	a10, a5, a9
	 * So, set fourth rate in series to be same as third one for above conditions.
	 */
	if (sc->sc_curmode == IEEE80211_MODE_11NG) {
		dot11Rate = pRateTable->info[rix].dot11Rate;
		phy = pRateTable->info[rix].phy;
		if (i == 4 &&
  908bb9:	0a0947        	extui	a9, a10, 0, 8
  908bbc:	73910a        	beq	a9, a3, 908bca <rcRateFind_11n+0x26a>
		    ((dot11Rate == 2 && phy == WLAN_RC_PHY_HT_40_SS) || 
  908bbf:	296cfe        	addi	a9, a6, -2
  908bc2:	095338        	moveqz	a3, a5, a9
	 * So, set fourth rate in series to be same as third one for above conditions.
	 */
	if (sc->sc_curmode == IEEE80211_MODE_11NG) {
		dot11Rate = pRateTable->info[rix].dot11Rate;
		phy = pRateTable->info[rix].phy;
		if (i == 4 &&
  908bc5:	030347        	extui	a3, a3, 0, 8
  908bc8:	cd35      	bnez.n	a3, 908be1 <rcRateFind_11n+0x281>
		    ((dot11Rate == 2 && phy == WLAN_RC_PHY_HT_40_SS) || 
		     (dot11Rate == 3 && phy == WLAN_RC_PHY_HT_20_SS))) 
  908bca:	c030      	movi.n	a3, 0
  908bcc:	288cfc        	addi	a8, a8, -4
  908bcf:	c051      	movi.n	a5, 1
  908bd1:	dc30      	mov.n	a12, a3
  908bd3:	085c38        	moveqz	a12, a5, a8
	 */
	if (sc->sc_curmode == IEEE80211_MODE_11NG) {
		dot11Rate = pRateTable->info[rix].dot11Rate;
		phy = pRateTable->info[rix].phy;
		if (i == 4 &&
		    ((dot11Rate == 2 && phy == WLAN_RC_PHY_HT_40_SS) || 
  908bd6:	73c117        	beq	a12, a3, 908bf1 <rcRateFind_11n+0x291>
		     (dot11Rate == 3 && phy == WLAN_RC_PHY_HT_20_SS))) 
  908bd9:	266cfd        	addi	a6, a6, -3
  908bdc:	065338        	moveqz	a3, a5, a6
	 */
	if (sc->sc_curmode == IEEE80211_MODE_11NG) {
		dot11Rate = pRateTable->info[rix].dot11Rate;
		phy = pRateTable->info[rix].phy;
		if (i == 4 &&
		    ((dot11Rate == 2 && phy == WLAN_RC_PHY_HT_40_SS) || 
  908bdf:	c83e      	beqz.n	a3, 908bf1 <rcRateFind_11n+0x291>
		     (dot11Rate == 3 && phy == WLAN_RC_PHY_HT_20_SS))) 
		{
			series[3].rix = series[2].rix;
  908be1:	234018        	l8ui	a3, a4, 24
  908be4:	234424        	s8i	a3, a4, 36
			series[3].flags = series[2].flags;
  908be7:	23401b        	l8ui	a3, a4, 27
  908bea:	234427        	s8i	a3, a4, 39
			series[3].max4msframelen = series[2].max4msframelen;
  908bed:	8347      	l32i.n	a3, a4, 28
  908bef:	934a      	s32i.n	a3, a4, 40
	/*
	 * 2009/02/06
	 * AP91 Kite: NetGear OTA location-4 downlink.
	 *            Enable RTS/CTS at MCS 3-0 for downlink throughput.
	 */
	if (sc->sc_curmode == IEEE80211_MODE_11NG) {
  908bf1:	2222c2        	l32i	a2, a2, 0x308
  908bf4:	692118        	bnei	a2, 1, 908c10 <rcRateFind_11n+0x2b0>
		dot11Rate = pRateTable->info[rix].dot11Rate;
  908bf7:	8210      	l32i.n	a2, a1, 0
  908bf9:	07770a        	addx4	a7, a7, a7
  908bfc:	02770b        	addx8	a7, a7, a2
		if (dot11Rate <= 3 ) {
  908bff:	22701a        	l8ui	a2, a7, 26
  908c02:	6f240a        	bgeui	a2, 4, 908c10 <rcRateFind_11n+0x2b0>
			series[0].flags |= ATH_RC_RTSCTS_FLAG;         
  908c05:	234003        	l8ui	a3, a4, 3
  908c08:	c120      	movi.n	a2, 16
  908c0a:	023202        	or	a2, a3, a2
  908c0d:	224403        	s8i	a2, a4, 3
  908c10:	d10f      	retw.n
	...

00908c14 <rcUpdate_11n>:
void rcUpdate_11n(struct ath_softc_tgt *sc, struct ath_node_target *an,
		  A_UINT8 curTxAnt, 
		  int finalTSIdx, int Xretries,
		  struct ath_rc_series rcs[], int nFrames, 
		  int nBad, int long_retry)
{
  908c14:	6c1008        	entry	a1, 64
  908c17:	d920      	mov.n	a9, a2
	A_UINT32 series = 0;
	A_UINT32 rix;
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  908c19:	2492c2        	l32i	a4, a9, 0x308
  908c1c:	222248        	l32i	a2, a2, 0x120
void rcUpdate_11n(struct ath_softc_tgt *sc, struct ath_node_target *an,
		  A_UINT8 curTxAnt, 
		  int finalTSIdx, int Xretries,
		  struct ath_rc_series rcs[], int nFrames, 
		  int nBad, int long_retry)
{
  908c1f:	d870      	mov.n	a8, a7
	A_UINT32 series = 0;
	A_UINT32 rix;
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  908c21:	02420a        	addx4	a2, a4, a2
  908c24:	8421      	l32i.n	a4, a2, 4
	struct atheros_node *pSib = ATH_NODE_ATHEROS(an);
  908c26:	223282        	l32i	a2, a3, 0x208
  908c29:	9215      	s32i.n	a2, a1, 20

	/*
	 * If the first rate is not the final index, there are intermediate rate failures
	 * to be processed.
	 */
	if (finalTSIdx != 0) {
  908c2b:	64509e        	beqz	a5, 908ccd <rcUpdate_11n+0xb9>
				} else {
					rix = pRateTable->info[rcs[series].rix].baseIndex;
				}

				/* FIXME:XXXX, too many args! */
				rcUpdate_ht(sc, an, rix, Xretries? 1 : 2, rcs[series].tries, 
  908c2e:	c0a1      	movi.n	a10, 1
  908c30:	9a14      	s32i.n	a10, a1, 16
  908c32:	8b14      	l32i.n	a11, a1, 16
  908c34:	c0a2      	movi.n	a10, 2
  908c36:	06ab38        	moveqz	a11, a10, a6

	/*
	 * If the first rate is not the final index, there are intermediate rate failures
	 * to be processed.
	 */
	if (finalTSIdx != 0) {
  908c39:	c020      	movi.n	a2, 0
				} else {
					rix = pRateTable->info[rcs[series].rix].baseIndex;
				}

				/* FIXME:XXXX, too many args! */
				rcUpdate_ht(sc, an, rix, Xretries? 1 : 2, rcs[series].tries, 
  908c3b:	9b14      	s32i.n	a11, a1, 16
  908c3d:	600080        	j	908cc1 <rcUpdate_11n+0xad>
  908c40:	002e70        	excw
	 */
	if (finalTSIdx != 0) {

		/* Process intermediate rates that failed.*/
		for (series = 0; series < finalTSIdx ; series++) {
			if (rcs[series].tries != 0) {
  908c43:	0164e0        	excw
  908c46:	752b70        	bgeu	a2, a5, 908cba <rcUpdate_11n+0xa6>
				flags = rcs[series].flags;
  908c49:	03c0c2        	excw
				/* If HT40 and we have switched mode from 40 to 20 => don't update */
				if ((flags & ATH_RC_CW40_FLAG) && 
  908c4c:	0cba01        	and	a10, a11, a12
  908c4f:	c8a9      	beqz.n	a10, 908c5c <rcUpdate_11n+0x48>
				    (pRc->rcPhyMode != (flags & ATH_RC_CW40_FLAG))) {
  908c51:	8d15      	l32i.n	a13, a1, 20
  908c53:	2cd07c        	l8ui	a12, a13, 124
		/* Process intermediate rates that failed.*/
		for (series = 0; series < finalTSIdx ; series++) {
			if (rcs[series].tries != 0) {
				flags = rcs[series].flags;
				/* If HT40 and we have switched mode from 40 to 20 => don't update */
				if ((flags & ATH_RC_CW40_FLAG) && 
  908c56:	7ac102        	beq	a12, a10, 908c5c <rcUpdate_11n+0x48>
  908c59:	6000e8        	j	908d45 <rcUpdate_11n+0x131>
				    (pRc->rcPhyMode != (flags & ATH_RC_CW40_FLAG))) {
					return;
				}
				if ((flags & ATH_RC_CW40_FLAG) && (flags & ATH_RC_HT40_SGI_FLAG)) {
  908c5c:	c0c6      	movi.n	a12, 6
  908c5e:	0cbc01        	and	a12, a11, a12
  908c61:	69c60f        	bnei	a12, 6, 908c74 <rcUpdate_11n+0x60>
					rix = pRateTable->info[rcs[series].rix].htIndex;
  908c64:	2a7000        	l8ui	a10, a7, 0
  908c67:	0aaa0a        	addx4	a10, a10, a10
  908c6a:	04aa0b        	addx8	a10, a10, a4
  908c6d:	2ca021        	l8ui	a12, a10, 33
  908c70:	600030        	j	908ca4 <rcUpdate_11n+0x90>
  908c73:	007db7        	excw
				} else if (flags & ATH_RC_HT40_SGI_FLAG) {
  908c76:	0e2a70        	excw
					rix = pRateTable->info[rcs[series].rix].sgiIndex;
  908c79:	000aaa        	excw
  908c7c:	0a04aa        	excw
  908c7f:	0b2ca0        	excw
  908c82:	206000        	l8ui	a0, a6, 0
  908c85:	1dc8ae        	l32r	a13, 8faf40 <memset+0x15da4>
				} else if (flags & ATH_RC_CW40_FLAG) {
					rix = pRateTable->info[rcs[series].rix].cw40Index;
  908c88:	2a7000        	l8ui	a10, a7, 0
  908c8b:	0aaa0a        	addx4	a10, a10, a10
  908c8e:	04aa0b        	addx8	a10, a10, a4
  908c91:	2ca01f        	l8ui	a12, a10, 31
  908c94:	60000c        	j	908ca4 <rcUpdate_11n+0x90>
  908c97:	002a70        	excw
				} else {
					rix = pRateTable->info[rcs[series].rix].baseIndex;
  908c9a:	000aaa        	excw
  908c9d:	0a04aa        	excw
  908ca0:	0b2ca0        	excw
  908ca3:	1e2a12        	l32r	a14, 8d34ec <_bss_end+0x3c5ce4>
				}

				/* FIXME:XXXX, too many args! */
				rcUpdate_ht(sc, an, rix, Xretries? 1 : 2, rcs[series].tries, 
  908ca6:	108d14        	l32r	a0, 8ec0f8 <memset+0x6f5c>
  908ca9:	0a0f4f        	extui	a15, a10, 0, 16
  908cac:	9f10      	s32i.n	a15, a1, 0
  908cae:	da90      	mov.n	a10, a9
  908cb0:	db30      	mov.n	a11, a3
  908cb2:	9817      	s32i.n	a8, a1, 28
  908cb4:	9916      	s32i.n	a9, a1, 24
  908cb6:	5bfdd7        	call8	908414 <rcUpdate_ht$isra$7>
  908cb9:	8916      	l32i.n	a9, a1, 24
  908cbb:	8817      	l32i.n	a8, a1, 28
	 * to be processed.
	 */
	if (finalTSIdx != 0) {

		/* Process intermediate rates that failed.*/
		for (series = 0; series < finalTSIdx ; series++) {
  908cbd:	b122      	addi.n	a2, a2, 1
  908cbf:	bc77      	addi.n	a7, a7, 12
  908cc1:	752b02        	bgeu	a2, a5, 908cc7 <rcUpdate_11n+0xb3>
  908cc4:	63ff79        	j	908c41 <rcUpdate_11n+0x2d>
  908cc7:	600011        	j	908cdc <rcUpdate_11n+0xc8>
  908cca:	000000        	ill
		/*
		 * Handle the special case of MIMO PS burst, where the second aggregate is sent
		 *  out with only one rate and one try. Treating it as an excessive retry penalizes
		 * the rate inordinately.
		 */
		if (rcs[0].tries == 1 && Xretries == 1) {
  908ccd:	277001        	l8ui	a7, a7, 1
		  A_UINT8 curTxAnt, 
		  int finalTSIdx, int Xretries,
		  struct ath_rc_series rcs[], int nFrames, 
		  int nBad, int long_retry)
{
	A_UINT32 series = 0;
  908cd0:	d250      	mov.n	a2, a5
		/*
		 * Handle the special case of MIMO PS burst, where the second aggregate is sent
		 *  out with only one rate and one try. Treating it as an excessive retry penalizes
		 * the rate inordinately.
		 */
		if (rcs[0].tries == 1 && Xretries == 1) {
  908cd2:	697106        	bnei	a7, 1, 908cdc <rcUpdate_11n+0xc8>
			Xretries = 2;
  908cd5:	b067      	addi.n	a7, a6, -1
  908cd7:	c052      	movi.n	a5, 2
  908cd9:	075638        	moveqz	a6, a5, a7
		}
	}

	flags = rcs[series].flags;
  908cdc:	022209        	addx2	a2, a2, a2
  908cdf:	08280a        	addx4	a8, a2, a8
  908ce2:	278003        	l8ui	a7, a8, 3
	/* If HT40 and we have switched mode from 40 to 20 => don't update */
	if ((flags & ATH_RC_CW40_FLAG) && 
  908ce5:	c052      	movi.n	a5, 2
  908ce7:	057501        	and	a5, a7, a5
  908cea:	c856      	beqz.n	a5, 908cf4 <rcUpdate_11n+0xe0>
	    (pRc->rcPhyMode != (flags & ATH_RC_CW40_FLAG))) {
  908cec:	8b15      	l32i.n	a11, a1, 20
  908cee:	22b07c        	l8ui	a2, a11, 124
		}
	}

	flags = rcs[series].flags;
	/* If HT40 and we have switched mode from 40 to 20 => don't update */
	if ((flags & ATH_RC_CW40_FLAG) && 
  908cf1:	752950        	bne	a2, a5, 908d45 <rcUpdate_11n+0x131>
	    (pRc->rcPhyMode != (flags & ATH_RC_CW40_FLAG))) {
		return;
	}
	if ((flags & ATH_RC_CW40_FLAG) && (flags & ATH_RC_HT40_SGI_FLAG)) {
  908cf4:	c026      	movi.n	a2, 6
  908cf6:	027201        	and	a2, a7, a2
  908cf9:	69260f        	bnei	a2, 6, 908d0c <rcUpdate_11n+0xf8>
		rix = pRateTable->info[rcs[series].rix].htIndex;
  908cfc:	228000        	l8ui	a2, a8, 0
  908cff:	02220a        	addx4	a2, a2, a2
  908d02:	04240b        	addx8	a4, a2, a4
  908d05:	2c4021        	l8ui	a12, a4, 33
  908d08:	60001f        	j	908d2b <rcUpdate_11n+0x117>
  908d0b:	002280        	excw
  908d0e:	000222        	excw
	} else if (flags & ATH_RC_HT40_SGI_FLAG) {
		rix = pRateTable->info[rcs[series].rix].sgiIndex;
  908d11:	0a0424        	excw
  908d14:	0b7d77        	excw
	    (pRc->rcPhyMode != (flags & ATH_RC_CW40_FLAG))) {
		return;
	}
	if ((flags & ATH_RC_CW40_FLAG) && (flags & ATH_RC_HT40_SGI_FLAG)) {
		rix = pRateTable->info[rcs[series].rix].htIndex;
	} else if (flags & ATH_RC_HT40_SGI_FLAG) {
  908d17:	052c40        	extui	a12, a5, 2, 1
		rix = pRateTable->info[rcs[series].rix].sgiIndex;
  908d1a:	206000        	l8ui	a0, a6, 0
  908d1d:	0cc856        	extui	a8, a12, 28, 7
	} else if (flags & ATH_RC_CW40_FLAG) {
		rix = pRateTable->info[rcs[series].rix].cw40Index;
  908d20:	2c401f        	l8ui	a12, a4, 31
  908d23:	600004        	j	908d2b <rcUpdate_11n+0x117>
  908d26:	00002c        	excw
	} else {
		rix = pRateTable->info[rcs[series].rix].baseIndex;
  908d29:	401e22        	excw
	}

	/* FIXME:XXXX, too many args! */
	rcUpdate_ht(sc, an, rix, Xretries, long_retry, curTxAnt, 
  908d2c:	12112e        	l32r	a2, 8cd1e4 <_bss_end+0x3bf9dc>
  908d2f:	121202        	l32r	a2, 8cd538 <_bss_end+0x3bfd30>
  908d32:	024f92        	excw
  908d35:	102212        	l32r	a0, 8d1580 <_bss_end+0x3c3d78>
  908d38:	10da90        	l32r	a0, 8ff778 <memset+0x1a5dc>
  908d3b:	db30      	mov.n	a11, a3
  908d3d:	dd60      	mov.n	a13, a6
  908d3f:	020f4f        	extui	a15, a2, 0, 16
  908d42:	5bfdb4        	call8	908414 <rcUpdate_ht$isra$7>
  908d45:	d10f      	retw.n
	...

00908d48 <ath_tx_status_update_rate>:

void ath_tx_status_update_rate(struct ath_softc_tgt *sc,
			       struct ath_rc_series rcs[],
			       int series,
			       WMI_TXSTATUS_EVENT *txs)
{
  908d48:	6c1004        	entry	a1, 32
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  908d4b:	282248        	l32i	a8, a2, 0x120

	/* HT Rate */
	if (pRateTable->info[rcs[series].rix].rateCode & 0x80) {
  908d4e:	044409        	addx2	a4, a4, a4
			       struct ath_rc_series rcs[],
			       int series,
			       WMI_TXSTATUS_EVENT *txs)
{
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  908d51:	2222c2        	l32i	a2, a2, 0x308

	/* HT Rate */
	if (pRateTable->info[rcs[series].rix].rateCode & 0x80) {
  908d54:	03430a        	addx4	a3, a4, a3
			       struct ath_rc_series rcs[],
			       int series,
			       WMI_TXSTATUS_EVENT *txs)
{
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  908d57:	08220a        	addx4	a2, a2, a8

	/* HT Rate */
	if (pRateTable->info[rcs[series].rix].rateCode & 0x80) {
  908d5a:	293000        	l8ui	a9, a3, 0
			       struct ath_rc_series rcs[],
			       int series,
			       WMI_TXSTATUS_EVENT *txs)
{
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  908d5d:	8221      	l32i.n	a2, a2, 4

	/* HT Rate */
	if (pRateTable->info[rcs[series].rix].rateCode & 0x80) {
  908d5f:	09940a        	addx4	a4, a9, a9
  908d62:	02420b        	addx8	a2, a4, a2
  908d65:	242018        	l8ui	a4, a2, 24
  908d68:	285000        	l8ui	a8, a5, 0
  908d6b:	004432        	sext	a4, a4, 7
  908d6e:	222c10        	addi	a2, a2, 16
  908d71:	674047        	bgez	a4, 908dbc <ath_tx_status_update_rate+0x74>
		txs->txstatus[txs->cnt].ts_rate |= SM(pRateTable->info[rcs[series].rix].dot11Rate,
  908d74:	088909        	addx2	a9, a8, a8
  908d77:	a959      	add.n	a9, a5, a9
  908d79:	22200a        	l8ui	a2, a2, 10
  908d7c:	249002        	l8ui	a4, a9, 2
  908d7f:	020243        	extui	a2, a2, 0, 4
  908d82:	042202        	or	a2, a2, a4
  908d85:	229402        	s8i	a2, a9, 2
								       ATH9K_HTC_TXSTAT_RATE);
		txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_MCS;
  908d88:	229003        	l8ui	a2, a9, 3
  908d8b:	c048      	movi.n	a4, 8
  908d8d:	042402        	or	a4, a2, a4
  908d90:	249403        	s8i	a4, a9, 3

		if (rcs[series].flags & ATH_RC_CW40_FLAG)
  908d93:	243003        	l8ui	a4, a3, 3
  908d96:	7e4707        	bbci	a4, 30, 908da1 <ath_tx_status_update_rate+0x59>
			txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_CW40;
  908d99:	c148      	movi.n	a4, 24
  908d9b:	042202        	or	a2, a2, a4
  908d9e:	229403        	s8i	a2, a9, 3

		if (rcs[series].flags & ATH_RC_HT40_SGI_FLAG)
  908da1:	223003        	l8ui	a2, a3, 3
  908da4:	7d2725        	bbci	a2, 29, 908dcd <ath_tx_status_update_rate+0x85>
			txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_SGI;
  908da7:	088809        	addx2	a8, a8, a8
  908daa:	a858      	add.n	a8, a5, a8
  908dac:	248003        	l8ui	a4, a8, 3
  908daf:	c220      	movi.n	a2, 32
  908db1:	024202        	or	a2, a4, a2
  908db4:	228403        	s8i	a2, a8, 3
  908db7:	600012        	j	908dcd <ath_tx_status_update_rate+0x85>
  908dba:	000008        	add	a0, a0, a0

	} else {
		txs->txstatus[txs->cnt].ts_rate |= SM(rcs[series].rix, ATH9K_HTC_TXSTAT_RATE);
  908dbd:	8809      	l32i.n	a8, a0, 36
  908dbf:	a858      	add.n	a8, a5, a8
  908dc1:	228002        	l8ui	a2, a8, 2
  908dc4:	090943        	extui	a9, a9, 0, 4
  908dc7:	029902        	or	a9, a9, a2
  908dca:	298402        	s8i	a9, a8, 2
	}

	if (rcs[series].flags & ATH_RC_RTSCTS_FLAG)
  908dcd:	223003        	l8ui	a2, a3, 3
  908dd0:	7b2712        	bbci	a2, 27, 908de6 <ath_tx_status_update_rate+0x9e>
		txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_RTC_CTS;
  908dd3:	225000        	l8ui	a2, a5, 0
  908dd6:	022209        	addx2	a2, a2, a2
  908dd9:	a255      	add.n	a5, a5, a2
  908ddb:	235003        	l8ui	a3, a5, 3
  908dde:	c024      	movi.n	a2, 4
  908de0:	023202        	or	a2, a3, a2
  908de3:	225403        	s8i	a2, a5, 3
  908de6:	d10f      	retw.n

00908de8 <ath_rate_attach>:

}

struct ath_ratectrl *
ath_rate_attach(struct ath_softc_tgt *sc)
{
  908de8:	6c1004        	entry	a1, 32
#include "Magpie_api.h"

static inline void *	__adf_os_mem_alloc(adf_os_size_t size)
{
//    return (malloc(size,M_DEVBUF,M_DONTWAIT | M_ZERO));
    return A_ALLOCRAM(size);
  908deb:	137184        	l32r	a3, 8e53fc <memset+0x260>
  908dee:	c0a0      	movi.n	a10, 0
  908df0:	223252        	l32i	a2, a3, 0x148
  908df3:	c1b8      	movi.n	a11, 24
  908df5:	0b2000        	callx8	a2
  908df8:	d2a0      	mov.n	a2, a10
	struct atheros_softc *asc;

	asc = adf_os_mem_alloc(sizeof(struct atheros_softc));
	if (asc == NULL)
  908dfa:	c9a6      	beqz.n	a10, 908e14 <ath_rate_attach+0x2c>

/* set a memory buffer */
static inline void
__adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
{
	A_MEMSET(buf, b, size);
  908dfc:	8334      	l32i.n	a3, a3, 16
  908dfe:	c0b0      	movi.n	a11, 0
  908e00:	c1c8      	movi.n	a12, 24
  908e02:	0b3000        	callx8	a3
		return NULL;

	adf_os_mem_set(asc, 0, sizeof(struct atheros_softc));
	asc->arc.arc_space = sizeof(struct atheros_node);
  908e05:	230a88        	movi	a3, 136
  908e08:	9320      	s32i.n	a3, a2, 0

	ar5416AttachRateTables(asc);
  908e0a:	da20      	mov.n	a10, a2

	asc->tx_chainmask = 1;
  908e0c:	230a01        	movi	a3, 1
		return NULL;

	adf_os_mem_set(asc, 0, sizeof(struct atheros_softc));
	asc->arc.arc_space = sizeof(struct atheros_node);

	ar5416AttachRateTables(asc);
  908e0f:	5807ec        	call8	90adc0 <ar5416AttachRateTables>

	asc->tx_chainmask = 1;
  908e12:	9323      	s32i.n	a3, a2, 12
    
	return &asc->arc;
}
  908e14:	d10f      	retw.n
	...

00908e18 <ath_rate_findrate>:
                  int numRates,
                  int stepDnInc,
                  unsigned int rcflag,
                  struct ath_rc_series series[],
                  int *isProbe)
{
  908e18:	6c1006        	entry	a1, 48
  908e1b:	881f      	l32i.n	a8, a1, 60
	*isProbe = 0;
  908e1d:	c0e0      	movi.n	a14, 0

	if (!numRates || !numTries) {
  908e1f:	c091      	movi.n	a9, 1
                  int stepDnInc,
                  unsigned int rcflag,
                  struct ath_rc_series series[],
                  int *isProbe)
{
	*isProbe = 0;
  908e21:	9e80      	s32i.n	a14, a8, 0

	if (!numRates || !numTries) {
  908e23:	079e38        	moveqz	a14, a9, a7
                  int numRates,
                  int stepDnInc,
                  unsigned int rcflag,
                  struct ath_rc_series series[],
                  int *isProbe)
{
  908e26:	dd70      	mov.n	a13, a7
  908e28:	da20      	mov.n	a10, a2
  908e2a:	db30      	mov.n	a11, a3
  908e2c:	dc60      	mov.n	a12, a6
	*isProbe = 0;

	if (!numRates || !numTries) {
  908e2e:	cde0      	bnez.n	a14, 908e42 <ath_rate_findrate+0x2a>
  908e30:	06e939        	movnez	a9, a14, a6
  908e33:	cc9b      	bnez.n	a9, 908e42 <ath_rate_findrate+0x2a>
	*isProbe = 0;
	if (!numRates || !numTries) {
		return;
	}

	rcRateFind_11n(sc, an, numTries, numRates, stepDnInc, rcflag, series, isProbe);
  908e35:	891e      	l32i.n	a9, a1, 56
  908e37:	8e1c      	l32i.n	a14, a1, 48
  908e39:	8f1d      	l32i.n	a15, a1, 52
  908e3b:	9910      	s32i.n	a9, a1, 0
  908e3d:	9811      	s32i.n	a8, a1, 4
  908e3f:	5bfec8        	call8	908960 <rcRateFind_11n>
  908e42:	d10f      	retw.n

00908e44 <ath_rate_tx_complete>:
ath_rate_tx_complete(struct ath_softc_tgt *sc,
		     struct ath_node_target *an,
		     struct ath_tx_desc *ds,
		     struct ath_rc_series rcs[], 
		     int nframes, int nbad)
{
  908e44:	6c1006        	entry	a1, 48
			 int nframes, int nbad)
{
	int finalTSIdx = ds->ds_txstat.ts_rate;
	int tx_status = 0;

	if ((ds->ds_txstat.ts_status & HAL_TXERR_XRETRY) ||
  908e47:	294066        	l8ui	a9, a4, 102
  908e4a:	c085      	movi.n	a8, 5
  908e4c:	089801        	and	a8, a9, a8
ath_rate_tx_complete(struct ath_softc_tgt *sc,
		     struct ath_node_target *an,
		     struct ath_tx_desc *ds,
		     struct ath_rc_series rcs[], 
		     int nframes, int nbad)
{
  908e4f:	da20      	mov.n	a10, a2
  908e51:	db30      	mov.n	a11, a3
  908e53:	df50      	mov.n	a15, a5
			 struct ath_node_target *an,
			 struct ath_tx_desc *ds,
			 struct ath_rc_series rcs[], 
			 int nframes, int nbad)
{
	int finalTSIdx = ds->ds_txstat.ts_rate;
  908e55:	2d4068        	l8ui	a13, a4, 104

	if ((ds->ds_txstat.ts_status & HAL_TXERR_XRETRY) ||
	    (ds->ds_txstat.ts_status & HAL_TXERR_FIFO) || 
	    (ds->ds_txstat.ts_flags & HAL_TX_DATA_UNDERRUN) ||
	    (ds->ds_txstat.ts_flags & HAL_TX_DELIM_UNDERRUN)) {
		tx_status = 1;
  908e58:	c0e1      	movi.n	a14, 1
			 int nframes, int nbad)
{
	int finalTSIdx = ds->ds_txstat.ts_rate;
	int tx_status = 0;

	if ((ds->ds_txstat.ts_status & HAL_TXERR_XRETRY) ||
  908e5a:	cc8a      	bnez.n	a8, 908e68 <ath_rate_tx_complete+0x24>
	    (ds->ds_txstat.ts_status & HAL_TXERR_FIFO) || 
	    (ds->ds_txstat.ts_flags & HAL_TX_DATA_UNDERRUN) ||
  908e5c:	2c4067        	l8ui	a12, a4, 103
  908e5f:	290a18        	movi	a9, 24
  908e62:	09c901        	and	a9, a12, a9
  908e65:	098e38        	moveqz	a14, a8, a9
	    (ds->ds_txstat.ts_flags & HAL_TX_DELIM_UNDERRUN)) {
		tx_status = 1;
	}

	rcUpdate_11n(sc, an,
  908e68:	2c4073        	l8ui	a12, a4, 115
  908e6b:	9610      	s32i.n	a6, a1, 0
  908e6d:	9711      	s32i.n	a7, a1, 4
  908e6f:	244071        	l8ui	a4, a4, 113
  908e72:	241602        	s32i	a4, a1, 8
  908e75:	5bff67        	call8	908c14 <rcUpdate_11n>
  908e78:	d10f      	retw.n
	...

00908e7c <ath_rate_newassoc>:
}

void
ath_rate_newassoc(struct ath_softc_tgt *sc, struct ath_node_target *an, int isnew, 
		  unsigned int capflag, struct ieee80211_rate *rs)
{
  908e7c:	6c1004        	entry	a1, 32
  908e7f:	da20      	mov.n	a10, a2
  908e81:	db30      	mov.n	a11, a3
  908e83:	dc50      	mov.n	a12, a5
  908e85:	dd60      	mov.n	a13, a6

static void
ath_rate_newassoc_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, int isnew, 
		      unsigned int capflag, struct ieee80211_rate *rs)
{
	if (isnew) {
  908e87:	c841      	beqz.n	a4, 908e8c <ath_rate_newassoc+0x10>
#ifdef MAGPIE_MERLIN
		struct atheros_node *oan = ATH_NODE_ATHEROS(an);
		/* Only MERLIN can send STBC */
		oan->stbc = (capflag & ATH_RC_TX_STBC_FLAG) ? 1 : 0;
#endif
		rcSibUpdate_ht(sc, an, capflag, 0, rs);
  908e89:	5bfde0        	call8	90860c <rcSibUpdate_ht$constprop$9>
  908e8c:	d10f      	retw.n
	...

00908e90 <ath_rate_node_update>:
void ath_rate_node_update(struct ath_softc_tgt *sc,
			  struct ath_node_target *an,
			  a_int32_t isnew,
			  a_uint32_t capflag,
			  struct ieee80211_rate *rs)
{
  908e90:	6c1004        	entry	a1, 32
  908e93:	da20      	mov.n	a10, a2
  908e95:	db30      	mov.n	a11, a3
  908e97:	dc50      	mov.n	a12, a5
  908e99:	dd60      	mov.n	a13, a6

static void
ath_rate_newassoc_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, int isnew, 
		      unsigned int capflag, struct ieee80211_rate *rs)
{
	if (isnew) {
  908e9b:	c841      	beqz.n	a4, 908ea0 <ath_rate_node_update+0x10>
#ifdef MAGPIE_MERLIN
		struct atheros_node *oan = ATH_NODE_ATHEROS(an);
		/* Only MERLIN can send STBC */
		oan->stbc = (capflag & ATH_RC_TX_STBC_FLAG) ? 1 : 0;
#endif
		rcSibUpdate_ht(sc, an, capflag, 0, rs);
  908e9d:	5bfddb        	call8	90860c <rcSibUpdate_ht$constprop$9>
  908ea0:	d10f      	retw.n
	...

00908ea4 <ath_rate_newstate>:
ath_rate_newstate(struct ath_softc_tgt *sc,
		  struct ieee80211vap_target *vap,
		  enum ieee80211_state state,
		  a_uint32_t capflag,
		  struct ieee80211_rate *rs)
{
  908ea4:	6c1004        	entry	a1, 32
	struct ieee80211_node_target *ni = vap->iv_bss;
	struct atheros_softc *asc = (struct atheros_softc *) sc->sc_rc;

	asc->tx_chainmask = sc->sc_ic.ic_tx_chainmask;
  908ea7:	292d16        	addmi	a9, a2, 0x1600
  908eaa:	282248        	l32i	a8, a2, 0x120
  908ead:	299026        	l8ui	a9, a9, 38
		  struct ieee80211vap_target *vap,
		  enum ieee80211_state state,
		  a_uint32_t capflag,
		  struct ieee80211_rate *rs)
{
	struct ieee80211_node_target *ni = vap->iv_bss;
  908eb0:	8b34      	l32i.n	a11, a3, 16
ath_rate_newstate(struct ath_softc_tgt *sc,
		  struct ieee80211vap_target *vap,
		  enum ieee80211_state state,
		  a_uint32_t capflag,
		  struct ieee80211_rate *rs)
{
  908eb2:	da20      	mov.n	a10, a2
	struct ieee80211_node_target *ni = vap->iv_bss;
	struct atheros_softc *asc = (struct atheros_softc *) sc->sc_rc;

	asc->tx_chainmask = sc->sc_ic.ic_tx_chainmask;
  908eb4:	9983      	s32i.n	a9, a8, 12
#ifdef MAGPIE_MERLIN
		struct atheros_node *oan = ATH_NODE_ATHEROS(an);
		/* Only MERLIN can send STBC */
		oan->stbc = (capflag & ATH_RC_TX_STBC_FLAG) ? 1 : 0;
#endif
		rcSibUpdate_ht(sc, an, capflag, 0, rs);
  908eb6:	dc50      	mov.n	a12, a5
  908eb8:	dd60      	mov.n	a13, a6
  908eba:	5bfdd4        	call8	90860c <rcSibUpdate_ht$constprop$9>
  908ebd:	d10f      	retw.n
	...

00908ec0 <__adf_os_mem_copy>:
    //free(buf,M_DEVBUF);
}

/* move a memory buffer */
static inline void 		__adf_os_mem_copy(void *dst, const void *src, adf_os_size_t size)
{
  908ec0:	6c1004        	entry	a1, 32
    A_MEMCPY(dst,src,size);    
  908ec3:	187184        	l32r	a8, 8e54d4 <memset+0x338>
  908ec6:	da20      	mov.n	a10, a2
  908ec8:	8885      	l32i.n	a8, a8, 20
  908eca:	db30      	mov.n	a11, a3
  908ecc:	dc40      	mov.n	a12, a4
  908ece:	0b8000        	callx8	a8
  908ed1:	d10f      	retw.n
	...

00908ed4 <ieee80211_anyhdrsize>:
/*
 * Like ieee80211_hdrsize, but handles any type of frame.
 */
static __inline a_int32_t
ieee80211_anyhdrsize(const void *data)
{
  908ed4:	6c1004        	entry	a1, 32
	const struct ieee80211_frame *wh = data;

	if ((wh->i_fc[0]&IEEE80211_FC0_TYPE_MASK) == IEEE80211_FC0_TYPE_CTL) {
  908ed7:	282000        	l8ui	a8, a2, 0
  908eda:	c09c      	movi.n	a9, 12
  908edc:	098901        	and	a9, a8, a9
  908edf:	69941d        	bnei	a9, 4, 908f00 <ieee80211_anyhdrsize+0x2c>
		switch (wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK) {
  908ee2:	c720      	movi.n	a2, -16
  908ee4:	028801        	and	a8, a8, a2
  908ee7:	288c40        	addi	a8, a8, 64
  908eea:	080847        	extui	a8, a8, 0, 8
  908eed:	c120      	movi.n	a2, 16
  908eef:	78232e        	bltu	a2, a8, 908f21 <ieee80211_anyhdrsize+0x4d>
		series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
	}

	ah->ah_set11nRateScenario(bf->bf_desc, 0, 0, series, 4, 4);
	ath_tgt_txq_add_ucast(sc, bf);
}
  908ef2:	1272bf        	l32r	a2, 8e59f0 <memset+0x854>
  908ef5:	a828      	add.n	a8, a2, a8
  908ef7:	228000        	l8ui	a2, a8, 0
  908efa:	002232        	sext	a2, a2, 7
  908efd:	d10f      	retw.n
  908eff:	002a20        	excw
	const struct ieee80211_frame *wh = data;
	a_int32_t size = sizeof(struct ieee80211_frame);

	/* NB: we don't handle control frames */
	adf_os_assert((wh->i_fc[0]&IEEE80211_FC0_TYPE_MASK) != IEEE80211_FC0_TYPE_CTL);
	if ((wh->i_fc[1] & IEEE80211_FC1_DIR_MASK) == IEEE80211_FC1_DIR_DSTODS)
  908f02:	01c19e        	excw
  908f05:	0a0a41        	extui	a10, a10, 0, 2
 */
static __inline a_int32_t
ieee80211_hdrsize(const void *data)
{
	const struct ieee80211_frame *wh = data;
	a_int32_t size = sizeof(struct ieee80211_frame);
  908f08:	2aacfd        	addi	a10, a10, -3
  908f0b:	c128      	movi.n	a2, 24
  908f0d:	0a9238        	moveqz	a2, a9, a10

	/* NB: we don't handle control frames */
	adf_os_assert((wh->i_fc[0]&IEEE80211_FC0_TYPE_MASK) != IEEE80211_FC0_TYPE_CTL);
	if ((wh->i_fc[1] & IEEE80211_FC1_DIR_MASK) == IEEE80211_FC1_DIR_DSTODS)
		size += IEEE80211_ADDR_LEN;
	if (IEEE80211_QOS_HAS_SEQ(wh))
  908f10:	29fa8c        	movi	a9, -116
  908f13:	098801        	and	a8, a8, a9
		size += sizeof(a_uint16_t);
  908f16:	2a0a88        	movi	a10, 136
  908f19:	b229      	addi.n	a9, a2, 2
  908f1b:	0a880c        	sub	a8, a8, a10
  908f1e:	089238        	moveqz	a2, a9, a8
			return sizeof(struct ieee80211_frame_ack);
		}
		return sizeof(struct ieee80211_frame_min);
	} else
		return ieee80211_hdrsize(data);
}
  908f21:	d10f      	retw.n
	...

00908f24 <owl_tgt_tid_init>:
	ath_rate_findrate(sc, an, 1, frameLen, 10, 4, 1,
			  ATH_RC_PROBE_ALLOWED, series, isProbe);
}

static void owl_tgt_tid_init(struct ath_atx_tid *tid)
{
  908f24:	6c1004        	entry	a1, 32
	int i;

	tid->seq_start  = tid->seq_next = 0;
  908f27:	c090      	movi.n	a9, 0
	tid->baw_size   = WME_MAX_BA;
  908f29:	c480      	movi.n	a8, 64

static void owl_tgt_tid_init(struct ath_atx_tid *tid)
{
	int i;

	tid->seq_start  = tid->seq_next = 0;
  908f2b:	292503        	s16i	a9, a2, 6
  908f2e:	292502        	s16i	a9, a2, 4
	tid->baw_size   = WME_MAX_BA;
  908f31:	282504        	s16i	a8, a2, 8
	tid->baw_head   = tid->baw_tail = 0;
	tid->paused     = 0;
  908f34:	292434        	s8i	a9, a2, 52
{
	int i;

	tid->seq_start  = tid->seq_next = 0;
	tid->baw_size   = WME_MAX_BA;
	tid->baw_head   = tid->baw_tail = 0;
  908f37:	c080      	movi.n	a8, 0
	tid->paused     = 0;
	tid->flag       = 0;
  908f39:	292436        	s8i	a9, a2, 54
	tid->sched      = AH_FALSE;
  908f3c:	292435        	s8i	a9, a2, 53

	asf_tailq_init(&tid->buf_q);
  908f3f:	292c2c        	addi	a9, a2, 44
{
	int i;

	tid->seq_start  = tid->seq_next = 0;
	tid->baw_size   = WME_MAX_BA;
	tid->baw_head   = tid->baw_tail = 0;
  908f42:	9824      	s32i.n	a8, a2, 16
  908f44:	9823      	s32i.n	a8, a2, 12
	tid->paused     = 0;
	tid->flag       = 0;
	tid->sched      = AH_FALSE;

	asf_tailq_init(&tid->buf_q);
  908f46:	982b      	s32i.n	a8, a2, 44
  908f48:	992c      	s32i.n	a9, a2, 48

	for (i = 0; i < ATH_TID_MAX_BUFS; i++) {
		TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, i);
  908f4a:	2d0a01        	movi	a13, 1
  908f4d:	2cfaff        	movi	a12, -1
  908f50:	085912        	srai	a9, a8, 5
  908f53:	b499      	addi.n	a9, a9, 4
  908f55:	02990a        	addx4	a9, a9, a2
  908f58:	008104        	ssl	a8
  908f5b:	00da1a        	sll	a10, a13
  908f5e:	8b91      	l32i.n	a11, a9, 4
  908f60:	0aca03        	xor	a10, a12, a10
  908f63:	0baa01        	and	a10, a10, a11
  908f66:	9a91      	s32i.n	a10, a9, 4
	tid->flag       = 0;
	tid->sched      = AH_FALSE;

	asf_tailq_init(&tid->buf_q);

	for (i = 0; i < ATH_TID_MAX_BUFS; i++) {
  908f68:	b188      	addi.n	a8, a8, 1
  908f6a:	698ee2        	bnei	a8, 128, 908f50 <owl_tgt_tid_init+0x2c>
		TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, i);
	}
}
  908f6d:	d10f      	retw.n
	...

00908f70 <ath_tgt_txq_add_ucast>:

	return 0;
}

static void ath_tgt_txq_add_ucast(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  908f70:	6c1006        	entry	a1, 48
	struct ath_hal *ah = sc->sc_ah;
  908f73:	222d05        	addmi	a2, a2, 0x500
  908f76:	842b      	l32i.n	a4, a2, 44
	struct ath_txq *txq;
	HAL_STATUS status;
	volatile a_int32_t txe_val;

	adf_os_assert(bf);
  908f78:	cc31      	bnez.n	a3, 908f7d <ath_tgt_txq_add_ucast+0xd>
  908f7a:	63fffc        	j	908f7a <ath_tgt_txq_add_ucast+0xa>

	txq = bf->bf_txq;

	status = ah->ah_procTxDesc(ah, bf->bf_lastds);
  908f7d:	28421a        	l32i	a8, a4, 104
  908f80:	8b3e      	l32i.n	a11, a3, 56
  908f82:	da40      	mov.n	a10, a4
	HAL_STATUS status;
	volatile a_int32_t txe_val;

	adf_os_assert(bf);

	txq = bf->bf_txq;
  908f84:	223220        	l32i	a2, a3, 128

	status = ah->ah_procTxDesc(ah, bf->bf_lastds);
  908f87:	0b8000        	callx8	a8

	ATH_TXQ_INSERT_TAIL(txq, bf, bf_list);
  908f8a:	c080      	movi.n	a8, 0
  908f8c:	9839      	s32i.n	a8, a3, 36
  908f8e:	8823      	l32i.n	a8, a2, 12
  908f90:	983a      	s32i.n	a8, a3, 40
  908f92:	9380      	s32i.n	a3, a8, 0
  908f94:	283c24        	addi	a8, a3, 36
  908f97:	9823      	s32i.n	a8, a2, 12
  908f99:	8824      	l32i.n	a8, a2, 16
  908f9b:	9325      	s32i.n	a3, a2, 20
  908f9d:	b188      	addi.n	a8, a8, 1
  908f9f:	9824      	s32i.n	a8, a2, 16

	if (txq->axq_link == NULL) {
  908fa1:	8821      	l32i.n	a8, a2, 4
  908fa3:	cc89      	bnez.n	a8, 908fb0 <ath_tgt_txq_add_ucast+0x40>
		ah->ah_setTxDP(ah, txq->axq_qnum, ATH_BUF_GET_DESC_PHY_ADDR(bf));
  908fa5:	884a      	l32i.n	a8, a4, 40
  908fa7:	da40      	mov.n	a10, a4
  908fa9:	8b20      	l32i.n	a11, a2, 0
  908fab:	8c3c      	l32i.n	a12, a3, 48
  908fad:	600024        	j	908fd5 <ath_tgt_txq_add_ucast+0x65>
	} else {
		*txq->axq_link = ATH_BUF_GET_DESC_PHY_ADDR(bf);
  908fb0:	8c3c      	l32i.n	a12, a3, 48
  908fb2:	9c80      	s32i.n	a12, a8, 0
  908fb4:	187242        	l32r	a8, 8e58bc <memset+0x720>

		txe_val = ioread32_mac(0x0840);
		if (!(txe_val & (1<< txq->axq_qnum)))
  908fb7:	8b20      	l32i.n	a11, a2, 0
  908fb9:	0c0200        	memw
  908fbc:	8880      	l32i.n	a8, a8, 0
	if (txq->axq_link == NULL) {
		ah->ah_setTxDP(ah, txq->axq_qnum, ATH_BUF_GET_DESC_PHY_ADDR(bf));
	} else {
		*txq->axq_link = ATH_BUF_GET_DESC_PHY_ADDR(bf);

		txe_val = ioread32_mac(0x0840);
  908fbe:	0c0200        	memw
  908fc1:	9810      	s32i.n	a8, a1, 0
		if (!(txe_val & (1<< txq->axq_qnum)))
  908fc3:	0c0200        	memw
  908fc6:	8810      	l32i.n	a8, a1, 0
  908fc8:	00b004        	ssr	a11
  908fcb:	08081b        	sra	a8, a8
  908fce:	7f8f06        	bbsi	a8, 31, 908fd8 <ath_tgt_txq_add_ucast+0x68>
			ah->ah_setTxDP(ah, txq->axq_qnum, ATH_BUF_GET_DESC_PHY_ADDR(bf));
  908fd1:	884a      	l32i.n	a8, a4, 40
  908fd3:	da40      	mov.n	a10, a4
  908fd5:	0b8000        	callx8	a8
	}

	txq->axq_link = &bf->bf_lastds->ds_link;
  908fd8:	833e      	l32i.n	a3, a3, 56
	ah->ah_startTxDma(ah, txq->axq_qnum);
  908fda:	8b20      	l32i.n	a11, a2, 0
		txe_val = ioread32_mac(0x0840);
		if (!(txe_val & (1<< txq->axq_qnum)))
			ah->ah_setTxDP(ah, txq->axq_qnum, ATH_BUF_GET_DESC_PHY_ADDR(bf));
	}

	txq->axq_link = &bf->bf_lastds->ds_link;
  908fdc:	9321      	s32i.n	a3, a2, 4
	ah->ah_startTxDma(ah, txq->axq_qnum);
  908fde:	834c      	l32i.n	a3, a4, 48
  908fe0:	da40      	mov.n	a10, a4
  908fe2:	0b3000        	callx8	a3
  908fe5:	d10f      	retw.n
	...

00908fe8 <ath_update_stats>:
			     bf->bf_lastds, bf->bf_rcs, 1, 0);
}

static void
ath_update_stats(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  908fe8:	6c1004        	entry	a1, 32
	struct ath_tx_desc *ds = bf->bf_desc;
  908feb:	883c      	l32i.n	a8, a3, 48
	u_int32_t sr, lr;

	if (ds->ds_txstat.ts_status == 0) {
  908fed:	298066        	l8ui	a9, a8, 102
  908ff0:	cd95      	bnez.n	a9, 909009 <ath_update_stats+0x21>
		if (ds->ds_txstat.ts_rate & HAL_TXSTAT_ALTRATE)
  908ff2:	298068        	l8ui	a9, a8, 104
  908ff5:	009932        	sext	a9, a9, 7
  908ff8:	679042        	bgez	a9, 90903e <ath_update_stats+0x56>
			sc->sc_tx_stats.ast_tx_altrate++;
  908ffb:	292259        	l32i	a9, a2, 0x164
  908ffe:	b199      	addi.n	a9, a9, 1
  909000:	292659        	s32i	a9, a2, 0x164
  909003:	600037        	j	90903e <ath_update_stats+0x56>
  909006:	000000        	ill
	} else {
		if (ds->ds_txstat.ts_status & HAL_TXERR_XRETRY)
  909009:	7f9707        	bbci	a9, 31, 909014 <ath_update_stats+0x2c>
			sc->sc_tx_stats.ast_tx_xretries++;
  90900c:	292252        	l32i	a9, a2, 0x148
  90900f:	b199      	addi.n	a9, a9, 1
  909011:	292652        	s32i	a9, a2, 0x148
		if (ds->ds_txstat.ts_status & HAL_TXERR_FIFO)
  909014:	298066        	l8ui	a9, a8, 102
  909017:	7d9707        	bbci	a9, 29, 909022 <ath_update_stats+0x3a>
			sc->sc_tx_stats.ast_tx_fifoerr++;
  90901a:	292253        	l32i	a9, a2, 0x14c
  90901d:	b199      	addi.n	a9, a9, 1
  90901f:	292653        	s32i	a9, a2, 0x14c
		if (ds->ds_txstat.ts_status & HAL_TXERR_FILT)
  909022:	298066        	l8ui	a9, a8, 102
  909025:	7e9707        	bbci	a9, 30, 909030 <ath_update_stats+0x48>
			sc->sc_tx_stats.ast_tx_filtered++;
  909028:	292254        	l32i	a9, a2, 0x150
  90902b:	b199      	addi.n	a9, a9, 1
  90902d:	292654        	s32i	a9, a2, 0x150
		if (ds->ds_txstat.ts_status & HAL_TXERR_TIMER_EXPIRED)
  909030:	298066        	l8ui	a9, a8, 102
  909033:	7b9707        	bbci	a9, 27, 90903e <ath_update_stats+0x56>
			sc->sc_tx_stats.ast_tx_timer_exp++;
  909036:	292255        	l32i	a9, a2, 0x154
  909039:	b199      	addi.n	a9, a9, 1
  90903b:	292655        	s32i	a9, a2, 0x154
	}
	sr = ds->ds_txstat.ts_shortretry;
	lr = ds->ds_txstat.ts_longretry;
  90903e:	298071        	l8ui	a9, a8, 113
	sc->sc_tx_stats.ast_tx_shortretry += sr;
  909041:	2a2256        	l32i	a10, a2, 0x158
		if (ds->ds_txstat.ts_status & HAL_TXERR_FILT)
			sc->sc_tx_stats.ast_tx_filtered++;
		if (ds->ds_txstat.ts_status & HAL_TXERR_TIMER_EXPIRED)
			sc->sc_tx_stats.ast_tx_timer_exp++;
	}
	sr = ds->ds_txstat.ts_shortretry;
  909044:	288070        	l8ui	a8, a8, 112
	lr = ds->ds_txstat.ts_longretry;
	sc->sc_tx_stats.ast_tx_shortretry += sr;
  909047:	a8a8      	add.n	a8, a10, a8
  909049:	282656        	s32i	a8, a2, 0x158
	sc->sc_tx_stats.ast_tx_longretry += lr;
  90904c:	282257        	l32i	a8, a2, 0x15c
  90904f:	a988      	add.n	a8, a8, a9
  909051:	282657        	s32i	a8, a2, 0x15c
  909054:	d10f      	retw.n
	...

00909058 <ath_tx_update_baw>:
	ath_tgt_tx_enqueue(txq, tid);
}

static void
ath_tx_update_baw(ath_atx_tid_t *tid, int seqno)
{
  909058:	6c1004        	entry	a1, 32
	int index;
	int cindex;

	index  = ATH_BA_INDEX(tid->seq_start, seqno);
  90905b:	2a2102        	l16ui	a10, a2, 4
	cindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);
  90905e:	8823      	l32i.n	a8, a2, 12
ath_tx_update_baw(ath_atx_tid_t *tid, int seqno)
{
	int index;
	int cindex;

	index  = ATH_BA_INDEX(tid->seq_start, seqno);
  909060:	0a330c        	sub	a3, a3, a10
  909063:	030a4b        	extui	a10, a3, 0, 12
	cindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);
  909066:	a8aa      	add.n	a10, a10, a8

	TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, cindex);
  909068:	0a5941        	extui	a9, a10, 5, 2
  90906b:	c081      	movi.n	a8, 1
  90906d:	b499      	addi.n	a9, a9, 4
  90906f:	02990a        	addx4	a9, a9, a2
  909072:	c7bf      	movi.n	a11, -1
  909074:	00a104        	ssl	a10
  909077:	008a1a        	sll	a10, a8
  90907a:	0aba03        	xor	a10, a11, a10
  90907d:	8b91      	l32i.n	a11, a9, 4

	while (tid->baw_head != tid->baw_tail &&
  90907f:	8c24      	l32i.n	a12, a2, 16
	int cindex;

	index  = ATH_BA_INDEX(tid->seq_start, seqno);
	cindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);

	TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, cindex);
  909081:	0baa01        	and	a10, a10, a11
  909084:	9a91      	s32i.n	a10, a9, 4

	while (tid->baw_head != tid->baw_tail &&
	       (!TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head))) {
  909086:	db80      	mov.n	a11, a8
	index  = ATH_BA_INDEX(tid->seq_start, seqno);
	cindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);

	TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, cindex);

	while (tid->baw_head != tid->baw_tail &&
  909088:	600012        	j	90909e <ath_tx_update_baw+0x46>
  90908b:	002921        	excw
	       (!TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head))) {
		INCR(tid->seq_start, IEEE80211_SEQ_MAX);
  90908e:	02b188        	excw
  909091:	b199      	addi.n	a9, a9, 1
  909093:	09094b        	extui	a9, a9, 0, 12
		INCR(tid->baw_head, ATH_TID_MAX_BUFS);
  909096:	080846        	extui	a8, a8, 0, 7

	TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, cindex);

	while (tid->baw_head != tid->baw_tail &&
	       (!TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head))) {
		INCR(tid->seq_start, IEEE80211_SEQ_MAX);
  909099:	292502        	s16i	a9, a2, 4
		INCR(tid->baw_head, ATH_TID_MAX_BUFS);
  90909c:	9823      	s32i.n	a8, a2, 12
	index  = ATH_BA_INDEX(tid->seq_start, seqno);
	cindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);

	TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, cindex);

	while (tid->baw_head != tid->baw_tail &&
  90909e:	8823      	l32i.n	a8, a2, 12
  9090a0:	7c8110        	beq	a8, a12, 9090b4 <ath_tx_update_baw+0x5c>
	       (!TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head))) {
  9090a3:	085912        	srai	a9, a8, 5
  9090a6:	02990a        	addx4	a9, a9, a2
  9090a9:	8995      	l32i.n	a9, a9, 20
  9090ab:	008104        	ssl	a8
  9090ae:	00ba1a        	sll	a10, a11
	index  = ATH_BA_INDEX(tid->seq_start, seqno);
	cindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);

	TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, cindex);

	while (tid->baw_head != tid->baw_tail &&
  9090b1:	79a0d7        	bnone	a10, a9, 90908c <ath_tx_update_baw+0x34>
  9090b4:	d10f      	retw.n
	...

009090b8 <ath_dma_unmap>:
	skb = adf_nbuf_queue_first(&bf->bf_skbhead);
	adf_nbuf_map(sc->sc_dev, bf->bf_dmamap, skb, ADF_OS_DMA_TO_DEVICE);
}

static void ath_dma_unmap(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  9090b8:	6c1004        	entry	a1, 32
 * @return first buffer in queue
 */
static inline adf_nbuf_t 
adf_nbuf_queue_first(adf_nbuf_queue_t *head)
{
    return (__adf_nbuf_queue_first(head));
  9090bb:	2a3c14        	addi	a10, a3, 20
  9090be:	5be984        	call8	9036d0 <__adf_nbuf_queue_first>
static inline void
adf_nbuf_unmap(adf_os_device_t      osdev, 
               adf_os_dma_map_t     bmap, 
               adf_os_dma_dir_t     dir)
{
    __adf_nbuf_unmap(osdev, bmap, dir);
  9090c1:	2a2246        	l32i	a10, a2, 0x118
  9090c4:	8b30      	l32i.n	a11, a3, 0
  9090c6:	2c0a00        	movi	a12, 0
  9090c9:	5be907        	call8	9034e8 <__adf_nbuf_unmap>
  9090cc:	d10f      	retw.n
	...

009090d0 <ath_tgt_skb_free>:
}

static void ath_tgt_skb_free(struct ath_softc_tgt *sc,
			     adf_nbuf_queue_t *head,
			     HTC_ENDPOINT_ID endpt)
{
  9090d0:	6c1004        	entry	a1, 32
	adf_nbuf_t tskb;

	while (adf_nbuf_queue_len(head) != 0) {
		tskb = adf_nbuf_queue_remove(head);
		ath_free_tx_skb(sc->tgt_htc_handle,endpt,tskb);
  9090d3:	157184        	l32r	a5, 8e56e4 <memset+0x548>
			     adf_nbuf_queue_t *head,
			     HTC_ENDPOINT_ID endpt)
{
	adf_nbuf_t tskb;

	while (adf_nbuf_queue_len(head) != 0) {
  9090d6:	600012        	j	9090ec <ath_tgt_skb_free+0x1c>
 * @return The head buf in the buf queue.
 */
static inline adf_nbuf_t
adf_nbuf_queue_remove(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_remove(head);
  9090d9:	da30      	mov.n	a10, a3
  9090db:	5be8ef        	call8	903498 <__adf_nbuf_queue_remove>
  9090de:	dca0      	mov.n	a12, a10
		tskb = adf_nbuf_queue_remove(head);
		ath_free_tx_skb(sc->tgt_htc_handle,endpt,tskb);
  9090e0:	285287        	l32i	a8, a5, 0x21c
  9090e3:	2a2202        	l32i	a10, a2, 8
  9090e6:	044b02        	or	a11, a4, a4
  9090e9:	0b8000        	callx8	a8
 * @return length of the queue
 */
static inline a_uint32_t
adf_nbuf_queue_len(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_len(head);
  9090ec:	da30      	mov.n	a10, a3
  9090ee:	5be976        	call8	9036c8 <__adf_nbuf_queue_len>
			     adf_nbuf_queue_t *head,
			     HTC_ENDPOINT_ID endpt)
{
	adf_nbuf_t tskb;

	while (adf_nbuf_queue_len(head) != 0) {
  9090f1:	65afe4        	bnez	a10, 9090d9 <ath_tgt_skb_free+0x9>
		tskb = adf_nbuf_queue_remove(head);
		ath_free_tx_skb(sc->tgt_htc_handle,endpt,tskb);
	}
}
  9090f4:	d10f      	retw.n
	...

009090f8 <ath_filltxdesc>:
	skb = adf_nbuf_queue_first(&bf->bf_skbhead);
	adf_nbuf_unmap( sc->sc_dev, bf->bf_dmamap, ADF_OS_DMA_TO_DEVICE);
}

static void ath_filltxdesc(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  9090f8:	6c1004        	entry	a1, 32
	struct ath_tx_desc *ds0, *ds = bf->bf_desc;
  9090fb:	863c      	l32i.n	a6, a3, 48
 * @param[out] sg   map info
 */
static inline void
adf_nbuf_dmamap_info(adf_os_dma_map_t bmap, adf_os_dmamap_info_t *sg)
{
    __adf_nbuf_dmamap_info(bmap, sg);
  9090fd:	8a30      	l32i.n	a10, a3, 0
	struct ath_hal *ah = sc->sc_ah;
  9090ff:	222d05        	addmi	a2, a2, 0x500
  909102:	b43b      	addi.n	a11, a3, 4
	a_uint8_t i;

	ds0 = ds;
	adf_nbuf_dmamap_info(bf->bf_dmamap, &bf->bf_dmamap_info);

	for (i = 0; i < bf->bf_dmamap_info.nsegs; i++, ds++) {
  909104:	c040      	movi.n	a4, 0
}

static void ath_filltxdesc(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_tx_desc *ds0, *ds = bf->bf_desc;
	struct ath_hal *ah = sc->sc_ah;
  909106:	872b      	l32i.n	a7, a2, 44
	ds0 = ds;
	adf_nbuf_dmamap_info(bf->bf_dmamap, &bf->bf_dmamap_info);

	for (i = 0; i < bf->bf_dmamap_info.nsegs; i++, ds++) {

		ds->ds_data = bf->bf_dmamap_info.dma_segs[i].paddr;
  909108:	d540      	mov.n	a5, a4
  90910a:	5be8fc        	call8	9034fc <__adf_nbuf_dmamap_info>
	adf_nbuf_unmap( sc->sc_dev, bf->bf_dmamap, ADF_OS_DMA_TO_DEVICE);
}

static void ath_filltxdesc(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_tx_desc *ds0, *ds = bf->bf_desc;
  90910d:	d260      	mov.n	a2, a6
	a_uint8_t i;

	ds0 = ds;
	adf_nbuf_dmamap_info(bf->bf_dmamap, &bf->bf_dmamap_info);

	for (i = 0; i < bf->bf_dmamap_info.nsegs; i++, ds++) {
  90910f:	600081        	j	909194 <ath_filltxdesc+0x9c>
  909112:	000003        	xor	a0, a0, a0

		ds->ds_data = bf->bf_dmamap_info.dma_segs[i].paddr;
  909115:	480b2a        	excw
  909118:	8008      	l32i.n	a0, a0, 32

		if (i == (bf->bf_dmamap_info.nsegs - 1)) {
  90911a:	b099      	addi.n	a9, a9, -1
	ds0 = ds;
	adf_nbuf_dmamap_info(bf->bf_dmamap, &bf->bf_dmamap_info);

	for (i = 0; i < bf->bf_dmamap_info.nsegs; i++, ds++) {

		ds->ds_data = bf->bf_dmamap_info.dma_segs[i].paddr;
  90911c:	2a2404        	s8i	a10, a2, 4
  90911f:	2a8009        	l8ui	a10, a8, 9
  909122:	2a2405        	s8i	a10, a2, 5
  909125:	2a800a        	l8ui	a10, a8, 10
  909128:	2a2406        	s8i	a10, a2, 6
  90912b:	28800b        	l8ui	a8, a8, 11
  90912e:	282407        	s8i	a8, a2, 7

		if (i == (bf->bf_dmamap_info.nsegs - 1)) {
  909131:	794910        	bne	a4, a9, 909145 <ath_filltxdesc+0x4d>
			ds->ds_link = 0;
  909134:	252400        	s8i	a5, a2, 0
  909137:	252401        	s8i	a5, a2, 1
  90913a:	252402        	s8i	a5, a2, 2
  90913d:	252403        	s8i	a5, a2, 3
			bf->bf_lastds = ds;
  909140:	923e      	s32i.n	a2, a3, 56
  909142:	600020        	j	909166 <ath_filltxdesc+0x6e>
		} else
			ds->ds_link = ATH_BUF_GET_DESC_PHY_ADDR_WITH_IDX(bf, i+1);
  909145:	b148      	addi.n	a8, a4, 1
  909147:	0c8911        	slli	a9, a8, 4
  90914a:	a898      	add.n	a8, a9, a8
  90914c:	893d      	l32i.n	a9, a3, 52
  90914e:	09880b        	addx8	a8, a8, a9
  909151:	088957        	extui	a9, a8, 24, 8
  909154:	292400        	s8i	a9, a2, 0
  909157:	080957        	extui	a9, a8, 16, 8
  90915a:	292401        	s8i	a9, a2, 1
  90915d:	088947        	extui	a9, a8, 8, 8
  909160:	292402        	s8i	a9, a2, 2
  909163:	282403        	s8i	a8, a2, 3

		ah->ah_fillTxDesc(ds
				   , bf->bf_dmamap_info.dma_segs[i].len
				   , i == 0
				   , i == (bf->bf_dmamap_info.nsegs - 1)
  909166:	8d31      	l32i.n	a13, a3, 4
			ds->ds_link = 0;
			bf->bf_lastds = ds;
		} else
			ds->ds_link = ATH_BUF_GET_DESC_PHY_ADDR_WITH_IDX(bf, i+1);

		ah->ah_fillTxDesc(ds
  909168:	c091      	movi.n	a9, 1
				   , bf->bf_dmamap_info.dma_segs[i].len
				   , i == 0
				   , i == (bf->bf_dmamap_info.nsegs - 1)
  90916a:	b0dd      	addi.n	a13, a13, -1
			ds->ds_link = 0;
			bf->bf_lastds = ds;
		} else
			ds->ds_link = ATH_BUF_GET_DESC_PHY_ADDR_WITH_IDX(bf, i+1);

		ah->ah_fillTxDesc(ds
  90916c:	0d4d0c        	sub	a13, a4, a13
  90916f:	034b0b        	addx8	a11, a4, a3
  909172:	c080      	movi.n	a8, 0
  909174:	dc80      	mov.n	a12, a8
  909176:	2f7218        	l32i	a15, a7, 96
  909179:	0d9838        	moveqz	a8, a9, a13
  90917c:	8bb3      	l32i.n	a11, a11, 12
  90917e:	049c38        	moveqz	a12, a9, a4
  909181:	dd80      	mov.n	a13, a8
  909183:	da20      	mov.n	a10, a2
  909185:	de60      	mov.n	a14, a6
  909187:	0bf000        	callx8	a15
	a_uint8_t i;

	ds0 = ds;
	adf_nbuf_dmamap_info(bf->bf_dmamap, &bf->bf_dmamap_info);

	for (i = 0; i < bf->bf_dmamap_info.nsegs; i++, ds++) {
  90918a:	b144      	addi.n	a4, a4, 1
  90918c:	280a88        	movi	a8, 136
  90918f:	040447        	extui	a4, a4, 0, 8
  909192:	a822      	add.n	a2, a2, a8
  909194:	8931      	l32i.n	a9, a3, 4
  909196:	794b02        	bgeu	a4, a9, 90919c <ath_filltxdesc+0xa4>
  909199:	63ff77        	j	909114 <ath_filltxdesc+0x1c>
				   , bf->bf_dmamap_info.dma_segs[i].len
				   , i == 0
				   , i == (bf->bf_dmamap_info.nsegs - 1)
				   , ds0);
	}
}
  90919c:	d10f      	retw.n
	...

009091a0 <ath_tx_tgt_setds>:

static void ath_tx_tgt_setds(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  9091a0:	6c1006        	entry	a1, 48
	struct ath_tx_desc *ds = bf->bf_desc;
	struct ath_hal *ah = sc->sc_ah;

	switch (bf->bf_protmode) {
  9091a3:	293084        	l8ui	a9, a3, 132
}

static void ath_tx_tgt_setds(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_tx_desc *ds = bf->bf_desc;
	struct ath_hal *ah = sc->sc_ah;
  9091a6:	282d05        	addmi	a8, a2, 0x500
  9091a9:	8d8b      	l32i.n	a13, a8, 44
	}
}

static void ath_tx_tgt_setds(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_tx_desc *ds = bf->bf_desc;
  9091ab:	8a3c      	l32i.n	a10, a3, 48
  9091ad:	283144        	l16ui	a8, a3, 136
	struct ath_hal *ah = sc->sc_ah;

	switch (bf->bf_protmode) {
  9091b0:	689108        	beqi	a9, 1, 9091bc <ath_tx_tgt_setds+0x1c>
  9091b3:	69920d        	bnei	a9, 2, 9091c4 <ath_tx_tgt_setds+0x24>
    	case IEEE80211_PROT_RTSCTS:
		bf->bf_flags |= HAL_TXDESC_RTSENA;
  9091b6:	c094      	movi.n	a9, 4
  9091b8:	600002        	j	9091be <ath_tx_tgt_setds+0x1e>
  9091bb:	00c098        	excw
		break;
    	case IEEE80211_PROT_CTSONLY:
		bf->bf_flags |= HAL_TXDESC_CTSENA;
  9091be:	098802        	or	a8, a8, a9
  9091c1:	283544        	s16i	a8, a3, 136
		break;
    	default:
		break;
	}

	ah->ah_set11nTxDesc(ds
  9091c4:	293144        	l16ui	a9, a3, 136
  9091c7:	c180      	movi.n	a8, 16
  9091c9:	089802        	or	a8, a9, a8
  9091cc:	08084f        	extui	a8, a8, 0, 16
  9091cf:	9810      	s32i.n	a8, a1, 0
  9091d1:	2b3122        	l16ui	a11, a3, 68
  9091d4:	88df      	l32i.n	a8, a13, 60
  9091d6:	2c304a        	l8ui	a12, a3, 74
  9091d9:	2e3049        	l8ui	a14, a3, 73
  9091dc:	2f3085        	l8ui	a15, a3, 133
  9091df:	2d0a3c        	movi	a13, 60
  9091e2:	0b8000        	callx8	a8
			      , 60
			      , bf->bf_keyix
			      , bf->bf_keytype
			      , bf->bf_flags | HAL_TXDESC_INTREQ);

	ath_filltxdesc(sc, bf);
  9091e5:	da20      	mov.n	a10, a2
  9091e7:	db30      	mov.n	a11, a3
  9091e9:	5bffc3        	call8	9090f8 <ath_filltxdesc>
  9091ec:	d10f      	retw.n
	...

009091f0 <ath_tgt_tx_enqueue>:
	ath_tgt_tx_send_normal(sc, bf);
}

static void
ath_tgt_tx_enqueue(struct ath_txq *txq, struct ath_atx_tid  *tid)
{
  9091f0:	6c1004        	entry	a1, 32
	if (tid->paused)
  9091f3:	283034        	l8ui	a8, a3, 52
  9091f6:	cd88      	bnez.n	a8, 909212 <ath_tgt_tx_enqueue+0x22>
		return;

	if (tid->sched)
  9091f8:	283035        	l8ui	a8, a3, 53
  9091fb:	008832        	sext	a8, a8, 7
  9091fe:	cd80      	bnez.n	a8, 909212 <ath_tgt_tx_enqueue+0x22>
		return;

	tid->sched = AH_TRUE;
  909200:	c091      	movi.n	a9, 1
  909202:	293435        	s8i	a9, a3, 53
	asf_tailq_insert_tail(&txq->axq_tidq, tid, tid_qelem);
  909205:	9839      	s32i.n	a8, a3, 36
  909207:	8827      	l32i.n	a8, a2, 28
  909209:	983a      	s32i.n	a8, a3, 40
  90920b:	9380      	s32i.n	a3, a8, 0
  90920d:	233c24        	addi	a3, a3, 36
  909210:	9327      	s32i.n	a3, a2, 28
  909212:	d10f      	retw.n

00909214 <ath_update_aggr_stats$isra$2>:
	ath_tx_set_retry(sc, bf);
	asf_tailq_insert_tail(bf_q, bf, bf_list);
}

static void
ath_update_aggr_stats(struct ath_softc_tgt *sc,
  909214:	6c1004        	entry	a1, 32
{

	u_int8_t status = ATH_DS_TX_STATUS(ds);
	u_int8_t txflags = ATH_DS_TX_FLAGS(ds);

	__statsn(sc, txaggr_longretries, ds->ds_txstat.ts_longretry);
  909217:	2a3071        	l8ui	a10, a3, 113
  90921a:	2b2268        	l32i	a11, a2, 0x1a0
ath_update_aggr_stats(struct ath_softc_tgt *sc,
		      struct ath_tx_desc *ds, int nframes,
		      int nbad)
{

	u_int8_t status = ATH_DS_TX_STATUS(ds);
  90921d:	283066        	l8ui	a8, a3, 102
	u_int8_t txflags = ATH_DS_TX_FLAGS(ds);

	__statsn(sc, txaggr_longretries, ds->ds_txstat.ts_longretry);
  909220:	0aba08        	add	a10, a11, a10
		      struct ath_tx_desc *ds, int nframes,
		      int nbad)
{

	u_int8_t status = ATH_DS_TX_STATUS(ds);
	u_int8_t txflags = ATH_DS_TX_FLAGS(ds);
  909223:	293067        	l8ui	a9, a3, 103

	__statsn(sc, txaggr_longretries, ds->ds_txstat.ts_longretry);
  909226:	2a2668        	s32i	a10, a2, 0x1a0
	__statsn(sc, txaggr_shortretries, ds->ds_txstat.ts_shortretry);
  909229:	233070        	l8ui	a3, a3, 112
  90922c:	2a226b        	l32i	a10, a2, 0x1ac
  90922f:	03a308        	add	a3, a10, a3
  909232:	23266b        	s32i	a3, a2, 0x1ac

	if (txflags & HAL_TX_DESC_CFG_ERR)
  909235:	7d9708        	bbci	a9, 29, 909241 <ath_update_aggr_stats$isra$2+0x2d>
		__stats(sc, txaggr_desc_cfgerr);
  909238:	232271        	l32i	a3, a2, 0x1c4
  90923b:	233c01        	addi	a3, a3, 1
  90923e:	232671        	s32i	a3, a2, 0x1c4

	if (txflags & HAL_TX_DATA_UNDERRUN)
  909241:	7c9708        	bbci	a9, 28, 90924d <ath_update_aggr_stats$isra$2+0x39>
		__stats(sc, txaggr_data_urun);
  909244:	232265        	l32i	a3, a2, 0x194
  909247:	233c01        	addi	a3, a3, 1
  90924a:	232665        	s32i	a3, a2, 0x194

	if (txflags & HAL_TX_DELIM_UNDERRUN)
  90924d:	7b9707        	bbci	a9, 27, 909258 <ath_update_aggr_stats$isra$2+0x44>
		__stats(sc, txaggr_delim_urun);
  909250:	232266        	l32i	a3, a2, 0x198
  909253:	b133      	addi.n	a3, a3, 1
  909255:	232666        	s32i	a3, a2, 0x198

	if (!status) {
  909258:	cb88      	beqz.n	a8, 909294 <ath_update_aggr_stats$isra$2+0x80>
		return;
	}

	if (status & HAL_TXERR_XRETRY)
  90925a:	7f8707        	bbci	a8, 31, 909265 <ath_update_aggr_stats$isra$2+0x51>
		__stats(sc, txaggr_compxretry);
  90925d:	23226a        	l32i	a3, a2, 0x1a8
  909260:	b133      	addi.n	a3, a3, 1
  909262:	23266a        	s32i	a3, a2, 0x1a8

	if (status & HAL_TXERR_FILT)
  909265:	7e8708        	bbci	a8, 30, 909271 <ath_update_aggr_stats$isra$2+0x5d>
		__stats(sc, txaggr_filtered);
  909268:	23226e        	l32i	a3, a2, 0x1b8
  90926b:	233c01        	addi	a3, a3, 1
  90926e:	23266e        	s32i	a3, a2, 0x1b8

	if (status & HAL_TXERR_FIFO)
  909271:	7d8708        	bbci	a8, 29, 90927d <ath_update_aggr_stats$isra$2+0x69>
		__stats(sc, txaggr_fifo);
  909274:	23226f        	l32i	a3, a2, 0x1bc
  909277:	233c01        	addi	a3, a3, 1
  90927a:	23266f        	s32i	a3, a2, 0x1bc

	if (status & HAL_TXERR_XTXOP)
  90927d:	7c8708        	bbci	a8, 28, 909289 <ath_update_aggr_stats$isra$2+0x75>
		__stats(sc, txaggr_xtxop);
  909280:	232270        	l32i	a3, a2, 0x1c0
  909283:	233c01        	addi	a3, a3, 1
  909286:	232670        	s32i	a3, a2, 0x1c0

	if (status & HAL_TXERR_TIMER_EXPIRED)
  909289:	7b8707        	bbci	a8, 27, 909294 <ath_update_aggr_stats$isra$2+0x80>
		__stats(sc, txaggr_timer_exp);
  90928c:	23226c        	l32i	a3, a2, 0x1b0
  90928f:	b133      	addi.n	a3, a3, 1
  909291:	23266c        	s32i	a3, a2, 0x1b0
  909294:	d10f      	retw.n
	...

00909298 <__adf_os_mem_set$constprop$13>:
}

/* set a memory buffer */
static inline void
__adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
  909298:	6c1004        	entry	a1, 32
{
	A_MEMSET(buf, b, size);
  90929b:	187184        	l32r	a8, 8e58ac <memset+0x710>
  90929e:	da20      	mov.n	a10, a2
  9092a0:	8884      	l32i.n	a8, a8, 16
  9092a2:	c0b0      	movi.n	a11, 0
  9092a4:	dc30      	mov.n	a12, a3
  9092a6:	0b8000        	callx8	a8
  9092a9:	d10f      	retw.n
	...

009092ac <ath_buf_set_rate>:
		asf_tailq_insert_tail(&sc->sc_txbuf, bf, bf_list);
	}
}

static void ath_buf_set_rate(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  9092ac:	6c1012        	entry	a1, 144
    a_int32_t prot_mode = AH_FALSE;

    rt = sc->sc_currates;
    rix = bf->bf_rcs[0].rix;
    flags = (bf->bf_flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA));
    cix = rt->info[sc->sc_protrix].controlRate;
  9092af:	272d03        	addmi	a7, a2, 0x300
  9092b2:	27700c        	l8ui	a7, a7, 12
	}
}

static void ath_buf_set_rate(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
    struct ath_hal *ah = sc->sc_ah;
  9092b5:	242d05        	addmi	a4, a2, 0x500
    HAL_11N_RATE_SERIES series[4];
    a_int32_t i, flags;
    a_uint8_t rix, cix, rtsctsrate;
    a_int32_t prot_mode = AH_FALSE;

    rt = sc->sc_currates;
  9092b8:	252281        	l32i	a5, a2, 0x204
    rix = bf->bf_rcs[0].rix;
    flags = (bf->bf_flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA));
    cix = rt->info[sc->sc_protrix].controlRate;
  9092bb:	b277      	addi.n	a7, a7, 2
	}
}

static void ath_buf_set_rate(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
    struct ath_hal *ah = sc->sc_ah;
  9092bd:	844b      	l32i.n	a4, a4, 44
    a_int32_t prot_mode = AH_FALSE;

    rt = sc->sc_currates;
    rix = bf->bf_rcs[0].rix;
    flags = (bf->bf_flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA));
    cix = rt->info[sc->sc_protrix].controlRate;
  9092bf:	0c7711        	slli	a7, a7, 4
  9092c2:	a757      	add.n	a7, a5, a7
  9092c4:	297013        	l8ui	a9, a7, 19
	}
}

static void ath_buf_set_rate(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
    struct ath_hal *ah = sc->sc_ah;
  9092c7:	241615        	s32i	a4, a1, 84
    const HAL_RATE_TABLE *rt;
    struct ath_tx_desc *ds = bf->bf_desc;
  9092ca:	843c      	l32i.n	a4, a3, 48
    a_uint8_t rix, cix, rtsctsrate;
    a_int32_t prot_mode = AH_FALSE;

    rt = sc->sc_currates;
    rix = bf->bf_rcs[0].rix;
    flags = (bf->bf_flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA));
  9092cc:	283144        	l16ui	a8, a3, 136
    cix = rt->info[sc->sc_protrix].controlRate;

    if (bf->bf_protmode != IEEE80211_PROT_NONE &&
  9092cf:	273084        	l8ui	a7, a3, 132

static void ath_buf_set_rate(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
    struct ath_hal *ah = sc->sc_ah;
    const HAL_RATE_TABLE *rt;
    struct ath_tx_desc *ds = bf->bf_desc;
  9092d2:	241616        	s32i	a4, a1, 88
    a_uint8_t rix, cix, rtsctsrate;
    a_int32_t prot_mode = AH_FALSE;

    rt = sc->sc_currates;
    rix = bf->bf_rcs[0].rix;
    flags = (bf->bf_flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA));
  9092d5:	c06c      	movi.n	a6, 12
    cix = rt->info[sc->sc_protrix].controlRate;
  9092d7:	291614        	s32i	a9, a1, 80
    a_int32_t i, flags;
    a_uint8_t rix, cix, rtsctsrate;
    a_int32_t prot_mode = AH_FALSE;

    rt = sc->sc_currates;
    rix = bf->bf_rcs[0].rix;
  9092da:	243050        	l8ui	a4, a3, 80
    flags = (bf->bf_flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA));
  9092dd:	068601        	and	a6, a8, a6
    cix = rt->info[sc->sc_protrix].controlRate;

    if (bf->bf_protmode != IEEE80211_PROT_NONE &&
  9092e0:	ca71      	beqz.n	a7, 909305 <ath_buf_set_rate+0x59>
	(rt->info[rix].phy == IEEE80211_T_OFDM ||
  9092e2:	b244      	addi.n	a4, a4, 2
  9092e4:	0c4411        	slli	a4, a4, 4
  9092e7:	a454      	add.n	a4, a5, a4
  9092e9:	294009        	l8ui	a9, a4, 9
  9092ec:	c071      	movi.n	a7, 1
  9092ee:	2a9cfc        	addi	a10, a9, -4
  9092f1:	c040      	movi.n	a4, 0
  9092f3:	0a7438        	moveqz	a4, a7, a10
    rt = sc->sc_currates;
    rix = bf->bf_rcs[0].rix;
    flags = (bf->bf_flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA));
    cix = rt->info[sc->sc_protrix].controlRate;

    if (bf->bf_protmode != IEEE80211_PROT_NONE &&
  9092f6:	cc46      	bnez.n	a4, 909300 <ath_buf_set_rate+0x54>
	(rt->info[rix].phy == IEEE80211_T_OFDM ||
  9092f8:	299cfe        	addi	a9, a9, -2
    rt = sc->sc_currates;
    rix = bf->bf_rcs[0].rix;
    flags = (bf->bf_flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA));
    cix = rt->info[sc->sc_protrix].controlRate;

    if (bf->bf_protmode != IEEE80211_PROT_NONE &&
  9092fb:	097438        	moveqz	a4, a7, a9
  9092fe:	c843      	beqz.n	a4, 909305 <ath_buf_set_rate+0x59>
	(rt->info[rix].phy == IEEE80211_T_OFDM ||
	 rt->info[rix].phy == IEEE80211_T_HT) &&
	(bf->bf_flags & HAL_TXDESC_NOACK) == 0) {
	    cix = rt->info[sc->sc_protrix].controlRate;
	    prot_mode = AH_TRUE;
  909300:	c071      	movi.n	a7, 1
    flags = (bf->bf_flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA));
    cix = rt->info[sc->sc_protrix].controlRate;

    if (bf->bf_protmode != IEEE80211_PROT_NONE &&
	(rt->info[rix].phy == IEEE80211_T_OFDM ||
	 rt->info[rix].phy == IEEE80211_T_HT) &&
  909302:	7e8744        	bbci	a8, 30, 90934a <ath_buf_set_rate+0x9e>
	(bf->bf_flags & HAL_TXDESC_NOACK) == 0) {
	    cix = rt->info[sc->sc_protrix].controlRate;
	    prot_mode = AH_TRUE;
    } else {
	    if (ath_hal_getcapability(ah, HAL_CAP_HT) && (!bf->bf_ismcast))
  909305:	2a1215        	l32i	a10, a1, 84
  909308:	c0b5      	movi.n	a11, 5
  90930a:	5bef0d        	call8	904f40 <ath_hal_getcapability>
  90930d:	c8a9      	beqz.n	a10, 90931a <ath_buf_set_rate+0x6e>
  90930f:	273221        	l32i	a7, a3, 132
		    flags = HAL_TXDESC_RTSENA;
  909312:	c044      	movi.n	a4, 4
	 rt->info[rix].phy == IEEE80211_T_HT) &&
	(bf->bf_flags & HAL_TXDESC_NOACK) == 0) {
	    cix = rt->info[sc->sc_protrix].controlRate;
	    prot_mode = AH_TRUE;
    } else {
	    if (ath_hal_getcapability(ah, HAL_CAP_HT) && (!bf->bf_ismcast))
  909314:	077740        	extui	a7, a7, 7, 1
		    flags = HAL_TXDESC_RTSENA;
  909317:	074638        	moveqz	a6, a4, a7
  90931a:	d730      	mov.n	a7, a3

	    for (i = 4; i--;) {
  90931c:	c044      	movi.n	a4, 4
  90931e:	600020        	j	909342 <ath_buf_set_rate+0x96>
  909321:	277cf4        	addi	a7, a7, -12
		    if (bf->bf_rcs[i].tries) {
  909324:	287081        	l8ui	a8, a7, 129
  909327:	c987      	beqz.n	a8, 909342 <ath_buf_set_rate+0x96>
			    cix = rt->info[bf->bf_rcs[i].rix].controlRate;
  909329:	044409        	addx2	a4, a4, a4
  90932c:	03440a        	addx4	a4, a4, a3
  90932f:	244050        	l8ui	a4, a4, 80
  909332:	b244      	addi.n	a4, a4, 2
  909334:	0c4411        	slli	a4, a4, 4
  909337:	a454      	add.n	a4, a5, a4
  909339:	244013        	l8ui	a4, a4, 19
  90933c:	241614        	s32i	a4, a1, 80
  90933f:	600004        	j	909347 <ath_buf_set_rate+0x9b>
	    prot_mode = AH_TRUE;
    } else {
	    if (ath_hal_getcapability(ah, HAL_CAP_HT) && (!bf->bf_ismcast))
		    flags = HAL_TXDESC_RTSENA;

	    for (i = 4; i--;) {
  909342:	b044      	addi.n	a4, a4, -1
  909344:	6940d9        	bnei	a4, -1, 909321 <ath_buf_set_rate+0x75>
    const HAL_RATE_TABLE *rt;
    struct ath_tx_desc *ds = bf->bf_desc;
    HAL_11N_RATE_SERIES series[4];
    a_int32_t i, flags;
    a_uint8_t rix, cix, rtsctsrate;
    a_int32_t prot_mode = AH_FALSE;
  909347:	270a00        	movi	a7, 0
 * @param[in] size  buffer size
 */
static inline void
adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
{
    __adf_os_mem_set(buf, b, size);
  90934a:	da10      	mov.n	a10, a1
  90934c:	c5b0      	movi.n	a11, 80
  90934e:	5bffd2        	call8	909298 <__adf_os_mem_set$constprop$13>
	if (bf != NULL) {
		asf_tailq_insert_tail(&sc->sc_txbuf, bf, bf_list);
	}
}

static void ath_buf_set_rate(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
  909351:	2f3c30        	addi	a15, a3, 48
  909354:	d830      	mov.n	a8, a3
  909356:	241c10        	addi	a4, a1, 16
  909359:	2f1617        	s32i	a15, a1, 92
    }

    adf_os_mem_set(series, 0, sizeof(HAL_11N_RATE_SERIES) * 4);

    for (i = 0; i < 4; i++) {
	    if (!bf->bf_rcs[i].tries)
  90935c:	298051        	l8ui	a9, a8, 81
  90935f:	6490f2        	beqz	a9, 909455 <ath_buf_set_rate+0x1a9>
		    continue;

	    rix = bf->bf_rcs[i].rix;

	    series[i].Rate = rt->info[rix].rateCode |
  909362:	2d8050        	l8ui	a13, a8, 80
		    (bf->bf_shpream ? rt->info[rix].shortPreamble : 0);
  909365:	2c3221        	l32i	a12, a3, 132
	    if (!bf->bf_rcs[i].tries)
		    continue;

	    rix = bf->bf_rcs[i].rix;

	    series[i].Rate = rt->info[rix].rateCode |
  909368:	b2db      	addi.n	a11, a13, 2
  90936a:	0cbb11        	slli	a11, a11, 4
  90936d:	ab5b      	add.n	a11, a5, a11
		    (bf->bf_shpream ? rt->info[rix].shortPreamble : 0);
  90936f:	c4f0      	movi.n	a15, 64
	    if (!bf->bf_rcs[i].tries)
		    continue;

	    rix = bf->bf_rcs[i].rix;

	    series[i].Rate = rt->info[rix].rateCode |
  909371:	2eb010        	l8ui	a14, a11, 16
		    (bf->bf_shpream ? rt->info[rix].shortPreamble : 0);
  909374:	c0a0      	movi.n	a10, 0
  909376:	7fc002        	bnone	a12, a15, 90937c <ath_buf_set_rate+0xd0>
  909379:	2ab011        	l8ui	a10, a11, 17
	    if (!bf->bf_rcs[i].tries)
		    continue;

	    rix = bf->bf_rcs[i].rix;

	    series[i].Rate = rt->info[rix].rateCode |
  90937c:	0eaa02        	or	a10, a10, a14
	if (bf != NULL) {
		asf_tailq_insert_tail(&sc->sc_txbuf, bf, bf_list);
	}
}

static void ath_buf_set_rate(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
  90937f:	2b4cf4        	addi	a11, a4, -12
	    if (!bf->bf_rcs[i].tries)
		    continue;

	    rix = bf->bf_rcs[i].rix;

	    series[i].Rate = rt->info[rix].rateCode |
  909382:	9ab0      	s32i.n	a10, a11, 0
	if (bf != NULL) {
		asf_tailq_insert_tail(&sc->sc_txbuf, bf, bf_list);
	}
}

static void ath_buf_set_rate(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
  909384:	2a4cf0        	addi	a10, a4, -16
	    rix = bf->bf_rcs[i].rix;

	    series[i].Rate = rt->info[rix].rateCode |
		    (bf->bf_shpream ? rt->info[rix].shortPreamble : 0);

	    series[i].Tries = bf->bf_rcs[i].tries;
  909387:	99a0      	s32i.n	a9, a10, 0
		    ((bf->bf_rcs[i].flags & ATH_RC_HT40_SGI_FLAG) ?
		     HAL_RATESERIES_HALFGI : 0 ) |
		    ((bf->bf_rcs[i].flags & ATH_RC_TX_STBC_FLAG) ?
		     HAL_RATESERIES_STBC: 0);
#else
	    series[i].RateFlags = ((bf->bf_rcs[i].flags & ATH_RC_RTSCTS_FLAG) ?
  909389:	298053        	l8ui	a9, a8, 83
				   HAL_RATESERIES_RTS_CTS : 0 ) |
		    ((bf->bf_rcs[i].flags & ATH_RC_CW40_FLAG) ?
		     HAL_RATESERIES_2040 : 0 ) |
  90938c:	c0a2      	movi.n	a10, 2
		    ((bf->bf_rcs[i].flags & ATH_RC_HT40_SGI_FLAG) ?
		     HAL_RATESERIES_HALFGI : 0 );
  90938e:	c0e4      	movi.n	a14, 4
		     HAL_RATESERIES_STBC: 0);
#else
	    series[i].RateFlags = ((bf->bf_rcs[i].flags & ATH_RC_RTSCTS_FLAG) ?
				   HAL_RATESERIES_RTS_CTS : 0 ) |
		    ((bf->bf_rcs[i].flags & ATH_RC_CW40_FLAG) ?
		     HAL_RATESERIES_2040 : 0 ) |
  909390:	0a9a01        	and	a10, a9, a10
		    ((bf->bf_rcs[i].flags & ATH_RC_HT40_SGI_FLAG) ?
		     HAL_RATESERIES_HALFGI : 0 );
  909393:	0e9e01        	and	a14, a9, a14
		     HAL_RATESERIES_HALFGI : 0 ) |
		    ((bf->bf_rcs[i].flags & ATH_RC_TX_STBC_FLAG) ?
		     HAL_RATESERIES_STBC: 0);
#else
	    series[i].RateFlags = ((bf->bf_rcs[i].flags & ATH_RC_RTSCTS_FLAG) ?
				   HAL_RATESERIES_RTS_CTS : 0 ) |
  909396:	0eab02        	or	a11, a10, a14
  909399:	094940        	extui	a9, a9, 4, 1
		    ((bf->bf_rcs[i].flags & ATH_RC_CW40_FLAG) ?
		     HAL_RATESERIES_2040 : 0 ) |
  90939c:	09b902        	or	a9, a11, a9
		    ((bf->bf_rcs[i].flags & ATH_RC_HT40_SGI_FLAG) ?
		     HAL_RATESERIES_HALFGI : 0 ) |
		    ((bf->bf_rcs[i].flags & ATH_RC_TX_STBC_FLAG) ?
		     HAL_RATESERIES_STBC: 0);
#else
	    series[i].RateFlags = ((bf->bf_rcs[i].flags & ATH_RC_RTSCTS_FLAG) ?
  90939f:	9940      	s32i.n	a9, a4, 0

static a_uint32_t ath_pkt_duration(struct ath_softc_tgt *sc,
				   a_uint8_t rix, struct ath_tx_buf *bf,
				   a_int32_t width, a_int32_t half_gi)
{
	const HAL_RATE_TABLE *rt = sc->sc_currates;
  9093a1:	2b2281        	l32i	a11, a2, 0x204
	a_uint32_t nbits, nsymbits, duration, nsymbols;
	a_uint8_t rc;
	a_int32_t streams;
	a_int32_t pktlen;

	pktlen = bf->bf_isaggr ? bf->bf_al : bf->bf_pktlen;
  9093a4:	7ac705        	bbci	a12, 26, 9093ad <ath_buf_set_rate+0x101>
  9093a7:	2c3127        	l16ui	a12, a3, 78
  9093aa:	600002        	j	9093b0 <ath_buf_set_rate+0x104>
  9093ad:	2c3122        	l16ui	a12, a3, 68
	rc = rt->info[rix].rateCode;
  9093b0:	b2d9      	addi.n	a9, a13, 2
  9093b2:	0c9911        	slli	a9, a9, 4
  9093b5:	a9b9      	add.n	a9, a11, a9
  9093b7:	299010        	l8ui	a9, a9, 16

	if (!IS_HT_RATE(rc))
  9093ba:	009f32        	sext	a15, a9, 7
  9093bd:	66f017        	bltz	a15, 9093d8 <ath_buf_set_rate+0x12c>
		return ath_hal_computetxtime(sc->sc_ah, rt, pktlen, rix,
					     bf->bf_shpream);
  9093c0:	2e3221        	l32i	a14, a3, 132

	pktlen = bf->bf_isaggr ? bf->bf_al : bf->bf_pktlen;
	rc = rt->info[rix].rateCode;

	if (!IS_HT_RATE(rc))
		return ath_hal_computetxtime(sc->sc_ah, rt, pktlen, rix,
  9093c3:	292d05        	addmi	a9, a2, 0x500
  9093c6:	8a9b      	l32i.n	a10, a9, 44
  9093c8:	0e6e40        	extui	a14, a14, 6, 1
  9093cb:	28161a        	s32i	a8, a1, 104
  9093ce:	5beeeb        	call8	904f7c <ath_hal_computetxtime>
  9093d1:	28121a        	l32i	a8, a1, 104
  9093d4:	600052        	j	90942a <ath_buf_set_rate+0x17e>
  9093d7:	00c0d1        	excw
		    ((bf->bf_rcs[i].flags & ATH_RC_CW40_FLAG) ?
		     HAL_RATESERIES_2040 : 0 ) |
		    ((bf->bf_rcs[i].flags & ATH_RC_HT40_SGI_FLAG) ?
		     HAL_RATESERIES_HALFGI : 0 );
#endif
	    series[i].PktDuration = ath_pkt_duration(sc, rix, bf,
  9093da:	c0b0      	movi.n	a11, 0
  9093dc:	0adb39        	movnez	a11, a13, a10
	if (!IS_HT_RATE(rc))
		return ath_hal_computetxtime(sc->sc_ah, rt, pktlen, rix,
					     bf->bf_shpream);

	nbits = (pktlen << 3) + OFDM_PLCP_BITS;
	nsymbits = bits_per_symbol[HT_RC_2_MCS(rc)][width];
  9093df:	090a43        	extui	a10, a9, 0, 4
  9093e2:	0bab09        	addx2	a11, a10, a11
  9093e5:	1a72c0        	l32r	a10, 8e5ee8 <memset+0xd4c>
	nsymbols = (nbits + nsymbits - 1) / nsymbits;
  9093e8:	28161a        	s32i	a8, a1, 104
	if (!IS_HT_RATE(rc))
		return ath_hal_computetxtime(sc->sc_ah, rt, pktlen, rix,
					     bf->bf_shpream);

	nbits = (pktlen << 3) + OFDM_PLCP_BITS;
	nsymbits = bits_per_symbol[HT_RC_2_MCS(rc)][width];
  9093eb:	0abb09        	addx2	a11, a11, a10
  9093ee:	2bb100        	l16ui	a11, a11, 0
	nsymbols = (nbits + nsymbits - 1) / nsymbits;
  9093f1:	291619        	s32i	a9, a1, 100

	if (!IS_HT_RATE(rc))
		return ath_hal_computetxtime(sc->sc_ah, rt, pktlen, rix,
					     bf->bf_shpream);

	nbits = (pktlen << 3) + OFDM_PLCP_BITS;
  9093f4:	0bca0b        	addx8	a10, a12, a11
	nsymbits = bits_per_symbol[HT_RC_2_MCS(rc)][width];
	nsymbols = (nbits + nsymbits - 1) / nsymbits;
  9093f7:	2aac15        	addi	a10, a10, 21
  9093fa:	2e1618        	s32i	a14, a1, 96
  9093fd:	5b6e68        	call8	8e4da0 <__udivsi3>

	if (!half_gi)
  909400:	2e1218        	l32i	a14, a1, 96
  909403:	28121a        	l32i	a8, a1, 104
  909406:	291219        	l32i	a9, a1, 100
  909409:	cce4      	bnez.n	a14, 909411 <ath_buf_set_rate+0x165>
		duration = SYMBOL_TIME(nsymbols);
  90940b:	0eaa11        	slli	a10, a10, 2
  90940e:	600010        	j	909422 <ath_buf_set_rate+0x176>
	else
		duration = SYMBOL_TIME_HALFGI(nsymbols);
  909411:	0aaa0b        	addx8	a10, a10, a10
  909414:	0faa11        	slli	a10, a10, 1
  909417:	1b72c1        	l32r	a11, 8e5f1c <memset+0xd80>
  90941a:	b4aa      	addi.n	a10, a10, 4
  90941c:	0baa2a        	muluh	a10, a10, a11
  90941f:	0a2a14        	srli	a10, a10, 2

	streams = HT_RC_2_STREAMS(rc);
  909422:	093943        	extui	a9, a9, 3, 4
	duration += L_STF + L_LTF + L_SIG + HT_SIG + HT_STF + HT_LTF(streams);
  909425:	b999      	addi.n	a9, a9, 9
  909427:	0a9a0a        	addx4	a10, a9, a10
	if (bf != NULL) {
		asf_tailq_insert_tail(&sc->sc_txbuf, bf, bf_list);
	}
}

static void ath_buf_set_rate(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
  90942a:	294cf8        	addi	a9, a4, -8
		    ((bf->bf_rcs[i].flags & ATH_RC_CW40_FLAG) ?
		     HAL_RATESERIES_2040 : 0 ) |
		    ((bf->bf_rcs[i].flags & ATH_RC_HT40_SGI_FLAG) ?
		     HAL_RATESERIES_HALFGI : 0 );
#endif
	    series[i].PktDuration = ath_pkt_duration(sc, rix, bf,
  90942d:	9a90      	s32i.n	a10, a9, 0
				     (bf->bf_rcs[i].flags & ATH_RC_CW40_FLAG) != 0,
				     (bf->bf_rcs[i].flags & ATH_RC_HT40_SGI_FLAG));

	    series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
  90942f:	2a2d16        	addmi	a10, a2, 0x1600
  909432:	2aa026        	l8ui	a10, a10, 38
	if (bf != NULL) {
		asf_tailq_insert_tail(&sc->sc_txbuf, bf, bf_list);
	}
}

static void ath_buf_set_rate(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
  909435:	294cfc        	addi	a9, a4, -4
#endif
	    series[i].PktDuration = ath_pkt_duration(sc, rix, bf,
				     (bf->bf_rcs[i].flags & ATH_RC_CW40_FLAG) != 0,
				     (bf->bf_rcs[i].flags & ATH_RC_HT40_SGI_FLAG));

	    series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
  909438:	9a90      	s32i.n	a10, a9, 0

	    if (prot_mode)
  90943a:	c877      	beqz.n	a7, 909445 <ath_buf_set_rate+0x199>
		    series[i].RateFlags |= HAL_RATESERIES_RTS_CTS;
  90943c:	8a40      	l32i.n	a10, a4, 0
  90943e:	c091      	movi.n	a9, 1
  909440:	09a902        	or	a9, a10, a9
  909443:	9940      	s32i.n	a9, a4, 0

	    if (bf->bf_rcs[i].flags & ATH_RC_DS_FLAG)
  909445:	298053        	l8ui	a9, a8, 83
  909448:	7f9709        	bbci	a9, 31, 909455 <ath_buf_set_rate+0x1a9>
		    series[i].RateFlags |= HAL_RATESERIES_RTS_CTS;
  90944b:	8a40      	l32i.n	a10, a4, 0
  90944d:	c091      	movi.n	a9, 1
  90944f:	09a902        	or	a9, a10, a9
  909452:	294600        	s32i	a9, a4, 0
	    }
    }

    adf_os_mem_set(series, 0, sizeof(HAL_11N_RATE_SERIES) * 4);

    for (i = 0; i < 4; i++) {
  909455:	291217        	l32i	a9, a1, 92
  909458:	bc88      	addi.n	a8, a8, 12
  90945a:	244c14        	addi	a4, a4, 20
  90945d:	798102        	beq	a8, a9, 909463 <ath_buf_set_rate+0x1b7>
  909460:	63fef8        	j	90935c <ath_buf_set_rate+0xb0>

	    if (bf->bf_rcs[i].flags & ATH_RC_DS_FLAG)
		    series[i].RateFlags |= HAL_RATESERIES_RTS_CTS;
    }

    rtsctsrate = rt->info[cix].rateCode |
  909463:	2f1214        	l32i	a15, a1, 80
	    (bf->bf_shpream ? rt->info[cix].shortPreamble : 0);
  909466:	233221        	l32i	a3, a3, 132

	    if (bf->bf_rcs[i].flags & ATH_RC_DS_FLAG)
		    series[i].RateFlags |= HAL_RATESERIES_RTS_CTS;
    }

    rtsctsrate = rt->info[cix].rateCode |
  909469:	b2f2      	addi.n	a2, a15, 2
  90946b:	0c2211        	slli	a2, a2, 4
  90946e:	a255      	add.n	a5, a5, a2
  909470:	2c5010        	l8ui	a12, a5, 16
  909473:	220a00        	movi	a2, 0
  909476:	793702        	bbci	a3, 25, 90947c <ath_buf_set_rate+0x1d0>
  909479:	225011        	l8ui	a2, a5, 17
	    (bf->bf_shpream ? rt->info[cix].shortPreamble : 0);

    ah->ah_set11nRateScenario(ds, 1,
  90947c:	241215        	l32i	a4, a1, 84
  90947f:	2a1216        	l32i	a10, a1, 88
  909482:	234210        	l32i	a3, a4, 64
  909485:	c0b1      	movi.n	a11, 1
  909487:	0c2c02        	or	a12, a2, a12
  90948a:	dd10      	mov.n	a13, a1
  90948c:	c0e4      	movi.n	a14, 4
  90948e:	066f02        	or	a15, a6, a6
  909491:	0b3000        	callx8	a3
  909494:	d10f      	retw.n
	...

00909498 <ath_dma_map>:

	return duration;
}

static void ath_dma_map(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  909498:	6c1004        	entry	a1, 32
 * @return first buffer in queue
 */
static inline adf_nbuf_t 
adf_nbuf_queue_first(adf_nbuf_queue_t *head)
{
    return (__adf_nbuf_queue_first(head));
  90949b:	2a3c14        	addi	a10, a3, 20
  90949e:	5be88c        	call8	9036d0 <__adf_nbuf_queue_first>
  9094a1:	dca0      	mov.n	a12, a10
adf_nbuf_map(adf_os_device_t        osdev, 
             adf_os_dma_map_t       bmap, 
             adf_nbuf_t             buf, 
             adf_os_dma_dir_t       dir)
{
    return __adf_nbuf_map(osdev, bmap, buf, dir);
  9094a3:	8b30      	l32i.n	a11, a3, 0
  9094a5:	2a2246        	l32i	a10, a2, 0x118
  9094a8:	c0d0      	movi.n	a13, 0
  9094aa:	5be80c        	call8	9034dc <__adf_nbuf_map>
  9094ad:	d10f      	retw.n
	...

009094b0 <ath_buf_toggle>:
}

static struct ath_tx_buf *ath_buf_toggle(struct ath_softc_tgt *sc,
				      struct ath_tx_buf *bf,
				      a_uint8_t retry)
{
  9094b0:	6c1004        	entry	a1, 32
  9094b3:	d520      	mov.n	a5, a2
	struct ath_tx_buf *tmp = NULL;
	adf_nbuf_t buf = NULL;

	adf_os_assert(sc->sc_txbuf_held != NULL);
  9094b5:	2222dc        	l32i	a2, a2, 0x370
  9094b8:	cc21      	bnez.n	a2, 9094bd <ath_buf_toggle+0xd>
  9094ba:	63fffc        	j	9094ba <ath_buf_toggle+0xa>

	tmp = sc->sc_txbuf_held;

	if (retry) {
  9094bd:	6440b7        	beqz	a4, 909578 <ath_buf_toggle+0xc8>
		ath_dma_unmap(sc, bf);
  9094c0:	db30      	mov.n	a11, a3
  9094c2:	055a02        	or	a10, a5, a5
  9094c5:	5bfefc        	call8	9090b8 <ath_dma_unmap>
		adf_nbuf_queue_init(&tmp->bf_skbhead);
  9094c8:	262c14        	addi	a6, a2, 20
 * @param[in] head  buf queue head
 */
static inline void
adf_nbuf_queue_init(adf_nbuf_queue_t *head)
{
    __adf_nbuf_queue_init(head);
  9094cb:	da60      	mov.n	a10, a6
  9094cd:	5be87a        	call8	9036b8 <__adf_nbuf_queue_init>
		buf = adf_nbuf_queue_remove(&bf->bf_skbhead);
  9094d0:	243c14        	addi	a4, a3, 20
 * @return The head buf in the buf queue.
 */
static inline adf_nbuf_t
adf_nbuf_queue_remove(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_remove(head);
  9094d3:	da40      	mov.n	a10, a4
  9094d5:	5be7f0        	call8	903498 <__adf_nbuf_queue_remove>
  9094d8:	dba0      	mov.n	a11, a10
		adf_os_assert(buf);
  9094da:	cca2      	bnez.n	a10, 9094e0 <ath_buf_toggle+0x30>
  9094dc:	63fffc        	j	9094dc <ath_buf_toggle+0x2c>
  9094df:	00da60        	excw
 * @param[in] buf   buf
 */
static inline void
adf_nbuf_queue_add(adf_nbuf_queue_t *head, adf_nbuf_t buf)
{
    __adf_nbuf_queue_add(head, buf);
  9094e2:	5be7e5        	call8	903478 <__adf_nbuf_queue_add>
 * @return length of the queue
 */
static inline a_uint32_t
adf_nbuf_queue_len(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_len(head);
  9094e5:	da40      	mov.n	a10, a4
  9094e7:	5be878        	call8	9036c8 <__adf_nbuf_queue_len>
  9094ea:	d4a0      	mov.n	a4, a10
		adf_nbuf_queue_add(&tmp->bf_skbhead, buf);

		adf_os_assert(adf_nbuf_queue_len(&bf->bf_skbhead) == 0);
  9094ec:	c8a2      	beqz.n	a10, 9094f2 <ath_buf_toggle+0x42>
  9094ee:	63fffc        	j	9094ee <ath_buf_toggle+0x3e>
  9094f1:	00863b        	movgez	a6, a8, a0
		tmp->bf_next = bf->bf_next;
		tmp->bf_endpt = bf->bf_endpt;
		tmp->bf_tidno = bf->bf_tidno;
		tmp->bf_skb = bf->bf_skb;
		tmp->bf_node = bf->bf_node;
		tmp->bf_isaggr = bf->bf_isaggr;
  9094f4:	282087        	l8ui	a8, a2, 135
		adf_os_assert(buf);
		adf_nbuf_queue_add(&tmp->bf_skbhead, buf);

		adf_os_assert(adf_nbuf_queue_len(&bf->bf_skbhead) == 0);

		tmp->bf_next = bf->bf_next;
  9094f7:	962b      	s32i.n	a6, a2, 44
		tmp->bf_endpt = bf->bf_endpt;
  9094f9:	263223        	l32i	a6, a3, 140
		tmp->bf_tidno = bf->bf_tidno;
		tmp->bf_skb = bf->bf_skb;
		tmp->bf_node = bf->bf_node;
		tmp->bf_isaggr = bf->bf_isaggr;
		tmp->bf_flags = bf->bf_flags;
		tmp->bf_state = bf->bf_state;
  9094fc:	2b3c3c        	addi	a11, a3, 60
		adf_nbuf_queue_add(&tmp->bf_skbhead, buf);

		adf_os_assert(adf_nbuf_queue_len(&bf->bf_skbhead) == 0);

		tmp->bf_next = bf->bf_next;
		tmp->bf_endpt = bf->bf_endpt;
  9094ff:	262623        	s32i	a6, a2, 140
		tmp->bf_tidno = bf->bf_tidno;
  909502:	26304d        	l8ui	a6, a3, 77
		tmp->bf_skb = bf->bf_skb;
		tmp->bf_node = bf->bf_node;
		tmp->bf_isaggr = bf->bf_isaggr;
		tmp->bf_flags = bf->bf_flags;
		tmp->bf_state = bf->bf_state;
  909505:	c4cc      	movi.n	a12, 76

		adf_os_assert(adf_nbuf_queue_len(&bf->bf_skbhead) == 0);

		tmp->bf_next = bf->bf_next;
		tmp->bf_endpt = bf->bf_endpt;
		tmp->bf_tidno = bf->bf_tidno;
  909507:	26244d        	s8i	a6, a2, 77
		tmp->bf_skb = bf->bf_skb;
  90950a:	8638      	l32i.n	a6, a3, 32
		tmp->bf_node = bf->bf_node;
		tmp->bf_isaggr = bf->bf_isaggr;
		tmp->bf_flags = bf->bf_flags;
		tmp->bf_state = bf->bf_state;
  90950c:	2a2c3c        	addi	a10, a2, 60
		adf_os_assert(adf_nbuf_queue_len(&bf->bf_skbhead) == 0);

		tmp->bf_next = bf->bf_next;
		tmp->bf_endpt = bf->bf_endpt;
		tmp->bf_tidno = bf->bf_tidno;
		tmp->bf_skb = bf->bf_skb;
  90950f:	9628      	s32i.n	a6, a2, 32
		tmp->bf_node = bf->bf_node;
  909511:	263204        	l32i	a6, a3, 16
  909514:	262604        	s32i	a6, a2, 16
		tmp->bf_isaggr = bf->bf_isaggr;
  909517:	293221        	l32i	a9, a3, 132
  90951a:	26fadf        	movi	a6, -33
  90951d:	095940        	extui	a9, a9, 5, 1
  909520:	0b9911        	slli	a9, a9, 5
  909523:	068801        	and	a8, a8, a6
  909526:	098802        	or	a8, a8, a9
  909529:	282487        	s8i	a8, a2, 135
		tmp->bf_flags = bf->bf_flags;
  90952c:	283144        	l16ui	a8, a3, 136
  90952f:	282544        	s16i	a8, a2, 136
		tmp->bf_state = bf->bf_state;
  909532:	5b6e61        	call8	8e4eb8 <memcpy>
		tmp->bf_retries = bf->bf_retries;
  909535:	283086        	l8ui	a8, a3, 134
		bf->bf_comp = NULL;

		bf->bf_retries = 0;
		bf->bf_nframes = 0;

		ath_dma_map(sc, tmp);
  909538:	da50      	mov.n	a10, a5
		tmp->bf_skb = bf->bf_skb;
		tmp->bf_node = bf->bf_node;
		tmp->bf_isaggr = bf->bf_isaggr;
		tmp->bf_flags = bf->bf_flags;
		tmp->bf_state = bf->bf_state;
		tmp->bf_retries = bf->bf_retries;
  90953a:	282486        	s8i	a8, a2, 134
		tmp->bf_comp = bf->bf_comp;
  90953d:	883f      	l32i.n	a8, a3, 60
		bf->bf_comp = NULL;

		bf->bf_retries = 0;
		bf->bf_nframes = 0;

		ath_dma_map(sc, tmp);
  90953f:	db20      	mov.n	a11, a2
		tmp->bf_node = bf->bf_node;
		tmp->bf_isaggr = bf->bf_isaggr;
		tmp->bf_flags = bf->bf_flags;
		tmp->bf_state = bf->bf_state;
		tmp->bf_retries = bf->bf_retries;
		tmp->bf_comp = bf->bf_comp;
  909541:	982f      	s32i.n	a8, a2, 60
		tmp->bf_nframes = bf->bf_nframes;
  909543:	28304c        	l8ui	a8, a3, 76
		tmp->bf_cookie = bf->bf_cookie;

		bf->bf_isaggr = 0;
		bf->bf_next = NULL;
  909546:	943b      	s32i.n	a4, a3, 44
		tmp->bf_isaggr = bf->bf_isaggr;
		tmp->bf_flags = bf->bf_flags;
		tmp->bf_state = bf->bf_state;
		tmp->bf_retries = bf->bf_retries;
		tmp->bf_comp = bf->bf_comp;
		tmp->bf_nframes = bf->bf_nframes;
  909548:	28244c        	s8i	a8, a2, 76
		tmp->bf_cookie = bf->bf_cookie;
  90954b:	283092        	l8ui	a8, a3, 146

		bf->bf_isaggr = 0;
		bf->bf_next = NULL;
		bf->bf_skb = NULL;
  90954e:	9438      	s32i.n	a4, a3, 32
		tmp->bf_flags = bf->bf_flags;
		tmp->bf_state = bf->bf_state;
		tmp->bf_retries = bf->bf_retries;
		tmp->bf_comp = bf->bf_comp;
		tmp->bf_nframes = bf->bf_nframes;
		tmp->bf_cookie = bf->bf_cookie;
  909550:	282492        	s8i	a8, a2, 146

		bf->bf_isaggr = 0;
  909553:	283087        	l8ui	a8, a3, 135
		bf->bf_next = NULL;
		bf->bf_skb = NULL;
		bf->bf_node = NULL;
  909556:	243604        	s32i	a4, a3, 16
		tmp->bf_retries = bf->bf_retries;
		tmp->bf_comp = bf->bf_comp;
		tmp->bf_nframes = bf->bf_nframes;
		tmp->bf_cookie = bf->bf_cookie;

		bf->bf_isaggr = 0;
  909559:	068601        	and	a6, a8, a6
  90955c:	263487        	s8i	a6, a3, 135
		bf->bf_next = NULL;
		bf->bf_skb = NULL;
		bf->bf_node = NULL;
		bf->bf_flags = 0;
  90955f:	243544        	s16i	a4, a3, 136
		bf->bf_comp = NULL;
  909562:	943f      	s32i.n	a4, a3, 60

		bf->bf_retries = 0;
  909564:	243486        	s8i	a4, a3, 134
		bf->bf_nframes = 0;
  909567:	24344c        	s8i	a4, a3, 76

		ath_dma_map(sc, tmp);
  90956a:	5bffcb        	call8	909498 <ath_dma_map>
		ath_tx_tgt_setds(sc, tmp);
  90956d:	da50      	mov.n	a10, a5
  90956f:	022b02        	or	a11, a2, a2

		bf->bf_isaggr = 0;
		bf->bf_next = NULL;
		bf->bf_skb = NULL;
		bf->bf_node = NULL;
		bf->bf_flags = 0;
  909572:	044602        	or	a6, a4, a4

		bf->bf_retries = 0;
		bf->bf_nframes = 0;

		ath_dma_map(sc, tmp);
		ath_tx_tgt_setds(sc, tmp);
  909575:	5bff0a        	call8	9091a0 <ath_tx_tgt_setds>
	}

	sc->sc_txbuf_held = bf;
  909578:	2356dc        	s32i	a3, a5, 0x370

	return tmp;
}
  90957b:	d10f      	retw.n
  90957d:	000000        	ill

00909580 <ath_bar_tx>:
	ath_buf_comp(sc, bf);
}

static void ath_bar_tx(struct ath_softc_tgt *sc,
		       ath_atx_tid_t *tid, struct ath_tx_buf *bf)
{
  909580:	6c1016        	entry	a1, 176
  909583:	d730      	mov.n	a7, a3
	adf_nbuf_t skb;
	struct ieee80211_frame_bar *bar;
	u_int8_t min_rate;
	struct ath_tx_desc *ds, *ds0;
	struct ath_hal *ah = sc->sc_ah;
  909585:	232d05        	addmi	a3, a2, 0x500
  909588:	833b      	l32i.n	a3, a3, 44
  90958a:	c5b0      	movi.n	a11, 80
  90958c:	231620        	s32i	a3, a1, 128
	int i = 0;
	adf_nbuf_queue_t skbhead;
	a_uint8_t *anbdata;
	a_uint32_t anblen;

	__stats(sc, tx_bars);
  90958f:	232278        	l32i	a3, a2, 0x1e0
  909592:	2a1c20        	addi	a10, a1, 32
  909595:	b133      	addi.n	a3, a3, 1
  909597:	232678        	s32i	a3, a2, 0x1e0
  90959a:	5bff3f        	call8	909298 <__adf_os_mem_set$constprop$13>

	adf_os_mem_set(&series, 0, sizeof(series));

	ath_aggr_pause_tid(sc, tid);

	skb = adf_nbuf_queue_remove(&bf->bf_skbhead);
  90959d:	254c14        	addi	a5, a4, 20
}

static inline void
ath_aggr_pause_tid(struct ath_softc_tgt *sc, ath_atx_tid_t *tid)
{
	tid->paused =1;
  9095a0:	230a01        	movi	a3, 1
  9095a3:	237434        	s8i	a3, a7, 52
 * @return The head buf in the buf queue.
 */
static inline adf_nbuf_t
adf_nbuf_queue_remove(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_remove(head);
  9095a6:	055a02        	or	a10, a5, a5
  9095a9:	5be7bb        	call8	903498 <__adf_nbuf_queue_remove>
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  9095ac:	2c1c70        	addi	a12, a1, 112
  9095af:	2b1c74        	addi	a11, a1, 116
 * @return The head buf in the buf queue.
 */
static inline adf_nbuf_t
adf_nbuf_queue_remove(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_remove(head);
  9095b2:	0aa302        	or	a3, a10, a10
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  9095b5:	5be83a        	call8	9036a0 <__adf_nbuf_peek_header>
 * @return none
 */
static inline void
adf_nbuf_trim_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    __adf_nbuf_trim_tail(buf, size);
  9095b8:	2b121c        	l32i	a11, a1, 112
  9095bb:	da30      	mov.n	a10, a3
  9095bd:	5be813        	call8	90360c <__adf_nbuf_trim_tail>
	adf_nbuf_trim_tail(skb, anblen);
	bar = (struct ieee80211_frame_bar *) anbdata;

	min_rate =  0x0b;

	ath_dma_unmap(sc, bf);
  9095c0:	da20      	mov.n	a10, a2
  9095c2:	db40      	mov.n	a11, a4
	ath_aggr_pause_tid(sc, tid);

	skb = adf_nbuf_queue_remove(&bf->bf_skbhead);
	adf_nbuf_peek_header(skb, &anbdata, &anblen);
	adf_nbuf_trim_tail(skb, anblen);
	bar = (struct ieee80211_frame_bar *) anbdata;
  9095c4:	26121d        	l32i	a6, a1, 116

	min_rate =  0x0b;

	ath_dma_unmap(sc, bf);
  9095c7:	5bfebc        	call8	9090b8 <ath_dma_unmap>
 * @param[in] buf   buf
 */
static inline void
adf_nbuf_queue_add(adf_nbuf_queue_t *head, adf_nbuf_t buf)
{
    __adf_nbuf_queue_add(head, buf);
  9095ca:	da50      	mov.n	a10, a5
  9095cc:	033b02        	or	a11, a3, a3
	adf_nbuf_queue_add(&bf->bf_skbhead, skb);

	bar->i_fc[1] = IEEE80211_FC1_DIR_NODS;
  9095cf:	c050      	movi.n	a5, 0
  9095d1:	5be7a9        	call8	903478 <__adf_nbuf_queue_add>
  9095d4:	256401        	s8i	a5, a6, 1
	bar->i_fc[0] = IEEE80211_FC0_VERSION_0 |
  9095d7:	25fa84        	movi	a5, -124
  9095da:	256400        	s8i	a5, a6, 0
		IEEE80211_FC0_TYPE_CTL |
		IEEE80211_FC0_SUBTYPE_BAR;
	bar->i_ctl = tid->tidno << IEEE80211_BAR_CTL_TID_S |
  9095dd:	8970      	l32i.n	a9, a7, 0
  9095df:	c054      	movi.n	a5, 4
  9095e1:	049911        	slli	a9, a9, 12
  9095e4:	059902        	or	a9, a9, a5
  9095e7:	09094f        	extui	a9, a9, 0, 16
  9095ea:	098a14        	srli	a10, a9, 8
  9095ed:	2a6410        	s8i	a10, a6, 16
  9095f0:	296411        	s8i	a9, a6, 17
		IEEE80211_BAR_CTL_COMBA;
	bar->i_seq = adf_os_cpu_to_le16(tid->seq_start << IEEE80211_SEQ_SEQ_SHIFT);
  9095f3:	297102        	l16ui	a9, a7, 4

	bar->i_fc[1] = IEEE80211_FC1_DIR_NODS;
	bar->i_fc[0] = IEEE80211_FC0_VERSION_0 |
		IEEE80211_FC0_TYPE_CTL |
		IEEE80211_FC0_SUBTYPE_BAR;
	bar->i_ctl = tid->tidno << IEEE80211_BAR_CTL_TID_S |
  9095f6:	c050      	movi.n	a5, 0
		IEEE80211_BAR_CTL_COMBA;
	bar->i_seq = adf_os_cpu_to_le16(tid->seq_start << IEEE80211_SEQ_SEQ_SHIFT);
  9095f8:	0c9911        	slli	a9, a9, 4
  9095fb:	09094f        	extui	a9, a9, 0, 16

#undef adf_os_cpu_to_le16

static a_uint16_t adf_os_cpu_to_le16(a_uint16_t x)
{
	return ((((x) & 0xff00) >> 8) |   (((x) & 0x00ff) << 8));
  9095fe:	089b11        	slli	a11, a9, 8
  909601:	098a14        	srli	a10, a9, 8
  909604:	0aba02        	or	a10, a11, a10
	bar->i_fc[0] = IEEE80211_FC0_VERSION_0 |
		IEEE80211_FC0_TYPE_CTL |
		IEEE80211_FC0_SUBTYPE_BAR;
	bar->i_ctl = tid->tidno << IEEE80211_BAR_CTL_TID_S |
		IEEE80211_BAR_CTL_COMBA;
	bar->i_seq = adf_os_cpu_to_le16(tid->seq_start << IEEE80211_SEQ_SEQ_SHIFT);
  909607:	0a0a4f        	extui	a10, a10, 0, 16
  90960a:	0a8b14        	srli	a11, a10, 8
  90960d:	2b6412        	s8i	a11, a6, 18
  909610:	2a6413        	s8i	a10, a6, 19

	bf->bf_seqno = tid->seq_start << IEEE80211_SEQ_SEQ_SHIFT;
  909613:	294523        	s16i	a9, a4, 70
 *         put, or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_put_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_put_tail(buf, size);
  909616:	da30      	mov.n	a10, a3
  909618:	c1b4      	movi.n	a11, 20
  90961a:	5be805        	call8	903630 <__adf_nbuf_put_tail>

	adf_nbuf_put_tail(skb, sizeof(struct ieee80211_frame_bar));

	bf->bf_comp = ath_bar_tx_comp;
  90961d:	1672c2        	l32r	a6, 8e6128 <memset+0xf8c>
	bf->bf_tidno = tid->tidno;
	bf->bf_node = &tid->an->ni;
	ath_dma_map(sc, bf);
  909620:	da20      	mov.n	a10, a2

	bf->bf_seqno = tid->seq_start << IEEE80211_SEQ_SEQ_SHIFT;

	adf_nbuf_put_tail(skb, sizeof(struct ieee80211_frame_bar));

	bf->bf_comp = ath_bar_tx_comp;
  909622:	964f      	s32i.n	a6, a4, 60
	bf->bf_tidno = tid->tidno;
  909624:	8670      	l32i.n	a6, a7, 0
	bf->bf_node = &tid->an->ni;
	ath_dma_map(sc, bf);
  909626:	db40      	mov.n	a11, a4
	bf->bf_seqno = tid->seq_start << IEEE80211_SEQ_SEQ_SHIFT;

	adf_nbuf_put_tail(skb, sizeof(struct ieee80211_frame_bar));

	bf->bf_comp = ath_bar_tx_comp;
	bf->bf_tidno = tid->tidno;
  909628:	26444d        	s8i	a6, a4, 77
	bf->bf_node = &tid->an->ni;
  90962b:	867e      	l32i.n	a6, a7, 56
  90962d:	9644      	s32i.n	a6, a4, 16
	ath_dma_map(sc, bf);
  90962f:	5bff9a        	call8	909498 <ath_dma_map>
 * @param[out] sg   map info
 */
static inline void
adf_nbuf_dmamap_info(adf_os_dma_map_t bmap, adf_os_dmamap_info_t *sg)
{
    __adf_nbuf_dmamap_info(bmap, sg);
  909632:	8a40      	l32i.n	a10, a4, 0
  909634:	b44b      	addi.n	a11, a4, 4
  909636:	5be7b1        	call8	9034fc <__adf_nbuf_dmamap_info>
	adf_nbuf_dmamap_info(bf->bf_dmamap, &bf->bf_dmamap_info);

	ds = bf->bf_desc;
	ah->ah_setupTxDesc(ds
  909639:	291220        	l32i	a9, a1, 128
 * @return The total length of this buf.
 */
static inline adf_os_size_t
adf_nbuf_len(adf_nbuf_t buf)
{
    return (__adf_nbuf_len(buf));
  90963c:	da30      	mov.n	a10, a3
  90963e:	289217        	l32i	a8, a9, 92
	bf->bf_tidno = tid->tidno;
	bf->bf_node = &tid->an->ni;
	ath_dma_map(sc, bf);
	adf_nbuf_dmamap_info(bf->bf_dmamap, &bf->bf_dmamap_info);

	ds = bf->bf_desc;
  909641:	864c      	l32i.n	a6, a4, 48
  909643:	281621        	s32i	a8, a1, 132
  909646:	5be80e        	call8	903680 <__adf_nbuf_len>
	ah->ah_setupTxDesc(ds
  909649:	234049        	l8ui	a3, a4, 73
  90964c:	c0fb      	movi.n	a15, 11
  90964e:	9311      	s32i.n	a3, a1, 4
  909650:	281221        	l32i	a8, a1, 132
  909653:	c131      	movi.n	a3, 17
  909655:	b4ab      	addi.n	a11, a10, 4
  909657:	9312      	s32i.n	a3, a1, 8
  909659:	da60      	mov.n	a10, a6
  90965b:	9f10      	s32i.n	a15, a1, 0
  90965d:	9513      	s32i.n	a5, a1, 12
  90965f:	9514      	s32i.n	a5, a1, 16
  909661:	dc50      	mov.n	a12, a5
  909663:	055d02        	or	a13, a5, a5
  909666:	2e0a3c        	movi	a14, 60
  909669:	0b8000        	callx8	a8
			    , HAL_TXDESC_INTREQ
			    | HAL_TXDESC_CLRDMASK
			    , 0, 0);

	skbhead = bf->bf_skbhead;
	bf->bf_isaggr = 0;
  90966c:	284087        	l8ui	a8, a4, 135
  90966f:	23fadf        	movi	a3, -33
  909672:	038301        	and	a3, a8, a3
  909675:	234487        	s8i	a3, a4, 135
	bf->bf_next = NULL;
  909678:	954b      	s32i.n	a5, a4, 44

	for (ds0 = ds, i=0; i < bf->bf_dmamap_info.nsegs; ds0++, i++) {
  90967a:	d360      	mov.n	a3, a6
  90967c:	260a88        	movi	a6, 136
  90967f:	600011        	j	909694 <ath_bar_tx+0x114>
  909682:	000000        	ill
		ah->ah_clr11nAggr(ds0);
  909685:	291220        	l32i	a9, a1, 128
  909688:	da30      	mov.n	a10, a3
  90968a:	289214        	l32i	a8, a9, 80

	skbhead = bf->bf_skbhead;
	bf->bf_isaggr = 0;
	bf->bf_next = NULL;

	for (ds0 = ds, i=0; i < bf->bf_dmamap_info.nsegs; ds0++, i++) {
  90968d:	a633      	add.n	a3, a3, a6
		ah->ah_clr11nAggr(ds0);
  90968f:	0b8000        	callx8	a8

	skbhead = bf->bf_skbhead;
	bf->bf_isaggr = 0;
	bf->bf_next = NULL;

	for (ds0 = ds, i=0; i < bf->bf_dmamap_info.nsegs; ds0++, i++) {
  909692:	b155      	addi.n	a5, a5, 1
  909694:	8841      	l32i.n	a8, a4, 4
  909696:	7853eb        	bltu	a5, a8, 909685 <ath_bar_tx+0x105>
		ah->ah_clr11nAggr(ds0);
	}

	ath_filltxdesc(sc, bf);
  909699:	022a02        	or	a10, a2, a2
  90969c:	044b02        	or	a11, a4, a4

	for (i = 0 ; i < 4; i++) {
		series[i].Tries = ATH_TXMAXTRY;
		series[i].Rate = min_rate;
		series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
  90969f:	232d16        	addmi	a3, a2, 0x1600

	for (ds0 = ds, i=0; i < bf->bf_dmamap_info.nsegs; ds0++, i++) {
		ah->ah_clr11nAggr(ds0);
	}

	ath_filltxdesc(sc, bf);
  9096a2:	5bfe95        	call8	9090f8 <ath_filltxdesc>

	for (i = 0 ; i < 4; i++) {
		series[i].Tries = ATH_TXMAXTRY;
		series[i].Rate = min_rate;
		series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
  9096a5:	283026        	l8ui	a8, a3, 38
  9096a8:	251c20        	addi	a5, a1, 32

	bf->bf_comp = NULL;
	ath_buf_comp(sc, bf);
}

static void ath_bar_tx(struct ath_softc_tgt *sc,
  9096ab:	261c70        	addi	a6, a1, 112
	}

	ath_filltxdesc(sc, bf);

	for (i = 0 ; i < 4; i++) {
		series[i].Tries = ATH_TXMAXTRY;
  9096ae:	c03b      	movi.n	a3, 11
  9096b0:	9350      	s32i.n	a3, a5, 0
		series[i].Rate = min_rate;
  9096b2:	9351      	s32i.n	a3, a5, 4
		series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
  9096b4:	9853      	s32i.n	a8, a5, 12
  9096b6:	255c14        	addi	a5, a5, 20
		ah->ah_clr11nAggr(ds0);
	}

	ath_filltxdesc(sc, bf);

	for (i = 0 ; i < 4; i++) {
  9096b9:	7659f3        	bne	a5, a6, 9096b0 <ath_bar_tx+0x130>
		series[i].Tries = ATH_TXMAXTRY;
		series[i].Rate = min_rate;
		series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
	}

	ah->ah_set11nRateScenario(bf->bf_desc, 0, 0, series, 4, 4);
  9096bc:	251220        	l32i	a5, a1, 128
  9096bf:	8a4c      	l32i.n	a10, a4, 48
  9096c1:	c0b0      	movi.n	a11, 0
  9096c3:	c0e4      	movi.n	a14, 4
  9096c5:	235210        	l32i	a3, a5, 64
  9096c8:	dcb0      	mov.n	a12, a11
  9096ca:	2d1c20        	addi	a13, a1, 32
  9096cd:	dfe0      	mov.n	a15, a14
  9096cf:	0b3000        	callx8	a3
	ath_tgt_txq_add_ucast(sc, bf);
  9096d2:	da20      	mov.n	a10, a2
  9096d4:	db40      	mov.n	a11, a4
  9096d6:	5bfe26        	call8	908f70 <ath_tgt_txq_add_ucast>
  9096d9:	d10f      	retw.n
	...

009096dc <ath_buf_comp>:
		ath_free_tx_skb(sc->tgt_htc_handle,endpt,tskb);
	}
}

static void ath_buf_comp(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  9096dc:	6c1004        	entry	a1, 32
	ath_dma_unmap(sc, bf);
  9096df:	022a02        	or	a10, a2, a2
  9096e2:	033b02        	or	a11, a3, a3
  9096e5:	5bfe74        	call8	9090b8 <ath_dma_unmap>
	ath_tgt_skb_free(sc, &bf->bf_skbhead,bf->bf_endpt);
  9096e8:	2c3223        	l32i	a12, a3, 140
  9096eb:	022a02        	or	a10, a2, a2
  9096ee:	2b3c14        	addi	a11, a3, 20
  9096f1:	5bfe77        	call8	9090d0 <ath_tgt_skb_free>
	bf->bf_skb = NULL;
  9096f4:	c090      	movi.n	a9, 0
				      a_uint8_t retry)
{
	struct ath_tx_buf *tmp = NULL;
	adf_nbuf_t buf = NULL;

	adf_os_assert(sc->sc_txbuf_held != NULL);
  9096f6:	2822dc        	l32i	a8, a2, 0x370

static void ath_buf_comp(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	ath_dma_unmap(sc, bf);
	ath_tgt_skb_free(sc, &bf->bf_skbhead,bf->bf_endpt);
	bf->bf_skb = NULL;
  9096f9:	9938      	s32i.n	a9, a3, 32
	bf->bf_node = NULL;
  9096fb:	9934      	s32i.n	a9, a3, 16
				      a_uint8_t retry)
{
	struct ath_tx_buf *tmp = NULL;
	adf_nbuf_t buf = NULL;

	adf_os_assert(sc->sc_txbuf_held != NULL);
  9096fd:	798903        	bne	a8, a9, 909704 <ath_buf_comp+0x28>
  909700:	63fffc        	j	909700 <ath_buf_comp+0x24>
  909703:	002326        	excw

		ath_dma_map(sc, tmp);
		ath_tx_tgt_setds(sc, tmp);
	}

	sc->sc_txbuf_held = bf;
  909706:	dc23      	excw
	ath_tgt_skb_free(sc, &bf->bf_skbhead,bf->bf_endpt);
	bf->bf_skb = NULL;
	bf->bf_node = NULL;
	bf = ath_buf_toggle(sc, bf, 0);
	if (bf != NULL) {
		asf_tailq_insert_tail(&sc->sc_txbuf, bf, bf_list);
  909708:	22f199        	l16ui	a2, a15, 0x132
  90970b:	8993      	l32i.n	a9, a9, 12
  90970d:	8a98      	l32i.n	a10, a9, 32
  90970f:	30288c        	excw
  909712:	242826        	excw
  909715:	f1          	.byte 0xf1
  909716:	d10f      	retw.n

00909718 <ath_tx_freebuf>:
	bf->bf_txq_add(sc, bf);
}

static void
ath_tx_freebuf(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  909718:	6c1004        	entry	a1, 32
	a_int32_t i ;
	struct ath_tx_desc *bfd = NULL;
	struct ath_hal *ah = sc->sc_ah;
  90971b:	242d05        	addmi	a4, a2, 0x500
  90971e:	864b      	l32i.n	a6, a4, 44

	for (bfd = bf->bf_desc, i = 0; i < bf->bf_dmamap_info.nsegs; bfd++, i++) {
  909720:	c050      	movi.n	a5, 0
  909722:	843c      	l32i.n	a4, a3, 48
  909724:	270a88        	movi	a7, 136
  909727:	600023        	j	90974e <ath_tx_freebuf+0x36>
  90972a:	000028        	mull	a0, a0, a0
		ah->ah_clr11nAggr(bfd);
  90972d:	6214da        	j	8eac0b <memset+0x5a6f>
  909730:	400b80        	excw
  909733:	002862        	excw
		ah->ah_set11nBurstDuration(bfd, 0);
  909736:	15044a        	l32r	a5, 8ca860 <_bss_end+0x3bd058>
  909739:	022b0a        	addx4	a11, a2, a2
  90973c:	000b80        	excw
  90973f:	002862        	excw
		ah->ah_set11nVirtualMoreFrag(bfd, 0);
  909742:	16da40        	l32r	a6, 900044 <memset+0x1aea8>
  909745:	c0b0      	movi.n	a11, 0
  909747:	0b8000        	callx8	a8
{
	a_int32_t i ;
	struct ath_tx_desc *bfd = NULL;
	struct ath_hal *ah = sc->sc_ah;

	for (bfd = bf->bf_desc, i = 0; i < bf->bf_dmamap_info.nsegs; bfd++, i++) {
  90974a:	a744      	add.n	a4, a4, a7
  90974c:	b155      	addi.n	a5, a5, 1
  90974e:	8831      	l32i.n	a8, a3, 4
  909750:	7853d8        	bltu	a5, a8, 90972c <ath_tx_freebuf+0x14>
		ah->ah_clr11nAggr(bfd);
		ah->ah_set11nBurstDuration(bfd, 0);
		ah->ah_set11nVirtualMoreFrag(bfd, 0);
	}

	ath_dma_unmap(sc, bf);
  909753:	022a02        	or	a10, a2, a2
  909756:	033b02        	or	a11, a3, a3
  909759:	5bfe57        	call8	9090b8 <ath_dma_unmap>

	ath_tgt_skb_free(sc, &bf->bf_skbhead,bf->bf_endpt);
  90975c:	2c3223        	l32i	a12, a3, 140
  90975f:	022a02        	or	a10, a2, a2
  909762:	2b3c14        	addi	a11, a3, 20
  909765:	5bfe5a        	call8	9090d0 <ath_tgt_skb_free>

	bf->bf_skb = NULL;
  909768:	c090      	movi.n	a9, 0
				      a_uint8_t retry)
{
	struct ath_tx_buf *tmp = NULL;
	adf_nbuf_t buf = NULL;

	adf_os_assert(sc->sc_txbuf_held != NULL);
  90976a:	2822dc        	l32i	a8, a2, 0x370

	ath_dma_unmap(sc, bf);

	ath_tgt_skb_free(sc, &bf->bf_skbhead,bf->bf_endpt);

	bf->bf_skb = NULL;
  90976d:	9938      	s32i.n	a9, a3, 32
	bf->bf_comp = NULL;
  90976f:	993f      	s32i.n	a9, a3, 60
	bf->bf_node = NULL;
  909771:	9934      	s32i.n	a9, a3, 16
	bf->bf_next = NULL;
  909773:	993b      	s32i.n	a9, a3, 44
				      a_uint8_t retry)
{
	struct ath_tx_buf *tmp = NULL;
	adf_nbuf_t buf = NULL;

	adf_os_assert(sc->sc_txbuf_held != NULL);
  909775:	798903        	bne	a8, a9, 90977c <ath_tx_freebuf+0x64>
  909778:	63fffc        	j	909778 <ath_tx_freebuf+0x60>
  90977b:	002326        	excw

		ath_dma_map(sc, tmp);
		ath_tx_tgt_setds(sc, tmp);
	}

	sc->sc_txbuf_held = bf;
  90977e:	dc24      	excw
	bf->bf_comp = NULL;
	bf->bf_node = NULL;
	bf->bf_next = NULL;
	bf = ath_buf_toggle(sc, bf, 0);
	bf->bf_retries = 0;
	bf->bf_isretried = 0;
  909780:	8087      	l32i.n	a0, a8, 28
  909782:	c63f      	movi.n	a3, -17
  909784:	034301        	and	a3, a4, a3
	bf->bf_skb = NULL;
	bf->bf_comp = NULL;
	bf->bf_node = NULL;
	bf->bf_next = NULL;
	bf = ath_buf_toggle(sc, bf, 0);
	bf->bf_retries = 0;
  909787:	298486        	s8i	a9, a8, 134
	bf->bf_isretried = 0;
  90978a:	238487        	s8i	a3, a8, 135

	if (bf != NULL)
		asf_tailq_insert_tail(&sc->sc_txbuf, bf, bf_list);
  90978d:	2322f1        	l32i	a3, a2, 0x3c4
  909790:	9989      	s32i.n	a9, a8, 36
  909792:	938a      	s32i.n	a3, a8, 40
  909794:	9830      	s32i.n	a8, a3, 0
  909796:	288c24        	addi	a8, a8, 36
  909799:	2826f1        	s32i	a8, a2, 0x3c4
  90979c:	d10f      	retw.n
	...

009097a0 <ATH_SKB_2_WH>:
int ath_tgt_tx_add_to_aggr(struct ath_softc_tgt *sc,
			   struct ath_buf *bf,int datatype,
			   ath_atx_tid_t *tid, int is_burst);

struct ieee80211_frame *ATH_SKB_2_WH(adf_nbuf_t skb)
{
  9097a0:	6c1006        	entry	a1, 48
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  9097a3:	da20      	mov.n	a10, a2
  9097a5:	b41b      	addi.n	a11, a1, 4
  9097a7:	dc10      	mov.n	a12, a1
  9097a9:	5be7bd        	call8	9036a0 <__adf_nbuf_peek_header>
	a_uint32_t anblen;

	adf_nbuf_peek_header(skb, &anbdata, &anblen);

	return((struct ieee80211_frame *)anbdata);
}
  9097ac:	8211      	l32i.n	a2, a1, 4
  9097ae:	d10f      	retw.n

009097b0 <ath_tx_set_retry>:
		INCR(tid->baw_head, ATH_TID_MAX_BUFS);
	}
}

static void ath_tx_set_retry(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  9097b0:	6c1004        	entry	a1, 32
	struct ieee80211_frame *wh;

	__stats(sc, txaggr_retries);
  9097b3:	282260        	l32i	a8, a2, 0x180

	bf->bf_isretried = 1;
	bf->bf_retries ++;
	wh = ATH_SKB_2_WH(bf->bf_skb);
  9097b6:	8a38      	l32i.n	a10, a3, 32

static void ath_tx_set_retry(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ieee80211_frame *wh;

	__stats(sc, txaggr_retries);
  9097b8:	b188      	addi.n	a8, a8, 1
  9097ba:	282660        	s32i	a8, a2, 0x180

	bf->bf_isretried = 1;
  9097bd:	283087        	l8ui	a8, a3, 135
  9097c0:	c120      	movi.n	a2, 16
  9097c2:	028202        	or	a2, a8, a2
  9097c5:	223487        	s8i	a2, a3, 135
	bf->bf_retries ++;
  9097c8:	223086        	l8ui	a2, a3, 134
  9097cb:	222c01        	addi	a2, a2, 1
  9097ce:	223486        	s8i	a2, a3, 134
	wh = ATH_SKB_2_WH(bf->bf_skb);
  9097d1:	5bfff3        	call8	9097a0 <ATH_SKB_2_WH>
	wh->i_fc[1] |= IEEE80211_FC1_RETRY;
  9097d4:	23a001        	l8ui	a3, a10, 1
  9097d7:	c028      	movi.n	a2, 8
  9097d9:	023202        	or	a2, a3, a2
  9097dc:	22a401        	s8i	a2, a10, 1
  9097df:	d10f      	retw.n
  9097e1:	000000        	ill

009097e4 <owl_tgt_node_init>:
		ath_aggr_resume_tid(sc, tid);
	}
}

void owl_tgt_node_init(struct ath_node_target * an)
{
  9097e4:	6c1004        	entry	a1, 32
	struct ath_atx_tid *tid;
	int tidno;

	for (tidno = 0, tid = &an->tid[tidno]; tidno < WME_NUM_TID;tidno++, tid++) {
  9097e7:	232c24        	addi	a3, a2, 36
  9097ea:	240a00        	movi	a4, 0
		tid->tidno = tidno;
		tid->an = an;

		if ( tid->flag & TID_CLEANUP_INPROGRES ) {
			tid->flag |= TID_REINITIALIZE;
  9097ed:	250a04        	movi	a5, 4

	for (tidno = 0, tid = &an->tid[tidno]; tidno < WME_NUM_TID;tidno++, tid++) {
		tid->tidno = tidno;
		tid->an = an;

		if ( tid->flag & TID_CLEANUP_INPROGRES ) {
  9097f0:	283036        	l8ui	a8, a3, 54
{
	struct ath_atx_tid *tid;
	int tidno;

	for (tidno = 0, tid = &an->tid[tidno]; tidno < WME_NUM_TID;tidno++, tid++) {
		tid->tidno = tidno;
  9097f3:	9430      	s32i.n	a4, a3, 0
		tid->an = an;
  9097f5:	923e      	s32i.n	a2, a3, 56

		if ( tid->flag & TID_CLEANUP_INPROGRES ) {
  9097f7:	7f871d        	bbci	a8, 31, 909818 <owl_tgt_node_init+0x34>
			tid->flag |= TID_REINITIALIZE;
  9097fa:	058802        	or	a8, a8, a5
  9097fd:	283436        	s8i	a8, a3, 54
			adf_os_print("tid[%p]->incomp is not 0: %d\n",
  909800:	187184        	l32r	a8, 8e5e10 <memset+0xc74>
  909803:	2c3037        	l8ui	a12, a3, 55
  909806:	288212        	l32i	a8, a8, 72
  909809:	1a72c3        	l32r	a10, 8e6318 <memset+0x117c>
  90980c:	db30      	mov.n	a11, a3
  90980e:	00cc32        	sext	a12, a12, 7
  909811:	0b8000        	callx8	a8
  909814:	600005        	j	90981d <owl_tgt_node_init+0x39>
  909817:	00da30        	excw
				     tid, tid->incomp);
		} else {
			owl_tgt_tid_init(tid);
  90981a:	5bfdc2        	call8	908f24 <owl_tgt_tid_init>
void owl_tgt_node_init(struct ath_node_target * an)
{
	struct ath_atx_tid *tid;
	int tidno;

	for (tidno = 0, tid = &an->tid[tidno]; tidno < WME_NUM_TID;tidno++, tid++) {
  90981d:	b144      	addi.n	a4, a4, 1
  90981f:	233c3c        	addi	a3, a3, 60
  909822:	6948ca        	bnei	a4, 8, 9097f0 <owl_tgt_node_init+0xc>
				     tid, tid->incomp);
		} else {
			owl_tgt_tid_init(tid);
		}
	}
}
  909825:	d10f      	retw.n
	...

00909828 <ath_tx_status_clear>:

void ath_tx_status_clear(struct ath_softc_tgt *sc)
{
  909828:	6c1004        	entry	a1, 32
	int i;

	for (i = 0; i < 2; i++) {
		sc->tx_status[i].cnt = 0;
  90982b:	222d16        	addmi	a2, a2, 0x1600
  90982e:	c080      	movi.n	a8, 0
  909830:	282438        	s8i	a8, a2, 56
  909833:	28245d        	s8i	a8, a2, 93
  909836:	d10f      	retw.n

00909838 <ath_tx_status_update>:

	return txs;
}

void ath_tx_status_update(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  909838:	6c1004        	entry	a1, 32
	struct ath_tx_desc *ds = bf->bf_lastds;
	WMI_TXSTATUS_EVENT *txs;

	if (sc->sc_tx_draining)
  90983b:	282249        	l32i	a8, a2, 0x124
  90983e:	14724a        	l32r	a4, 8e6168 <memset+0xfcc>

	return txs;
}

void ath_tx_status_update(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  909841:	da20      	mov.n	a10, a2
	struct ath_tx_desc *ds = bf->bf_lastds;
	WMI_TXSTATUS_EVENT *txs;

	if (sc->sc_tx_draining)
  909843:	048401        	and	a4, a8, a4
	return txs;
}

void ath_tx_status_update(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_tx_desc *ds = bf->bf_lastds;
  909846:	2c320e        	l32i	a12, a3, 56
	WMI_TXSTATUS_EVENT *txs;

	if (sc->sc_tx_draining)
  909849:	654074        	bnez	a4, 9098c1 <ath_tx_status_update+0x89>
{
	WMI_TXSTATUS_EVENT *txs = NULL;
	int i;

	for (i = 0; i < 2; i++) {
		if (sc->tx_status[i].cnt < HTC_MAX_TX_STATUS) {
  90984c:	292d16        	addmi	a9, a2, 0x1600
  90984f:	2b9038        	l8ui	a11, a9, 56
  909852:	280a0b        	movi	a8, 11
  909855:	7b8b07        	bgeu	a8, a11, 909860 <ath_tx_status_update+0x28>
  909858:	24905d        	l8ui	a4, a9, 93
  90985b:	748362        	bltu	a8, a4, 9098c1 <ath_tx_status_update+0x89>
static WMI_TXSTATUS_EVENT *ath_tx_status_get(struct ath_softc_tgt *sc)
{
	WMI_TXSTATUS_EVENT *txs = NULL;
	int i;

	for (i = 0; i < 2; i++) {
  90985e:	c041      	movi.n	a4, 1
		if (sc->tx_status[i].cnt < HTC_MAX_TX_STATUS) {
			txs = &sc->tx_status[i];
  909860:	04480b        	addx8	a8, a4, a4
  909863:	04840a        	addx4	a4, a8, a4
  909866:	1872c4        	l32r	a8, 8e6378 <memset+0x11dc>

	txs = ath_tx_status_get(sc);
	if (txs == NULL)
		return;

	txs->txstatus[txs->cnt].ts_flags = 0;
  909869:	c0b0      	movi.n	a11, 0
	WMI_TXSTATUS_EVENT *txs = NULL;
	int i;

	for (i = 0; i < 2; i++) {
		if (sc->tx_status[i].cnt < HTC_MAX_TX_STATUS) {
			txs = &sc->tx_status[i];
  90986b:	a844      	add.n	a4, a4, a8
  90986d:	a4a4      	add.n	a4, a10, a4

	txs = ath_tx_status_get(sc);
	if (txs == NULL)
		return;

	txs->txstatus[txs->cnt].ts_flags = 0;
  90986f:	284008        	l8ui	a8, a4, 8
	WMI_TXSTATUS_EVENT *txs = NULL;
	int i;

	for (i = 0; i < 2; i++) {
		if (sc->tx_status[i].cnt < HTC_MAX_TX_STATUS) {
			txs = &sc->tx_status[i];
  909872:	2d4c08        	addi	a13, a4, 8

	txs = ath_tx_status_get(sc);
	if (txs == NULL)
		return;

	txs->txstatus[txs->cnt].ts_flags = 0;
  909875:	088909        	addx2	a9, a8, a8
  909878:	a9d9      	add.n	a9, a13, a9
  90987a:	2b9403        	s8i	a11, a9, 3

	txs->txstatus[txs->cnt].cookie = bf->bf_cookie;
  90987d:	2b3092        	l8ui	a11, a3, 146
  909880:	2b9401        	s8i	a11, a9, 1
	txs->txstatus[txs->cnt].ts_rate = SM(bf->bf_endpt, ATH9K_HTC_TXSTAT_EPID);
  909883:	2b3223        	l32i	a11, a3, 140
  909886:	0cbb11        	slli	a11, a11, 4
  909889:	2b9402        	s8i	a11, a9, 2

	if (ds->ds_txstat.ts_status & HAL_TXERR_FILT)
  90988c:	2bc066        	l8ui	a11, a12, 102
  90988f:	7eb705        	bbci	a11, 30, 909898 <ath_tx_status_update+0x60>
		txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_FILT;
  909892:	2b0a02        	movi	a11, 2
  909895:	2b9403        	s8i	a11, a9, 3

	if (!(ds->ds_txstat.ts_status & HAL_TXERR_XRETRY) &&
  909898:	2bc066        	l8ui	a11, a12, 102
  90989b:	c197      	movi.n	a9, 23
  90989d:	79b80f        	bany	a11, a9, 9098b0 <ath_tx_status_update+0x78>
	    !(ds->ds_txstat.ts_status & HAL_TXERR_FIFO) &&
	    !(ds->ds_txstat.ts_status & HAL_TXERR_TIMER_EXPIRED) &&
	    !(ds->ds_txstat.ts_status & HAL_TXERR_FILT))
		txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_ACK;
  9098a0:	088809        	addx2	a8, a8, a8
  9098a3:	a8d8      	add.n	a8, a13, a8
  9098a5:	2b8003        	l8ui	a11, a8, 3
  9098a8:	c091      	movi.n	a9, 1
  9098aa:	09b902        	or	a9, a11, a9
  9098ad:	298403        	s8i	a9, a8, 3

	ath_tx_status_update_rate(sc, bf->bf_rcs, ds->ds_txstat.ts_rate, txs);
  9098b0:	2cc068        	l8ui	a12, a12, 104
  9098b3:	2b3c50        	addi	a11, a3, 80
  9098b6:	5bfd24        	call8	908d48 <ath_tx_status_update_rate>

	txs->cnt++;
  9098b9:	234008        	l8ui	a3, a4, 8
  9098bc:	b133      	addi.n	a3, a3, 1
  9098be:	234408        	s8i	a3, a4, 8
  9098c1:	d10f      	retw.n
	...

009098c4 <ath_tx_status_update_aggr>:
}

void ath_tx_status_update_aggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
			       struct ath_tx_desc *ds, struct ath_rc_series rcs[],
			       int txok)
{
  9098c4:	6c1004        	entry	a1, 32
	WMI_TXSTATUS_EVENT *txs;

	if (sc->sc_tx_draining)
  9098c7:	282249        	l32i	a8, a2, 0x124
  9098ca:	17724a        	l32r	a7, 8e61f4 <memset+0x1058>
}

void ath_tx_status_update_aggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
			       struct ath_tx_desc *ds, struct ath_rc_series rcs[],
			       int txok)
{
  9098cd:	da20      	mov.n	a10, a2
	WMI_TXSTATUS_EVENT *txs;

	if (sc->sc_tx_draining)
  9098cf:	078701        	and	a7, a8, a7
}

void ath_tx_status_update_aggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
			       struct ath_tx_desc *ds, struct ath_rc_series rcs[],
			       int txok)
{
  9098d2:	db50      	mov.n	a11, a5
	WMI_TXSTATUS_EVENT *txs;

	if (sc->sc_tx_draining)
  9098d4:	657058        	bnez	a7, 909930 <ath_tx_status_update_aggr+0x6c>
{
	WMI_TXSTATUS_EVENT *txs = NULL;
	int i;

	for (i = 0; i < 2; i++) {
		if (sc->tx_status[i].cnt < HTC_MAX_TX_STATUS) {
  9098d7:	292d16        	addmi	a9, a2, 0x1600
  9098da:	2c9038        	l8ui	a12, a9, 56
  9098dd:	280a0b        	movi	a8, 11
  9098e0:	7c8b08        	bgeu	a8, a12, 9098ec <ath_tx_status_update_aggr+0x28>
  9098e3:	27905d        	l8ui	a7, a9, 93
  9098e6:	778346        	bltu	a8, a7, 909930 <ath_tx_status_update_aggr+0x6c>
static WMI_TXSTATUS_EVENT *ath_tx_status_get(struct ath_softc_tgt *sc)
{
	WMI_TXSTATUS_EVENT *txs = NULL;
	int i;

	for (i = 0; i < 2; i++) {
  9098e9:	270a01        	movi	a7, 1
		if (sc->tx_status[i].cnt < HTC_MAX_TX_STATUS) {
			txs = &sc->tx_status[i];
  9098ec:	07780b        	addx8	a8, a7, a7
  9098ef:	07870a        	addx4	a7, a8, a7
  9098f2:	1872c4        	l32r	a8, 8e6404 <memset+0x1268>

	txs = ath_tx_status_get(sc);
	if (txs == NULL)
		return;

	txs->txstatus[txs->cnt].cookie = bf->bf_cookie;
  9098f5:	293092        	l8ui	a9, a3, 146
	WMI_TXSTATUS_EVENT *txs = NULL;
	int i;

	for (i = 0; i < 2; i++) {
		if (sc->tx_status[i].cnt < HTC_MAX_TX_STATUS) {
			txs = &sc->tx_status[i];
  9098f8:	a877      	add.n	a7, a7, a8
  9098fa:	a7a7      	add.n	a7, a10, a7

	txs = ath_tx_status_get(sc);
	if (txs == NULL)
		return;

	txs->txstatus[txs->cnt].cookie = bf->bf_cookie;
  9098fc:	287008        	l8ui	a8, a7, 8
	WMI_TXSTATUS_EVENT *txs = NULL;
	int i;

	for (i = 0; i < 2; i++) {
		if (sc->tx_status[i].cnt < HTC_MAX_TX_STATUS) {
			txs = &sc->tx_status[i];
  9098ff:	b87d      	addi.n	a13, a7, 8

	txs = ath_tx_status_get(sc);
	if (txs == NULL)
		return;

	txs->txstatus[txs->cnt].cookie = bf->bf_cookie;
  909901:	088809        	addx2	a8, a8, a8
  909904:	a8d8      	add.n	a8, a13, a8
  909906:	298401        	s8i	a9, a8, 1
	txs->txstatus[txs->cnt].ts_rate = SM(bf->bf_endpt, ATH9K_HTC_TXSTAT_EPID);
  909909:	233223        	l32i	a3, a3, 140
  90990c:	0c3311        	slli	a3, a3, 4
  90990f:	238402        	s8i	a3, a8, 2

	if (txok)
  909912:	c86a      	beqz.n	a6, 909920 <ath_tx_status_update_aggr+0x5c>
		txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_ACK;
  909914:	298003        	l8ui	a9, a8, 3
  909917:	230a01        	movi	a3, 1
  90991a:	039302        	or	a3, a9, a3
  90991d:	238403        	s8i	a3, a8, 3

	if (rcs)
  909920:	c8b4      	beqz.n	a11, 909928 <ath_tx_status_update_aggr+0x64>
		ath_tx_status_update_rate(sc, rcs, ds->ds_txstat.ts_rate, txs);
  909922:	2c4068        	l8ui	a12, a4, 104
  909925:	5bfd08        	call8	908d48 <ath_tx_status_update_rate>

	txs->cnt++;
  909928:	237008        	l8ui	a3, a7, 8
  90992b:	b133      	addi.n	a3, a3, 1
  90992d:	237408        	s8i	a3, a7, 8
  909930:	d10f      	retw.n
	...

00909934 <ath_tx_retry_subframe>:
}

static void
ath_tx_retry_subframe(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
		      ath_tx_bufhead *bf_q, struct ath_tx_buf **bar)
{
  909934:	6c1006        	entry	a1, 48
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
	struct ath_tx_desc *ds = NULL;
	struct ath_hal *ah = sc->sc_ah;
	int i = 0;

	__stats(sc, txaggr_compretries);
  909937:	262263        	l32i	a6, a2, 0x18c
}

static void
ath_tx_retry_subframe(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
		      ath_tx_bufhead *bf_q, struct ath_tx_buf **bar)
{
  90993a:	d850      	mov.n	a8, a5
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
	struct ath_tx_desc *ds = NULL;
	struct ath_hal *ah = sc->sc_ah;
	int i = 0;

	__stats(sc, txaggr_compretries);
  90993c:	b166      	addi.n	a6, a6, 1
{

	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
	struct ath_tx_desc *ds = NULL;
	struct ath_hal *ah = sc->sc_ah;
  90993e:	252d05        	addmi	a5, a2, 0x500
static void
ath_tx_retry_subframe(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
		      ath_tx_bufhead *bf_q, struct ath_tx_buf **bar)
{

	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
  909941:	8c34      	l32i.n	a12, a3, 16
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  909943:	29304d        	l8ui	a9, a3, 77
	struct ath_tx_desc *ds = NULL;
	struct ath_hal *ah = sc->sc_ah;
  909946:	855b      	l32i.n	a5, a5, 44
	int i = 0;

	__stats(sc, txaggr_compretries);
  909948:	262663        	s32i	a6, a2, 0x18c

	for(ds = bf->bf_desc, i = 0; i < bf->bf_dmamap_info.nsegs; ds++, i++) {
  90994b:	c070      	movi.n	a7, 0
  90994d:	863c      	l32i.n	a6, a3, 48
  90994f:	2d0a88        	movi	a13, 136
  909952:	600030        	j	909986 <ath_tx_retry_subframe+0x52>
		ah->ah_clr11nAggr(ds);
  909955:	2b5214        	l32i	a11, a5, 80
  909958:	da60      	mov.n	a10, a6
  90995a:	9813      	s32i.n	a8, a1, 12
  90995c:	9911      	s32i.n	a9, a1, 4
  90995e:	9c10      	s32i.n	a12, a1, 0
  909960:	9d12      	s32i.n	a13, a1, 8
  909962:	0bb000        	callx8	a11
		ah->ah_set11nBurstDuration(ds, 0);
  909965:	2e5215        	l32i	a14, a5, 84
  909968:	066a02        	or	a10, a6, a6
  90996b:	c0b0      	movi.n	a11, 0
  90996d:	0be000        	callx8	a14
		ah->ah_set11nVirtualMoreFrag(ds, 0);
  909970:	2e5216        	l32i	a14, a5, 88
  909973:	da60      	mov.n	a10, a6
  909975:	c0b0      	movi.n	a11, 0
  909977:	0be000        	callx8	a14
	struct ath_hal *ah = sc->sc_ah;
	int i = 0;

	__stats(sc, txaggr_compretries);

	for(ds = bf->bf_desc, i = 0; i < bf->bf_dmamap_info.nsegs; ds++, i++) {
  90997a:	8d12      	l32i.n	a13, a1, 8
  90997c:	8c10      	l32i.n	a12, a1, 0
  90997e:	8911      	l32i.n	a9, a1, 4
  909980:	8813      	l32i.n	a8, a1, 12
  909982:	ad66      	add.n	a6, a6, a13
  909984:	b177      	addi.n	a7, a7, 1
  909986:	8b31      	l32i.n	a11, a3, 4
  909988:	7b73c9        	bltu	a7, a11, 909955 <ath_tx_retry_subframe+0x21>
		ah->ah_clr11nAggr(ds);
		ah->ah_set11nBurstDuration(ds, 0);
		ah->ah_set11nVirtualMoreFrag(ds, 0);
	}

	if (bf->bf_retries >= OWLMAX_RETRIES) {
  90998b:	253086        	l8ui	a5, a3, 134
  90998e:	c069      	movi.n	a6, 9
  909990:	756b40        	bgeu	a6, a5, 9099d4 <ath_tx_retry_subframe+0xa0>
		__stats(sc, txaggr_xretries);
  909993:	242274        	l32i	a4, a2, 0x1d0
		ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  909996:	2b3123        	l16ui	a11, a3, 70
		ah->ah_set11nBurstDuration(ds, 0);
		ah->ah_set11nVirtualMoreFrag(ds, 0);
	}

	if (bf->bf_retries >= OWLMAX_RETRIES) {
		__stats(sc, txaggr_xretries);
  909999:	b144      	addi.n	a4, a4, 1
  90999b:	242674        	s32i	a4, a2, 0x1d0
ath_tx_retry_subframe(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
		      ath_tx_bufhead *bf_q, struct ath_tx_buf **bar)
{

	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90999e:	0c9411        	slli	a4, a9, 4
  9099a1:	09490c        	sub	a9, a4, a9
  9099a4:	0c9a0a        	addx4	a10, a9, a12
		ah->ah_set11nVirtualMoreFrag(ds, 0);
	}

	if (bf->bf_retries >= OWLMAX_RETRIES) {
		__stats(sc, txaggr_xretries);
		ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  9099a7:	2aac24        	addi	a10, a10, 36
  9099aa:	0b4b14        	srli	a11, a11, 4
  9099ad:	9813      	s32i.n	a8, a1, 12
  9099af:	5bfdaa        	call8	909058 <ath_tx_update_baw>
		ath_tx_status_update_aggr(sc, bf, bf->bf_lastds, NULL, 0);
  9099b2:	c0d0      	movi.n	a13, 0
  9099b4:	8c3e      	l32i.n	a12, a3, 56
  9099b6:	da20      	mov.n	a10, a2
  9099b8:	db30      	mov.n	a11, a3
  9099ba:	0dde02        	or	a14, a13, a13
  9099bd:	5bffc1        	call8	9098c4 <ath_tx_status_update_aggr>

		if (!*bar)
  9099c0:	8813      	l32i.n	a8, a1, 12
  9099c2:	8480      	l32i.n	a4, a8, 0
  9099c4:	cc42      	bnez.n	a4, 9099ca <ath_tx_retry_subframe+0x96>
			*bar = bf;
  9099c6:	9380      	s32i.n	a3, a8, 0
  9099c8:	d10f      	retw.n
		else
			ath_tx_freebuf(sc, bf);
  9099ca:	da20      	mov.n	a10, a2
  9099cc:	db30      	mov.n	a11, a3
  9099ce:	5bff52        	call8	909718 <ath_tx_freebuf>
  9099d1:	d10f      	retw.n
  9099d3:	00853b        	movgez	a5, a8, a0
		return;
	}

	if (!bf->bf_next) {
  9099d6:	cd54      	bnez.n	a5, 9099ee <ath_tx_retry_subframe+0xba>
		__stats(sc, txaggr_errlast);
  9099d8:	252267        	l32i	a5, a2, 0x19c
		bf = ath_buf_toggle(sc, bf, 1);
  9099db:	db30      	mov.n	a11, a3
			ath_tx_freebuf(sc, bf);
		return;
	}

	if (!bf->bf_next) {
		__stats(sc, txaggr_errlast);
  9099dd:	b155      	addi.n	a5, a5, 1
  9099df:	252667        	s32i	a5, a2, 0x19c
		bf = ath_buf_toggle(sc, bf, 1);
  9099e2:	da20      	mov.n	a10, a2
  9099e4:	c0c1      	movi.n	a12, 1
  9099e6:	5bfeb2        	call8	9094b0 <ath_buf_toggle>
  9099e9:	d3a0      	mov.n	a3, a10
  9099eb:	60000d        	j	9099fc <ath_tx_retry_subframe+0xc8>
	} else
		bf->bf_lastds = &(bf->bf_descarr[bf->bf_dmamap_info.nsegs - 1]);
  9099ee:	b0b5      	addi.n	a5, a11, -1
  9099f0:	0c5611        	slli	a6, a5, 4
  9099f3:	a565      	add.n	a5, a6, a5
  9099f5:	863d      	l32i.n	a6, a3, 52
  9099f7:	06550b        	addx8	a5, a5, a6
  9099fa:	953e      	s32i.n	a5, a3, 56

	ath_tx_set_retry(sc, bf);
  9099fc:	da20      	mov.n	a10, a2
  9099fe:	db30      	mov.n	a11, a3
	asf_tailq_insert_tail(bf_q, bf, bf_list);
  909a00:	c020      	movi.n	a2, 0
		__stats(sc, txaggr_errlast);
		bf = ath_buf_toggle(sc, bf, 1);
	} else
		bf->bf_lastds = &(bf->bf_descarr[bf->bf_dmamap_info.nsegs - 1]);

	ath_tx_set_retry(sc, bf);
  909a02:	5bff6b        	call8	9097b0 <ath_tx_set_retry>
	asf_tailq_insert_tail(bf_q, bf, bf_list);
  909a05:	9239      	s32i.n	a2, a3, 36
  909a07:	8241      	l32i.n	a2, a4, 4
  909a09:	923a      	s32i.n	a2, a3, 40
  909a0b:	9320      	s32i.n	a3, a2, 0
  909a0d:	233c24        	addi	a3, a3, 36
  909a10:	9341      	s32i.n	a3, a4, 4
  909a12:	d10f      	retw.n

00909a14 <ath_tx_comp_aggr_error>:
}

static void
ath_tx_comp_aggr_error(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
		       ath_atx_tid_t *tid)
{
  909a14:	6c1020        	entry	a1, 0x100


	struct ath_tx_desc lastds;
	struct ath_tx_desc *ds = &lastds;
	struct ath_rc_series rcs[4];
	struct ath_tx_buf *bar = NULL;
  909a17:	c060      	movi.n	a6, 0
  909a19:	261630        	s32i	a6, a1, 192
	struct ath_tx_buf *bf_next;
	int nframes = bf->bf_nframes;
	ath_tx_bufhead bf_q;
	struct ath_txq *txq;

	asf_tailq_init(&bf_q);
  909a1c:	26162e        	s32i	a6, a1, 184
 * @param[in] size    buffer size
 */
static inline void
adf_os_mem_copy(void *dst, const void *src, adf_os_size_t size)
{
    __adf_os_mem_copy(dst, src, size);
  909a1f:	8b3e      	l32i.n	a11, a3, 56
  909a21:	260ab8        	movi	a6, 184
  909a24:	a616      	add.n	a6, a1, a6
  909a26:	011a02        	or	a10, a1, a1
  909a29:	2c0a88        	movi	a12, 136
	struct ath_tx_desc lastds;
	struct ath_tx_desc *ds = &lastds;
	struct ath_rc_series rcs[4];
	struct ath_tx_buf *bar = NULL;
	struct ath_tx_buf *bf_next;
	int nframes = bf->bf_nframes;
  909a2c:	25304c        	l8ui	a5, a3, 76
	ath_tx_bufhead bf_q;
	struct ath_txq *txq;

	asf_tailq_init(&bf_q);
  909a2f:	26162f        	s32i	a6, a1, 188
	txq = bf->bf_txq;
  909a32:	273220        	l32i	a7, a3, 128
  909a35:	5bfd22        	call8	908ec0 <__adf_os_mem_copy>
  909a38:	2a0a88        	movi	a10, 136
  909a3b:	aa1a      	add.n	a10, a1, a10
  909a3d:	2b3c50        	addi	a11, a3, 80
  909a40:	2c0a30        	movi	a12, 48
  909a43:	5bfd1f        	call8	908ec0 <__adf_os_mem_copy>
	adf_os_mem_copy(ds, bf->bf_lastds, sizeof (struct ath_tx_desc));
	adf_os_mem_copy(rcs, bf->bf_rcs, sizeof(rcs));

	while (bf) {
		bf_next = bf->bf_next;
		ath_tx_retry_subframe(sc, bf, &bf_q, &bar);
  909a46:	066802        	or	a8, a6, a6
  909a49:	2d0ac0        	movi	a13, 192

	adf_os_mem_copy(ds, bf->bf_lastds, sizeof (struct ath_tx_desc));
	adf_os_mem_copy(rcs, bf->bf_rcs, sizeof(rcs));

	while (bf) {
		bf_next = bf->bf_next;
  909a4c:	863b      	l32i.n	a6, a3, 44
		ath_tx_retry_subframe(sc, bf, &bf_q, &bar);
  909a4e:	db30      	mov.n	a11, a3
  909a50:	dc80      	mov.n	a12, a8
  909a52:	022a02        	or	a10, a2, a2
  909a55:	a1dd      	add.n	a13, a13, a1
  909a57:	281634        	s32i	a8, a1, 208
  909a5a:	5bffb6        	call8	909934 <ath_tx_retry_subframe>
		bf = bf_next;
  909a5d:	d360      	mov.n	a3, a6
	txq = bf->bf_txq;

	adf_os_mem_copy(ds, bf->bf_lastds, sizeof (struct ath_tx_desc));
	adf_os_mem_copy(rcs, bf->bf_rcs, sizeof(rcs));

	while (bf) {
  909a5f:	281234        	l32i	a8, a1, 208
  909a62:	656fe3        	bnez	a6, 909a49 <ath_tx_comp_aggr_error+0x35>
		bf_next = bf->bf_next;
		ath_tx_retry_subframe(sc, bf, &bf_q, &bar);
		bf = bf_next;
	}

	ath_update_aggr_stats(sc, ds, nframes, nframes);
  909a65:	022a02        	or	a10, a2, a2
  909a68:	011b02        	or	a11, a1, a1
  909a6b:	5bfdea        	call8	909214 <ath_update_aggr_stats$isra$2>
	ath_rate_tx_complete(sc, tid->an, ds, rcs, nframes, nframes);
  909a6e:	8b4e      	l32i.n	a11, a4, 56
  909a70:	2d0a88        	movi	a13, 136
  909a73:	dc10      	mov.n	a12, a1
  909a75:	da20      	mov.n	a10, a2
  909a77:	ad1d      	add.n	a13, a1, a13
  909a79:	de50      	mov.n	a14, a5
  909a7b:	df50      	mov.n	a15, a5
  909a7d:	5bfcf1        	call8	908e44 <ath_rate_tx_complete>

	if (bar) {
  909a80:	2c1230        	l32i	a12, a1, 192
  909a83:	c8c5      	beqz.n	a12, 909a8c <ath_tx_comp_aggr_error+0x78>
		ath_bar_tx(sc, tid, bar);
  909a85:	da20      	mov.n	a10, a2
  909a87:	db40      	mov.n	a11, a4
  909a89:	5bfebd        	call8	909580 <ath_bar_tx>
	}

	if (!asf_tailq_empty(&bf_q)) {
  909a8c:	23122e        	l32i	a3, a1, 184
  909a8f:	ca3d      	beqz.n	a3, 909ac0 <ath_tx_comp_aggr_error+0xac>
		__stats(sc, txaggr_prepends);
  909a91:	232264        	l32i	a3, a2, 0x190
  909a94:	b133      	addi.n	a3, a3, 1
  909a96:	232664        	s32i	a3, a2, 0x190
		TAILQ_INSERTQ_HEAD(&tid->buf_q, &bf_q, bf_list);
  909a99:	834b      	l32i.n	a3, a4, 44
  909a9b:	22122f        	l32i	a2, a1, 188
  909a9e:	c83b      	beqz.n	a3, 909aad <ath_tx_comp_aggr_error+0x99>
  909aa0:	9320      	s32i.n	a3, a2, 0
  909aa2:	824b      	l32i.n	a2, a4, 44
  909aa4:	23122f        	l32i	a3, a1, 188
  909aa7:	932a      	s32i.n	a3, a2, 40
  909aa9:	600002        	j	909aaf <ath_tx_comp_aggr_error+0x9b>
  909aac:	00924c        	extui	a2, a0, 9, 13
  909aaf:	22122e        	l32i	a2, a1, 184
  909ab2:	234c2c        	addi	a3, a4, 44
  909ab5:	924b      	s32i.n	a2, a4, 44
  909ab7:	932a      	s32i.n	a3, a2, 40
		ath_tgt_tx_enqueue(txq, tid);
  909ab9:	da70      	mov.n	a10, a7
  909abb:	db40      	mov.n	a11, a4
  909abd:	5bfdcc        	call8	9091f0 <ath_tgt_tx_enqueue>
  909ac0:	d10f      	retw.n
	...

00909ac4 <ath_tx_status_send>:

	txs->cnt++;
}

void ath_tx_status_send(struct ath_softc_tgt *sc)
{
  909ac4:	6c1004        	entry	a1, 32
	int i;

	if (sc->sc_tx_draining)
  909ac7:	242249        	l32i	a4, a2, 0x124
  909aca:	13724a        	l32r	a3, 8e63f4 <memset+0x1258>
  909acd:	034401        	and	a4, a4, a3
  909ad0:	cf44      	bnez.n	a4, 909b08 <ath_tx_status_send+0x44>
		return;

	for (i = 0; i < 2; i++) {
		if (sc->tx_status[i].cnt) {
  909ad2:	232d16        	addmi	a3, a2, 0x1600
  909ad5:	283038        	l8ui	a8, a3, 56
  909ad8:	c980      	beqz.n	a8, 909aec <ath_tx_status_send+0x28>
			wmi_event(sc->tgt_wmi_handle, WMI_TXSTATUS_EVENTID,
  909ada:	1c72c6        	l32r	a12, 8e65f4 <memset+0x1458>
  909add:	8a23      	l32i.n	a10, a2, 12
  909adf:	1b72c5        	l32r	a11, 8e65f4 <memset+0x1458>
  909ae2:	ac2c      	add.n	a12, a2, a12
  909ae4:	c2d5      	movi.n	a13, 37
  909ae6:	5bf441        	call8	906bec <wmi_event>
				  &sc->tx_status[i], sizeof(WMI_TXSTATUS_EVENT));
			/* FIXME: Handle failures. */
			sc->tx_status[i].cnt = 0;
  909ae9:	243438        	s8i	a4, a3, 56

	if (sc->sc_tx_draining)
		return;

	for (i = 0; i < 2; i++) {
		if (sc->tx_status[i].cnt) {
  909aec:	232d16        	addmi	a3, a2, 0x1600
  909aef:	24305d        	l8ui	a4, a3, 93
  909af2:	c942      	beqz.n	a4, 909b08 <ath_tx_status_send+0x44>
			wmi_event(sc->tgt_wmi_handle, WMI_TXSTATUS_EVENTID,
  909af4:	1c72c7        	l32r	a12, 8e6610 <memset+0x1474>
  909af7:	8a23      	l32i.n	a10, a2, 12
  909af9:	1b72c5        	l32r	a11, 8e6610 <memset+0x1474>
  909afc:	ac2c      	add.n	a12, a2, a12
  909afe:	c2d5      	movi.n	a13, 37
				  &sc->tx_status[i], sizeof(WMI_TXSTATUS_EVENT));
			/* FIXME: Handle failures. */
			sc->tx_status[i].cnt = 0;
  909b00:	c020      	movi.n	a2, 0
	if (sc->sc_tx_draining)
		return;

	for (i = 0; i < 2; i++) {
		if (sc->tx_status[i].cnt) {
			wmi_event(sc->tgt_wmi_handle, WMI_TXSTATUS_EVENTID,
  909b02:	5bf43a        	call8	906bec <wmi_event>
				  &sc->tx_status[i], sizeof(WMI_TXSTATUS_EVENT));
			/* FIXME: Handle failures. */
			sc->tx_status[i].cnt = 0;
  909b05:	22345d        	s8i	a2, a3, 93
  909b08:	d10f      	retw.n
	...

00909b0c <ath_tgt_tid_drain>:
	return((struct ieee80211_frame *)anbdata);
}

void
ath_tgt_tid_drain(struct ath_softc_tgt *sc, struct ath_atx_tid *tid)
{
  909b0c:	6c1004        	entry	a1, 32
	struct ath_tx_buf *bf;

	while (!asf_tailq_empty(&tid->buf_q)) {
  909b0f:	600015        	j	909b28 <ath_tgt_tid_drain+0x1c>
		TAILQ_DEQ(&tid->buf_q, bf, bf_list);
  909b12:	88b9      	l32i.n	a8, a11, 36
  909b14:	89ba      	l32i.n	a9, a11, 40
  909b16:	c883      	beqz.n	a8, 909b1d <ath_tgt_tid_drain+0x11>
  909b18:	998a      	s32i.n	a9, a8, 40
  909b1a:	600001        	j	909b1f <ath_tgt_tid_drain+0x13>
  909b1d:	993c      	s32i.n	a9, a3, 48
  909b1f:	89ba      	l32i.n	a9, a11, 40
		ath_tx_freebuf(sc, bf);
  909b21:	da20      	mov.n	a10, a2
ath_tgt_tid_drain(struct ath_softc_tgt *sc, struct ath_atx_tid *tid)
{
	struct ath_tx_buf *bf;

	while (!asf_tailq_empty(&tid->buf_q)) {
		TAILQ_DEQ(&tid->buf_q, bf, bf_list);
  909b23:	9890      	s32i.n	a8, a9, 0
		ath_tx_freebuf(sc, bf);
  909b25:	5bfefc        	call8	909718 <ath_tx_freebuf>
void
ath_tgt_tid_drain(struct ath_softc_tgt *sc, struct ath_atx_tid *tid)
{
	struct ath_tx_buf *bf;

	while (!asf_tailq_empty(&tid->buf_q)) {
  909b28:	8b3b      	l32i.n	a11, a3, 44
  909b2a:	65bfe4        	bnez	a11, 909b12 <ath_tgt_tid_drain+0x6>
		TAILQ_DEQ(&tid->buf_q, bf, bf_list);
		ath_tx_freebuf(sc, bf);
	}

	tid->seq_next = tid->seq_start;
  909b2d:	223102        	l16ui	a2, a3, 4
  909b30:	223503        	s16i	a2, a3, 6
	tid->baw_tail = tid->baw_head;
  909b33:	8233      	l32i.n	a2, a3, 12
  909b35:	9234      	s32i.n	a2, a3, 16
  909b37:	d10f      	retw.n
  909b39:	000000        	ill

00909b3c <ath_tgt_tx_prepare>:
	return  bf;
}

struct ath_tx_buf* ath_tgt_tx_prepare(struct ath_softc_tgt *sc,
				   adf_nbuf_t skb, ath_data_hdr_t *dh)
{
  909b3c:	6c1006        	entry	a1, 48
  909b3f:	d520      	mov.n	a5, a2
	struct ath_tx_buf *bf;
	struct ieee80211_node_target *ni;
	struct ath_atx_tid *tid;

	ni = ath_tgt_find_node(sc, dh->ni_index);
  909b41:	224001        	l8ui	a2, a4, 1
							a_int32_t node_index)
{
	struct ath_node_target *an;
	struct ieee80211_node_target *ni;

	if (node_index > TARGET_NODE_MAX)
  909b44:	c068      	movi.n	a6, 8
  909b46:	726a02        	bge	a6, a2, 909b4c <ath_tgt_tx_prepare+0x10>
  909b49:	60022b        	j	909d78 <ath_tgt_tx_prepare+0x23c>
	  	return NULL;

	an = &sc->sc_sta[node_index];
  909b4c:	0a2611        	slli	a6, a2, 6
  909b4f:	a266      	add.n	a6, a6, a2
  909b51:	026609        	addx2	a6, a6, a2
  909b54:	275a30        	movi	a7, 0x530
  909b57:	07660a        	addx4	a6, a6, a7
  909b5a:	a656      	add.n	a6, a5, a6
  909b5c:	b866      	addi.n	a6, a6, 8
	ni = &an->ni;

	if (an->an_valid) {
  909b5e:	226d02        	addmi	a2, a6, 0x200
  909b61:	222004        	l8ui	a2, a2, 4
  909b64:	002232        	sext	a2, a2, 7
  909b67:	642213        	beqz	a2, 909d7e <ath_tgt_tx_prepare+0x242>
		if (ni->ni_vap == NULL) {
  909b6a:	8268      	l32i.n	a2, a6, 32
  909b6c:	64220e        	beqz	a2, 909d7e <ath_tgt_tx_prepare+0x242>
	struct ath_tx_buf *bf;
	struct ieee80211_node_target *ni;
	struct ath_atx_tid *tid;

	ni = ath_tgt_find_node(sc, dh->ni_index);
	if (ni == NULL)
  909b6f:	646209        	beqz	a6, 909d7c <ath_tgt_tx_prepare+0x240>
		return NULL;

	tid = ATH_AN_2_TID(ATH_NODE_TARGET(ni), dh->tidno);
  909b72:	224003        	l8ui	a2, a4, 3
  909b75:	0c2711        	slli	a7, a2, 4
  909b78:	02720c        	sub	a2, a7, a2
  909b7b:	06220a        	addx4	a2, a2, a6
	if (tid->flag & TID_REINITIALIZE) {
  909b7e:	22205a        	l8ui	a2, a2, 90
  909b81:	7d270f        	bbci	a2, 29, 909b94 <ath_tgt_tx_prepare+0x58>
		adf_os_print("drop frame due to TID reinit\n");
  909b84:	127184        	l32r	a2, 8e6194 <memset+0xff8>
  909b87:	1a72c8        	l32r	a10, 8e66a8 <memset+0x150c>
  909b8a:	222212        	l32i	a2, a2, 72
  909b8d:	0b2000        	callx8	a2
  909b90:	6001e4        	j	909d78 <ath_tgt_tx_prepare+0x23c>
  909b93:	002252        	extui	a2, a0, 18, 3

static struct ath_tx_buf* ath_tx_buf_alloc(struct ath_softc_tgt *sc)
{
	struct ath_tx_buf *bf = NULL;

	bf = asf_tailq_first(&sc->sc_txbuf);
  909b96:	f0          	.byte 0xf0
	if (bf !=  NULL) {
  909b97:	cb22      	beqz.n	a2, 909bcd <ath_tgt_tx_prepare+0x91>
 * @param[in] size  buffer size
 */
static inline void
adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
{
    __adf_os_mem_set(buf, b, size);
  909b99:	2a2c3c        	addi	a10, a2, 60
  909b9c:	c4bc      	movi.n	a11, 76
  909b9e:	5bfdbe        	call8	909298 <__adf_os_mem_set$constprop$13>
		adf_os_mem_set(&bf->bf_state, 0, sizeof(struct ath_buf_state));
		asf_tailq_remove(&sc->sc_txbuf, bf, bf_list);
  909ba1:	8729      	l32i.n	a7, a2, 36
  909ba3:	882a      	l32i.n	a8, a2, 40
  909ba5:	c874      	beqz.n	a7, 909bad <ath_tgt_tx_prepare+0x71>
  909ba7:	987a      	s32i.n	a8, a7, 40
  909ba9:	600003        	j	909bb0 <ath_tgt_tx_prepare+0x74>
  909bac:	002856        	extui	a8, a0, 18, 7
  909baf:	f1          	.byte 0xf1
  909bb0:	882a      	l32i.n	a8, a2, 40
		__stats(sc, tx_nobufs);
		return NULL;
	}

	bf->bf_tidno = dh->tidno;
	bf->bf_txq = TID_TO_ACTXQ(bf->bf_tidno);
  909bb2:	c091      	movi.n	a9, 1
	struct ath_tx_buf *bf = NULL;

	bf = asf_tailq_first(&sc->sc_txbuf);
	if (bf !=  NULL) {
		adf_os_mem_set(&bf->bf_state, 0, sizeof(struct ath_buf_state));
		asf_tailq_remove(&sc->sc_txbuf, bf, bf_list);
  909bb4:	9780      	s32i.n	a7, a8, 0
	if (!bf) {
		__stats(sc, tx_nobufs);
		return NULL;
	}

	bf->bf_tidno = dh->tidno;
  909bb6:	284003        	l8ui	a8, a4, 3
	bf->bf_txq = TID_TO_ACTXQ(bf->bf_tidno);
  909bb9:	c070      	movi.n	a7, 0
  909bbb:	2a8cfd        	addi	a10, a8, -3
	if (!bf) {
		__stats(sc, tx_nobufs);
		return NULL;
	}

	bf->bf_tidno = dh->tidno;
  909bbe:	28244d        	s8i	a8, a2, 77
	bf->bf_txq = TID_TO_ACTXQ(bf->bf_tidno);
  909bc1:	0a9739        	movnez	a7, a9, a10
  909bc4:	c870      	beqz.n	a7, 909bc8 <ath_tgt_tx_prepare+0x8c>
  909bc6:	cc86      	bnez.n	a8, 909bd0 <ath_tgt_tx_prepare+0x94>
  909bc8:	c090      	movi.n	a9, 0
  909bca:	600017        	j	909be5 <ath_tgt_tx_prepare+0xa9>
  909bcd:	63fffc        	j	909bcd <ath_tgt_tx_prepare+0x91>
  909bd0:	b087      	addi.n	a7, a8, -1
  909bd2:	070747        	extui	a7, a7, 0, 8
  909bd5:	6e720c        	bltui	a7, 2, 909be5 <ath_tgt_tx_prepare+0xa9>
  909bd8:	288cfc        	addi	a8, a8, -4
  909bdb:	080847        	extui	a8, a8, 0, 8
  909bde:	c093      	movi.n	a9, 3
  909be0:	6f8201        	bgeui	a8, 2, 909be5 <ath_tgt_tx_prepare+0xa9>
  909be3:	c092      	movi.n	a9, 2
  909be5:	05990a        	addx4	a9, a9, a5
  909be8:	299d05        	addmi	a9, a9, 0x500
  909beb:	8793      	l32i.n	a7, a9, 12
 * @param[in] buf   buf
 */
static inline void
adf_nbuf_queue_add(adf_nbuf_queue_t *head, adf_nbuf_t buf)
{
    __adf_nbuf_queue_add(head, buf);
  909bed:	db30      	mov.n	a11, a3
  909bef:	272620        	s32i	a7, a2, 128
	bf->bf_keytype = dh->keytype;
  909bf2:	274008        	l8ui	a7, a4, 8
  909bf5:	272485        	s8i	a7, a2, 133
	bf->bf_keyix = dh->keyix;
  909bf8:	274009        	l8ui	a7, a4, 9
  909bfb:	272449        	s8i	a7, a2, 73
	bf->bf_protmode = dh->flags & (IEEE80211_PROT_RTSCTS | IEEE80211_PROT_CTSONLY);
  909bfe:	274007        	l8ui	a7, a4, 7
	bf->bf_node = ni;
  909c01:	9624      	s32i.n	a6, a2, 16

	bf->bf_tidno = dh->tidno;
	bf->bf_txq = TID_TO_ACTXQ(bf->bf_tidno);
	bf->bf_keytype = dh->keytype;
	bf->bf_keyix = dh->keyix;
	bf->bf_protmode = dh->flags & (IEEE80211_PROT_RTSCTS | IEEE80211_PROT_CTSONLY);
  909c03:	070741        	extui	a7, a7, 0, 2
	bf->bf_node = ni;

	adf_nbuf_queue_add(&bf->bf_skbhead, skb);
  909c06:	262c14        	addi	a6, a2, 20
  909c09:	da60      	mov.n	a10, a6

	bf->bf_tidno = dh->tidno;
	bf->bf_txq = TID_TO_ACTXQ(bf->bf_tidno);
	bf->bf_keytype = dh->keytype;
	bf->bf_keyix = dh->keyix;
	bf->bf_protmode = dh->flags & (IEEE80211_PROT_RTSCTS | IEEE80211_PROT_CTSONLY);
  909c0b:	272484        	s8i	a7, a2, 132
  909c0e:	5be61a        	call8	903478 <__adf_nbuf_queue_add>
 * @return first buffer in queue
 */
static inline adf_nbuf_t 
adf_nbuf_queue_first(adf_nbuf_queue_t *head)
{
    return (__adf_nbuf_queue_first(head));
  909c11:	da60      	mov.n	a10, a6
  909c13:	5be6af        	call8	9036d0 <__adf_nbuf_queue_first>
  909c16:	d3a0      	mov.n	a3, a10
 * @return length of the queue
 */
static inline a_uint32_t
adf_nbuf_queue_len(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_len(head);
  909c18:	da60      	mov.n	a10, a6
  909c1a:	5be6ab        	call8	9036c8 <__adf_nbuf_queue_len>
	bf->bf_node = ni;

	adf_nbuf_queue_add(&bf->bf_skbhead, skb);
	skb = adf_nbuf_queue_first(&(bf->bf_skbhead));

	if (adf_nbuf_queue_len(&(bf->bf_skbhead)) == 0) {
  909c1d:	ccab      	bnez.n	a10, 909c2c <ath_tgt_tx_prepare+0xf0>
		__stats(sc, tx_noskbs);
  909c1f:	225276        	l32i	a2, a5, 0x1d8
  909c22:	b122      	addi.n	a2, a2, 1
  909c24:	225676        	s32i	a2, a5, 0x1d8
		return NULL;
  909c27:	d2a0      	mov.n	a2, a10
  909c29:	d10f      	retw.n
  909c2b:	00cc32        	sext	a12, a12, 7
	}

	adf_os_assert(skb);
  909c2e:	63fffc        	j	909c2e <ath_tgt_tx_prepare+0xf2>
  909c31:	00da30        	excw
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  909c34:	b41b      	addi.n	a11, a1, 4

	bf->bf_skb = skb;
  909c36:	9328      	s32i.n	a3, a2, 32
  909c38:	dc10      	mov.n	a12, a1
  909c3a:	5be699        	call8	9036a0 <__adf_nbuf_peek_header>
				     ath_data_hdr_t *dh)

{
	struct ieee80211_frame *wh = ATH_SKB2_WH(bf->bf_skb);
	a_int32_t retval;
	a_uint32_t flags = adf_os_ntohl(dh->flags);
  909c3d:	294004        	l8ui	a9, a4, 4
  909c40:	284005        	l8ui	a8, a4, 5
  909c43:	274006        	l8ui	a7, a4, 6
  909c46:	089910        	slli	a9, a9, 24
  909c49:	008811        	slli	a8, a8, 16
  909c4c:	098802        	or	a8, a8, a9
  909c4f:	244007        	l8ui	a4, a4, 7
  909c52:	087711        	slli	a7, a7, 8

static void ath_tgt_tx_seqno_normal(struct ath_tx_buf *bf)
{
	struct ieee80211_node_target *ni = bf->bf_node;
	struct ath_node_target *an = ATH_NODE_TARGET(ni);
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);
  909c55:	8a28      	l32i.n	a10, a2, 32
				     ath_data_hdr_t *dh)

{
	struct ieee80211_frame *wh = ATH_SKB2_WH(bf->bf_skb);
	a_int32_t retval;
	a_uint32_t flags = adf_os_ntohl(dh->flags);
  909c57:	087702        	or	a7, a7, a8
{
	a_uint8_t *anbdata;
	a_uint32_t anblen;

	adf_nbuf_peek_header(skb, &anbdata, &anblen);
	return((struct ieee80211_frame *)anbdata);
  909c5a:	8311      	l32i.n	a3, a1, 4
				     ath_data_hdr_t *dh)

{
	struct ieee80211_frame *wh = ATH_SKB2_WH(bf->bf_skb);
	a_int32_t retval;
	a_uint32_t flags = adf_os_ntohl(dh->flags);
  909c5c:	074402        	or	a4, a4, a7
	return bf;
}

static void ath_tgt_tx_seqno_normal(struct ath_tx_buf *bf)
{
	struct ieee80211_node_target *ni = bf->bf_node;
  909c5f:	272204        	l32i	a7, a2, 16
	struct ath_node_target *an = ATH_NODE_TARGET(ni);
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);
  909c62:	5bfecf        	call8	9097a0 <ATH_SKB_2_WH>
	struct ath_atx_tid *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  909c65:	28204d        	l8ui	a8, a2, 77

	u_int8_t fragno = (wh->i_seq[0] & 0xf);

	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);
  909c68:	2b710c        	l16ui	a11, a7, 24
static void ath_tgt_tx_seqno_normal(struct ath_tx_buf *bf)
{
	struct ieee80211_node_target *ni = bf->bf_node;
	struct ath_node_target *an = ATH_NODE_TARGET(ni);
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);
	struct ath_atx_tid *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  909c6b:	0c8911        	slli	a9, a8, 4
  909c6e:	08980c        	sub	a8, a9, a8
  909c71:	07880a        	addx4	a8, a8, a7

	u_int8_t fragno = (wh->i_seq[0] & 0xf);

	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);
  909c74:	b1bb      	addi.n	a11, a11, 1
  909c76:	0b0b4b        	extui	a11, a11, 0, 12
static void ath_tgt_tx_seqno_normal(struct ath_tx_buf *bf)
{
	struct ieee80211_node_target *ni = bf->bf_node;
	struct ath_node_target *an = ATH_NODE_TARGET(ni);
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);
	struct ath_atx_tid *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  909c79:	288c24        	addi	a8, a8, 36

	u_int8_t fragno = (wh->i_seq[0] & 0xf);
  909c7c:	29a016        	l8ui	a9, a10, 22

	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);
  909c7f:	2b750c        	s16i	a11, a7, 24

	bf->bf_seqno = (tid->seq_next << IEEE80211_SEQ_SEQ_SHIFT);
  909c82:	278103        	l16ui	a7, a8, 6
	struct ieee80211_node_target *ni = bf->bf_node;
	struct ath_node_target *an = ATH_NODE_TARGET(ni);
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);
	struct ath_atx_tid *tid = ATH_AN_2_TID(an, bf->bf_tidno);

	u_int8_t fragno = (wh->i_seq[0] & 0xf);
  909c85:	090943        	extui	a9, a9, 0, 4

	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);

	bf->bf_seqno = (tid->seq_next << IEEE80211_SEQ_SEQ_SHIFT);
  909c88:	0c7711        	slli	a7, a7, 4
  909c8b:	07074f        	extui	a7, a7, 0, 16
  909c8e:	272523        	s16i	a7, a2, 70

#undef adf_os_cpu_to_le16

static a_uint16_t adf_os_cpu_to_le16(a_uint16_t x)
{
	return ((((x) & 0xff00) >> 8) |   (((x) & 0x00ff) << 8));
  909c91:	087b11        	slli	a11, a7, 8
  909c94:	078714        	srli	a7, a7, 8
  909c97:	07b702        	or	a7, a11, a7

	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);

	bf->bf_seqno = (tid->seq_next << IEEE80211_SEQ_SEQ_SHIFT);

	*(u_int16_t *)wh->i_seq = adf_os_cpu_to_le16(bf->bf_seqno);
  909c9a:	070b4f        	extui	a11, a7, 0, 16
  909c9d:	27a50b        	s16i	a7, a10, 22
	wh->i_seq[0] |= fragno;
  909ca0:	0b8714        	srli	a7, a11, 8
  909ca3:	079702        	or	a7, a9, a7
  909ca6:	27a416        	s8i	a7, a10, 22

	if (!(wh->i_fc[1] & IEEE80211_FC1_MORE_FRAG))
  909ca9:	27a001        	l8ui	a7, a10, 1
  909cac:	7d7f08        	bbsi	a7, 29, 909cb8 <ath_tgt_tx_prepare+0x17c>
		INCR(tid->seq_next, IEEE80211_SEQ_MAX);
  909caf:	278103        	l16ui	a7, a8, 6
  909cb2:	277c01        	addi	a7, a7, 1
  909cb5:	278503        	s16i	a7, a8, 6
  909cb8:	278103        	l16ui	a7, a8, 6
	a_uint32_t flags = adf_os_ntohl(dh->flags);

	ath_tgt_tx_seqno_normal(bf);

	bf->bf_txq_add  = ath_tgt_txq_add_ucast;
	bf->bf_hdrlen   = ieee80211_anyhdrsize(wh);
  909cbb:	033a02        	or	a10, a3, a3

	*(u_int16_t *)wh->i_seq = adf_os_cpu_to_le16(bf->bf_seqno);
	wh->i_seq[0] |= fragno;

	if (!(wh->i_fc[1] & IEEE80211_FC1_MORE_FRAG))
		INCR(tid->seq_next, IEEE80211_SEQ_MAX);
  909cbe:	07074b        	extui	a7, a7, 0, 12
  909cc1:	278503        	s16i	a7, a8, 6
	a_int32_t retval;
	a_uint32_t flags = adf_os_ntohl(dh->flags);

	ath_tgt_tx_seqno_normal(bf);

	bf->bf_txq_add  = ath_tgt_txq_add_ucast;
  909cc4:	1772c9        	l32r	a7, 8e67e8 <memset+0x164c>
  909cc7:	272610        	s32i	a7, a2, 64
	bf->bf_hdrlen   = ieee80211_anyhdrsize(wh);
  909cca:	5bfc82        	call8	908ed4 <ieee80211_anyhdrsize>
  909ccd:	d7a0      	mov.n	a7, a10
  909ccf:	2a2448        	s8i	a10, a2, 72
 * @return first buffer in queue
 */
static inline adf_nbuf_t 
adf_nbuf_queue_first(adf_nbuf_queue_t *head)
{
    return (__adf_nbuf_queue_first(head));
  909cd2:	066a02        	or	a10, a6, a6
  909cd5:	5be67e        	call8	9036d0 <__adf_nbuf_queue_first>
 * @return The total length of this buf.
 */
static inline adf_os_size_t
adf_nbuf_len(adf_nbuf_t buf)
{
    return (__adf_nbuf_len(buf));
  909cd8:	5be669        	call8	903680 <__adf_nbuf_len>
	a_int32_t pktlen;

	skb = adf_nbuf_queue_first(&bf->bf_skbhead);
	pktlen = adf_nbuf_len(skb);

	pktlen -= (hdrlen & 3);
  909cdb:	070741        	extui	a7, a7, 0, 2
  909cde:	07aa0c        	sub	a10, a10, a7
	pktlen += IEEE80211_CRC_LEN;
  909ce1:	b4a7      	addi.n	a7, a10, 4

	ath_tgt_tx_seqno_normal(bf);

	bf->bf_txq_add  = ath_tgt_txq_add_ucast;
	bf->bf_hdrlen   = ieee80211_anyhdrsize(wh);
	bf->bf_pktlen   = ath_get_pktlen(bf, bf->bf_hdrlen);
  909ce3:	272522        	s16i	a7, a2, 68
	bf->bf_ismcast  = IEEE80211_IS_MULTICAST(wh->i_addr1);
  909ce6:	263004        	l8ui	a6, a3, 4
  909ce9:	232087        	l8ui	a3, a2, 135
  909cec:	096611        	slli	a6, a6, 7
  909cef:	030346        	extui	a3, a3, 0, 7
  909cf2:	063302        	or	a3, a3, a6
}

static a_int32_t ath_key_setup(struct ieee80211_node_target *ni,
			       struct ath_tx_buf *bf)
{
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);
  909cf5:	8a28      	l32i.n	a10, a2, 32
	ath_tgt_tx_seqno_normal(bf);

	bf->bf_txq_add  = ath_tgt_txq_add_ucast;
	bf->bf_hdrlen   = ieee80211_anyhdrsize(wh);
	bf->bf_pktlen   = ath_get_pktlen(bf, bf->bf_hdrlen);
	bf->bf_ismcast  = IEEE80211_IS_MULTICAST(wh->i_addr1);
  909cf7:	232487        	s8i	a3, a2, 135

	if ((retval = ath_key_setup(bf->bf_node, bf)) < 0)
  909cfa:	262204        	l32i	a6, a2, 16
}

static a_int32_t ath_key_setup(struct ieee80211_node_target *ni,
			       struct ath_tx_buf *bf)
{
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);
  909cfd:	5bfea8        	call8	9097a0 <ATH_SKB_2_WH>

	if (!(wh->i_fc[1] & IEEE80211_FC1_WEP)) {
  909d00:	27a001        	l8ui	a7, a10, 1
  909d03:	c430      	movi.n	a3, 64
  909d05:	037301        	and	a3, a7, a3
  909d08:	030747        	extui	a7, a3, 0, 8
  909d0b:	cc79      	bnez.n	a7, 909d18 <ath_tgt_tx_prepare+0x1dc>
		bf->bf_keytype = HAL_KEY_TYPE_CLEAR;
  909d0d:	232485        	s8i	a3, a2, 133
		bf->bf_keyix = HAL_TXKEYIX_INVALID;
  909d10:	c73f      	movi.n	a3, -1
  909d12:	232449        	s8i	a3, a2, 73
  909d15:	60002d        	j	909d46 <ath_tgt_tx_prepare+0x20a>
		return 0;
	}

	switch (bf->bf_keytype) {
  909d18:	2c2085        	l8ui	a12, a2, 133
  909d1b:	68c209        	beqi	a12, 2, 909d28 <ath_tgt_tx_prepare+0x1ec>
  909d1e:	68c30e        	beqi	a12, 3, 909d30 <ath_tgt_tx_prepare+0x1f4>
  909d21:	69c113        	bnei	a12, 1, 909d38 <ath_tgt_tx_prepare+0x1fc>
  909d24:	600008        	j	909d30 <ath_tgt_tx_prepare+0x1f4>
  909d27:	002321        	excw
	case HAL_KEY_TYPE_WEP:
		bf->bf_pktlen += IEEE80211_WEP_ICVLEN;
		break;
	case HAL_KEY_TYPE_AES:
		bf->bf_pktlen += IEEE80211_WEP_MICLEN;
  909d2a:	22b833        	excw
  909d2d:	600004        	j	909d35 <ath_tgt_tx_prepare+0x1f9>
		break;
	case HAL_KEY_TYPE_TKIP:
		bf->bf_pktlen += IEEE80211_WEP_ICVLEN;
  909d30:	232122        	l16ui	a3, a2, 68
  909d33:	b433      	addi.n	a3, a3, 4
  909d35:	232522        	s16i	a3, a2, 68
		break;
	default:
		break;
	}

	if (bf->bf_keytype == HAL_KEY_TYPE_AES ||
  909d38:	23ccfe        	addi	a3, a12, -2
  909d3b:	030347        	extui	a3, a3, 0, 8
  909d3e:	6f3204        	bgeui	a3, 2, 909d46 <ath_tgt_tx_prepare+0x20a>
	    bf->bf_keytype == HAL_KEY_TYPE_TKIP)
		ieee80211_tgt_crypto_encap(wh, ni, bf->bf_keytype);
  909d41:	db60      	mov.n	a11, a6
  909d43:	580432        	call8	90ae0c <ieee80211_tgt_crypto_encap>
  909d46:	232087        	l8ui	a3, a2, 135
	bf->bf_ismcast  = IEEE80211_IS_MULTICAST(wh->i_addr1);

	if ((retval = ath_key_setup(bf->bf_node, bf)) < 0)
		return retval;

	if (flags & ATH_SHORT_PREAMBLE)
  909d49:	7f4707        	bbci	a4, 31, 909d54 <ath_tgt_tx_prepare+0x218>
		bf->bf_shpream = AH_TRUE;
  909d4c:	c440      	movi.n	a4, 64
  909d4e:	043302        	or	a3, a3, a4
  909d51:	600005        	j	909d5a <ath_tgt_tx_prepare+0x21e>
	else
		bf->bf_shpream = AH_FALSE;
  909d54:	24fabf        	movi	a4, -65
  909d57:	043301        	and	a3, a3, a4
  909d5a:	232487        	s8i	a3, a2, 135

	bf->bf_flags = HAL_TXDESC_CLRDMASK;
  909d5d:	c031      	movi.n	a3, 1
  909d5f:	232544        	s16i	a3, a2, 136
	bf->bf_atype = HAL_PKT_TYPE_NORMAL;
  909d62:	c030      	movi.n	a3, 0
	adf_os_assert(skb);

	bf->bf_skb = skb;

	ath_tgt_txbuf_setup(sc, bf, dh);
	ath_dma_map(sc, bf);
  909d64:	da50      	mov.n	a10, a5
  909d66:	db20      	mov.n	a11, a2
		bf->bf_shpream = AH_TRUE;
	else
		bf->bf_shpream = AH_FALSE;

	bf->bf_flags = HAL_TXDESC_CLRDMASK;
	bf->bf_atype = HAL_PKT_TYPE_NORMAL;
  909d68:	23244a        	s8i	a3, a2, 74
	adf_os_assert(skb);

	bf->bf_skb = skb;

	ath_tgt_txbuf_setup(sc, bf, dh);
	ath_dma_map(sc, bf);
  909d6b:	5bfdcb        	call8	909498 <ath_dma_map>
	ath_tx_tgt_setds(sc, bf);
  909d6e:	da50      	mov.n	a10, a5
  909d70:	db20      	mov.n	a11, a2
  909d72:	5bfd0b        	call8	9091a0 <ath_tx_tgt_setds>

	return bf;
  909d75:	d10f      	retw.n
  909d77:	00c020        	excw
	struct ieee80211_node_target *ni;
	struct ath_atx_tid *tid;

	ni = ath_tgt_find_node(sc, dh->ni_index);
	if (ni == NULL)
		return NULL;
  909d7a:	d10f      	retw.n
  909d7c:	d260      	mov.n	a2, a6
	ath_tgt_txbuf_setup(sc, bf, dh);
	ath_dma_map(sc, bf);
	ath_tx_tgt_setds(sc, bf);

	return bf;
}
  909d7e:	d10f      	retw.n

00909d80 <ath_tgt_tx_send_normal>:
	return pktlen;
}

void
ath_tgt_tx_send_normal(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  909d80:	6c1014        	entry	a1, 160
	struct ath_rc_series rcs[4];
	struct ath_rc_series mrcs[4];
	a_int32_t shortPreamble = 0;
	a_int32_t isProbe = 0;

	adf_os_mem_set(rcs, 0, sizeof(struct ath_rc_series)*4 );
  909d83:	251c40        	addi	a5, a1, 64
  909d86:	da50      	mov.n	a10, a5
  909d88:	c3b0      	movi.n	a11, 48
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	struct ath_rc_series rcs[4];
	struct ath_rc_series mrcs[4];
	a_int32_t shortPreamble = 0;
	a_int32_t isProbe = 0;
  909d8a:	c040      	movi.n	a4, 0
}

void
ath_tgt_tx_send_normal(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
  909d8c:	8634      	l32i.n	a6, a3, 16
	struct ath_rc_series rcs[4];
	struct ath_rc_series mrcs[4];
	a_int32_t shortPreamble = 0;
	a_int32_t isProbe = 0;
  909d8e:	24161c        	s32i	a4, a1, 112
  909d91:	5bfd41        	call8	909298 <__adf_os_mem_set$constprop$13>
  909d94:	2a1c10        	addi	a10, a1, 16
  909d97:	c3b0      	movi.n	a11, 48
  909d99:	5bfd3f        	call8	909298 <__adf_os_mem_set$constprop$13>

	adf_os_mem_set(rcs, 0, sizeof(struct ath_rc_series)*4 );
	adf_os_mem_set(mrcs, 0, sizeof(struct ath_rc_series)*4 );

	if (!bf->bf_ismcast) {
  909d9c:	283221        	l32i	a8, a3, 132
  909d9f:	2d0a80        	movi	a13, 128
  909da2:	08dd01        	and	a13, a13, a8
  909da5:	74d920        	bne	a13, a4, 909dc9 <ath_tgt_tx_send_normal+0x49>
				  a_int32_t stepDnInc,
				  a_uint32_t rcflag,
				  struct ath_rc_series series[],
				  a_int32_t *isProbe)
{
	ath_rate_findrate(sc, an, 1, frameLen, 10, 4, 1,
  909da8:	c0c1      	movi.n	a12, 1

	adf_os_mem_set(rcs, 0, sizeof(struct ath_rc_series)*4 );
	adf_os_mem_set(mrcs, 0, sizeof(struct ath_rc_series)*4 );

	if (!bf->bf_ismcast) {
		ath_tgt_rate_findrate(sc, an, shortPreamble,
  909daa:	241c70        	addi	a4, a1, 112
				  a_int32_t stepDnInc,
				  a_uint32_t rcflag,
				  struct ath_rc_series series[],
				  a_int32_t *isProbe)
{
	ath_rate_findrate(sc, an, 1, frameLen, 10, 4, 1,
  909dad:	da20      	mov.n	a10, a2
  909daf:	db60      	mov.n	a11, a6
  909db1:	9c10      	s32i.n	a12, a1, 0
  909db3:	9c11      	s32i.n	a12, a1, 4
  909db5:	9512      	s32i.n	a5, a1, 8
  909db7:	9413      	s32i.n	a4, a1, 12
  909db9:	c0ea      	movi.n	a14, 10
  909dbb:	c0f4      	movi.n	a15, 4
  909dbd:	5bfc16        	call8	908e18 <ath_rate_findrate>

	if (!bf->bf_ismcast) {
		ath_tgt_rate_findrate(sc, an, shortPreamble,
				      0, 0, 0, 0, 0,
				      rcs, &isProbe);
		ath_hal_memcpy(bf->bf_rcs, rcs, sizeof(rcs));
  909dc0:	2a3c50        	addi	a10, a3, 80
  909dc3:	db50      	mov.n	a11, a5
  909dc5:	600023        	j	909dec <ath_tgt_tx_send_normal+0x6c>
  909dc8:	00c051        	extui	a0, a0, 28, 2
	} else {
		mrcs[1].tries = mrcs[2].tries = mrcs[3].tries = 0;
  909dcb:	241435        	s8i	a4, a1, 53
  909dce:	241429        	s8i	a4, a1, 41
  909dd1:	24141d        	s8i	a4, a1, 29
		mrcs[1].rix = mrcs[2].rix = mrcs[3].rix = 0;
  909dd4:	241434        	s8i	a4, a1, 52
  909dd7:	241428        	s8i	a4, a1, 40
  909dda:	24141c        	s8i	a4, a1, 28
		mrcs[0].rix   = 0;
  909ddd:	241410        	s8i	a4, a1, 16
		mrcs[0].tries = 1;
  909de0:	251411        	s8i	a5, a1, 17
		mrcs[0].flags = 0;
  909de3:	241413        	s8i	a4, a1, 19
		ath_hal_memcpy(bf->bf_rcs, mrcs, sizeof(mrcs));
  909de6:	2a3c50        	addi	a10, a3, 80
  909de9:	2b1c10        	addi	a11, a1, 16
  909dec:	c3c0      	movi.n	a12, 48
  909dee:	5be788        	call8	903c10 <ath_hal_memcpy>
	}

	ath_buf_set_rate(sc, bf);
  909df1:	da20      	mov.n	a10, a2
  909df3:	db30      	mov.n	a11, a3
  909df5:	5bfd2d        	call8	9092ac <ath_buf_set_rate>
	bf->bf_txq_add(sc, bf);
  909df8:	243210        	l32i	a4, a3, 64
  909dfb:	da20      	mov.n	a10, a2
  909dfd:	db30      	mov.n	a11, a3
  909dff:	0b4000        	callx8	a4
  909e02:	d10f      	retw.n

00909e04 <ath_tgt_send_mgt>:
}

void
ath_tgt_send_mgt(struct ath_softc_tgt *sc,adf_nbuf_t hdr_buf, adf_nbuf_t skb,
		 HTC_ENDPOINT_ID endpt)
{
  909e04:	6c1020        	entry	a1, 0x100
	struct ieee80211_node_target *ni;
	struct ieee80211vap_target *vap;
	struct ath_vap_target *avp;
	struct ath_hal *ah = sc->sc_ah;
  909e07:	262d05        	addmi	a6, a2, 0x500
  909e0a:	866b      	l32i.n	a6, a6, 44
  909e0c:	2b0a84        	movi	a11, 132
  909e0f:	26162d        	s32i	a6, a1, 180
  909e12:	2c0a80        	movi	a12, 128
	struct ath_rc_series rcs[4];
	HAL_11N_RATE_SERIES series[4];
	ath_mgt_hdr_t *mh;
	a_int8_t keyix;

	if (!hdr_buf) {
  909e15:	cd37      	bnez.n	a3, 909e30 <ath_tgt_send_mgt+0x2c>
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  909e17:	231c20        	addi	a3, a1, 32
  909e1a:	da40      	mov.n	a10, a4
  909e1c:	ab3b      	add.n	a11, a3, a11
  909e1e:	0c3c08        	add	a12, a3, a12
  909e21:	5be61f        	call8	9036a0 <__adf_nbuf_peek_header>
 *         or NULL if there is not sufficient data to pull.
 */
static inline a_uint8_t *
adf_nbuf_pull_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_pull_head(buf, size);
  909e24:	da40      	mov.n	a10, a4
  909e26:	2b0a08        	movi	a11, 8
  909e29:	5be575        	call8	903400 <__adf_nbuf_pull_head>
  909e2c:	60000c        	j	909e3c <ath_tgt_send_mgt+0x38>
  909e2f:	00261c        	mul16u	a6, a2, a0
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  909e32:	20da30        	movi	a0, 0xfffffd30
  909e35:	ab6b      	add.n	a11, a6, a11
  909e37:	ac6c      	add.n	a12, a6, a12
  909e39:	5be619        	call8	9036a0 <__adf_nbuf_peek_header>
		adf_nbuf_pull_head(skb, sizeof(ath_mgt_hdr_t));
	} else {
		adf_nbuf_peek_header(hdr_buf, &data, &len);
	}

	adf_os_assert(len >= sizeof(ath_mgt_hdr_t));
  909e3c:	231228        	l32i	a3, a1, 160
  909e3f:	6f3802        	bgeui	a3, 8, 909e45 <ath_tgt_send_mgt+0x41>
  909e42:	63fffc        	j	909e42 <ath_tgt_send_mgt+0x3e>
  909e45:	281c20        	addi	a8, a1, 32
  909e48:	2b0a84        	movi	a11, 132
  909e4b:	2c0a80        	movi	a12, 128
  909e4e:	ab8b      	add.n	a11, a8, a11
  909e50:	0c8c08        	add	a12, a8, a12
  909e53:	044a02        	or	a10, a4, a4

	mh = (ath_mgt_hdr_t *)data;
  909e56:	231229        	l32i	a3, a1, 164
  909e59:	5be611        	call8	9036a0 <__adf_nbuf_peek_header>
  909e5c:	2a1c70        	addi	a10, a1, 112
  909e5f:	2b0a30        	movi	a11, 48
	adf_nbuf_peek_header(skb, &data, &len);
	wh = (struct ieee80211_frame *)data;
  909e62:	261229        	l32i	a6, a1, 164
  909e65:	5bfd0c        	call8	909298 <__adf_os_mem_set$constprop$13>
  909e68:	2a1c20        	addi	a10, a1, 32
  909e6b:	c5b0      	movi.n	a11, 80
  909e6d:	5bfd0a        	call8	909298 <__adf_os_mem_set$constprop$13>

	adf_os_mem_set(rcs, 0, sizeof(struct ath_rc_series)*4);
	adf_os_mem_set(series, 0, sizeof(HAL_11N_RATE_SERIES)*4);

	bf = asf_tailq_first(&sc->sc_txbuf);
  909e70:	2722f0        	l32i	a7, a2, 0x3c0
	if (!bf)
  909e73:	64732a        	beqz	a7, 90a1a1 <ath_tgt_send_mgt+0x39d>
		goto fail;

	asf_tailq_remove(&sc->sc_txbuf, bf, bf_list);
  909e76:	8979      	l32i.n	a9, a7, 36
  909e78:	8a7a      	l32i.n	a10, a7, 40
  909e7a:	c893      	beqz.n	a9, 909e81 <ath_tgt_send_mgt+0x7d>
  909e7c:	9a9a      	s32i.n	a10, a9, 40
  909e7e:	600002        	j	909e84 <ath_tgt_send_mgt+0x80>
  909e81:	2a26f1        	s32i	a10, a2, 0x3c4
  909e84:	8a7a      	l32i.n	a10, a7, 40
  909e86:	99a0      	s32i.n	a9, a10, 0

	ni = ath_tgt_find_node(sc, mh->ni_index);
  909e88:	293000        	l8ui	a9, a3, 0
							a_int32_t node_index)
{
	struct ath_node_target *an;
	struct ieee80211_node_target *ni;

	if (node_index > TARGET_NODE_MAX)
  909e8b:	c0a8      	movi.n	a10, 8
  909e8d:	79aa02        	bge	a10, a9, 909e93 <ath_tgt_send_mgt+0x8f>
  909e90:	60030d        	j	90a1a1 <ath_tgt_send_mgt+0x39d>
	  	return NULL;

	an = &sc->sc_sta[node_index];
  909e93:	0a9e11        	slli	a14, a9, 6
  909e96:	a9ee      	add.n	a14, a14, a9
  909e98:	09ee09        	addx2	a14, a14, a9
  909e9b:	2a5a30        	movi	a10, 0x530
  909e9e:	0aee0a        	addx4	a14, a14, a10
  909ea1:	ae2e      	add.n	a14, a2, a14
  909ea3:	b8ee      	addi.n	a14, a14, 8
	ni = &an->ni;

	if (an->an_valid) {
  909ea5:	29ed02        	addmi	a9, a14, 0x200
  909ea8:	299004        	l8ui	a9, a9, 4
  909eab:	6492f2        	beqz	a9, 90a1a1 <ath_tgt_send_mgt+0x39d>
		if (ni->ni_vap == NULL) {
  909eae:	89e8      	l32i.n	a9, a14, 32
  909eb0:	6492ed        	beqz	a9, 90a1a1 <ath_tgt_send_mgt+0x39d>

	ni = ath_tgt_find_node(sc, mh->ni_index);
	if (!ni)
		goto fail;

	bf->bf_endpt = endpt;
  909eb3:	257623        	s32i	a5, a7, 140
	bf->bf_cookie = mh->cookie;
  909eb6:	253006        	l8ui	a5, a3, 6
	bf->bf_protmode = mh->flags & (IEEE80211_PROT_RTSCTS | IEEE80211_PROT_CTSONLY);
	txq = &sc->sc_txq[1];
	iswep = wh->i_fc[1] & IEEE80211_FC1_WEP;
	ismcast = IEEE80211_IS_MULTICAST(wh->i_addr1);
	hdrlen = ieee80211_anyhdrsize(wh);
  909eb9:	da60      	mov.n	a10, a6
	ni = ath_tgt_find_node(sc, mh->ni_index);
	if (!ni)
		goto fail;

	bf->bf_endpt = endpt;
	bf->bf_cookie = mh->cookie;
  909ebb:	257492        	s8i	a5, a7, 146
	bf->bf_protmode = mh->flags & (IEEE80211_PROT_RTSCTS | IEEE80211_PROT_CTSONLY);
  909ebe:	253003        	l8ui	a5, a3, 3
  909ec1:	050541        	extui	a5, a5, 0, 2
  909ec4:	257484        	s8i	a5, a7, 132
	txq = &sc->sc_txq[1];
	iswep = wh->i_fc[1] & IEEE80211_FC1_WEP;
  909ec7:	296001        	l8ui	a9, a6, 1
  909eca:	250a40        	movi	a5, 64
  909ecd:	059901        	and	a9, a9, a5
  909ed0:	291632        	s32i	a9, a1, 200
	ismcast = IEEE80211_IS_MULTICAST(wh->i_addr1);
  909ed3:	256004        	l8ui	a5, a6, 4
	hdrlen = ieee80211_anyhdrsize(wh);
  909ed6:	2e1636        	s32i	a14, a1, 216
  909ed9:	5bfbfe        	call8	908ed4 <ieee80211_anyhdrsize>
	pktlen = len;
	keyix = HAL_TXKEYIX_INVALID;
	pktlen -= (hdrlen & 3);
  909edc:	0a0941        	extui	a9, a10, 0, 2
	bf->bf_cookie = mh->cookie;
	bf->bf_protmode = mh->flags & (IEEE80211_PROT_RTSCTS | IEEE80211_PROT_CTSONLY);
	txq = &sc->sc_txq[1];
	iswep = wh->i_fc[1] & IEEE80211_FC1_WEP;
	ismcast = IEEE80211_IS_MULTICAST(wh->i_addr1);
	hdrlen = ieee80211_anyhdrsize(wh);
  909edf:	2a1633        	s32i	a10, a1, 204
	pktlen = len;
	keyix = HAL_TXKEYIX_INVALID;
	pktlen -= (hdrlen & 3);
  909ee2:	2a1228        	l32i	a10, a1, 160
	txq = &sc->sc_txq[1];
	iswep = wh->i_fc[1] & IEEE80211_FC1_WEP;
	ismcast = IEEE80211_IS_MULTICAST(wh->i_addr1);
	hdrlen = ieee80211_anyhdrsize(wh);
	pktlen = len;
	keyix = HAL_TXKEYIX_INVALID;
  909ee5:	280aff        	movi	a8, 255
	pktlen -= (hdrlen & 3);
  909ee8:	09a90c        	sub	a9, a10, a9
	pktlen += IEEE80211_CRC_LEN;
  909eeb:	b499      	addi.n	a9, a9, 4
	txq = &sc->sc_txq[1];
	iswep = wh->i_fc[1] & IEEE80211_FC1_WEP;
	ismcast = IEEE80211_IS_MULTICAST(wh->i_addr1);
	hdrlen = ieee80211_anyhdrsize(wh);
	pktlen = len;
	keyix = HAL_TXKEYIX_INVALID;
  909eed:	281631        	s32i	a8, a1, 196
	pktlen -= (hdrlen & 3);
	pktlen += IEEE80211_CRC_LEN;

	if (iswep)
  909ef0:	281232        	l32i	a8, a1, 200
	ismcast = IEEE80211_IS_MULTICAST(wh->i_addr1);
	hdrlen = ieee80211_anyhdrsize(wh);
	pktlen = len;
	keyix = HAL_TXKEYIX_INVALID;
	pktlen -= (hdrlen & 3);
	pktlen += IEEE80211_CRC_LEN;
  909ef3:	29162f        	s32i	a9, a1, 188
	bf->bf_endpt = endpt;
	bf->bf_cookie = mh->cookie;
	bf->bf_protmode = mh->flags & (IEEE80211_PROT_RTSCTS | IEEE80211_PROT_CTSONLY);
	txq = &sc->sc_txq[1];
	iswep = wh->i_fc[1] & IEEE80211_FC1_WEP;
	ismcast = IEEE80211_IS_MULTICAST(wh->i_addr1);
  909ef6:	050540        	extui	a5, a5, 0, 1
	pktlen = len;
	keyix = HAL_TXKEYIX_INVALID;
	pktlen -= (hdrlen & 3);
	pktlen += IEEE80211_CRC_LEN;

	if (iswep)
  909ef9:	2e1236        	l32i	a14, a1, 216
  909efc:	648005        	beqz	a8, 909f05 <ath_tgt_send_mgt+0x101>
		keyix = mh->keyix;
  909eff:	283005        	l8ui	a8, a3, 5
  909f02:	281631        	s32i	a8, a1, 196
adf_nbuf_map(adf_os_device_t        osdev, 
             adf_os_dma_map_t       bmap, 
             adf_nbuf_t             buf, 
             adf_os_dma_dir_t       dir)
{
    return __adf_nbuf_map(osdev, bmap, buf, dir);
  909f05:	8b70      	l32i.n	a11, a7, 0
  909f07:	2a2246        	l32i	a10, a2, 0x118
  909f0a:	dc40      	mov.n	a12, a4
  909f0c:	c0d0      	movi.n	a13, 0
  909f0e:	2e1636        	s32i	a14, a1, 216
  909f11:	5be572        	call8	9034dc <__adf_nbuf_map>
 * @param[in] buf   buf
 */
static inline void
adf_nbuf_queue_add(adf_nbuf_queue_t *head, adf_nbuf_t buf)
{
    __adf_nbuf_queue_add(head, buf);
  909f14:	db40      	mov.n	a11, a4

	adf_nbuf_map(sc->sc_dev, bf->bf_dmamap, skb, ADF_OS_DMA_TO_DEVICE);

	bf->bf_skb = skb;
  909f16:	9478      	s32i.n	a4, a7, 32
  909f18:	2a7c14        	addi	a10, a7, 20
  909f1b:	5be557        	call8	903478 <__adf_nbuf_queue_add>
	adf_nbuf_queue_add(&bf->bf_skbhead, skb);

	ds = bf->bf_desc;
  909f1e:	847c      	l32i.n	a4, a7, 48
	rt = sc->sc_currates;
  909f20:	292281        	l32i	a9, a2, 0x204
	adf_nbuf_map(sc->sc_dev, bf->bf_dmamap, skb, ADF_OS_DMA_TO_DEVICE);

	bf->bf_skb = skb;
	adf_nbuf_queue_add(&bf->bf_skbhead, skb);

	ds = bf->bf_desc;
  909f23:	241630        	s32i	a4, a1, 192
	rt = sc->sc_currates;
	adf_os_assert(rt != NULL);
  909f26:	2e1236        	l32i	a14, a1, 216
  909f29:	cc93      	bnez.n	a9, 909f30 <ath_tgt_send_mgt+0x12c>
  909f2b:	63fffc        	j	909f2b <ath_tgt_send_mgt+0x127>
  909f2e:	000024        	excw

	if (mh->flags == ATH_SHORT_PREAMBLE)
  909f31:	3003c0        	excw
  909f34:	c0b0      	movi.n	a11, 0
  909f36:	44c0a1        	excw
  909f39:	d8c0      	mov.n	a8, a12
	else
		shortPreamble = AH_FALSE;

	flags = HAL_TXDESC_CLRDMASK;

	switch (wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) {
  909f3b:	2b6000        	l8ui	a11, a6, 0

	ds = bf->bf_desc;
	rt = sc->sc_currates;
	adf_os_assert(rt != NULL);

	if (mh->flags == ATH_SHORT_PREAMBLE)
  909f3e:	04a838        	moveqz	a8, a10, a4
	else
		shortPreamble = AH_FALSE;

	flags = HAL_TXDESC_CLRDMASK;

	switch (wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) {
  909f41:	c04c      	movi.n	a4, 12
  909f43:	04b401        	and	a4, a11, a4
  909f46:	7c491f        	bne	a4, a12, 909f69 <ath_tgt_send_mgt+0x165>
	case IEEE80211_FC0_TYPE_MGT:
		subtype = wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK;
  909f49:	c7c0      	movi.n	a12, -16
  909f4b:	0cbb01        	and	a11, a11, a12

		if (subtype == IEEE80211_FC0_SUBTYPE_PROBE_RESP)
			atype = HAL_PKT_TYPE_PROBE_RESP;
  909f4e:	c0c4      	movi.n	a12, 4
  909f50:	2c162e        	s32i	a12, a1, 184

	switch (wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) {
	case IEEE80211_FC0_TYPE_MGT:
		subtype = wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK;

		if (subtype == IEEE80211_FC0_SUBTYPE_PROBE_RESP)
  909f53:	c5c0      	movi.n	a12, 80
  909f55:	7cb113        	beq	a11, a12, 909f6c <ath_tgt_send_mgt+0x168>
			atype = HAL_PKT_TYPE_PROBE_RESP;
		else if (subtype == IEEE80211_FC0_SUBTYPE_ATIM)
  909f58:	2cfa70        	movi	a12, -144
  909f5b:	acbb      	add.n	a11, a11, a12
  909f5d:	0ba438        	moveqz	a4, a10, a11
  909f60:	24162e        	s32i	a4, a1, 184
  909f63:	600005        	j	909f6c <ath_tgt_send_mgt+0x168>
  909f66:	000000        	ill
		else
			atype = HAL_PKT_TYPE_NORMAL;

		break;
	default:
		atype = HAL_PKT_TYPE_NORMAL;
  909f69:	2c162e        	s32i	a12, a1, 184
		break;
	}

	avp = &sc->sc_vap[mh->vap_index];
  909f6c:	243001        	l8ui	a4, a3, 1
  909f6f:	1a72a4        	l32r	a10, 8e6a00 <memset+0x1864>
  909f72:	0c4b11        	slli	a11, a4, 4
  909f75:	a4bb      	add.n	a11, a11, a4
  909f77:	0abb0a        	addx4	a11, a11, a10
  909f7a:	ab2b      	add.n	a11, a2, a11

	rcs[0].rix = ath_get_minrateidx(sc, avp);
  909f7c:	b8bb      	addi.n	a11, a11, 8
  909f7e:	022a02        	or	a10, a2, a2
  909f81:	281635        	s32i	a8, a1, 212
  909f84:	291634        	s32i	a9, a1, 208
  909f87:	2e1636        	s32i	a14, a1, 216
	rcs[0].tries = ATH_TXMAXTRY;
  909f8a:	240a0b        	movi	a4, 11
		break;
	}

	avp = &sc->sc_vap[mh->vap_index];

	rcs[0].rix = ath_get_minrateidx(sc, avp);
  909f8d:	5bf754        	call8	907ce0 <ath_get_minrateidx>
  909f90:	2a1470        	s8i	a10, a1, 112
	rcs[0].tries = ATH_TXMAXTRY;
  909f93:	241471        	s8i	a4, a1, 113
 * @param[in] size    buffer size
 */
static inline void
adf_os_mem_copy(void *dst, const void *src, adf_os_size_t size)
{
    __adf_os_mem_copy(dst, src, size);
  909f96:	2a7c50        	addi	a10, a7, 80
	rcs[0].flags = 0;
  909f99:	240a00        	movi	a4, 0
  909f9c:	2c0a30        	movi	a12, 48
  909f9f:	2b1c70        	addi	a11, a1, 112
  909fa2:	241473        	s8i	a4, a1, 115
  909fa5:	5bfbc6        	call8	908ec0 <__adf_os_mem_copy>

	adf_os_mem_copy(bf->bf_rcs, rcs, sizeof(rcs));
	rix = rcs[0].rix;
	try0 = rcs[0].tries;
	txrate = rt->info[rix].rateCode;
  909fa8:	2d1070        	l8ui	a13, a1, 112
  909fab:	291234        	l32i	a9, a1, 208
  909fae:	b2d4      	addi.n	a4, a13, 2
  909fb0:	0c4411        	slli	a4, a4, 4
  909fb3:	a494      	add.n	a4, a9, a4
  909fb5:	2a4010        	l8ui	a10, a4, 16

	if (shortPreamble){
  909fb8:	281235        	l32i	a8, a1, 212
	rcs[0].flags = 0;

	adf_os_mem_copy(bf->bf_rcs, rcs, sizeof(rcs));
	rix = rcs[0].rix;
	try0 = rcs[0].tries;
	txrate = rt->info[rix].rateCode;
  909fbb:	2a162c        	s32i	a10, a1, 176
	rcs[0].tries = ATH_TXMAXTRY;
	rcs[0].flags = 0;

	adf_os_mem_copy(bf->bf_rcs, rcs, sizeof(rcs));
	rix = rcs[0].rix;
	try0 = rcs[0].tries;
  909fbe:	2c1071        	l8ui	a12, a1, 113
	txrate = rt->info[rix].rateCode;

	if (shortPreamble){
  909fc1:	2e1236        	l32i	a14, a1, 216
  909fc4:	648008        	beqz	a8, 909fd0 <ath_tgt_send_mgt+0x1cc>
		txrate |= rt->info[rix].shortPreamble;
  909fc7:	244011        	l8ui	a4, a4, 17
  909fca:	04aa02        	or	a10, a10, a4
  909fcd:	2a162c        	s32i	a10, a1, 176
	}

	vap = ni->ni_vap;
  909fd0:	84e8      	l32i.n	a4, a14, 32
	bf->bf_node = ni;
  909fd2:	9e74      	s32i.n	a14, a7, 16

	if (ismcast) {
  909fd4:	cd56      	bnez.n	a5, 909fee <ath_tgt_send_mgt+0x1ea>
		flags |= HAL_TXDESC_NOACK;
		try0 = 1;
	} else if (pktlen > vap->iv_rtsthreshold) {
  909fd6:	244105        	l16ui	a4, a4, 10
  909fd9:	25122f        	l32i	a5, a1, 188
  909fdc:	754a16        	bge	a4, a5, 909ff6 <ath_tgt_send_mgt+0x1f2>
		flags |= HAL_TXDESC_RTSENA;
		cix = rt->info[rix].controlRate;
  909fdf:	b2d4      	addi.n	a4, a13, 2
  909fe1:	0c4411        	slli	a4, a4, 4
  909fe4:	a494      	add.n	a4, a9, a4
  909fe6:	2b4013        	l8ui	a11, a4, 19

	if (ismcast) {
		flags |= HAL_TXDESC_NOACK;
		try0 = 1;
	} else if (pktlen > vap->iv_rtsthreshold) {
		flags |= HAL_TXDESC_RTSENA;
  909fe9:	c055      	movi.n	a5, 5
  909feb:	60000c        	j	909ffb <ath_tgt_send_mgt+0x1f7>
	vap = ni->ni_vap;
	bf->bf_node = ni;

	if (ismcast) {
		flags |= HAL_TXDESC_NOACK;
		try0 = 1;
  909fee:	c0c1      	movi.n	a12, 1

	vap = ni->ni_vap;
	bf->bf_node = ni;

	if (ismcast) {
		flags |= HAL_TXDESC_NOACK;
  909ff0:	c053      	movi.n	a5, 3
  909ff2:	600002        	j	909ff8 <ath_tgt_send_mgt+0x1f4>
  909ff5:	00c051        	extui	a0, a0, 28, 2
{
	struct ieee80211_node_target *ni;
	struct ieee80211vap_target *vap;
	struct ath_vap_target *avp;
	struct ath_hal *ah = sc->sc_ah;
	a_uint8_t rix, txrate, ctsrate, cix = 0xff, *data;
  909ff8:	2b0aff        	movi	a11, 255
	} else if (pktlen > vap->iv_rtsthreshold) {
		flags |= HAL_TXDESC_RTSENA;
		cix = rt->info[rix].controlRate;
	}

	if ((bf->bf_protmode != IEEE80211_PROT_NONE) &&
  909ffb:	247084        	l8ui	a4, a7, 132
  909ffe:	ca46      	beqz.n	a4, 90a028 <ath_tgt_send_mgt+0x224>
	    rt->info[rix].phy == IEEE80211_T_OFDM &&
  90a000:	b2d4      	addi.n	a4, a13, 2
  90a002:	0c4411        	slli	a4, a4, 4
  90a005:	a494      	add.n	a4, a9, a4
	} else if (pktlen > vap->iv_rtsthreshold) {
		flags |= HAL_TXDESC_RTSENA;
		cix = rt->info[rix].controlRate;
	}

	if ((bf->bf_protmode != IEEE80211_PROT_NONE) &&
  90a007:	244009        	l8ui	a4, a4, 9
  90a00a:	69421a        	bnei	a4, 2, 90a028 <ath_tgt_send_mgt+0x224>
	    rt->info[rix].phy == IEEE80211_T_OFDM &&
  90a00d:	745817        	bany	a5, a4, 90a028 <ath_tgt_send_mgt+0x224>
	    (flags & HAL_TXDESC_NOACK) == 0) {
		cix = rt->info[sc->sc_protrix].controlRate;
  90a010:	242d03        	addmi	a4, a2, 0x300
  90a013:	24400c        	l8ui	a4, a4, 12
  90a016:	b244      	addi.n	a4, a4, 2
  90a018:	0c4411        	slli	a4, a4, 4
  90a01b:	a494      	add.n	a4, a9, a4
  90a01d:	2b4013        	l8ui	a11, a4, 19
		sc->sc_tx_stats.ast_tx_protect++;
  90a020:	24225a        	l32i	a4, a2, 0x168
  90a023:	b144      	addi.n	a4, a4, 1
  90a025:	24265a        	s32i	a4, a2, 0x168
	}

	*(a_uint16_t *)&wh->i_seq[0] =  adf_os_cpu_to_le16(ni->ni_txseqmgmt <<
  90a028:	24e10c        	l16ui	a4, a14, 24
							   IEEE80211_SEQ_SEQ_SHIFT);
	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);

	ctsduration = 0;
	if (flags & (HAL_TXDESC_RTSENA|HAL_TXDESC_CTSENA)) {
  90a02b:	c0fc      	movi.n	a15, 12
	    (flags & HAL_TXDESC_NOACK) == 0) {
		cix = rt->info[sc->sc_protrix].controlRate;
		sc->sc_tx_stats.ast_tx_protect++;
	}

	*(a_uint16_t *)&wh->i_seq[0] =  adf_os_cpu_to_le16(ni->ni_txseqmgmt <<
  90a02d:	0c4411        	slli	a4, a4, 4
  90a030:	04044f        	extui	a4, a4, 0, 16

#undef adf_os_cpu_to_le16

static a_uint16_t adf_os_cpu_to_le16(a_uint16_t x)
{
	return ((((x) & 0xff00) >> 8) |   (((x) & 0x00ff) << 8));
  90a033:	084a11        	slli	a10, a4, 8
  90a036:	048414        	srli	a4, a4, 8
  90a039:	04a402        	or	a4, a10, a4
	    (flags & HAL_TXDESC_NOACK) == 0) {
		cix = rt->info[sc->sc_protrix].controlRate;
		sc->sc_tx_stats.ast_tx_protect++;
	}

	*(a_uint16_t *)&wh->i_seq[0] =  adf_os_cpu_to_le16(ni->ni_txseqmgmt <<
  90a03c:	24650b        	s16i	a4, a6, 22
							   IEEE80211_SEQ_SEQ_SHIFT);
	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);
  90a03f:	24e10c        	l16ui	a4, a14, 24

	ctsduration = 0;
	if (flags & (HAL_TXDESC_RTSENA|HAL_TXDESC_CTSENA)) {
  90a042:	0f5f01        	and	a15, a5, a15
		sc->sc_tx_stats.ast_tx_protect++;
	}

	*(a_uint16_t *)&wh->i_seq[0] =  adf_os_cpu_to_le16(ni->ni_txseqmgmt <<
							   IEEE80211_SEQ_SEQ_SHIFT);
	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);
  90a045:	b144      	addi.n	a4, a4, 1
  90a047:	04044b        	extui	a4, a4, 0, 12
  90a04a:	24e50c        	s16i	a4, a14, 24

	ctsduration = 0;
	if (flags & (HAL_TXDESC_RTSENA|HAL_TXDESC_CTSENA)) {
  90a04d:	64f065        	beqz	a15, 90a0b6 <ath_tgt_send_mgt+0x2b2>
		adf_os_assert(cix != 0xff);
  90a050:	240aff        	movi	a4, 255
  90a053:	74b902        	bne	a11, a4, 90a059 <ath_tgt_send_mgt+0x255>
  90a056:	63fffc        	j	90a056 <ath_tgt_send_mgt+0x252>
		ctsrate = rt->info[cix].rateCode;
  90a059:	b2ba      	addi.n	a10, a11, 2
  90a05b:	0caa11        	slli	a10, a10, 4
  90a05e:	aa9a      	add.n	a10, a9, a10
  90a060:	24a010        	l8ui	a4, a10, 16
  90a063:	c0c4      	movi.n	a12, 4
		if (shortPreamble) {
  90a065:	c98c      	beqz.n	a8, 90a085 <ath_tgt_send_mgt+0x281>
			ctsrate |= rt->info[cix].shortPreamble;
  90a067:	2ea011        	l8ui	a14, a10, 17

	*(a_uint16_t *)&wh->i_seq[0] =  adf_os_cpu_to_le16(ni->ni_txseqmgmt <<
							   IEEE80211_SEQ_SEQ_SHIFT);
	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);

	ctsduration = 0;
  90a06a:	c0f0      	movi.n	a15, 0
	if (flags & (HAL_TXDESC_RTSENA|HAL_TXDESC_CTSENA)) {
		adf_os_assert(cix != 0xff);
		ctsrate = rt->info[cix].rateCode;
		if (shortPreamble) {
			ctsrate |= rt->info[cix].shortPreamble;
  90a06c:	0e4402        	or	a4, a4, a14
			if (flags & HAL_TXDESC_RTSENA)      /* SIFS + CTS */
  90a06f:	7c5002        	bnone	a5, a12, 90a075 <ath_tgt_send_mgt+0x271>
				ctsduration += rt->info[cix].spAckDuration;
  90a072:	2fa10b        	l16ui	a15, a10, 22
			if ((flags & HAL_TXDESC_NOACK) == 0)    /* SIFS + ACK */
  90a075:	7e5f23        	bbsi	a5, 30, 90a09c <ath_tgt_send_mgt+0x298>
				ctsduration += rt->info[cix].spAckDuration;
  90a078:	b2bb      	addi.n	a11, a11, 2
  90a07a:	0cbb11        	slli	a11, a11, 4
  90a07d:	ab9b      	add.n	a11, a9, a11
  90a07f:	2ab10b        	l16ui	a10, a11, 22
  90a082:	600014        	j	90a09a <ath_tgt_send_mgt+0x296>

	*(a_uint16_t *)&wh->i_seq[0] =  adf_os_cpu_to_le16(ni->ni_txseqmgmt <<
							   IEEE80211_SEQ_SEQ_SHIFT);
	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);

	ctsduration = 0;
  90a085:	df80      	mov.n	a15, a8
			if (flags & HAL_TXDESC_RTSENA)      /* SIFS + CTS */
				ctsduration += rt->info[cix].spAckDuration;
			if ((flags & HAL_TXDESC_NOACK) == 0)    /* SIFS + ACK */
				ctsduration += rt->info[cix].spAckDuration;
		} else {
			if (flags & HAL_TXDESC_RTSENA)      /* SIFS + CTS */
  90a087:	7c5002        	bnone	a5, a12, 90a08d <ath_tgt_send_mgt+0x289>
				ctsduration += rt->info[cix].lpAckDuration;
  90a08a:	2fa10a        	l16ui	a15, a10, 20
			if ((flags & HAL_TXDESC_NOACK) == 0)    /* SIFS + ACK */
  90a08d:	7e5f0b        	bbsi	a5, 30, 90a09c <ath_tgt_send_mgt+0x298>
				ctsduration += rt->info[cix].lpAckDuration;
  90a090:	b2bb      	addi.n	a11, a11, 2
  90a092:	0cbb11        	slli	a11, a11, 4
  90a095:	ab9b      	add.n	a11, a9, a11
  90a097:	2ab10a        	l16ui	a10, a11, 20
  90a09a:	aaff      	add.n	a15, a15, a10
		}
		ctsduration += ath_hal_computetxtime(ah,
  90a09c:	2c122f        	l32i	a12, a1, 188
  90a09f:	2a122d        	l32i	a10, a1, 180
  90a0a2:	db90      	mov.n	a11, a9
  90a0a4:	de80      	mov.n	a14, a8
  90a0a6:	2f1634        	s32i	a15, a1, 208
  90a0a9:	5bebb4        	call8	904f7c <ath_hal_computetxtime>
  90a0ac:	2f1234        	l32i	a15, a1, 208
						     rt, pktlen, rix, shortPreamble);
		try0 = 1;
  90a0af:	c0c1      	movi.n	a12, 1
			if (flags & HAL_TXDESC_RTSENA)      /* SIFS + CTS */
				ctsduration += rt->info[cix].lpAckDuration;
			if ((flags & HAL_TXDESC_NOACK) == 0)    /* SIFS + ACK */
				ctsduration += rt->info[cix].lpAckDuration;
		}
		ctsduration += ath_hal_computetxtime(ah,
  90a0b1:	afaa      	add.n	a10, a10, a15
  90a0b3:	600003        	j	90a0ba <ath_tgt_send_mgt+0x2b6>

	*(a_uint16_t *)&wh->i_seq[0] =  adf_os_cpu_to_le16(ni->ni_txseqmgmt <<
							   IEEE80211_SEQ_SEQ_SHIFT);
	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);

	ctsduration = 0;
  90a0b6:	daf0      	mov.n	a10, a15
		}
		ctsduration += ath_hal_computetxtime(ah,
						     rt, pktlen, rix, shortPreamble);
		try0 = 1;
	} else
		ctsrate = 0;
  90a0b8:	d4f0      	mov.n	a4, a15

	flags |= HAL_TXDESC_INTREQ;

	ah->ah_setupTxDesc(ds
  90a0ba:	281231        	l32i	a8, a1, 196
						     rt, pktlen, rix, shortPreamble);
		try0 = 1;
	} else
		ctsrate = 0;

	flags |= HAL_TXDESC_INTREQ;
  90a0bd:	c190      	movi.n	a9, 16
  90a0bf:	095502        	or	a5, a5, a9

	ah->ah_setupTxDesc(ds
  90a0c2:	008932        	sext	a9, a8, 7
  90a0c5:	28122d        	l32i	a8, a1, 180
  90a0c8:	9c10      	s32i.n	a12, a1, 0
  90a0ca:	9512      	s32i.n	a5, a1, 8
  90a0cc:	9a14      	s32i.n	a10, a1, 16
  90a0ce:	9911      	s32i.n	a9, a1, 4
  90a0d0:	9413      	s32i.n	a4, a1, 12
  90a0d2:	298217        	l32i	a9, a8, 92
  90a0d5:	2a1230        	l32i	a10, a1, 192
  90a0d8:	2b122f        	l32i	a11, a1, 188
  90a0db:	2c1233        	l32i	a12, a1, 204
  90a0de:	2d122e        	l32i	a13, a1, 184
  90a0e1:	2f122c        	l32i	a15, a1, 176
  90a0e4:	c3ec      	movi.n	a14, 60
  90a0e6:	0b9000        	callx8	a9
			    , keyix
			    , flags
			    , ctsrate
			    , ctsduration);

	bf->bf_flags = flags;
  90a0e9:	257544        	s16i	a5, a7, 136

	/*
	 * Set key type in tx desc while sending the encrypted challenge to AP
	 * in Auth frame 3 of Shared Authentication, owl needs this.
	 */
	if (iswep && (keyix != HAL_TXKEYIX_INVALID) &&
  90a0ec:	251232        	l32i	a5, a1, 200
  90a0ef:	c95f      	beqz.n	a5, 90a112 <ath_tgt_send_mgt+0x30e>
			(wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK) == IEEE80211_FC0_SUBTYPE_AUTH)
  90a0f1:	266000        	l8ui	a6, a6, 0
  90a0f4:	250af0        	movi	a5, 240

	/*
	 * Set key type in tx desc while sending the encrypted challenge to AP
	 * in Auth frame 3 of Shared Authentication, owl needs this.
	 */
	if (iswep && (keyix != HAL_TXKEYIX_INVALID) &&
  90a0f7:	056601        	and	a6, a6, a5
  90a0fa:	250ab0        	movi	a5, 176
  90a0fd:	756911        	bne	a6, a5, 90a112 <ath_tgt_send_mgt+0x30e>
			(wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK) == IEEE80211_FC0_SUBTYPE_AUTH)
		ah->ah_fillKeyTxDesc(ds, mh->keytype);
  90a100:	26122d        	l32i	a6, a1, 180
  90a103:	2b3004        	l8ui	a11, a3, 4
  90a106:	2a1230        	l32i	a10, a1, 192
  90a109:	236219        	l32i	a3, a6, 100
  90a10c:	00bb32        	sext	a11, a11, 7
  90a10f:	0b3000        	callx8	a3

	ath_filltxdesc(sc, bf);
  90a112:	da20      	mov.n	a10, a2
  90a114:	db70      	mov.n	a11, a7
  90a116:	5bfbf8        	call8	9090f8 <ath_filltxdesc>

	for (i=0; i<4; i++) {
		series[i].Tries = 2;
		series[i].Rate = txrate;
		series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
  90a119:	232d16        	addmi	a3, a2, 0x1600
  90a11c:	2a3026        	l8ui	a10, a3, 38
	sc->sc_tx_stats.ast_tx_shortretry += sr;
	sc->sc_tx_stats.ast_tx_longretry += lr;
}

void
ath_tgt_send_mgt(struct ath_softc_tgt *sc,adf_nbuf_t hdr_buf, adf_nbuf_t skb,
  90a11f:	261c70        	addi	a6, a1, 112
  90a122:	231c20        	addi	a3, a1, 32
		ah->ah_fillKeyTxDesc(ds, mh->keytype);

	ath_filltxdesc(sc, bf);

	for (i=0; i<4; i++) {
		series[i].Tries = 2;
  90a125:	c0b2      	movi.n	a11, 2
		series[i].Rate = txrate;
		series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
		series[i].RateFlags = 0;
  90a127:	c090      	movi.n	a9, 0

	ath_filltxdesc(sc, bf);

	for (i=0; i<4; i++) {
		series[i].Tries = 2;
		series[i].Rate = txrate;
  90a129:	28122c        	l32i	a8, a1, 176
		ah->ah_fillKeyTxDesc(ds, mh->keytype);

	ath_filltxdesc(sc, bf);

	for (i=0; i<4; i++) {
		series[i].Tries = 2;
  90a12c:	9b30      	s32i.n	a11, a3, 0
		series[i].Rate = txrate;
  90a12e:	9831      	s32i.n	a8, a3, 4
		series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
  90a130:	9a33      	s32i.n	a10, a3, 12
		series[i].RateFlags = 0;
  90a132:	9934      	s32i.n	a9, a3, 16
  90a134:	233c14        	addi	a3, a3, 20
  90a137:	c050      	movi.n	a5, 0
			(wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK) == IEEE80211_FC0_SUBTYPE_AUTH)
		ah->ah_fillKeyTxDesc(ds, mh->keytype);

	ath_filltxdesc(sc, bf);

	for (i=0; i<4; i++) {
  90a139:	7639ec        	bne	a3, a6, 90a129 <ath_tgt_send_mgt+0x325>
		series[i].Tries = 2;
		series[i].Rate = txrate;
		series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
		series[i].RateFlags = 0;
	}
	ah->ah_set11nRateScenario(ds, 0, ctsrate, series, 4, 0);
  90a13c:	26122d        	l32i	a6, a1, 180
  90a13f:	2a1230        	l32i	a10, a1, 192
  90a142:	236210        	l32i	a3, a6, 64
  90a145:	db50      	mov.n	a11, a5
  90a147:	dc40      	mov.n	a12, a4
  90a149:	df50      	mov.n	a15, a5
  90a14b:	2d1c20        	addi	a13, a1, 32
  90a14e:	2e0a04        	movi	a14, 4
  90a151:	0b3000        	callx8	a3
static void
ath_tgt_txqaddbuf(struct ath_softc_tgt *sc,
		  struct ath_txq *txq, struct ath_tx_buf *bf,
		  struct ath_tx_desc *lastds)
{
	struct ath_hal *ah = sc->sc_ah;
  90a154:	232d05        	addmi	a3, a2, 0x500
  90a157:	843b      	l32i.n	a4, a3, 44

	ATH_TXQ_INSERT_TAIL(txq, bf, bf_list);
  90a159:	233aec        	movi	a3, 0x3ec
  90a15c:	a323      	add.n	a3, a2, a3
  90a15e:	9579      	s32i.n	a5, a7, 36
  90a160:	8533      	l32i.n	a5, a3, 12
		series[i].Rate = txrate;
		series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
		series[i].RateFlags = 0;
	}
	ah->ah_set11nRateScenario(ds, 0, ctsrate, series, 4, 0);
	ath_tgt_txqaddbuf(sc, txq, bf, bf->bf_lastds);
  90a162:	867e      	l32i.n	a6, a7, 56
		  struct ath_txq *txq, struct ath_tx_buf *bf,
		  struct ath_tx_desc *lastds)
{
	struct ath_hal *ah = sc->sc_ah;

	ATH_TXQ_INSERT_TAIL(txq, bf, bf_list);
  90a164:	957a      	s32i.n	a5, a7, 40
  90a166:	9750      	s32i.n	a7, a5, 0
  90a168:	257c24        	addi	a5, a7, 36
  90a16b:	9533      	s32i.n	a5, a3, 12
  90a16d:	8534      	l32i.n	a5, a3, 16
  90a16f:	9735      	s32i.n	a7, a3, 20
  90a171:	b155      	addi.n	a5, a5, 1
  90a173:	9534      	s32i.n	a5, a3, 16

	if (txq->axq_link == NULL) {
  90a175:	8531      	l32i.n	a5, a3, 4
  90a177:	cc5d      	bnez.n	a5, 90a188 <ath_tgt_send_mgt+0x384>
		ah->ah_setTxDP(ah, txq->axq_qnum, ATH_BUF_GET_DESC_PHY_ADDR(bf));
  90a179:	854a      	l32i.n	a5, a4, 40
  90a17b:	8b30      	l32i.n	a11, a3, 0
  90a17d:	8c7c      	l32i.n	a12, a7, 48
  90a17f:	da40      	mov.n	a10, a4
  90a181:	0b5000        	callx8	a5
  90a184:	600004        	j	90a18c <ath_tgt_send_mgt+0x388>
  90a187:	00837c        	excw
	} else {
		*txq->axq_link = ATH_BUF_GET_DESC_PHY_ADDR(bf);
  90a18a:	9350      	s32i.n	a3, a5, 0
	}

	txq->axq_link = &lastds->ds_link;
  90a18c:	233aec        	movi	a3, 0x3ec
  90a18f:	a322      	add.n	a2, a2, a3
	ah->ah_startTxDma(ah, txq->axq_qnum);
  90a191:	8b20      	l32i.n	a11, a2, 0
  90a193:	834c      	l32i.n	a3, a4, 48
		ah->ah_setTxDP(ah, txq->axq_qnum, ATH_BUF_GET_DESC_PHY_ADDR(bf));
	} else {
		*txq->axq_link = ATH_BUF_GET_DESC_PHY_ADDR(bf);
	}

	txq->axq_link = &lastds->ds_link;
  90a195:	9621      	s32i.n	a6, a2, 4
	ah->ah_startTxDma(ah, txq->axq_qnum);
  90a197:	da40      	mov.n	a10, a4
  90a199:	0b3000        	callx8	a3
  90a19c:	d10f      	retw.n
  90a19e:	000000        	ill
	ah->ah_set11nRateScenario(ds, 0, ctsrate, series, 4, 0);
	ath_tgt_txqaddbuf(sc, txq, bf, bf->bf_lastds);

	return;
fail:
	HTC_ReturnBuffers(sc->tgt_htc_handle, endpt, skb);
  90a1a1:	137184        	l32r	a3, 8e67b4 <memset+0x1618>
  90a1a4:	8a22      	l32i.n	a10, a2, 8
  90a1a6:	233287        	l32i	a3, a3, 0x21c
  90a1a9:	db50      	mov.n	a11, a5
  90a1ab:	dc40      	mov.n	a12, a4
  90a1ad:	0b3000        	callx8	a3
  90a1b0:	d10f      	retw.n
	...

0090a1b4 <ath_tgt_handle_normal>:
	txq->axq_link = &lastds->ds_link;
	ah->ah_startTxDma(ah, txq->axq_qnum);
}

void ath_tgt_handle_normal(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90a1b4:	6c1004        	entry	a1, 32
	ath_atx_tid_t *tid;
	struct ath_node_target *an;

	an = (struct ath_node_target *)bf->bf_node;
  90a1b7:	8934      	l32i.n	a9, a3, 16
	txq->axq_link = &lastds->ds_link;
	ah->ah_startTxDma(ah, txq->axq_qnum);
}

void ath_tgt_handle_normal(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90a1b9:	da20      	mov.n	a10, a2
  90a1bb:	db30      	mov.n	a11, a3
	ath_atx_tid_t *tid;
	struct ath_node_target *an;

	an = (struct ath_node_target *)bf->bf_node;
	adf_os_assert(an);
  90a1bd:	cc94      	bnez.n	a9, 90a1c5 <ath_tgt_handle_normal+0x11>
  90a1bf:	63fffc        	j	90a1bf <ath_tgt_handle_normal+0xb>
  90a1c2:	000000        	ill

	tid = &an->tid[bf->bf_tidno];
  90a1c5:	28304d        	l8ui	a8, a3, 77
  90a1c8:	0c8c11        	slli	a12, a8, 4
  90a1cb:	08c80c        	sub	a8, a12, a8
  90a1ce:	09880a        	addx4	a8, a8, a9
	adf_os_assert(tid);

	bf->bf_comp = ath_tgt_tx_comp_normal;
  90a1d1:	1972ca        	l32r	a9, 8e6cfc <memset+0x1b60>
  90a1d4:	993f      	s32i.n	a9, a3, 60
	INCR(tid->seq_start, IEEE80211_SEQ_MAX);
  90a1d6:	298114        	l16ui	a9, a8, 40
  90a1d9:	b199      	addi.n	a9, a9, 1
  90a1db:	09094b        	extui	a9, a9, 0, 12
  90a1de:	298514        	s16i	a9, a8, 40
	ath_tgt_tx_send_normal(sc, bf);
  90a1e1:	5bfee7        	call8	909d80 <ath_tgt_tx_send_normal>
  90a1e4:	d10f      	retw.n
	...

0090a1e8 <ath_tx_addto_baw>:

	return ATH_TGT_AGGR_DONE;
}

void ath_tx_addto_baw(ath_atx_tid_t *tid, struct ath_tx_buf *bf)
{
  90a1e8:	6c1004        	entry	a1, 32
	int index, cindex;

	if (bf->bf_isretried) {
  90a1eb:	283221        	l32i	a8, a3, 132
  90a1ee:	7b8f3e        	bbsi	a8, 27, 90a230 <ath_tx_addto_baw+0x48>
		return;
	}

	index  = ATH_BA_INDEX(tid->seq_start, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90a1f1:	293123        	l16ui	a9, a3, 70
  90a1f4:	232102        	l16ui	a3, a2, 4
  90a1f7:	094914        	srli	a9, a9, 4
  90a1fa:	03990c        	sub	a9, a9, a3
	cindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);
  90a1fd:	8a23      	l32i.n	a10, a2, 12

	if (bf->bf_isretried) {
		return;
	}

	index  = ATH_BA_INDEX(tid->seq_start, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90a1ff:	09094b        	extui	a9, a9, 0, 12
	cindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);
  90a202:	a9ac      	add.n	a12, a10, a9
  90a204:	0c0846        	extui	a8, a12, 0, 7

	TX_BUF_BITMAP_SET(tid->tx_buf_bitmap, cindex);
  90a207:	085b12        	srai	a11, a8, 5
  90a20a:	b4bb      	addi.n	a11, a11, 4
  90a20c:	02bb0a        	addx4	a11, a11, a2
  90a20f:	c031      	movi.n	a3, 1
  90a211:	00c104        	ssl	a12
  90a214:	003c1a        	sll	a12, a3
  90a217:	83b1      	l32i.n	a3, a11, 4
  90a219:	0c3c02        	or	a12, a3, a12

	if (index >= ((tid->baw_tail - tid->baw_head) & (ATH_TID_MAX_BUFS - 1))) {
  90a21c:	8324      	l32i.n	a3, a2, 16
	}

	index  = ATH_BA_INDEX(tid->seq_start, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
	cindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);

	TX_BUF_BITMAP_SET(tid->tx_buf_bitmap, cindex);
  90a21e:	9cb1      	s32i.n	a12, a11, 4

	if (index >= ((tid->baw_tail - tid->baw_head) & (ATH_TID_MAX_BUFS - 1))) {
  90a220:	0a3a0c        	sub	a10, a3, a10
  90a223:	0a0a46        	extui	a10, a10, 0, 7
  90a226:	7a9206        	blt	a9, a10, 90a230 <ath_tx_addto_baw+0x48>
		tid->baw_tail = cindex;
		INCR(tid->baw_tail, ATH_TID_MAX_BUFS);
  90a229:	b188      	addi.n	a8, a8, 1
  90a22b:	080846        	extui	a8, a8, 0, 7
  90a22e:	9824      	s32i.n	a8, a2, 16
  90a230:	d10f      	retw.n
	...

0090a234 <ath_tgt_tx_form_aggr>:
	return aggr_limit;
}

int ath_tgt_tx_form_aggr(struct ath_softc_tgt *sc, ath_atx_tid_t *tid,
			 ath_tx_bufhead *bf_q)
{
  90a234:	6c100e        	entry	a1, 112
  90a237:	9419      	s32i.n	a4, a1, 36
	struct ath_tx_buf *bf_first ,*bf_prev = NULL;
	int nframes = 0, rl = 0;;
	struct ath_tx_desc *ds = NULL;
	struct ath_tx_buf *bf;
	struct ath_hal *ah = sc->sc_ah;
  90a239:	242d05        	addmi	a4, a2, 0x500
  90a23c:	844b      	l32i.n	a4, a4, 44
  90a23e:	c161      	movi.n	a6, 17
  90a240:	941b      	s32i.n	a4, a1, 44
	u_int16_t aggr_limit =  (64*1024 -1), al = 0, bpad = 0, al_delta;
	u_int16_t h_baw = tid->baw_size/2, prev_al = 0, prev_frames = 0;
  90a242:	243104        	l16ui	a4, a3, 8
  90a245:	961a      	s32i.n	a6, a1, 40
  90a247:	041414        	srli	a4, a4, 1
  90a24a:	c160      	movi.n	a6, 16

	bf_first = asf_tailq_first(&tid->buf_q);
  90a24c:	853b      	l32i.n	a5, a3, 44
  90a24e:	746302        	bltu	a6, a4, 90a254 <ath_tgt_tx_form_aggr+0x20>
  90a251:	24160a        	s32i	a4, a1, 40
	struct ath_tx_buf *bf_first ,*bf_prev = NULL;
	int nframes = 0, rl = 0;;
	struct ath_tx_desc *ds = NULL;
	struct ath_tx_buf *bf;
	struct ath_hal *ah = sc->sc_ah;
	u_int16_t aggr_limit =  (64*1024 -1), al = 0, bpad = 0, al_delta;
  90a254:	c090      	movi.n	a9, 0
  90a256:	17728e        	l32r	a7, 8e6c90 <memset+0x1af4>
  90a259:	d890      	mov.n	a8, a9

int ath_tgt_tx_form_aggr(struct ath_softc_tgt *sc, ath_atx_tid_t *tid,
			 ath_tx_bufhead *bf_q)
{
	struct ath_tx_buf *bf_first ,*bf_prev = NULL;
	int nframes = 0, rl = 0;;
  90a25b:	dd90      	mov.n	a13, a9
  90a25d:	d690      	mov.n	a6, a9
}

int ath_tgt_tx_form_aggr(struct ath_softc_tgt *sc, ath_atx_tid_t *tid,
			 ath_tx_bufhead *bf_q)
{
	struct ath_tx_buf *bf_first ,*bf_prev = NULL;
  90a25f:	9918      	s32i.n	a9, a1, 32
	u_int16_t h_baw = tid->baw_size/2, prev_al = 0, prev_frames = 0;

	bf_first = asf_tailq_first(&tid->buf_q);

	do {
		bf = asf_tailq_first(&tid->buf_q);
  90a261:	843b      	l32i.n	a4, a3, 44
		adf_os_assert(bf);
  90a263:	cc41      	bnez.n	a4, 90a268 <ath_tgt_tx_form_aggr+0x34>
  90a265:	63fffc        	j	90a265 <ath_tgt_tx_form_aggr+0x31>

		if (!BAW_WITHIN(tid->seq_start, tid->baw_size,
  90a268:	2b4123        	l16ui	a11, a4, 70
  90a26b:	2a3102        	l16ui	a10, a3, 4
  90a26e:	0b4b14        	srli	a11, a11, 4
  90a271:	0abb0c        	sub	a11, a11, a10
  90a274:	2a3104        	l16ui	a10, a3, 8
  90a277:	0b0b4b        	extui	a11, a11, 0, 12
  90a27a:	7ab20a        	blt	a11, a10, 90a288 <ath_tgt_tx_form_aggr+0x54>
				SEQNO_FROM_BF_SEQNO(bf->bf_seqno))) {

			bf_first->bf_al= al;
  90a27d:	285527        	s16i	a8, a5, 78
			bf_first->bf_nframes = nframes;
  90a280:	26544c        	s8i	a6, a5, 76
			return ATH_TGT_AGGR_BAW_CLOSED;
  90a283:	c021      	movi.n	a2, 1
  90a285:	d10f      	retw.n
  90a287:	0065d0        	excw
		}

		if (!rl) {
  90a28a:	af2a      	add.n	a10, a2, a15
				 struct ath_tx_buf *bf)
{
	int i, prate;
	u_int32_t max4msframelen, frame_length;
	u_int16_t aggr_limit, legacy=0;
	const HAL_RATE_TABLE  *rt = sc->sc_currates;
  90a28c:	22812b        	l16ui	a2, a8, 86
	struct ieee80211_node_target *ieee_node = (struct ieee80211_node_target *)an;

	if (bf->bf_ismcast) {
  90a28f:	0a809a        	excw
				 struct ath_tx_buf *bf)
{
	int i, prate;
	u_int32_t max4msframelen, frame_length;
	u_int16_t aggr_limit, legacy=0;
	const HAL_RATE_TABLE  *rt = sc->sc_currates;
  90a292:	1c2a42        	l32r	a12, 8d4b9c <_bss_end+0x3c7394>
	struct ieee80211_node_target *ieee_node = (struct ieee80211_node_target *)an;

	if (bf->bf_ismcast) {
  90a295:	21873e        	excw
  90a298:	7ab018        	bnone	a11, a10, 90a2b4 <ath_tgt_tx_form_aggr+0x80>
		bf->bf_rcs[1].tries = bf->bf_rcs[2].tries = bf->bf_rcs[3].tries = 0;
		bf->bf_rcs[0].rix   = 0xb;
  90a29b:	c0ab      	movi.n	a10, 11
  90a29d:	2a4450        	s8i	a10, a4, 80
		bf->bf_rcs[0].tries = ATH_TXMAXTRY - 1;
  90a2a0:	c0aa      	movi.n	a10, 10
	u_int16_t aggr_limit, legacy=0;
	const HAL_RATE_TABLE  *rt = sc->sc_currates;
	struct ieee80211_node_target *ieee_node = (struct ieee80211_node_target *)an;

	if (bf->bf_ismcast) {
		bf->bf_rcs[1].tries = bf->bf_rcs[2].tries = bf->bf_rcs[3].tries = 0;
  90a2a2:	2d4475        	s8i	a13, a4, 117
  90a2a5:	2d4469        	s8i	a13, a4, 105
  90a2a8:	2d445d        	s8i	a13, a4, 93
		bf->bf_rcs[0].rix   = 0xb;
		bf->bf_rcs[0].tries = ATH_TXMAXTRY - 1;
  90a2ab:	2a4451        	s8i	a10, a4, 81
		bf->bf_rcs[0].flags = 0;
  90a2ae:	2d4453        	s8i	a13, a4, 83
  90a2b1:	600024        	j	90a2d9 <ath_tgt_tx_form_aggr+0xa5>
	} else {
		ath_tgt_rate_findrate(sc, an, AH_TRUE, 0, ATH_TXMAXTRY-1, 4, 1,
				      ATH_RC_PROBE_ALLOWED, bf->bf_rcs, &prate);
  90a2b4:	2a4c50        	addi	a10, a4, 80
				  a_int32_t stepDnInc,
				  a_uint32_t rcflag,
				  struct ath_rc_series series[],
				  a_int32_t *isProbe)
{
	ath_rate_findrate(sc, an, 1, frameLen, 10, 4, 1,
  90a2b7:	c0c1      	movi.n	a12, 1
  90a2b9:	9a12      	s32i.n	a10, a1, 8
  90a2bb:	2a1c10        	addi	a10, a1, 16
  90a2be:	9a13      	s32i.n	a10, a1, 12
  90a2c0:	9c10      	s32i.n	a12, a1, 0
  90a2c2:	9c11      	s32i.n	a12, a1, 4
  90a2c4:	da20      	mov.n	a10, a2
  90a2c6:	db70      	mov.n	a11, a7
  90a2c8:	c0ea      	movi.n	a14, 10
  90a2ca:	c0f4      	movi.n	a15, 4
  90a2cc:	981f      	s32i.n	a8, a1, 60
  90a2ce:	291610        	s32i	a9, a1, 64
  90a2d1:	5bfad1        	call8	908e18 <ath_rate_findrate>
  90a2d4:	291210        	l32i	a9, a1, 64
  90a2d7:	881f      	l32i.n	a8, a1, 60
}

int ath_tgt_tx_form_aggr(struct ath_softc_tgt *sc, ath_atx_tid_t *tid,
			 ath_tx_bufhead *bf_q)
{
	struct ath_tx_buf *bf_first ,*bf_prev = NULL;
  90a2d9:	1b728e        	l32r	a11, 8e6d14 <memset+0x1b78>
  90a2dc:	da40      	mov.n	a10, a4
  90a2de:	c0c0      	movi.n	a12, 0
	}

	max4msframelen = IEEE80211_AMPDU_LIMIT_MAX;

	for (i = 0; i < 4; i++) {
		if (bf->bf_rcs[i].tries) {
  90a2e0:	2da051        	l8ui	a13, a10, 81
  90a2e3:	c9d6      	beqz.n	a13, 90a2fd <ath_tgt_tx_form_aggr+0xc9>
			frame_length = bf->bf_rcs[i].max4msframelen;

			if (rt->info[bf->bf_rcs[i].rix].phy != IEEE80211_T_HT) {
  90a2e5:	2ea050        	l8ui	a14, a10, 80
  90a2e8:	8f1c      	l32i.n	a15, a1, 48
  90a2ea:	b2ee      	addi.n	a14, a14, 2
  90a2ec:	0cee11        	slli	a14, a14, 4
  90a2ef:	aefe      	add.n	a14, a15, a14
  90a2f1:	2ee009        	l8ui	a14, a14, 9

	max4msframelen = IEEE80211_AMPDU_LIMIT_MAX;

	for (i = 0; i < 4; i++) {
		if (bf->bf_rcs[i].tries) {
			frame_length = bf->bf_rcs[i].max4msframelen;
  90a2f4:	2da215        	l32i	a13, a10, 84

			if (rt->info[bf->bf_rcs[i].rix].phy != IEEE80211_T_HT) {
  90a2f7:	69e40f        	bnei	a14, 4, 90a30a <ath_tgt_tx_form_aggr+0xd6>
				legacy = 1;
				break;
			}

			max4msframelen = ATH_MIN(max4msframelen, frame_length);
  90a2fa:	0dbb36        	minu	a11, a11, a13
				      ATH_RC_PROBE_ALLOWED, bf->bf_rcs, &prate);
	}

	max4msframelen = IEEE80211_AMPDU_LIMIT_MAX;

	for (i = 0; i < 4; i++) {
  90a2fd:	b1cc      	addi.n	a12, a12, 1
  90a2ff:	bcaa      	addi.n	a10, a10, 12
  90a301:	69c4db        	bnei	a12, 4, 90a2e0 <ath_tgt_tx_form_aggr+0xac>
				 struct ath_node_target *an,
				 struct ath_tx_buf *bf)
{
	int i, prate;
	u_int32_t max4msframelen, frame_length;
	u_int16_t aggr_limit, legacy=0;
  90a304:	c0c0      	movi.n	a12, 0
  90a306:	600002        	j	90a30c <ath_tgt_tx_form_aggr+0xd8>
  90a309:	00c0c1        	excw

			max4msframelen = ATH_MIN(max4msframelen, frame_length);
		}
	}

	if (prate || legacy)
  90a30c:	8d14      	l32i.n	a13, a1, 16
		return 0;
  90a30e:	c0a0      	movi.n	a10, 0

			max4msframelen = ATH_MIN(max4msframelen, frame_length);
		}
	}

	if (prate || legacy)
  90a310:	7ad924        	bne	a13, a10, 90a338 <ath_tgt_tx_form_aggr+0x104>
		return 0;
  90a313:	dad0      	mov.n	a10, a13

			max4msframelen = ATH_MIN(max4msframelen, frame_length);
		}
	}

	if (prate || legacy)
  90a315:	cdcf      	bnez.n	a12, 90a338 <ath_tgt_tx_form_aggr+0x104>
		return 0;

	if (sc->sc_ic.ic_enable_coex)
  90a317:	2a2d16        	addmi	a10, a2, 0x1600
  90a31a:	2ca025        	l8ui	a12, a10, 37
  90a31d:	2aa208        	l32i	a10, a10, 32
  90a320:	64c005        	beqz	a12, 90a329 <ath_tgt_tx_form_aggr+0xf5>
		aggr_limit = ATH_MIN((max4msframelen*3)/8, sc->sc_ic.ic_ampdu_limit);
  90a323:	0bbb09        	addx2	a11, a11, a11
  90a326:	0b3b14        	srli	a11, a11, 3
	else
		aggr_limit = ATH_MIN(max4msframelen, sc->sc_ic.ic_ampdu_limit);
  90a329:	0aba36        	minu	a10, a11, a10

	if (ieee_node->ni_maxampdu)
  90a32c:	27710a        	l16ui	a7, a7, 20
		return 0;

	if (sc->sc_ic.ic_enable_coex)
		aggr_limit = ATH_MIN((max4msframelen*3)/8, sc->sc_ic.ic_ampdu_limit);
	else
		aggr_limit = ATH_MIN(max4msframelen, sc->sc_ic.ic_ampdu_limit);
  90a32f:	0a0a4f        	extui	a10, a10, 0, 16

	if (ieee_node->ni_maxampdu)
		aggr_limit = ATH_MIN(aggr_limit, ieee_node->ni_maxampdu);
  90a332:	07ab36        	minu	a11, a10, a7
  90a335:	07ba39        	movnez	a10, a11, a7
			bf_first->bf_nframes = nframes;
			return ATH_TGT_AGGR_BAW_CLOSED;
		}

		if (!rl) {
			aggr_limit = ath_lookup_rate(sc, tid->an, bf);
  90a338:	0a074f        	extui	a7, a10, 0, 16
			rl = 1;
		}

		al_delta = ATH_AGGR_DELIM_SZ + bf->bf_pktlen;
  90a33b:	2c4122        	l16ui	a12, a4, 68
  90a33e:	b4cc      	addi.n	a12, a12, 4
  90a340:	0c0c4f        	extui	a12, a12, 0, 16

		if (nframes && (aggr_limit < (al + bpad + al_delta + prev_al))) {
  90a343:	c869      	beqz.n	a6, 90a350 <ath_tgt_tx_form_aggr+0x11c>
  90a345:	a98a      	add.n	a10, a8, a9
  90a347:	acaa      	add.n	a10, a10, a12
  90a349:	7a7a03        	bge	a7, a10, 90a350 <ath_tgt_tx_form_aggr+0x11c>
  90a34c:	600005        	j	90a355 <ath_tgt_tx_form_aggr+0x121>
  90a34f:	008a1a        	sll	a10, a8
			bf_first->bf_nframes = nframes;
			return ATH_TGT_AGGR_LIMITED;
		}

#ifdef PROJECT_K2
		if ((nframes + prev_frames) >= ATH_MIN((h_baw), 17)) {
  90a352:	7a620a        	blt	a6, a10, 90a360 <ath_tgt_tx_form_aggr+0x12c>
#else
		if ((nframes + prev_frames) >= ATH_MIN((h_baw), 22)) {
#endif
			bf_first->bf_al= al;
  90a355:	285527        	s16i	a8, a5, 78
			bf_first->bf_nframes = nframes;
  90a358:	26544c        	s8i	a6, a5, 76
			return ATH_TGT_AGGR_LIMITED;
  90a35b:	c022      	movi.n	a2, 2
  90a35d:	d10f      	retw.n
  90a35f:	00da30        	excw
		}

		ath_tx_addto_baw(tid, bf);
  90a362:	db40      	mov.n	a11, a4
  90a364:	981f      	s32i.n	a8, a1, 60
  90a366:	291610        	s32i	a9, a1, 64
  90a369:	9c1e      	s32i.n	a12, a1, 56
  90a36b:	5bff9f        	call8	90a1e8 <ath_tx_addto_baw>
		asf_tailq_remove(&tid->buf_q, bf, bf_list);
  90a36e:	8a49      	l32i.n	a10, a4, 36
  90a370:	8b4a      	l32i.n	a11, a4, 40
  90a372:	881f      	l32i.n	a8, a1, 60
  90a374:	291210        	l32i	a9, a1, 64
  90a377:	8c1e      	l32i.n	a12, a1, 56
  90a379:	c8a3      	beqz.n	a10, 90a380 <ath_tgt_tx_form_aggr+0x14c>
  90a37b:	9baa      	s32i.n	a11, a10, 40
  90a37d:	600001        	j	90a382 <ath_tgt_tx_form_aggr+0x14e>
  90a380:	9b3c      	s32i.n	a11, a3, 48
  90a382:	8b4a      	l32i.n	a11, a4, 40
		asf_tailq_insert_tail(bf_q, bf, bf_list);
  90a384:	8d19      	l32i.n	a13, a1, 36
			bf_first->bf_nframes = nframes;
			return ATH_TGT_AGGR_LIMITED;
		}

		ath_tx_addto_baw(tid, bf);
		asf_tailq_remove(&tid->buf_q, bf, bf_list);
  90a386:	9ab0      	s32i.n	a10, a11, 0
		asf_tailq_insert_tail(bf_q, bf, bf_list);
  90a388:	8bd1      	l32i.n	a11, a13, 4
  90a38a:	c0a0      	movi.n	a10, 0
  90a38c:	9b4a      	s32i.n	a11, a4, 40
  90a38e:	9a49      	s32i.n	a10, a4, 36
  90a390:	94b0      	s32i.n	a4, a11, 0
  90a392:	2b4c24        	addi	a11, a4, 36
  90a395:	9bd1      	s32i.n	a11, a13, 4
		nframes ++;

		adf_os_assert(bf);

		adf_os_assert(bf->bf_comp == ath_tgt_tx_comp_aggr);
  90a397:	8d4f      	l32i.n	a13, a4, 60
  90a399:	1b72cb        	l32r	a11, 8e6ec8 <memset+0x1d2c>
		}

		ath_tx_addto_baw(tid, bf);
		asf_tailq_remove(&tid->buf_q, bf, bf_list);
		asf_tailq_insert_tail(bf_q, bf, bf_list);
		nframes ++;
  90a39c:	b166      	addi.n	a6, a6, 1

		adf_os_assert(bf);

		adf_os_assert(bf->bf_comp == ath_tgt_tx_comp_aggr);
  90a39e:	7bd102        	beq	a13, a11, 90a3a4 <ath_tgt_tx_form_aggr+0x170>
  90a3a1:	63fffc        	j	90a3a1 <ath_tgt_tx_form_aggr+0x16d>

		al += bpad + al_delta;
  90a3a4:	a988      	add.n	a8, a8, a9
		bf->bf_ndelim = ATH_AGGR_GET_NDELIM(bf->bf_pktlen);
  90a3a6:	294122        	l16ui	a9, a4, 68

		adf_os_assert(bf);

		adf_os_assert(bf->bf_comp == ath_tgt_tx_comp_aggr);

		al += bpad + al_delta;
  90a3a9:	ac88      	add.n	a8, a8, a12
		bf->bf_ndelim = ATH_AGGR_GET_NDELIM(bf->bf_pktlen);
  90a3ab:	2b0afb        	movi	a11, 251

		adf_os_assert(bf);

		adf_os_assert(bf->bf_comp == ath_tgt_tx_comp_aggr);

		al += bpad + al_delta;
  90a3ae:	08084f        	extui	a8, a8, 0, 16
		bf->bf_ndelim = ATH_AGGR_GET_NDELIM(bf->bf_pktlen);
  90a3b1:	79b208        	blt	a11, a9, 90a3bd <ath_tgt_tx_form_aggr+0x189>
  90a3b4:	2a0afc        	movi	a10, 252
  90a3b7:	09aa0c        	sub	a10, a10, a9
  90a3ba:	0a2a47        	extui	a10, a10, 2, 8

		switch (bf->bf_keytype) {
  90a3bd:	2b4085        	l8ui	a11, a4, 133
		adf_os_assert(bf);

		adf_os_assert(bf->bf_comp == ath_tgt_tx_comp_aggr);

		al += bpad + al_delta;
		bf->bf_ndelim = ATH_AGGR_GET_NDELIM(bf->bf_pktlen);
  90a3c0:	2a444b        	s8i	a10, a4, 75

		switch (bf->bf_keytype) {
  90a3c3:	68b212        	beqi	a11, 2, 90a3d9 <ath_tgt_tx_form_aggr+0x1a5>
  90a3c6:	6fb306        	bgeui	a11, 3, 90a3d0 <ath_tgt_tx_form_aggr+0x19c>
  90a3c9:	69b11f        	bnei	a11, 1, 90a3ec <ath_tgt_tx_form_aggr+0x1b8>
  90a3cc:	600010        	j	90a3e0 <ath_tgt_tx_form_aggr+0x1ac>
  90a3cf:	0068b3        	excw
  90a3d2:	0c69b4        	excw
  90a3d5:	156000        	l32r	a5, 8e23d8 <athos_indirection_table_install+0xe90>
  90a3d8:	0dbaaa        	excw
		case HAL_KEY_TYPE_AES:
			bf->bf_ndelim += ATH_AGGR_ENCRYPTDELIM;
  90a3db:	60000a        	j	90a3e9 <ath_tgt_tx_form_aggr+0x1b5>
  90a3de:	00002a        	muluh	a0, a0, a0
			break;
		case HAL_KEY_TYPE_WEP:
		case HAL_KEY_TYPE_TKIP:
			bf->bf_ndelim += 64;
  90a3e1:	ac40      	add.n	a0, a4, a12
  90a3e3:	600002        	j	90a3e9 <ath_tgt_tx_form_aggr+0x1b5>
  90a3e6:	00bcaa        	excw
			break;
		case HAL_KEY_TYPE_WAPI:
			bf->bf_ndelim += 12;
  90a3e9:	2a444b        	s8i	a10, a4, 75
			break;
		default:
			break;
		}

		bpad = PADBYTES(al_delta) + (bf->bf_ndelim << 2);
  90a3ec:	0c0c06        	neg	a12, a12
  90a3ef:	29404b        	l8ui	a9, a4, 75

		if (bf_prev) {
  90a3f2:	8f18      	l32i.n	a15, a1, 32
			break;
		default:
			break;
		}

		bpad = PADBYTES(al_delta) + (bf->bf_ndelim << 2);
  90a3f4:	0c0c41        	extui	a12, a12, 0, 2
  90a3f7:	0c990a        	addx4	a9, a9, a12

		if (bf_prev) {
  90a3fa:	c9fa      	beqz.n	a15, 90a418 <ath_tgt_tx_form_aggr+0x1e4>
			bf_prev->bf_next = bf;
			bf_prev->bf_lastds->ds_link = ATH_BUF_GET_DESC_PHY_ADDR(bf);
  90a3fc:	2b4030        	l8ui	a11, a4, 48
  90a3ff:	8afe      	l32i.n	a10, a15, 56
		}

		bpad = PADBYTES(al_delta) + (bf->bf_ndelim << 2);

		if (bf_prev) {
			bf_prev->bf_next = bf;
  90a401:	94fb      	s32i.n	a4, a15, 44
			bf_prev->bf_lastds->ds_link = ATH_BUF_GET_DESC_PHY_ADDR(bf);
  90a403:	2ba400        	s8i	a11, a10, 0
  90a406:	2b4031        	l8ui	a11, a4, 49
  90a409:	2ba401        	s8i	a11, a10, 1
  90a40c:	2b4032        	l8ui	a11, a4, 50
  90a40f:	2ba402        	s8i	a11, a10, 2
  90a412:	2b4033        	l8ui	a11, a4, 51
  90a415:	2ba403        	s8i	a11, a10, 3
		}
		bf_prev = bf;

		for(ds = bf->bf_desc; ds <= bf->bf_lastds; ds++)
  90a418:	8c4c      	l32i.n	a12, a4, 48
  90a41a:	2d0a88        	movi	a13, 136
  90a41d:	600020        	j	90a441 <ath_tgt_tx_form_aggr+0x20d>
			ah->ah_set11nAggrMiddle(ds, bf->bf_ndelim);
  90a420:	8a1b      	l32i.n	a10, a1, 44
  90a422:	2b404b        	l8ui	a11, a4, 75
  90a425:	2ea212        	l32i	a14, a10, 72
  90a428:	dac0      	mov.n	a10, a12
  90a42a:	981f      	s32i.n	a8, a1, 60
  90a42c:	291610        	s32i	a9, a1, 64
  90a42f:	9c1e      	s32i.n	a12, a1, 56
  90a431:	9d1d      	s32i.n	a13, a1, 52
  90a433:	0be000        	callx8	a14
			bf_prev->bf_next = bf;
			bf_prev->bf_lastds->ds_link = ATH_BUF_GET_DESC_PHY_ADDR(bf);
		}
		bf_prev = bf;

		for(ds = bf->bf_desc; ds <= bf->bf_lastds; ds++)
  90a436:	8c1e      	l32i.n	a12, a1, 56
  90a438:	8d1d      	l32i.n	a13, a1, 52
  90a43a:	291210        	l32i	a9, a1, 64
  90a43d:	881f      	l32i.n	a8, a1, 60
  90a43f:	adcc      	add.n	a12, a12, a13
  90a441:	8a4e      	l32i.n	a10, a4, 56
  90a443:	7cabd9        	bgeu	a10, a12, 90a420 <ath_tgt_tx_form_aggr+0x1ec>
  90a446:	9418      	s32i.n	a4, a1, 32
			ah->ah_set11nAggrMiddle(ds, bf->bf_ndelim);

	} while (!asf_tailq_empty(&tid->buf_q));
  90a448:	843b      	l32i.n	a4, a3, 44
  90a44a:	c0d1      	movi.n	a13, 1
  90a44c:	654e11        	bnez	a4, 90a261 <ath_tgt_tx_form_aggr+0x2d>

	bf_first->bf_al= al;
  90a44f:	285527        	s16i	a8, a5, 78
	bf_first->bf_nframes = nframes;
  90a452:	26544c        	s8i	a6, a5, 76

	return ATH_TGT_AGGR_DONE;
  90a455:	d240      	mov.n	a2, a4
}
  90a457:	d10f      	retw.n
  90a459:	000000        	ill

0090a45c <ath_tgt_txq_schedule>:
	asf_tailq_insert_tail(&txq->axq_tidq, tid, tid_qelem);
}

static void
ath_tgt_txq_schedule(struct ath_softc_tgt *sc, struct ath_txq *txq)
{
  90a45c:	6c1008        	entry	a1, 64
	u_int8_t bdone;

	bdone = AH_FALSE;

	do {
		TAILQ_DEQ(&txq->axq_tidq, tid, tid_qelem);
  90a45f:	8536      	l32i.n	a5, a3, 24
  90a461:	6451e8        	beqz	a5, 90a64d <ath_tgt_txq_schedule+0x1f1>
  90a464:	8459      	l32i.n	a4, a5, 36
  90a466:	865a      	l32i.n	a6, a5, 40
  90a468:	c844      	beqz.n	a4, 90a470 <ath_tgt_txq_schedule+0x14>
  90a46a:	964a      	s32i.n	a6, a4, 40
  90a46c:	600002        	j	90a472 <ath_tgt_txq_schedule+0x16>
  90a46f:	009637        	maxu	a6, a9, a0
  90a472:	865a      	l32i.n	a6, a5, 40
  90a474:	9460      	s32i.n	a4, a6, 0
		if (tid == NULL)
			return;

		tid->sched = AH_FALSE;

		if (tid->paused)
  90a476:	275034        	l8ui	a7, a5, 52
		TAILQ_DEQ(&txq->axq_tidq, tid, tid_qelem);

		if (tid == NULL)
			return;

		tid->sched = AH_FALSE;
  90a479:	c040      	movi.n	a4, 0
  90a47b:	245435        	s8i	a4, a5, 53

		if (tid->paused)
  90a47e:	007732        	sext	a7, a7, 7
  90a481:	6571bf        	bnez	a7, 90a644 <ath_tgt_txq_schedule+0x1e8>
			continue;

		if (!(tid->flag & TID_AGGR_ENABLED))
  90a484:	285036        	l8ui	a8, a5, 54
  90a487:	c042      	movi.n	a4, 2
  90a489:	048801        	and	a8, a8, a4
  90a48c:	c061      	movi.n	a6, 1
  90a48e:	8450      	l32i.n	a4, a5, 0
  90a490:	658050        	bnez	a8, 90a4e4 <ath_tgt_txq_schedule+0x88>

static void
ath_tgt_tx_sched_normal(struct ath_softc_tgt *sc, ath_atx_tid_t *tid)
{
	struct ath_tx_buf *bf;
	struct ath_txq *txq =TID_TO_ACTXQ(tid->tidno);;
  90a493:	274cfd        	addi	a7, a4, -3
  90a496:	d980      	mov.n	a9, a8
  90a498:	076939        	movnez	a9, a6, a7
  90a49b:	c997      	beqz.n	a9, 90a4b6 <ath_tgt_txq_schedule+0x5a>
  90a49d:	046839        	movnez	a8, a6, a4
  90a4a0:	c982      	beqz.n	a8, 90a4b6 <ath_tgt_txq_schedule+0x5a>
  90a4a2:	b047      	addi.n	a7, a4, -1
  90a4a4:	6e7210        	bltui	a7, 2, 90a4b8 <ath_tgt_txq_schedule+0x5c>
  90a4a7:	244cfc        	addi	a4, a4, -4
  90a4aa:	c063      	movi.n	a6, 3
  90a4ac:	6f4208        	bgeui	a4, 2, 90a4b8 <ath_tgt_txq_schedule+0x5c>
  90a4af:	c062      	movi.n	a6, 2
  90a4b1:	600003        	j	90a4b8 <ath_tgt_txq_schedule+0x5c>
  90a4b4:	0000c0        	excw
  90a4b7:	600266        	j	90a721 <ath_tgt_tx_comp_normal+0x39>
  90a4ba:	0a266d        	excw
  90a4bd:	058763        	excw

	do {
		if (asf_tailq_empty(&tid->buf_q))
  90a4c0:	8b5b      	l32i.n	a11, a5, 44
  90a4c2:	64b16e        	beqz	a11, 90a634 <ath_tgt_txq_schedule+0x1d8>
			break;

		bf = asf_tailq_first(&tid->buf_q);
		asf_tailq_remove(&tid->buf_q, bf, bf_list);
  90a4c5:	84b9      	l32i.n	a4, a11, 36
  90a4c7:	86ba      	l32i.n	a6, a11, 40
  90a4c9:	c844      	beqz.n	a4, 90a4d1 <ath_tgt_txq_schedule+0x75>
  90a4cb:	964a      	s32i.n	a6, a4, 40
  90a4cd:	600002        	j	90a4d3 <ath_tgt_txq_schedule+0x77>
  90a4d0:	00965c        	extui	a6, a0, 25, 13
  90a4d3:	86ba      	l32i.n	a6, a11, 40
		ath_tgt_tx_send_normal(sc, bf);
  90a4d5:	da20      	mov.n	a10, a2
	do {
		if (asf_tailq_empty(&tid->buf_q))
			break;

		bf = asf_tailq_first(&tid->buf_q);
		asf_tailq_remove(&tid->buf_q, bf, bf_list);
  90a4d7:	9460      	s32i.n	a4, a6, 0
		ath_tgt_tx_send_normal(sc, bf);
  90a4d9:	5bfe29        	call8	909d80 <ath_tgt_tx_send_normal>

	} while (txq->axq_depth < ATH_AGGR_MIN_QDEPTH);
  90a4dc:	8474      	l32i.n	a4, a7, 16
  90a4de:	644fde        	beqz	a4, 90a4c0 <ath_tgt_txq_schedule+0x64>
  90a4e1:	60014f        	j	90a634 <ath_tgt_txq_schedule+0x1d8>
ath_tgt_tx_sched_aggr(struct ath_softc_tgt *sc, ath_atx_tid_t *tid)
{
	struct ath_tx_buf  *bf, *bf_last;
	ATH_AGGR_STATUS status;
	ath_tx_bufhead bf_q;
	struct ath_txq *txq = TID_TO_ACTXQ(tid->tidno);
  90a4e4:	284cfd        	addi	a8, a4, -3
  90a4e7:	d970      	mov.n	a9, a7
  90a4e9:	086939        	movnez	a9, a6, a8
  90a4ec:	090847        	extui	a8, a9, 0, 8
  90a4ef:	c98b      	beqz.n	a8, 90a50e <ath_tgt_txq_schedule+0xb2>
  90a4f1:	046739        	movnez	a7, a6, a4
  90a4f4:	070747        	extui	a7, a7, 0, 8
  90a4f7:	c973      	beqz.n	a7, 90a50e <ath_tgt_txq_schedule+0xb2>
  90a4f9:	b047      	addi.n	a7, a4, -1
  90a4fb:	6e7211        	bltui	a7, 2, 90a510 <ath_tgt_txq_schedule+0xb4>
  90a4fe:	244cfc        	addi	a4, a4, -4
  90a501:	c063      	movi.n	a6, 3
  90a503:	6f4209        	bgeui	a4, 2, 90a510 <ath_tgt_txq_schedule+0xb4>
  90a506:	c062      	movi.n	a6, 2
  90a508:	600004        	j	90a510 <ath_tgt_txq_schedule+0xb4>
  90a50b:	000000        	ill
  90a50e:	c060      	movi.n	a6, 0
  90a510:	02660a        	addx4	a6, a6, a2
  90a513:	266d05        	addmi	a6, a6, 0x500
  90a516:	8663      	l32i.n	a6, a6, 12
	struct ath_tx_desc *ds = NULL;
	struct ath_hal *ah = sc->sc_ah;
  90a518:	242d05        	addmi	a4, a2, 0x500
ath_tgt_tx_sched_aggr(struct ath_softc_tgt *sc, ath_atx_tid_t *tid)
{
	struct ath_tx_buf  *bf, *bf_last;
	ATH_AGGR_STATUS status;
	ath_tx_bufhead bf_q;
	struct ath_txq *txq = TID_TO_ACTXQ(tid->tidno);
  90a51b:	9615      	s32i.n	a6, a1, 20
	struct ath_tx_desc *ds = NULL;
	struct ath_hal *ah = sc->sc_ah;
  90a51d:	864b      	l32i.n	a6, a4, 44
	int i;


	if (asf_tailq_empty(&tid->buf_q))
  90a51f:	845b      	l32i.n	a4, a5, 44
  90a521:	64410f        	beqz	a4, 90a634 <ath_tgt_txq_schedule+0x1d8>

	do {
		if (asf_tailq_empty(&tid->buf_q))
			break;

		asf_tailq_init(&bf_q);
  90a524:	c040      	movi.n	a4, 0

	if (asf_tailq_empty(&tid->buf_q))
		return;

	do {
		if (asf_tailq_empty(&tid->buf_q))
  90a526:	875b      	l32i.n	a7, a5, 44
  90a528:	647108        	beqz	a7, 90a634 <ath_tgt_txq_schedule+0x1d8>
			break;

		asf_tailq_init(&bf_q);

		status = ath_tgt_tx_form_aggr(sc, tid, &bf_q);
  90a52b:	da20      	mov.n	a10, a2
  90a52d:	db50      	mov.n	a11, a5
  90a52f:	dc10      	mov.n	a12, a1

	do {
		if (asf_tailq_empty(&tid->buf_q))
			break;

		asf_tailq_init(&bf_q);
  90a531:	9410      	s32i.n	a4, a1, 0
  90a533:	9111      	s32i.n	a1, a1, 4

		status = ath_tgt_tx_form_aggr(sc, tid, &bf_q);
  90a535:	5bff3f        	call8	90a234 <ath_tgt_tx_form_aggr>

		if (asf_tailq_empty(&bf_q))
  90a538:	8710      	l32i.n	a7, a1, 0
		if (asf_tailq_empty(&tid->buf_q))
			break;

		asf_tailq_init(&bf_q);

		status = ath_tgt_tx_form_aggr(sc, tid, &bf_q);
  90a53a:	9a14      	s32i.n	a10, a1, 16

		if (asf_tailq_empty(&bf_q))
  90a53c:	6470f4        	beqz	a7, 90a634 <ath_tgt_txq_schedule+0x1d8>
			break;

		bf = asf_tailq_first(&bf_q);
		bf_last = asf_tailq_last(&bf_q, ath_tx_bufhead_s);
  90a53f:	8a11      	l32i.n	a10, a1, 4
  90a541:	8aa1      	l32i.n	a10, a10, 4
  90a543:	8da0      	l32i.n	a13, a10, 0

		if (bf->bf_nframes == 1) {
  90a545:	2a704c        	l8ui	a10, a7, 76
  90a548:	69a166        	bnei	a10, 1, 90a5b2 <ath_tgt_txq_schedule+0x156>

			if(bf->bf_retries == 0)
  90a54b:	2a7086        	l8ui	a10, a7, 134
  90a54e:	cca6      	bnez.n	a10, 90a558 <ath_tgt_txq_schedule+0xfc>
				__stats(sc, txaggr_single);
  90a550:	2a2261        	l32i	a10, a2, 0x184
  90a553:	b1aa      	addi.n	a10, a10, 1
  90a555:	2a2661        	s32i	a10, a2, 0x184
			bf->bf_isaggr = 0;
  90a558:	2b7087        	l8ui	a11, a7, 135
  90a55b:	2afadf        	movi	a10, -33
  90a55e:	0aba01        	and	a10, a11, a10
  90a561:	2a7487        	s8i	a10, a7, 135
			bf->bf_lastds = &(bf->bf_descarr[bf->bf_dmamap_info.nsegs -1]);
  90a564:	8a71      	l32i.n	a10, a7, 4
			bf->bf_lastds->ds_link = 0;
  90a566:	c080      	movi.n	a8, 0
		if (bf->bf_nframes == 1) {

			if(bf->bf_retries == 0)
				__stats(sc, txaggr_single);
			bf->bf_isaggr = 0;
			bf->bf_lastds = &(bf->bf_descarr[bf->bf_dmamap_info.nsegs -1]);
  90a568:	b0aa      	addi.n	a10, a10, -1
  90a56a:	0cab11        	slli	a11, a10, 4
  90a56d:	aaba      	add.n	a10, a11, a10
  90a56f:	8b7d      	l32i.n	a11, a7, 52
			bf->bf_lastds->ds_link = 0;
			bf->bf_next = NULL;

			for(ds = bf->bf_desc; ds <= bf->bf_lastds; ds++)
  90a571:	2c0a88        	movi	a12, 136
		if (bf->bf_nframes == 1) {

			if(bf->bf_retries == 0)
				__stats(sc, txaggr_single);
			bf->bf_isaggr = 0;
			bf->bf_lastds = &(bf->bf_descarr[bf->bf_dmamap_info.nsegs -1]);
  90a574:	0baa0b        	addx8	a10, a10, a11
  90a577:	9a7e      	s32i.n	a10, a7, 56
			bf->bf_lastds->ds_link = 0;
  90a579:	24a400        	s8i	a4, a10, 0
  90a57c:	28a401        	s8i	a8, a10, 1
  90a57f:	28a402        	s8i	a8, a10, 2
  90a582:	28a403        	s8i	a8, a10, 3
			bf->bf_next = NULL;
  90a585:	947b      	s32i.n	a4, a7, 44

			for(ds = bf->bf_desc; ds <= bf->bf_lastds; ds++)
  90a587:	8b7c      	l32i.n	a11, a7, 48
  90a589:	600013        	j	90a5a0 <ath_tgt_txq_schedule+0x144>
				ah->ah_clr11nAggr(ds);
  90a58c:	2d6214        	l32i	a13, a6, 80
  90a58f:	dab0      	mov.n	a10, a11
  90a591:	2b1607        	s32i	a11, a1, 28
  90a594:	2c1606        	s32i	a12, a1, 24
  90a597:	0bd000        	callx8	a13
			bf->bf_isaggr = 0;
			bf->bf_lastds = &(bf->bf_descarr[bf->bf_dmamap_info.nsegs -1]);
			bf->bf_lastds->ds_link = 0;
			bf->bf_next = NULL;

			for(ds = bf->bf_desc; ds <= bf->bf_lastds; ds++)
  90a59a:	8b17      	l32i.n	a11, a1, 28
  90a59c:	8c16      	l32i.n	a12, a1, 24
  90a59e:	acbb      	add.n	a11, a11, a12
  90a5a0:	8a7e      	l32i.n	a10, a7, 56
  90a5a2:	7babe6        	bgeu	a10, a11, 90a58c <ath_tgt_txq_schedule+0x130>
				ah->ah_clr11nAggr(ds);

			ath_buf_set_rate(sc, bf);
  90a5a5:	da20      	mov.n	a10, a2
  90a5a7:	db70      	mov.n	a11, a7
  90a5a9:	5bfb40        	call8	9092ac <ath_buf_set_rate>
  90a5ac:	60006c        	j	90a61c <ath_tgt_txq_schedule+0x1c0>
  90a5af:	000000        	ill

			continue;
		}

		bf_last->bf_next = NULL;
		bf_last->bf_lastds->ds_link = 0;
  90a5b2:	8ade      	l32i.n	a10, a13, 56
			bf->bf_txq_add(sc, bf);

			continue;
		}

		bf_last->bf_next = NULL;
  90a5b4:	94db      	s32i.n	a4, a13, 44
		bf_last->bf_lastds->ds_link = 0;
  90a5b6:	24a400        	s8i	a4, a10, 0
  90a5b9:	24a401        	s8i	a4, a10, 1
  90a5bc:	24a402        	s8i	a4, a10, 2
  90a5bf:	24a403        	s8i	a4, a10, 3
		bf_last->bf_ndelim = 0;
  90a5c2:	24d44b        	s8i	a4, a13, 75

		bf->bf_isaggr  = 1;
  90a5c5:	2b7087        	l8ui	a11, a7, 135
  90a5c8:	c2a0      	movi.n	a10, 32
  90a5ca:	0aba02        	or	a10, a11, a10
  90a5cd:	2a7487        	s8i	a10, a7, 135
		ath_buf_set_rate(sc, bf);
  90a5d0:	db70      	mov.n	a11, a7
  90a5d2:	da20      	mov.n	a10, a2
  90a5d4:	2d1606        	s32i	a13, a1, 24
  90a5d7:	5bfb35        	call8	9092ac <ath_buf_set_rate>
		ah->ah_set11nAggrFirst(bf->bf_desc, bf->bf_al,
  90a5da:	8a7c      	l32i.n	a10, a7, 48
  90a5dc:	2b7127        	l16ui	a11, a7, 78
  90a5df:	2e6211        	l32i	a14, a6, 68
  90a5e2:	2c704b        	l8ui	a12, a7, 75
  90a5e5:	0be000        	callx8	a14
					  bf->bf_ndelim);
		bf->bf_lastds = bf_last->bf_lastds;
  90a5e8:	8d16      	l32i.n	a13, a1, 24

		for (i = 0; i < bf_last->bf_dmamap_info.nsegs; i++)
  90a5ea:	c0b0      	movi.n	a11, 0

		bf->bf_isaggr  = 1;
		ath_buf_set_rate(sc, bf);
		ah->ah_set11nAggrFirst(bf->bf_desc, bf->bf_al,
					  bf->bf_ndelim);
		bf->bf_lastds = bf_last->bf_lastds;
  90a5ec:	8ade      	l32i.n	a10, a13, 56
  90a5ee:	9a7e      	s32i.n	a10, a7, 56
  90a5f0:	60001a        	j	90a60e <ath_tgt_txq_schedule+0x1b2>
  90a5f3:	008add        	excw
	tid->sched = AH_TRUE;
	asf_tailq_insert_tail(&txq->axq_tidq, tid, tid_qelem);
}

static void
ath_tgt_txq_schedule(struct ath_softc_tgt *sc, struct ath_txq *txq)
  90a5f6:	0cbe11        	slli	a14, a11, 4
  90a5f9:	abee      	add.n	a14, a14, a11
		ah->ah_set11nAggrFirst(bf->bf_desc, bf->bf_al,
					  bf->bf_ndelim);
		bf->bf_lastds = bf_last->bf_lastds;

		for (i = 0; i < bf_last->bf_dmamap_info.nsegs; i++)
			ah->ah_set11nAggrLast(&bf_last->bf_descarr[i]);
  90a5fb:	2c6213        	l32i	a12, a6, 76
  90a5fe:	0aea0b        	addx8	a10, a14, a10
  90a601:	9b17      	s32i.n	a11, a1, 28
  90a603:	9d16      	s32i.n	a13, a1, 24
  90a605:	0bc000        	callx8	a12
		ath_buf_set_rate(sc, bf);
		ah->ah_set11nAggrFirst(bf->bf_desc, bf->bf_al,
					  bf->bf_ndelim);
		bf->bf_lastds = bf_last->bf_lastds;

		for (i = 0; i < bf_last->bf_dmamap_info.nsegs; i++)
  90a608:	8b17      	l32i.n	a11, a1, 28
  90a60a:	8d16      	l32i.n	a13, a1, 24
  90a60c:	b1bb      	addi.n	a11, a11, 1
  90a60e:	8ad1      	l32i.n	a10, a13, 4
  90a610:	7ab3e0        	bltu	a11, a10, 90a5f4 <ath_tgt_txq_schedule+0x198>
			ah->ah_set11nAggrLast(&bf_last->bf_descarr[i]);

		if (status == ATH_AGGR_8K_LIMITED) {
  90a613:	8914      	l32i.n	a9, a1, 16
  90a615:	699403        	bnei	a9, 4, 90a61c <ath_tgt_txq_schedule+0x1c0>
  90a618:	63fffc        	j	90a618 <ath_tgt_txq_schedule+0x1bc>
  90a61b:	002c72        	excw
			adf_os_assert(0);
			break;
		}

		bf->bf_txq_add(sc, bf);
  90a61e:	10da20        	l32r	a0, 900ea0 <memset+0x1bd04>
  90a621:	db70      	mov.n	a11, a7
  90a623:	0bc000        	callx8	a12
	} while (txq->axq_depth < ATH_AGGR_MIN_QDEPTH &&
		 status != ATH_TGT_AGGR_BAW_CLOSED);
  90a626:	8915      	l32i.n	a9, a1, 20
  90a628:	8894      	l32i.n	a8, a9, 16
  90a62a:	cc86      	bnez.n	a8, 90a634 <ath_tgt_txq_schedule+0x1d8>
			adf_os_assert(0);
			break;
		}

		bf->bf_txq_add(sc, bf);
	} while (txq->axq_depth < ATH_AGGR_MIN_QDEPTH &&
  90a62c:	8814      	l32i.n	a8, a1, 16
  90a62e:	688102        	beqi	a8, 1, 90a634 <ath_tgt_txq_schedule+0x1d8>
  90a631:	63fef1        	j	90a526 <ath_tgt_txq_schedule+0xca>
		else
			ath_tgt_tx_sched_aggr(sc,tid);

		bdone = AH_TRUE;

		if (!asf_tailq_empty(&tid->buf_q)) {
  90a634:	865b      	l32i.n	a6, a5, 44
		if (!(tid->flag & TID_AGGR_ENABLED))
			ath_tgt_tx_sched_normal(sc,tid);
		else
			ath_tgt_tx_sched_aggr(sc,tid);

		bdone = AH_TRUE;
  90a636:	c041      	movi.n	a4, 1

		if (!asf_tailq_empty(&tid->buf_q)) {
  90a638:	c86a      	beqz.n	a6, 90a646 <ath_tgt_txq_schedule+0x1ea>
			ath_tgt_tx_enqueue(txq, tid);
  90a63a:	da30      	mov.n	a10, a3
  90a63c:	db50      	mov.n	a11, a5
  90a63e:	5bfaec        	call8	9091f0 <ath_tgt_tx_enqueue>
  90a641:	600001        	j	90a646 <ath_tgt_txq_schedule+0x1ea>
		if (tid == NULL)
			return;

		tid->sched = AH_FALSE;

		if (tid->paused)
  90a644:	c040      	movi.n	a4, 0

		if (!asf_tailq_empty(&tid->buf_q)) {
			ath_tgt_tx_enqueue(txq, tid);
		}

	} while (!asf_tailq_empty(&txq->axq_tidq) && !bdone);
  90a646:	8636      	l32i.n	a6, a3, 24
  90a648:	c861      	beqz.n	a6, 90a64d <ath_tgt_txq_schedule+0x1f1>
  90a64a:	644e11        	beqz	a4, 90a45f <ath_tgt_txq_schedule+0x3>
  90a64d:	d10f      	retw.n
	...

0090a650 <ath_aggr_resume_tid>:
	return ((((x) & 0xff00) >> 8) |   (((x) & 0x00ff) << 8));
}

static inline void
ath_aggr_resume_tid(struct ath_softc_tgt *sc, ath_atx_tid_t *tid)
{
  90a650:	6c1004        	entry	a1, 32
	struct ath_txq *txq;

	txq = TID_TO_ACTXQ(tid->tidno);
  90a653:	8930      	l32i.n	a9, a3, 0
  90a655:	c081      	movi.n	a8, 1
  90a657:	249cfd        	addi	a4, a9, -3
  90a65a:	c0b0      	movi.n	a11, 0
  90a65c:	048b39        	movnez	a11, a8, a4
  90a65f:	c9b3      	beqz.n	a11, 90a676 <ath_aggr_resume_tid+0x26>
  90a661:	c991      	beqz.n	a9, 90a676 <ath_aggr_resume_tid+0x26>
  90a663:	b094      	addi.n	a4, a9, -1
  90a665:	6e420f        	bltui	a4, 2, 90a678 <ath_aggr_resume_tid+0x28>
  90a668:	299cfc        	addi	a9, a9, -4
  90a66b:	c083      	movi.n	a8, 3
  90a66d:	6f9207        	bgeui	a9, 2, 90a678 <ath_aggr_resume_tid+0x28>
  90a670:	c082      	movi.n	a8, 2
  90a672:	600002        	j	90a678 <ath_aggr_resume_tid+0x28>
  90a675:	00c080        	excw
  90a678:	02880a        	addx4	a8, a8, a2
  90a67b:	288d05        	addmi	a8, a8, 0x500
  90a67e:	8483      	l32i.n	a4, a8, 12
	tid->paused = 0;
  90a680:	c080      	movi.n	a8, 0
  90a682:	283434        	s8i	a8, a3, 52

	if (asf_tailq_empty(&tid->buf_q))
  90a685:	883b      	l32i.n	a8, a3, 44
  90a687:	c88d      	beqz.n	a8, 90a698 <ath_aggr_resume_tid+0x48>
		return;

	ath_tgt_tx_enqueue(txq, tid);
  90a689:	da40      	mov.n	a10, a4
  90a68b:	033b02        	or	a11, a3, a3
  90a68e:	5bfad8        	call8	9091f0 <ath_tgt_tx_enqueue>
	ath_tgt_txq_schedule(sc, txq);
  90a691:	da20      	mov.n	a10, a2
  90a693:	db40      	mov.n	a11, a4
  90a695:	5bff71        	call8	90a45c <ath_tgt_txq_schedule>
  90a698:	d10f      	retw.n
	...

0090a69c <owl_tgt_tid_cleanup>:
	}
}

static void owl_tgt_tid_cleanup(struct ath_softc_tgt *sc,
				struct ath_atx_tid *tid)
{
  90a69c:	6c1004        	entry	a1, 32
	tid->incomp--;
  90a69f:	283037        	l8ui	a8, a3, 55
	}
}

static void owl_tgt_tid_cleanup(struct ath_softc_tgt *sc,
				struct ath_atx_tid *tid)
{
  90a6a2:	da20      	mov.n	a10, a2
	tid->incomp--;
  90a6a4:	b088      	addi.n	a8, a8, -1
  90a6a6:	080847        	extui	a8, a8, 0, 8
  90a6a9:	283437        	s8i	a8, a3, 55
	if (tid->incomp) {
  90a6ac:	cf85      	bnez.n	a8, 90a6e5 <owl_tgt_tid_cleanup+0x49>
		return;
	}

	tid->flag &= ~TID_CLEANUP_INPROGRES;
  90a6ae:	283036        	l8ui	a8, a3, 54
  90a6b1:	29fafe        	movi	a9, -2
  90a6b4:	098901        	and	a9, a8, a9
  90a6b7:	293436        	s8i	a9, a3, 54

	if (tid->flag & TID_REINITIALIZE) {
  90a6ba:	7d8722        	bbci	a8, 29, 90a6e0 <owl_tgt_tid_cleanup+0x44>
		adf_os_print("TID REINIT DONE for tid %p\n", tid);
  90a6bd:	187184        	l32r	a8, 8e6cd0 <memset+0x1b34>
  90a6c0:	1a72cc        	l32r	a10, 8e71f0 <memset+0x2054>
  90a6c3:	288212        	l32i	a8, a8, 72
  90a6c6:	033b02        	or	a11, a3, a3
  90a6c9:	0b8000        	callx8	a8
		tid->flag  &= ~TID_REINITIALIZE;
  90a6cc:	293036        	l8ui	a9, a3, 54
  90a6cf:	c78b      	movi.n	a8, -5
  90a6d1:	089801        	and	a8, a9, a8
  90a6d4:	283436        	s8i	a8, a3, 54
		owl_tgt_tid_init(tid);
  90a6d7:	da30      	mov.n	a10, a3
  90a6d9:	5bfa12        	call8	908f24 <owl_tgt_tid_init>
  90a6dc:	d10f      	retw.n
  90a6de:	0000db        	excw
	} else {
		ath_aggr_resume_tid(sc, tid);
  90a6e1:	305bff        	excw
  90a6e4:	dbd1      	excw
  90a6e6:	0f006c        	excw

0090a6e8 <ath_tgt_tx_comp_normal>:
	tid->baw_tail = tid->baw_head;
}

static void ath_tgt_tx_comp_normal(struct ath_softc_tgt *sc,
				   struct ath_tx_buf *bf)
{
  90a6e8:	6c1004        	entry	a1, 32
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90a6eb:	28304d        	l8ui	a8, a3, 77
  90a6ee:	8934      	l32i.n	a9, a3, 16
  90a6f0:	0c8b11        	slli	a11, a8, 4
  90a6f3:	08bb0c        	sub	a11, a11, a8
  90a6f6:	09bb0a        	addx4	a11, a11, a9
  90a6f9:	2bbc24        	addi	a11, a11, 36

	if (tid->flag & TID_CLEANUP_INPROGRES) {
  90a6fc:	28b036        	l8ui	a8, a11, 54
  90a6ff:	7f8705        	bbci	a8, 31, 90a708 <ath_tgt_tx_comp_normal+0x20>
		owl_tgt_tid_cleanup(sc, tid);
  90a702:	022a02        	or	a10, a2, a2
  90a705:	5bffe5        	call8	90a69c <owl_tgt_tid_cleanup>
	}

	if (bf->bf_node) {
  90a708:	8834      	l32i.n	a8, a3, 16
  90a70a:	c98f      	beqz.n	a8, 90a72d <ath_tgt_tx_comp_normal+0x45>
}

static void
ath_tx_uc_comp(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	ath_tx_status_update(sc, bf);
  90a70c:	da20      	mov.n	a10, a2
  90a70e:	033b02        	or	a11, a3, a3
  90a711:	5bfc49        	call8	909838 <ath_tx_status_update>
	ath_update_stats(sc, bf);
  90a714:	da20      	mov.n	a10, a2
  90a716:	033b02        	or	a11, a3, a3
  90a719:	5bfa33        	call8	908fe8 <ath_update_stats>
	ath_rate_tx_complete(sc, ATH_NODE_TARGET(bf->bf_node),
  90a71c:	8b34      	l32i.n	a11, a3, 16
  90a71e:	8c3e      	l32i.n	a12, a3, 56
  90a720:	da20      	mov.n	a10, a2
  90a722:	2d3c50        	addi	a13, a3, 80
  90a725:	c0e1      	movi.n	a14, 1
  90a727:	2f0a00        	movi	a15, 0
  90a72a:	5bf9c6        	call8	908e44 <ath_rate_tx_complete>

	if (bf->bf_node) {
		ath_tx_uc_comp(sc, bf);
	}

	ath_tx_freebuf(sc, bf);
  90a72d:	da20      	mov.n	a10, a2
  90a72f:	db30      	mov.n	a11, a3
  90a731:	5bfbf9        	call8	909718 <ath_tx_freebuf>
  90a734:	d10f      	retw.n
	...

0090a738 <ath_tgt_tx_comp_aggr>:
		INCR(tid->baw_tail, ATH_TID_MAX_BUFS);
	}
}

void ath_tgt_tx_comp_aggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90a738:	6c1032        	entry	a1, 0x190
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90a73b:	25304d        	l8ui	a5, a3, 77
	}
}

void ath_tgt_tx_comp_aggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
  90a73e:	8434      	l32i.n	a4, a3, 16
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90a740:	0c5811        	slli	a8, a5, 4
  90a743:	05880c        	sub	a8, a8, a5
  90a746:	04880a        	addx4	a8, a8, a4
  90a749:	258c24        	addi	a5, a8, 36
	struct ath_rc_series rcs[4];
	u_int16_t seq_st;
	u_int32_t *ba;
	int ba_index;
	int nbad = 0;
	int nframes = bf->bf_nframes;
  90a74c:	26304c        	l8ui	a6, a3, 76
	ath_tx_bufhead bf_q;
	int tx_ok = 1;
	struct ath_tx_buf *bar = NULL;
	struct ath_txq *txq;

	txq = bf->bf_txq;
  90a74f:	283220        	l32i	a8, a3, 128

	if (tid->flag & TID_CLEANUP_INPROGRES) {
  90a752:	295036        	l8ui	a9, a5, 54
	struct ath_rc_series rcs[4];
	u_int16_t seq_st;
	u_int32_t *ba;
	int ba_index;
	int nbad = 0;
	int nframes = bf->bf_nframes;
  90a755:	261654        	s32i	a6, a1, 0x150
	struct ath_tx_buf *bf_next;
	ath_tx_bufhead bf_q;
	int tx_ok = 1;
	struct ath_tx_buf *bar = NULL;
  90a758:	c060      	movi.n	a6, 0
  90a75a:	261652        	s32i	a6, a1, 0x148
	struct ath_txq *txq;

	txq = bf->bf_txq;
  90a75d:	281655        	s32i	a8, a1, 0x154

	if (tid->flag & TID_CLEANUP_INPROGRES) {
  90a760:	090640        	extui	a6, a9, 0, 1
  90a763:	6460b1        	beqz	a6, 90a818 <ath_tgt_tx_comp_aggr+0xe0>
  90a766:	8b3e      	l32i.n	a11, a3, 56
  90a768:	da10      	mov.n	a10, a1
  90a76a:	2c0a88        	movi	a12, 136
  90a76d:	5bf9d4        	call8	908ec0 <__adf_os_mem_copy>
  90a770:	2a1a10        	movi	a10, 0x110
  90a773:	a1aa      	add.n	a10, a10, a1
  90a775:	2b3c50        	addi	a11, a3, 80
  90a778:	c3c0      	movi.n	a12, 48
  90a77a:	5bf9d1        	call8	908ec0 <__adf_os_mem_copy>

	while (bf) {
		ba_index = ATH_BA_INDEX(seq_st, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
		bf_next  = bf->bf_next;

		ath_tx_status_update_aggr(sc, bf, ds, rcs, 0);
  90a77d:	281a10        	movi	a8, 0x110

	seq_st = ATH_DS_BA_SEQ(ds);
	ba     = ATH_DS_BA_BITMAP(ds);
	tx_ok  = (ATH_DS_TX_STATUS(ds) == HAL_OK);

	if (!bf->bf_isaggr) {
  90a780:	263221        	l32i	a6, a3, 132

	while (bf) {
		ba_index = ATH_BA_INDEX(seq_st, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
		bf_next  = bf->bf_next;

		ath_tx_status_update_aggr(sc, bf, ds, rcs, 0);
  90a783:	a188      	add.n	a8, a8, a1
  90a785:	d780      	mov.n	a7, a8

	seq_st = ATH_DS_BA_SEQ(ds);
	ba     = ATH_DS_BA_BITMAP(ds);
	tx_ok  = (ATH_DS_TX_STATUS(ds) == HAL_OK);

	if (!bf->bf_isaggr) {
  90a787:	7a6f2f        	bbsi	a6, 26, 90a7ba <ath_tgt_tx_comp_aggr+0x82>
		ath_update_stats(sc, bf);
  90a78a:	db30      	mov.n	a11, a3
  90a78c:	da20      	mov.n	a10, a2
  90a78e:	5bfa16        	call8	908fe8 <ath_update_stats>

		__stats(sc, tx_compunaggr);
  90a791:	24225e        	l32i	a4, a2, 0x178

		ath_tx_status_update(sc, bf);
  90a794:	db30      	mov.n	a11, a3
	tx_ok  = (ATH_DS_TX_STATUS(ds) == HAL_OK);

	if (!bf->bf_isaggr) {
		ath_update_stats(sc, bf);

		__stats(sc, tx_compunaggr);
  90a796:	b144      	addi.n	a4, a4, 1

		ath_tx_status_update(sc, bf);
  90a798:	022a02        	or	a10, a2, a2
	tx_ok  = (ATH_DS_TX_STATUS(ds) == HAL_OK);

	if (!bf->bf_isaggr) {
		ath_update_stats(sc, bf);

		__stats(sc, tx_compunaggr);
  90a79b:	24265e        	s32i	a4, a2, 0x178

		ath_tx_status_update(sc, bf);
  90a79e:	5bfc26        	call8	909838 <ath_tx_status_update>

		ath_tx_freebuf(sc, bf);
  90a7a1:	db30      	mov.n	a11, a3
  90a7a3:	da20      	mov.n	a10, a2
  90a7a5:	5bfbdc        	call8	909718 <ath_tx_freebuf>

		if (tid->flag & TID_CLEANUP_INPROGRES) {
  90a7a8:	235036        	l8ui	a3, a5, 54
  90a7ab:	7f3f02        	bbsi	a3, 31, 90a7b1 <ath_tgt_tx_comp_aggr+0x79>
  90a7ae:	6002e2        	j	90aa94 <ath_tgt_tx_comp_aggr+0x35c>
			owl_tgt_tid_cleanup(sc, tid);
  90a7b1:	da20      	mov.n	a10, a2
  90a7b3:	db50      	mov.n	a11, a5
  90a7b5:	5bffb9        	call8	90a69c <owl_tgt_tid_cleanup>
  90a7b8:	d10f      	retw.n

	while (bf) {
		ba_index = ATH_BA_INDEX(seq_st, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
		bf_next  = bf->bf_next;

		ath_tx_status_update_aggr(sc, bf, ds, rcs, 0);
  90a7ba:	db30      	mov.n	a11, a3
  90a7bc:	da20      	mov.n	a10, a2
  90a7be:	dc10      	mov.n	a12, a1
  90a7c0:	dd70      	mov.n	a13, a7
  90a7c2:	c0e0      	movi.n	a14, 0
		return;
	}

	while (bf) {
		ba_index = ATH_BA_INDEX(seq_st, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
		bf_next  = bf->bf_next;
  90a7c4:	26320b        	l32i	a6, a3, 44

		ath_tx_status_update_aggr(sc, bf, ds, rcs, 0);
  90a7c7:	5bfc3f        	call8	9098c4 <ath_tx_status_update_aggr>

		ath_tx_freebuf(sc, bf);
  90a7ca:	db30      	mov.n	a11, a3
  90a7cc:	da20      	mov.n	a10, a2
  90a7ce:	5bfbd2        	call8	909718 <ath_tx_freebuf>

		tid->incomp--;
  90a7d1:	235037        	l8ui	a3, a5, 55
  90a7d4:	b033      	addi.n	a3, a3, -1
  90a7d6:	030347        	extui	a3, a3, 0, 8
  90a7d9:	235437        	s8i	a3, a5, 55
		if (!tid->incomp) {
  90a7dc:	cd35      	bnez.n	a3, 90a7f5 <ath_tgt_tx_comp_aggr+0xbd>
			tid->flag  &= ~TID_CLEANUP_INPROGRES;
  90a7de:	265036        	l8ui	a6, a5, 54
  90a7e1:	c73e      	movi.n	a3, -2
  90a7e3:	036301        	and	a3, a6, a3
  90a7e6:	235436        	s8i	a3, a5, 54
			ath_aggr_resume_tid(sc, tid);
  90a7e9:	da20      	mov.n	a10, a2
  90a7eb:	db50      	mov.n	a11, a5
  90a7ed:	5bff98        	call8	90a650 <ath_aggr_resume_tid>
  90a7f0:	600006        	j	90a7fa <ath_tgt_tx_comp_aggr+0xc2>
  90a7f3:	0000d3        	excw
			break;
		}

		bf = bf_next;
  90a7f6:	60656f        	j	910d69 <_etext+0x5ea4>
		}

		return;
	}

	while (bf) {
  90a7f9:	bfda      	addi.n	a10, a13, 15
		}

		bf = bf_next;
	}

	ath_update_aggr_stats(sc, ds, nframes, nbad);
  90a7fb:	20db10        	l32ai	a0, a13, 64
  90a7fe:	5bfa85        	call8	909214 <ath_update_aggr_stats$isra$2>
	ath_rate_tx_complete(sc, an, ds, rcs, nframes, nbad);
  90a801:	2d1a10        	movi	a13, 0x110
  90a804:	2e1254        	l32i	a14, a1, 0x150
  90a807:	da20      	mov.n	a10, a2
  90a809:	db40      	mov.n	a11, a4
  90a80b:	dc10      	mov.n	a12, a1
  90a80d:	ad1d      	add.n	a13, a1, a13
  90a80f:	c0f0      	movi.n	a15, 0
  90a811:	5bf98c        	call8	908e44 <ath_rate_tx_complete>
  90a814:	d10f      	retw.n
  90a816:	00002c        	excw
void ath_tgt_tx_comp_aggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
	struct ath_tx_desc lastds;
	struct ath_tx_desc *ds = &lastds;
  90a819:	0a882b        	mulsh	a8, a8, a10
  90a81c:	320e0c        	excw
  90a81f:	1a085b        	l32r	a10, 8cc98c <_bss_end+0x3bf184>
  90a822:	f9          	.byte 0xf9
  90a823:	a72d      	add.n	a13, a2, a7
		ath_tx_comp_cleanup(sc, bf);
		return;
	}

	adf_os_mem_copy(ds, bf->bf_lastds, sizeof (struct ath_tx_desc));
	adf_os_mem_copy(rcs, bf->bf_rcs, sizeof(rcs));
  90a825:	3c502a        	excw
  90a828:	1a10aa        	l32r	a10, 8cead0 <_bss_end+0x3c12c8>
  90a82b:	1a0ddb        	l32r	a10, 8cdf98 <_bss_end+0x3c0790>
  90a82e:	022c0a        	addx4	a12, a2, a2
  90a831:	302d16        	excw
  90a834:	585bf9        	call8	92181c <_etext+0x16957>
  90a837:	a22a      	add.n	a10, a2, a2

	if (ds->ds_txstat.ts_flags == HAL_TX_SW_FILTERED) {
  90a839:	10ef2d        	l32r	a0, 9064f0 <tgt_reg_service+0x24>
  90a83c:	125869        	l32r	a2, 8e09e0 <_bss_end+0x3d31d8>
  90a83f:	ae02      	add.n	a2, a0, a14
  90a841:	63fffc        	j	90a841 <ath_tgt_tx_comp_aggr+0x109>
		adf_os_assert(0);
		return;
	}

	if (!bf->bf_isaggr) {
  90a844:	273221        	l32i	a7, a3, 132
  90a847:	c2b0      	movi.n	a11, 32
  90a849:	07b701        	and	a7, a11, a7
  90a84c:	657104        	bnez	a7, 90a954 <ath_tgt_tx_comp_aggr+0x21c>
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
	struct ath_tx_desc *ds  = bf->bf_lastds;

	ath_update_stats(sc, bf);
  90a84f:	da20      	mov.n	a10, a2
  90a851:	db30      	mov.n	a11, a3
static void
ath_tx_comp_unaggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
	struct ath_tx_desc *ds  = bf->bf_lastds;
  90a853:	853e      	l32i.n	a5, a3, 56
}

static void
ath_tx_comp_unaggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
  90a855:	8434      	l32i.n	a4, a3, 16
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90a857:	26304d        	l8ui	a6, a3, 77
	struct ath_tx_desc *ds  = bf->bf_lastds;

	ath_update_stats(sc, bf);
  90a85a:	2d1658        	s32i	a13, a1, 0x160
  90a85d:	5bf9e2        	call8	908fe8 <ath_update_stats>
	ath_rate_tx_complete(sc, an, ds, bf->bf_rcs, 1, 0);
  90a860:	2d1258        	l32i	a13, a1, 0x160
  90a863:	dc50      	mov.n	a12, a5
  90a865:	da20      	mov.n	a10, a2
  90a867:	db40      	mov.n	a11, a4
  90a869:	c0e1      	movi.n	a14, 1
  90a86b:	df70      	mov.n	a15, a7
  90a86d:	5bf975        	call8	908e44 <ath_rate_tx_complete>

	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
  90a870:	255066        	l8ui	a5, a5, 102
  90a873:	7f5f02        	bbsi	a5, 31, 90a879 <ath_tgt_tx_comp_aggr+0x141>
  90a876:	6000ab        	j	90a925 <ath_tgt_tx_comp_aggr+0x1ed>

static inline void
ath_tx_retry_unaggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90a879:	24304d        	l8ui	a4, a3, 77
	struct ath_txq *txq;

	txq = bf->bf_txq;

	if (bf->bf_retries >= OWLMAX_RETRIES) {
  90a87c:	c079      	movi.n	a7, 9

static inline void
ath_tx_retry_unaggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90a87e:	0c4511        	slli	a5, a4, 4
  90a881:	04540c        	sub	a4, a5, a4
  90a884:	8534      	l32i.n	a5, a3, 16
	struct ath_txq *txq;

	txq = bf->bf_txq;
  90a886:	263220        	l32i	a6, a3, 128

static inline void
ath_tx_retry_unaggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90a889:	05440a        	addx4	a4, a4, a5
	struct ath_txq *txq;

	txq = bf->bf_txq;

	if (bf->bf_retries >= OWLMAX_RETRIES) {
  90a88c:	253086        	l8ui	a5, a3, 134

static inline void
ath_tx_retry_unaggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90a88f:	244c24        	addi	a4, a4, 36
	struct ath_txq *txq;

	txq = bf->bf_txq;

	if (bf->bf_retries >= OWLMAX_RETRIES) {
  90a892:	757b27        	bgeu	a7, a5, 90a8bd <ath_tgt_tx_comp_aggr+0x185>
		__stats(sc, txunaggr_xretry);
  90a895:	252273        	l32i	a5, a2, 0x1cc
		ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90a898:	2b3123        	l16ui	a11, a3, 70
	struct ath_txq *txq;

	txq = bf->bf_txq;

	if (bf->bf_retries >= OWLMAX_RETRIES) {
		__stats(sc, txunaggr_xretry);
  90a89b:	b155      	addi.n	a5, a5, 1
		ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90a89d:	044a02        	or	a10, a4, a4
	struct ath_txq *txq;

	txq = bf->bf_txq;

	if (bf->bf_retries >= OWLMAX_RETRIES) {
		__stats(sc, txunaggr_xretry);
  90a8a0:	252673        	s32i	a5, a2, 0x1cc
		ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90a8a3:	0b4b14        	srli	a11, a11, 4
  90a8a6:	5bf9ec        	call8	909058 <ath_tx_update_baw>
		ath_tx_status_update(sc, bf);
  90a8a9:	da20      	mov.n	a10, a2
  90a8ab:	db30      	mov.n	a11, a3
  90a8ad:	5bfbe2        	call8	909838 <ath_tx_status_update>
		ath_bar_tx(sc, tid, bf);
  90a8b0:	da20      	mov.n	a10, a2
  90a8b2:	db40      	mov.n	a11, a4
  90a8b4:	dc30      	mov.n	a12, a3
  90a8b6:	5bfb32        	call8	909580 <ath_bar_tx>
  90a8b9:	d10f      	retw.n
  90a8bb:	000025        	excw
		return;
	}

	__stats(sc, txunaggr_compretries);
  90a8be:	226db1        	addmi	a2, a6, 0xffffb100
  90a8c1:	552526        	call4	953d5c <_etext+0x48e97>
  90a8c4:	6d853e        	excw
	if (!bf->bf_lastds->ds_link) {
  90a8c7:	295000        	l8ui	a9, a5, 0
  90a8ca:	285001        	l8ui	a8, a5, 1
  90a8cd:	275002        	l8ui	a7, a5, 2
  90a8d0:	089910        	slli	a9, a9, 24
  90a8d3:	008811        	slli	a8, a8, 16
  90a8d6:	098802        	or	a8, a8, a9
  90a8d9:	087711        	slli	a7, a7, 8
  90a8dc:	255003        	l8ui	a5, a5, 3
  90a8df:	087702        	or	a7, a7, a8
  90a8e2:	075502        	or	a5, a5, a7
  90a8e5:	cd54      	bnez.n	a5, 90a8fd <ath_tgt_tx_comp_aggr+0x1c5>
		__stats(sc, txunaggr_errlast);
  90a8e7:	252272        	l32i	a5, a2, 0x1c8
		bf = ath_buf_toggle(sc, bf, 1);
  90a8ea:	db30      	mov.n	a11, a3
		return;
	}

	__stats(sc, txunaggr_compretries);
	if (!bf->bf_lastds->ds_link) {
		__stats(sc, txunaggr_errlast);
  90a8ec:	b155      	addi.n	a5, a5, 1
  90a8ee:	252672        	s32i	a5, a2, 0x1c8
		bf = ath_buf_toggle(sc, bf, 1);
  90a8f1:	022a02        	or	a10, a2, a2
  90a8f4:	2c0a01        	movi	a12, 1
  90a8f7:	5bfaee        	call8	9094b0 <ath_buf_toggle>
  90a8fa:	0aa302        	or	a3, a10, a10
	}

	ath_tx_set_retry(sc, bf);
  90a8fd:	da20      	mov.n	a10, a2
  90a8ff:	db30      	mov.n	a11, a3
  90a901:	5bfbab        	call8	9097b0 <ath_tx_set_retry>
	asf_tailq_insert_head(&tid->buf_q, bf, bf_list);
  90a904:	824b      	l32i.n	a2, a4, 44
  90a906:	253c24        	addi	a5, a3, 36
  90a909:	9239      	s32i.n	a2, a3, 36
  90a90b:	c823      	beqz.n	a2, 90a912 <ath_tgt_tx_comp_aggr+0x1da>
  90a90d:	952a      	s32i.n	a5, a2, 40
  90a90f:	600001        	j	90a914 <ath_tgt_tx_comp_aggr+0x1dc>
  90a912:	954c      	s32i.n	a5, a4, 48
  90a914:	934b      	s32i.n	a3, a4, 44
  90a916:	224c2c        	addi	a2, a4, 44
  90a919:	923a      	s32i.n	a2, a3, 40
	ath_tgt_tx_enqueue(txq, tid);
  90a91b:	da60      	mov.n	a10, a6
  90a91d:	db40      	mov.n	a11, a4
  90a91f:	60016e        	j	90aa91 <ath_tgt_tx_comp_aggr+0x359>
  90a922:	000000        	ill

	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
		ath_tx_retry_unaggr(sc, bf);
		return;
	}
	__stats(sc, tx_compunaggr);
  90a925:	25225e        	l32i	a5, a2, 0x178

	ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90a928:	2b3123        	l16ui	a11, a3, 70

	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
		ath_tx_retry_unaggr(sc, bf);
		return;
	}
	__stats(sc, tx_compunaggr);
  90a92b:	b155      	addi.n	a5, a5, 1
  90a92d:	25265e        	s32i	a5, a2, 0x178

static void
ath_tx_comp_unaggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90a930:	0c6511        	slli	a5, a6, 4
  90a933:	06560c        	sub	a6, a5, a6
  90a936:	046a0a        	addx4	a10, a6, a4
		ath_tx_retry_unaggr(sc, bf);
		return;
	}
	__stats(sc, tx_compunaggr);

	ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90a939:	2aac24        	addi	a10, a10, 36
  90a93c:	0b4b14        	srli	a11, a11, 4
  90a93f:	5bf9c6        	call8	909058 <ath_tx_update_baw>
	ath_tx_status_update(sc, bf);
  90a942:	da20      	mov.n	a10, a2
  90a944:	db30      	mov.n	a11, a3
  90a946:	5bfbbc        	call8	909838 <ath_tx_status_update>
	ath_tx_freebuf(sc, bf);
  90a949:	da20      	mov.n	a10, a2
  90a94b:	db30      	mov.n	a11, a3
  90a94d:	5bfb72        	call8	909718 <ath_tx_freebuf>
  90a950:	d10f      	retw.n
  90a952:	000027        	excw
	if (!bf->bf_isaggr) {
		ath_tx_comp_unaggr(sc, bf);
		return;
	}

	__stats(sc, tx_compaggr);
  90a955:	225f26        	s32ri	a2, a5, 152

	asf_tailq_init(&bf_q);
  90a958:	1650b1        	l32r	a6, 8dec1c <_bss_end+0x3d1414>
	if (!bf->bf_isaggr) {
		ath_tx_comp_unaggr(sc, bf);
		return;
	}

	__stats(sc, tx_compaggr);
  90a95b:	77261a        	bbci	a2, 7, 90a979 <ath_tgt_tx_comp_aggr+0x241>

	asf_tailq_init(&bf_q);
  90a95e:	402726        	excw
	if (!bf->bf_isaggr) {
		ath_tx_comp_unaggr(sc, bf);
		return;
	}

	__stats(sc, tx_compaggr);
  90a961:	5fa617        	call12	8f41c0 <memset+0xf024>

	asf_tailq_init(&bf_q);
  90a964:	271651        	s32i	a7, a1, 0x144

	seq_st =  ATH_DS_BA_SEQ(ds);
  90a967:	281176        	l16ui	a8, a1, 236
	ba     =  ATH_DS_BA_BITMAP(ds);
	tx_ok  =  (ATH_DS_TX_STATUS(ds) == HAL_OK);
  90a96a:	2710ee        	l8ui	a7, a1, 238

	__stats(sc, tx_compaggr);

	asf_tailq_init(&bf_q);

	seq_st =  ATH_DS_BA_SEQ(ds);
  90a96d:	281656        	s32i	a8, a1, 0x158
	ba     =  ATH_DS_BA_BITMAP(ds);
	tx_ok  =  (ATH_DS_TX_STATUS(ds) == HAL_OK);

	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
  90a970:	070f40        	extui	a15, a7, 0, 1
  90a973:	c8f1      	beqz.n	a15, 90a978 <ath_tgt_tx_comp_aggr+0x240>
  90a975:	60001f        	j	90a998 <ath_tgt_tx_comp_aggr+0x260>

	asf_tailq_init(&bf_q);

	seq_st =  ATH_DS_BA_SEQ(ds);
	ba     =  ATH_DS_BA_BITMAP(ds);
	tx_ok  =  (ATH_DS_TX_STATUS(ds) == HAL_OK);
  90a978:	c091      	movi.n	a9, 1
  90a97a:	07f939        	movnez	a9, a15, a7
	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
		ath_tx_comp_aggr_error(sc, bf, tid);
		return;
	}

	if (tx_ok && !ATH_DS_TX_BA(ds)) {
  90a97d:	ca95      	beqz.n	a9, 90a9a6 <ath_tgt_tx_comp_aggr+0x26e>
  90a97f:	d6f0      	mov.n	a6, a15
  90a981:	7faf23        	bbsi	a10, 31, 90a9a8 <ath_tgt_tx_comp_aggr+0x270>
		__stats(sc, txaggr_babug);
  90a984:	242269        	l32i	a4, a2, 0x1a4
		adf_os_print("BA Bug?\n");
  90a987:	1a72cd        	l32r	a10, 8e74bc <memset+0x2320>
		ath_tx_comp_aggr_error(sc, bf, tid);
		return;
	}

	if (tx_ok && !ATH_DS_TX_BA(ds)) {
		__stats(sc, txaggr_babug);
  90a98a:	b144      	addi.n	a4, a4, 1
  90a98c:	242669        	s32i	a4, a2, 0x1a4
		adf_os_print("BA Bug?\n");
  90a98f:	147184        	l32r	a4, 8e6fa0 <memset+0x1e04>
  90a992:	244212        	l32i	a4, a4, 72
  90a995:	0b4000        	callx8	a4
		ath_tx_comp_aggr_error(sc, bf, tid);
  90a998:	da20      	mov.n	a10, a2
  90a99a:	db30      	mov.n	a11, a3
  90a99c:	dc50      	mov.n	a12, a5
  90a99e:	5bfc1d        	call8	909a14 <ath_tx_comp_aggr_error>
  90a9a1:	d10f      	retw.n
  90a9a3:	000000        	ill
	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
		ath_tx_comp_aggr_error(sc, bf, tid);
		return;
	}

	if (tx_ok && !ATH_DS_TX_BA(ds)) {
  90a9a6:	d690      	mov.n	a6, a9

	while (bf) {
		ba_index = ATH_BA_INDEX(seq_st, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
		bf_next  = bf->bf_next;

		if (tx_ok && ATH_BA_ISSET(ba, ba_index)) {
  90a9a8:	270afc        	movi	a7, 252
		ath_tx_comp_aggr_error(sc, bf, tid);
		return;
	}

	while (bf) {
		ba_index = ATH_BA_INDEX(seq_st, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90a9ab:	2b3123        	l16ui	a11, a3, 70
  90a9ae:	281256        	l32i	a8, a1, 0x158
  90a9b1:	0b4b14        	srli	a11, a11, 4
  90a9b4:	08ba0c        	sub	a10, a11, a8
		bf_next  = bf->bf_next;
  90a9b7:	883b      	l32i.n	a8, a3, 44
		ath_tx_comp_aggr_error(sc, bf, tid);
		return;
	}

	while (bf) {
		ba_index = ATH_BA_INDEX(seq_st, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90a9b9:	0a0c4b        	extui	a12, a10, 0, 12
		bf_next  = bf->bf_next;
  90a9bc:	281657        	s32i	a8, a1, 0x15c

		if (tx_ok && ATH_BA_ISSET(ba, ba_index)) {
  90a9bf:	c38f      	movi.n	a8, 63
  90a9c1:	7c824c        	blt	a8, a12, 90aa11 <ath_tgt_tx_comp_aggr+0x2d9>
  90a9c4:	649049        	beqz	a9, 90aa11 <ath_tgt_tx_comp_aggr+0x2d9>
  90a9c7:	0c5c12        	srai	a12, a12, 5
  90a9ca:	01cc0a        	addx4	a12, a12, a1
  90a9cd:	a7cc      	add.n	a12, a12, a7
  90a9cf:	c0e1      	movi.n	a14, 1
  90a9d1:	8cc0      	l32i.n	a12, a12, 0
  90a9d3:	00a104        	ssl	a10
  90a9d6:	00ea1a        	sll	a10, a14
  90a9d9:	7ca034        	bnone	a10, a12, 90aa11 <ath_tgt_tx_comp_aggr+0x2d9>
			__stats(sc, txaggr_compgood);
  90a9dc:	2a2262        	l32i	a10, a2, 0x188
  90a9df:	aeaa      	add.n	a10, a10, a14
  90a9e1:	2a2662        	s32i	a10, a2, 0x188
			ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90a9e4:	055a02        	or	a10, a5, a5
  90a9e7:	291659        	s32i	a9, a1, 0x164
  90a9ea:	2e1658        	s32i	a14, a1, 0x160
  90a9ed:	5bf99a        	call8	909058 <ath_tx_update_baw>
			ath_tx_status_update_aggr(sc, bf, ds, rcs, 1);
  90a9f0:	2e1258        	l32i	a14, a1, 0x160
  90a9f3:	2c0a88        	movi	a12, 136
  90a9f6:	2d1a10        	movi	a13, 0x110
  90a9f9:	da20      	mov.n	a10, a2
  90a9fb:	db30      	mov.n	a11, a3
  90a9fd:	a1cc      	add.n	a12, a12, a1
  90a9ff:	0d1d08        	add	a13, a1, a13
  90aa02:	5bfbb0        	call8	9098c4 <ath_tx_status_update_aggr>
			ath_tx_freebuf(sc, bf);
  90aa05:	da20      	mov.n	a10, a2
  90aa07:	db30      	mov.n	a11, a3
  90aa09:	5bfb43        	call8	909718 <ath_tx_freebuf>
  90aa0c:	600019        	j	90aa29 <ath_tgt_tx_comp_aggr+0x2f1>
  90aa0f:	00002c        	excw
		} else {
			ath_tx_retry_subframe(sc, bf, &bf_q, &bar);
  90aa12:	1a402d        	l32r	a10, 8daac8 <_bss_end+0x3cd2c0>
  90aa15:	1a48da        	l32r	a10, 8dcd80 <_bss_end+0x3cf578>
  90aa18:	20db30        	l32ai	a0, a13, 192
  90aa1b:	ac1c      	add.n	a12, a1, a12
  90aa1d:	0d1d08        	add	a13, a1, a13
  90aa20:	291659        	s32i	a9, a1, 0x164
			nbad ++;
  90aa23:	266c01        	addi	a6, a6, 1
			__stats(sc, txaggr_compgood);
			ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
			ath_tx_status_update_aggr(sc, bf, ds, rcs, 1);
			ath_tx_freebuf(sc, bf);
		} else {
			ath_tx_retry_subframe(sc, bf, &bf_q, &bar);
  90aa26:	5bfbc3        	call8	909934 <ath_tx_retry_subframe>
  90aa29:	231257        	l32i	a3, a1, 0x15c
			nbad ++;
  90aa2c:	291259        	l32i	a9, a1, 0x164
		adf_os_print("BA Bug?\n");
		ath_tx_comp_aggr_error(sc, bf, tid);
		return;
	}

	while (bf) {
  90aa2f:	653f78        	bnez	a3, 90a9ab <ath_tgt_tx_comp_aggr+0x273>
			nbad ++;
		}
		bf = bf_next;
	}

	ath_update_aggr_stats(sc, ds, nframes, nbad);
  90aa32:	2b0a88        	movi	a11, 136
  90aa35:	da20      	mov.n	a10, a2
  90aa37:	a1bb      	add.n	a11, a11, a1
  90aa39:	5bf9f6        	call8	909214 <ath_update_aggr_stats$isra$2>
	ath_rate_tx_complete(sc, an, ds, rcs, nframes, nbad);
  90aa3c:	2c0a88        	movi	a12, 136
  90aa3f:	2d1a10        	movi	a13, 0x110
  90aa42:	2e1254        	l32i	a14, a1, 0x150
  90aa45:	a1cc      	add.n	a12, a12, a1
  90aa47:	da20      	mov.n	a10, a2
  90aa49:	db40      	mov.n	a11, a4
  90aa4b:	0d1d08        	add	a13, a1, a13
  90aa4e:	066f02        	or	a15, a6, a6
  90aa51:	5bf8fc        	call8	908e44 <ath_rate_tx_complete>

	if (bar) {
  90aa54:	2c1252        	l32i	a12, a1, 0x148
  90aa57:	c8c5      	beqz.n	a12, 90aa60 <ath_tgt_tx_comp_aggr+0x328>
		ath_bar_tx(sc, tid, bar);
  90aa59:	da20      	mov.n	a10, a2
  90aa5b:	db50      	mov.n	a11, a5
  90aa5d:	5bfac8        	call8	909580 <ath_bar_tx>
	}

	if (!asf_tailq_empty(&bf_q)) {
  90aa60:	231250        	l32i	a3, a1, 0x140
  90aa63:	ca3d      	beqz.n	a3, 90aa94 <ath_tgt_tx_comp_aggr+0x35c>
		__stats(sc, txaggr_prepends);
  90aa65:	232264        	l32i	a3, a2, 0x190
  90aa68:	b133      	addi.n	a3, a3, 1
  90aa6a:	232664        	s32i	a3, a2, 0x190
		TAILQ_INSERTQ_HEAD(&tid->buf_q, &bf_q, bf_list);
  90aa6d:	835b      	l32i.n	a3, a5, 44
  90aa6f:	221251        	l32i	a2, a1, 0x144
  90aa72:	c83a      	beqz.n	a3, 90aa80 <ath_tgt_tx_comp_aggr+0x348>
  90aa74:	9320      	s32i.n	a3, a2, 0
  90aa76:	825b      	l32i.n	a2, a5, 44
  90aa78:	231251        	l32i	a3, a1, 0x144
  90aa7b:	932a      	s32i.n	a3, a2, 40
  90aa7d:	600001        	j	90aa82 <ath_tgt_tx_comp_aggr+0x34a>
  90aa80:	925c      	s32i.n	a2, a5, 48
  90aa82:	221250        	l32i	a2, a1, 0x140
  90aa85:	235c2c        	addi	a3, a5, 44
  90aa88:	925b      	s32i.n	a2, a5, 44
		ath_tgt_tx_enqueue(txq, tid);
  90aa8a:	2a1255        	l32i	a10, a1, 0x154
		ath_bar_tx(sc, tid, bar);
	}

	if (!asf_tailq_empty(&bf_q)) {
		__stats(sc, txaggr_prepends);
		TAILQ_INSERTQ_HEAD(&tid->buf_q, &bf_q, bf_list);
  90aa8d:	932a      	s32i.n	a3, a2, 40
		ath_tgt_tx_enqueue(txq, tid);
  90aa8f:	db50      	mov.n	a11, a5
  90aa91:	5bf9d7        	call8	9091f0 <ath_tgt_tx_enqueue>
  90aa94:	d10f      	retw.n
	...

0090aa98 <owltgt_tx_processq>:
	ath_tx_status_send(sc);
}

void owltgt_tx_processq(struct ath_softc_tgt *sc, struct ath_txq *txq,
			owl_txq_state_t txqstate)
{
  90aa98:	6c1006        	entry	a1, 48
	struct ath_tx_buf *bf;
	struct ath_tx_desc *ds;
	struct ath_hal *ah = sc->sc_ah;
  90aa9b:	252d05        	addmi	a5, a2, 0x500
  90aa9e:	865b      	l32i.n	a6, a5, 44
		bf = asf_tailq_first(&txq->axq_q);

		ds = bf->bf_lastds;
		status = ah->ah_procTxDesc(ah, ds);

		if (status == HAL_EINPROGRESS) {
  90aaa0:	c07f      	movi.n	a7, 15
	struct ath_tx_desc *ds;
	struct ath_hal *ah = sc->sc_ah;
	HAL_STATUS status;

	for (;;) {
		if (asf_tailq_empty(&txq->axq_q)) {
  90aaa2:	8532      	l32i.n	a5, a3, 8
  90aaa4:	cc54      	bnez.n	a5, 90aaac <owltgt_tx_processq+0x14>
			txq->axq_link = NULL;
  90aaa6:	9531      	s32i.n	a5, a3, 4
			txq->axq_linkbuf = NULL;
  90aaa8:	9535      	s32i.n	a5, a3, 20
			break;
  90aaaa:	d10f      	retw.n
		}

		bf = asf_tailq_first(&txq->axq_q);

		ds = bf->bf_lastds;
  90aaac:	885e      	l32i.n	a8, a5, 56
		status = ah->ah_procTxDesc(ah, ds);
  90aaae:	29621a        	l32i	a9, a6, 104
  90aab1:	db80      	mov.n	a11, a8
  90aab3:	9810      	s32i.n	a8, a1, 0
  90aab5:	da60      	mov.n	a10, a6
  90aab7:	0b9000        	callx8	a9

		if (status == HAL_EINPROGRESS) {
  90aaba:	8810      	l32i.n	a8, a1, 0
  90aabc:	77a91e        	bne	a10, a7, 90aade <owltgt_tx_processq+0x46>
			if (txqstate == OWL_TXQ_ACTIVE)
  90aabf:	64406d        	beqz	a4, 90ab30 <owltgt_tx_processq+0x98>
				break;
			else if (txqstate == OWL_TXQ_STOPPED) {
  90aac2:	694112        	bnei	a4, 1, 90aad8 <owltgt_tx_processq+0x40>
				__stats(sc, tx_stopfiltered);
  90aac5:	292275        	l32i	a9, a2, 0x1d4
  90aac8:	b199      	addi.n	a9, a9, 1
  90aaca:	292675        	s32i	a9, a2, 0x1d4
				ds->ds_txstat.ts_flags  = 0;
  90aacd:	c090      	movi.n	a9, 0
  90aacf:	298467        	s8i	a9, a8, 103
				ds->ds_txstat.ts_status = HAL_OK;
  90aad2:	298466        	s8i	a9, a8, 102
  90aad5:	600005        	j	90aade <owltgt_tx_processq+0x46>
			} else {
				ds->ds_txstat.ts_flags  = HAL_TX_SW_FILTERED;
  90aad8:	29fa80        	movi	a9, -128
  90aadb:	298467        	s8i	a9, a8, 103
			}
		}

		ATH_TXQ_REMOVE_HEAD(txq, bf, bf_list);
  90aade:	8859      	l32i.n	a8, a5, 36
  90aae0:	895a      	l32i.n	a9, a5, 40
  90aae2:	c883      	beqz.n	a8, 90aae9 <owltgt_tx_processq+0x51>
  90aae4:	998a      	s32i.n	a9, a8, 40
  90aae6:	600001        	j	90aaeb <owltgt_tx_processq+0x53>
  90aae9:	9933      	s32i.n	a9, a3, 12
  90aaeb:	895a      	l32i.n	a9, a5, 40
  90aaed:	9890      	s32i.n	a8, a9, 0
  90aaef:	8834      	l32i.n	a8, a3, 16
  90aaf1:	b088      	addi.n	a8, a8, -1
  90aaf3:	9834      	s32i.n	a8, a3, 16
		if ((asf_tailq_empty(&txq->axq_q))) {
  90aaf5:	8832      	l32i.n	a8, a3, 8
  90aaf7:	cc8a      	bnez.n	a8, 90ab05 <owltgt_tx_processq+0x6d>
			__stats(sc, tx_qnull);
  90aaf9:	29225c        	l32i	a9, a2, 0x170
  90aafc:	b199      	addi.n	a9, a9, 1
  90aafe:	29265c        	s32i	a9, a2, 0x170
			txq->axq_link = NULL;
  90ab01:	9831      	s32i.n	a8, a3, 4
			txq->axq_linkbuf = NULL;
  90ab03:	9835      	s32i.n	a8, a3, 20
		}

		if (bf->bf_comp) {
  90ab05:	885f      	l32i.n	a8, a5, 60
			bf->bf_comp(sc, bf);
  90ab07:	da20      	mov.n	a10, a2
  90ab09:	db50      	mov.n	a11, a5
			__stats(sc, tx_qnull);
			txq->axq_link = NULL;
			txq->axq_linkbuf = NULL;
		}

		if (bf->bf_comp) {
  90ab0b:	c886      	beqz.n	a8, 90ab15 <owltgt_tx_processq+0x7d>
			bf->bf_comp(sc, bf);
  90ab0d:	0b8000        	callx8	a8
  90ab10:	60000c        	j	90ab20 <owltgt_tx_processq+0x88>
  90ab13:	00005b        	extui	a0, a0, 16, 12
		} else {
			ath_tx_status_update(sc, bf);
  90ab16:	fb          	.byte 0xfb
  90ab17:	48022a        	excw
			ath_buf_comp(sc, bf);
  90ab1a:	02db50        	extui	a11, a2, 29, 1
  90ab1d:	5bfaef        	call8	9096dc <ath_buf_comp>
		}

		if (txqstate == OWL_TXQ_ACTIVE) {
  90ab20:	654f7e        	bnez	a4, 90aaa2 <owltgt_tx_processq+0xa>
			ath_tgt_txq_schedule(sc, txq);
  90ab23:	022a02        	or	a10, a2, a2
  90ab26:	033b02        	or	a11, a3, a3
  90ab29:	5bfe4c        	call8	90a45c <ath_tgt_txq_schedule>
  90ab2c:	63ff72        	j	90aaa2 <owltgt_tx_processq+0xa>
  90ab2f:	00d10f        	subx8	a1, a13, a0
	...

0090ab34 <owl_tgt_tx_tasklet>:
	owltgt_tx_processq(sc, txq, OWL_TXQ_ACTIVE);
	ah->ah_setInterrupts(ah, sc->sc_imask);
}

void owl_tgt_tx_tasklet(TQUEUE_ARG data)
{
  90ab34:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)data;
	a_int32_t i;
	struct ath_txq *txq;

	ath_tx_status_clear(sc);
  90ab37:	da20      	mov.n	a10, a2
  90ab39:	5bfb3b        	call8	909828 <ath_tx_status_clear>

	for (i = 0; i < (HAL_NUM_TX_QUEUES - 6); i++) {
  90ab3c:	c030      	movi.n	a3, 0
		txq = ATH_TXQ(sc, i);

		if (ATH_TXQ_SETUP(sc, i)) {
			if (txq == sc->sc_cabq)
  90ab3e:	262d05        	addmi	a6, a2, 0x500
	ath_tx_status_clear(sc);

	for (i = 0; i < (HAL_NUM_TX_QUEUES - 6); i++) {
		txq = ATH_TXQ(sc, i);

		if (ATH_TXQ_SETUP(sc, i)) {
  90ab41:	242d03        	addmi	a4, a2, 0x300
  90ab44:	2440c8        	l8ui	a4, a4, 200
  90ab47:	003004        	ssr	a3
  90ab4a:	04041b        	sra	a4, a4
  90ab4d:	7f4745        	bbci	a4, 31, 90ab96 <owl_tgt_tx_tasklet+0x62>
	struct ath_txq *txq;

	ath_tx_status_clear(sc);

	for (i = 0; i < (HAL_NUM_TX_QUEUES - 6); i++) {
		txq = ATH_TXQ(sc, i);
  90ab50:	253c1e        	addi	a5, a3, 30
  90ab53:	0b5511        	slli	a5, a5, 5
  90ab56:	a525      	add.n	a5, a2, a5

		if (ATH_TXQ_SETUP(sc, i)) {
			if (txq == sc->sc_cabq)
  90ab58:	846c      	l32i.n	a4, a6, 48
	struct ath_txq *txq;

	ath_tx_status_clear(sc);

	for (i = 0; i < (HAL_NUM_TX_QUEUES - 6); i++) {
		txq = ATH_TXQ(sc, i);
  90ab5a:	bc55      	addi.n	a5, a5, 12

		if (ATH_TXQ_SETUP(sc, i)) {
			if (txq == sc->sc_cabq)
  90ab5c:	74592d        	bne	a5, a4, 90ab8d <owl_tgt_tx_tasklet+0x59>
	}
}

static void owltgt_tx_process_cabq(struct ath_softc_tgt *sc, struct ath_txq *txq)
{
	struct ath_hal *ah = sc->sc_ah;
  90ab5f:	846b      	l32i.n	a4, a6, 44
	ah->ah_setInterrupts(ah, sc->sc_imask & ~HAL_INT_SWBA);
  90ab61:	1972ab        	l32r	a9, 8e7610 <memset+0x2474>
  90ab64:	2b22c4        	l32i	a11, a2, 0x310
  90ab67:	284228        	l32i	a8, a4, 160
  90ab6a:	09bb01        	and	a11, a11, a9
  90ab6d:	da40      	mov.n	a10, a4
  90ab6f:	0b8000        	callx8	a8
	owltgt_tx_processq(sc, txq, OWL_TXQ_ACTIVE);
  90ab72:	da20      	mov.n	a10, a2
  90ab74:	db50      	mov.n	a11, a5
  90ab76:	2c0a00        	movi	a12, 0
  90ab79:	5bffc7        	call8	90aa98 <owltgt_tx_processq>
	ah->ah_setInterrupts(ah, sc->sc_imask);
  90ab7c:	2b22c4        	l32i	a11, a2, 0x310
  90ab7f:	254228        	l32i	a5, a4, 160
  90ab82:	044a02        	or	a10, a4, a4
  90ab85:	0b5000        	callx8	a5
  90ab88:	60000a        	j	90ab96 <owl_tgt_tx_tasklet+0x62>
  90ab8b:	0000da        	excw

		if (ATH_TXQ_SETUP(sc, i)) {
			if (txq == sc->sc_cabq)
				owltgt_tx_process_cabq(sc, txq);
			else
				owltgt_tx_processq(sc, txq, OWL_TXQ_ACTIVE);
  90ab8e:	20db50        	l32ai	a0, a13, 0x140
  90ab91:	c0c0      	movi.n	a12, 0
  90ab93:	5bffc1        	call8	90aa98 <owltgt_tx_processq>
	a_int32_t i;
	struct ath_txq *txq;

	ath_tx_status_clear(sc);

	for (i = 0; i < (HAL_NUM_TX_QUEUES - 6); i++) {
  90ab96:	b133      	addi.n	a3, a3, 1
  90ab98:	6934a5        	bnei	a3, 4, 90ab41 <owl_tgt_tx_tasklet+0xd>
			else
				owltgt_tx_processq(sc, txq, OWL_TXQ_ACTIVE);
		}
	}

	ath_tx_status_send(sc);
  90ab9b:	da20      	mov.n	a10, a2
  90ab9d:	5bfbc9        	call8	909ac4 <ath_tx_status_send>
  90aba0:	d10f      	retw.n
	...

0090aba4 <ath_tgt_handle_aggr>:
	} while (!asf_tailq_empty(&txq->axq_tidq) && !bdone);
}

void
ath_tgt_handle_aggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90aba4:	6c1004        	entry	a1, 32
	ath_atx_tid_t *tid;
	struct ath_node_target *an;
	struct ath_txq *txq = bf->bf_txq;
	a_bool_t queue_frame, within_baw;

	an = (struct ath_node_target *)bf->bf_node;
  90aba7:	8834      	l32i.n	a8, a3, 16
void
ath_tgt_handle_aggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	ath_atx_tid_t *tid;
	struct ath_node_target *an;
	struct ath_txq *txq = bf->bf_txq;
  90aba9:	2a3220        	l32i	a10, a3, 128
	a_bool_t queue_frame, within_baw;

	an = (struct ath_node_target *)bf->bf_node;
	adf_os_assert(an);
  90abac:	cc81      	bnez.n	a8, 90abb1 <ath_tgt_handle_aggr+0xd>
  90abae:	63fffc        	j	90abae <ath_tgt_handle_aggr+0xa>

	tid = &an->tid[bf->bf_tidno];
  90abb1:	29304d        	l8ui	a9, a3, 77
	within_baw = BAW_WITHIN(tid->seq_start, tid->baw_size,
				SEQNO_FROM_BF_SEQNO(bf->bf_seqno));

	queue_frame = ( (txq->axq_depth >= ATH_AGGR_MIN_QDEPTH) ||
			(!asf_tailq_empty(&tid->buf_q)) ||
			(tid->paused) || (!within_baw) );
  90abb4:	8da4      	l32i.n	a13, a10, 16
	a_bool_t queue_frame, within_baw;

	an = (struct ath_node_target *)bf->bf_node;
	adf_os_assert(an);

	tid = &an->tid[bf->bf_tidno];
  90abb6:	0c9b11        	slli	a11, a9, 4
  90abb9:	09bb0c        	sub	a11, a11, a9
  90abbc:	08bb0a        	addx4	a11, a11, a8
	adf_os_assert(tid);

	bf->bf_comp = ath_tgt_tx_comp_aggr;
  90abbf:	1872cb        	l32r	a8, 8e76ec <memset+0x2550>
	a_bool_t queue_frame, within_baw;

	an = (struct ath_node_target *)bf->bf_node;
	adf_os_assert(an);

	tid = &an->tid[bf->bf_tidno];
  90abc2:	2bbc24        	addi	a11, a11, 36
	adf_os_assert(tid);

	bf->bf_comp = ath_tgt_tx_comp_aggr;
  90abc5:	983f      	s32i.n	a8, a3, 60

	within_baw = BAW_WITHIN(tid->seq_start, tid->baw_size,
  90abc7:	293123        	l16ui	a9, a3, 70
  90abca:	2cb102        	l16ui	a12, a11, 4
  90abcd:	28b104        	l16ui	a8, a11, 8
				SEQNO_FROM_BF_SEQNO(bf->bf_seqno));

	queue_frame = ( (txq->axq_depth >= ATH_AGGR_MIN_QDEPTH) ||
			(!asf_tailq_empty(&tid->buf_q)) ||
			(tid->paused) || (!within_baw) );
  90abd0:	cdd4      	bnez.n	a13, 90abe8 <ath_tgt_handle_aggr+0x44>
	bf->bf_comp = ath_tgt_tx_comp_aggr;

	within_baw = BAW_WITHIN(tid->seq_start, tid->baw_size,
				SEQNO_FROM_BF_SEQNO(bf->bf_seqno));

	queue_frame = ( (txq->axq_depth >= ATH_AGGR_MIN_QDEPTH) ||
  90abd2:	8dbb      	l32i.n	a13, a11, 44
  90abd4:	65d010        	bnez	a13, 90abe8 <ath_tgt_handle_aggr+0x44>
			(!asf_tailq_empty(&tid->buf_q)) ||
  90abd7:	2db034        	l8ui	a13, a11, 52
  90abda:	ccda      	bnez.n	a13, 90abe8 <ath_tgt_handle_aggr+0x44>
	tid = &an->tid[bf->bf_tidno];
	adf_os_assert(tid);

	bf->bf_comp = ath_tgt_tx_comp_aggr;

	within_baw = BAW_WITHIN(tid->seq_start, tid->baw_size,
  90abdc:	094914        	srli	a9, a9, 4
  90abdf:	0c990c        	sub	a9, a9, a12
  90abe2:	09094b        	extui	a9, a9, 0, 12
				SEQNO_FROM_BF_SEQNO(bf->bf_seqno));

	queue_frame = ( (txq->axq_depth >= ATH_AGGR_MIN_QDEPTH) ||
			(!asf_tailq_empty(&tid->buf_q)) ||
			(tid->paused) || (!within_baw) );
  90abe5:	789215        	blt	a9, a8, 90abfe <ath_tgt_handle_aggr+0x5a>

	if (queue_frame) {
		asf_tailq_insert_tail(&tid->buf_q, bf, bf_list);
  90abe8:	c020      	movi.n	a2, 0
  90abea:	9239      	s32i.n	a2, a3, 36
  90abec:	82bc      	l32i.n	a2, a11, 48
  90abee:	923a      	s32i.n	a2, a3, 40
  90abf0:	9320      	s32i.n	a3, a2, 0
  90abf2:	233c24        	addi	a3, a3, 36
  90abf5:	93bc      	s32i.n	a3, a11, 48
		ath_tgt_tx_enqueue(txq, tid);
  90abf7:	5bf97e        	call8	9091f0 <ath_tgt_tx_enqueue>
  90abfa:	d10f      	retw.n
  90abfc:	0000da        	excw
	} else {
		ath_tx_addto_baw(tid, bf);
  90abff:	b0db      	addi.n	a11, a13, -1
  90ac01:	305bfd        	excw
  90ac04:	792822        	bany	a2, a9, 90ac2a <ath_tgt_tx_cleanup+0x12>
		__stats(sc, txaggr_nframes);
  90ac07:	5dda20        	call12	981488 <_etext+0x765c3>
  90ac0a:	b188      	addi.n	a8, a8, 1
  90ac0c:	28265d        	s32i	a8, a2, 0x174
		ath_tgt_tx_send_normal(sc, bf);
  90ac0f:	db30      	mov.n	a11, a3
  90ac11:	5bfc5b        	call8	909d80 <ath_tgt_tx_send_normal>
  90ac14:	d10f      	retw.n
	...

0090ac18 <ath_tgt_tx_cleanup>:
	wh->i_fc[1] |= IEEE80211_FC1_RETRY;
}

void ath_tgt_tx_cleanup(struct ath_softc_tgt *sc, struct ath_node_target *an,
			ath_atx_tid_t *tid, a_uint8_t discard_all)
{
  90ac18:	6c1004        	entry	a1, 32
  90ac1b:	050547        	extui	a5, a5, 0, 8
	struct ath_tx_buf *bf_next;
	struct ath_txq *txq;

	txq = TID_TO_ACTXQ(tid->tidno);

	bf = asf_tailq_first(&tid->buf_q);
  90ac1e:	834b      	l32i.n	a3, a4, 44

	while (bf) {
		if (discard_all || bf->bf_isretried) {
			bf_next = asf_tailq_next(bf, bf_list);
			TAILQ_DEQ(&tid->buf_q, bf, bf_list);
			if (bf->bf_isretried)
  90ac20:	c160      	movi.n	a6, 16

	txq = TID_TO_ACTXQ(tid->tidno);

	bf = asf_tailq_first(&tid->buf_q);

	while (bf) {
  90ac22:	600042        	j	90ac68 <ath_tgt_tx_cleanup+0x50>
		if (discard_all || bf->bf_isretried) {
  90ac25:	cc54      	bnez.n	a5, 90ac2d <ath_tgt_tx_cleanup+0x15>
  90ac27:	273221        	l32i	a7, a3, 132
  90ac2a:	776033        	bnone	a6, a7, 90ac61 <ath_tgt_tx_cleanup+0x49>
			bf_next = asf_tailq_next(bf, bf_list);
  90ac2d:	8739      	l32i.n	a7, a3, 36
			TAILQ_DEQ(&tid->buf_q, bf, bf_list);
  90ac2f:	834b      	l32i.n	a3, a4, 44
  90ac31:	c83f      	beqz.n	a3, 90ac44 <ath_tgt_tx_cleanup+0x2c>
  90ac33:	8839      	l32i.n	a8, a3, 36
  90ac35:	893a      	l32i.n	a9, a3, 40
  90ac37:	c883      	beqz.n	a8, 90ac3e <ath_tgt_tx_cleanup+0x26>
  90ac39:	998a      	s32i.n	a9, a8, 40
  90ac3b:	600001        	j	90ac40 <ath_tgt_tx_cleanup+0x28>
  90ac3e:	994c      	s32i.n	a9, a4, 48
  90ac40:	893a      	l32i.n	a9, a3, 40
  90ac42:	9890      	s32i.n	a8, a9, 0
			if (bf->bf_isretried)
  90ac44:	283221        	l32i	a8, a3, 132
  90ac47:	78600a        	bnone	a6, a8, 90ac55 <ath_tgt_tx_cleanup+0x3d>
				ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90ac4a:	2b3123        	l16ui	a11, a3, 70
  90ac4d:	da40      	mov.n	a10, a4
  90ac4f:	0b4b14        	srli	a11, a11, 4
  90ac52:	5bf901        	call8	909058 <ath_tx_update_baw>
			ath_tx_freebuf(sc, bf);
  90ac55:	db30      	mov.n	a11, a3
  90ac57:	da20      	mov.n	a10, a2
  90ac59:	5bfaaf        	call8	909718 <ath_tx_freebuf>
			bf = bf_next;
  90ac5c:	d370      	mov.n	a3, a7
			continue;
  90ac5e:	600006        	j	90ac68 <ath_tgt_tx_cleanup+0x50>
		}
		bf->bf_comp = ath_tgt_tx_comp_normal;
  90ac61:	1772ca        	l32r	a7, 8e778c <memset+0x25f0>
  90ac64:	973f      	s32i.n	a7, a3, 60
		bf = asf_tailq_next(bf, bf_list);
  90ac66:	8339      	l32i.n	a3, a3, 36

	txq = TID_TO_ACTXQ(tid->tidno);

	bf = asf_tailq_first(&tid->buf_q);

	while (bf) {
  90ac68:	653fb9        	bnez	a3, 90ac25 <ath_tgt_tx_cleanup+0xd>
}

static inline void
ath_aggr_pause_tid(struct ath_softc_tgt *sc, ath_atx_tid_t *tid)
{
	tid->paused =1;
  90ac6b:	c031      	movi.n	a3, 1
  90ac6d:	234434        	s8i	a3, a4, 52
		bf = asf_tailq_next(bf, bf_list);
	}

	ath_aggr_pause_tid(sc, tid);

	while (tid->baw_head != tid->baw_tail) {
  90ac70:	8944      	l32i.n	a9, a4, 16
		if (TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head)) {
  90ac72:	c051      	movi.n	a5, 1
			tid->incomp++;
			tid->flag |= TID_CLEANUP_INPROGRES;
			TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, tid->baw_head);
  90ac74:	c7af      	movi.n	a10, -1
  90ac76:	60003d        	j	90acb7 <ath_tgt_tx_cleanup+0x9f>
	}

	ath_aggr_pause_tid(sc, tid);

	while (tid->baw_head != tid->baw_tail) {
		if (TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head)) {
  90ac79:	035612        	srai	a6, a3, 5
  90ac7c:	b466      	addi.n	a6, a6, 4
  90ac7e:	04660a        	addx4	a6, a6, a4
  90ac81:	8761      	l32i.n	a7, a6, 4
  90ac83:	003104        	ssl	a3
  90ac86:	00581a        	sll	a8, a5
  90ac89:	778018        	bnone	a8, a7, 90aca5 <ath_tgt_tx_cleanup+0x8d>
			tid->incomp++;
  90ac8c:	2b4037        	l8ui	a11, a4, 55
			tid->flag |= TID_CLEANUP_INPROGRES;
			TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, tid->baw_head);
  90ac8f:	08a803        	xor	a8, a10, a8

	ath_aggr_pause_tid(sc, tid);

	while (tid->baw_head != tid->baw_tail) {
		if (TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head)) {
			tid->incomp++;
  90ac92:	b1bb      	addi.n	a11, a11, 1
  90ac94:	2b4437        	s8i	a11, a4, 55
			tid->flag |= TID_CLEANUP_INPROGRES;
  90ac97:	2b4036        	l8ui	a11, a4, 54
			TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, tid->baw_head);
  90ac9a:	078701        	and	a7, a8, a7
	ath_aggr_pause_tid(sc, tid);

	while (tid->baw_head != tid->baw_tail) {
		if (TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head)) {
			tid->incomp++;
			tid->flag |= TID_CLEANUP_INPROGRES;
  90ac9d:	05bb02        	or	a11, a11, a5
  90aca0:	2b4436        	s8i	a11, a4, 54
			TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, tid->baw_head);
  90aca3:	9761      	s32i.n	a7, a6, 4
		}
		INCR(tid->baw_head, ATH_TID_MAX_BUFS);
  90aca5:	b133      	addi.n	a3, a3, 1
  90aca7:	030346        	extui	a3, a3, 0, 7
  90acaa:	9343      	s32i.n	a3, a4, 12
		INCR(tid->seq_start, IEEE80211_SEQ_MAX);
  90acac:	234102        	l16ui	a3, a4, 4
  90acaf:	b133      	addi.n	a3, a3, 1
  90acb1:	03034b        	extui	a3, a3, 0, 12
  90acb4:	234502        	s16i	a3, a4, 4
		bf = asf_tailq_next(bf, bf_list);
	}

	ath_aggr_pause_tid(sc, tid);

	while (tid->baw_head != tid->baw_tail) {
  90acb7:	8343      	l32i.n	a3, a4, 12
  90acb9:	7939bc        	bne	a3, a9, 90ac79 <ath_tgt_tx_cleanup+0x61>
		}
		INCR(tid->baw_head, ATH_TID_MAX_BUFS);
		INCR(tid->seq_start, IEEE80211_SEQ_MAX);
	}

	if (!(tid->flag & TID_CLEANUP_INPROGRES)) {
  90acbc:	234036        	l8ui	a3, a4, 54
  90acbf:	7f3f06        	bbsi	a3, 31, 90acc9 <ath_tgt_tx_cleanup+0xb1>
		ath_aggr_resume_tid(sc, tid);
  90acc2:	da20      	mov.n	a10, a2
  90acc4:	db40      	mov.n	a11, a4
  90acc6:	5bfe62        	call8	90a650 <ath_aggr_resume_tid>
  90acc9:	d10f      	retw.n
	...

0090accc <ath_bar_tx_comp>:
	ath_tx_set_retry(sc, bf);
	ath_tgt_txq_add_ucast(sc, bf);
}

static void ath_bar_tx_comp(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90accc:	6c1006        	entry	a1, 48
	struct ath_node_target *an;
	ath_atx_tid_t *tid;
	struct ath_txq *txq;

	an = (struct ath_node_target *)bf->bf_node;
	tid = &an->tid[bf->bf_tidno];
  90accf:	25304d        	l8ui	a5, a3, 77
	ath_tgt_txq_add_ucast(sc, bf);
}

static void ath_bar_tx_comp(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_tx_desc *ds = bf->bf_lastds;
  90acd2:	883e      	l32i.n	a8, a3, 56
	struct ath_node_target *an;
	ath_atx_tid_t *tid;
	struct ath_txq *txq;

	an = (struct ath_node_target *)bf->bf_node;
	tid = &an->tid[bf->bf_tidno];
  90acd4:	0c5911        	slli	a9, a5, 4
	struct ath_tx_desc *ds = bf->bf_lastds;
	struct ath_node_target *an;
	ath_atx_tid_t *tid;
	struct ath_txq *txq;

	an = (struct ath_node_target *)bf->bf_node;
  90acd7:	8434      	l32i.n	a4, a3, 16
	tid = &an->tid[bf->bf_tidno];
	txq = TID_TO_ACTXQ(tid->tidno);

	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
  90acd9:	268066        	l8ui	a6, a8, 102
	struct ath_node_target *an;
	ath_atx_tid_t *tid;
	struct ath_txq *txq;

	an = (struct ath_node_target *)bf->bf_node;
	tid = &an->tid[bf->bf_tidno];
  90acdc:	05990c        	sub	a9, a9, a5
  90acdf:	04990a        	addx4	a9, a9, a4
	txq = TID_TO_ACTXQ(tid->tidno);

	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
  90ace2:	060640        	extui	a6, a6, 0, 1
	struct ath_node_target *an;
	ath_atx_tid_t *tid;
	struct ath_txq *txq;

	an = (struct ath_node_target *)bf->bf_node;
	tid = &an->tid[bf->bf_tidno];
  90ace5:	259c24        	addi	a5, a9, 36
  90ace8:	299c20        	addi	a9, a9, 32
	txq = TID_TO_ACTXQ(tid->tidno);

	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
  90aceb:	6460bf        	beqz	a6, 90adae <ath_bar_tx_comp+0xe2>
static void ath_bar_retry(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);

	if (bf->bf_retries >= OWLMAX_BAR_RETRIES) {
  90acee:	263086        	l8ui	a6, a3, 134
  90acf1:	c0a9      	movi.n	a10, 9
  90acf3:	76ab5a        	bgeu	a10, a6, 90ad51 <ath_bar_tx_comp+0x85>
		ath_tgt_delba_send(sc, bf->bf_node, tid->tidno, 1,
  90acf6:	269007        	l8ui	a6, a9, 7
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, tidno);
	struct wmi_data_delba wmi_delba;

	tid->flag &= ~TID_AGGR_ENABLED;

	ath_tgt_tx_cleanup(sc, an, tid, 1);
  90acf9:	db40      	mov.n	a11, a4
			       struct ieee80211_node_target *ni,
			       a_uint8_t tidno, a_uint8_t initiator,
			       a_uint16_t reasoncode)
{
	struct ath_node_target *an = ATH_NODE_TARGET(ni);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, tidno);
  90acfb:	0c6811        	slli	a8, a6, 4
  90acfe:	06860c        	sub	a6, a8, a6
  90ad01:	04660a        	addx4	a6, a6, a4
  90ad04:	2c6c24        	addi	a12, a6, 36
	struct wmi_data_delba wmi_delba;

	tid->flag &= ~TID_AGGR_ENABLED;
  90ad07:	29c036        	l8ui	a9, a12, 54
  90ad0a:	c78d      	movi.n	a8, -3
  90ad0c:	089801        	and	a8, a9, a8
  90ad0f:	28c436        	s8i	a8, a12, 54

	ath_tgt_tx_cleanup(sc, an, tid, 1);
  90ad12:	da20      	mov.n	a10, a2
  90ad14:	c0d1      	movi.n	a13, 1
  90ad16:	5bffc0        	call8	90ac18 <ath_tgt_tx_cleanup>

	wmi_delba.ni_nodeindex = ni->ni_nodeindex;
  90ad19:	24400c        	l8ui	a4, a4, 12
	wmi_delba.tidno = tid->tidno;
	wmi_delba.initiator = 1;
	wmi_delba.reasoncode = IEEE80211_REASON_UNSPECIFIED;

	__stats(sc, txbar_xretry);
	wmi_event(sc->tgt_wmi_handle,
  90ad1c:	1b72ce        	l32r	a11, 8e7854 <memset+0x26b8>

	tid->flag &= ~TID_AGGR_ENABLED;

	ath_tgt_tx_cleanup(sc, an, tid, 1);

	wmi_delba.ni_nodeindex = ni->ni_nodeindex;
  90ad1f:	241400        	s8i	a4, a1, 0
	wmi_delba.tidno = tid->tidno;
  90ad22:	8469      	l32i.n	a4, a6, 36
	wmi_delba.initiator = 1;
	wmi_delba.reasoncode = IEEE80211_REASON_UNSPECIFIED;

	__stats(sc, txbar_xretry);
	wmi_event(sc->tgt_wmi_handle,
  90ad24:	8a23      	l32i.n	a10, a2, 12
	tid->flag &= ~TID_AGGR_ENABLED;

	ath_tgt_tx_cleanup(sc, an, tid, 1);

	wmi_delba.ni_nodeindex = ni->ni_nodeindex;
	wmi_delba.tidno = tid->tidno;
  90ad26:	241401        	s8i	a4, a1, 1
	wmi_delba.initiator = 1;
  90ad29:	c041      	movi.n	a4, 1
  90ad2b:	241402        	s8i	a4, a1, 2
	wmi_delba.reasoncode = IEEE80211_REASON_UNSPECIFIED;
  90ad2e:	241403        	s8i	a4, a1, 3

	__stats(sc, txbar_xretry);
  90ad31:	242279        	l32i	a4, a2, 0x1e4
	wmi_event(sc->tgt_wmi_handle,
  90ad34:	dc10      	mov.n	a12, a1
	wmi_delba.ni_nodeindex = ni->ni_nodeindex;
	wmi_delba.tidno = tid->tidno;
	wmi_delba.initiator = 1;
	wmi_delba.reasoncode = IEEE80211_REASON_UNSPECIFIED;

	__stats(sc, txbar_xretry);
  90ad36:	b144      	addi.n	a4, a4, 1
  90ad38:	242679        	s32i	a4, a2, 0x1e4
	wmi_event(sc->tgt_wmi_handle,
  90ad3b:	c0d4      	movi.n	a13, 4
  90ad3d:	5befab        	call8	906bec <wmi_event>
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);

	if (bf->bf_retries >= OWLMAX_BAR_RETRIES) {
		ath_tgt_delba_send(sc, bf->bf_node, tid->tidno, 1,
				   IEEE80211_REASON_UNSPECIFIED);
		ath_tgt_tid_drain(sc, tid);
  90ad40:	da20      	mov.n	a10, a2
  90ad42:	db50      	mov.n	a11, a5

		bf->bf_comp = NULL;
  90ad44:	c040      	movi.n	a4, 0
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);

	if (bf->bf_retries >= OWLMAX_BAR_RETRIES) {
		ath_tgt_delba_send(sc, bf->bf_node, tid->tidno, 1,
				   IEEE80211_REASON_UNSPECIFIED);
		ath_tgt_tid_drain(sc, tid);
  90ad46:	5bfb71        	call8	909b0c <ath_tgt_tid_drain>
			       struct ieee80211_node_target *ni,
			       a_uint8_t tidno, a_uint8_t initiator,
			       a_uint16_t reasoncode)
{
	struct ath_node_target *an = ATH_NODE_TARGET(ni);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, tidno);
  90ad49:	266c20        	addi	a6, a6, 32
	if (bf->bf_retries >= OWLMAX_BAR_RETRIES) {
		ath_tgt_delba_send(sc, bf->bf_node, tid->tidno, 1,
				   IEEE80211_REASON_UNSPECIFIED);
		ath_tgt_tid_drain(sc, tid);

		bf->bf_comp = NULL;
  90ad4c:	943f      	s32i.n	a4, a3, 60
  90ad4e:	600065        	j	90adb7 <ath_bar_tx_comp+0xeb>
		ath_buf_comp(sc, bf);
		return;
	}

	__stats(sc, txbar_compretries);
  90ad51:	24227a        	l32i	a4, a2, 0x1e8
  90ad54:	b144      	addi.n	a4, a4, 1
  90ad56:	24267a        	s32i	a4, a2, 0x1e8

	if (!bf->bf_lastds->ds_link) {
  90ad59:	268000        	l8ui	a6, a8, 0
  90ad5c:	258001        	l8ui	a5, a8, 1
  90ad5f:	248002        	l8ui	a4, a8, 2
  90ad62:	086610        	slli	a6, a6, 24
  90ad65:	005511        	slli	a5, a5, 16
  90ad68:	065502        	or	a5, a5, a6
  90ad6b:	084411        	slli	a4, a4, 8
  90ad6e:	054402        	or	a4, a4, a5
  90ad71:	258003        	l8ui	a5, a8, 3
  90ad74:	045402        	or	a4, a5, a4
  90ad77:	cd43      	bnez.n	a4, 90ad8e <ath_bar_tx_comp+0xc2>
		__stats(sc, txbar_errlast);
  90ad79:	24227b        	l32i	a4, a2, 0x1ec
		bf = ath_buf_toggle(sc, bf, 1);
  90ad7c:	db30      	mov.n	a11, a3
	}

	__stats(sc, txbar_compretries);

	if (!bf->bf_lastds->ds_link) {
		__stats(sc, txbar_errlast);
  90ad7e:	b144      	addi.n	a4, a4, 1
  90ad80:	24267b        	s32i	a4, a2, 0x1ec
		bf = ath_buf_toggle(sc, bf, 1);
  90ad83:	022a02        	or	a10, a2, a2
  90ad86:	2c0a01        	movi	a12, 1
  90ad89:	5bf9c9        	call8	9094b0 <ath_buf_toggle>
  90ad8c:	d3a0      	mov.n	a3, a10
	}

	bf->bf_lastds->ds_link = 0;
  90ad8e:	843e      	l32i.n	a4, a3, 56
  90ad90:	c080      	movi.n	a8, 0

	ath_tx_set_retry(sc, bf);
  90ad92:	da20      	mov.n	a10, a2
  90ad94:	db30      	mov.n	a11, a3
	if (!bf->bf_lastds->ds_link) {
		__stats(sc, txbar_errlast);
		bf = ath_buf_toggle(sc, bf, 1);
	}

	bf->bf_lastds->ds_link = 0;
  90ad96:	284400        	s8i	a8, a4, 0
  90ad99:	284401        	s8i	a8, a4, 1
  90ad9c:	284402        	s8i	a8, a4, 2
  90ad9f:	284403        	s8i	a8, a4, 3

	ath_tx_set_retry(sc, bf);
  90ada2:	5bfa83        	call8	9097b0 <ath_tx_set_retry>
	ath_tgt_txq_add_ucast(sc, bf);
  90ada5:	da20      	mov.n	a10, a2
  90ada7:	db30      	mov.n	a11, a3
  90ada9:	5bf871        	call8	908f70 <ath_tgt_txq_add_ucast>
  90adac:	d10f      	retw.n
	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
		ath_bar_retry(sc, bf);
		return;
	}

	ath_aggr_resume_tid(sc, tid);
  90adae:	da20      	mov.n	a10, a2
  90adb0:	db50      	mov.n	a11, a5
  90adb2:	5bfe27        	call8	90a650 <ath_aggr_resume_tid>

	bf->bf_comp = NULL;
  90adb5:	963f      	s32i.n	a6, a3, 60
	ath_buf_comp(sc, bf);
  90adb7:	da20      	mov.n	a10, a2
  90adb9:	db30      	mov.n	a11, a3
  90adbb:	5bfa48        	call8	9096dc <ath_buf_comp>
  90adbe:	d10f      	retw.n

0090adc0 <ar5416AttachRateTables>:

#endif //#ifdef MAGPIE_MERLIN // MAGPIE_MERLIN 

void
ar5416AttachRateTables(struct atheros_softc *sc)
{
  90adc0:	6c1004        	entry	a1, 32
    sc->hwRateTable[WIRELESS_MODE_11NG]  = &ar5416_11ngRateTable;
  90adc3:	1872cf        	l32r	a8, 8e7900 <memset+0x2764>
  90adc6:	9822      	s32i.n	a8, a2, 8
  90adc8:	d10f      	retw.n
	...

0090adcc <io32_rmw>:
	iowrite8(addr, val);
}

static inline void io32_rmw(volatile uint32_t addr,
			    const uint32_t set, const uint32_t clr)
{
  90adcc:	6c1006        	entry	a1, 48
  90adcf:	0c0200        	memw
  90add2:	9210      	s32i.n	a2, a1, 0
	uint32_t val;

	val = ioread32(addr);
  90add4:	0c0200        	memw
  90add7:	8810      	l32i.n	a8, a1, 0
	val &= ~clr;
  90add9:	c79f      	movi.n	a9, -1
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90addb:	0c0200        	memw
  90adde:	8880      	l32i.n	a8, a8, 0
			    const uint32_t set, const uint32_t clr)
{
	uint32_t val;

	val = ioread32(addr);
	val &= ~clr;
  90ade0:	049403        	xor	a4, a9, a4
  90ade3:	084801        	and	a8, a4, a8
	val |= set;
	iowrite32(addr, val);
  90ade6:	0c0200        	memw
  90ade9:	8a10      	l32i.n	a10, a1, 0
{
	uint32_t val;

	val = ioread32(addr);
	val &= ~clr;
	val |= set;
  90adeb:	038302        	or	a3, a8, a3
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90adee:	0c0200        	memw
  90adf1:	93a0      	s32i.n	a3, a10, 0
  90adf3:	d10f      	retw.n
  90adf5:	000000        	ill

0090adf8 <__adf_net_register_drv>:
 * 
 * @return a_status_t
 */
a_status_t
__adf_net_register_drv(adf_drv_info_t *drv)
{
  90adf8:	6c1004        	entry	a1, 32
    wlan_pci_register_drv(drv);    
  90adfb:	da20      	mov.n	a10, a2
  90adfd:	5be38e        	call8	903c38 <wlan_pci_register_drv>
    return A_STATUS_OK;
}
  90ae00:	c020      	movi.n	a2, 0
  90ae02:	d10f      	retw.n

0090ae04 <__adf_net_unregister_drv>:
 * @brief unregister the driver from the shim
 * @param[in] name
 */
void
__adf_net_unregister_drv(a_uint8_t *name)
{
  90ae04:	6c1004        	entry	a1, 32
  90ae07:	d10f      	retw.n
  90ae09:	000000        	ill

0090ae0c <ieee80211_tgt_crypto_encap>:

a_status_t
ieee80211_tgt_crypto_encap(struct ieee80211_frame *wh,
			   struct ieee80211_node_target *ni,
			   a_uint8_t keytype)
{
  90ae0c:	6c1004        	entry	a1, 32
	a_uint16_t tmp;
	a_uint16_t offset = IEEE80211_WLAN_HDR_LEN;
	a_uint8_t b1, b2;
	struct ieee80211_qosframe_addr4 *wh_mesh;

	if (IEEE80211_QOS_HAS_SEQ(wh))
  90ae0f:	2a2000        	l8ui	a10, a2, 0
  90ae12:	280a8c        	movi	a8, 140
  90ae15:	08aa01        	and	a10, a10, a8
#define CRYPTO_KEY_TYPE_WAPI         4
#define IEEE80211_WLAN_HDR_LEN      24

	a_uint8_t *iv = NULL;
	a_uint16_t tmp;
	a_uint16_t offset = IEEE80211_WLAN_HDR_LEN;
  90ae18:	290a88        	movi	a9, 136
  90ae1b:	09aa0c        	sub	a10, a10, a9
  90ae1e:	c188      	movi.n	a8, 24
  90ae20:	c19c      	movi.n	a9, 28
  90ae22:	0a9838        	moveqz	a8, a9, a10
	if (IEEE80211_QOS_HAS_SEQ(wh))
		offset += 4;  // pad for 4 byte alignment

	/* set the offset to 32 if the mesh control field is present */
	wh_mesh = (struct ieee80211_qosframe_addr4 *)wh;
	if (wh_mesh->i_qos[1] & 0x01)
  90ae25:	2a201f        	l8ui	a10, a2, 31
		offset = 32;
  90ae28:	c290      	movi.n	a9, 32
	if (IEEE80211_QOS_HAS_SEQ(wh))
		offset += 4;  // pad for 4 byte alignment

	/* set the offset to 32 if the mesh control field is present */
	wh_mesh = (struct ieee80211_qosframe_addr4 *)wh;
	if (wh_mesh->i_qos[1] & 0x01)
  90ae2a:	0a0a40        	extui	a10, a10, 0, 1
		offset = 32;
  90ae2d:	0a9839        	movnez	a8, a9, a10

a_status_t
ieee80211_tgt_crypto_encap(struct ieee80211_frame *wh,
			   struct ieee80211_node_target *ni,
			   a_uint8_t keytype)
{
  90ae30:	040447        	extui	a4, a4, 0, 8
	wh_mesh = (struct ieee80211_qosframe_addr4 *)wh;
	if (wh_mesh->i_qos[1] & 0x01)
		offset = 32;

	iv = (a_uint8_t *) wh;
	iv = iv + offset;
  90ae33:	a822      	add.n	a2, a2, a8

	switch (keytype) {
  90ae35:	684208        	beqi	a4, 2, 90ae41 <ieee80211_tgt_crypto_encap+0x35>
  90ae38:	684302        	beqi	a4, 3, 90ae3e <ieee80211_tgt_crypto_encap+0x32>
  90ae3b:	600082        	j	90aec1 <ieee80211_tgt_crypto_encap+0xb5>
  90ae3e:	600031        	j	90ae73 <ieee80211_tgt_crypto_encap+0x67>
	case CRYPTO_KEY_TYPE_AES:
		ni->ni_iv16++;
  90ae41:	28310d        	l16ui	a8, a3, 26
  90ae44:	b188      	addi.n	a8, a8, 1
  90ae46:	08084f        	extui	a8, a8, 0, 16
  90ae49:	28350d        	s16i	a8, a3, 26
		if (ni->ni_iv16 == 0)
  90ae4c:	cc84      	bnez.n	a8, 90ae54 <ieee80211_tgt_crypto_encap+0x48>
		{
			ni->ni_iv32++;
  90ae4e:	8437      	l32i.n	a4, a3, 28
  90ae50:	b144      	addi.n	a4, a4, 1
  90ae52:	9437      	s32i.n	a4, a3, 28
		}

		*iv++ = (a_uint8_t) ni->ni_iv16;
  90ae54:	282400        	s8i	a8, a2, 0
		*iv++ = (a_uint8_t) (ni->ni_iv16 >> 8);
  90ae57:	24310d        	l16ui	a4, a3, 26
		*iv++ = 0x00;
		*iv++ |= 0x20;
  90ae5a:	282003        	l8ui	a8, a2, 3
		{
			ni->ni_iv32++;
		}

		*iv++ = (a_uint8_t) ni->ni_iv16;
		*iv++ = (a_uint8_t) (ni->ni_iv16 >> 8);
  90ae5d:	048414        	srli	a4, a4, 8
  90ae60:	242401        	s8i	a4, a2, 1
		*iv++ = 0x00;
  90ae63:	c040      	movi.n	a4, 0
  90ae65:	242402        	s8i	a4, a2, 2
		*iv++ |= 0x20;
  90ae68:	c240      	movi.n	a4, 32
  90ae6a:	048402        	or	a4, a8, a4
  90ae6d:	242403        	s8i	a4, a2, 3
  90ae70:	600036        	j	90aeaa <ieee80211_tgt_crypto_encap+0x9e>
		tmp = (a_uint16_t) (ni->ni_iv32 >> 16);
		*iv++ = (a_uint8_t) tmp;
		*iv = (a_uint8_t) (tmp >> 8);
		break;
	case CRYPTO_KEY_TYPE_TKIP:
		ni->ni_iv16++;
  90ae73:	28310d        	l16ui	a8, a3, 26
  90ae76:	b188      	addi.n	a8, a8, 1
  90ae78:	08084f        	extui	a8, a8, 0, 16
  90ae7b:	28350d        	s16i	a8, a3, 26
		if (ni->ni_iv16 == 0)
  90ae7e:	cc86      	bnez.n	a8, 90ae88 <ieee80211_tgt_crypto_encap+0x7c>
		{
			ni->ni_iv32++;
  90ae80:	243207        	l32i	a4, a3, 28
  90ae83:	b144      	addi.n	a4, a4, 1
  90ae85:	243607        	s32i	a4, a3, 28
		}

		b1 = (a_uint8_t) (ni->ni_iv16 >> 8);
  90ae88:	088814        	srli	a8, a8, 8
		b2 = (b1 | 0x20) & 0x7f;
  90ae8b:	c54f      	movi.n	a4, 95
		if (ni->ni_iv16 == 0)
		{
			ni->ni_iv32++;
		}

		b1 = (a_uint8_t) (ni->ni_iv16 >> 8);
  90ae8d:	282400        	s8i	a8, a2, 0
		b2 = (b1 | 0x20) & 0x7f;
  90ae90:	c290      	movi.n	a9, 32
  90ae92:	048801        	and	a8, a8, a4
  90ae95:	098802        	or	a8, a8, a9
  90ae98:	282401        	s8i	a8, a2, 1

		*iv++ = b1;
		*iv++ = b2;

		*iv++ = (a_uint8_t) ni->ni_iv16;
  90ae9b:	24310d        	l16ui	a4, a3, 26
  90ae9e:	242402        	s8i	a4, a2, 2
		*iv++ |= 0x20;
  90aea1:	242003        	l8ui	a4, a2, 3
  90aea4:	094902        	or	a9, a4, a9
  90aea7:	292403        	s8i	a9, a2, 3

		tmp = (a_uint16_t) ni->ni_iv32;
  90aeaa:	8837      	l32i.n	a8, a3, 28
		*iv++ = (a_uint8_t) tmp;
  90aeac:	282404        	s8i	a8, a2, 4
		*iv++ = (a_uint8_t) (tmp >> 8);
  90aeaf:	088847        	extui	a8, a8, 8, 8
  90aeb2:	282405        	s8i	a8, a2, 5

		tmp = (a_uint16_t) (ni->ni_iv32 >> 16);
  90aeb5:	23310e        	l16ui	a3, a3, 28
		*iv++ = (a_uint8_t) tmp;
  90aeb8:	232406        	s8i	a3, a2, 6
		*iv = (a_uint8_t) (tmp >> 8);
  90aebb:	038314        	srli	a3, a3, 8
  90aebe:	232407        	s8i	a3, a2, 7

#undef CRYPTO_KEY_TYPE_TKIP
#undef CRYPTO_KEY_TYPE_AES
#undef CRYPTO_KEY_TYPE_WAPI
#undef IEEE80211_WLAN_HDR_LEN
}
  90aec1:	c021      	movi.n	a2, 1
  90aec3:	d10f      	retw.n
