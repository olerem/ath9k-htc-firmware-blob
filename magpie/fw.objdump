
../ath9k-htc-firmware-blob/magpie/fw.elf:     Dateiformat elf32-xtensa-be
../ath9k-htc-firmware-blob/magpie/fw.elf
Architektur: xtensa, Flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
Startadresse 0x00906000

Xtensa header:

Machine     = Base
Insn tables = true
Literal tables = true

Programm-Header:
    LOAD off    0x00501000 vaddr 0x00501000 paddr 0x00501000 align 2**29
         filesz 0x00001c70 memsz 0x00001c70 flags r--
    LOAD off    0x00510d00 vaddr 0x00510d00 paddr 0x00510d00 align 2**29
         filesz 0x00001f68 memsz 0x00002210 flags rw-
    LOAD off    0x00906000 vaddr 0x00906000 paddr 0x00906000 align 2**29
         filesz 0x00009119 memsz 0x00009119 flags r-x

Sektionen:
Idx Name          Größe     VMA       LMA       Datei-Off Ausr.
  0 .lit4         00019000  004e8000  004e8000  00000000  2**0
                  ALLOC
  1 .rodata       00001440  00501000  00501000  00501000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .literals     00000830  00502440  00502440  00502440  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .data         00001f68  00510d00  00510d00  00510d00  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          000002a8  00512c68  00512c68  00512c68  2**2
                  ALLOC
  5 .boot         0000027c  00906000  00906000  00906000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .text         00008e9d  0090627c  0090627c  0090627c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .debug_aranges 00000348  00000000  00000000  0090f119  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   0005c065  00000000  00000000  0090f461  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00005ee3  00000000  00000000  0096b4c6  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   00011752  00000000  00000000  009713a9  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  00001fb8  00000000  00000000  00982afc  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00008660  00000000  00000000  00984ab4  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    0000eb85  00000000  00000000  0098d114  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .xt.prop      00004fe0  00000000  00000000  0099bc99  2**0
                  CONTENTS, READONLY
 15 .debug_ranges 00001800  00000000  00000000  009a0c79  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .comment      0000006d  00000000  00000000  009a2479  2**0
                  CONTENTS, READONLY
 17 .xtensa.info  00000038  00000000  00000000  009a24e6  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
004e8000 l    d  .lit4	00000000 .lit4
00501000 l    d  .rodata	00000000 .rodata
00502440 l    d  .literals	00000000 .literals
00510d00 l    d  .data	00000000 .data
00512c68 l    d  .bss	00000000 .bss
00906000 l    d  .boot	00000000 .boot
0090627c l    d  .text	00000000 .text
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .xt.prop	00000000 .xt.prop
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .xtensa.info	00000000 .xtensa.info
00000000 l    df *ABS*	00000000 magpie.c
00501000 l     O .rodata	0000000d __FUNCTION__$3859
00000000 l    df *ABS*	00000000 adf_nbuf.c
00501010 l     O .rodata	00000010 __FUNCTION__$4966
00501020 l     O .rodata	0000001c __FUNCTION__$4971
0050103c l     O .rodata	0000001c __FUNCTION__$4976
00501058 l     O .rodata	00000012 __FUNCTION__$4982
00501084 l     O .rodata	00000010 __FUNCTION__$5011
00501094 l     O .rodata	00000013 __FUNCTION__$5016
005010a8 l     O .rodata	00000014 __FUNCTION__$5029
005010bc l     O .rodata	0000001b __FUNCTION__$5086
005010d8 l     O .rodata	00000019 __FUNCTION__$5099
0050106c l     O .rodata	00000015 __FUNCTION__$5006
00000000 l    df *ABS*	00000000 dbg_api.c
00906dd8 l     F .text	00000011 db_incorect_format
00906dec l     F .text	00000028 zf_debug_init
00906e14 l     F .text	00000066 db_ascii_to_hex
00906e7c l     F .text	00000037 db_hex_to_ascii
00906eb4 l     F .text	0000003b db_help_cmd
00906ef0 l     F .text	00000013 db_cmd_starthtc
00906f04 l     F .text	0000005c db_cmd_memcmp
00906f60 l     F .text	000000a8 db_cmd_memdump
00907008 l     F .text	000000c0 db_str_cmd
009070c8 l     F .text	00000083 db_ldr_cmd
0090714c l     F .text	000000dd db_intr_cmd
0090722c l     F .text	0000014a db_wdt_cmd
00907378 l     F .text	00000036 db_usb_cmd
009073b0 l     F .text	00000024 db_info_cmd
009073d4 l     F .text	00000264 zf_debug_task
00907674 l     F .text	0000006f db_clock_cmd
00000000 l    df *ABS*	00000000 usb_api_main_patch.c
00510d00 l     O .data	00000002 cmd_is_new$3834
00512c80 l     O .bss	00000004 evntbuf$3832
00512c84 l     O .bss	00000004 regaddr$3833
00512c88 l     O .bss	00000002 buf_len$3831
00510d02 l     O .data	00000002 cmd_is_new$3853
00512c8c l     O .bss	00000004 buf$3851
00512c90 l     O .bss	00000002 cmd_len$3850
005011c0 l     O .rodata	00000012 __func__$3854
00512c94 l     O .bss	00000004 regaddr$3849
00000000 l    df *ABS*	00000000 if_ath.c
00907b5c l     F .text	00000014 __adf_os_mem_alloc
00907b70 l     F .text	00000013 __adf_os_mem_copy
00907b84 l     F .text	00000013 __adf_os_mem_set
00907b98 l     F .text	00000005 tgt_HTCRecv_uapsdhandler
00501258 l     O .rodata	00000019 __FUNCTION__$7595
00907ba0 l     F .text	0000001c dispatch_magpie_sys_cmds
00907bbc l     F .text	00000005 htc_setup_comp
00908010 l     F .text	00000130 tgt_HTCSendCompleteHandler
00907f44 l     F .text	00000070 tgt_ServiceConnect
00907bc4 l     F .text	0000002e tgt_reg_service
00907bf4 l     F .text	00000010 tgt_HTCRecv_mgmthandler
00907c04 l     F .text	000000b6 ath_tgt_rx_tasklet
00907cbc l     F .text	00000098 ath_descdma_cleanup
00907d54 l     F .text	00000014 __adf_os_init_bh$isra$4
00907d68 l     F .text	00000010 __adf_os_sched_bh$isra$5
00907d78 l     F .text	00000194 ath_rxdesc_init
00512c9c l     O .bss	00000001 reset_pll$7404
00907f0c l     F .text	00000036 ath_pll_reset_ones$isra$9
005012a4 l     O .rodata	00000013 __FUNCTION__$7635
00907fb4 l     F .text	0000005c ath_reg_read_filter
00908140 l     F .text	0000004c ath_desc_free
005012c8 l     O .rodata	00000012 __FUNCTION__$7187
0090818c l     F .text	000000af ath_descdma_setup$constprop$22
00501274 l     O .rodata	0000001a __FUNCTION__$7146
0090823c l     F .text	000000aa tgt_HTCRecvMessageHandler
009082e8 l     F .text	0000003b tgt_HTCRecv_cabhandler
00908374 l     F .text	00000012 ath_fatal_tasklet
00908388 l     F .text	00000012 ath_bmiss_tasklet
00510d04 l     O .data	00000004 ath_numrxbufs
00501204 l     O .rodata	0000001a __FUNCTION__$7010
005011f8 l     O .rodata	0000000c __FUNCTION__$6952
00908b38 l     F .text	0000006a ath_hal_reg_rmw_tgt
00908ba4 l     F .text	00000084 ath_rc_mask_tgt
00908c28 l     F .text	00000023 ath_rx_stats_tgt
00908c4c l     F .text	00000042 ath_tx_stats_tgt
00908c90 l     F .text	00000032 ath_int_stats_tgt
00908cc4 l     F .text	00000062 ath_node_update_tgt
00908d28 l     F .text	0000002a ath_detach_tgt
00501220 l     O .rodata	00000014 __FUNCTION__$7326
00908d54 l     F .text	00000088 ath_enable_aggr_tgt
00908ddc l     F .text	0000002c ath_ic_update_tgt
00908e08 l     F .text	00000056 handle_rc_rate_update_cmd
00908e60 l     F .text	00000052 handle_rc_state_change_cmd
00908eb4 l     F .text	0000004a ath_hal_reg_write_tgt
00908f00 l     F .text	0000003f ath_hal_reg_read_tgt
00501234 l     O .rodata	00000013 __FUNCTION__$7349
00908f40 l     F .text	00000074 ath_vap_create_tgt
00908fb4 l     F .text	00000054 ath_vap_delete_tgt
00909008 l     F .text	0000002c ath_node_cleanup_tgt
00909034 l     F .text	00000097 ath_node_create_tgt
00501248 l     O .rodata	0000000f __FUNCTION__$6931
009090cc l     F .text	00000078 ath_setcurmode_tgt
00909144 l     F .text	00000050 ath_flushrecv_tgt
00909194 l     F .text	0000003a ath_stoprecv_tgt
009091d0 l     F .text	00000086 ath_startrecv_tgt
00909258 l     F .text	000000c8 ath_draintxq_tgt
00909320 l     F .text	0000002e ath_tx_draintxq_tgt
00909350 l     F .text	00000023 ath_aborttx_dma_tgt
00909374 l     F .text	00000026 ath_stop_tx_dma_tgt
0090939c l     F .text	00000040 ath_aborttxq_tgt
009093dc l     F .text	0000004e ath_init_tgt
0090942c l     F .text	00000054 ath_enable_intr_tgt
00909480 l     F .text	00000026 ath_disable_intr_tgt
009094a8 l     F .text	0000001e ath_get_tgt_version
009094c8 l     F .text	00000013 handle_echo_command
00501290 l     O .rodata	00000014 __FUNCTION__$7070
009094f4 l     F .text	000001d2 tgt_HTCRecv_beaconhandler
00510d0c l     O .data	00000100 Magpie_Sys_DispatchEntries
00510d08 l     O .data	00000004 ath_numrxdescs
005012b8 l     O .rodata	0000000f __FUNCTION__$7211
00000000 l    df *ABS*	00000000 htc.c
005012dc l     O .rodata	00000018 __FUNCTION__$4065
00000000 l    df *ABS*	00000000 wmi_svc.c
0090a428 l     F .text	0000000b WMIServiceConnect
0090a434 l     F .text	00000007 _WMI_GetPendingEventsCount
0090a43c l     F .text	00000007 _WMI_GetControlEp
0090a444 l     F .text	00000014 _WMI_RegisterDispatchTable
0090a458 l     F .text	00000005 _WMI_Shutdown
005012f4 l     O .rodata	00000016 __FUNCTION__$3864
0090a460 l     F .text	0000009e WMIRecvMessageHandler
0090a500 l     F .text	00000020 _WMI_SendCompleteHandler
0090a520 l     F .text	00000030 _WMI_AllocEvent
0090a550 l     F .text	00000036 _WMI_SendEvent
0090a588 l     F .text	0000006f _WMI_Init
00000000 l    df *ABS*	00000000 ar5416_hw.c
0050130c l     O .rodata	000000d4 ar5416hal_10
00000000 l    df *ABS*	00000000 ratectrl_11n_ln.c
0090c1d8 l     F .text	000000c0 rcRateSetseries
0090c298 l     F .text	00000074 rcIsValidPhyRate
005013e0 l     O .rodata	00000028 nRetry2PerLookup$7250
0090c30c l     F .text	000001fe rcUpdate_ht$isra$4
0090c50c l     F .text	00000396 rcSibUpdate_ht$constprop$6
0090c8a4 l     F .text	0000002a ath_rate_newassoc_11n
00000000 l    df *ABS*	00000000 if_owl.c
0090cea8 l     F .text	00000013 __adf_os_mem_copy
0090cebc l     F .text	0000004c ieee80211_anyhdrsize
0090cf08 l     F .text	0000004b owl_tgt_tid_init
00501498 l     O .rodata	00000016 __FUNCTION__$7146
0090cf54 l     F .text	0000008b ath_tgt_txq_add_ucast
0090cfe0 l     F .text	0000006e ath_update_stats
0090d050 l     F .text	0000005e ath_tx_update_baw
0090d0b0 l     F .text	00000016 ath_dma_unmap
0090d0c8 l     F .text	00000026 ath_tgt_skb_free
0090d0f0 l     F .text	000000a6 ath_filltxdesc
0090d198 l     F .text	0000004e ath_tx_tgt_setds
0090d1e8 l     F .text	00000024 ath_tgt_tx_enqueue
0090d20c l     F .text	00000082 ath_update_aggr_stats$isra$2
0090d290 l     F .text	00000013 __adf_os_mem_set$constprop$13
00501430 l     O .rodata	00000040 bits_per_symbol
0090d2a4 l     F .text	000001fa ath_buf_set_rate
0090d4a0 l     F .text	00000017 ath_dma_map
00501408 l     O .rodata	0000000f __FUNCTION__$6945
0090d4b8 l     F .text	0000010d ath_buf_toggle
0090d5c8 l     F .text	00000083 ath_tx_freebuf
0090d64c l     F .text	0000003c ath_buf_comp
0090ee60 l     F .text	000000f4 ath_bar_tx_comp
0090d688 l     F .text	0000015e ath_bar_tx
0090d7f8 l     F .text	00000031 ath_tx_set_retry
0090d97c l     F .text	000000e0 ath_tx_retry_subframe
0090da5c l     F .text	000000ae ath_tx_comp_aggr_error
00501484 l     O .rodata	00000011 __FUNCTION__$7108
00501470 l     O .rodata	00000013 __FUNCTION__$7117
005014b0 l     O .rodata	00000011 __FUNCTION__$7227
005014c4 l     O .rodata	00000016 __FUNCTION__$7248
0090e834 l     F .text	0000004e ath_tgt_tx_comp_normal
005014f0 l     O .rodata	00000015 __FUNCTION__$7339
00501418 l     O .rodata	00000016 __FUNCTION__$7301
0090e590 l     F .text	0000020a ath_tgt_txq_schedule
0090e79c l     F .text	0000004a ath_aggr_resume_tid
0090e7e8 l     F .text	0000004b owl_tgt_tid_cleanup
00501508 l     O .rodata	00000015 __FUNCTION__$7376
005014dc l     O .rodata	00000014 __FUNCTION__$7271
00000000 l    df *ABS*	00000000 app_start.c
0090f020 l     F .text	00000029 io32_rmw
00000000 l    df *ABS*	00000000 init.c
0090627c l     F .text	00000029 io32_rmw
00512c70 l     O .bss	00000004 loop_high
00512c74 l     O .bss	00000004 loop_low
00000000 l    df *ABS*	00000000 ah_osdep.c
00000000 l    df *ABS*	00000000 wlan_pci.c
00000000 l    df *ABS*	00000000 usb_api_magpie_patch.c
0090a630 l     F .text	00000029 io32_rmw
0090a65c l     F .text	00000068 _fw_restore_dma_fifo
0090a6c4 l     F .text	00000377 _fw_reset_dma_fifo
00000000 l    df *ABS*	00000000 if_ath_pci.c
0090ef54 l     F .text	00000005 ath_pci_suspend
0090ef5c l     F .text	00000005 ath_pci_resume
0090ef64 l     F .text	00000010 ath_pci_remove
00511bc0 l     O .data	00000020 ath_drv_info
0090ef84 l     F .text	0000007e ath_pci_probe
00511be0 l     O .data	00000160 ath_pci_id_table
00000000 l    df *ABS*	00000000 buf_pool_static.c
00000000 l    df *ABS*	00000000 cmnos_clock_patch.c
00512cbc l     O .bss	00000004 last_tick$3775
00000000 l    df *ABS*	00000000 HIF_usb_patch.c
00000000 l    df *ABS*	00000000 adf_os_dma.c
00000000 l    df *ABS*	00000000 adf_os_irq_pvt.c
00000000 l    df *ABS*	00000000 ah.c
00000000 l    df *ABS*	00000000 ar5416_phy.c
00000000 l    df *ABS*	00000000 adf_net.c
00000000 l    df *ABS*	00000000 ar5416Phy.c
00000000 l    df *ABS*	00000000 ieee80211_output.c
00000000 l    df *ABS*	00000000 
00500abc g       *ABS*	00000000 u16TxRxCounter
00906738 g     F .text	00000032 init_mem
00511388 g     O .data	000002bc ar5416_11g_table
008e37e8 g       *ABS*	00000000 HIFusb_DescTraceDump
0090ce28 g     F .text	00000036 ath_rate_tx_complete
004e8000 g       *ABS*	00000000 _rom_literal_start
00906554 g     F .text	00000054 zfGenWrongEpidEvent
00906a9c g     F .text	0000002b __adf_nbuf_dmamap_info
00512cf4 g     O .bss	000000a0 cmd_str
00510e0c g     O .data	00000002 bEepromExist
00907a58 g     F .text	00000078 bGet_descriptor_patch
0090db54 g     F .text	0000002d ath_tgt_tid_drain
00906be0 g     F .text	00000011 __adf_nbuf_last
00500ad0 g       *ABS*	00000000 u8UsbInterfaceValue
00906990 g     F .text	00000020 __adf_nbuf_copy
00512cc0 g     O .bss	00000004 _assfail_ori
00906a7c g     F .text	00000009 __adf_nbuf_map
00502440 g       *ABS*	00000000 _bss_table_end
0090f108 g     F .text	0000000c __adf_net_register_drv
00512ca0 g     O .bss	00000004 g_wlan_intr
00906a60 g     F .text	0000001c __adf_nbuf_dmamap_create
0090adf8 g     F .text	00000052 ath_hal_get_curmode
00511d40 g     O .data	00000004 ar5416_11naRateTable
0090a160 g     F .text	0000009c HTCControlSvcProcessMsg
0051247c g     O .data	00000004 ar5416_11ngRateTable
00512d94 g     O .bss	00000002 gvLen
00909b48 g     F .text	0000000f wlan_pci_module_init
00500000 g       *ABS*	00000000 _indir_tbl
0090ad40 g     F .text	00000010 ath_hal_attach_tgt
00906db4 g     F .text	00000023 buf_pool_module_install
00501000 g       *ABS*	00000000 _lit4_end
00906c98 g     F .text	00000007 __adf_nbuf_is_cloned
00907880 g     F .text	00000107 usb_reg_out_patch
00906ac8 g     F .text	00000005 __adf_nbuf_set_rx_cksum
0090bc38 g     F .text	000000bc ar5416AbortTxDma
00512d98 g     O .bss	00000004 cmd_buf_ptr
0090f119 g       *ABS*	00000000 _text_end
0090e884 g     F .text	00000376 ath_tgt_tx_comp_aggr
0090ac68 g     F .text	00000011 _HIFusb_isr_handler_patch
0090cdcc g     F .text	0000002e ath_rate_attach
0090bb44 g     F .text	00000044 ar5416Set11nBurstDuration_20
009079cc g     F .text	00000022 vUsbFIFO_EPxCfg_FS_patch
00906ad8 g     F .text	000000a7 __adf_nbuf_create_frm_frag
00907750 g     F .text	00000022 cold_reboot
00501000 g       *ABS*	00000000 _lit4_start
009076fc g     F .text	0000000f cmnos_dbg_module_install
00502c70 g       *ABS*	00000000 _dram0_literal_end
0090a1fc g     F .text	00000031 AdjustCreditThreshold
00502c70 g       *ABS*	00000000 _dram0_literal_start
0090ae4c g     F .text	00000029 ath_hal_wait
0090f119 g       .text	00000000 _etext
0090bb88 g     F .text	0000006f ar5416Set11nVirtualMoreFrag_20
008e4f60 g       *ABS*	00000000 vbuf_module_install
00512c68 g     O .bss	00000004 idle_cnt
0090d82c g     F .text	00000043 owl_tgt_node_init
00907774 g     F .text	0000010a usb_status_in_patch
00909b58 g     F .text	0000000a wlan_pci_register_drv
00906938 g     F .text	0000002a __adf_nbuf_push_head
0090770c g     F .text	00000022 _fw_usbfifo_recv_command
0090f010 g     F .text	0000000f ar5416AttachRateTables
00909cf4 g     F .text	000000bf _HTC_Init
009068d8 g     F .text	0000001e __adf_nbuf_realloc_headroom
0090b974 g     F .text	00000089 ar5416Set11nAggrFirst_20
00906a94 g     F .text	00000005 __adf_nbuf_dmamap_destroy
0090de80 g     F .text	00000412 ath_tgt_send_mgt
0090c1a4 g     F .text	00000032 ar5416GetRateTable
00906cb8 g     F .text	0000000d __adf_nbuf_queue_init
008e6b64 g       *ABS*	00000000 memcpy
009076e4 g     F .text	00000016 dbg_timer_func
0090ce60 g     F .text	00000012 ath_rate_newassoc
00502440 g       *ABS*	00000000 _rodata_end
00906ad0 g     F .text	00000007 __adf_nbuf_get_vlan_info
0090cbd0 g     F .text	00000158 rcUpdate_11n
0090ad8c g     F .text	0000006b ath_hal_computetxtime
00500ad8 g       *ABS*	00000000 u8UsbDeviceDescriptor
0090cd28 g     F .text	000000a2 ath_tx_status_update_rate
00906cd0 g     F .text	00000007 __adf_nbuf_queue_first
00512cc4 g     O .bss	00000004 htc_handle
0090d7e8 g     F .text	00000010 ATH_SKB_2_WH
0090f04c g     F .text	000000b9 ieee80211_tgt_crypto_encap
008e6a4c g       *ABS*	00000000 __udivsi3
00909e44 g     F .text	00000057 _HTC_Ready
00907ad0 g     F .text	00000010 ath_hal_getuptime
00906bf4 g     F .text	0000003b __adf_nbuf_trim_tail
00512c68 g       *ABS*	00000000 _bss_start
00510d00 g       *ABS*	00000000 _dram0_data_end
00511900 g     O .data	000002bc ar5416_11a_table
00909f44 g     F .text	00000062 ReturnBuffers
0090ddfc g     F .text	00000084 ath_tgt_tx_send_normal
00500ad2 g       *ABS*	00000000 u8UsbInterfaceAlternateSetting
00512c68 g       *ABS*	00000000 __XT_EXCEPTION_DESCS__
0090ed08 g     F .text	000000a2 ath_tgt_handle_aggr
005010f4 g     O .rodata	000000cc command_table
0090627c g       *ABS*	00000000 _text_start
00907730 g     F .text	00000020 _fw_usbfifo_init
0090ebfc g     F .text	0000009a owltgt_tx_processq
009068f8 g     F .text	0000001e __adf_nbuf_realloc_tailroom
0090e294 g     F .text	00000062 ath_tgt_handle_normal
0090b268 g     F .text	00000015 ar5416StartTxDma
0090be04 g     F .text	00000059 ar5416SetRxFilter
00907b3c g     F .text	00000005 ath_hal_free
0090a230 g     F .text	00000156 _HTC_SendMsg
0090c12c g     F .text	00000077 ar5416Attach
00906c90 g     F .text	00000005 __adf_nbuf_cat
0090b254 g     F .text	00000012 ar5416SetTxDP
0090ce74 g     F .text	00000012 ath_rate_node_update
008e1548 g       *ABS*	00000000 generic_hif_module_install
00906c64 g     F .text	00000019 __adf_nbuf_tailroom
00906c88 g     F .text	00000007 __adf_nbuf_clone
008e4934 g       *ABS*	00000000 mUsbFIFOConfig
0090abe4 g     F .text	0000000a cmnos_clock_init_patch
008e36e4 g       *ABS*	00000000 _HIFusb_isr_handler
00906d10 g     F .text	00000057 _buf_pool_static_create_pool
00512d9c g     O .bss	00000028 raw_cmd
00906cc8 g     F .text	00000007 __adf_nbuf_queue_len
00501000 g       *ABS*	00000000 _dport0_literal_start
0090f004 g     F .text	0000000b exit_ath_pci
00512f10 g       *ABS*	00000000 _bss_end
00906d08 g     F .text	00000005 _buf_pool_static_shutdown
0090b1f0 g     F .text	00000061 ar5416UpdateTxTrigLevel
00512cb4 g     O .bss	00000002 bJumptoFlash
00512cc8 g     O .bss	0000002c g_poolCtx
009069f8 g     F .text	00000020 __adf_nbuf_get_priv
00512cb0 g     O .bss	00000004 gpio_func
0090a0dc g     F .text	00000082 HTCProcessConfigPipeMsg
00906d68 g     F .text	00000022 _buf_pool_static_alloc_buf
0090bd18 g     F .text	0000000a ar5416Detach
0090af64 g     F .text	0000000f ar5416EnableReceive
00500aa4 g       *ABS*	00000000 usbFifoConf
00500ab8 g       *ABS*	00000000 pu8DescriptorEX
0090abf0 g     F .text	0000000a cmnos_refclk_speed_get_patch
0090b5f0 g     F .text	0000010c ar5416Set11nTxDesc_20
00510d00 g       *ABS*	00000000 _dram0_data_start
0090ef74 g     F .text	0000000d init_ath_pci
00511644 g     O .data	000002bc ar5416_11b_table
008e3a9c g       *ABS*	00000000 bGet_descriptor
0090b280 g     F .text	0000002b ar5416NumTxPending
009096c8 g     F .text	00000456 ath_tgt_attach
00909c9c g     F .text	00000013 _HTC_GetReservedHeadroom
00906840 g     F .text	0000003c Magpie_init
00512c68 g       *ABS*	00000000 __XT_EXCEPTION_DESCS_END__
00906478 g     F .text	0000005e zfGenExceptionEvent
00906b80 g     F .text	00000060 __adf_nbuf_split_to_frag
0090a5f8 g     F .text	00000037 WMI_service_module_install
00906d8c g     F .text	00000010 _buf_pool_static_alloc_buf_align
00501000 g       *ABS*	00000000 _dport0_rodata_start
00510d00 g       *ABS*	00000000 _dport0_data_start
008e6958 g       *ABS*	00000000 xthal_get_ccount
00906918 g     F .text	0000001e __adf_nbuf_expand
0090ae9c g     F .text	00000083 ar5416SetInterrupts
009062f0 g     F .text	00000062 change_magpie_clk
0090af54 g     F .text	0000000d ar5416SetRxDP
0090d870 g     F .text	00000010 ath_tx_status_clear
00512ca4 g     O .bss	00000004 g_wlan_drv_handle
00909cb0 g     F .text	0000002a HTCSendDoneHandler
0090aa3c g     F .text	00000079 _fw_usb_suspend_reboot
008e497c g       *ABS*	00000000 mUsbEPMxPtSzLow
0090af20 g     F .text	00000034 ar5416GetTsf64
00512cb8 g     O .bss	00000004 ref_clk
00909e9c g     F .text	00000066 HTCCheckAndSendCreditReport
00500a98 g       *ABS*	00000000 ControlCmd
00510d00 g       *ABS*	00000000 _data_start
00500ace g       *ABS*	00000000 u8UsbConfigValue
00907b18 g     F .text	00000022 ath_hal_malloc
0090bcf4 g     F .text	00000021 ar5416StopDmaReceive
00909db4 g     F .text	00000005 _HTC_PauseRecv
0090f114 g     F .text	00000005 __adf_net_unregister_drv
0090acfc g     F .text	0000002b __adf_os_dmamem_alloc
008e48f8 g       *ABS*	00000000 mUsbEPMap
00906964 g     F .text	0000002b __adf_nbuf_pull_head
0090ad28 g     F .text	0000000c __adf_os_setup_intr
00512c7c g     O .bss	00000004 m_origUsbfifoRecvCmd
0090ac18 g     F .text	0000002b cmnos_tick_patch
00906a18 g     F .text	0000001e __adf_nbuf_queue_add
00908adc g     F .text	0000005a wmi_cmd_rsp
009069b0 g     F .text	00000020 __adf_nbuf_unshare
00512ec0 g     O .bss	00000012 UsbDeviceDescriptorPatch
00906d9c g     F .text	00000016 _buf_pool_static_free_buf
00906ce0 g     F .text	0000000e __adf_nbuf_is_queue_empty
0090ae78 g     F .text	00000022 ar5416IsInterruptPending
00907b44 g     F .text	00000015 ath_hal_memcpy
008e6348 g       *ABS*	00000000 _xtos_set_exception_handler
00906000 g     F .boot	0000027c app_start
0090b2ac g     F .text	000001e6 ar5416SetupTxDesc_20
0050095c g       *ABS*	00000000 cticks
008e5010 g       *ABS*	00000000 vdesc_module_install
0090d880 g     F .text	0000008b ath_tx_status_update
00512c68 g       *ABS*	00000000 _data_end
0090f119 g       *ABS*	00000000 _iram0_text_end
0090e344 g     F .text	0000024b ath_tgt_tx_form_aggr
00502430 g       *ABS*	00000000 __XT_EXCEPTION_TABLE__
0090e2f8 g     F .text	0000004a ath_tx_addto_baw
00906a38 g     F .text	00000026 __adf_nbuf_queue_remove
00909b20 g     F .text	00000028 ath_detach
0090676c g     F .text	0000005b wlan_task
00502440 g       *ABS*	00000000 _literals_start
00512dc4 g     O .bss	000000f0 cmd_buffer
00906cf0 g     F .text	00000017 _buf_pool_static_init
00512c6c g     O .bss	00000001 htc_complete_setup
00906c80 g     F .text	00000008 __adf_nbuf_len
0090bbf8 g     F .text	0000003d ar5416StopTxDma
00909c6c g     F .text	00000016 wlan_pci_isr
008e6e48 g       *ABS*	00000000 memset
00502c70 g       *ABS*	00000000 _literals_end
00909c84 g     F .text	00000005 _HTC_Shutdown
0090ad50 g     F .text	0000003a ath_hal_getcapability
009069d0 g     F .text	00000027 __adf_nbuf_frag_info
00501000 g       *ABS*	00000000 _dport0_rodata_end
0090abfc g     F .text	0000001c cmnos_delay_us_patch
00500ac4 g       *ABS*	00000000 eUsbCxFinishAction
00512c98 g     O .bss	00000004 init_htc_handle
00909e08 g     F .text	00000016 HTCFreeMsgBuffer
0090ba00 g     F .text	00000083 ar5416Set11nAggrMiddle_20
00906ca0 g     F .text	00000015 __adf_nbuf_peek_header
009065dc g     F .text	0000015b HTCMsgRecvHandler_patch
0090644c g     F .text	0000002a reset_EP4_FIFO
008e6998 g       *ABS*	00000000 __divsi3
008e6560 g       *ABS*	00000000 strcmp
0090b004 g     F .text	000001ea ar5416ProcRxDescFast_20
00501000 g       *ABS*	00000000 _dram0_rodata_start
0090aab8 g     F .text	000000da zfTurnOffPower_patch
00501000 g       *ABS*	00000000 _rom_literal_end
00908324 g     F .text	0000004e wmi_event
00512c78 g     O .bss	00000004 delay
00909b94 g     F .text	00000038 wlan_pci_config_read
0090839c g     F .text	0000073e ath_intr
00909fa8 g     F .text	00000010 _HTC_ReturnBuffers
008e1574 g       *ABS*	00000000 athos_indirection_table_install
008e6980 g       *ABS*	00000000 xthal_get_intenable
0090ec98 g     F .text	0000006e owl_tgt_tx_tasklet
008e4954 g       *ABS*	00000000 mUsbEPMxPtSzHigh
00907b08 g     F .text	00000010 ath_hal_delay
00500ac0 g       *ABS*	00000000 u8ConfigDescriptorEX
0090687c g     F .text	0000003e __adf_nbuf_alloc
0090ac7c g     F .text	00000080 _HIFusb_start_patch
00906cd8 g     F .text	00000007 __adf_nbuf_queue_next
00907638 g     F .text	00000039 db_ascii_to_int
0090a388 g     F .text	00000097 HTCMsgRecvHandler
0090d90c g     F .text	0000006e ath_tx_status_update_aggr
009068bc g     F .text	0000001c __adf_nbuf_free
00512eb4 g     O .bss	00000004 cmd_not_found
008e4914 g       *ABS*	00000000 mUsbFIFOMap
009067c8 g     F .text	00000005 htc_setup_comp
00502430 g       *ABS*	00000000 _bss_table_start
005110cc g     O .data	000002bc ar5416_11ng_table
00906a88 g     F .text	00000009 __adf_nbuf_unmap
00906c58 g     F .text	0000000a __adf_nbuf_headroom
0090edac g     F .text	000000b3 ath_tgt_tx_cleanup
008e3e64 g       *ABS*	00000000 bStandardCommand
008e3b54 g       *ABS*	00000000 bSet_configuration
00909bcc g     F .text	000000a0 wlan_pci_probe
009064d8 g     F .text	0000007c AR6002_fatal_exception_handler_patch
00909dc4 g     F .text	00000041 htc_module_install
00510d00 g       *ABS*	00000000 _dport0_data_end
0090ac44 g     F .text	0000000d cmnos_milliseconds_patch
00512cac g     O .bss	00000004 gpio
00501000 g       *ABS*	00000000 _rodata_start
009094dc g     F .text	00000018 ath_get_minrateidx
00512f10 g       .bss	00000000 _end
008e34a0 g       *ABS*	00000000 _HIFusb_start
0090ac54 g     F .text	00000011 _HIFusb_get_max_msg_len_patch
0090ab94 g     F .text	0000004f zfResetUSBFIFO_patch
0090db0c g     F .text	00000046 ath_tx_status_send
00512eb8 g     O .bss	00000004 cmd_buf_full
0090f119 g       *ABS*	00000000 _iram0_text_start
0090ba84 g     F .text	0000007d ar5416Set11nAggrLast_20
00909f04 g     F .text	0000003f HTCControlSvcProcessSendComplete
00909e20 g     F .text	00000021 HTCAllocMsgBuffer
00511bbc g     O .data	00000004 g_pci_init_func
00909c8c g     F .text	0000000d _HTC_RegisterService
00907ae0 g     F .text	00000026 _ath_hal_attach_tgt
00909ffc g     F .text	000000e0 HTCProcessConnectMsg
0090bb04 g     F .text	0000003e ar5416Clr11nAggr_20
0090c8d0 g     F .text	000002fe rcRateFind_11n
00906c30 g     F .text	00000026 __adf_nbuf_put_tail
0090cdfc g     F .text	0000002c ath_rate_findrate
00512ca8 g     O .bss	00000004 g_wlan_drv
00906354 g     F .text	000000f6 exception_reset
0090b494 g     F .text	00000136 ar5416FillTxDesc_20
00909cdc g     F .text	00000017 HTC_AssembleBuffers
00510e10 g     O .data	000002bc ar5416_11na_table
00512f10 g       *ABS*	00000000 _fw_image_end
00909dbc g     F .text	00000005 _HTC_ResumeRecv
0090db84 g     F .text	00000278 ath_tgt_tx_prepare
0090627c g       .text	00000000 _stext
009079f0 g     F .text	00000023 bSet_configuration_patch
0090ad34 g     F .text	0000000c __adf_os_free_intr
0090b5cc g     F .text	00000021 ar5416FillKeyTxDesc_20
009067d0 g     F .text	0000006e _wmi_cmd_rsp
00512ebc g     O .bss	00000004 pressed_time
00909b64 g     F .text	0000002f wlan_pci_config_write
009062a8 g     F .text	00000046 fatal_exception_func
00909fb8 g     F .text	00000044 _HTC_ReturnBuffersList
0090af8c g     F .text	00000077 ar5416SetupRxDesc_20
009065a8 g     F .text	00000032 HTCControlSvcProcessMsg_patch
008e49a0 g       *ABS*	00000000 mUsbEPinHighBandSet
0090ce88 g     F .text	0000001e ath_rate_newstate
00510d00 g       *ABS*	00000000 _dport0_bss_start
00501000 g       *ABS*	00000000 _dram0_rodata_end
0090be60 g     F .text	000002c9 ar5416ProcTxDesc_20
0090a420 g     F .text	00000005 RedistributeCredit
00907988 g     F .text	00000042 vUSBFIFO_EP6Cfg_FS_patch
00510d00 g       *ABS*	00000000 _dport0_bss_end
00907a14 g     F .text	00000044 bStandardCommand_patch
00512ed4 g     O .bss	0000003c ConfigDescriptorPatch
0090bd24 g     F .text	000000df ar5416GetPendingInterrupts
00501000 g       *ABS*	00000000 _dport0_literal_end
0090b6fc g     F .text	00000278 ar5416Set11nRateScenario_20
0090af74 g     F .text	00000017 ar5416StopPcuReceive



Disassembly of section .boot:

00906000 <app_start>:

extern BOOLEAN bJumptoFlash;
extern BOOLEAN bEepromExist;

void __section(boot) __noreturn __visible app_start(void)
{
  906000:	6c1004        	entry	a1, 32
#if defined(PROJECT_MAGPIE)
	T_EEP_RET retEEP;
#endif

	/* Zero BSS segment & dynamic memory section. */
	init_mem();
  906003:	5801cd        	call8	906738 <init_mem>

#if defined(PROJECT_MAGPIE)
	fatal_exception_func();
  906006:	5800a8        	call8	9062a8 <fatal_exception_func>
#endif

	if( IS_FLASHBOOT() ) {
  906009:	126912        	l32r	a2, 8e0454 <_bss_end+0x3cd544>
  90600c:	136913        	l32r	a3, 8e0458 <_bss_end+0x3cd548>
  90600f:	0c0200        	memw
  906012:	242200        	l32i	a4, a2, 0
  906015:	126915        	l32r	a2, 8e046c <_bss_end+0x3cd55c>
  906018:	04045f        	extui	a4, a4, 16, 16
  90601b:	734935        	bne	a4, a3, 906054 <app_start+0x54>
		athos_indirection_table_install();
  90601e:	5b6d55        	call8	8e1574 <athos_indirection_table_install>
		DBG_MODULE_INSTALL();
  906021:	1a6914        	l32r	a10, 8e0474 <_bss_end+0x3cd564>
  906024:	5805b5        	call8	9076fc <cmnos_dbg_module_install>
		A_CLOCK_INIT(SYSTEM_CLK);
  906027:	1a6916        	l32r	a10, 8e0480 <_bss_end+0x3cd570>
  90602a:	232238        	l32i	a3, a2, 224
  90602d:	0b3000        	callx8	a3
		A_UART_INIT();
  906030:	2a2213        	l32i	a10, a2, 76
  906033:	0ba000        	callx8	a10
		A_PRINTF_INIT();
  906036:	232211        	l32i	a3, a2, 68
  906039:	0b3000        	callx8	a3
		A_DBG_INIT();
  90603c:	23226e        	l32i	a3, a2, 0x1b8
  90603f:	0b3000        	callx8	a3
		A_EEP_INIT();
  906042:	23225f        	l32i	a3, a2, 0x17c
  906045:	0b3000        	callx8	a3
		A_TASKLET_INIT();
  906048:	232269        	l32i	a3, a2, 0x1a4
  90604b:	0b3000        	callx8	a3
		_indir_tbl.cmnos.timer._timer_init();
  90604e:	222241        	l32i	a2, a2, 0x104
  906051:	600002        	j	906057 <app_start+0x57>
		u8UsbInterfaceAlternateSetting = u8UsbConfigValue = u8UsbInterfaceValue = 0;
#endif
	}
#ifdef ROM_VER_1_1
	else
		A_EEP_INIT(); /*Required for 1_1*/
  906054:	22225f        	l32i	a2, a2, 0x17c
  906057:	0b2000        	callx8	a2
#endif

#if defined(PROJECT_MAGPIE)
	retEEP = A_EEP_IS_EXIST();
  90605a:	126915        	l32r	a2, 8e04b0 <_bss_end+0x3cd5a0>
	bJumptoFlash = FALSE;
  90605d:	c040      	movi.n	a4, 0
	else
		A_EEP_INIT(); /*Required for 1_1*/
#endif

#if defined(PROJECT_MAGPIE)
	retEEP = A_EEP_IS_EXIST();
  90605f:	2a2262        	l32i	a10, a2, 0x188
  906062:	0ba000        	callx8	a10
	bJumptoFlash = FALSE;
  906065:	136917        	l32r	a3, 8e04c4 <_bss_end+0x3cd5b4>
  906068:	243500        	s16i	a4, a3, 0
  90606b:	136918        	l32r	a3, 8e04cc <_bss_end+0x3cd5bc>
	if ( RET_SUCCESS == retEEP ) {
  90606e:	cca0      	bnez.n	a10, 906072 <app_start+0x72>
		bEepromExist = TRUE;
  906070:	c041      	movi.n	a4, 1
	} else {
		bEepromExist = FALSE;
	}
#endif

	hostif = A_IS_HOST_PRESENT();
  906072:	8a2e      	l32i.n	a10, a2, 56
	retEEP = A_EEP_IS_EXIST();
	bJumptoFlash = FALSE;
	if ( RET_SUCCESS == retEEP ) {
		bEepromExist = TRUE;
	} else {
		bEepromExist = FALSE;
  906074:	243500        	s16i	a4, a3, 0
	}
#endif

	hostif = A_IS_HOST_PRESENT();
  906077:	0ba000        	callx8	a10
  90607a:	d6a0      	mov.n	a6, a10
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90607c:	136919        	l32r	a3, 8e04e0 <_bss_end+0x3cd5d0>
#elif defined(PROJECT_K2)
	rst_status = ioread32(MAGPIE_REG_RST_STATUS_ADDR);
#endif /* #if defined(PROJECT_MAGPIE) */


	A_PRINTF(" A_WDT_INIT()\n\r");
  90607f:	242212        	l32i	a4, a2, 72
  906082:	1a691a        	l32r	a10, 8e04ec <_bss_end+0x3cd5dc>
  906085:	0c0200        	memw
  906088:	8330      	l32i.n	a3, a3, 0
  90608a:	0b4000        	callx8	a4
		_indir_tbl.cmnos.usb._usb_fw_task = _fw_usb_fw_task;
		_indir_tbl.cmnos.usb._usb_reset_fifo = _fw_usb_reset_fifo;
#endif
	}

	if( rst_status == WDT_MAGIC_PATTERN ) {
  90608d:	14691b        	l32r	a4, 8e04fc <_bss_end+0x3cd5ec>
  906090:	74391d        	bne	a3, a4, 9060b1 <app_start+0xb1>
		A_PRINTF(" ==>WDT reset<==\n");
  906093:	222212        	l32i	a2, a2, 72
  906096:	1a691c        	l32r	a10, 8e0508 <_bss_end+0x3cd5f8>
  906099:	0b2000        	callx8	a2
#if defined(PROJECT_MAGPIE)
		reset_EP4_FIFO();
  90609c:	5800eb        	call8	90644c <reset_EP4_FIFO>
#endif
		*((volatile uint32_t*)WATCH_DOG_RESET_COUNTER_ADDR)+=1;
  90609f:	12691d        	l32r	a2, 8e0514 <_bss_end+0x3cd604>
  9060a2:	0c0200        	memw
  9060a5:	8320      	l32i.n	a3, a2, 0
  9060a7:	b133      	addi.n	a3, a3, 1
  9060a9:	0c0200        	memw
  9060ac:	9320      	s32i.n	a3, a2, 0
  9060ae:	600011        	j	9060c3 <app_start+0xc3>
	} else if (rst_status == SUS_MAGIC_PATTERN) {
  9060b1:	14691e        	l32r	a4, 8e052c <_bss_end+0x3cd61c>
		A_PRINTF(" ==>warm start<==\n");
  9060b4:	222212        	l32i	a2, a2, 72
  9060b7:	1a691f        	l32r	a10, 8e0534 <_bss_end+0x3cd624>
		A_PRINTF(" ==>WDT reset<==\n");
#if defined(PROJECT_MAGPIE)
		reset_EP4_FIFO();
#endif
		*((volatile uint32_t*)WATCH_DOG_RESET_COUNTER_ADDR)+=1;
	} else if (rst_status == SUS_MAGIC_PATTERN) {
  9060ba:	743102        	beq	a3, a4, 9060c0 <app_start+0xc0>
		A_PRINTF(" ==>warm start<==\n");
	} else
		A_PRINTF(" ==>cold start<==\n");
  9060bd:	1a6920        	l32r	a10, 8e0540 <_bss_end+0x3cd630>
  9060c0:	0b2000        	callx8	a2

#if defined(PROJECT_MAGPIE)
	*((volatile uint32_t*)WATCH_DOG_MAGIC_PATTERN_ADDR)=WDT_MAGIC_PATTERN;
  9060c3:	13691b        	l32r	a3, 8e0530 <_bss_end+0x3cd620>
  9060c6:	126919        	l32r	a2, 8e052c <_bss_end+0x3cd61c>
#endif /* #if defined(PROJECT_MAGPIE) */

	/* intr enable would left for firmware */
	/* athos_interrupt_init(); */

	DBG_MODULE_INSTALL();
  9060c9:	1a6914        	l32r	a10, 8e051c <_bss_end+0x3cd60c>
		A_PRINTF(" ==>warm start<==\n");
	} else
		A_PRINTF(" ==>cold start<==\n");

#if defined(PROJECT_MAGPIE)
	*((volatile uint32_t*)WATCH_DOG_MAGIC_PATTERN_ADDR)=WDT_MAGIC_PATTERN;
  9060cc:	0c0200        	memw
  9060cf:	232600        	s32i	a3, a2, 0
#endif /* #if defined(PROJECT_MAGPIE) */

	/* intr enable would left for firmware */
	/* athos_interrupt_init(); */

	DBG_MODULE_INSTALL();
  9060d2:	58058a        	call8	9076fc <cmnos_dbg_module_install>
	SFLASH_MODULE_INSTALL();
	A_SFLASH_INIT();
#endif
#endif

	HIF_MODULE_INSTALL();
  9060d5:	1a6921        	l32r	a10, 8e055c <_bss_end+0x3cd64c>
  9060d8:	5b6d1b        	call8	8e1548 <generic_hif_module_install>
	HTC_MODULE_INSTALL();
  9060db:	1a6922        	l32r	a10, 8e0564 <_bss_end+0x3cd654>
  9060de:	580f39        	call8	909dc4 <htc_module_install>
	WMI_SERVICE_MODULE_INSTALL();
  9060e1:	1a6923        	l32r	a10, 8e0570 <_bss_end+0x3cd660>
  9060e4:	581144        	call8	90a5f8 <WMI_service_module_install>
	BUF_POOL_MODULE_INSTALL();
  9060e7:	1a6924        	l32r	a10, 8e0578 <_bss_end+0x3cd668>
  9060ea:	580332        	call8	906db4 <buf_pool_module_install>
	VBUF_MODULE_INSTALL();
  9060ed:	1a6925        	l32r	a10, 8e0584 <_bss_end+0x3cd674>
  9060f0:	5b7b9b        	call8	8e4f60 <vbuf_module_install>
	VDESC_MODULE_INSTALL();
  9060f3:	1a6926        	l32r	a10, 8e058c <_bss_end+0x3cd67c>
  9060f6:	5b7bc6        	call8	8e5010 <vdesc_module_install>

	//init each module, should be put together..
	A_PRINTF("ALLOCRAM start 0x%x size %d\n", ALLOCRAM_START, ALLOCRAM_SIZE);
  9060f9:	136927        	l32r	a3, 8e0598 <_bss_end+0x3cd688>
  9060fc:	146928        	l32r	a4, 8e059c <_bss_end+0x3cd68c>
  9060ff:	126915        	l32r	a2, 8e0554 <_bss_end+0x3cd644>
  906102:	b437      	addi.n	a7, a3, 4
  906104:	282212        	l32i	a8, a2, 72
  906107:	03450c        	sub	a5, a4, a3
  90610a:	1a6929        	l32r	a10, 8e05b0 <_bss_end+0x3cd6a0>
  90610d:	db70      	mov.n	a11, a7
  90610f:	dc50      	mov.n	a12, a5
  906111:	0b8000        	callx8	a8
	A_ALLOCRAM_INIT(ALLOCRAM_START, ALLOCRAM_SIZE);
  906114:	c78c      	movi.n	a8, -4
  906116:	783107        	beq	a3, a8, 906121 <app_start+0x121>
  906119:	da70      	mov.n	a10, a7
  90611b:	743905        	bne	a3, a4, 906124 <app_start+0x124>
  90611e:	600009        	j	90612b <app_start+0x12b>
  906121:	1a6910        	l32r	a10, 8e0564 <_bss_end+0x3cd654>
  906124:	db50      	mov.n	a11, a5
  906126:	600004        	j	90612e <app_start+0x12e>
  906129:	00001b        	sra	a0, a0
  90612c:	691123        	bnei	a1, 1, 906153 <app_start+0x153>
  90612f:	22510b        	l16ui	a2, a5, 22
  906132:	300065        	excw

	if( hostif == HIF_USB ) {
  906135:	60c513        	j	91264c <_iram0_text_end+0x3533>
		_indir_tbl.hif._get_max_msg_len = _HIFusb_get_max_msg_len_patch;
  906138:	692a23        	bnei	a2, 12, 90615f <app_start+0x15f>
  90613b:	267913        	l16si	a6, a7, 38
		_indir_tbl.cmnos.usb._usb_reg_out = usb_reg_out_patch;
  90613e:	692b23        	bnei	a2, 16, 906165 <app_start+0x165>
  906141:	263313        	excw
		_indir_tbl.hif._isr_handler = _HIFusb_isr_handler_patch;
  906144:	692c23        	bnei	a2, 32, 90616b <app_start+0x16b>
  906147:	267b13        	l32ai	a6, a7, 76
		_indir_tbl.cmnos.usb._usb_set_configuration = bSet_configuration_patch;
  90614a:	692d23        	bnei	a2, 64, 906171 <app_start+0x171>
  90614d:	262613        	s32i	a6, a2, 76
		_indir_tbl.cmnos.usb._usb_status_in = usb_status_in_patch;
  906150:	692e23        	bnei	a2, 128, 906177 <app_start+0x177>
  906153:	263413        	s8i	a6, a3, 19
		_indir_tbl.cmnos.usb._usb_get_descriptor = bGet_descriptor_patch;
  906156:	692f23        	bnei	a2, 0x100, 90617d <app_start+0x17d>
  906159:	263013        	l8ui	a6, a3, 19
		_indir_tbl.cmnos.usb._usb_standard_cmd = bStandardCommand_patch;
  90615c:	693023        	bnei	a3, -1, 906183 <app_start+0x183>
  90615f:	262713        	excw
		_indir_tbl.usbfifo_api._init = _fw_usbfifo_init;
  906162:	693123        	bnei	a3, 1, 906189 <app_start+0x189>
  906165:	269613        	s32i	a6, a9, 76

#if defined(PROJECT_MAGPIE)
		_indir_tbl.cmnos.usb._usb_power_off = zfTurnOffPower_patch;
  906168:	693223        	bnei	a3, 2, 90618f <app_start+0x18f>
  90616b:	262913        	l16si	a6, a2, 38
		_indir_tbl.cmnos.usb._usb_reset_fifo = zfResetUSBFIFO_patch;
  90616e:	693323        	bnei	a3, 3, 906195 <app_start+0x195>
  906171:	262a13        	movi	a6, 0x213
		_indir_tbl.hif._start = _HIFusb_start_patch;
  906174:	693423        	bnei	a3, 4, 90619b <app_start+0x19b>
  906177:	267413        	s8i	a6, a7, 19
		_indir_tbl.htc._HTC_MsgRecvHandler = HTCMsgRecvHandler_patch;
  90617a:	693523        	bnei	a3, 5, 9061a1 <app_start+0x1a1>
  90617d:	268613        	s32i	a6, a8, 76
		_indir_tbl.htc._HTC_ControlSvcProcessMsg = HTCControlSvcProcessMsg_patch;
  906180:	693623        	bnei	a3, 6, 9061a7 <app_start+0x1a7>
  906183:	268812        	excw

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  906186:	693722        	bnei	a3, 7, 9061ac <app_start+0x1ac>
  906189:	200079        	l8ui	a0, a0, 121
#endif

		if (!(ioread8_usb(ZM_MAIN_CTRL_OFFSET) & BIT6))
  90618c:	2f0258        	l32i	a15, a0, 0x160
			vUSBFIFO_EP6Cfg_FS_patch();
  90618f:	05fe12        	srai	a14, a5, 15
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  906192:	693813        	bnei	a3, 8, 9061a9 <app_start+0x1a9>

#ifdef FUSION_USB_ENABLE_TX_STREAM
		// For K2, enable tx stream mode
		A_PRINTF("Enable Tx Stream mode: 0x%x\r\n",
  906195:	69150c        	bnei	a1, 5, 9061a5 <app_start+0x1a5>
  906198:	02008b        	excw
  90619b:	202332        	excw
  90619e:	121a69        	l32r	a2, 8ccb44 <_bss_end+0x3b9c34>
  9061a1:	390b30        	excw
  9061a4:	00da20        	excw
			ioread32_usb(ZM_SOC_USB_MODE_CTRL_OFFSET));

		/* Patch for K2 USB STREAM mode */
		/* disable down stream DMA mode */
		io32_rmw_usb(ZM_SOC_USB_MODE_CTRL_OFFSET, BIT6, BIT0);
  9061a7:	c4b0      	movi.n	a11, 64
  9061a9:	c0c1      	movi.n	a12, 1
  9061ab:	58239d        	call8	90f020 <io32_rmw>
#if SYSTEM_MODULE_HP_EP5
		io32_set_usb(ZM_SOC_USB_MODE_CTRL_OFFSET, BIT8);
  9061ae:	da20      	mov.n	a10, a2
  9061b0:	2b1a00        	movi	a11, 0x100
  9061b3:	c0c0      	movi.n	a12, 0
  9061b5:	58239a        	call8	90f020 <io32_rmw>
#endif

#if SYSTEM_MODULE_HP_EP6
		io32_set_usb(ZM_SOC_USB_MODE_CTRL_OFFSET, BIT9);
  9061b8:	da20      	mov.n	a10, a2
  9061ba:	2b2a00        	movi	a11, 0x200
  9061bd:	c0c0      	movi.n	a12, 0
  9061bf:	582398        	call8	90f020 <io32_rmw>
#endif
		/* enable down stream DMA mode */
		io32_set_usb(ZM_SOC_USB_MODE_CTRL_OFFSET, BIT0);
  9061c2:	da20      	mov.n	a10, a2
  9061c4:	c0b1      	movi.n	a11, 1
  9061c6:	2c0a00        	movi	a12, 0
  9061c9:	582395        	call8	90f020 <io32_rmw>
#endif

#ifdef FUSION_USB_ENABLE_RX_STREAM
		/* Patch for K2 USB STREAM mode */
		/* disable upstream DMA mode and enable upstream stream mode */
		io32_clr_usb(ZM_SOC_USB_MODE_CTRL_OFFSET, BIT1 | BIT3);
  9061cc:	da20      	mov.n	a10, a2
  9061ce:	c0b0      	movi.n	a11, 0
  9061d0:	c0ca      	movi.n	a12, 10
  9061d2:	582393        	call8	90f020 <io32_rmw>

		/* K2, Set maximum IN transfer to 8K */
		io32_rmw_usb(ZM_SOC_USB_MODE_CTRL_OFFSET, 0x20, 0x30);
  9061d5:	da20      	mov.n	a10, a2
  9061d7:	c2b0      	movi.n	a11, 32
  9061d9:	c3c0      	movi.n	a12, 48
  9061db:	582391        	call8	90f020 <io32_rmw>

		/* enable upstream DMA mode */
		io32_set_usb(ZM_SOC_USB_MODE_CTRL_OFFSET, BIT1);
  9061de:	da20      	mov.n	a10, a2
  9061e0:	c0b2      	movi.n	a11, 2
  9061e2:	2c0a00        	movi	a12, 0
  9061e5:	58238e        	call8	90f020 <io32_rmw>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  9061e8:	12693a        	l32r	a2, 8e06d0 <_bss_end+0x3cd7c0>
  9061eb:	230aa0        	movi	a3, 160
  9061ee:	0c0200        	memw
  9061f1:	9320      	s32i.n	a3, a2, 0
  9061f3:	12693b        	l32r	a2, 8e06e0 <_bss_end+0x3cd7d0>
  9061f6:	c039      	movi.n	a3, 9
  9061f8:	0c0200        	memw
  9061fb:	9320      	s32i.n	a3, a2, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  9061fd:	12693c        	l32r	a2, 8e06f0 <_bss_end+0x3cd7e0>
	}
#if defined(PROJECT_MAGPIE) && !defined(ROM_VER_1_1)
	else if (hostif == HIF_PCI )
		hif_pci_patch_install(&_indir_tbl.hif);
#endif
	A_PRINTF("USB mode: 0x%x\r\n", ioread32_usb(0x100));
  906200:	1a693d        	l32r	a10, 8e06f4 <_bss_end+0x3cd7e4>
  906203:	0c0200        	memw
  906206:	8b20      	l32i.n	a11, a2, 0
  906208:	126915        	l32r	a2, 8e065c <_bss_end+0x3cd74c>
  90620b:	232212        	l32i	a3, a2, 72
  90620e:	0b3000        	callx8	a3

	// patch the clock function
	if(1) {
		_indir_tbl.cmnos.clock._clock_init = cmnos_clock_init_patch;
  906211:	13693e        	l32r	a3, 8e070c <_bss_end+0x3cd7fc>
		_indir_tbl.cmnos.clock._delay_us = cmnos_delay_us_patch;
		_indir_tbl.cmnos.clock._clock_tick = cmnos_tick_patch;
		_indir_tbl.cmnos.clock._milliseconds = cmnos_milliseconds_patch;

		//default clock, setup initial variable, SYSTEM_FREQ=40
		A_CLOCK_INIT(SYSTEM_FREQ);
  906214:	2a0a28        	movi	a10, 40
#endif
	A_PRINTF("USB mode: 0x%x\r\n", ioread32_usb(0x100));

	// patch the clock function
	if(1) {
		_indir_tbl.cmnos.clock._clock_init = cmnos_clock_init_patch;
  906217:	232638        	s32i	a3, a2, 224
		_indir_tbl.cmnos.clock._refclk_speed_get = cmnos_refclk_speed_get_patch;
  90621a:	13693f        	l32r	a3, 8e0718 <_bss_end+0x3cd808>
  90621d:	23263d        	s32i	a3, a2, 244
		_indir_tbl.cmnos.clock._delay_us = cmnos_delay_us_patch;
  906220:	136940        	l32r	a3, 8e0720 <_bss_end+0x3cd810>
  906223:	23263b        	s32i	a3, a2, 236
		_indir_tbl.cmnos.clock._clock_tick = cmnos_tick_patch;
  906226:	136941        	l32r	a3, 8e072c <_bss_end+0x3cd81c>
  906229:	232640        	s32i	a3, a2, 0x100
		_indir_tbl.cmnos.clock._milliseconds = cmnos_milliseconds_patch;
  90622c:	136942        	l32r	a3, 8e0734 <_bss_end+0x3cd824>
  90622f:	23263e        	s32i	a3, a2, 248

		//default clock, setup initial variable, SYSTEM_FREQ=40
		A_CLOCK_INIT(SYSTEM_FREQ);
  906232:	58126c        	call8	90abe4 <cmnos_clock_init_patch>
	}

	Magpie_init();
  906235:	580182        	call8	906840 <Magpie_init>

#if MAGPIE_ENABLE_WLAN == 1
	io32_clr(MAGPIE_REG_RST_RESET_ADDR, BIT10 | BIT8 | BIT7 | BIT6);
  906238:	1a6943        	l32r	a10, 8e0744 <_bss_end+0x3cd834>
  90623b:	2b0a00        	movi	a11, 0
  90623e:	2c5ac0        	movi	a12, 0x5c0
  906241:	582377        	call8	90f020 <io32_rmw>
#if defined(PROJECT_MAGPIE)
	io32_set(MAGPIE_REG_AHB_ARB_ADDR, BIT1);
  906244:	1a6944        	l32r	a10, 8e0754 <_bss_end+0x3cd844>
  906247:	2b0a02        	movi	a11, 2
  90624a:	2c0a00        	movi	a12, 0
  90624d:	582374        	call8	90f020 <io32_rmw>
#endif

	wlan_pci_module_init();
  906250:	580e3d        	call8	909b48 <wlan_pci_module_init>
	wlan_pci_probe();
  906253:	580e5e        	call8	909bcc <wlan_pci_probe>
#endif


	A_PRINTF("Tgt running\n\r");
  906256:	1a6945        	l32r	a10, 8e076c <_bss_end+0x3cd85c>
  906259:	232212        	l32i	a3, a2, 72
  90625c:	0b3000        	callx8	a3

#if defined(PROJECT_MAGPIE)
	if(1) {
		A_PRINTF("======= Apply MISC Assert patch\n\r");
  90625f:	1a6946        	l32r	a10, 8e0778 <_bss_end+0x3cd868>
  906262:	232212        	l32i	a3, a2, 72
  906265:	0b3000        	callx8	a3
		_assfail_ori =  _indir_tbl.cmnos.misc._assfail;
  906268:	842a      	l32i.n	a4, a2, 40
  90626a:	136947        	l32r	a3, 8e0788 <_bss_end+0x3cd878>
  90626d:	243600        	s32i	a4, a3, 0
		_indir_tbl.cmnos.misc._assfail = exception_reset;
  906270:	136948        	l32r	a3, 8e0790 <_bss_end+0x3cd880>
  906273:	23260a        	s32i	a3, a2, 40
	}

	change_magpie_clk();
  906276:	58001e        	call8	9062f0 <change_magpie_clk>
#endif
	wlan_task(); //never return
  906279:	58013c        	call8	90676c <wlan_task>

Disassembly of section .text:

0090627c <io32_rmw>:
	iowrite8(addr, val);
}

static inline void io32_rmw(volatile uint32_t addr,
			    const uint32_t set, const uint32_t clr)
{
  90627c:	6c1006        	entry	a1, 48
  90627f:	0c0200        	memw
  906282:	9210      	s32i.n	a2, a1, 0
	uint32_t val;

	val = ioread32(addr);
  906284:	0c0200        	memw
  906287:	8810      	l32i.n	a8, a1, 0
	val &= ~clr;
  906289:	c79f      	movi.n	a9, -1
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90628b:	0c0200        	memw
  90628e:	8880      	l32i.n	a8, a8, 0
			    const uint32_t set, const uint32_t clr)
{
	uint32_t val;

	val = ioread32(addr);
	val &= ~clr;
  906290:	049403        	xor	a4, a9, a4
  906293:	084801        	and	a8, a4, a8
	val |= set;
	iowrite32(addr, val);
  906296:	0c0200        	memw
  906299:	8a10      	l32i.n	a10, a1, 0
{
	uint32_t val;

	val = ioread32(addr);
	val &= ~clr;
	val |= set;
  90629b:	038302        	or	a3, a8, a3
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90629e:	0c0200        	memw
  9062a1:	93a0      	s32i.n	a3, a10, 0
  9062a3:	d10f      	retw.n
  9062a5:	000000        	ill

009062a8 <fatal_exception_func>:

static void idle_task();

#if defined(PROJECT_MAGPIE)
void fatal_exception_func()
{
  9062a8:	6c1004        	entry	a1, 32
	// patch for execption
	(void)_xtos_set_exception_handler(EXCCAUSE_UNALIGNED, AR6002_fatal_exception_handler_patch);
  9062ab:	126949        	l32r	a2, 8e07d0 <_bss_end+0x3cd8c0>
  9062ae:	c0a9      	movi.n	a10, 9
  9062b0:	022b02        	or	a11, a2, a2
  9062b3:	5b8025        	call8	8e6348 <_xtos_set_exception_handler>
	(void)_xtos_set_exception_handler(EXCCAUSE_LOAD_STORE_ERROR, AR6002_fatal_exception_handler_patch);
  9062b6:	db20      	mov.n	a11, a2
  9062b8:	2a0a03        	movi	a10, 3
  9062bb:	5b8023        	call8	8e6348 <_xtos_set_exception_handler>
	(void)_xtos_set_exception_handler(EXCCAUSE_ILLEGAL, AR6002_fatal_exception_handler_patch);
  9062be:	db20      	mov.n	a11, a2
  9062c0:	2a0a00        	movi	a10, 0
  9062c3:	5b8021        	call8	8e6348 <_xtos_set_exception_handler>
	(void)_xtos_set_exception_handler(EXCCAUSE_INSTR_ERROR, AR6002_fatal_exception_handler_patch);
  9062c6:	db20      	mov.n	a11, a2
  9062c8:	2a0a02        	movi	a10, 2
  9062cb:	5b801f        	call8	8e6348 <_xtos_set_exception_handler>
	(void)_xtos_set_exception_handler(EXCCAUSE_PRIVILEGED, AR6002_fatal_exception_handler_patch);
  9062ce:	db20      	mov.n	a11, a2
  9062d0:	2a0a08        	movi	a10, 8
  9062d3:	5b801d        	call8	8e6348 <_xtos_set_exception_handler>
	(void)_xtos_set_exception_handler(EXCCAUSE_INSTR_DATA_ERROR, AR6002_fatal_exception_handler_patch);
  9062d6:	db20      	mov.n	a11, a2
  9062d8:	2a0a0c        	movi	a10, 12
  9062db:	5b801b        	call8	8e6348 <_xtos_set_exception_handler>
	(void)_xtos_set_exception_handler(EXCCAUSE_LOAD_STORE_DATA_ERROR, AR6002_fatal_exception_handler_patch);
  9062de:	db20      	mov.n	a11, a2
  9062e0:	c0ad      	movi.n	a10, 13
  9062e2:	5b8019        	call8	8e6348 <_xtos_set_exception_handler>
	(void)_xtos_set_exception_handler(EXCCAUSE_DIVIDE_BY_ZERO, AR6002_fatal_exception_handler_patch);
  9062e5:	db20      	mov.n	a11, a2
  9062e7:	c0a6      	movi.n	a10, 6
  9062e9:	5b8017        	call8	8e6348 <_xtos_set_exception_handler>
  9062ec:	d10f      	retw.n
	...

009062f0 <change_magpie_clk>:
#endif

#if defined(PROJECT_MAGPIE)
void
change_magpie_clk(void)
{
  9062f0:	6c1004        	entry	a1, 32
  9062f3:	12694a        	l32r	a2, 8e081c <_bss_end+0x3cd90c>
  9062f6:	c131      	movi.n	a3, 17
  9062f8:	0c0200        	memw
  9062fb:	9320      	s32i.n	a3, a2, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  9062fd:	0c0200        	memw
  906300:	8320      	l32i.n	a3, a2, 0
	iowrite32(0x00056004, BIT4 | BIT0);

	/* Wait for the update bit (BIT0) to get cleared */
	while (ioread32(0x00056004) & BIT0)
  906302:	030340        	extui	a3, a3, 0, 1
  906305:	653ff4        	bnez	a3, 9062fd <change_magpie_clk+0xd>
		;

	/* Put the PLL into reset */
	io32_set(0x00050010, BIT1);
  906308:	146943        	l32r	a4, 8e0814 <_bss_end+0x3cd904>
  90630b:	dc30      	mov.n	a12, a3
  90630d:	da40      	mov.n	a10, a4
  90630f:	c0b2      	movi.n	a11, 2
  906311:	5bffda        	call8	90627c <io32_rmw>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  906314:	18694b        	l32r	a8, 8e0840 <_bss_end+0x3cd930>
  906317:	293a25        	movi	a9, 0x325
	 */
	/* Setting PLL to 400MHz */
	iowrite32(0x00056000, 0x325);

	/* Pull CPU PLL out of Reset */
	io32_clr(0x00050010, BIT1);
  90631a:	da40      	mov.n	a10, a4
  90631c:	db30      	mov.n	a11, a3
  90631e:	0c0200        	memw
  906321:	9980      	s32i.n	a9, a8, 0
  906323:	2c0a02        	movi	a12, 2
  906326:	5bffd5        	call8	90627c <io32_rmw>

	A_DELAY_USECS(60); // wait for stable
  906329:	136915        	l32r	a3, 8e0780 <_bss_end+0x3cd870>
  90632c:	c3ac      	movi.n	a10, 60
  90632e:	24323b        	l32i	a4, a3, 236
  906331:	0b4000        	callx8	a4
  906334:	14694c        	l32r	a4, 8e0864 <_bss_end+0x3cd954>
  906337:	0c0200        	memw
  90633a:	9420      	s32i.n	a4, a2, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90633c:	0c0200        	memw
  90633f:	8420      	l32i.n	a4, a2, 0
	/*
	 * AHB clk = ( CPU clk / 2 )
	 */
	iowrite32(0x00056004, 0x00001 | BIT16 | BIT8); /* set plldiv to 2 */

	while (ioread32(0x00056004) & BIT0)
  906341:	7f4ff7        	bbsi	a4, 31, 90633c <change_magpie_clk+0x4c>
		;

	/* UART Setting */
	A_UART_HWINIT((100*1000*1000), 115200);
  906344:	22321a        	l32i	a2, a3, 104
  906347:	1a694d        	l32r	a10, 8e087c <_bss_end+0x3cd96c>
  90634a:	1b694e        	l32r	a11, 8e0884 <_bss_end+0x3cd974>
  90634d:	0b2000        	callx8	a2
  906350:	d10f      	retw.n
	...

00906354 <exception_reset>:

}

void exception_reset(struct register_dump_s *dump)
{
  906354:	6c1004        	entry	a1, 32
	A_PRINTF("exception_reset \n");
  906357:	136915        	l32r	a3, 8e07ac <_bss_end+0x3cd89c>
  90635a:	1a694f        	l32r	a10, 8e0898 <_bss_end+0x3cd988>
  90635d:	243212        	l32i	a4, a3, 72
  906360:	0b4000        	callx8	a4

	/* phase I dump info */
	A_PRINTF("exception reset-phase 1\n");
  906363:	1a6950        	l32r	a10, 8e08a4 <_bss_end+0x3cd994>
  906366:	243212        	l32i	a4, a3, 72
  906369:	0b4000        	callx8	a4
	if(_assfail_ori)
  90636c:	146947        	l32r	a4, 8e0888 <_bss_end+0x3cd978>
  90636f:	8440      	l32i.n	a4, a4, 0
  906371:	c844      	beqz.n	a4, 906379 <exception_reset+0x25>
		_assfail_ori(dump);
  906373:	022a02        	or	a10, a2, a2
  906376:	0b4000        	callx8	a4

	/* phase II reset */
	A_PRINTF("exception reset-phase 2\n");
  906379:	223212        	l32i	a2, a3, 72
  90637c:	1a6951        	l32r	a10, 8e08c0 <_bss_end+0x3cd9b0>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90637f:	c040      	movi.n	a4, 0
  906381:	0b2000        	callx8	a2
  906384:	156919        	l32r	a5, 8e07e8 <_bss_end+0x3cd8d8>
  906387:	12691b        	l32r	a2, 8e07f4 <_bss_end+0x3cd8e4>
	iowrite32(WATCH_DOG_MAGIC_PATTERN_ADDR, WDT_MAGIC_PATTERN);

	io32_set(MAGPIE_REG_RST_RESET_ADDR, BIT10 | BIT8 | BIT7 | BIT6);
  90638a:	2b5ac0        	movi	a11, 0x5c0
  90638d:	0c0200        	memw
  906390:	9250      	s32i.n	a2, a5, 0
  906392:	126943        	l32r	a2, 8e08a0 <_bss_end+0x3cd990>
  906395:	c0c0      	movi.n	a12, 0
  906397:	da20      	mov.n	a10, a2
  906399:	5bffb8        	call8	90627c <io32_rmw>

	io32_set(MAGPIE_REG_AHB_ARB_ADDR, BIT1);
  90639c:	1a6944        	l32r	a10, 8e08ac <_bss_end+0x3cd99c>
  90639f:	2b0a02        	movi	a11, 2
  9063a2:	2c0a00        	movi	a12, 0
  9063a5:	5bffb5        	call8	90627c <io32_rmw>
  9063a8:	166952        	l32r	a6, 8e08f0 <_bss_end+0x3cd9e0>

	iowrite32_usb(ZM_SOC_USB_DMA_RESET_OFFSET, 0x0);
	io32_set(0x50010, BIT4);
  9063ab:	dc40      	mov.n	a12, a4
  9063ad:	0c0200        	memw
  9063b0:	9460      	s32i.n	a4, a6, 0
  9063b2:	da20      	mov.n	a10, a2
  9063b4:	c1b0      	movi.n	a11, 16
  9063b6:	5bffb1        	call8	90627c <io32_rmw>
	A_DELAY_USECS(5);
  9063b9:	28323b        	l32i	a8, a3, 236
  9063bc:	c0a5      	movi.n	a10, 5
  9063be:	0b8000        	callx8	a8
	io32_clr(0x50010, BIT4);
  9063c1:	c1c0      	movi.n	a12, 16
  9063c3:	044b02        	or	a11, a4, a4
  9063c6:	022a02        	or	a10, a2, a2
  9063c9:	5bffac        	call8	90627c <io32_rmw>
	A_DELAY_USECS(5);
  9063cc:	22323b        	l32i	a2, a3, 236
  9063cf:	c0a5      	movi.n	a10, 5
  9063d1:	0b2000        	callx8	a2
  9063d4:	c021      	movi.n	a2, 1
  9063d6:	0c0200        	memw
  9063d9:	226600        	s32i	a2, a6, 0
  9063dc:	16694a        	l32r	a6, 8e0904 <_bss_end+0x3cd9f4>
  9063df:	280a11        	movi	a8, 17
  9063e2:	0c0200        	memw
  9063e5:	286600        	s32i	a8, a6, 0
	iowrite32_usb(ZM_SOC_USB_DMA_RESET_OFFSET, BIT0);

	// set clock to bypass mode - 40Mhz from XTAL
	iowrite32(MAGPIE_REG_CPU_PLL_BYPASS_ADDR, BIT0 | BIT4);
	A_DELAY_USECS(100); // wait for stable
  9063e8:	26323b        	l32i	a6, a3, 236
  9063eb:	2a0a64        	movi	a10, 100
  9063ee:	0b6000        	callx8	a6
  9063f1:	186953        	l32r	a8, 8e0940 <_bss_end+0x3cda30>
  9063f4:	16694b        	l32r	a6, 8e0920 <_bss_end+0x3cda10>
	iowrite32(MAGPIE_REG_CPU_PLL_ADDR, BIT16);

	A_UART_HWINIT((40*1000*1000), 115200);
  9063f7:	1b694e        	l32r	a11, 8e0930 <_bss_end+0x3cda20>
  9063fa:	0c0200        	memw
  9063fd:	9860      	s32i.n	a8, a6, 0
  9063ff:	1a6916        	l32r	a10, 8e0858 <_bss_end+0x3cd948>
  906402:	26321a        	l32i	a6, a3, 104
  906405:	0b6000        	callx8	a6

	A_PRINTF("do TX/RX swap\n");
  906408:	1a6954        	l32r	a10, 8e0958 <_bss_end+0x3cda48>
  90640b:	263212        	l32i	a6, a3, 72
  90640e:	0b6000        	callx8	a6

	MAGPIE_REG_USB_RX0_SWAP_DATA = 0x1;
  906411:	166955        	l32r	a6, 8e0968 <_bss_end+0x3cda58>
	MAGPIE_REG_USB_TX0_SWAP_DATA = 0x1;
	MAGPIE_REG_USB_RX1_SWAP_DATA = 0x1;
	MAGPIE_REG_USB_RX2_SWAP_DATA = 0x1;

        A_PRINTF("Cold reboot initiated.");
  906414:	1a6959        	l32r	a10, 8e0978 <_bss_end+0x3cda68>

	A_UART_HWINIT((40*1000*1000), 115200);

	A_PRINTF("do TX/RX swap\n");

	MAGPIE_REG_USB_RX0_SWAP_DATA = 0x1;
  906417:	0c0200        	memw
  90641a:	9260      	s32i.n	a2, a6, 0
	MAGPIE_REG_USB_TX0_SWAP_DATA = 0x1;
  90641c:	166956        	l32r	a6, 8e0974 <_bss_end+0x3cda64>
  90641f:	0c0200        	memw
  906422:	226600        	s32i	a2, a6, 0
	MAGPIE_REG_USB_RX1_SWAP_DATA = 0x1;
  906425:	166957        	l32r	a6, 8e0984 <_bss_end+0x3cda74>
  906428:	0c0200        	memw
  90642b:	226600        	s32i	a2, a6, 0
	MAGPIE_REG_USB_RX2_SWAP_DATA = 0x1;
  90642e:	166958        	l32r	a6, 8e0990 <_bss_end+0x3cda80>
  906431:	0c0200        	memw
  906434:	226600        	s32i	a2, a6, 0

        A_PRINTF("Cold reboot initiated.");
  906437:	223212        	l32i	a2, a3, 72
  90643a:	0b2000        	callx8	a2
#if defined(PROJECT_MAGPIE)
	iowrite32(WATCH_DOG_MAGIC_PATTERN_ADDR, 0);
#elif defined(PROJECT_K2)
	iowrite32(MAGPIE_REG_RST_STATUS_ADDR, 0);
#endif /* #if defined(PROJECT_MAGPIE) */
	A_USB_JUMP_BOOT();
  90643d:	22322c        	l32i	a2, a3, 176
  906440:	0c0200        	memw
  906443:	9450      	s32i.n	a4, a5, 0
  906445:	0b2000        	callx8	a2
  906448:	d10f      	retw.n
	...

0090644c <reset_EP4_FIFO>:
}

void reset_EP4_FIFO(void)
{
  90644c:	6c1004        	entry	a1, 32
  90644f:	18695a        	l32r	a8, 8e09b8 <_bss_end+0x3cdaa8>
{
	uint8_t val;

	val = ioread8(addr);
	val &= ~clr;
	val |= set;
  906452:	c1a0      	movi.n	a10, 16

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  906454:	298000        	l8ui	a9, a8, 0
  906457:	090947        	extui	a9, a9, 0, 8
{
	uint8_t val;

	val = ioread8(addr);
	val &= ~clr;
	val |= set;
  90645a:	0a9902        	or	a9, a9, a10
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  90645d:	0c0200        	memw
  906460:	298400        	s8i	a9, a8, 0

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  906463:	298000        	l8ui	a9, a8, 0
			    const uint8_t set, const uint8_t clr)
{
	uint8_t val;

	val = ioread8(addr);
	val &= ~clr;
  906466:	c6af      	movi.n	a10, -17

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  906468:	090947        	extui	a9, a9, 0, 8
			    const uint8_t set, const uint8_t clr)
{
	uint8_t val;

	val = ioread8(addr);
	val &= ~clr;
  90646b:	0a9901        	and	a9, a9, a10
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  90646e:	0c0200        	memw
  906471:	298400        	s8i	a9, a8, 0
  906474:	d10f      	retw.n
	...

00906478 <zfGenExceptionEvent>:
	for(i = 0; i < 100; i++) {}
	io8_clr_usb(ZM_EP4_BYTE_COUNT_HIGH_OFFSET, BIT4);
}

LOCAL void zfGenExceptionEvent(uint32_t exccause, uint32_t pc, uint32_t badvaddr)
{
  906478:	6c1004        	entry	a1, 32
	uint32_t pattern = 0x33221199;

	A_PRINTF("<Exception>Tgt Drv send an event 44332211 to Host Drv\n");
  90647b:	186915        	l32r	a8, 8e08d0 <_bss_end+0x3cd9c0>
  90647e:	1a695b        	l32r	a10, 8e09ec <_bss_end+0x3cdadc>
  906481:	288212        	l32i	a8, a8, 72
  906484:	0b8000        	callx8	a8

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  906487:	18695c        	l32r	a8, 8e09f8 <_bss_end+0x3cdae8>
	mUSB_STATUS_IN_INT_DISABLE();
  90648a:	2a0ac0        	movi	a10, 192
  90648d:	298000        	l8ui	a9, a8, 0
  906490:	090947        	extui	a9, a9, 0, 8
  906493:	0a9902        	or	a9, a9, a10
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  906496:	0c0200        	memw
  906499:	298400        	s8i	a9, a8, 0
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90649c:	18693c        	l32r	a8, 8e098c <_bss_end+0x3cda7c>
  90649f:	c09f      	movi.n	a9, 15
  9064a1:	0c0200        	memw
  9064a4:	9980      	s32i.n	a9, a8, 0
  9064a6:	18695d        	l32r	a8, 8e0a1c <_bss_end+0x3cdb0c>
  9064a9:	19695e        	l32r	a9, 8e0a24 <_bss_end+0x3cdb14>
  9064ac:	0c0200        	memw
  9064af:	9980      	s32i.n	a9, a8, 0
  9064b1:	0c0200        	memw
  9064b4:	9280      	s32i.n	a2, a8, 0
  9064b6:	0c0200        	memw
  9064b9:	9380      	s32i.n	a3, a8, 0
  9064bb:	0c0200        	memw
  9064be:	9480      	s32i.n	a4, a8, 0

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  9064c0:	18695f        	l32r	a8, 8e0a3c <_bss_end+0x3cdb2c>
	iowrite32_usb(ZM_EP3_DATA_OFFSET, pattern);
	iowrite32_usb(ZM_EP3_DATA_OFFSET, exccause);
	iowrite32_usb(ZM_EP3_DATA_OFFSET, pc);
	iowrite32_usb(ZM_EP3_DATA_OFFSET, badvaddr);
    
	mUSB_EP3_XFER_DONE();
  9064c3:	c038      	movi.n	a3, 8
  9064c5:	228000        	l8ui	a2, a8, 0
  9064c8:	020247        	extui	a2, a2, 0, 8
  9064cb:	032202        	or	a2, a2, a3
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  9064ce:	0c0200        	memw
  9064d1:	228400        	s8i	a2, a8, 0
  9064d4:	d10f      	retw.n
	...

009064d8 <AR6002_fatal_exception_handler_patch>:
	mUSB_EP3_XFER_DONE();
}

void
AR6002_fatal_exception_handler_patch(CPU_exception_frame_t *exc_frame)
{
  9064d8:	6c1016        	entry	a1, 176
	struct register_dump_s dump;
	uint32_t  exc_cause, exc_vaddr;
	asm volatile("rsr %0,%1" : "=r" (exc_cause) : "n" (EXCCAUSE));
  9064db:	04e830        	rsr.exccause	a4
	asm volatile("rsr %0,%1" : "=r" (exc_vaddr) : "n" (EXCVADDR));
  9064de:	03ee30        	rsr.excvaddr	a3

	dump.exc_frame              = *exc_frame; /* structure copy */
  9064e1:	2c0a80        	movi	a12, 128
  9064e4:	022b02        	or	a11, a2, a2
  9064e7:	2a1c10        	addi	a10, a1, 16
  9064ea:	5b819e        	call8	8e6b64 <memcpy>
	dump.badvaddr               = exc_vaddr;
	dump.exc_frame.xt_exccause  = exc_cause;
	dump.pc                     = exc_frame->xt_pc;
  9064ed:	8b20      	l32i.n	a11, a2, 0
	dump.assline                = 0;

	zfGenExceptionEvent(dump.exc_frame.xt_exccause, dump.pc, dump.badvaddr);
  9064ef:	da40      	mov.n	a10, a4
  9064f1:	dc30      	mov.n	a12, a3

	dump.exc_frame              = *exc_frame; /* structure copy */
	dump.badvaddr               = exc_vaddr;
	dump.exc_frame.xt_exccause  = exc_cause;
	dump.pc                     = exc_frame->xt_pc;
	dump.assline                = 0;
  9064f3:	c020      	movi.n	a2, 0
	uint32_t  exc_cause, exc_vaddr;
	asm volatile("rsr %0,%1" : "=r" (exc_cause) : "n" (EXCCAUSE));
	asm volatile("rsr %0,%1" : "=r" (exc_vaddr) : "n" (EXCVADDR));

	dump.exc_frame              = *exc_frame; /* structure copy */
	dump.badvaddr               = exc_vaddr;
  9064f5:	9313      	s32i.n	a3, a1, 12
	dump.exc_frame.xt_exccause  = exc_cause;
	dump.pc                     = exc_frame->xt_pc;
  9064f7:	9b12      	s32i.n	a11, a1, 8
	dump.assline                = 0;
  9064f9:	9211      	s32i.n	a2, a1, 4
	asm volatile("rsr %0,%1" : "=r" (exc_cause) : "n" (EXCCAUSE));
	asm volatile("rsr %0,%1" : "=r" (exc_vaddr) : "n" (EXCVADDR));

	dump.exc_frame              = *exc_frame; /* structure copy */
	dump.badvaddr               = exc_vaddr;
	dump.exc_frame.xt_exccause  = exc_cause;
  9064fb:	941c      	s32i.n	a4, a1, 48
	dump.pc                     = exc_frame->xt_pc;
	dump.assline                = 0;

	zfGenExceptionEvent(dump.exc_frame.xt_exccause, dump.pc, dump.badvaddr);
  9064fd:	5bffde        	call8	906478 <zfGenExceptionEvent>

#if SYSTEM_MODULE_PRINT
	A_PRINTF("\nFatal exception (%d): \tpc=0x%x \n\r\tbadvaddr=0x%x \n\r\tdump area=0x%x\n",
  906500:	126915        	l32r	a2, 8e0954 <_bss_end+0x3cda44>
  906503:	8b1c      	l32i.n	a11, a1, 48
  906505:	232212        	l32i	a3, a2, 72
  906508:	8c12      	l32i.n	a12, a1, 8
  90650a:	8d13      	l32i.n	a13, a1, 12
  90650c:	1a6960        	l32r	a10, 8e0a8c <_bss_end+0x3cdb7c>
  90650f:	de10      	mov.n	a14, a1
  906511:	0b3000        	callx8	a3
		 dump.exc_frame.xt_exccause, dump.pc, dump.badvaddr, &dump);
	PRINT_FAILURE_STATE();
  906514:	0bb130        	rsr.epc1	a11
  906517:	0cb230        	rsr.epc2	a12
  90651a:	0db330        	rsr.epc3	a13
  90651d:	0eb430        	rsr.epc4	a14
  906520:	1a6961        	l32r	a10, 8e0aa4 <_bss_end+0x3cdb94>
  906523:	232212        	l32i	a3, a2, 72
  906526:	0b3000        	callx8	a3
  906529:	136912        	l32r	a3, 8e0974 <_bss_end+0x3cda64>
  90652c:	1a6962        	l32r	a10, 8e0ab4 <_bss_end+0x3cdba4>
  90652f:	0c0200        	memw
  906532:	8b30      	l32i.n	a11, a3, 0
  906534:	13691d        	l32r	a3, 8e09a8 <_bss_end+0x3cda98>
  906537:	0c0200        	memw
  90653a:	8c30      	l32i.n	a12, a3, 0
  90653c:	136919        	l32r	a3, 8e09a0 <_bss_end+0x3cda90>
  90653f:	0c0200        	memw
  906542:	8d30      	l32i.n	a13, a3, 0
  906544:	232212        	l32i	a3, a2, 72
  906547:	0b3000        	callx8	a3
#else
	A_PUTS("Fatal exception\n\r");
#endif
	A_ASSFAIL(&dump);
  90654a:	822a      	l32i.n	a2, a2, 40
  90654c:	da10      	mov.n	a10, a1
  90654e:	0b2000        	callx8	a2
  906551:	63fffc        	j	906551 <AR6002_fatal_exception_handler_patch+0x79>

00906554 <zfGenWrongEpidEvent>:
    
	mUSB_EP3_XFER_DONE();
}

LOCAL void zfGenWrongEpidEvent(uint32_t epid)
{
  906554:	6c1004        	entry	a1, 32
	uint32_t pattern   = 0x33221299;

	A_PRINTF("<WrongEPID>Tgt Drv send an event 44332212 to Host Drv\n");
  906557:	186915        	l32r	a8, 8e09ac <_bss_end+0x3cda9c>
  90655a:	1a6963        	l32r	a10, 8e0ae8 <_bss_end+0x3cdbd8>
  90655d:	288212        	l32i	a8, a8, 72
  906560:	0b8000        	callx8	a8

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  906563:	18695c        	l32r	a8, 8e0ad4 <_bss_end+0x3cdbc4>
	mUSB_STATUS_IN_INT_DISABLE();
  906566:	2a0ac0        	movi	a10, 192
  906569:	298000        	l8ui	a9, a8, 0
  90656c:	090947        	extui	a9, a9, 0, 8
  90656f:	0a9902        	or	a9, a9, a10
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  906572:	0c0200        	memw
  906575:	298400        	s8i	a9, a8, 0
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  906578:	18693c        	l32r	a8, 8e0a68 <_bss_end+0x3cdb58>
  90657b:	c09f      	movi.n	a9, 15
  90657d:	0c0200        	memw
  906580:	9980      	s32i.n	a9, a8, 0
  906582:	18695d        	l32r	a8, 8e0af8 <_bss_end+0x3cdbe8>
  906585:	196964        	l32r	a9, 8e0b18 <_bss_end+0x3cdc08>
  906588:	0c0200        	memw
  90658b:	9980      	s32i.n	a9, a8, 0
  90658d:	0c0200        	memw
  906590:	9280      	s32i.n	a2, a8, 0

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  906592:	18695f        	l32r	a8, 8e0b10 <_bss_end+0x3cdc00>
	iowrite32_usb(ZM_CBUS_FIFO_SIZE_OFFSET, 0x0f);

	iowrite32_usb(ZM_EP3_DATA_OFFSET, pattern);
	iowrite32_usb(ZM_EP3_DATA_OFFSET, epid);

	mUSB_EP3_XFER_DONE();
  906595:	c098      	movi.n	a9, 8
  906597:	228000        	l8ui	a2, a8, 0
  90659a:	020247        	extui	a2, a2, 0, 8
  90659d:	092202        	or	a2, a2, a9
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  9065a0:	0c0200        	memw
  9065a3:	228400        	s8i	a2, a8, 0
  9065a6:	d10f      	retw.n

009065a8 <HTCControlSvcProcessMsg_patch>:
}

void 
HTCControlSvcProcessMsg_patch(HTC_ENDPOINT_ID EndpointID, adf_nbuf_t hdr_buf,
			      adf_nbuf_t pBuffers, void *arg)
{
  9065a8:	6c1006        	entry	a1, 48
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  9065ab:	da40      	mov.n	a10, a4
  9065ad:	b41b      	addi.n	a11, a1, 4
  9065af:	dc10      	mov.n	a12, a1
  9065b1:	5801bb        	call8	906ca0 <__adf_nbuf_peek_header>
	/* we assume buffers are aligned such that we can access the message
	 * parameters directly*/
	adf_nbuf_peek_header(pBuffers, &anbdata, &anblen);
	pMsg = (HTC_UNKNOWN_MSG *)anbdata;

	if (pMsg->MessageID == HTC_MSG_SETUP_COMPLETE_ID) {
  9065b4:	8811      	l32i.n	a8, a1, 4
  9065b6:	298000        	l8ui	a9, a8, 0
  9065b9:	288001        	l8ui	a8, a8, 1
  9065bc:	089911        	slli	a9, a9, 8
  9065bf:	098802        	or	a8, a8, a9
  9065c2:	698407        	bnei	a8, 4, 9065cd <HTCControlSvcProcessMsg_patch+0x25>
		htc_complete_setup = 1;
  9065c5:	186965        	l32r	a8, 8e0b5c <_bss_end+0x3cdc4c>
  9065c8:	c091      	movi.n	a9, 1
  9065ca:	298400        	s8i	a9, a8, 0
	}

	HTCControlSvcProcessMsg(EndpointID, hdr_buf, pBuffers, arg);
  9065cd:	da20      	mov.n	a10, a2
  9065cf:	db30      	mov.n	a11, a3
  9065d1:	dc40      	mov.n	a12, a4
  9065d3:	dd50      	mov.n	a13, a5
  9065d5:	580ee2        	call8	90a160 <HTCControlSvcProcessMsg>
  9065d8:	d10f      	retw.n
	...

009065dc <HTCMsgRecvHandler_patch>:
}

/* Patch callback for check the endpoint ID is correct or not */
void 
HTCMsgRecvHandler_patch(adf_nbuf_t hdr_buf, adf_nbuf_t buffer, void *context)
{
  9065dc:	6c100a        	entry	a1, 80
	adf_nbuf_t tmp_nbuf;
	HTC_FRAME_HDR *pHTCHdr;
                
	if (hdr_buf == ADF_NBUF_NULL) {
		/* HTC hdr is not in the hdr_buf */
		tmp_nbuf = buffer;
  9065df:	033502        	or	a5, a3, a3
  9065e2:	022539        	movnez	a5, a2, a2
  9065e5:	2b1c24        	addi	a11, a1, 36
  9065e8:	055a02        	or	a10, a5, a5
  9065eb:	2c1c20        	addi	a12, a1, 32
  9065ee:	5801ac        	call8	906ca0 <__adf_nbuf_peek_header>
	} else {
		tmp_nbuf = hdr_buf;
	}
                
	adf_nbuf_peek_header(tmp_nbuf, &anbdata, &anblen);        
	pHTCHdr = (HTC_FRAME_HDR *)anbdata; 
  9065f1:	8619      	l32i.n	a6, a1, 36
  
	eid = pHTCHdr->EndpointID;
  9065f3:	2b6000        	l8ui	a11, a6, 0
    
	if ((eid != 0) && (htc_complete_setup == 0)) {
  9065f6:	64b132        	beqz	a11, 90672c <HTCMsgRecvHandler_patch+0x150>
  9065f9:	186965        	l32r	a8, 8e0b90 <_bss_end+0x3cdc80>
  9065fc:	288000        	l8ui	a8, a8, 0
  9065ff:	658095        	bnez	a8, 906698 <HTCMsgRecvHandler_patch+0xbc>
		A_PRINTF("\nHTC Hdr EndpointID = %d, anblen = %d\n", pHTCHdr->EndpointID, anblen);
  906602:	126915        	l32r	a2, 8e0a58 <_bss_end+0x3cdb48>
  906605:	8c18      	l32i.n	a12, a1, 32
  906607:	232212        	l32i	a3, a2, 72
  90660a:	1a6966        	l32r	a10, 8e0ba4 <_bss_end+0x3cdc94>
  90660d:	0b3000        	callx8	a3
		A_PRINTF("HTC Hder : %2x-%2x-%2x-%2x-%2x-%2x-%2x-%2x-%2x-%2x-%2x-%2x\n",
                         *anbdata, *(anbdata+1), *(anbdata+2), *(anbdata+3), 
  906610:	8819      	l32i.n	a8, a1, 36
  
	eid = pHTCHdr->EndpointID;
    
	if ((eid != 0) && (htc_complete_setup == 0)) {
		A_PRINTF("\nHTC Hdr EndpointID = %d, anblen = %d\n", pHTCHdr->EndpointID, anblen);
		A_PRINTF("HTC Hder : %2x-%2x-%2x-%2x-%2x-%2x-%2x-%2x-%2x-%2x-%2x-%2x\n",
  906612:	1a6967        	l32r	a10, 8e0bb0 <_bss_end+0x3cdca0>
  906615:	238005        	l8ui	a3, a8, 5
  906618:	2b8000        	l8ui	a11, a8, 0
  90661b:	2c8001        	l8ui	a12, a8, 1
  90661e:	2d8002        	l8ui	a13, a8, 2
  906621:	2e8003        	l8ui	a14, a8, 3
  906624:	2f8004        	l8ui	a15, a8, 4
  906627:	9310      	s32i.n	a3, a1, 0
  906629:	238006        	l8ui	a3, a8, 6
  90662c:	9311      	s32i.n	a3, a1, 4
  90662e:	238007        	l8ui	a3, a8, 7
  906631:	9312      	s32i.n	a3, a1, 8
  906633:	238008        	l8ui	a3, a8, 8
  906636:	9313      	s32i.n	a3, a1, 12
  906638:	238009        	l8ui	a3, a8, 9
  90663b:	9314      	s32i.n	a3, a1, 16
  90663d:	23800a        	l8ui	a3, a8, 10
  906640:	9315      	s32i.n	a3, a1, 20
  906642:	23800b        	l8ui	a3, a8, 11
  906645:	9316      	s32i.n	a3, a1, 24
  906647:	232212        	l32i	a3, a2, 72
  90664a:	0b3000        	callx8	a3
                         *anbdata, *(anbdata+1), *(anbdata+2), *(anbdata+3), 
                         *(anbdata+4), *(anbdata+5), *(anbdata+6), *(anbdata+7),
                         *(anbdata+8), *(anbdata+9), *(anbdata+10), *(anbdata+11)); 
		A_PRINTF("init_htc_handle = 0x%8x\n", init_htc_handle);
  90664d:	136969        	l32r	a3, 8e0bf4 <_bss_end+0x3cdce4>
  906650:	242212        	l32i	a4, a2, 72
  906653:	1a6968        	l32r	a10, 8e0bf4 <_bss_end+0x3cdce4>
  906656:	2b3200        	l32i	a11, a3, 0
  906659:	0b4000        	callx8	a4
            
		if (pHTCHdr->EndpointID == 1) {
  90665c:	266000        	l8ui	a6, a6, 0
  90665f:	696112        	bnei	a6, 1, 906675 <HTCMsgRecvHandler_patch+0x99>
			A_PRINTF("Return WMI Command buffer\n");
  906662:	242212        	l32i	a4, a2, 72
  906665:	1a696a        	l32r	a10, 8e0c10 <_bss_end+0x3cdd00>
  906668:	0b4000        	callx8	a4
			HTC_ReturnBuffers(init_htc_handle, 1, tmp_nbuf);
  90666b:	8a30      	l32i.n	a10, a3, 0
  90666d:	222282        	l32i	a2, a2, 0x208
  906670:	db60      	mov.n	a11, a6
  906672:	60001b        	j	906691 <HTCMsgRecvHandler_patch+0xb5>
		} else if ((pHTCHdr->EndpointID == 5) || (pHTCHdr->EndpointID == 6)) {
  906675:	266cfb        	addi	a6, a6, -5
  906678:	060647        	extui	a6, a6, 0, 8
  90667b:	6e6202        	bltui	a6, 2, 906681 <HTCMsgRecvHandler_patch+0xa5>
  90667e:	6000b3        	j	906735 <HTCMsgRecvHandler_patch+0x159>
			A_PRINTF("Return Data buffer\n");
  906681:	242212        	l32i	a4, a2, 72
  906684:	1a696b        	l32r	a10, 8e0c30 <_bss_end+0x3cdd20>
  906687:	0b4000        	callx8	a4
			HTC_ReturnBuffers(init_htc_handle, 6, tmp_nbuf);
  90668a:	8a30      	l32i.n	a10, a3, 0
  90668c:	222282        	l32i	a2, a2, 0x208
  90668f:	c0b6      	movi.n	a11, 6
  906691:	dc50      	mov.n	a12, a5
  906693:	0b2000        	callx8	a2
  906696:	d10f      	retw.n
		} else {
		}
	} else {
		if ((pHTCHdr->EndpointID < 0) || (pHTCHdr->EndpointID >= ENDPOINT_MAX)) {
  906698:	c185      	movi.n	a8, 21
  90669a:	7b8302        	bltu	a8, a11, 9066a0 <HTCMsgRecvHandler_patch+0xc4>
  90669d:	60008b        	j	90672c <HTCMsgRecvHandler_patch+0x150>
			A_PRINTF("HTC Hdr EndpointID = %d, anblen = %d\n", pHTCHdr->EndpointID, anblen);
  9066a0:	126915        	l32r	a2, 8e0af4 <_bss_end+0x3cdbe4>
  9066a3:	8c18      	l32i.n	a12, a1, 32
  9066a5:	232212        	l32i	a3, a2, 72
  9066a8:	1a696c        	l32r	a10, 8e0c58 <_bss_end+0x3cdd48>
			A_PRINTF("HTC Hder : %2x-%2x-%2x-%2x-%2x-%2x-%2x-%2x\n", 
                                 *anbdata, *(anbdata+1), *(anbdata+2), *(anbdata+3), 
                                 *(anbdata+4), *(anbdata+5), *(anbdata+6), *(anbdata+7));

			if (anblen > 64) {
  9066ab:	c440      	movi.n	a4, 64
			HTC_ReturnBuffers(init_htc_handle, 6, tmp_nbuf);
		} else {
		}
	} else {
		if ((pHTCHdr->EndpointID < 0) || (pHTCHdr->EndpointID >= ENDPOINT_MAX)) {
			A_PRINTF("HTC Hdr EndpointID = %d, anblen = %d\n", pHTCHdr->EndpointID, anblen);
  9066ad:	0b3000        	callx8	a3
			A_PRINTF("HTC Hder : %2x-%2x-%2x-%2x-%2x-%2x-%2x-%2x\n", 
                                 *anbdata, *(anbdata+1), *(anbdata+2), *(anbdata+3), 
  9066b0:	8819      	l32i.n	a8, a1, 36
		} else {
		}
	} else {
		if ((pHTCHdr->EndpointID < 0) || (pHTCHdr->EndpointID >= ENDPOINT_MAX)) {
			A_PRINTF("HTC Hdr EndpointID = %d, anblen = %d\n", pHTCHdr->EndpointID, anblen);
			A_PRINTF("HTC Hder : %2x-%2x-%2x-%2x-%2x-%2x-%2x-%2x\n", 
  9066b2:	1a696d        	l32r	a10, 8e0c68 <_bss_end+0x3cdd58>
  9066b5:	238005        	l8ui	a3, a8, 5
  9066b8:	2b8000        	l8ui	a11, a8, 0
  9066bb:	2c8001        	l8ui	a12, a8, 1
  9066be:	2d8002        	l8ui	a13, a8, 2
  9066c1:	2e8003        	l8ui	a14, a8, 3
  9066c4:	2f8004        	l8ui	a15, a8, 4
  9066c7:	9310      	s32i.n	a3, a1, 0
  9066c9:	238006        	l8ui	a3, a8, 6
  9066cc:	9311      	s32i.n	a3, a1, 4
  9066ce:	238007        	l8ui	a3, a8, 7
  9066d1:	231602        	s32i	a3, a1, 8
  9066d4:	232212        	l32i	a3, a2, 72
  9066d7:	0b3000        	callx8	a3
                                 *anbdata, *(anbdata+1), *(anbdata+2), *(anbdata+3), 
                                 *(anbdata+4), *(anbdata+5), *(anbdata+6), *(anbdata+7));

			if (anblen > 64) {
  9066da:	231208        	l32i	a3, a1, 32
  9066dd:	734b20        	bgeu	a4, a3, 906701 <HTCMsgRecvHandler_patch+0x125>
				A_PRINTF("EP1-Tx-Data with Wrong Htc Header Endpoint ID, WAR free this buffer\n");
  9066e0:	232212        	l32i	a3, a2, 72
  9066e3:	1a696e        	l32r	a10, 8e0c9c <_bss_end+0x3cdd8c>
  9066e6:	0b3000        	callx8	a3
				HTC_ReturnBuffers(init_htc_handle, 6, tmp_nbuf);
  9066e9:	146969        	l32r	a4, 8e0c90 <_bss_end+0x3cdd80>
  9066ec:	232282        	l32i	a3, a2, 0x208
  9066ef:	8a40      	l32i.n	a10, a4, 0
  9066f1:	c0b6      	movi.n	a11, 6
  9066f3:	dc50      	mov.n	a12, a5
  9066f5:	0b3000        	callx8	a3
				A_PRINTF("EP1-Tx-Data > Free this buffer successfully\n");
  9066f8:	1a696f        	l32r	a10, 8e0cb4 <_bss_end+0x3cdda4>
  9066fb:	222212        	l32i	a2, a2, 72
  9066fe:	600024        	j	906726 <HTCMsgRecvHandler_patch+0x14a>
			} else {
				A_PRINTF("EP4-WMI-Cmd with Wrong Htc Header Endpoint ID, WAR free this buffer\n");
  906701:	232212        	l32i	a3, a2, 72
  906704:	1a6970        	l32r	a10, 8e0cc4 <_bss_end+0x3cddb4>
  906707:	0b3000        	callx8	a3
				zfGenWrongEpidEvent((a_uint32_t)pHTCHdr->EndpointID);
  90670a:	2a6000        	l8ui	a10, a6, 0
  90670d:	5bff91        	call8	906554 <zfGenWrongEpidEvent>
				HTC_ReturnBuffers(init_htc_handle, 1, tmp_nbuf);
  906710:	146969        	l32r	a4, 8e0cb4 <_bss_end+0x3cdda4>
  906713:	232282        	l32i	a3, a2, 0x208
  906716:	8a40      	l32i.n	a10, a4, 0
  906718:	c0b1      	movi.n	a11, 1
  90671a:	055c02        	or	a12, a5, a5
  90671d:	0b3000        	callx8	a3
				A_PRINTF("EP4-WMI-Cmd > Free this buffer successfully\n");
  906720:	1a6971        	l32r	a10, 8e0ce4 <_bss_end+0x3cddd4>
  906723:	222212        	l32i	a2, a2, 72
  906726:	0b2000        	callx8	a2
  906729:	d10f      	retw.n
  90672b:	00da20        	excw
			}
		} else
			HTCMsgRecvHandler( hdr_buf, buffer, context);
  90672e:	db30      	mov.n	a11, a3
  906730:	dc40      	mov.n	a12, a4
  906732:	580f15        	call8	90a388 <HTCMsgRecvHandler>
  906735:	d10f      	retw.n
	...

00906738 <init_mem>:
	}
}
#endif

void init_mem()
{
  906738:	6c1004        	entry	a1, 32
	int i = 0;
	uint32_t *temp = (uint32_t *)ALLOCRAM_START;

	/* clear bss segment */
	for(temp = (uint32_t *)&START_BSS; temp < (uint32_t *)&END_BSS; temp++)
  90673b:	186972        	l32r	a8, 8e0d04 <_bss_end+0x3cddf4>
  90673e:	196973        	l32r	a9, 8e0d0c <_bss_end+0x3cddfc>
		*temp = 0;
  906741:	c0a0      	movi.n	a10, 0
{
	int i = 0;
	uint32_t *temp = (uint32_t *)ALLOCRAM_START;

	/* clear bss segment */
	for(temp = (uint32_t *)&START_BSS; temp < (uint32_t *)&END_BSS; temp++)
  906743:	600003        	j	90674a <init_mem+0x12>
		*temp = 0;
  906746:	9a80      	s32i.n	a10, a8, 0
{
	int i = 0;
	uint32_t *temp = (uint32_t *)ALLOCRAM_START;

	/* clear bss segment */
	for(temp = (uint32_t *)&START_BSS; temp < (uint32_t *)&END_BSS; temp++)
  906748:	b488      	addi.n	a8, a8, 4
  90674a:	7983f8        	bltu	a8, a9, 906746 <init_mem+0xe>
		*temp = 0;

	/* clear heap segment */
	for(i = 0; i < ((ALLOCRAM_SIZE - 4)/4); i++)
  90674d:	1a6974        	l32r	a10, 8e0d20 <_bss_end+0x3cde10>
  906750:	196927        	l32r	a9, 8e0bec <_bss_end+0x3cdcdc>
  906753:	09a90c        	sub	a9, a10, a9
  906756:	092914        	srli	a9, a9, 2
			HTCMsgRecvHandler( hdr_buf, buffer, context);
	}
}
#endif

void init_mem()
  906759:	08990a        	addx4	a9, a9, a8
	for(temp = (uint32_t *)&START_BSS; temp < (uint32_t *)&END_BSS; temp++)
		*temp = 0;

	/* clear heap segment */
	for(i = 0; i < ((ALLOCRAM_SIZE - 4)/4); i++)
		temp[i] = 0;
  90675c:	c0a0      	movi.n	a10, 0
  90675e:	600003        	j	906765 <init_mem+0x2d>
  906761:	9a80      	s32i.n	a10, a8, 0
  906763:	b488      	addi.n	a8, a8, 4
	/* clear bss segment */
	for(temp = (uint32_t *)&START_BSS; temp < (uint32_t *)&END_BSS; temp++)
		*temp = 0;

	/* clear heap segment */
	for(i = 0; i < ((ALLOCRAM_SIZE - 4)/4); i++)
  906765:	7989f8        	bne	a8, a9, 906761 <init_mem+0x29>
		temp[i] = 0;
}
  906768:	d10f      	retw.n
	...

0090676c <wlan_task>:
	}
	return;
}

void __noreturn wlan_task(void)
{
  90676c:	6c1004        	entry	a1, 32
	loop_low=loop_high=0;
  90676f:	136975        	l32r	a3, 8e0d44 <_bss_end+0x3cde34>
  906772:	c020      	movi.n	a2, 0
  906774:	9230      	s32i.n	a2, a3, 0
  906776:	136976        	l32r	a3, 8e0d50 <_bss_end+0x3cde40>
  906779:	9230      	s32i.n	a2, a3, 0

	while(1) {
		/* update wdt timer */
		A_WDT_TASK();
  90677b:	126915        	l32r	a2, 8e0bd0 <_bss_end+0x3cdcc0>
  90677e:	23225c        	l32i	a3, a2, 0x170
  906781:	0b3000        	callx8	a3

		/* UPDATE cticks - to be moved to idle_tsk, put here will be easier to read  */
		A_CLOCK_TICK();
  906784:	232240        	l32i	a3, a2, 0x100
  906787:	0b3000        	callx8	a3

		HIF_isr_handler(NULL);
  90678a:	23227b        	l32i	a3, a2, 0x1ec
  90678d:	c0a0      	movi.n	a10, 0
  90678f:	0b3000        	callx8	a3

#if MAGPIE_ENABLE_WLAN == 1
		wlan_pci_isr();
  906792:	580d36        	call8	909c6c <wlan_pci_isr>
#endif

		A_TASKLET_RUN();
  906795:	23226d        	l32i	a3, a2, 0x1b4
  906798:	0b3000        	callx8	a3
		A_TIMER_RUN();
  90679b:	232245        	l32i	a3, a2, 0x114
  90679e:	0b3000        	callx8	a3

		/* Very low priority tasks */
		if ((loop_low & 0x1fff) == 0x7)
  9067a1:	136976        	l32r	a3, 8e0d7c <_bss_end+0x3cde6c>
  9067a4:	8830      	l32i.n	a8, a3, 0
  9067a6:	08084c        	extui	a8, a8, 0, 13
  9067a9:	698705        	bnei	a8, 7, 9067b2 <wlan_task+0x46>
			A_DBG_TASK();
  9067ac:	28226f        	l32i	a8, a2, 0x1bc
  9067af:	0b8000        	callx8	a8
		temp[i] = 0;
}

static void idle_task()
{
	if (loop_low == 0xffffffff) {
  9067b2:	8830      	l32i.n	a8, a3, 0
  9067b4:	698008        	bnei	a8, -1, 9067c0 <wlan_task+0x54>
		loop_low = 0;
  9067b7:	c080      	movi.n	a8, 0
  9067b9:	9830      	s32i.n	a8, a3, 0
		loop_high++;
  9067bb:	136975        	l32r	a3, 8e0d90 <_bss_end+0x3cde80>
  9067be:	8830      	l32i.n	a8, a3, 0
	} else {
		loop_low++;
  9067c0:	b188      	addi.n	a8, a8, 1
  9067c2:	9830      	s32i.n	a8, a3, 0
  9067c4:	63ffb6        	j	90677e <wlan_task+0x12>
	...

009067c8 <htc_setup_comp>:
#define MAGPIE 1

#if MAGPIE==1

void htc_setup_comp(void)
{
  9067c8:	6c1004        	entry	a1, 32
  9067cb:	d10f      	retw.n
  9067cd:	000000        	ill

009067d0 <_wmi_cmd_rsp>:
	}
}

void _wmi_cmd_rsp(void *pContext, WMI_COMMAND_ID cmd_id, A_UINT16 SeqNo,
		  A_UINT8 *buffer, int Length)
{
  9067d0:	6c1006        	entry	a1, 48
	adf_nbuf_t netbuf = ADF_NBUF_NULL;
	A_UINT8 *pData;

	netbuf = WMI_AllocEvent(pContext, WMI_EVT_CLASS_CMD_REPLY, sizeof(WMI_CMD_HDR) + Length);
  9067d3:	176915        	l32r	a7, 8e0c28 <_bss_end+0x3cdd18>
  9067d6:	da20      	mov.n	a10, a2
  9067d8:	28728d        	l32i	a8, a7, 0x234
  9067db:	2b0a01        	movi	a11, 1
  9067de:	2c6c04        	addi	a12, a6, 4
  9067e1:	0b8000        	callx8	a8
	}
}

void _wmi_cmd_rsp(void *pContext, WMI_COMMAND_ID cmd_id, A_UINT16 SeqNo,
		  A_UINT8 *buffer, int Length)
{
  9067e4:	04044f        	extui	a4, a4, 0, 16
	adf_nbuf_t netbuf = ADF_NBUF_NULL;
	A_UINT8 *pData;

	netbuf = WMI_AllocEvent(pContext, WMI_EVT_CLASS_CMD_REPLY, sizeof(WMI_CMD_HDR) + Length);
  9067e7:	d8a0      	mov.n	a8, a10
    
	if (netbuf == ADF_NBUF_NULL) {
  9067e9:	cea5      	bnez.n	a10, 906812 <_wmi_cmd_rsp+0x42>
		adf_os_print("%s: buffer allocation for event_id %x failed!\n", __FUNCTION__, cmd_id);
  9067eb:	126978        	l32r	a2, 8e0dcc <_bss_end+0x3cdebc>
  9067ee:	247212        	l32i	a4, a7, 72
  9067f1:	1a6977        	l32r	a10, 8e0dd0 <_bss_end+0x3cdec0>
  9067f4:	022b02        	or	a11, a2, a2
  9067f7:	033c02        	or	a12, a3, a3
  9067fa:	0b4000        	callx8	a4
		adf_os_assert(0);
  9067fd:	1a6979        	l32r	a10, 8e0de4 <_bss_end+0x3cded4>
  906800:	237212        	l32i	a3, a7, 72
  906803:	db20      	mov.n	a11, a2
  906805:	0b3000        	callx8	a3
  906808:	12697a        	l32r	a2, 8e0df0 <_bss_end+0x3cdee0>
  90680b:	0c0200        	memw
  90680e:	8220      	l32i.n	a2, a2, 0
  906810:	d10f      	retw.n
		return;
	}

	if (Length != 0 && buffer != NULL) {
  906812:	c962      	beqz.n	a6, 906828 <_wmi_cmd_rsp+0x58>
  906814:	c950      	beqz.n	a5, 906828 <_wmi_cmd_rsp+0x58>
 *         put, or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_put_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_put_tail(buf, size);
  906816:	db60      	mov.n	a11, a6
  906818:	9810      	s32i.n	a8, a1, 0
  90681a:	580105        	call8	906c30 <__adf_nbuf_put_tail>
}

/* move a memory buffer */
static inline void 		__adf_os_mem_copy(void *dst, const void *src, adf_os_size_t size)
{
    A_MEMCPY(dst,src,size);    
  90681d:	8775      	l32i.n	a7, a7, 20
  90681f:	db50      	mov.n	a11, a5
  906821:	dc60      	mov.n	a12, a6
  906823:	0b7000        	callx8	a7
  906826:	8810      	l32i.n	a8, a1, 0
		pData = (A_UINT8 *)adf_nbuf_put_tail(netbuf, Length);
		adf_os_mem_copy(pData, buffer, Length);
	}

	WMI_SendEvent(pContext, netbuf, cmd_id, SeqNo, Length);
  906828:	156915        	l32r	a5, 8e0c7c <_bss_end+0x3cdd6c>
  90682b:	da20      	mov.n	a10, a2
  90682d:	25528e        	l32i	a5, a5, 0x238
  906830:	db80      	mov.n	a11, a8
  906832:	030c4f        	extui	a12, a3, 0, 16
  906835:	dd40      	mov.n	a13, a4
  906837:	de60      	mov.n	a14, a6
  906839:	0b5000        	callx8	a5
  90683c:	d10f      	retw.n
	...

00906840 <Magpie_init>:
}


void Magpie_init(void)
{
  906840:	6c1004        	entry	a1, 32
	A_PRINTF("[+++Magpie_init]\n\r");
  906843:	126915        	l32r	a2, 8e0c98 <_bss_end+0x3cdd88>
  906846:	1a697b        	l32r	a10, 8e0e34 <_bss_end+0x3cdf24>
  906849:	232212        	l32i	a3, a2, 72
  90684c:	0b3000        	callx8	a3
 
	A_PRINTF("[+++VBUF_init(%d)]\n\r", MAX_BUF_NUM);
  90684f:	13697c        	l32r	a3, 8e0e40 <_bss_end+0x3cdf30>
  906852:	282212        	l32i	a8, a2, 72
  906855:	2b0a64        	movi	a11, 100
  906858:	da30      	mov.n	a10, a3
  90685a:	0b8000        	callx8	a8
	VBUF_init(MAX_BUF_NUM);
  90685d:	2822a0        	l32i	a8, a2, 0x280
  906860:	2a0a64        	movi	a10, 100
  906863:	0b8000        	callx8	a8
    
	A_PRINTF("[+++VBUF_init(%d)]\n\r", MAX_DESC_NUM);
  906866:	282212        	l32i	a8, a2, 72
  906869:	da30      	mov.n	a10, a3
  90686b:	2b0a64        	movi	a11, 100
  90686e:	0b8000        	callx8	a8
	VDESC_init(MAX_DESC_NUM);
  906871:	2222a5        	l32i	a2, a2, 0x294
  906874:	2a0a64        	movi	a10, 100
  906877:	0b2000        	callx8	a2
  90687a:	d10f      	retw.n

0090687c <__adf_nbuf_alloc>:
 * @return newly allocated nbuf
 */
__adf_nbuf_t 
__adf_nbuf_alloc(adf_os_size_t size, a_uint32_t reserve, 
                 a_uint32_t align)
{
  90687c:	6c1004        	entry	a1, 32
    VBUF *buf = NULL;
    VDESC *desc;
    
    buf = VBUF_alloc_vbuf();
  90687f:	156915        	l32r	a5, 8e0cd4 <_bss_end+0x3cddc4>
 * @return newly allocated nbuf
 */
__adf_nbuf_t 
__adf_nbuf_alloc(adf_os_size_t size, a_uint32_t reserve, 
                 a_uint32_t align)
{
  906882:	d620      	mov.n	a6, a2
    VBUF *buf = NULL;
    VDESC *desc;
    
    buf = VBUF_alloc_vbuf();
  906884:	2a52a1        	l32i	a10, a5, 0x284
  906887:	0ba000        	callx8	a10
  90688a:	d2a0      	mov.n	a2, a10
    if ( buf != NULL ) {
  90688c:	64a028        	beqz	a10, 9068b8 <__adf_nbuf_alloc+0x3c>
        desc = VDESC_alloc_vdesc();
  90688f:	2a52a6        	l32i	a10, a5, 0x298
  906892:	0ba000        	callx8	a10
        desc->buf_addr = (A_UINT8 *)A_ALLOCRAM(size);
  906895:	255252        	l32i	a5, a5, 0x148
    VBUF *buf = NULL;
    VDESC *desc;
    
    buf = VBUF_alloc_vbuf();
    if ( buf != NULL ) {
        desc = VDESC_alloc_vdesc();
  906898:	d4a0      	mov.n	a4, a10
        desc->buf_addr = (A_UINT8 *)A_ALLOCRAM(size);
  90689a:	db60      	mov.n	a11, a6
  90689c:	c0a0      	movi.n	a10, 0
  90689e:	0b5000        	callx8	a5
        desc->buf_size = size;
        desc->next_desc = NULL;
  9068a1:	c080      	movi.n	a8, 0
    VDESC *desc;
    
    buf = VBUF_alloc_vbuf();
    if ( buf != NULL ) {
        desc = VDESC_alloc_vdesc();
        desc->buf_addr = (A_UINT8 *)A_ALLOCRAM(size);
  9068a3:	9a41      	s32i.n	a10, a4, 4
        desc->buf_size = size;
  9068a5:	264504        	s16i	a6, a4, 8
        desc->next_desc = NULL;
  9068a8:	9840      	s32i.n	a8, a4, 0
        desc->data_offset = reserve;
  9068aa:	234505        	s16i	a3, a4, 10
        desc->data_size = 0;
  9068ad:	284506        	s16i	a8, a4, 12
        desc->control = 0;    
  9068b0:	284507        	s16i	a8, a4, 14
        
        buf->desc_list = desc;
  9068b3:	9420      	s32i.n	a4, a2, 0
        buf->buf_length = 0;    
  9068b5:	282504        	s16i	a8, a2, 8
    }
    
    return buf;
}   
  9068b8:	d10f      	retw.n
	...

009068bc <__adf_nbuf_free>:
 * @param hdl
 * @param adf_nbuf
 * 
 */
void __adf_nbuf_free(__adf_nbuf_t  buf)
{
  9068bc:	6c1004        	entry	a1, 32
    adf_os_assert(0);
  9068bf:	186915        	l32r	a8, 8e0d14 <_bss_end+0x3cde04>
  9068c2:	1a697d        	l32r	a10, 8e0eb8 <_bss_end+0x3cdfa8>
  9068c5:	288212        	l32i	a8, a8, 72
  9068c8:	1b697e        	l32r	a11, 8e0ec0 <_bss_end+0x3cdfb0>
  9068cb:	0b8000        	callx8	a8
  9068ce:	18697a        	l32r	a8, 8e0eb8 <_bss_end+0x3cdfa8>
  9068d1:	0c0200        	memw
  9068d4:	8880      	l32i.n	a8, a8, 0
  9068d6:	d10f      	retw.n

009068d8 <__adf_nbuf_realloc_headroom>:
 * 
 * @return new nbuf
 */
__adf_nbuf_t 
__adf_nbuf_realloc_headroom(__adf_nbuf_t buf, a_uint32_t headroom)
{
  9068d8:	6c1004        	entry	a1, 32
    adf_os_assert(0);
  9068db:	186915        	l32r	a8, 8e0d30 <_bss_end+0x3cde20>
  9068de:	1b697f        	l32r	a11, 8e0edc <_bss_end+0x3cdfcc>
  9068e1:	288212        	l32i	a8, a8, 72
  9068e4:	1a697d        	l32r	a10, 8e0ed8 <_bss_end+0x3cdfc8>
    return NULL;
}
  9068e7:	c020      	movi.n	a2, 0
 * @return new nbuf
 */
__adf_nbuf_t 
__adf_nbuf_realloc_headroom(__adf_nbuf_t buf, a_uint32_t headroom)
{
    adf_os_assert(0);
  9068e9:	0b8000        	callx8	a8
  9068ec:	18697a        	l32r	a8, 8e0ed4 <_bss_end+0x3cdfc4>
  9068ef:	0c0200        	memw
  9068f2:	8880      	l32i.n	a8, a8, 0
    return NULL;
}
  9068f4:	d10f      	retw.n
	...

009068f8 <__adf_nbuf_realloc_tailroom>:
 * 
 * @return struct mbuf * (buffer with the new tailroom)
 */
__adf_nbuf_t 
__adf_nbuf_realloc_tailroom(__adf_nbuf_t  buf, a_uint32_t tailroom)
{
  9068f8:	6c1004        	entry	a1, 32
    adf_os_assert(0);
  9068fb:	186915        	l32r	a8, 8e0d50 <_bss_end+0x3cde40>
  9068fe:	1b6980        	l32r	a11, 8e0f00 <_bss_end+0x3cdff0>
  906901:	288212        	l32i	a8, a8, 72
  906904:	1a697d        	l32r	a10, 8e0ef8 <_bss_end+0x3cdfe8>
    return NULL;
}
  906907:	c020      	movi.n	a2, 0
 * @return struct mbuf * (buffer with the new tailroom)
 */
__adf_nbuf_t 
__adf_nbuf_realloc_tailroom(__adf_nbuf_t  buf, a_uint32_t tailroom)
{
    adf_os_assert(0);
  906909:	0b8000        	callx8	a8
  90690c:	18697a        	l32r	a8, 8e0ef4 <_bss_end+0x3cdfe4>
  90690f:	0c0200        	memw
  906912:	8880      	l32i.n	a8, a8, 0
    return NULL;
}
  906914:	d10f      	retw.n
	...

00906918 <__adf_nbuf_expand>:
 * 
 * @return struct mbuf* (NULL if something goofed up)
 */
__adf_nbuf_t 
__adf_nbuf_expand(__adf_nbuf_t buf, a_uint32_t headroom, a_uint32_t tailroom)
{
  906918:	6c1004        	entry	a1, 32
    adf_os_assert(0);
  90691b:	186915        	l32r	a8, 8e0d70 <_bss_end+0x3cde60>
  90691e:	1b6981        	l32r	a11, 8e0f24 <_bss_end+0x3ce014>
  906921:	288212        	l32i	a8, a8, 72
  906924:	1a697d        	l32r	a10, 8e0f18 <_bss_end+0x3ce008>
    return NULL;
}
  906927:	c020      	movi.n	a2, 0
 * @return struct mbuf* (NULL if something goofed up)
 */
__adf_nbuf_t 
__adf_nbuf_expand(__adf_nbuf_t buf, a_uint32_t headroom, a_uint32_t tailroom)
{
    adf_os_assert(0);
  906929:	0b8000        	callx8	a8
  90692c:	18697a        	l32r	a8, 8e0f14 <_bss_end+0x3ce004>
  90692f:	0c0200        	memw
  906932:	8880      	l32i.n	a8, a8, 0
    return NULL;
}
  906934:	d10f      	retw.n
	...

00906938 <__adf_nbuf_push_head>:
 * @return new data pointer ,NULL if the len is more than the
 *         space available in the head frag.
 */
a_uint8_t *       
__adf_nbuf_push_head(__adf_nbuf_t buf, adf_os_size_t len)
{
  906938:	6c1004        	entry	a1, 32
    a_uint8_t *ptr = NULL; 
    VDESC *desc = buf->desc_list;
  90693b:	8820      	l32i.n	a8, a2, 0
    
    desc->data_offset -= len;
  90693d:	03034f        	extui	a3, a3, 0, 16
    desc->data_size += len;
  906940:	2a8106        	l16ui	a10, a8, 12
__adf_nbuf_push_head(__adf_nbuf_t buf, adf_os_size_t len)
{
    a_uint8_t *ptr = NULL; 
    VDESC *desc = buf->desc_list;
    
    desc->data_offset -= len;
  906943:	298105        	l16ui	a9, a8, 10
    desc->data_size += len;
  906946:	aa3a      	add.n	a10, a3, a10
  906948:	2a8506        	s16i	a10, a8, 12
__adf_nbuf_push_head(__adf_nbuf_t buf, adf_os_size_t len)
{
    a_uint8_t *ptr = NULL; 
    VDESC *desc = buf->desc_list;
    
    desc->data_offset -= len;
  90694b:	03990c        	sub	a9, a9, a3
    desc->data_size += len;
    buf->buf_length += len;
  90694e:	2a2104        	l16ui	a10, a2, 8
__adf_nbuf_push_head(__adf_nbuf_t buf, adf_os_size_t len)
{
    a_uint8_t *ptr = NULL; 
    VDESC *desc = buf->desc_list;
    
    desc->data_offset -= len;
  906951:	09094f        	extui	a9, a9, 0, 16
  906954:	298505        	s16i	a9, a8, 10
    desc->data_size += len;
    buf->buf_length += len;
  906957:	aa33      	add.n	a3, a3, a10
  906959:	232504        	s16i	a3, a2, 8
    ptr = desc->buf_addr + desc->data_offset;
  90695c:	8281      	l32i.n	a2, a8, 4
    return(ptr);
}
  90695e:	a922      	add.n	a2, a2, a9
  906960:	d10f      	retw.n
	...

00906964 <__adf_nbuf_pull_head>:
 * 
 * @return new data pointer
 */
a_uint8_t * 
__adf_nbuf_pull_head(__adf_nbuf_t buf, adf_os_size_t len)
{
  906964:	6c1004        	entry	a1, 32
    a_uint8_t *ptr = NULL;
    VDESC *desc = buf->desc_list;
  906967:	8820      	l32i.n	a8, a2, 0
    
    desc->data_offset += len;
  906969:	03034f        	extui	a3, a3, 0, 16
    desc->data_size -= len;
  90696c:	2a8106        	l16ui	a10, a8, 12
__adf_nbuf_pull_head(__adf_nbuf_t buf, adf_os_size_t len)
{
    a_uint8_t *ptr = NULL;
    VDESC *desc = buf->desc_list;
    
    desc->data_offset += len;
  90696f:	298105        	l16ui	a9, a8, 10
    desc->data_size -= len;
  906972:	03aa0c        	sub	a10, a10, a3
  906975:	2a8506        	s16i	a10, a8, 12
__adf_nbuf_pull_head(__adf_nbuf_t buf, adf_os_size_t len)
{
    a_uint8_t *ptr = NULL;
    VDESC *desc = buf->desc_list;
    
    desc->data_offset += len;
  906978:	a939      	add.n	a9, a3, a9
    desc->data_size -= len;
    buf->buf_length -= len;
  90697a:	2a2104        	l16ui	a10, a2, 8
__adf_nbuf_pull_head(__adf_nbuf_t buf, adf_os_size_t len)
{
    a_uint8_t *ptr = NULL;
    VDESC *desc = buf->desc_list;
    
    desc->data_offset += len;
  90697d:	09094f        	extui	a9, a9, 0, 16
  906980:	298505        	s16i	a9, a8, 10
    desc->data_size -= len;
    buf->buf_length -= len;
  906983:	03a30c        	sub	a3, a10, a3
  906986:	232504        	s16i	a3, a2, 8
    ptr = desc->buf_addr + desc->data_offset;
  906989:	8281      	l32i.n	a2, a8, 4
    
    return ptr;
}
  90698b:	a922      	add.n	a2, a2, a9
  90698d:	d10f      	retw.n
	...

00906990 <__adf_nbuf_copy>:
 * 
 * @return struct mbuf * (newly allocated buffer)
 */
__adf_nbuf_t 
__adf_nbuf_copy(__adf_nbuf_t src)
{
  906990:	6c1004        	entry	a1, 32
    __adf_nbuf_t buf = NULL; 

    adf_os_assert(src != NULL);
  906993:	cd25      	bnez.n	a2, 9069ac <__adf_nbuf_copy+0x1c>
  906995:	186915        	l32r	a8, 8e0dec <_bss_end+0x3cdedc>
  906998:	1a697d        	l32r	a10, 8e0f8c <_bss_end+0x3ce07c>
  90699b:	288212        	l32i	a8, a8, 72
  90699e:	1b6982        	l32r	a11, 8e0fa8 <_bss_end+0x3ce098>
  9069a1:	0b8000        	callx8	a8
  9069a4:	18697a        	l32r	a8, 8e0f8c <_bss_end+0x3ce07c>
  9069a7:	0c0200        	memw
  9069aa:	8880      	l32i.n	a8, a8, 0
    
    return buf;
}
  9069ac:	c020      	movi.n	a2, 0
  9069ae:	d10f      	retw.n

009069b0 <__adf_nbuf_unshare>:
 * 
 * @return new nbuf
 */
__adf_nbuf_t 
__adf_nbuf_unshare(__adf_nbuf_t  src)
{
  9069b0:	6c1004        	entry	a1, 32
    __adf_nbuf_t buf = NULL;

    adf_os_assert(src != NULL);
  9069b3:	cd25      	bnez.n	a2, 9069cc <__adf_nbuf_unshare+0x1c>
  9069b5:	186915        	l32r	a8, 8e0e0c <_bss_end+0x3cdefc>
  9069b8:	1a697d        	l32r	a10, 8e0fac <_bss_end+0x3ce09c>
  9069bb:	288212        	l32i	a8, a8, 72
  9069be:	1b6983        	l32r	a11, 8e0fcc <_bss_end+0x3ce0bc>
  9069c1:	0b8000        	callx8	a8
  9069c4:	18697a        	l32r	a8, 8e0fac <_bss_end+0x3ce09c>
  9069c7:	0c0200        	memw
  9069ca:	8880      	l32i.n	a8, a8, 0

    return buf;
}
  9069cc:	c020      	movi.n	a2, 0
  9069ce:	d10f      	retw.n

009069d0 <__adf_nbuf_frag_info>:
 * @param[out] sg (scatter/gather list of all the frags)
 * 
 */
void  
__adf_nbuf_frag_info(__adf_nbuf_t buf, adf_os_sglist_t	*sg)
{
  9069d0:	6c1004        	entry	a1, 32
    VDESC *desc = buf->desc_list;
  9069d3:	8820      	l32i.n	a8, a2, 0
  9069d5:	d930      	mov.n	a9, a3
    int count = 0;
  9069d7:	c0a0      	movi.n	a10, 0
    
    while( desc != NULL ) {
  9069d9:	600013        	j	9069f0 <__adf_nbuf_frag_info+0x20>
        sg->sg_segs[count].vaddr = desc->buf_addr + desc->data_offset;
  9069dc:	2b8105        	l16ui	a11, a8, 10
  9069df:	8c81      	l32i.n	a12, a8, 4
        sg->sg_segs[count].len   = desc->data_size;
        
        count++;        
  9069e1:	b1aa      	addi.n	a10, a10, 1
{
    VDESC *desc = buf->desc_list;
    int count = 0;
    
    while( desc != NULL ) {
        sg->sg_segs[count].vaddr = desc->buf_addr + desc->data_offset;
  9069e3:	abcb      	add.n	a11, a12, a11
  9069e5:	9b91      	s32i.n	a11, a9, 4
        sg->sg_segs[count].len   = desc->data_size;
  9069e7:	2b8106        	l16ui	a11, a8, 12
  9069ea:	9b92      	s32i.n	a11, a9, 8
        
        count++;        
        desc = desc->next_desc;
  9069ec:	8880      	l32i.n	a8, a8, 0
  9069ee:	b899      	addi.n	a9, a9, 8
__adf_nbuf_frag_info(__adf_nbuf_t buf, adf_os_sglist_t	*sg)
{
    VDESC *desc = buf->desc_list;
    int count = 0;
    
    while( desc != NULL ) {
  9069f0:	658fe8        	bnez	a8, 9069dc <__adf_nbuf_frag_info+0xc>
        
        count++;        
        desc = desc->next_desc;
    }
    
    sg->nsegs = count;
  9069f3:	9a30      	s32i.n	a10, a3, 0
  9069f5:	d10f      	retw.n
	...

009069f8 <__adf_nbuf_get_priv>:
 * 
 * @return uint8_t* ( pointer to the data )
 */
a_uint8_t *
__adf_nbuf_get_priv(__adf_nbuf_t buf)
{
  9069f8:	6c1004        	entry	a1, 32
    adf_os_assert(buf != NULL);
  9069fb:	cd25      	bnez.n	a2, 906a14 <__adf_nbuf_get_priv+0x1c>
  9069fd:	186915        	l32r	a8, 8e0e54 <_bss_end+0x3cdf44>
  906a00:	1a697d        	l32r	a10, 8e0ff4 <_bss_end+0x3ce0e4>
  906a03:	288212        	l32i	a8, a8, 72
  906a06:	1b6984        	l32r	a11, 8e1018 <_bss_end+0x3ce108>
  906a09:	0b8000        	callx8	a8
  906a0c:	18697a        	l32r	a8, 8e0ff4 <_bss_end+0x3ce0e4>
  906a0f:	0c0200        	memw
  906a12:	8880      	l32i.n	a8, a8, 0

    return buf->ctx;
}
  906a14:	bc22      	addi.n	a2, a2, 12
  906a16:	d10f      	retw.n

00906a18 <__adf_nbuf_queue_add>:
 * 
 */
void 
__adf_nbuf_queue_add(__adf_nbuf_qhead_t  *qhead, 
                     __adf_nbuf_t  buf)
{
  906a18:	6c1004        	entry	a1, 32
    qhead->qlen++;
  906a1b:	8822      	l32i.n	a8, a2, 8
  906a1d:	b188      	addi.n	a8, a8, 1
  906a1f:	9822      	s32i.n	a8, a2, 8

    buf->next_buf = NULL;
  906a21:	c080      	movi.n	a8, 0
  906a23:	9831      	s32i.n	a8, a3, 4

    if (qhead->head == NULL) {
  906a25:	8820      	l32i.n	a8, a2, 0
  906a27:	cc83      	bnez.n	a8, 906a2e <__adf_nbuf_queue_add+0x16>
        qhead->head = buf;
  906a29:	9320      	s32i.n	a3, a2, 0
  906a2b:	600003        	j	906a32 <__adf_nbuf_queue_add+0x1a>
    }
    else {
        qhead->tail->next_buf = buf;
  906a2e:	8821      	l32i.n	a8, a2, 4
  906a30:	9381      	s32i.n	a3, a8, 4
    }
    qhead->tail = buf;
  906a32:	9321      	s32i.n	a3, a2, 4
  906a34:	d10f      	retw.n
	...

00906a38 <__adf_nbuf_queue_remove>:
 * 
 * @return the nbuf
 */
__adf_nbuf_t   
__adf_nbuf_queue_remove(__adf_nbuf_qhead_t *qhead)
{
  906a38:	6c1004        	entry	a1, 32
  906a3b:	d820      	mov.n	a8, a2
    __adf_nbuf_t  b0 = NULL;

    if (qhead->head) {
  906a3d:	8220      	l32i.n	a2, a2, 0
  906a3f:	c929      	beqz.n	a2, 906a5c <__adf_nbuf_queue_remove+0x24>
        qhead->qlen--;
  906a41:	8982      	l32i.n	a9, a8, 8
        b0 = qhead->head;
        if ( qhead->head == qhead->tail ) {
  906a43:	8a81      	l32i.n	a10, a8, 4
__adf_nbuf_queue_remove(__adf_nbuf_qhead_t *qhead)
{
    __adf_nbuf_t  b0 = NULL;

    if (qhead->head) {
        qhead->qlen--;
  906a45:	b099      	addi.n	a9, a9, -1
  906a47:	9982      	s32i.n	a9, a8, 8
  906a49:	c090      	movi.n	a9, 0
        b0 = qhead->head;
        if ( qhead->head == qhead->tail ) {
  906a4b:	7a2907        	bne	a2, a10, 906a56 <__adf_nbuf_queue_remove+0x1e>
            qhead->head = NULL;
  906a4e:	9980      	s32i.n	a9, a8, 0
            qhead->tail = NULL;
  906a50:	9981      	s32i.n	a9, a8, 4
  906a52:	600004        	j	906a5a <__adf_nbuf_queue_remove+0x22>
  906a55:	008a21        	excw
        } else {
            qhead->head = qhead->head->next_buf;
  906a58:	9a80      	s32i.n	a10, a8, 0
        }
    
        b0->next_buf = NULL;
  906a5a:	9921      	s32i.n	a9, a2, 4
    }
	return b0;
}
  906a5c:	d10f      	retw.n
	...

00906a60 <__adf_nbuf_dmamap_create>:
 * 
 * @return a_status_t
 */
a_status_t 
__adf_nbuf_dmamap_create(__adf_os_device_t osdev, __adf_os_dma_map_t *dmap)
{
  906a60:	6c1004        	entry	a1, 32
    a_status_t retval = A_STATUS_OK;
    
    (*dmap) = A_ALLOCRAM(sizeof(struct __adf_dma_map));
  906a63:	126915        	l32r	a2, 8e0eb8 <_bss_end+0x3cdfa8>
  906a66:	c0a0      	movi.n	a10, 0
  906a68:	222252        	l32i	a2, a2, 0x148
  906a6b:	c0bc      	movi.n	a11, 12
  906a6d:	0b2000        	callx8	a2
  906a70:	9a30      	s32i.n	a10, a3, 0
    if(*dmap == NULL)
        return A_STATUS_ENOMEM;
  906a72:	c023      	movi.n	a2, 3
__adf_nbuf_dmamap_create(__adf_os_device_t osdev, __adf_os_dma_map_t *dmap)
{
    a_status_t retval = A_STATUS_OK;
    
    (*dmap) = A_ALLOCRAM(sizeof(struct __adf_dma_map));
    if(*dmap == NULL)
  906a74:	c8a2      	beqz.n	a10, 906a7a <__adf_nbuf_dmamap_create+0x1a>
        return A_STATUS_ENOMEM;
            
    (*dmap)->buf = NULL;
  906a76:	c020      	movi.n	a2, 0
  906a78:	92a0      	s32i.n	a2, a10, 0
    return retval;
}
  906a7a:	d10f      	retw.n

00906a7c <__adf_nbuf_map>:


a_status_t 
__adf_nbuf_map(__adf_os_device_t osdev, __adf_os_dma_map_t bmap, 
                          __adf_nbuf_t buf, adf_os_dma_dir_t dir)
{   
  906a7c:	6c1004        	entry	a1, 32
    bmap->buf = buf;
  906a7f:	9430      	s32i.n	a4, a3, 0
    
    return A_STATUS_OK;
}
  906a81:	c020      	movi.n	a2, 0
  906a83:	d10f      	retw.n
  906a85:	000000        	ill

00906a88 <__adf_nbuf_unmap>:

void 
__adf_nbuf_unmap(__adf_os_device_t osdev, __adf_os_dma_map_t bmap, 
                            adf_os_dma_dir_t dir)
{
  906a88:	6c1004        	entry	a1, 32
    bmap->buf = NULL;
  906a8b:	c080      	movi.n	a8, 0
  906a8d:	9830      	s32i.n	a8, a3, 0
  906a8f:	d10f      	retw.n
  906a91:	000000        	ill

00906a94 <__adf_nbuf_dmamap_destroy>:
}

void
__adf_nbuf_dmamap_destroy(__adf_os_device_t osdev, 
                          __adf_os_dma_map_t dmap)
{
  906a94:	6c1004        	entry	a1, 32
  906a97:	d10f      	retw.n
  906a99:	000000        	ill

00906a9c <__adf_nbuf_dmamap_info>:
 * @param[in]  bmap
 * @param[out] sg (map_info ptr)
 */
void 
__adf_nbuf_dmamap_info(__adf_os_dma_map_t bmap, adf_os_dmamap_info_t *sg)
{
  906a9c:	6c1004        	entry	a1, 32
    VDESC *desc = bmap->buf->desc_list;
  906a9f:	8820      	l32i.n	a8, a2, 0
  906aa1:	d930      	mov.n	a9, a3
  906aa3:	8880      	l32i.n	a8, a8, 0
    int count = 0;
  906aa5:	c0a0      	movi.n	a10, 0
    
    while( desc != NULL ) {
  906aa7:	600015        	j	906ac0 <__adf_nbuf_dmamap_info+0x24>
  906aaa:	00002b        	mulsh	a0, a0, a0
        sg->dma_segs[count].paddr = (adf_os_dma_addr_t)(desc->buf_addr + desc->data_offset);
  906aad:	8105      	l32i.n	a1, a0, 20
  906aaf:	8c81      	l32i.n	a12, a8, 4
        sg->dma_segs[count].len   = desc->data_size;
        
        count++;        
  906ab1:	b1aa      	addi.n	a10, a10, 1
{
    VDESC *desc = bmap->buf->desc_list;
    int count = 0;
    
    while( desc != NULL ) {
        sg->dma_segs[count].paddr = (adf_os_dma_addr_t)(desc->buf_addr + desc->data_offset);
  906ab3:	abcb      	add.n	a11, a12, a11
  906ab5:	9b91      	s32i.n	a11, a9, 4
        sg->dma_segs[count].len   = desc->data_size;
  906ab7:	2b8106        	l16ui	a11, a8, 12
        
        count++;        
        desc = desc->next_desc;
  906aba:	8880      	l32i.n	a8, a8, 0
    VDESC *desc = bmap->buf->desc_list;
    int count = 0;
    
    while( desc != NULL ) {
        sg->dma_segs[count].paddr = (adf_os_dma_addr_t)(desc->buf_addr + desc->data_offset);
        sg->dma_segs[count].len   = desc->data_size;
  906abc:	9b92      	s32i.n	a11, a9, 8
  906abe:	b899      	addi.n	a9, a9, 8
__adf_nbuf_dmamap_info(__adf_os_dma_map_t bmap, adf_os_dmamap_info_t *sg)
{
    VDESC *desc = bmap->buf->desc_list;
    int count = 0;
    
    while( desc != NULL ) {
  906ac0:	658fe8        	bnez	a8, 906aac <__adf_nbuf_dmamap_info+0x10>
        
        count++;        
        desc = desc->next_desc;
    }
    
    sg->nsegs = count;    
  906ac3:	9a30      	s32i.n	a10, a3, 0
  906ac5:	d10f      	retw.n
	...

00906ac8 <__adf_nbuf_set_rx_cksum>:
 * @param buf
 * @param cksum
 */
void 
__adf_nbuf_set_rx_cksum(__adf_nbuf_t buf, adf_nbuf_rx_cksum_t *cksum)
{
  906ac8:	6c1004        	entry	a1, 32
  906acb:	d10f      	retw.n
  906acd:	000000        	ill

00906ad0 <__adf_nbuf_get_vlan_info>:
}

a_status_t      
__adf_nbuf_get_vlan_info(adf_net_handle_t hdl, __adf_nbuf_t buf, 
                         adf_net_vlanhdr_t *vlan)
{
  906ad0:	6c1004        	entry	a1, 32
    return A_STATUS_OK;
}
  906ad3:	c020      	movi.n	a2, 0
  906ad5:	d10f      	retw.n
	...

00906ad8 <__adf_nbuf_create_frm_frag>:

__adf_nbuf_t
__adf_nbuf_create_frm_frag(__adf_nbuf_queue_t *qhead)
{
  906ad8:	6c1004        	entry	a1, 32
    VBUF *buf_tmp, *buf_head = NULL;
    VDESC *vdesc_prev = NULL, *vdesc_tmp = NULL;
    a_uint32_t cnt = 0, len = __adf_nbuf_queue_len(qhead);
    a_uint16_t total_len = 0;

    buf_head = VBUF_alloc_vbuf();
  906adb:	166915        	l32r	a6, 8e0f30 <_bss_end+0x3ce020>
    return A_STATUS_OK;
}

__adf_nbuf_t
__adf_nbuf_create_frm_frag(__adf_nbuf_queue_t *qhead)
{
  906ade:	022402        	or	a4, a2, a2
    VBUF *buf_tmp, *buf_head = NULL;
    VDESC *vdesc_prev = NULL, *vdesc_tmp = NULL;
    a_uint32_t cnt = 0, len = __adf_nbuf_queue_len(qhead);
    a_uint16_t total_len = 0;

    buf_head = VBUF_alloc_vbuf();
  906ae1:	2a62a1        	l32i	a10, a6, 0x284
 * 
 */
a_uint32_t  
__adf_nbuf_queue_len(__adf_nbuf_qhead_t *qhead)
{
    return qhead->qlen;
  906ae4:	252202        	l32i	a5, a2, 8
    VBUF *buf_tmp, *buf_head = NULL;
    VDESC *vdesc_prev = NULL, *vdesc_tmp = NULL;
    a_uint32_t cnt = 0, len = __adf_nbuf_queue_len(qhead);
    a_uint16_t total_len = 0;

    buf_head = VBUF_alloc_vbuf();
  906ae7:	0ba000        	callx8	a10
  906aea:	d2a0      	mov.n	a2, a10
 * @return (NULL if the Q is empty)
 */
__adf_nbuf_t   
__adf_nbuf_queue_first(__adf_nbuf_queue_t *qhead)
{
    return qhead->head;
  906aec:	8340      	l32i.n	a3, a4, 0
    a_uint16_t total_len = 0;

    buf_head = VBUF_alloc_vbuf();
    buf_tmp = __adf_nbuf_queue_first(qhead);

    __adf_os_assert(buf_head);
  906aee:	cda2      	bnez.n	a10, 906b04 <__adf_nbuf_create_frm_frag+0x2c>
  906af0:	266212        	l32i	a6, a6, 72
  906af3:	1a697d        	l32r	a10, 8e10e8 <_bss_end+0x3ce1d8>
  906af6:	1b6985        	l32r	a11, 8e110c <_bss_end+0x3ce1fc>
  906af9:	0b6000        	callx8	a6
  906afc:	16697a        	l32r	a6, 8e10e4 <_bss_end+0x3ce1d4>
  906aff:	0c0200        	memw
  906b02:	8660      	l32i.n	a6, a6, 0
    __adf_os_assert(buf_tmp);
  906b04:	cd35      	bnez.n	a3, 906b1d <__adf_nbuf_create_frm_frag+0x45>
  906b06:	166915        	l32r	a6, 8e0f5c <_bss_end+0x3ce04c>
  906b09:	1a697d        	l32r	a10, 8e1100 <_bss_end+0x3ce1f0>
  906b0c:	266212        	l32i	a6, a6, 72
  906b0f:	1b6985        	l32r	a11, 8e1124 <_bss_end+0x3ce214>
  906b12:	0b6000        	callx8	a6
  906b15:	16697a        	l32r	a6, 8e1100 <_bss_end+0x3ce1f0>
  906b18:	0c0200        	memw
  906b1b:	8660      	l32i.n	a6, a6, 0

    buf_head->desc_list = buf_tmp->desc_list;
  906b1d:	8330      	l32i.n	a3, a3, 0
  906b1f:	9320      	s32i.n	a3, a2, 0
__adf_nbuf_create_frm_frag(__adf_nbuf_queue_t *qhead)
{
    VBUF *buf_tmp, *buf_head = NULL;
    VDESC *vdesc_prev = NULL, *vdesc_tmp = NULL;
    a_uint32_t cnt = 0, len = __adf_nbuf_queue_len(qhead);
    a_uint16_t total_len = 0;
  906b21:	c030      	movi.n	a3, 0
__adf_nbuf_t
__adf_nbuf_create_frm_frag(__adf_nbuf_queue_t *qhead)
{
    VBUF *buf_tmp, *buf_head = NULL;
    VDESC *vdesc_prev = NULL, *vdesc_tmp = NULL;
    a_uint32_t cnt = 0, len = __adf_nbuf_queue_len(qhead);
  906b23:	d730      	mov.n	a7, a3

__adf_nbuf_t
__adf_nbuf_create_frm_frag(__adf_nbuf_queue_t *qhead)
{
    VBUF *buf_tmp, *buf_head = NULL;
    VDESC *vdesc_prev = NULL, *vdesc_tmp = NULL;
  906b25:	d630      	mov.n	a6, a3
    __adf_os_assert(buf_head);
    __adf_os_assert(buf_tmp);

    buf_head->desc_list = buf_tmp->desc_list;

    while ((buf_tmp = __adf_nbuf_queue_remove(qhead)) != NULL) {
  906b27:	60002d        	j	906b58 <__adf_nbuf_create_frm_frag+0x80>
  906b2a:	000029        	excw
        cnt++;

        //adf_os_print("merge buf: %x\n", buf_tmp->desc_list->buf_addr + buf_tmp->desc_list->data_offset);

        total_len += buf_tmp->buf_length;
  906b2d:	a104      	add.n	a4, a0, a1
    __adf_os_assert(buf_tmp);

    buf_head->desc_list = buf_tmp->desc_list;

    while ((buf_tmp = __adf_nbuf_queue_remove(qhead)) != NULL) {
        cnt++;
  906b2f:	b177      	addi.n	a7, a7, 1

        //adf_os_print("merge buf: %x\n", buf_tmp->desc_list->buf_addr + buf_tmp->desc_list->data_offset);

        total_len += buf_tmp->buf_length;
  906b31:	a933      	add.n	a3, a3, a9
  906b33:	03034f        	extui	a3, a3, 0, 16
  906b36:	89a0      	l32i.n	a9, a10, 0

        if (vdesc_prev) {
  906b38:	c860      	beqz.n	a6, 906b3c <__adf_nbuf_create_frm_frag+0x64>
            /* link "the last VDESC of previous VBUF" to "the 1st VDESC of this VBUF" */
            vdesc_prev->next_desc = buf_tmp->desc_list;
  906b3a:	9960      	s32i.n	a9, a6, 0
        }

        /* traverse VDESC list in this VBUF to find out the last VDESC */
        vdesc_tmp = buf_tmp->desc_list;
  906b3c:	d690      	mov.n	a6, a9
        while (vdesc_tmp->next_desc) {
  906b3e:	600002        	j	906b44 <__adf_nbuf_create_frm_frag+0x6c>
  906b41:	00d680        	excw
  906b44:	8860      	l32i.n	a8, a6, 0
  906b46:	658ff8        	bnez	a8, 906b42 <__adf_nbuf_create_frm_frag+0x6a>
        vdesc_prev = vdesc_tmp;

        /* return VBUF to the pool */
        buf_tmp->desc_list = NULL;
        buf_tmp->buf_length = 0;
        VBUF_free_vbuf(buf_tmp);
  906b49:	196915        	l32r	a9, 8e0fa0 <_bss_end+0x3ce090>
            vdesc_tmp = vdesc_tmp->next_desc;
        }
        vdesc_prev = vdesc_tmp;

        /* return VBUF to the pool */
        buf_tmp->desc_list = NULL;
  906b4c:	28a600        	s32i	a8, a10, 0
        buf_tmp->buf_length = 0;
  906b4f:	28a504        	s16i	a8, a10, 8
        VBUF_free_vbuf(buf_tmp);
  906b52:	2892a3        	l32i	a8, a9, 0x28c
  906b55:	0b8000        	callx8	a8
    __adf_os_assert(buf_head);
    __adf_os_assert(buf_tmp);

    buf_head->desc_list = buf_tmp->desc_list;

    while ((buf_tmp = __adf_nbuf_queue_remove(qhead)) != NULL) {
  906b58:	da40      	mov.n	a10, a4
  906b5a:	5bffb7        	call8	906a38 <__adf_nbuf_queue_remove>
  906b5d:	65afcb        	bnez	a10, 906b2c <__adf_nbuf_create_frm_frag+0x54>
        buf_tmp->desc_list = NULL;
        buf_tmp->buf_length = 0;
        VBUF_free_vbuf(buf_tmp);
    }

    if (cnt != len) {
  906b60:	757116        	beq	a7, a5, 906b7a <__adf_nbuf_create_frm_frag+0xa2>
        //adf_os_print("cnt: %x, len: %x, __adf_nbuf_queue_len: %x\n", cnt, len, 
        //             __adf_nbuf_queue_len(qhead));
        adf_os_assert(0);
  906b63:	146915        	l32r	a4, 8e0fb8 <_bss_end+0x3ce0a8>
  906b66:	1a697d        	l32r	a10, 8e115c <_bss_end+0x3ce24c>
  906b69:	244212        	l32i	a4, a4, 72
  906b6c:	1b6985        	l32r	a11, 8e1180 <_bss_end+0x3ce270>
  906b6f:	0b4000        	callx8	a4
  906b72:	14697a        	l32r	a4, 8e115c <_bss_end+0x3ce24c>
  906b75:	0c0200        	memw
  906b78:	8440      	l32i.n	a4, a4, 0
    }
    //__adf_os_assert(cnt == len);

    buf_head->buf_length = total_len;
  906b7a:	232504        	s16i	a3, a2, 8

    return buf_head;
}
  906b7d:	d10f      	retw.n
	...

00906b80 <__adf_nbuf_split_to_frag>:

void
__adf_nbuf_split_to_frag(__adf_nbuf_t buf, __adf_nbuf_qhead_t *qhead)
{
  906b80:	6c1004        	entry	a1, 32
 * @param qhead
 */
void 
__adf_nbuf_queue_init(__adf_nbuf_qhead_t *qhead)
{
    qhead->qlen = 0;
  906b83:	c040      	movi.n	a4, 0
  906b85:	9432      	s32i.n	a4, a3, 8
    qhead->head = NULL;
  906b87:	9430      	s32i.n	a4, a3, 0
    qhead->tail = NULL;
  906b89:	9431      	s32i.n	a4, a3, 4
  906b8b:	166915        	l32r	a6, 8e0fe0 <_bss_end+0x3ce0d0>
{
    VBUF *buf_tmp;
    VDESC *desc_tmp = NULL;

    __adf_nbuf_queue_init(qhead);
    desc_tmp = buf->desc_list;
  906b8e:	8420      	l32i.n	a4, a2, 0

    while (desc_tmp /*&& desc_tmp->buf_addr*/) {
  906b90:	60003a        	j	906bce <__adf_nbuf_split_to_frag+0x4e>
  906b93:	00002a        	muluh	a0, a0, a0
        buf_tmp = VBUF_alloc_vbuf();
  906b96:	62a10b        	j	8f0ca5 <memset+0x9e5d>
  906b99:	a000      	add.n	a0, a0, a0
  906b9b:	d5a0      	mov.n	a5, a10

        __adf_os_assert(buf_tmp);
  906b9d:	65a014        	bnez	a10, 906bb5 <__adf_nbuf_split_to_frag+0x35>
  906ba0:	276212        	l32i	a7, a6, 72
  906ba3:	1a697d        	l32r	a10, 8e1198 <_bss_end+0x3ce288>
  906ba6:	1b6986        	l32r	a11, 8e11c0 <_bss_end+0x3ce2b0>
  906ba9:	0b7000        	callx8	a7
  906bac:	17697a        	l32r	a7, 8e1194 <_bss_end+0x3ce284>
  906baf:	0c0200        	memw
  906bb2:	277200        	l32i	a7, a7, 0

        //desc_tmp->data_size = 0;
        buf_tmp->desc_list = desc_tmp;
        //buf_tmp->buf_length = desc_tmp->buf_size;
        buf_tmp->buf_length = desc_tmp->data_size;
  906bb5:	274106        	l16ui	a7, a4, 12
        buf_tmp = VBUF_alloc_vbuf();

        __adf_os_assert(buf_tmp);

        //desc_tmp->data_size = 0;
        buf_tmp->desc_list = desc_tmp;
  906bb8:	9450      	s32i.n	a4, a5, 0
        //buf_tmp->buf_length = desc_tmp->buf_size;
        buf_tmp->buf_length = desc_tmp->data_size;
  906bba:	275504        	s16i	a7, a5, 8
        buf_tmp->next_buf = NULL;
  906bbd:	c070      	movi.n	a7, 0
  906bbf:	9751      	s32i.n	a7, a5, 4

        //adf_os_print("split - buf: %x\n", buf_tmp->desc_list->buf_addr + buf_tmp->desc_list->data_offset);

        __adf_nbuf_queue_add(qhead, buf_tmp);
  906bc1:	db50      	mov.n	a11, a5
  906bc3:	da30      	mov.n	a10, a3
  906bc5:	5bff94        	call8	906a18 <__adf_nbuf_queue_add>

        desc_tmp = desc_tmp->next_desc;

        buf_tmp->desc_list->next_desc = NULL;
  906bc8:	8550      	l32i.n	a5, a5, 0

        //adf_os_print("split - buf: %x\n", buf_tmp->desc_list->buf_addr + buf_tmp->desc_list->data_offset);

        __adf_nbuf_queue_add(qhead, buf_tmp);

        desc_tmp = desc_tmp->next_desc;
  906bca:	8440      	l32i.n	a4, a4, 0

        buf_tmp->desc_list->next_desc = NULL;
  906bcc:	9750      	s32i.n	a7, a5, 0
    VDESC *desc_tmp = NULL;

    __adf_nbuf_queue_init(qhead);
    desc_tmp = buf->desc_list;

    while (desc_tmp /*&& desc_tmp->buf_addr*/) {
  906bce:	654fc3        	bnez	a4, 906b95 <__adf_nbuf_split_to_frag+0x15>
        buf_tmp->desc_list->next_desc = NULL;
    }

    buf->desc_list = NULL;
    buf->buf_length = 0;
    VBUF_free_vbuf(buf);
  906bd1:	2362a3        	l32i	a3, a6, 0x28c
        desc_tmp = desc_tmp->next_desc;

        buf_tmp->desc_list->next_desc = NULL;
    }

    buf->desc_list = NULL;
  906bd4:	9420      	s32i.n	a4, a2, 0
    buf->buf_length = 0;
  906bd6:	242504        	s16i	a4, a2, 8
    VBUF_free_vbuf(buf);
  906bd9:	da20      	mov.n	a10, a2
  906bdb:	0b3000        	callx8	a3
  906bde:	d10f      	retw.n

00906be0 <__adf_nbuf_last>:
 * 
 * @return struct mbuf*
 */
VDESC * 
__adf_nbuf_last(VBUF *buf)
{
  906be0:	6c1004        	entry	a1, 32
    VDESC *desc = buf->desc_list;
  906be3:	8220      	l32i.n	a2, a2, 0
    
    //for(; desc->next_desc != NULL; desc = desc->next_desc)
    //    ;
    while(desc->next_desc != NULL)
  906be5:	600001        	j	906bea <__adf_nbuf_last+0xa>
    {
        desc = desc->next_desc;
  906be8:	d280      	mov.n	a2, a8
{
    VDESC *desc = buf->desc_list;
    
    //for(; desc->next_desc != NULL; desc = desc->next_desc)
    //    ;
    while(desc->next_desc != NULL)
  906bea:	8820      	l32i.n	a8, a2, 0
  906bec:	658ff8        	bnez	a8, 906be8 <__adf_nbuf_last+0x8>
    {
        desc = desc->next_desc;
    }
    
    return desc;
}
  906bef:	d10f      	retw.n
  906bf1:	000000        	ill

00906bf4 <__adf_nbuf_trim_tail>:
 * @param len (how much to strip down)
 * 
 */
void 
__adf_nbuf_trim_tail(__adf_nbuf_t buf, adf_os_size_t len)
{
  906bf4:	6c1004        	entry	a1, 32
    VDESC *last_desc = __adf_nbuf_last(buf);
  906bf7:	022a02        	or	a10, a2, a2
  906bfa:	5bfff9        	call8	906be0 <__adf_nbuf_last>
  906bfd:	d4a0      	mov.n	a4, a10
    
    adf_os_assert(buf != NULL);
  906bff:	cd25      	bnez.n	a2, 906c18 <__adf_nbuf_trim_tail+0x24>
  906c01:	186915        	l32r	a8, 8e1058 <_bss_end+0x3ce148>
  906c04:	1a697d        	l32r	a10, 8e11f8 <_bss_end+0x3ce2e8>
  906c07:	288212        	l32i	a8, a8, 72
  906c0a:	1b6987        	l32r	a11, 8e1228 <_bss_end+0x3ce318>
  906c0d:	0b8000        	callx8	a8
  906c10:	18697a        	l32r	a8, 8e11f8 <_bss_end+0x3ce2e8>
  906c13:	0c0200        	memw
  906c16:	8880      	l32i.n	a8, a8, 0
    last_desc->data_size -= len;
  906c18:	284106        	l16ui	a8, a4, 12
  906c1b:	03034f        	extui	a3, a3, 0, 16
  906c1e:	03880c        	sub	a8, a8, a3
  906c21:	284506        	s16i	a8, a4, 12
    buf->buf_length -= len;
  906c24:	242104        	l16ui	a4, a2, 8
  906c27:	03430c        	sub	a3, a4, a3
  906c2a:	232504        	s16i	a3, a2, 8
  906c2d:	d10f      	retw.n
	...

00906c30 <__adf_nbuf_put_tail>:
 * @return previous tail (data+len),NULL if the len is more than
 *         space available
 */
a_uint8_t *
__adf_nbuf_put_tail(__adf_nbuf_t buf, adf_os_size_t len)
{
  906c30:	6c1004        	entry	a1, 32
    a_uint8_t *tail = NULL;
    VDESC *last_desc = __adf_nbuf_last(buf);
  906c33:	da20      	mov.n	a10, a2
  906c35:	5bffea        	call8	906be0 <__adf_nbuf_last>
    
    tail = last_desc->buf_addr + last_desc->data_offset + last_desc->data_size;
  906c38:	28a106        	l16ui	a8, a10, 12
  906c3b:	29a105        	l16ui	a9, a10, 10
    last_desc->data_size += len;
  906c3e:	03034f        	extui	a3, a3, 0, 16
__adf_nbuf_put_tail(__adf_nbuf_t buf, adf_os_size_t len)
{
    a_uint8_t *tail = NULL;
    VDESC *last_desc = __adf_nbuf_last(buf);
    
    tail = last_desc->buf_addr + last_desc->data_offset + last_desc->data_size;
  906c41:	a989      	add.n	a9, a8, a9
    last_desc->data_size += len;
  906c43:	a838      	add.n	a8, a3, a8
  906c45:	28a506        	s16i	a8, a10, 12
    buf->buf_length += len;
  906c48:	282104        	l16ui	a8, a2, 8
__adf_nbuf_put_tail(__adf_nbuf_t buf, adf_os_size_t len)
{
    a_uint8_t *tail = NULL;
    VDESC *last_desc = __adf_nbuf_last(buf);
    
    tail = last_desc->buf_addr + last_desc->data_offset + last_desc->data_size;
  906c4b:	8ba1      	l32i.n	a11, a10, 4
    last_desc->data_size += len;
    buf->buf_length += len;
  906c4d:	a833      	add.n	a3, a3, a8
  906c4f:	232504        	s16i	a3, a2, 8
    
    return tail;
}
  906c52:	a9b2      	add.n	a2, a11, a9
  906c54:	d10f      	retw.n
	...

00906c58 <__adf_nbuf_headroom>:
 * 
 * @return num of bytes available
 */
a_uint32_t
__adf_nbuf_headroom(__adf_nbuf_t  buf)
{
  906c58:	6c1004        	entry	a1, 32
    return buf->desc_list->data_offset;
  906c5b:	8820      	l32i.n	a8, a2, 0
}
  906c5d:	228105        	l16ui	a2, a8, 10
  906c60:	d10f      	retw.n
	...

00906c64 <__adf_nbuf_tailroom>:
 * @return num of bytes
 */

a_uint32_t 
__adf_nbuf_tailroom(__adf_nbuf_t  buf)
{
  906c64:	6c1004        	entry	a1, 32
    VDESC *last_desc = __adf_nbuf_last(buf);
  906c67:	da20      	mov.n	a10, a2
  906c69:	5bffdd        	call8	906be0 <__adf_nbuf_last>
    
    return last_desc->buf_size - last_desc->data_offset - last_desc->data_size;
  906c6c:	28a104        	l16ui	a8, a10, 8
  906c6f:	22a105        	l16ui	a2, a10, 10
  906c72:	02820c        	sub	a2, a8, a2
  906c75:	28a106        	l16ui	a8, a10, 12
}
  906c78:	08220c        	sub	a2, a2, a8
  906c7b:	d10f      	retw.n
  906c7d:	000000        	ill

00906c80 <__adf_nbuf_len>:
 * 
 * @return total length of packet (sum of all frag lengths)
 */ 
a_uint32_t
__adf_nbuf_len(__adf_nbuf_t  buf)
{
  906c80:	6c1004        	entry	a1, 32
    return buf->buf_length; 
}
  906c83:	222104        	l16ui	a2, a2, 8
  906c86:	d10f      	retw.n

00906c88 <__adf_nbuf_clone>:
 * 
 * @return Read-only copy of the nbuf (including clusters)
 */
__adf_nbuf_t 
__adf_nbuf_clone(__adf_nbuf_t  src)
{
  906c88:	6c1004        	entry	a1, 32
    __adf_nbuf_t buf = NULL;
    
    return buf;
}
  906c8b:	c020      	movi.n	a2, 0
  906c8d:	d10f      	retw.n
	...

00906c90 <__adf_nbuf_cat>:

void
__adf_nbuf_cat(__adf_nbuf_t dst, __adf_nbuf_t src)
{
  906c90:	6c1004        	entry	a1, 32
  906c93:	d10f      	retw.n
  906c95:	000000        	ill

00906c98 <__adf_nbuf_is_cloned>:
 * 
 * @return a_bool_t
 */
a_bool_t
__adf_nbuf_is_cloned(__adf_nbuf_t  buf)
{
  906c98:	6c1004        	entry	a1, 32
    return A_FALSE;
}
  906c9b:	c020      	movi.n	a2, 0
  906c9d:	d10f      	retw.n
	...

00906ca0 <__adf_nbuf_peek_header>:
 * @brief This will return the header's addr & m_len
 */
void
__adf_nbuf_peek_header(__adf_nbuf_t buf, a_uint8_t   **addr, 
                       a_uint32_t	*len)
{
  906ca0:	6c1004        	entry	a1, 32
    VDESC *desc = buf->desc_list;
  906ca3:	8820      	l32i.n	a8, a2, 0
    
    *addr = desc->buf_addr + desc->data_offset;
  906ca5:	298105        	l16ui	a9, a8, 10
  906ca8:	8a81      	l32i.n	a10, a8, 4
    *len = desc->data_size; 
  906caa:	288106        	l16ui	a8, a8, 12
__adf_nbuf_peek_header(__adf_nbuf_t buf, a_uint8_t   **addr, 
                       a_uint32_t	*len)
{
    VDESC *desc = buf->desc_list;
    
    *addr = desc->buf_addr + desc->data_offset;
  906cad:	a9a9      	add.n	a9, a10, a9
  906caf:	9930      	s32i.n	a9, a3, 0
    *len = desc->data_size; 
  906cb1:	9840      	s32i.n	a8, a4, 0
  906cb3:	d10f      	retw.n
  906cb5:	000000        	ill

00906cb8 <__adf_nbuf_queue_init>:
 * @brief init the queue
 * @param qhead
 */
void 
__adf_nbuf_queue_init(__adf_nbuf_qhead_t *qhead)
{
  906cb8:	6c1004        	entry	a1, 32
    qhead->qlen = 0;
  906cbb:	c080      	movi.n	a8, 0
  906cbd:	9822      	s32i.n	a8, a2, 8
    qhead->head = NULL;
  906cbf:	9820      	s32i.n	a8, a2, 0
    qhead->tail = NULL;
  906cc1:	9821      	s32i.n	a8, a2, 4
  906cc3:	d10f      	retw.n
  906cc5:	000000        	ill

00906cc8 <__adf_nbuf_queue_len>:
 * @return length
 * 
 */
a_uint32_t  
__adf_nbuf_queue_len(__adf_nbuf_qhead_t *qhead)
{
  906cc8:	6c1004        	entry	a1, 32
    return qhead->qlen;
}
  906ccb:	8222      	l32i.n	a2, a2, 8
  906ccd:	d10f      	retw.n
	...

00906cd0 <__adf_nbuf_queue_first>:
 * 
 * @return (NULL if the Q is empty)
 */
__adf_nbuf_t   
__adf_nbuf_queue_first(__adf_nbuf_queue_t *qhead)
{
  906cd0:	6c1004        	entry	a1, 32
    return qhead->head;
}
  906cd3:	8220      	l32i.n	a2, a2, 0
  906cd5:	d10f      	retw.n
	...

00906cd8 <__adf_nbuf_queue_next>:
 * 
 * @return (NULL if no packets are there)
 */
__adf_nbuf_t   
__adf_nbuf_queue_next(__adf_nbuf_t  buf)
{
  906cd8:	6c1004        	entry	a1, 32
    return buf->next_buf;
}
  906cdb:	8221      	l32i.n	a2, a2, 4
  906cdd:	d10f      	retw.n
	...

00906ce0 <__adf_nbuf_is_queue_empty>:
 * 
 * @return a_bool_t
 */
a_bool_t  
__adf_nbuf_is_queue_empty(__adf_nbuf_qhead_t *qhead)
{
  906ce0:	6c1004        	entry	a1, 32
    return ((qhead->qlen == 0));
  906ce3:	8922      	l32i.n	a9, a2, 8
  906ce5:	c081      	movi.n	a8, 1
  906ce7:	c020      	movi.n	a2, 0
  906ce9:	098238        	moveqz	a2, a8, a9
}
  906cec:	d10f      	retw.n
	...

00906cf0 <_buf_pool_static_init>:
    pAPIs->_free_buf = _buf_pool_static_free_buf;
    pAPIs->_shutdown = _buf_pool_static_shutdown;
}
 
LOCAL pool_handle_t _buf_pool_static_init(adf_os_handle_t handle)
{
  906cf0:	6c1004        	entry	a1, 32
  906cf3:	c080      	movi.n	a8, 0
    pAPIs->_alloc_buf_align = _buf_pool_static_alloc_buf_align;
    pAPIs->_free_buf = _buf_pool_static_free_buf;
    pAPIs->_shutdown = _buf_pool_static_shutdown;
}
 
LOCAL pool_handle_t _buf_pool_static_init(adf_os_handle_t handle)
  906cf5:	126988        	l32r	a2, 8e1318 <_bss_end+0x3ce408>
{
#if 1
    int i;
    
    for(i=0; i < POOL_ID_MAX; i++) {
        g_poolCtx.bufQ[i] = NULL;
  906cf8:	db80      	mov.n	a11, a8
LOCAL pool_handle_t _buf_pool_static_init(adf_os_handle_t handle)
{
#if 1
    int i;
    
    for(i=0; i < POOL_ID_MAX; i++) {
  906cfa:	c298      	movi.n	a9, 40
    pAPIs->_alloc_buf_align = _buf_pool_static_alloc_buf_align;
    pAPIs->_free_buf = _buf_pool_static_free_buf;
    pAPIs->_shutdown = _buf_pool_static_shutdown;
}
 
LOCAL pool_handle_t _buf_pool_static_init(adf_os_handle_t handle)
  906cfc:	a28a      	add.n	a10, a8, a2
{
#if 1
    int i;
    
    for(i=0; i < POOL_ID_MAX; i++) {
        g_poolCtx.bufQ[i] = NULL;
  906cfe:	9ba0      	s32i.n	a11, a10, 0
  906d00:	b488      	addi.n	a8, a8, 4
LOCAL pool_handle_t _buf_pool_static_init(adf_os_handle_t handle)
{
#if 1
    int i;
    
    for(i=0; i < POOL_ID_MAX; i++) {
  906d02:	7989f6        	bne	a8, a9, 906cfc <_buf_pool_static_init+0xc>
    ctx = (BUF_POOL_STATIC_CONTEXT *)adf_os_mem_alloc(sizeof(BUF_POOL_STATIC_CONTEXT));
    ctx->NetHandle = handle;
    
    return ctx; 
#endif    
}      
  906d05:	d10f      	retw.n
	...

00906d08 <_buf_pool_static_shutdown>:
    
LOCAL void _buf_pool_static_shutdown(pool_handle_t handle) 
{
  906d08:	6c1004        	entry	a1, 32
  906d0b:	d10f      	retw.n
  906d0d:	000000        	ill

00906d10 <_buf_pool_static_create_pool>:
    // SHALL NOT BE USED in FW
}

LOCAL void _buf_pool_static_create_pool(pool_handle_t handle, BUF_POOL_ID poolId, int nItems, int nSize)
{
  906d10:	6c1006        	entry	a1, 48
        desc->data_size = 0;
        
        buf->buf_length = 0;        
        buf->desc_list = desc;
        
        if ( g_poolCtx.bufQ[poolId] == NULL ) {
  906d13:	126988        	l32r	a2, 8e1334 <_bss_end+0x3ce424>
{
    // SHALL NOT BE USED in FW
}

LOCAL void _buf_pool_static_create_pool(pool_handle_t handle, BUF_POOL_ID poolId, int nItems, int nSize)
{
  906d16:	d940      	mov.n	a9, a4
    VDESC *desc;
    
    //BUF_POOL_STATIC_CONTEXT *ctx = (BUF_POOL_STATIC_CONTEXT *)handle;
    
    for ( i = 0; i < nItems; i++) {
        buf = VBUF_alloc_vbuf();
  906d18:	176915        	l32r	a7, 8e116c <_bss_end+0x3ce25c>
    VBUF *buf;
    VDESC *desc;
    
    //BUF_POOL_STATIC_CONTEXT *ctx = (BUF_POOL_STATIC_CONTEXT *)handle;
    
    for ( i = 0; i < nItems; i++) {
  906d1b:	c040      	movi.n	a4, 0
        desc->data_size = 0;
        
        buf->buf_length = 0;        
        buf->desc_list = desc;
        
        if ( g_poolCtx.bufQ[poolId] == NULL ) {
  906d1d:	02330a        	addx4	a3, a3, a2
    VBUF *buf;
    VDESC *desc;
    
    //BUF_POOL_STATIC_CONTEXT *ctx = (BUF_POOL_STATIC_CONTEXT *)handle;
    
    for ( i = 0; i < nItems; i++) {
  906d20:	60003e        	j	906d62 <_buf_pool_static_create_pool+0x52>
  906d23:	002a72        	excw
        buf = VBUF_alloc_vbuf();
  906d26:	a199      	add.n	a9, a9, a1
  906d28:	100ba0        	l32r	a0, 8c9ba8 <_bss_end+0x3b6c98>
  906d2b:	00d2a0        	excw
        desc = VDESC_alloc_vdesc();
  906d2e:	2a72a6        	l32i	a10, a7, 0x298
  906d31:	0ba000        	callx8	a10
#include "Magpie_api.h"

static inline void *	__adf_os_mem_alloc(adf_os_size_t size)
{
//    return (malloc(size,M_DEVBUF,M_DONTWAIT | M_ZERO));
    return A_ALLOCRAM(size);
  906d34:	287252        	l32i	a8, a7, 0x148
  906d37:	d6a0      	mov.n	a6, a10
  906d39:	db50      	mov.n	a11, a5
  906d3b:	c0a0      	movi.n	a10, 0
  906d3d:	0b8000        	callx8	a8

        desc->buf_addr = (A_UINT8 *)adf_os_mem_alloc(nSize);
        desc->buf_size = nSize;
        desc->data_offset = 0;
  906d40:	c080      	movi.n	a8, 0
    
    for ( i = 0; i < nItems; i++) {
        buf = VBUF_alloc_vbuf();
        desc = VDESC_alloc_vdesc();

        desc->buf_addr = (A_UINT8 *)adf_os_mem_alloc(nSize);
  906d42:	9a61      	s32i.n	a10, a6, 4
        desc->buf_size = nSize;
  906d44:	256504        	s16i	a5, a6, 8
        desc->data_offset = 0;
  906d47:	286505        	s16i	a8, a6, 10
        desc->data_size = 0;
  906d4a:	286506        	s16i	a8, a6, 12
        
        buf->buf_length = 0;        
        buf->desc_list = desc;
  906d4d:	9620      	s32i.n	a6, a2, 0
        
        if ( g_poolCtx.bufQ[poolId] == NULL ) {
  906d4f:	8630      	l32i.n	a6, a3, 0
        desc->buf_addr = (A_UINT8 *)adf_os_mem_alloc(nSize);
        desc->buf_size = nSize;
        desc->data_offset = 0;
        desc->data_size = 0;
        
        buf->buf_length = 0;        
  906d51:	282504        	s16i	a8, a2, 8
        buf->desc_list = desc;
        
        if ( g_poolCtx.bufQ[poolId] == NULL ) {
  906d54:	8910      	l32i.n	a9, a1, 0
  906d56:	cc62      	bnez.n	a6, 906d5c <_buf_pool_static_create_pool+0x4c>
  906d58:	600002        	j	906d5e <_buf_pool_static_create_pool+0x4e>
  906d5b:	009621        	excw
            g_poolCtx.bufQ[poolId] = buf;
        } else {
            buf->next_buf = g_poolCtx.bufQ[poolId];
            g_poolCtx.bufQ[poolId] = buf;
  906d5e:	9230      	s32i.n	a2, a3, 0
    VBUF *buf;
    VDESC *desc;
    
    //BUF_POOL_STATIC_CONTEXT *ctx = (BUF_POOL_STATIC_CONTEXT *)handle;
    
    for ( i = 0; i < nItems; i++) {
  906d60:	b144      	addi.n	a4, a4, 1
  906d62:	7942be        	blt	a4, a9, 906d24 <_buf_pool_static_create_pool+0x14>
        } else {
            buf->next_buf = g_poolCtx.bufQ[poolId];
            g_poolCtx.bufQ[poolId] = buf;
        }
    }
}
  906d65:	d10f      	retw.n
	...

00906d68 <_buf_pool_static_alloc_buf>:
            
LOCAL adf_nbuf_t  _buf_pool_static_alloc_buf(pool_handle_t handle, BUF_POOL_ID poolId, int reserve)
{
  906d68:	6c1004        	entry	a1, 32
    VBUF *buf;
    
    buf = g_poolCtx.bufQ[poolId];
  906d6b:	126988        	l32r	a2, 8e138c <_bss_end+0x3ce47c>
  906d6e:	02330a        	addx4	a3, a3, a2
  906d71:	8230      	l32i.n	a2, a3, 0
    if ( buf != NULL ) {
  906d73:	c921      	beqz.n	a2, 906d88 <_buf_pool_static_alloc_buf+0x20>
        g_poolCtx.bufQ[poolId] = buf->next_buf;
  906d75:	8821      	l32i.n	a8, a2, 4
  906d77:	9830      	s32i.n	a8, a3, 0
        
        buf->next_buf = NULL;
        buf->desc_list->data_offset = reserve;
  906d79:	8920      	l32i.n	a9, a2, 0
    
    buf = g_poolCtx.bufQ[poolId];
    if ( buf != NULL ) {
        g_poolCtx.bufQ[poolId] = buf->next_buf;
        
        buf->next_buf = NULL;
  906d7b:	c080      	movi.n	a8, 0
  906d7d:	9821      	s32i.n	a8, a2, 4
        buf->desc_list->data_offset = reserve;
  906d7f:	249505        	s16i	a4, a9, 10
        buf->desc_list->data_size = 0;
  906d82:	289506        	s16i	a8, a9, 12
        buf->buf_length = 0;
  906d85:	282504        	s16i	a8, a2, 8
    }
    
    return buf;
}
  906d88:	d10f      	retw.n
	...

00906d8c <_buf_pool_static_alloc_buf_align>:

LOCAL adf_nbuf_t  _buf_pool_static_alloc_buf_align(pool_handle_t handle, BUF_POOL_ID poolId, int reserve, int align)
{
  906d8c:	6c1004        	entry	a1, 32
    return _buf_pool_static_alloc_buf(handle, poolId, reserve);
  906d8f:	da20      	mov.n	a10, a2
  906d91:	db30      	mov.n	a11, a3
  906d93:	dc40      	mov.n	a12, a4
  906d95:	5bfff4        	call8	906d68 <_buf_pool_static_alloc_buf>
}
  906d98:	d2a0      	mov.n	a2, a10
  906d9a:	d10f      	retw.n

00906d9c <_buf_pool_static_free_buf>:
    
LOCAL void _buf_pool_static_free_buf(pool_handle_t handle, BUF_POOL_ID poolId, adf_nbuf_t buf)
{
  906d9c:	6c1004        	entry	a1, 32
    if ( g_poolCtx.bufQ[poolId] == NULL ) {
  906d9f:	186988        	l32r	a8, 8e13c0 <_bss_end+0x3ce4b0>
  906da2:	08330a        	addx4	a3, a3, a8
  906da5:	8830      	l32i.n	a8, a3, 0
  906da7:	cc81      	bnez.n	a8, 906dac <_buf_pool_static_free_buf+0x10>
  906da9:	600001        	j	906dae <_buf_pool_static_free_buf+0x12>
        g_poolCtx.bufQ[poolId] = buf;
    } else {
        buf->next_buf = g_poolCtx.bufQ[poolId];
  906dac:	9841      	s32i.n	a8, a4, 4
        g_poolCtx.bufQ[poolId] = buf;
  906dae:	9430      	s32i.n	a4, a3, 0
  906db0:	d10f      	retw.n
	...

00906db4 <buf_pool_module_install>:
LOCAL void _buf_pool_static_shutdown(pool_handle_t handle);      

BUF_POOL_STATIC_CONTEXT g_poolCtx;

void buf_pool_module_install(struct buf_pool_api *pAPIs)
{   
  906db4:	6c1004        	entry	a1, 32
    pAPIs->_init = _buf_pool_static_init;
  906db7:	186989        	l32r	a8, 8e13dc <_bss_end+0x3ce4cc>
  906dba:	9820      	s32i.n	a8, a2, 0
    pAPIs->_create_pool = _buf_pool_static_create_pool;
  906dbc:	18698a        	l32r	a8, 8e13e4 <_bss_end+0x3ce4d4>
  906dbf:	9822      	s32i.n	a8, a2, 8
    pAPIs->_alloc_buf = _buf_pool_static_alloc_buf;
  906dc1:	18698b        	l32r	a8, 8e13f0 <_bss_end+0x3ce4e0>
  906dc4:	9823      	s32i.n	a8, a2, 12
    pAPIs->_alloc_buf_align = _buf_pool_static_alloc_buf_align;
  906dc6:	18698c        	l32r	a8, 8e13f8 <_bss_end+0x3ce4e8>
  906dc9:	9824      	s32i.n	a8, a2, 16
    pAPIs->_free_buf = _buf_pool_static_free_buf;
  906dcb:	18698d        	l32r	a8, 8e1400 <_bss_end+0x3ce4f0>
  906dce:	9825      	s32i.n	a8, a2, 20
    pAPIs->_shutdown = _buf_pool_static_shutdown;
  906dd0:	18698e        	l32r	a8, 8e1408 <_bss_end+0x3ce4f8>
  906dd3:	9821      	s32i.n	a8, a2, 4
  906dd5:	d10f      	retw.n
	...

00906dd8 <db_incorect_format>:
int cmd_not_found;
uint16_t gvLen;
int pressed_time;

static void db_incorect_format(void)
{
  906dd8:	6c1004        	entry	a1, 32
	A_PRINTF("Error! Incorrect format.\n\r");
  906ddb:	186915        	l32r	a8, 8e1230 <_bss_end+0x3ce320>
  906dde:	1a698f        	l32r	a10, 8e141c <_bss_end+0x3ce50c>
  906de1:	288212        	l32i	a8, a8, 72
  906de4:	0b8000        	callx8	a8
  906de7:	d10f      	retw.n
  906de9:	000000        	ill

00906dec <zf_debug_init>:
	} while (mem1 < mem2);
	A_PRINTF("\n\r");
}

static void zf_debug_init(void)
{
  906dec:	6c1006        	entry	a1, 48
	uint8_t ch;

	/* Purge Rx FIFO */
	while ((zm_get_char(&ch)) != 0)
  906def:	126915        	l32r	a2, 8e1244 <_bss_end+0x3ce334>
  906df2:	282215        	l32i	a8, a2, 84
  906df5:	da10      	mov.n	a10, a1
  906df7:	0b8000        	callx8	a8
  906dfa:	65aff4        	bnez	a10, 906df2 <zf_debug_init+0x6>
	{
	}

	cmd_buf_ptr = 0;
  906dfd:	126990        	l32r	a2, 8e1440 <_bss_end+0x3ce530>
  906e00:	9a20      	s32i.n	a10, a2, 0
	cmd_buf_full = FALSE;
  906e02:	126991        	l32r	a2, 8e1448 <_bss_end+0x3ce538>
  906e05:	9a20      	s32i.n	a10, a2, 0
	gvLen = 0;
  906e07:	126992        	l32r	a2, 8e1450 <_bss_end+0x3ce540>
  906e0a:	2a2500        	s16i	a10, a2, 0
	pressed_time = 0;
  906e0d:	126993        	l32r	a2, 8e145c <_bss_end+0x3ce54c>
  906e10:	9a20      	s32i.n	a10, a2, 0
  906e12:	d10f      	retw.n

00906e14 <db_ascii_to_hex>:
	}
	return (int)A_STRLEN(cmd_str);
}

static int db_ascii_to_hex(char *num_str, unsigned long *hex_num)
{
  906e14:	6c1004        	entry	a1, 32
	int i = 0;

	*hex_num = 0;
  906e17:	c080      	movi.n	a8, 0
  906e19:	9830      	s32i.n	a8, a3, 0
	while (num_str[i])
	{
		if ((num_str[i] >= '0') && (num_str[i] <= '9'))
  906e1b:	c099      	movi.n	a9, 9
static int db_ascii_to_hex(char *num_str, unsigned long *hex_num)
{
	int i = 0;

	*hex_num = 0;
	while (num_str[i])
  906e1d:	60004b        	j	906e6c <db_ascii_to_hex+0x58>
	{
		if ((num_str[i] >= '0') && (num_str[i] <= '9'))
  906e20:	2a8cd0        	addi	a10, a8, -48
  906e23:	0a0a47        	extui	a10, a10, 0, 8
  906e26:	7a930e        	bltu	a9, a10, 906e38 <db_ascii_to_hex+0x24>
		{
			*hex_num <<= 4;
  906e29:	8830      	l32i.n	a8, a3, 0
  906e2b:	0c8811        	slli	a8, a8, 4
  906e2e:	9830      	s32i.n	a8, a3, 0
			*hex_num += (num_str[i] - '0');
  906e30:	288cd0        	addi	a8, a8, -48
  906e33:	60002c        	j	906e63 <db_ascii_to_hex+0x4f>
  906e36:	00002a        	muluh	a0, a0, a0
		}
		else if ((num_str[i] >= 'A') && (num_str[i] <= 'F'))
  906e39:	8cbf      	l32i.n	a12, a11, 60
  906e3b:	0a0a47        	extui	a10, a10, 0, 8
  906e3e:	6fa60e        	bgeui	a10, 6, 906e50 <db_ascii_to_hex+0x3c>
		{
			*hex_num <<= 4;
  906e41:	8830      	l32i.n	a8, a3, 0
  906e43:	0c8811        	slli	a8, a8, 4
  906e46:	9830      	s32i.n	a8, a3, 0
			*hex_num += (num_str[i] - 'A' + 10);
  906e48:	288cc9        	addi	a8, a8, -55
  906e4b:	600014        	j	906e63 <db_ascii_to_hex+0x4f>
  906e4e:	000028        	mull	a0, a0, a0
		}
		else if ((num_str[i] >= 'a') && (num_str[i] <= 'f'))
  906e51:	8c9f      	l32i.n	a12, a9, 60
  906e53:	080847        	extui	a8, a8, 0, 8
  906e56:	6f861c        	bgeui	a8, 6, 906e76 <db_ascii_to_hex+0x62>
		{
			*hex_num <<= 4;
  906e59:	8830      	l32i.n	a8, a3, 0
  906e5b:	0c8811        	slli	a8, a8, 4
  906e5e:	9830      	s32i.n	a8, a3, 0
			*hex_num += (num_str[i] - 'a' + 10);
  906e60:	288ca9        	addi	a8, a8, -87
  906e63:	2a2000        	l8ui	a10, a2, 0
  906e66:	b122      	addi.n	a2, a2, 1
  906e68:	aa88      	add.n	a8, a8, a10
  906e6a:	9830      	s32i.n	a8, a3, 0
static int db_ascii_to_hex(char *num_str, unsigned long *hex_num)
{
	int i = 0;

	*hex_num = 0;
	while (num_str[i])
  906e6c:	282000        	l8ui	a8, a2, 0
  906e6f:	658fad        	bnez	a8, 906e20 <db_ascii_to_hex+0xc>
		{
			return -1;
		}
		i++;
	}
	return 0;
  906e72:	d280      	mov.n	a2, a8
  906e74:	d10f      	retw.n
			*hex_num <<= 4;
			*hex_num += (num_str[i] - 'a' + 10);
		}
		else
		{
			return -1;
  906e76:	c72f      	movi.n	a2, -1
		}
		i++;
	}
	return 0;
}
  906e78:	d10f      	retw.n
	...

00906e7c <db_hex_to_ascii>:
	}
	return 0;
}

static int db_hex_to_ascii(unsigned long hex_num, char *num_str)
{
  906e7c:	6c1004        	entry	a1, 32
  906e7f:	d930      	mov.n	a9, a3
  906e81:	c18c      	movi.n	a8, 28
	unsigned long four_bits;

	for (i=7; i>=0; i--)
	{
		four_bits = (hex_num >> i*4) & 0xf;
		if (four_bits < 10)
  906e83:	c0c9      	movi.n	a12, 9
static int db_hex_to_ascii(unsigned long hex_num, char *num_str)
{
	int i;
	unsigned long four_bits;

	for (i=7; i>=0; i--)
  906e85:	2bfafc        	movi	a11, -4
	{
		four_bits = (hex_num >> i*4) & 0xf;
  906e88:	008004        	ssr	a8
  906e8b:	020a19        	srl	a10, a2
  906e8e:	0a0a43        	extui	a10, a10, 0, 4
		if (four_bits < 10)
  906e91:	7ac307        	bltu	a12, a10, 906e9c <db_hex_to_ascii+0x20>
		{
			num_str[7-i] = four_bits + '0';
  906e94:	2aac30        	addi	a10, a10, 48
  906e97:	600004        	j	906e9f <db_hex_to_ascii+0x23>
  906e9a:	00002a        	muluh	a0, a0, a0
		}
		else
		{
			num_str[7-i] = four_bits - 10 + 'A';
  906e9d:	ac37      	add.n	a7, a3, a12
  906e9f:	2a9400        	s8i	a10, a9, 0
  906ea2:	288cfc        	addi	a8, a8, -4
  906ea5:	b199      	addi.n	a9, a9, 1
static int db_hex_to_ascii(unsigned long hex_num, char *num_str)
{
	int i;
	unsigned long four_bits;

	for (i=7; i>=0; i--)
  906ea7:	7b89dd        	bne	a8, a11, 906e88 <db_hex_to_ascii+0xc>
		else
		{
			num_str[7-i] = four_bits - 10 + 'A';
		}
	}
	num_str[8] = 0;
  906eaa:	c020      	movi.n	a2, 0
  906eac:	223408        	s8i	a2, a3, 8
	return 0;
}
  906eaf:	c020      	movi.n	a2, 0
  906eb1:	d10f      	retw.n
	...

00906eb4 <db_help_cmd>:

int db_help_cmd(char *cmd, char *param1, char *param2, char *param3)
{
  906eb4:	6c1004        	entry	a1, 32
	int i;

	i = 0;

	A_PRINTF("%s %s\n", ATH_DEBUGGER_VERSION_STR, ATH_COMMAND_LIST_STR);
  906eb7:	146915        	l32r	a4, 8e130c <_bss_end+0x3ce3fc>
  906eba:	1a6994        	l32r	a10, 8e150c <_bss_end+0x3ce5fc>
  906ebd:	224212        	l32i	a2, a4, 72
  906ec0:	1b6995        	l32r	a11, 8e1514 <_bss_end+0x3ce604>
  906ec3:	1c6996        	l32r	a12, 8e151c <_bss_end+0x3ce60c>
  906ec6:	0b2000        	callx8	a2
  906ec9:	136997        	l32r	a3, 8e1528 <_bss_end+0x3ce618>

int db_help_cmd(char *cmd, char *param1, char *param2, char *param3)
{
	int i;

	i = 0;
  906ecc:	c020      	movi.n	a2, 0

	A_PRINTF("%s %s\n", ATH_DEBUGGER_VERSION_STR, ATH_COMMAND_LIST_STR);

	while (command_table[i].cmd_func)
  906ece:	600016        	j	906ee8 <db_help_cmd+0x34>
	}
	num_str[8] = 0;
	return 0;
}

int db_help_cmd(char *cmd, char *param1, char *param2, char *param3)
  906ed1:	293cfc        	addi	a9, a3, -4
  906ed4:	2b3cf8        	addi	a11, a3, -8

	A_PRINTF("%s %s\n", ATH_DEBUGGER_VERSION_STR, ATH_COMMAND_LIST_STR);

	while (command_table[i].cmd_func)
	{
		A_PRINTF("%s\t%s\n\r", command_table[i].cmd_str,
  906ed7:	284212        	l32i	a8, a4, 72
  906eda:	1a6998        	l32r	a10, 8e153c <_bss_end+0x3ce62c>
  906edd:	8bb0      	l32i.n	a11, a11, 0
  906edf:	8c90      	l32i.n	a12, a9, 0
				       command_table[i].help_str);
		i++;
  906ee1:	b122      	addi.n	a2, a2, 1

	A_PRINTF("%s %s\n", ATH_DEBUGGER_VERSION_STR, ATH_COMMAND_LIST_STR);

	while (command_table[i].cmd_func)
	{
		A_PRINTF("%s\t%s\n\r", command_table[i].cmd_str,
  906ee3:	0b8000        	callx8	a8
  906ee6:	bc33      	addi.n	a3, a3, 12

	i = 0;

	A_PRINTF("%s %s\n", ATH_DEBUGGER_VERSION_STR, ATH_COMMAND_LIST_STR);

	while (command_table[i].cmd_func)
  906ee8:	8830      	l32i.n	a8, a3, 0
  906eea:	658fe3        	bnez	a8, 906ed1 <db_help_cmd+0x1d>
		A_PRINTF("%s\t%s\n\r", command_table[i].cmd_str,
				       command_table[i].help_str);
		i++;
	}
	return i;
}
  906eed:	d10f      	retw.n
	...

00906ef0 <db_cmd_starthtc>:
#endif
	return 1;
}

static int db_cmd_starthtc(char *cmd, char *param1, char *param2, char *param3)
{
  906ef0:	6c1004        	entry	a1, 32
    extern htc_handle_t htc_handle;
    HTC_Ready(htc_handle);
  906ef3:	126915        	l32r	a2, 8e1348 <_bss_end+0x3ce438>
  906ef6:	282281        	l32i	a8, a2, 0x204
  906ef9:	126999        	l32r	a2, 8e1560 <generic_hif_module_install+0x18>
  906efc:	8a20      	l32i.n	a10, a2, 0
  906efe:	0b8000        	callx8	a8
}
  906f01:	d10f      	retw.n
	...

00906f04 <db_cmd_memcmp>:
#endif
#endif /* #if defined(PROJECT_K2) */

/* Memory Comparison */
static int db_cmd_memcmp(char *cmd, char *param1, char *param2, char *param3)
{
  906f04:	6c1006        	entry	a1, 48
	unsigned long       addr1, addr2, len;
	A_UINT8             *buf1, *buf2;

	if (db_ascii_to_hex(param1, &addr1) != -1 &&
  906f07:	033a02        	or	a10, a3, a3
  906f0a:	2b1c08        	addi	a11, a1, 8
  906f0d:	5bffc1        	call8	906e14 <db_ascii_to_hex>
  906f10:	68a045        	beqi	a10, -1, 906f59 <db_cmd_memcmp+0x55>
	    db_ascii_to_hex(param2, &addr2) != -1 &&
  906f13:	044a02        	or	a10, a4, a4
  906f16:	2b1c04        	addi	a11, a1, 4
  906f19:	5bffbe        	call8	906e14 <db_ascii_to_hex>
static int db_cmd_memcmp(char *cmd, char *param1, char *param2, char *param3)
{
	unsigned long       addr1, addr2, len;
	A_UINT8             *buf1, *buf2;

	if (db_ascii_to_hex(param1, &addr1) != -1 &&
  906f1c:	68a039        	beqi	a10, -1, 906f59 <db_cmd_memcmp+0x55>
	    db_ascii_to_hex(param2, &addr2) != -1 &&
	    db_ascii_to_hex(param3, &len) != -1 &&
  906f1f:	055a02        	or	a10, a5, a5
  906f22:	011b02        	or	a11, a1, a1
  906f25:	5bffbb        	call8	906e14 <db_ascii_to_hex>
{
	unsigned long       addr1, addr2, len;
	A_UINT8             *buf1, *buf2;

	if (db_ascii_to_hex(param1, &addr1) != -1 &&
	    db_ascii_to_hex(param2, &addr2) != -1 &&
  906f28:	68a02d        	beqi	a10, -1, 906f59 <db_cmd_memcmp+0x55>
	    db_ascii_to_hex(param3, &len) != -1 &&
	    addr1 != addr2 && addr1%4 == 0 && addr2%4 == 0 && len%4 == 0)
  906f2b:	8a12      	l32i.n	a10, a1, 8
  906f2d:	8b11      	l32i.n	a11, a1, 4
	unsigned long       addr1, addr2, len;
	A_UINT8             *buf1, *buf2;

	if (db_ascii_to_hex(param1, &addr1) != -1 &&
	    db_ascii_to_hex(param2, &addr2) != -1 &&
	    db_ascii_to_hex(param3, &len) != -1 &&
  906f2f:	7ba126        	beq	a10, a11, 906f59 <db_cmd_memcmp+0x55>
	    addr1 != addr2 && addr1%4 == 0 && addr2%4 == 0 && len%4 == 0)
  906f32:	0a0241        	extui	a2, a10, 0, 2
  906f35:	ce20      	bnez.n	a2, 906f59 <db_cmd_memcmp+0x55>
  906f37:	0b0241        	extui	a2, a11, 0, 2
  906f3a:	cd2b      	bnez.n	a2, 906f59 <db_cmd_memcmp+0x55>
  906f3c:	8c10      	l32i.n	a12, a1, 0
  906f3e:	0c0241        	extui	a2, a12, 0, 2
  906f41:	cd24      	bnez.n	a2, 906f59 <db_cmd_memcmp+0x55>
	{
		buf1 = (A_UINT8 *)addr1;
		buf2 = (A_UINT8 *)addr2;        ;

		A_PRINTF("memcmp(buf1, buf2, len) = %d\n\r", A_MEMCMP(buf1, buf2, len));
  906f43:	186915        	l32r	a8, 8e1398 <_bss_end+0x3ce488>
  906f46:	8587      	l32i.n	a5, a8, 28
  906f48:	248212        	l32i	a4, a8, 72
  906f4b:	0b5000        	callx8	a5
  906f4e:	dba0      	mov.n	a11, a10
  906f50:	1a699a        	l32r	a10, 8e15b8 <athos_indirection_table_install+0x44>
  906f53:	0b4000        	callx8	a4
  906f56:	d10f      	retw.n
  906f58:	005bff        	excw
		return 0;
	}

	db_incorect_format();
  906f5b:	9fc7      	s32i.n	a15, a12, 28
	return -1;
  906f5d:	2fd10f        	l16ui	a15, a13, 30

00906f60 <db_cmd_memdump>:
}

/* Memory Dump */
static int db_cmd_memdump(char *cmd, char *param1, char *param2, char *param3)
{
  906f60:	6c1006        	entry	a1, 48
	unsigned long       addr1, addr2;

	if (db_ascii_to_hex(param1, &addr1) != -1 && db_ascii_to_hex(param2, &addr2) != -1 && addr1 < addr2 && addr1%4 == 0)
  906f63:	033a02        	or	a10, a3, a3
  906f66:	2b1c04        	addi	a11, a1, 4
  906f69:	5bffaa        	call8	906e14 <db_ascii_to_hex>
  906f6c:	69a002        	bnei	a10, -1, 906f72 <db_cmd_memdump+0x12>
  906f6f:	60008e        	j	907001 <db_cmd_memdump+0xa1>
  906f72:	da40      	mov.n	a10, a4
  906f74:	db10      	mov.n	a11, a1
  906f76:	5bffa7        	call8	906e14 <db_ascii_to_hex>
  906f79:	69a002        	bnei	a10, -1, 906f7f <db_cmd_memdump+0x1f>
  906f7c:	600081        	j	907001 <db_cmd_memdump+0xa1>
  906f7f:	8211      	l32i.n	a2, a1, 4
  906f81:	241200        	l32i	a4, a1, 0
  906f84:	742b79        	bgeu	a2, a4, 907001 <db_cmd_memdump+0xa1>
  906f87:	020341        	extui	a3, a2, 0, 2
  906f8a:	653073        	bnez	a3, 907001 <db_cmd_memdump+0xa1>
	unsigned int i = 0;
	const char *tmp;

	do {
		if (i == 0) {
			A_PRINTF("\n\r%06x: ", mem1);
  906f8d:	176915        	l32r	a7, 8e13e4 <_bss_end+0x3ce4d4>
{
	unsigned int i = 0;
	const char *tmp;

	do {
		if (i == 0) {
  906f90:	cc3c      	bnez.n	a3, 906fa0 <db_cmd_memdump+0x40>
			A_PRINTF("\n\r%06x: ", mem1);
  906f92:	257212        	l32i	a5, a7, 72
  906f95:	1a699b        	l32r	a10, 8e1604 <athos_indirection_table_install+0x90>
  906f98:	db20      	mov.n	a11, a2
  906f9a:	0b5000        	callx8	a5
  906f9d:	022502        	or	a5, a2, a2
			tmp = mem1;
		}

		A_PRINTF("%04x ", *(uint16_t *)mem1);
  906fa0:	166915        	l32r	a6, 8e13f4 <_bss_end+0x3ce4e4>
  906fa3:	2b2100        	l16ui	a11, a2, 0
  906fa6:	286212        	l32i	a8, a6, 72
  906fa9:	1a699c        	l32r	a10, 8e161c <athos_indirection_table_install+0xa8>

		mem1 += 2;
		i++;
  906fac:	233c01        	addi	a3, a3, 1
		if (i == 0) {
			A_PRINTF("\n\r%06x: ", mem1);
			tmp = mem1;
		}

		A_PRINTF("%04x ", *(uint16_t *)mem1);
  906faf:	0b8000        	callx8	a8

		mem1 += 2;
  906fb2:	b222      	addi.n	a2, a2, 2
		i++;

		if (i == 8) {
  906fb4:	693834        	bnei	a3, 8, 906fec <db_cmd_memdump+0x8c>
			A_PRINTF(" ");
  906fb7:	236212        	l32i	a3, a6, 72
  906fba:	1a699d        	l32r	a10, 8e1630 <athos_indirection_table_install+0xbc>
  906fbd:	0b3000        	callx8	a3
			do {
				if (*tmp > 0x20 && *tmp < 0x7e)
  906fc0:	c53c      	movi.n	a3, 92
  906fc2:	2b5000        	l8ui	a11, a5, 0
  906fc5:	166915        	l32r	a6, 8e141c <_bss_end+0x3ce50c>
  906fc8:	28bcdf        	addi	a8, a11, -33
  906fcb:	080847        	extui	a8, a8, 0, 8
					A_PRINTF("%c", *tmp);
  906fce:	266212        	l32i	a6, a6, 72
		i++;

		if (i == 8) {
			A_PRINTF(" ");
			do {
				if (*tmp > 0x20 && *tmp < 0x7e)
  906fd1:	783308        	bltu	a3, a8, 906fdd <db_cmd_memdump+0x7d>
					A_PRINTF("%c", *tmp);
  906fd4:	1a699e        	l32r	a10, 8e164c <athos_indirection_table_install+0xd8>
  906fd7:	0b6000        	callx8	a6
  906fda:	600005        	j	906fe3 <db_cmd_memdump+0x83>
				else
					A_PRINTF(".");
  906fdd:	1a699f        	l32r	a10, 8e165c <athos_indirection_table_install+0xe8>
  906fe0:	0b6000        	callx8	a6
				tmp++;
  906fe3:	255c01        	addi	a5, a5, 1
			} while (tmp < mem1);
  906fe6:	7253d8        	bltu	a5, a2, 906fc2 <db_cmd_memdump+0x62>
			i = 0;
  906fe9:	230a00        	movi	a3, 0
		}
	} while (mem1 < mem2);
  906fec:	7423a0        	bltu	a2, a4, 906f90 <db_cmd_memdump+0x30>
	A_PRINTF("\n\r");
  906fef:	126915        	l32r	a2, 8e1444 <_bss_end+0x3ce534>
  906ff2:	1a69a0        	l32r	a10, 8e1674 <athos_indirection_table_install+0x100>
  906ff5:	222212        	l32i	a2, a2, 72
  906ff8:	0b2000        	callx8	a2
	unsigned long       addr1, addr2;

	if (db_ascii_to_hex(param1, &addr1) != -1 && db_ascii_to_hex(param2, &addr2) != -1 && addr1 < addr2 && addr1%4 == 0)
	{
		db_print_dump((const char *)addr1, (const char *)addr2);
		return 0;
  906ffb:	c020      	movi.n	a2, 0
  906ffd:	d10f      	retw.n
  906fff:	00005b        	extui	a0, a0, 16, 12
	}

	db_incorect_format();
  907002:	ff          	.byte 0xff
  907003:	75c72f        	bbci	a12, 21, 907036 <db_str_cmd+0x2e>
	return -1;
}
  907006:	d10f      	retw.n

00907008 <db_str_cmd>:
	db_incorect_format();
	return -1;
}

static int db_str_cmd(char *cmd, char *param1, char *param2, char *param3)
{
  907008:	6c100a        	entry	a1, 80
	unsigned long val;
	unsigned long addr;
	char val_str[20];
	char addr_str[20];

	if ((A_STRLEN(param2) > 0) &&
  90700b:	186915        	l32r	a8, 8e1460 <_bss_end+0x3ce550>
  90700e:	da40      	mov.n	a10, a4
  907010:	288266        	l32i	a8, a8, 0x198
  907013:	0b8000        	callx8	a8
  907016:	6ba102        	bgei	a10, 1, 90701c <db_str_cmd+0x14>
  907019:	6000a4        	j	9070c1 <db_str_cmd+0xb9>
	    (db_ascii_to_hex(param1, &addr) != -1) &&
  90701c:	da30      	mov.n	a10, a3
  90701e:	2b1c28        	addi	a11, a1, 40
  907021:	5bff7c        	call8	906e14 <db_ascii_to_hex>
	unsigned long val;
	unsigned long addr;
	char val_str[20];
	char addr_str[20];

	if ((A_STRLEN(param2) > 0) &&
  907024:	69a002        	bnei	a10, -1, 90702a <db_str_cmd+0x22>
  907027:	600096        	j	9070c1 <db_str_cmd+0xb9>
	    (db_ascii_to_hex(param1, &addr) != -1) &&
	    (db_ascii_to_hex(param2, &val) != -1))
  90702a:	da40      	mov.n	a10, a4
  90702c:	2b1c2c        	addi	a11, a1, 44
  90702f:	5bff79        	call8	906e14 <db_ascii_to_hex>
	unsigned long addr;
	char val_str[20];
	char addr_str[20];

	if ((A_STRLEN(param2) > 0) &&
	    (db_ascii_to_hex(param1, &addr) != -1) &&
  907032:	69a002        	bnei	a10, -1, 907038 <db_str_cmd+0x30>
  907035:	600088        	j	9070c1 <db_str_cmd+0xb9>
	    (db_ascii_to_hex(param2, &val) != -1))
	{
		if (strcmp(cmd, "STR") == 0)
  907038:	1b69a1        	l32r	a11, 8e16bc <athos_indirection_table_install+0x148>
  90703b:	da20      	mov.n	a10, a2
  90703d:	5b7d48        	call8	8e6560 <strcmp>
  907040:	cda1      	bnez.n	a10, 907055 <db_str_cmd+0x4d>
		{
			addr &= 0xfffffffc;
  907042:	821a      	l32i.n	a2, a1, 40
  907044:	c73c      	movi.n	a3, -4
  907046:	023201        	and	a2, a3, a2
			iowrite32(addr, val);
  907049:	831b      	l32i.n	a3, a1, 44
	    (db_ascii_to_hex(param1, &addr) != -1) &&
	    (db_ascii_to_hex(param2, &val) != -1))
	{
		if (strcmp(cmd, "STR") == 0)
		{
			addr &= 0xfffffffc;
  90704b:	921a      	s32i.n	a2, a1, 40
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90704d:	0c0200        	memw
  907050:	9320      	s32i.n	a3, a2, 0
  907052:	600044        	j	90709a <db_str_cmd+0x92>
			iowrite32(addr, val);
		}

		else if (strcmp(cmd, "STRH") == 0)
  907055:	1b69a2        	l32r	a11, 8e16e0 <athos_indirection_table_install+0x16c>
  907058:	da20      	mov.n	a10, a2
  90705a:	5b7d41        	call8	8e6560 <strcmp>
  90705d:	cda3      	bnez.n	a10, 907074 <db_str_cmd+0x6c>
		{
			addr &= 0xfffffffe;
  90705f:	821a      	l32i.n	a2, a1, 40
  907061:	c73e      	movi.n	a3, -2
  907063:	023201        	and	a2, a3, a2
  907066:	231117        	l16ui	a3, a1, 46
  907069:	921a      	s32i.n	a2, a1, 40
	*(volatile uint8_t *) addr = b;
}

static inline void iowrite16(volatile uint32_t addr, const uint16_t b)
{
	*(volatile uint16_t *) addr = b;
  90706b:	0c0200        	memw
  90706e:	232500        	s16i	a3, a2, 0
  907071:	600025        	j	90709a <db_str_cmd+0x92>
			//*(volatile unsigned short *)(addr & 0xfffffffe) = (unsigned short)val;
			iowrite16(addr, val);
		}
		else if (strcmp(cmd, "STRB") == 0)
  907074:	1b69a3        	l32r	a11, 8e1700 <athos_indirection_table_install+0x18c>
  907077:	da20      	mov.n	a10, a2
  907079:	5b7d39        	call8	8e6560 <strcmp>
  90707c:	cdaa      	bnez.n	a10, 90709a <db_str_cmd+0x92>
		{
			if( addr & 0x00f00000 )
  90707e:	821a      	l32i.n	a2, a1, 40
  907080:	1369a4        	l32r	a3, 8e1710 <athos_indirection_table_install+0x19c>
  907083:	841b      	l32i.n	a4, a1, 44
  907085:	732003        	bnone	a2, a3, 90708c <db_str_cmd+0x84>
  907088:	600005        	j	907091 <db_str_cmd+0x89>
  90708b:	00c033        	excw
				iowrite8(addr, val);
			else
				iowrite8(addr^3, val);
  90708e:	032203        	xor	a2, a2, a3
  907091:	040447        	extui	a4, a4, 0, 8
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  907094:	0c0200        	memw
  907097:	242400        	s8i	a4, a2, 0
			//*(volatile unsigned char *)addr = (unsigned char)val;
		}

		db_hex_to_ascii(val, val_str);
  90709a:	8a1b      	l32i.n	a10, a1, 44
  90709c:	2b1c14        	addi	a11, a1, 20
  90709f:	5bff77        	call8	906e7c <db_hex_to_ascii>
		db_hex_to_ascii(addr, addr_str);
  9070a2:	8a1a      	l32i.n	a10, a1, 40
  9070a4:	db10      	mov.n	a11, a1
  9070a6:	5bff75        	call8	906e7c <db_hex_to_ascii>

		A_PRINTF("%s : %s\n\r", addr_str, val_str);
  9070a9:	126915        	l32r	a2, 8e1500 <_bss_end+0x3ce5f0>
  9070ac:	1a69a5        	l32r	a10, 8e1740 <athos_indirection_table_install+0x1cc>
  9070af:	222212        	l32i	a2, a2, 72
  9070b2:	db10      	mov.n	a11, a1
  9070b4:	2c1c14        	addi	a12, a1, 20
  9070b7:	0b2000        	callx8	a2
		return 0;
  9070ba:	c020      	movi.n	a2, 0
  9070bc:	d10f      	retw.n
  9070be:	000000        	ill
	}

	db_incorect_format();
  9070c1:	5bff45        	call8	906dd8 <db_incorect_format>
	return -1;
  9070c4:	c72f      	movi.n	a2, -1
}
  9070c6:	d10f      	retw.n

009070c8 <db_ldr_cmd>:
	}
	return i;
}

static int db_ldr_cmd(char *cmd, char *param1, char *param2, char *param3)
{
  9070c8:	6c100a        	entry	a1, 80
	unsigned long val;
	unsigned long addr;
	char val_str[20];
	char addr_str[20];

	if (db_ascii_to_hex(param1, &addr) != -1)
  9070cb:	033a02        	or	a10, a3, a3
  9070ce:	2b1c28        	addi	a11, a1, 40
  9070d1:	5bff50        	call8	906e14 <db_ascii_to_hex>
  9070d4:	d3a0      	mov.n	a3, a10
  9070d6:	68a06b        	beqi	a10, -1, 907145 <db_ldr_cmd+0x7d>
	{
		if( addr == 0 )
  9070d9:	831a      	l32i.n	a3, a1, 40
  9070db:	cd31      	bnez.n	a3, 9070f0 <db_ldr_cmd+0x28>
		{
			A_PRINTF("Error! bad address 0x%08x.\n\r",
  9070dd:	126915        	l32r	a2, 8e1534 <_bss_end+0x3ce624>
  9070e0:	1a69a6        	l32r	a10, 8e1778 <athos_indirection_table_install+0x204>
  9070e3:	222212        	l32i	a2, a2, 72
  9070e6:	033b02        	or	a11, a3, a3
  9070e9:	0b2000        	callx8	a2
				 (unsigned long)addr);
			return -1;
  9070ec:	c72f      	movi.n	a2, -1
  9070ee:	d10f      	retw.n
		}
		if (strcmp(cmd, "LDR") == 0)
  9070f0:	1b69a7        	l32r	a11, 8e178c <athos_indirection_table_install+0x218>
  9070f3:	da20      	mov.n	a10, a2
  9070f5:	5b7d1a        	call8	8e6560 <strcmp>
  9070f8:	ccad      	bnez.n	a10, 907109 <db_ldr_cmd+0x41>
		{
			addr &= 0xfffffffc;
  9070fa:	c72c      	movi.n	a2, -4
  9070fc:	023301        	and	a3, a3, a2
  9070ff:	931a      	s32i.n	a3, a1, 40
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  907101:	0c0200        	memw
  907104:	8430      	l32i.n	a4, a3, 0
  907106:	600017        	j	907121 <db_ldr_cmd+0x59>
			//val = *(unsigned long *)addr;

			val = ioread32(addr);
		}
		else if (strcmp(cmd, "LDRH") == 0)
  907109:	1b69a8        	l32r	a11, 8e17ac <athos_indirection_table_install+0x238>
  90710c:	022a02        	or	a10, a2, a2
  90710f:	5b7d14        	call8	8e6560 <strcmp>
  907112:	ccab      	bnez.n	a10, 907121 <db_ldr_cmd+0x59>
		{
			addr &= 0xfffffffe;
  907114:	c72e      	movi.n	a2, -2
  907116:	023301        	and	a3, a3, a2
	return *(const volatile uint8_t *) addr;
}

static inline uint16_t ioread16(const volatile uint32_t addr)
{
	return *(const volatile uint16_t *) addr;
  907119:	243100        	l16ui	a4, a3, 0
  90711c:	931a      	s32i.n	a3, a1, 40
  90711e:	04044f        	extui	a4, a4, 0, 16
		}
		else if (strcmp(cmd, "LDRB") == 0)
		{
		}

		db_hex_to_ascii(val, val_str);
  907121:	2b1c14        	addi	a11, a1, 20
  907124:	da40      	mov.n	a10, a4
  907126:	5bff55        	call8	906e7c <db_hex_to_ascii>
		db_hex_to_ascii(addr, addr_str);
  907129:	8a1a      	l32i.n	a10, a1, 40
  90712b:	db10      	mov.n	a11, a1
  90712d:	5bff53        	call8	906e7c <db_hex_to_ascii>

		A_PRINTF("%s : %s\n\r", addr_str, val_str);
  907130:	126915        	l32r	a2, 8e1584 <athos_indirection_table_install+0x10>
  907133:	1a69a5        	l32r	a10, 8e17c8 <athos_indirection_table_install+0x254>
  907136:	222212        	l32i	a2, a2, 72
  907139:	db10      	mov.n	a11, a1
  90713b:	2c1c14        	addi	a12, a1, 20
  90713e:	0b2000        	callx8	a2
		return 0;
  907141:	c020      	movi.n	a2, 0
  907143:	d10f      	retw.n
	}

	db_incorect_format();
  907145:	5bff24        	call8	906dd8 <db_incorect_format>
  907148:	63ffa0        	j	9070ec <db_ldr_cmd+0x24>
	...

0090714c <db_intr_cmd>:
}

uint32_t delay = 0;

static int db_intr_cmd(char *cmd, char *param1, char *param2, char *param3)
{
  90714c:	6c1006        	entry	a1, 48
#if SYSTEM_MODULE_INTR
	uint32_t pending_intrs;

	if(strcmp(param1, "read") == 0 )
  90714f:	1b69a9        	l32r	a11, 8e17f4 <athos_indirection_table_install+0x280>
  907152:	033a02        	or	a10, a3, a3
  907155:	5b7d02        	call8	8e6560 <strcmp>
  907158:	65a024        	bnez	a10, 907180 <db_intr_cmd+0x34>
	{
		{
			/* Update snapshot of pending interrupts */

			pending_intrs = A_INTR_GET_INTRPENDING();
  90715b:	146915        	l32r	a4, 8e15b0 <athos_indirection_table_install+0x3c>
  90715e:	2a424f        	l32i	a10, a4, 0x13c
  907161:	0ba000        	callx8	a10
  907164:	d2a0      	mov.n	a2, a10

			A_PRINTF("intr mask [0x%08x]\n\r", xthal_get_intenable());
  907166:	234212        	l32i	a3, a4, 72
  907169:	5b7e05        	call8	8e6980 <xthal_get_intenable>
  90716c:	dba0      	mov.n	a11, a10
  90716e:	1a69aa        	l32r	a10, 8e1818 <athos_indirection_table_install+0x2a4>
  907171:	0b3000        	callx8	a3
			A_PRINTF("intr on [0x%08x]\n\r", pending_intrs);
  907174:	1a69ab        	l32r	a10, 8e1820 <athos_indirection_table_install+0x2ac>
  907177:	234212        	l32i	a3, a4, 72
  90717a:	db20      	mov.n	a11, a2
  90717c:	600089        	j	907209 <db_intr_cmd+0xbd>
  90717f:	001b69        	excw
		}
	}
	else if (strcmp(param1, "timer") == 0 )
  907182:	acda      	add.n	a10, a13, a12
  907184:	305b7c        	excw
  907187:	f6          	.byte 0xf6
  907188:	65a084        	bnez	a10, 907210 <db_intr_cmd+0xc4>
	{
		uint32_t data = 0;

		if (strcmp(param2, "on") == 0 )
  90718b:	1b69ad        	l32r	a11, 8e1840 <athos_indirection_table_install+0x2cc>
			A_PRINTF("intr on [0x%08x]\n\r", pending_intrs);
		}
	}
	else if (strcmp(param1, "timer") == 0 )
	{
		uint32_t data = 0;
  90718e:	9a10      	s32i.n	a10, a1, 0

		if (strcmp(param2, "on") == 0 )
  907190:	da40      	mov.n	a10, a4
  907192:	5b7cf3        	call8	8e6560 <strcmp>
  907195:	65a013        	bnez	a10, 9071ac <db_intr_cmd+0x60>
		{
			/* TODO: this part is probably dead. */
			pending_intrs = A_INTR_GET_INTRENABLE()|CMNOS_IMASK_XTTIMER;
  907198:	146915        	l32r	a4, 8e15ec <athos_indirection_table_install+0x78>
  90719b:	230a02        	movi	a3, 2
  90719e:	2a424d        	l32i	a10, a4, 0x134
  9071a1:	0ba000        	callx8	a10
  9071a4:	03a302        	or	a3, a10, a3
  9071a7:	600019        	j	9071c4 <db_intr_cmd+0x78>
  9071aa:	00001b        	sra	a0, a0
			A_INTR_SET_INTRENABLE(pending_intrs);
			A_PRINTF("- intr [0x%08x]\n\r", pending_intrs);
		}
		else if ( strcmp(param2, "off") == 0 )
  9071ad:	69afda        	bnei	a10, 0x100, 90718b <db_intr_cmd+0x3f>
  9071b0:	405b7c        	excw
  9071b3:	eb          	.byte 0xeb
  9071b4:	cea5      	bnez.n	a10, 9071dd <db_intr_cmd+0x91>
		{
			pending_intrs = A_INTR_GET_INTRENABLE()&(~CMNOS_IMASK_XTTIMER);
  9071b6:	146915        	l32r	a4, 8e160c <athos_indirection_table_install+0x98>
  9071b9:	c73d      	movi.n	a3, -3
  9071bb:	2a424d        	l32i	a10, a4, 0x134
  9071be:	0ba000        	callx8	a10
  9071c1:	03a301        	and	a3, a10, a3
			A_INTR_SET_INTRENABLE(pending_intrs);
  9071c4:	22424e        	l32i	a2, a4, 0x138
  9071c7:	033a02        	or	a10, a3, a3
  9071ca:	0b2000        	callx8	a2
			A_PRINTF("- intr [0x%08x]\n\r", pending_intrs);
  9071cd:	1a69ae        	l32r	a10, 8e1888 <athos_indirection_table_install+0x314>
  9071d0:	244212        	l32i	a4, a4, 72
  9071d3:	db30      	mov.n	a11, a3
  9071d5:	0b4000        	callx8	a4
  9071d8:	600049        	j	907225 <db_intr_cmd+0xd9>
  9071db:	0000da        	excw
            
		}
		else if( db_ascii_to_hex(param2, &data)==0 )
  9071de:	40db10        	excw
  9071e1:	5bff0c        	call8	906e14 <db_ascii_to_hex>
  9071e4:	cfad      	bnez.n	a10, 907225 <db_intr_cmd+0xd9>
		{
			if( data>=0 && data <=10 )
  9071e6:	8410      	l32i.n	a4, a1, 0
  9071e8:	c02a      	movi.n	a2, 10
  9071ea:	1369b0        	l32r	a3, 8e18ac <athos_indirection_table_install+0x338>
  9071ed:	742304        	bltu	a2, a4, 9071f5 <db_intr_cmd+0xa9>
				delay = data;
  9071f0:	9430      	s32i.n	a4, a3, 0
  9071f2:	600004        	j	9071fa <db_intr_cmd+0xae>
			else
				delay = 3;
  9071f5:	c023      	movi.n	a2, 3
  9071f7:	223600        	s32i	a2, a3, 0
            
			A_PRINTF("==>set cb to %d seconds \n\r", delay);
  9071fa:	126915        	l32r	a2, 8e1650 <athos_indirection_table_install+0xdc>
  9071fd:	1a69b1        	l32r	a10, 8e18c4 <athos_indirection_table_install+0x350>
  907200:	232212        	l32i	a3, a2, 72
  907203:	1269b0        	l32r	a2, 8e18c4 <athos_indirection_table_install+0x350>
  907206:	2b2200        	l32i	a11, a2, 0
  907209:	0b3000        	callx8	a3
  90720c:	600015        	j	907225 <db_intr_cmd+0xd9>
  90720f:	001369        	excw
		}

	}
	else
	{
		A_PRINTF("\tintr read - read the interrenable status\n\r");
  907212:	151a69        	l32r	a5, 8cdbb8 <_bss_end+0x3baca8>
  907215:	b222      	addi.n	a2, a2, 2
  907217:	32120b        	excw
  90721a:	20001a        	l8ui	a0, a0, 26
		A_PRINTF("\tintr timer on/off/tick - timer attach on/off/ticks\n\r");
  90721d:	69b322        	bnei	a11, 3, 907243 <db_wdt_cmd+0x17>
  907220:	32120b        	excw
  907223:	2000c0        	l8ui	a0, a0, 192

	}

#endif //#if SYSTEM_MODULE_INTR
	return 0;
}
  907226:	20d10f        	l16ui	a0, a13, 30
  907229:	000000        	ill

0090722c <db_wdt_cmd>:
    extern htc_handle_t htc_handle;
    HTC_Ready(htc_handle);
}

static int db_wdt_cmd(char *cmd, char *param1, char *param2, char *param3)
{
  90722c:	6c1008        	entry	a1, 64
        if ( strcmp(param1, "rst") == 0 )
  90722f:	1b69b4        	l32r	a11, 8e1900 <athos_indirection_table_install+0x38c>
  907232:	033a02        	or	a10, a3, a3
  907235:	5b7cca        	call8	8e6560 <strcmp>
  907238:	cda1      	bnez.n	a10, 90724d <db_wdt_cmd+0x21>
        {
		A_PRINTF(" reseting...\n\n\r");
  90723a:	136915        	l32r	a3, 8e1690 <athos_indirection_table_install+0x11c>
  90723d:	1a69b5        	l32r	a10, 8e1914 <athos_indirection_table_install+0x3a0>
  907240:	243212        	l32i	a4, a3, 72
  907243:	0b4000        	callx8	a4
		A_WDT_RESET();
  907246:	22325d        	l32i	a2, a3, 0x174
  907249:	600010        	j	90725d <db_wdt_cmd+0x31>
  90724c:	001b69        	excw
        }
        else if( strcmp(param1, "on") == 0 )
  90724f:	adda      	add.n	a10, a13, a13
  907251:	305b7c        	excw
  907254:	c3cc      	movi.n	a12, 60
  907256:	ab12      	add.n	a2, a1, a11
        {
		A_WDT_ENABLE();
  907258:	691522        	bnei	a1, 5, 90727e <db_wdt_cmd+0x52>
  90725b:	22590b        	l16si	a2, a5, 22
  90725e:	2000d1        	l8ui	a0, a0, 209
  907261:	0f0000        	callx12	a0
        }
        else if (strcmp(param1, "off") == 0 )
  907264:	1b69af        	l32r	a11, 8e1920 <athos_indirection_table_install+0x3ac>
  907267:	da30      	mov.n	a10, a3
  907269:	5b7cbd        	call8	8e6560 <strcmp>
  90726c:	cca8      	bnez.n	a10, 907278 <db_wdt_cmd+0x4c>
        {
		A_WDT_DISABLE();
  90726e:	126915        	l32r	a2, 8e16c4 <athos_indirection_table_install+0x150>
  907271:	22225a        	l32i	a2, a2, 0x168
  907274:	63ffe5        	j	90725d <db_wdt_cmd+0x31>
  907277:	001b69        	excw
        }
        else if ( strcmp(param1, "boot") == 0 )
  90727a:	b6da      	addi.n	a10, a13, 6
  90727c:	305b7c        	excw
  90727f:	b8ce      	addi.n	a14, a12, 8
  907281:	a413      	add.n	a3, a1, a4
        {
		A_PRINTF("Last BOOT is ");
  907283:	69151a        	bnei	a1, 5, 9072a1 <db_wdt_cmd+0x75>
  907286:	69b724        	bnei	a11, 7, 9072ae <db_wdt_cmd+0x82>
  907289:	32120b        	excw
  90728c:	40002a        	excw
		if (ENUM_WDT_BOOT == A_WDT_LASTBOOT() )
  90728f:	325e0b        	excw
  907292:	a000      	add.n	a0, a0, a0
			A_PRINTF("wdt");
  907294:	233212        	l32i	a3, a3, 72
		A_WDT_DISABLE();
        }
        else if ( strcmp(param1, "boot") == 0 )
        {
		A_PRINTF("Last BOOT is ");
		if (ENUM_WDT_BOOT == A_WDT_LASTBOOT() )
  907297:	69a105        	bnei	a10, 1, 9072a0 <db_wdt_cmd+0x74>
			A_PRINTF("wdt");
  90729a:	1a69b8        	l32r	a10, 8e197c <athos_indirection_table_install+0x408>
  90729d:	600002        	j	9072a3 <db_wdt_cmd+0x77>
		else
			A_PRINTF("normal boot");
  9072a0:	1a69b9        	l32r	a10, 8e1984 <athos_indirection_table_install+0x410>
  9072a3:	0b3000        	callx8	a3
  9072a6:	d10f      	retw.n
        }
        else if (strcmp(param1, "loop") == 0 )
  9072a8:	1b69ba        	l32r	a11, 8e1990 <athos_indirection_table_install+0x41c>
  9072ab:	da30      	mov.n	a10, a3
  9072ad:	5b7cac        	call8	8e6560 <strcmp>
  9072b0:	ceac      	bnez.n	a10, 9072e0 <db_wdt_cmd+0xb4>
        {
		T_WDT_CMD wdt_cmd;
		uint32_t time_offset;
		A_PRINTF(" doing the wdt reseting...");
  9072b2:	136915        	l32r	a3, 8e1708 <athos_indirection_table_install+0x194>
  9072b5:	1a69bb        	l32r	a10, 8e19a4 <athos_indirection_table_install+0x430>
  9072b8:	253212        	l32i	a5, a3, 72
  9072bb:	0b5000        	callx8	a5

		if( db_ascii_to_hex(param2, &time_offset)!=0 )
  9072be:	da40      	mov.n	a10, a4
  9072c0:	2b1c10        	addi	a11, a1, 16
  9072c3:	5bfed4        	call8	906e14 <db_ascii_to_hex>
		{
			if( time_offset < 0 || time_offset >0xffffffff )
				time_offset = 0xffffff;
		}
		A_PRINTF(" (wdt tick: 0x%08x...\n\n\r", time_offset);
  9072c6:	2b1204        	l32i	a11, a1, 16
  9072c9:	243212        	l32i	a4, a3, 72
  9072cc:	1a69bc        	l32r	a10, 8e19bc <athos_indirection_table_install+0x448>
  9072cf:	0b4000        	callx8	a4
		wdt_cmd.cmd = WDT_TIMEOUT;
		wdt_cmd.timeout = time_offset;

		A_WDT_SET(wdt_cmd);
  9072d2:	8b14      	l32i.n	a11, a1, 16
  9072d4:	23325b        	l32i	a3, a3, 0x16c
  9072d7:	c0a1      	movi.n	a10, 1
  9072d9:	0b3000        	callx8	a3
  9072dc:	63fffc        	j	9072dc <db_wdt_cmd+0xb0>
  9072df:	001b69        	excw
		while(1) ;
        }
        else if (strcmp(param1, "noloop") == 0 )
  9072e2:	bdda      	addi.n	a10, a13, 13
  9072e4:	305b7c        	excw
  9072e7:	9ece      	s32i.n	a14, a12, 56
  9072e9:	ad13      	add.n	a3, a1, a13
        {
		T_WDT_CMD wdt_cmd;
		uint32_t time_offset;
		A_PRINTF(" doing the wdt reseting...");
  9072eb:	69151a        	bnei	a1, 5, 907309 <db_wdt_cmd+0xdd>
  9072ee:	69bb24        	bnei	a11, 16, 907316 <db_wdt_cmd+0xea>
  9072f1:	32120b        	excw
  9072f4:	40002b        	excw

		if( db_ascii_to_hex(param3, &time_offset)!=0 )
  9072f7:	1c10da        	l32r	a12, 8cb660 <_bss_end+0x3b8750>
  9072fa:	505bfe        	call0	91e2f4 <_etext+0xf1db>
  9072fd:	c62b      	movi.n	a2, -21
		{
			if( time_offset < 0 || time_offset >0xffffffff )
				time_offset = 0xffffff;
		}
		A_PRINTF(" (wdt tick: 0x%08x...\n\n\r", time_offset);
  9072ff:	120424        	l32r	a2, 8c8390 <_bss_end+0x3b5480>
  907302:	32121a        	excw
  907305:	69bc0b        	bnei	a11, 32, 907314 <db_wdt_cmd+0xe8>
  907308:	40008b        	excw

		wdt_cmd.cmd = WDT_TIMEOUT;
		wdt_cmd.timeout = time_offset;

		A_WDT_SET(wdt_cmd);
  90730b:	142332        	l32r	a4, 8cffd4 <_bss_end+0x3bd0c4>
  90730e:	5bc0a1        	call8	8f7594 <memset+0x1074c>
  907311:	0b3000        	callx8	a3
  907314:	d10f      	retw.n
  907316:	000000        	ill
        }
        else if( strcmp(param1, "event") == 0 )
  907319:	1b69be        	l32r	a11, 8e1a14 <athos_indirection_table_install+0x4a0>
  90731c:	da30      	mov.n	a10, a3
  90731e:	5b7c90        	call8	8e6560 <strcmp>
  907321:	65a04f        	bnez	a10, 907374 <db_wdt_cmd+0x148>

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  907324:	13695c        	l32r	a3, 8e1894 <athos_indirection_table_install+0x320>
        {
		uint32_t event= 0x00123400;

		/* disable ep3 intr */
		iowrite8_usb(0x17, ioread8_usb(0x17)|0xc0);
  907327:	240ac0        	movi	a4, 192
  90732a:	223000        	l8ui	a2, a3, 0
  90732d:	18695f        	l32r	a8, 8e18ac <athos_indirection_table_install+0x338>
  907330:	020247        	extui	a2, a2, 0, 8
  907333:	042202        	or	a2, a2, a4
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  907336:	0c0200        	memw
  907339:	223400        	s8i	a2, a3, 0
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90733c:	12693c        	l32r	a2, 8e182c <athos_indirection_table_install+0x2b8>
  90733f:	c04f      	movi.n	a4, 15
  907341:	0c0200        	memw
  907344:	9420      	s32i.n	a4, a2, 0
  907346:	1469bf        	l32r	a4, 8e1a44 <athos_indirection_table_install+0x4d0>
  907349:	12695d        	l32r	a2, 8e18c0 <athos_indirection_table_install+0x34c>
  90734c:	0c0200        	memw
  90734f:	9420      	s32i.n	a4, a2, 0

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  907351:	228000        	l8ui	a2, a8, 0

		/* ZM_EP3_DATA_REG = event; */
		iowrite32_usb(0xF8, event);

		/* tx done */
		iowrite8_usb(0xAE, ioread8_usb(0xAE) | 0x08);
  907354:	c048      	movi.n	a4, 8
  907356:	020247        	extui	a2, a2, 0, 8
  907359:	042202        	or	a2, a2, a4
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  90735c:	0c0200        	memw
  90735f:	228400        	s8i	a2, a8, 0

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  907362:	223000        	l8ui	a2, a3, 0

		/* enable ep3 intr */
		iowrite8_usb(0x17, ioread8_usb(0x17) & 0xbf);
  907365:	24fabf        	movi	a4, -65
  907368:	020247        	extui	a2, a2, 0, 8
  90736b:	042201        	and	a2, a2, a4
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  90736e:	0c0200        	memw
  907371:	223400        	s8i	a2, a3, 0
        }
}
  907374:	d10f      	retw.n
	...

00907378 <db_usb_cmd>:
#endif //#if SYSTEM_MODULE_INTR
	return 0;
}

static int db_usb_cmd(char *cmd, char *param1, char *param2, char *param3)
{
  907378:	6c1004        	entry	a1, 32
	A_PRINTF("THIS IS USB COMMAND\n\r");
  90737b:	126915        	l32r	a2, 8e17d0 <athos_indirection_table_install+0x25c>
  90737e:	1a69c0        	l32r	a10, 8e1a80 <athos_indirection_table_install+0x50c>
  907381:	282212        	l32i	a8, a2, 72
  907384:	0b8000        	callx8	a8

	if( strcmp(param1, "que") == 0 )
  907387:	1b69c1        	l32r	a11, 8e1a8c <athos_indirection_table_install+0x518>
  90738a:	033a02        	or	a10, a3, a3
  90738d:	5b7c74        	call8	8e6560 <strcmp>
  907390:	cca4      	bnez.n	a10, 907398 <db_usb_cmd+0x20>
	{
		HIFusb_DescTraceDump();
  907392:	5b7115        	call8	8e37e8 <HIFusb_DescTraceDump>
  907395:	600011        	j	9073aa <db_usb_cmd+0x32>
	}
	else
	{
		A_PRINTF("\tusb que - dump descriptor queue\n\r");
  907398:	282212        	l32i	a8, a2, 72
  90739b:	1a69c2        	l32r	a10, 8e1aa4 <athos_indirection_table_install+0x530>
  90739e:	0b8000        	callx8	a8
		A_PRINTF("\tusb fw on/off - enable/disable write fw download to ram\n\r");
  9073a1:	1a69c3        	l32r	a10, 8e1ab0 <athos_indirection_table_install+0x53c>
  9073a4:	222212        	l32i	a2, a2, 72
  9073a7:	0b2000        	callx8	a2

	}
	return 0;
}
  9073aa:	c020      	movi.n	a2, 0
  9073ac:	d10f      	retw.n
	...

009073b0 <db_info_cmd>:
		clk_change(clk, ratio, baud);
	}
}

static int db_info_cmd(char *cmd, char *param1, char *param2, char *param3)
{
  9073b0:	6c1004        	entry	a1, 32
#if 1

	if(strcmp(param1, "ram") == 0 )
  9073b3:	1b69c4        	l32r	a11, 8e1ac4 <athos_indirection_table_install+0x550>
  9073b6:	033a02        	or	a10, a3, a3
  9073b9:	5b7c69        	call8	8e6560 <strcmp>
  9073bc:	65a00d        	bnez	a10, 9073cd <db_info_cmd+0x1d>
	{
		A_ALLOCRAM_DEBUG();
  9073bf:	186915        	l32r	a8, 8e1814 <athos_indirection_table_install+0x2a0>
  9073c2:	288253        	l32i	a8, a8, 0x14c
  9073c5:	0b8000        	callx8	a8
  9073c8:	600004        	j	9073d0 <db_info_cmd+0x20>
  9073cb:	00005b        	extui	a0, a0, 16, 12
	* is dead too */
	else if(strcmp(param1, "cpu") == 0)
		zfPrintCpuUtilization();
#endif
	else   // defalut dump
		HIFusb_DescTraceDump();
  9073ce:	7106c0        	bbci	a0, 1, 907392 <db_usb_cmd+0x1a>
		A_PRINTF("read 0x%08x (0x%08x) use %d clocks\n\r", data3, data, ccount2-ccount1);

	}
#endif
	return 1;
}
  9073d1:	21d10f        	l16ui	a1, a13, 30

009073d4 <zf_debug_task>:
	gvLen = 0;
	pressed_time = 0;
}

static void zf_debug_task(void)
{
  9073d4:	6c1006        	entry	a1, 48
	int i;
	uint8_t ch;

	if ((zm_get_char(&ch)) == 0)
  9073d7:	136915        	l32r	a3, 8e182c <athos_indirection_table_install+0x2b8>
  9073da:	da10      	mov.n	a10, a1
  9073dc:	223215        	l32i	a2, a3, 84
  9073df:	0b2000        	callx8	a2
  9073e2:	64a250        	beqz	a10, 907636 <zf_debug_task+0x262>
	{
		return;
	}

	if (db_get_cmd_line(ch, raw_cmd, &gvLen) == 0)
  9073e5:	2b1000        	l8ui	a11, a1, 0

static uint16_t db_get_cmd_line(uint8_t ch, char *cmd_line, uint16_t *i)
{
	int cmd_buf_loc;

	switch (ch)
  9073e8:	69b802        	bnei	a11, 8, 9073ee <zf_debug_task+0x1a>
  9073eb:	6000f6        	j	9074e5 <zf_debug_task+0x111>
  9073ee:	c028      	movi.n	a2, 8
  9073f0:	7b2306        	bltu	a2, a11, 9073fa <zf_debug_task+0x26>
  9073f3:	64b23f        	beqz	a11, 907636 <zf_debug_task+0x262>
  9073f6:	60010a        	j	907504 <zf_debug_task+0x130>
  9073f9:	00c02d        	excw
  9073fc:	72b179        	beq	a11, a2, 907479 <zf_debug_task+0xa5>
  9073ff:	c52c      	movi.n	a2, 92
  907401:	72b102        	beq	a11, a2, 907407 <zf_debug_task+0x33>
  907404:	6000fc        	j	907504 <zf_debug_task+0x130>
	{
	case '\\' : /* Last command */
		pressed_time++;
  907407:	126993        	l32r	a2, 8e1a54 <athos_indirection_table_install+0x4e0>
  90740a:	8320      	l32i.n	a3, a2, 0
  90740c:	b133      	addi.n	a3, a3, 1
		if (pressed_time >= COMMAND_BUFFER_SIZE)
  90740e:	6b3602        	bgei	a3, 6, 907414 <zf_debug_task+0x40>
	int cmd_buf_loc;

	switch (ch)
	{
	case '\\' : /* Last command */
		pressed_time++;
  907411:	232600        	s32i	a3, a2, 0
		if (pressed_time >= COMMAND_BUFFER_SIZE)
		{
			pressed_time--;
		}
		cmd_buf_loc = cmd_buf_ptr - pressed_time;
  907414:	136990        	l32r	a3, 8e1a54 <athos_indirection_table_install+0x4e0>
  907417:	8220      	l32i.n	a2, a2, 0
  907419:	8a30      	l32i.n	a10, a3, 0
  90741b:	02aa0c        	sub	a10, a10, a2
		if (cmd_buf_loc < 0)
  90741e:	67a00e        	bgez	a10, 907430 <zf_debug_task+0x5c>
		{
			if (cmd_buf_full == TRUE)
  907421:	126991        	l32r	a2, 8e1a68 <athos_indirection_table_install+0x4f4>
  907424:	8320      	l32i.n	a3, a2, 0
			{
				cmd_buf_loc += COMMAND_BUFFER_SIZE;
  907426:	b6a2      	addi.n	a2, a10, 6
  907428:	b033      	addi.n	a3, a3, -1
  90742a:	2a0a00        	movi	a10, 0
  90742d:	032a38        	moveqz	a10, a2, a3
			{
				cmd_buf_loc = 0;
			}
		}

		if (A_STRLEN(cmd_buffer[cmd_buf_loc]) != 0)
  907430:	1269c5        	l32r	a2, 8e1b44 <athos_indirection_table_install+0x5d0>
  907433:	0aaa0a        	addx4	a10, a10, a10
  907436:	02a30b        	addx8	a3, a10, a2
  907439:	126915        	l32r	a2, 8e1890 <athos_indirection_table_install+0x31c>
  90743c:	033a02        	or	a10, a3, a3
  90743f:	242266        	l32i	a4, a2, 0x198
  907442:	0b4000        	callx8	a4
  907445:	64a1ed        	beqz	a10, 907636 <zf_debug_task+0x262>
		{
			A_STRCPY(cmd_line, cmd_buffer[cmd_buf_loc]);
  907448:	1469c6        	l32r	a4, 8e1b60 <athos_indirection_table_install+0x5ec>
  90744b:	252264        	l32i	a5, a2, 0x190
  90744e:	db30      	mov.n	a11, a3
  907450:	da40      	mov.n	a10, a4
  907452:	0b5000        	callx8	a5
			*i = A_STRLEN(cmd_buffer[cmd_buf_loc]);
  907455:	252266        	l32i	a5, a2, 0x198
  907458:	da30      	mov.n	a10, a3
  90745a:	0b5000        	callx8	a5
  90745d:	136992        	l32r	a3, 8e1aa8 <athos_indirection_table_install+0x534>
  907460:	2a3500        	s16i	a10, a3, 0
			A_PRINTF("\r>");
  907463:	232212        	l32i	a3, a2, 72
  907466:	1a69c7        	l32r	a10, 8e1b84 <athos_indirection_table_install+0x610>
  907469:	0b3000        	callx8	a3
			A_PRINTF("%s", cmd_line);
  90746c:	1a69c8        	l32r	a10, 8e1b8c <athos_indirection_table_install+0x618>
  90746f:	222212        	l32i	a2, a2, 72
  907472:	db40      	mov.n	a11, a4
  907474:	6000d1        	j	907549 <zf_debug_task+0x175>
  907477:	000012        	srai	a0, a0, 0
		}
		break;
	case 13 : /* Return */
		pressed_time = 0;
  90747a:	6993c0        	bnei	a9, 3, 90743e <zf_debug_task+0x6a>
  90747d:	509520        	call0	92c900 <_etext+0x1d7e7>
		cmd_line[*i] = 0;
  907480:	126992        	l32r	a2, 8e1ac8 <athos_indirection_table_install+0x554>
  907483:	1469c6        	l32r	a4, 8e1b9c <athos_indirection_table_install+0x628>
  907486:	262100        	l16ui	a6, a2, 0
		A_PRINTF("\n\r");
  907489:	1a69a0        	l32r	a10, 8e1b0c <athos_indirection_table_install+0x598>
			A_PRINTF("%s", cmd_line);
		}
		break;
	case 13 : /* Return */
		pressed_time = 0;
		cmd_line[*i] = 0;
  90748c:	064608        	add	a6, a4, a6
  90748f:	256400        	s8i	a5, a6, 0
		A_PRINTF("\n\r");
  907492:	253212        	l32i	a5, a3, 72
  907495:	0b5000        	callx8	a5
		if (*i != 0)
  907498:	222100        	l16ui	a2, a2, 0
  90749b:	ca2d      	beqz.n	a2, 9074cc <zf_debug_task+0xf8>
		{
			//Filter duplicated string in command history
			if (strcmp(cmd_buffer[(cmd_buf_ptr==0)?(COMMAND_BUFFER_SIZE-1):(cmd_buf_ptr-1)], cmd_line) != 0)
  90749d:	166990        	l32r	a6, 8e1ae0 <athos_indirection_table_install+0x56c>
  9074a0:	c0a5      	movi.n	a10, 5
  9074a2:	8260      	l32i.n	a2, a6, 0
  9074a4:	db40      	mov.n	a11, a4
  9074a6:	252cff        	addi	a5, a2, -1
  9074a9:	025a39        	movnez	a10, a5, a2
  9074ac:	1569c5        	l32r	a5, 8e1bc0 <athos_indirection_table_install+0x64c>
  9074af:	0aaa0a        	addx4	a10, a10, a10
  9074b2:	05aa0b        	addx8	a10, a10, a5
  9074b5:	5b7c2a        	call8	8e6560 <strcmp>
  9074b8:	c9a0      	beqz.n	a10, 9074cc <zf_debug_task+0xf8>
			{
				A_STRCPY(cmd_buffer[cmd_buf_ptr++], cmd_line);
  9074ba:	b127      	addi.n	a7, a2, 1
  9074bc:	022a0a        	addx4	a10, a2, a2
  9074bf:	233264        	l32i	a3, a3, 0x190
  9074c2:	9760      	s32i.n	a7, a6, 0
  9074c4:	05aa0b        	addx8	a10, a10, a5
  9074c7:	db40      	mov.n	a11, a4
  9074c9:	0b3000        	callx8	a3
			}
		}
		if (cmd_buf_ptr >= COMMAND_BUFFER_SIZE)
  9074cc:	126990        	l32r	a2, 8e1b0c <athos_indirection_table_install+0x598>
  9074cf:	8320      	l32i.n	a3, a2, 0
  9074d1:	6b3602        	bgei	a3, 6, 9074d7 <zf_debug_task+0x103>
  9074d4:	600148        	j	907620 <zf_debug_task+0x24c>
		{
			cmd_buf_ptr = 0;
  9074d7:	c030      	movi.n	a3, 0
  9074d9:	9320      	s32i.n	a3, a2, 0
			cmd_buf_full = TRUE;
  9074db:	126991        	l32r	a2, 8e1b20 <athos_indirection_table_install+0x5ac>
  9074de:	c031      	movi.n	a3, 1
  9074e0:	9320      	s32i.n	a3, a2, 0
  9074e2:	60013a        	j	907620 <zf_debug_task+0x24c>
		}
		return 1;
	case '\b' : /* Backspace */
		pressed_time = 0;
  9074e5:	126993        	l32r	a2, 8e1b34 <athos_indirection_table_install+0x5c0>
  9074e8:	c040      	movi.n	a4, 0
  9074ea:	9420      	s32i.n	a4, a2, 0
		if (*i > 0)
  9074ec:	126992        	l32r	a2, 8e1b34 <athos_indirection_table_install+0x5c0>
  9074ef:	242100        	l16ui	a4, a2, 0
  9074f2:	644140        	beqz	a4, 907636 <zf_debug_task+0x262>
		{
			*i = *i-1;
  9074f5:	b044      	addi.n	a4, a4, -1
  9074f7:	242500        	s16i	a4, a2, 0
			A_PRINTF("\b \b");
  9074fa:	1a69c9        	l32r	a10, 8e1c20 <athos_indirection_table_install+0x6ac>
  9074fd:	223212        	l32i	a2, a3, 72
  907500:	600115        	j	907619 <zf_debug_task+0x245>
  907503:	0022bc        	excw
		}
		break;
	case 0 : //None
		break;
	default :
		if ((ch >= ' ') && (ch <= '~'))
  907506:	e0          	.byte 0xe0
  907507:	020247        	extui	a2, a2, 0, 8
  90750a:	c53e      	movi.n	a3, 94
  90750c:	72332d        	bltu	a3, a2, 90753d <zf_debug_task+0x169>
		{
			pressed_time = 0;
  90750f:	126993        	l32r	a2, 8e1b5c <athos_indirection_table_install+0x5e8>
  907512:	c030      	movi.n	a3, 0
  907514:	9320      	s32i.n	a3, a2, 0
			if (*i < DB_MAX_COMMAND_LENGTH-2)
  907516:	136992        	l32r	a3, 8e1b60 <athos_indirection_table_install+0x5ec>
  907519:	c245      	movi.n	a4, 37
  90751b:	223100        	l16ui	a2, a3, 0
  90751e:	724b02        	bgeu	a4, a2, 907524 <zf_debug_task+0x150>
  907521:	600111        	j	907636 <zf_debug_task+0x262>
				{
					//if ((buf <= 'z') && (buf >= 'a'))
					//{
					//    buf -= 'a' - 'A';
					//}
					cmd_line[*i] = ch;
  907524:	1469c6        	l32r	a4, 8e1c3c <athos_indirection_table_install+0x6c8>
					*i = *i + 1;
					A_PRINTF("%c", ch);
  907527:	1a699e        	l32r	a10, 8e1ba0 <athos_indirection_table_install+0x62c>
				{
					//if ((buf <= 'z') && (buf >= 'a'))
					//{
					//    buf -= 'a' - 'A';
					//}
					cmd_line[*i] = ch;
  90752a:	a244      	add.n	a4, a4, a2
					*i = *i + 1;
  90752c:	b122      	addi.n	a2, a2, 1
  90752e:	223500        	s16i	a2, a3, 0
					A_PRINTF("%c", ch);
  907531:	126915        	l32r	a2, 8e1988 <athos_indirection_table_install+0x414>
				{
					//if ((buf <= 'z') && (buf >= 'a'))
					//{
					//    buf -= 'a' - 'A';
					//}
					cmd_line[*i] = ch;
  907534:	2b4400        	s8i	a11, a4, 0
					*i = *i + 1;
					A_PRINTF("%c", ch);
  907537:	222212        	l32i	a2, a2, 72
  90753a:	60000b        	j	907549 <zf_debug_task+0x175>
			}
		}
		else
		{
			ch = 7; /* Beep */
			A_PRINTF("%c", ch);
  90753d:	126915        	l32r	a2, 8e1994 <athos_indirection_table_install+0x420>
  907540:	1a699e        	l32r	a10, 8e1bb8 <athos_indirection_table_install+0x644>
  907543:	222212        	l32i	a2, a2, 72
  907546:	2b0a07        	movi	a11, 7
  907549:	0b2000        	callx8	a2
  90754c:	d10f      	retw.n
  90754e:	000012        	srai	a0, a0, 0
	cmd_buf_full = FALSE;
	gvLen = 0;
	pressed_time = 0;
}

static void zf_debug_task(void)
  907551:	69c6c0        	bnei	a12, 6, 907515 <zf_debug_task+0x141>
  907554:	b1a2      	addi.n	a2, a10, 1
  907556:	c922      	beqz.n	a2, 90756c <zf_debug_task+0x198>


	for (k=0; k<4; k++)
	{
		/* Remove preceeding spaces */
		while (raw_str[i++] == ' '){}
  907558:	9000      	s32i.n	a0, a0, 0
  90755a:	b1cc      	addi.n	a12, a12, 1
	cmd_buf_full = FALSE;
	gvLen = 0;
	pressed_time = 0;
}

static void zf_debug_task(void)
  90755c:	a8a7      	add.n	a7, a10, a8


	for (k=0; k<4; k++)
	{
		/* Remove preceeding spaces */
		while (raw_str[i++] == ' '){}
  90755e:	692c2b        	bnei	a2, 32, 90758d <zf_debug_task+0x1b9>
  907561:	63ffeb        	j	907550 <zf_debug_task+0x17c>

		/* Copy command string */
		j = 0;
		while(raw_str[i] && (raw_str[i] != ' '))
		{
			if (k == 0)
  907564:	cdea      	bnez.n	a14, 907582 <zf_debug_task+0x1ae>
			{
				if ((raw_str[i] <= 'z') && (raw_str[i] >= 'a'))
  907566:	22dc9f        	addi	a2, a13, -97
  907569:	020247        	extui	a2, a2, 0, 8
  90756c:	723305        	bltu	a3, a2, 907575 <zf_debug_task+0x1a1>
				{
					raw_str[i] -= 'a' - 'A';
  90756f:	2ddce0        	addi	a13, a13, -32
  907572:	2d9400        	s8i	a13, a9, 0
	cmd_buf_full = FALSE;
	gvLen = 0;
	pressed_time = 0;
}

static void zf_debug_task(void)
  907575:	afb2      	add.n	a2, a11, a15
			{
				if ((raw_str[i] <= 'z') && (raw_str[i] >= 'a'))
				{
					raw_str[i] -= 'a' - 'A';
				}
				cmd_str[k*DB_MAX_COMMAND_LENGTH + j++] = raw_str[i++];
  907577:	269000        	l8ui	a6, a9, 0
	cmd_buf_full = FALSE;
	gvLen = 0;
	pressed_time = 0;
}

static void zf_debug_task(void)
  90757a:	b022      	addi.n	a2, a2, -1
			{
				if ((raw_str[i] <= 'z') && (raw_str[i] >= 'a'))
				{
					raw_str[i] -= 'a' - 'A';
				}
				cmd_str[k*DB_MAX_COMMAND_LENGTH + j++] = raw_str[i++];
  90757c:	262400        	s8i	a6, a2, 0
  90757f:	600006        	j	907589 <zf_debug_task+0x1b5>
	cmd_buf_full = FALSE;
	gvLen = 0;
	pressed_time = 0;
}

static void zf_debug_task(void)
  907582:	ab72      	add.n	a2, a7, a11
  907584:	b022      	addi.n	a2, a2, -1
				}
				cmd_str[k*DB_MAX_COMMAND_LENGTH + j++] = raw_str[i++];
			}
			else
			{
				cmd_str[k*DB_MAX_COMMAND_LENGTH + j++] = raw_str[i++];
  907586:	2d2400        	s8i	a13, a2, 0
  907589:	b199      	addi.n	a9, a9, 1
  90758b:	b1bb      	addi.n	a11, a11, 1
		while (raw_str[i++] == ' '){}
		i--;

		/* Copy command string */
		j = 0;
		while(raw_str[i] && (raw_str[i] != ' '))
  90758d:	2d9000        	l8ui	a13, a9, 0
	cmd_buf_full = FALSE;
	gvLen = 0;
	pressed_time = 0;
}

static void zf_debug_task(void)
  907590:	059c0c        	sub	a12, a9, a5
		while (raw_str[i++] == ' '){}
		i--;

		/* Copy command string */
		j = 0;
		while(raw_str[i] && (raw_str[i] != ' '))
  907593:	04d201        	and	a2, a13, a4
	cmd_buf_full = FALSE;
	gvLen = 0;
	pressed_time = 0;
}

static void zf_debug_task(void)
  907596:	b0b6      	addi.n	a6, a11, -1
		while (raw_str[i++] == ' '){}
		i--;

		/* Copy command string */
		j = 0;
		while(raw_str[i] && (raw_str[i] != ' '))
  907598:	652fc8        	bnez	a2, 907564 <zf_debug_task+0x190>
			else
			{
				cmd_str[k*DB_MAX_COMMAND_LENGTH + j++] = raw_str[i++];
			}
		}
		cmd_str[k*DB_MAX_COMMAND_LENGTH + j] = 0;
  90759b:	a8a7      	add.n	a7, a10, a8
  90759d:	067608        	add	a6, a7, a6
  9075a0:	226400        	s8i	a2, a6, 0
  9075a3:	288c28        	addi	a8, a8, 40
	int i = 0;
	int j;
	int k;


	for (k=0; k<4; k++)
  9075a6:	260aa0        	movi	a6, 160
  9075a9:	2eec01        	addi	a14, a14, 1
  9075ac:	7689a0        	bne	a8, a6, 907550 <zf_debug_task+0x17c>
				cmd_str[k*DB_MAX_COMMAND_LENGTH + j++] = raw_str[i++];
			}
		}
		cmd_str[k*DB_MAX_COMMAND_LENGTH + j] = 0;
	}
	return (int)A_STRLEN(cmd_str);
  9075af:	136915        	l32r	a3, 8e1a04 <athos_indirection_table_install+0x490>
  9075b2:	233266        	l32i	a3, a3, 0x198
  9075b5:	0b3000        	callx8	a3
	if (db_get_cmd_line(ch, raw_cmd, &gvLen) == 0)
	{
		return;
	}

	if (db_formalize_command(raw_cmd, cmd_str))
  9075b8:	64a054        	beqz	a10, 907610 <zf_debug_task+0x23c>
	{
		gvLen = 0;
  9075bb:	136992        	l32r	a3, 8e1c04 <athos_indirection_table_install+0x690>
  9075be:	223500        	s16i	a2, a3, 0
		i = 0;

		cmd_not_found = TRUE;
  9075c1:	1269cb        	l32r	a2, 8e1cf0 <athos_indirection_table_install+0x77c>
  9075c4:	c031      	movi.n	a3, 1
  9075c6:	9320      	s32i.n	a3, a2, 0
  9075c8:	126997        	l32r	a2, 8e1c24 <athos_indirection_table_install+0x6b0>
		while(command_table[i].cmd_func)
		{
			if (!strcmp(command_table[i].cmd_str, cmd_str))
  9075cb:	1369ca        	l32r	a3, 8e1cf4 <athos_indirection_table_install+0x780>
  9075ce:	600026        	j	9075f8 <zf_debug_task+0x224>
	cmd_buf_full = FALSE;
	gvLen = 0;
	pressed_time = 0;
}

static void zf_debug_task(void)
  9075d1:	252cf8        	addi	a5, a2, -8
		i = 0;

		cmd_not_found = TRUE;
		while(command_table[i].cmd_func)
		{
			if (!strcmp(command_table[i].cmd_str, cmd_str))
  9075d4:	8a50      	l32i.n	a10, a5, 0
  9075d6:	033b02        	or	a11, a3, a3
  9075d9:	5b7be1        	call8	8e6560 <strcmp>
  9075dc:	bc22      	addi.n	a2, a2, 12
  9075de:	cda6      	bnez.n	a10, 9075f8 <zf_debug_task+0x224>
			{
				cmd_not_found = FALSE;
  9075e0:	1269cb        	l32r	a2, 8e1d0c <athos_indirection_table_install+0x798>
				command_table[i].cmd_func(cmd_str,
  9075e3:	1b69cc        	l32r	a11, 8e1d14 <athos_indirection_table_install+0x7a0>
  9075e6:	1c69cd        	l32r	a12, 8e1d1c <athos_indirection_table_install+0x7a8>
  9075e9:	1d69ce        	l32r	a13, 8e1d24 <athos_indirection_table_install+0x7b0>
		cmd_not_found = TRUE;
		while(command_table[i].cmd_func)
		{
			if (!strcmp(command_table[i].cmd_str, cmd_str))
			{
				cmd_not_found = FALSE;
  9075ec:	9a20      	s32i.n	a10, a2, 0
				command_table[i].cmd_func(cmd_str,
  9075ee:	033a02        	or	a10, a3, a3
  9075f1:	0b4000        	callx8	a4
  9075f4:	600005        	j	9075fd <zf_debug_task+0x229>
  9075f7:	008420        	excw
	{
		gvLen = 0;
		i = 0;

		cmd_not_found = TRUE;
		while(command_table[i].cmd_func)
  9075fa:	654fd3        	bnez	a4, 9075d1 <zf_debug_task+0x1fd>
							  cmd_str+DB_MAX_COMMAND_LENGTH*3);
				break;
			}
			i++;
		}
		if (cmd_not_found)
  9075fd:	1269cb        	l32r	a2, 8e1d2c <athos_indirection_table_install+0x7b8>
  907600:	8220      	l32i.n	a2, a2, 0
  907602:	c82a      	beqz.n	a2, 907610 <zf_debug_task+0x23c>
		{
			A_PRINTF("Error, HELP for command list.\n\r");
  907604:	126915        	l32r	a2, 8e1a58 <athos_indirection_table_install+0x4e4>
  907607:	1a69cf        	l32r	a10, 8e1d44 <athos_indirection_table_install+0x7d0>
  90760a:	222212        	l32i	a2, a2, 72
  90760d:	0b2000        	callx8	a2
		}

	}

	A_PRINTF(">");
  907610:	126915        	l32r	a2, 8e1a64 <athos_indirection_table_install+0x4f0>
  907613:	1a69d0        	l32r	a10, 8e1d54 <athos_indirection_table_install+0x7e0>
  907616:	222212        	l32i	a2, a2, 72
  907619:	0b2000        	callx8	a2
  90761c:	d10f      	retw.n
  90761e:	00001a        	sll	a0, a0
  907621:	69cac0        	bnei	a12, 12, 9075e5 <zf_debug_task+0x211>
		cmd_line[*i] = 0;
		A_PRINTF("\n\r");
		if (*i != 0)
		{
			//Filter duplicated string in command history
			if (strcmp(cmd_buffer[(cmd_buf_ptr==0)?(COMMAND_BUFFER_SIZE-1):(cmd_buf_ptr-1)], cmd_line) != 0)
  907624:	80dc      	l32i.n	a0, a13, 48
  907626:	80de      	l32i.n	a0, a13, 56
  907628:	8015      	l32i.n	a0, a1, 20
	cmd_buf_full = FALSE;
	gvLen = 0;
	pressed_time = 0;
}

static void zf_debug_task(void)
  90762a:	69c624        	bnei	a12, 6, 907652 <db_ascii_to_int+0x1a>
		while (raw_str[i++] == ' '){}
		i--;

		/* Copy command string */
		j = 0;
		while(raw_str[i] && (raw_str[i] != ' '))
  90762d:	fa          	.byte 0xfa
  90762e:	dfc1      	excw
		{
			if (k == 0)
			{
				if ((raw_str[i] <= 'z') && (raw_str[i] >= 'a'))
  907630:	39dfa0        	excw
	cmd_buf_full = FALSE;
	gvLen = 0;
	pressed_time = 0;
}

static void zf_debug_task(void)
  907633:	63ff19        	j	907550 <zf_debug_task+0x17c>
  907636:	d10f      	retw.n

00907638 <db_ascii_to_int>:
	}
	return 0;
}

int db_ascii_to_int(char *num_str, unsigned long *int_num)
{
  907638:	6c1004        	entry	a1, 32
	int i = 0;

	*int_num = 0;
  90763b:	c080      	movi.n	a8, 0
  90763d:	9830      	s32i.n	a8, a3, 0
	while (num_str[i])
	{
		if ((num_str[i] >= '0') && (num_str[i] <= '9'))
  90763f:	c099      	movi.n	a9, 9
int db_ascii_to_int(char *num_str, unsigned long *int_num)
{
	int i = 0;

	*int_num = 0;
	while (num_str[i])
  907641:	60001e        	j	907663 <db_ascii_to_int+0x2b>
	{
		if ((num_str[i] >= '0') && (num_str[i] <= '9'))
  907644:	288cd0        	addi	a8, a8, -48
  907647:	080847        	extui	a8, a8, 0, 8
  90764a:	78931f        	bltu	a9, a8, 90766d <db_ascii_to_int+0x35>
		{
			*int_num *= 10;
  90764d:	8830      	l32i.n	a8, a3, 0
  90764f:	08880a        	addx4	a8, a8, a8
  907652:	0f8811        	slli	a8, a8, 1
  907655:	9830      	s32i.n	a8, a3, 0
			*int_num += (num_str[i] - '0');
  907657:	2a2000        	l8ui	a10, a2, 0
  90765a:	288cd0        	addi	a8, a8, -48
  90765d:	aa88      	add.n	a8, a8, a10
  90765f:	9830      	s32i.n	a8, a3, 0
  907661:	b122      	addi.n	a2, a2, 1
int db_ascii_to_int(char *num_str, unsigned long *int_num)
{
	int i = 0;

	*int_num = 0;
	while (num_str[i])
  907663:	282000        	l8ui	a8, a2, 0
  907666:	658fda        	bnez	a8, 907644 <db_ascii_to_int+0xc>
		{
			return -1;
		}
		i++;
	}
	return 0;
  907669:	d280      	mov.n	a2, a8
  90766b:	d10f      	retw.n
			*int_num *= 10;
			*int_num += (num_str[i] - '0');
		}
		else
		{
			return -1;
  90766d:	c72f      	movi.n	a2, -1
		}
		i++;
	}
	return 0;
}
  90766f:	d10f      	retw.n
  907671:	000000        	ill

00907674 <db_clock_cmd>:
	A_UART_HWINIT((clk*1000*1000)/ratio, baud);

}

static int db_clock_cmd(char *cmd, char *param1, char *param2, char *param3)
{
  907674:	6c1006        	entry	a1, 48
	uint32_t ratio = 1;
	uint32_t baud = 19200;
	uint32_t clk = 0;
  907677:	c020      	movi.n	a2, 0
    
	if( db_ascii_to_int(param1, &clk) != -1 )
  907679:	033a02        	or	a10, a3, a3
  90767c:	db10      	mov.n	a11, a1

static int db_clock_cmd(char *cmd, char *param1, char *param2, char *param3)
{
	uint32_t ratio = 1;
	uint32_t baud = 19200;
	uint32_t clk = 0;
  90767e:	221600        	s32i	a2, a1, 0
    
	if( db_ascii_to_int(param1, &clk) != -1 )
  907681:	5bffed        	call8	907638 <db_ascii_to_int>
  907684:	68a059        	beqi	a10, -1, 9076e1 <db_clock_cmd+0x6d>
	{
		A_PRINTF("changing clock to %d\n", clk);
  907687:	186915        	l32r	a8, 8e1adc <athos_indirection_table_install+0x568>
  90768a:	1a69d1        	l32r	a10, 8e1dd0 <athos_indirection_table_install+0x85c>
  90768d:	288212        	l32i	a8, a8, 72
  907690:	8b10      	l32i.n	a11, a1, 0
  907692:	0b8000        	callx8	a8
		clk_change(clk, ratio, baud);
  907695:	8810      	l32i.n	a8, a1, 0

static void clk_change(uint32_t clk, uint32_t ratio, uint32_t baud)
{
	uint32_t clk_sel = 0;

	switch(clk){
  907697:	c2ac      	movi.n	a10, 44
		break;
        case 88:
		clk_sel = 1;
		break;
        case 44:
		clk_sel = 2;
  907699:	c092      	movi.n	a9, 2

static void clk_change(uint32_t clk, uint32_t ratio, uint32_t baud)
{
	uint32_t clk_sel = 0;

	switch(clk){
  90769b:	7a8122        	beq	a8, a10, 9076c1 <db_clock_cmd+0x4d>
  90769e:	78a30e        	bltu	a10, a8, 9076b0 <db_clock_cmd+0x3c>
        case 22:
		clk_sel = 0;
  9076a1:	d920      	mov.n	a9, a2

static void clk_change(uint32_t clk, uint32_t ratio, uint32_t baud)
{
	uint32_t clk_sel = 0;

	switch(clk){
  9076a3:	c126      	movi.n	a2, 22
  9076a5:	728118        	beq	a8, a2, 9076c1 <db_clock_cmd+0x4d>
		break;
        case 117:
		clk_sel = 4;
		break;
        case 40:
		clk_sel = 6;            
  9076a8:	c096      	movi.n	a9, 6

static void clk_change(uint32_t clk, uint32_t ratio, uint32_t baud)
{
	uint32_t clk_sel = 0;

	switch(clk){
  9076aa:	c228      	movi.n	a2, 40
  9076ac:	60000c        	j	9076bc <db_clock_cmd+0x48>
  9076af:	00c528        	mull	a5, a12, a0
        case 22:
		clk_sel = 0;
		break;
        case 88:
		clk_sel = 1;
  9076b2:	c091      	movi.n	a9, 1

static void clk_change(uint32_t clk, uint32_t ratio, uint32_t baud)
{
	uint32_t clk_sel = 0;

	switch(clk){
  9076b4:	728109        	beq	a8, a2, 9076c1 <db_clock_cmd+0x4d>
		break;
        case 44:
		clk_sel = 2;
		break;
        case 117:
		clk_sel = 4;
  9076b7:	c094      	movi.n	a9, 4

static void clk_change(uint32_t clk, uint32_t ratio, uint32_t baud)
{
	uint32_t clk_sel = 0;

	switch(clk){
  9076b9:	220a75        	movi	a2, 117
  9076bc:	728101        	beq	a8, a2, 9076c1 <db_clock_cmd+0x4d>
		break;
        case 40:
		clk_sel = 6;            
		break;
        default:
		clk_sel = 6;
  9076bf:	c096      	movi.n	a9, 6
		break;
	}

	iowrite32(0x50040, (0x300|clk_sel|(ratio>>1)<<12));
  9076c1:	223a00        	movi	a2, 0x300
  9076c4:	029902        	or	a9, a9, a2
  9076c7:	1269d2        	l32r	a2, 8e1e10 <athos_indirection_table_install+0x89c>
	A_UART_HWINIT((clk*1000*1000)/ratio, baud);
  9076ca:	1a69d3        	l32r	a10, 8e1e18 <athos_indirection_table_install+0x8a4>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  9076cd:	0c0200        	memw
  9076d0:	9920      	s32i.n	a9, a2, 0
  9076d2:	126915        	l32r	a2, 8e1b28 <athos_indirection_table_install+0x5b4>
  9076d5:	0a8a28        	mull	a10, a8, a10
  9076d8:	22221a        	l32i	a2, a2, 104
  9076db:	1b69d4        	l32r	a11, 8e1e2c <athos_indirection_table_install+0x8b8>
  9076de:	0b2000        	callx8	a2
	if( db_ascii_to_int(param1, &clk) != -1 )
	{
		A_PRINTF("changing clock to %d\n", clk);
		clk_change(clk, ratio, baud);
	}
}
  9076e1:	d10f      	retw.n
	...

009076e4 <dbg_timer_func>:
	db_incorect_format();
	return -1;
}

LOCAL void dbg_timer_func(A_HANDLE alarm, void *data)
{
  9076e4:	6c1004        	entry	a1, 32
	A_PRINTF("this is a timer alarm function 0x%08x\n\r", xthal_get_ccount());
  9076e7:	126915        	l32r	a2, 8e1b3c <athos_indirection_table_install+0x5c8>
  9076ea:	222212        	l32i	a2, a2, 72
  9076ed:	5b7c9a        	call8	8e6958 <xthal_get_ccount>
  9076f0:	dba0      	mov.n	a11, a10
  9076f2:	1a69d5        	l32r	a10, 8e1e48 <athos_indirection_table_install+0x8d4>
  9076f5:	0b2000        	callx8	a2
  9076f8:	d10f      	retw.n
	...

009076fc <cmnos_dbg_module_install>:

	db_incorect_format();
	return -1;
}
void cmnos_dbg_module_install(struct dbg_api *apis)
{
  9076fc:	6c1004        	entry	a1, 32
	apis->_dbg_init = zf_debug_init;
  9076ff:	1869d6        	l32r	a8, 8e1e58 <athos_indirection_table_install+0x8e4>
  907702:	9820      	s32i.n	a8, a2, 0
	apis->_dbg_task = zf_debug_task;
  907704:	1869d7        	l32r	a8, 8e1e60 <athos_indirection_table_install+0x8ec>
  907707:	9821      	s32i.n	a8, a2, 4
  907709:	d10f      	retw.n
	...

0090770c <_fw_usbfifo_recv_command>:

typedef void (* USBFIFO_recv_command)(VBUF *cmd);
USBFIFO_recv_command m_origUsbfifoRecvCmd = NULL;

void _fw_usbfifo_recv_command(VBUF *buf)
{
  90770c:	6c1004        	entry	a1, 32
	uint8_t *cmd_data;
	uint32_t tmp;

	cmd_data = (uint8_t *)(buf->desc_list->buf_addr +
  90770f:	8820      	l32i.n	a8, a2, 0

typedef void (* USBFIFO_recv_command)(VBUF *cmd);
USBFIFO_recv_command m_origUsbfifoRecvCmd = NULL;

void _fw_usbfifo_recv_command(VBUF *buf)
{
  907711:	da20      	mov.n	a10, a2
	uint8_t *cmd_data;
	uint32_t tmp;

	cmd_data = (uint8_t *)(buf->desc_list->buf_addr +
  907713:	298105        	l16ui	a9, a8, 10
				buf->desc_list->data_offset);
	tmp = *((uint32_t *)cmd_data);
  907716:	8881      	l32i.n	a8, a8, 4
  907718:	a988      	add.n	a8, a8, a9
	if (tmp == 0xFFFFFFFF)
  90771a:	8880      	l32i.n	a8, a8, 0
  90771c:	698004        	bnei	a8, -1, 907724 <_fw_usbfifo_recv_command+0x18>
		_fw_usb_suspend_reboot();
  90771f:	580cc7        	call8	90aa3c <_fw_usb_suspend_reboot>
  907722:	d10f      	retw.n
	else
		m_origUsbfifoRecvCmd(buf);
  907724:	1869d8        	l32r	a8, 8e1e84 <athos_indirection_table_install+0x910>
  907727:	8880      	l32i.n	a8, a8, 0
  907729:	0b8000        	callx8	a8
  90772c:	d10f      	retw.n
	...

00907730 <_fw_usbfifo_init>:
}

void _fw_usbfifo_init(USB_FIFO_CONFIG *pConfig)
{
  907730:	6c1004        	entry	a1, 32
	m_origUsbfifoRecvCmd = pConfig->recv_command;
  907733:	8921      	l32i.n	a9, a2, 4
  907735:	1869d8        	l32r	a8, 8e1e98 <athos_indirection_table_install+0x924>
  907738:	9980      	s32i.n	a9, a8, 0

	usbFifoConf.get_command_buf = pConfig->get_command_buf;
  90773a:	1869d9        	l32r	a8, 8e1ea0 <athos_indirection_table_install+0x92c>
  90773d:	8920      	l32i.n	a9, a2, 0
  90773f:	9980      	s32i.n	a9, a8, 0
	usbFifoConf.recv_command    = _fw_usbfifo_recv_command;
  907741:	1969da        	l32r	a9, 8e1eac <athos_indirection_table_install+0x938>
  907744:	9981      	s32i.n	a9, a8, 4
	usbFifoConf.get_event_buf   = pConfig->get_event_buf;
  907746:	8922      	l32i.n	a9, a2, 8
	usbFifoConf.send_event_done = pConfig->send_event_done;
  907748:	8223      	l32i.n	a2, a2, 12
{
	m_origUsbfifoRecvCmd = pConfig->recv_command;

	usbFifoConf.get_command_buf = pConfig->get_command_buf;
	usbFifoConf.recv_command    = _fw_usbfifo_recv_command;
	usbFifoConf.get_event_buf   = pConfig->get_event_buf;
  90774a:	9982      	s32i.n	a9, a8, 8
	usbFifoConf.send_event_done = pConfig->send_event_done;
  90774c:	9283      	s32i.n	a2, a8, 12
  90774e:	d10f      	retw.n

00907750 <cold_reboot>:
}

void cold_reboot(void)
{
  907750:	6c1004        	entry	a1, 32
	A_PRINTF("Cold reboot initiated.");
  907753:	126915        	l32r	a2, 8e1ba8 <athos_indirection_table_install+0x634>
  907756:	1a69db        	l32r	a10, 8e1ec4 <athos_indirection_table_install+0x950>
  907759:	282212        	l32i	a8, a2, 72
  90775c:	0b8000        	callx8	a8
  90775f:	186919        	l32r	a8, 8e1bc4 <athos_indirection_table_install+0x650>
  907762:	c090      	movi.n	a9, 0
#if defined(PROJECT_MAGPIE)
	iowrite32(WATCH_DOG_MAGIC_PATTERN_ADDR, 0);
#elif defined(PROJECT_K2)
	iowrite32(MAGPIE_REG_RST_STATUS_ADDR, 0);
#endif /* #if defined(PROJECT_MAGPIE) */
	A_USB_JUMP_BOOT();
  907764:	22222c        	l32i	a2, a2, 176
  907767:	0c0200        	memw
  90776a:	298600        	s32i	a9, a8, 0
  90776d:	0b2000        	callx8	a2
  907770:	d10f      	retw.n
	...

00907774 <usb_status_in_patch>:

/*
 * support more than 64 bytes command on ep3
 */
void usb_status_in_patch(void)
{
  907774:	6c1004        	entry	a1, 32
	static VBUF *evntbuf = NULL;
	static volatile uint32_t *regaddr;
	static BOOLEAN cmd_is_new = TRUE;
	BOOLEAN cmd_end = FALSE;

	if (cmd_is_new) {
  907777:	1269dc        	l32r	a2, 8e1ee8 <athos_indirection_table_install+0x974>
  90777a:	282100        	l16ui	a8, a2, 0
  90777d:	648048        	beqz	a8, 9077c9 <usb_status_in_patch+0x55>
		evntbuf = usbFifoConf.get_event_buf();
  907780:	1869d9        	l32r	a8, 8e1ee4 <athos_indirection_table_install+0x970>
  907783:	8a82      	l32i.n	a10, a8, 8
  907785:	0ba000        	callx8	a10
  907788:	1869dd        	l32r	a8, 8e1efc <athos_indirection_table_install+0x988>
  90778b:	9a80      	s32i.n	a10, a8, 0
		if (evntbuf != NULL) {
  90778d:	c9af      	beqz.n	a10, 9077b0 <usb_status_in_patch+0x3c>
			regaddr = (uint32_t *)VBUF_GET_DATA_ADDR(evntbuf);
  90778f:	88a0      	l32i.n	a8, a10, 0
  907791:	298105        	l16ui	a9, a8, 10
  907794:	8881      	l32i.n	a8, a8, 4
  907796:	a989      	add.n	a9, a8, a9
  907798:	1869de        	l32r	a8, 8e1f10 <athos_indirection_table_install+0x99c>
  90779b:	9980      	s32i.n	a9, a8, 0
			buf_len = evntbuf->buf_length;
  90779d:	1869df        	l32r	a8, 8e1f1c <athos_indirection_table_install+0x9a8>
  9077a0:	29a104        	l16ui	a9, a10, 8
  9077a3:	298500        	s16i	a9, a8, 0
		} else {
			mUSB_STATUS_IN_INT_DISABLE();
			return;
		}

		cmd_is_new = FALSE;
  9077a6:	c080      	movi.n	a8, 0
  9077a8:	282500        	s16i	a8, a2, 0
  9077ab:	60001a        	j	9077c9 <usb_status_in_patch+0x55>
  9077ae:	000012        	srai	a0, a0, 0

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  9077b1:	695c29        	bnei	a5, 32, 9077de <usb_status_in_patch+0x6a>
		evntbuf = usbFifoConf.get_event_buf();
		if (evntbuf != NULL) {
			regaddr = (uint32_t *)VBUF_GET_DATA_ADDR(evntbuf);
			buf_len = evntbuf->buf_length;
		} else {
			mUSB_STATUS_IN_INT_DISABLE();
  9077b4:	0ac028        	mull	a0, a12, a10
  9077b7:	200008        	l8ui	a0, a0, 8
  9077ba:	084709        	addx2	a7, a4, a8
  9077bd:	8802      	l32i.n	a8, a0, 8
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  9077bf:	0c0200        	memw
  9077c2:	282400        	s8i	a8, a2, 0
  9077c5:	d10f      	retw.n
  9077c7:	00001a        	sll	a0, a0
		}

		cmd_is_new = FALSE;
	}

	if (buf_len > USB_EP3_MAX_PKT_SIZE) {
  9077ca:	69dfc4        	bnei	a13, 0x100, 907792 <usb_status_in_patch+0x1e>
  9077cd:	9028      	s32i.n	a0, a2, 32
  9077cf:	a100      	add.n	a0, a0, a1
	}
	/* TODO: 64 bytes...
	 * controller supposed will take care of zero-length? */
	else {
		reg_buf_len = buf_len;
		cmd_end = TRUE;
  9077d1:	c021      	movi.n	a2, 1
		}

		cmd_is_new = FALSE;
	}

	if (buf_len > USB_EP3_MAX_PKT_SIZE) {
  9077d3:	789b09        	bgeu	a9, a8, 9077e0 <usb_status_in_patch+0x6c>
		reg_buf_len = USB_EP3_MAX_PKT_SIZE;
		buf_len -= USB_EP3_MAX_PKT_SIZE;
  9077d6:	288cc0        	addi	a8, a8, -64
  9077d9:	28a500        	s16i	a8, a10, 0
	uint16_t reg_buf_len;
	static uint16_t buf_len;
	static VBUF *evntbuf = NULL;
	static volatile uint32_t *regaddr;
	static BOOLEAN cmd_is_new = TRUE;
	BOOLEAN cmd_end = FALSE;
  9077dc:	c020      	movi.n	a2, 0

		cmd_is_new = FALSE;
	}

	if (buf_len > USB_EP3_MAX_PKT_SIZE) {
		reg_buf_len = USB_EP3_MAX_PKT_SIZE;
  9077de:	d890      	mov.n	a8, a9
  9077e0:	1969de        	l32r	a9, 8e1f58 <athos_indirection_table_install+0x9e4>
		reg_buf_len = buf_len;
		cmd_end = TRUE;
	}

	/* INT use EP3 */
	for (count = 0; count < (reg_buf_len / 4); count++)
  9077e3:	082c14        	srli	a12, a8, 2
  9077e6:	8b90      	l32i.n	a11, a9, 0
  9077e8:	1e695d        	l32r	a14, 8e1d5c <athos_indirection_table_install+0x7e8>
  9077eb:	dab0      	mov.n	a10, a11
  9077ed:	c090      	movi.n	a9, 0
  9077ef:	600010        	j	907803 <usb_status_in_patch+0x8f>
  9077f2:	00000c        	sub	a0, a0, a0
	{
		iowrite32_usb(ZM_EP3_DATA_OFFSET, *regaddr);
  9077f5:	02008d        	excw
  9077f8:	d0b1      	excw
		reg_buf_len = buf_len;
		cmd_end = TRUE;
	}

	/* INT use EP3 */
	for (count = 0; count < (reg_buf_len / 4); count++)
  9077fa:	990c      	s32i.n	a9, a0, 48
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  9077fc:	02009d        	excw
  9077ff:	e0          	.byte 0xe0
  907800:	09094f        	extui	a9, a9, 0, 16
  907803:	dda0      	mov.n	a13, a10
  907805:	b4aa      	addi.n	a10, a10, 4
  907807:	7c99e9        	bne	a9, a12, 9077f4 <usb_status_in_patch+0x80>
  90780a:	1a69de        	l32r	a10, 8e1f84 <athos_indirection_table_install+0xa10>
  90780d:	0b990a        	addx4	a9, a9, a11
  907810:	99a0      	s32i.n	a9, a10, 0
	{
		iowrite32_usb(ZM_EP3_DATA_OFFSET, *regaddr);
		regaddr++;
	}

	remainder = reg_buf_len % 4;
  907812:	080841        	extui	a8, a8, 0, 2

	if (remainder) {
  907815:	cb84      	beqz.n	a8, 90784d <usb_status_in_patch+0xd9>
  907817:	19693c        	l32r	a9, 8e1d08 <athos_indirection_table_install+0x794>
		switch(remainder) {
  90781a:	688207        	beqi	a8, 2, 907825 <usb_status_in_patch+0xb1>
  90781d:	698309        	bnei	a8, 3, 90782a <usb_status_in_patch+0xb6>
  907820:	c087      	movi.n	a8, 7
  907822:	600006        	j	90782c <usb_status_in_patch+0xb8>
  907825:	c083      	movi.n	a8, 3
  907827:	600001        	j	90782c <usb_status_in_patch+0xb8>
  90782a:	c081      	movi.n	a8, 1
  90782c:	0c0200        	memw
  90782f:	9890      	s32i.n	a8, a9, 0
		case 1:
			iowrite32_usb(ZM_CBUS_FIFO_SIZE_OFFSET, 0x1);
			break;
		}

		iowrite32_usb(ZM_EP3_DATA_OFFSET, *regaddr);
  907831:	1869de        	l32r	a8, 8e1fac <athos_indirection_table_install+0xa38>
  907834:	8880      	l32i.n	a8, a8, 0
  907836:	0c0200        	memw
  907839:	8980      	l32i.n	a9, a8, 0
  90783b:	18695d        	l32r	a8, 8e1db0 <athos_indirection_table_install+0x83c>
  90783e:	0c0200        	memw
  907841:	9980      	s32i.n	a9, a8, 0
  907843:	18693c        	l32r	a8, 8e1d34 <athos_indirection_table_install+0x7c0>
  907846:	c09f      	movi.n	a9, 15
  907848:	0c0200        	memw
  90784b:	9980      	s32i.n	a9, a8, 0

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  90784d:	18695f        	l32r	a8, 8e1dcc <athos_indirection_table_install+0x858>

		/* Restore CBus FIFO size to word size */
		iowrite32_usb(ZM_CBUS_FIFO_SIZE_OFFSET, 0xF);
	}

	mUSB_EP3_XFER_DONE();
  907850:	c0a8      	movi.n	a10, 8
  907852:	298000        	l8ui	a9, a8, 0
  907855:	090947        	extui	a9, a9, 0, 8
  907858:	0a9902        	or	a9, a9, a10
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  90785b:	0c0200        	memw
  90785e:	298400        	s8i	a9, a8, 0

	if (evntbuf != NULL && cmd_end) {
  907861:	1869dd        	l32r	a8, 8e1fd8 <athos_indirection_table_install+0xa64>
  907864:	8a80      	l32i.n	a10, a8, 0
  907866:	c9a2      	beqz.n	a10, 90787c <usb_status_in_patch+0x108>
  907868:	642010        	beqz	a2, 90787c <usb_status_in_patch+0x108>
		usbFifoConf.send_event_done(evntbuf);
  90786b:	1269d9        	l32r	a2, 8e1fd0 <athos_indirection_table_install+0xa5c>
  90786e:	222203        	l32i	a2, a2, 12
  907871:	0b2000        	callx8	a2
		cmd_is_new = TRUE;
  907874:	1269dc        	l32r	a2, 8e1fe4 <athos_indirection_table_install+0xa70>
  907877:	c081      	movi.n	a8, 1
  907879:	282500        	s16i	a8, a2, 0
  90787c:	d10f      	retw.n
	...

00907880 <usb_reg_out_patch>:

/*
 * support more than 64 bytes command on ep4 
 */
void usb_reg_out_patch(void)
{
  907880:	6c1004        	entry	a1, 32

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  907883:	1269e0        	l32r	a2, 8e2004 <athos_indirection_table_install+0xa90>
	static BOOLEAN cmd_is_new = TRUE;

	/* get the size of this transcation */
	usbfifolen = ioread8_usb(ZM_EP4_BYTE_COUNT_LOW_OFFSET);

	if (usbfifolen > USB_EP4_MAX_PKT_SIZE) {
  907886:	230a40        	movi	a3, 64
  907889:	222000        	l8ui	a2, a2, 0
  90788c:	020247        	extui	a2, a2, 0, 8
  90788f:	723b11        	bgeu	a3, a2, 9078a4 <usb_reg_out_patch+0x24>
		A_PRINTF("EP4 FIFO Bug? Buffer is too big: %x\n", usbfifolen);
  907892:	136915        	l32r	a3, 8e1ce8 <athos_indirection_table_install+0x774>
  907895:	1a69e1        	l32r	a10, 8e201c <athos_indirection_table_install+0xaa8>
  907898:	233212        	l32i	a3, a3, 72
  90789b:	022b02        	or	a11, a2, a2
  90789e:	0b3000        	callx8	a3
		cold_reboot();
  9078a1:	5bffab        	call8	907750 <cold_reboot>
	}

	/* check is command is new */
	if(cmd_is_new) {
  9078a4:	1369e2        	l32r	a3, 8e202c <athos_indirection_table_install+0xab8>
  9078a7:	243100        	l16ui	a4, a3, 0
  9078aa:	cb4a      	beqz.n	a4, 9078e8 <usb_reg_out_patch+0x68>

		buf = usbFifoConf.get_command_buf();
  9078ac:	1469d9        	l32r	a4, 8e2010 <athos_indirection_table_install+0xa9c>
  9078af:	8a40      	l32i.n	a10, a4, 0
  9078b1:	0ba000        	callx8	a10
  9078b4:	1469e3        	l32r	a4, 8e2040 <athos_indirection_table_install+0xacc>
		cmd_len = 0;
  9078b7:	c080      	movi.n	a8, 0
	}

	/* check is command is new */
	if(cmd_is_new) {

		buf = usbFifoConf.get_command_buf();
  9078b9:	9a40      	s32i.n	a10, a4, 0
		cmd_len = 0;
  9078bb:	1469e4        	l32r	a4, 8e204c <athos_indirection_table_install+0xad8>
  9078be:	284500        	s16i	a8, a4, 0

		if(!buf) {
  9078c1:	cda5      	bnez.n	a10, 9078da <usb_reg_out_patch+0x5a>
			A_PRINTF("%s: Filed to get new buffer.\n", __func__);
  9078c3:	136915        	l32r	a3, 8e1d18 <athos_indirection_table_install+0x7a4>
  9078c6:	1a69e5        	l32r	a10, 8e205c <athos_indirection_table_install+0xae8>
  9078c9:	233212        	l32i	a3, a3, 72
  9078cc:	1b69e6        	l32r	a11, 8e2064 <athos_indirection_table_install+0xaf0>
  9078cf:	0b3000        	callx8	a3
		usbfifolen = (usbfifolen >> 2) + 1;
	else
		usbfifolen = usbfifolen >> 2;

	/* retrieve the data from fifo */
	for(ii = 0; ii < usbfifolen; ii++) {
  9078d2:	c080      	movi.n	a8, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  9078d4:	1369e9        	l32r	a3, 8e2078 <athos_indirection_table_install+0xb04>
  9078d7:	6000a7        	j	907982 <usb_reg_out_patch+0x102>
			A_PRINTF("%s: Filed to get new buffer.\n", __func__);
			goto err;
		}

		/* copy free, assignment buffer of the address */
		regaddr = (uint32_t *)buf->desc_list->buf_addr;
  9078da:	84a0      	l32i.n	a4, a10, 0

		cmd_is_new = FALSE;
  9078dc:	283500        	s16i	a8, a3, 0
			A_PRINTF("%s: Filed to get new buffer.\n", __func__);
			goto err;
		}

		/* copy free, assignment buffer of the address */
		regaddr = (uint32_t *)buf->desc_list->buf_addr;
  9078df:	294201        	l32i	a9, a4, 4
  9078e2:	1469e7        	l32r	a4, 8e2080 <athos_indirection_table_install+0xb0c>
  9078e5:	294600        	s32i	a9, a4, 0

		cmd_is_new = FALSE;
	}

	/* just in case, suppose should not happen */
	if(!buf)
  9078e8:	1369e3        	l32r	a3, 8e2074 <athos_indirection_table_install+0xb00>
  9078eb:	8a30      	l32i.n	a10, a3, 0
  9078ed:	64afe1        	beqz	a10, 9078d2 <usb_reg_out_patch+0x52>
	 */
	if(usbfifolen < USB_EP4_MAX_PKT_SIZE)
		cmd_is_last = TRUE;

	/* accumulate the size */
	cmd_len += usbfifolen;
  9078f0:	1369e4        	l32r	a3, 8e2080 <athos_indirection_table_install+0xb0c>

	if (cmd_len > buf->desc_list->buf_size) {
  9078f3:	88a0      	l32i.n	a8, a10, 0
	 */
	if(usbfifolen < USB_EP4_MAX_PKT_SIZE)
		cmd_is_last = TRUE;

	/* accumulate the size */
	cmd_len += usbfifolen;
  9078f5:	293100        	l16ui	a9, a3, 0
  9078f8:	a929      	add.n	a9, a2, a9
  9078fa:	09094f        	extui	a9, a9, 0, 16
  9078fd:	293500        	s16i	a9, a3, 0

	if (cmd_len > buf->desc_list->buf_size) {
  907900:	238104        	l16ui	a3, a8, 8
  907903:	793b0b        	bgeu	a3, a9, 907912 <usb_reg_out_patch+0x92>
		A_PRINTF("%s: Data length on EP4 FIFO is bigger as "
  907906:	136915        	l32r	a3, 8e1d5c <athos_indirection_table_install+0x7e8>
  907909:	1a69e8        	l32r	a10, 8e20ac <athos_indirection_table_install+0xb38>
  90790c:	233212        	l32i	a3, a3, 72
  90790f:	63ffb9        	j	9078cc <usb_reg_out_patch+0x4c>
		goto err;
	}

	/* round it to alignment */
	if(usbfifolen % 4)
		usbfifolen = (usbfifolen >> 2) + 1;
  907912:	c031      	movi.n	a3, 1
			 "allocated buffer data! Drop it!\n", __func__);
		goto err;
	}

	/* round it to alignment */
	if(usbfifolen % 4)
  907914:	020441        	extui	a4, a2, 0, 2
		usbfifolen = (usbfifolen >> 2) + 1;
  907917:	c0b0      	movi.n	a11, 0
  907919:	043b39        	movnez	a11, a3, a4
  90791c:	1369e7        	l32r	a3, 8e20b8 <athos_indirection_table_install+0xb44>
	else
		usbfifolen = usbfifolen >> 2;
  90791f:	022c14        	srli	a12, a2, 2
  907922:	8330      	l32i.n	a3, a3, 0
		goto err;
	}

	/* round it to alignment */
	if(usbfifolen % 4)
		usbfifolen = (usbfifolen >> 2) + 1;
  907924:	abcc      	add.n	a12, a12, a11
  907926:	dd30      	mov.n	a13, a3
	else
		usbfifolen = usbfifolen >> 2;

	/* retrieve the data from fifo */
	for(ii = 0; ii < usbfifolen; ii++) {
  907928:	c0b0      	movi.n	a11, 0
  90792a:	1f69e9        	l32r	a15, 8e20d0 <athos_indirection_table_install+0xb5c>
  90792d:	60000f        	j	907940 <usb_reg_out_patch+0xc0>
  907930:	000c02        	or	a12, a0, a0
  907933:	0084f0        	excw
  907936:	b1bb      	addi.n	a11, a11, 1
		/* read fifo data out */
		ep4_data = ioread32_usb(ZM_EP4_DATA_OFFSET);
		*regaddr = ep4_data;
  907938:	0c0200        	memw
  90793b:	94e0      	s32i.n	a4, a14, 0
		usbfifolen = (usbfifolen >> 2) + 1;
	else
		usbfifolen = usbfifolen >> 2;

	/* retrieve the data from fifo */
	for(ii = 0; ii < usbfifolen; ii++) {
  90793d:	0b0b4f        	extui	a11, a11, 0, 16
  907940:	ded0      	mov.n	a14, a13
  907942:	b4dd      	addi.n	a13, a13, 4
  907944:	7cb9e9        	bne	a11, a12, 907931 <usb_reg_out_patch+0xb1>
  907947:	1c69e7        	l32r	a12, 8e20e4 <athos_indirection_table_install+0xb70>
  90794a:	03bb0a        	addx4	a11, a11, a3
  90794d:	9bc0      	s32i.n	a11, a12, 0
		*regaddr = ep4_data;
		regaddr++;
	}

	/* if this is the last command, callback to HTC */
	if (cmd_is_last) {
  90794f:	c33f      	movi.n	a3, 63
  907951:	723330        	bltu	a3, a2, 907985 <usb_reg_out_patch+0x105>
		buf->desc_list->next_desc = NULL;
  907954:	c020      	movi.n	a2, 0
  907956:	9280      	s32i.n	a2, a8, 0
		buf->desc_list->data_offset = 0;
  907958:	228505        	s16i	a2, a8, 10
		buf->desc_list->data_size = cmd_len;
		buf->desc_list->control = 0;
  90795b:	228507        	s16i	a2, a8, 14

	/* if this is the last command, callback to HTC */
	if (cmd_is_last) {
		buf->desc_list->next_desc = NULL;
		buf->desc_list->data_offset = 0;
		buf->desc_list->data_size = cmd_len;
  90795e:	298506        	s16i	a9, a8, 12
		buf->desc_list->control = 0;
		buf->next_buf = NULL;
  907961:	92a1      	s32i.n	a2, a10, 4
		buf->buf_length = cmd_len;

		usbFifoConf.recv_command(buf);
  907963:	1269d9        	l32r	a2, 8e20c8 <athos_indirection_table_install+0xb54>
		buf->desc_list->next_desc = NULL;
		buf->desc_list->data_offset = 0;
		buf->desc_list->data_size = cmd_len;
		buf->desc_list->control = 0;
		buf->next_buf = NULL;
		buf->buf_length = cmd_len;
  907966:	29a504        	s16i	a9, a10, 8

		usbFifoConf.recv_command(buf);
  907969:	8221      	l32i.n	a2, a2, 4

		cmd_is_new = TRUE;
  90796b:	c031      	movi.n	a3, 1
		buf->desc_list->data_size = cmd_len;
		buf->desc_list->control = 0;
		buf->next_buf = NULL;
		buf->buf_length = cmd_len;

		usbFifoConf.recv_command(buf);
  90796d:	0b2000        	callx8	a2

		cmd_is_new = TRUE;
  907970:	1269e2        	l32r	a2, 8e20f8 <athos_indirection_table_install+0xb84>
  907973:	232500        	s16i	a3, a2, 0
  907976:	d10f      	retw.n
	goto done;
err:
	/* we might get no command buffer here?
	 * but if we return here, the ep4 fifo will be lock out,
	 * so that we still read them out but just drop it? */
	for(ii = 0; ii < usbfifolen; ii++)
  907978:	b188      	addi.n	a8, a8, 1
  90797a:	0c0200        	memw
  90797d:	8430      	l32i.n	a4, a3, 0
  90797f:	08084f        	extui	a8, a8, 0, 16
  907982:	7283f2        	bltu	a8, a2, 907978 <usb_reg_out_patch+0xf8>
  907985:	d10f      	retw.n
	...

00907988 <vUSBFIFO_EP6Cfg_FS_patch>:
#define FS_C1_I0_A0_EP6_MAP		\
	 (FS_C1_I0_A0_EP6_FIFO_START | (FS_C1_I0_A0_EP6_FIFO_START << 4) | \
	  (MASK_F0 >> (4*FS_C1_I0_A0_EP6_DIRECTION)))

void vUSBFIFO_EP6Cfg_FS_patch(void)
{
  907988:	6c1004        	entry	a1, 32
#if (FS_C1_I0_A0_EP_NUMBER >= 6)
	int i;

	/* EP0X06 */
	mUsbEPMap(EP6, FS_C1_I0_A0_EP6_MAP);
  90798b:	2b0a6f        	movi	a11, 111
  90798e:	2a0a06        	movi	a10, 6
  907991:	5b73d9        	call8	8e48f8 <mUsbEPMap>
	mUsbFIFOMap(FS_C1_I0_A0_EP6_FIFO_START, FS_C1_I0_A0_EP6_FIFO_MAP);
  907994:	2a0a06        	movi	a10, 6
  907997:	0aab02        	or	a11, a10, a10
  90799a:	5b73de        	call8	8e4914 <mUsbFIFOMap>
	mUsbFIFOConfig(FS_C1_I0_A0_EP6_FIFO_START, FS_C1_I0_A0_EP6_FIFO_CONFIG);
  90799d:	2b0a86        	movi	a11, 134
  9079a0:	c0a6      	movi.n	a10, 6
  9079a2:	5b73e4        	call8	8e4934 <mUsbFIFOConfig>

	for(i = FS_C1_I0_A0_EP6_FIFO_START + 1 ;
            i < FS_C1_I0_A0_EP6_FIFO_START + FS_C1_I0_A0_EP6_FIFO_NO ; i ++)
	{
		mUsbFIFOConfig(i, (FS_C1_I0_A0_EP6_FIFO_CONFIG & (~BIT7)) );
  9079a5:	c0b6      	movi.n	a11, 6
  9079a7:	c0a7      	movi.n	a10, 7
  9079a9:	5b73e2        	call8	8e4934 <mUsbFIFOConfig>
	}

	mUsbEPMxPtSzHigh(EP6, FS_C1_I0_A0_EP6_DIRECTION,
  9079ac:	c0b1      	movi.n	a11, 1
  9079ae:	c4c0      	movi.n	a12, 64
  9079b0:	c0a6      	movi.n	a10, 6
  9079b2:	5b73e8        	call8	8e4954 <mUsbEPMxPtSzHigh>
			 (FS_C1_I0_A0_EP6_MAX_PACKET & 0x7ff));
	mUsbEPMxPtSzLow(EP6, FS_C1_I0_A0_EP6_DIRECTION,
  9079b5:	c0b1      	movi.n	a11, 1
  9079b7:	c4c0      	movi.n	a12, 64
  9079b9:	c0a6      	movi.n	a10, 6
  9079bb:	5b73f0        	call8	8e497c <mUsbEPMxPtSzLow>
			(FS_C1_I0_A0_EP6_MAX_PACKET & 0x7ff));
	mUsbEPinHighBandSet(EP6, FS_C1_I0_A0_EP6_DIRECTION,
  9079be:	c0b1      	movi.n	a11, 1
  9079c0:	c4c0      	movi.n	a12, 64
  9079c2:	2a0a06        	movi	a10, 6
  9079c5:	5b73f6        	call8	8e49a0 <mUsbEPinHighBandSet>
  9079c8:	d10f      	retw.n
	...

009079cc <vUsbFIFO_EPxCfg_FS_patch>:
			    FS_C1_I0_A0_EP6_MAX_PACKET);
#endif
}

void vUsbFIFO_EPxCfg_FS_patch(void)
{
  9079cc:	6c1004        	entry	a1, 32
	switch (u8UsbConfigValue)
  9079cf:	1869ea        	l32r	a8, 8e2178 <athos_indirection_table_install+0xc04>
  9079d2:	288100        	l16ui	a8, a8, 0
  9079d5:	698113        	bnei	a8, 1, 9079ec <vUsbFIFO_EPxCfg_FS_patch+0x20>
	{
#if (FS_CONFIGURATION_NUMBER >= 1)
		/* Configuration 0X01 */
        case 0X01:
		switch (u8UsbInterfaceValue)
  9079d8:	1869eb        	l32r	a8, 8e2184 <athos_indirection_table_install+0xc10>
  9079db:	288100        	l16ui	a8, a8, 0
  9079de:	cc8a      	bnez.n	a8, 9079ec <vUsbFIFO_EPxCfg_FS_patch+0x20>
		{
#if (FS_C1_INTERFACE_NUMBER >= 1)
			/* Interface 0 */
                case 0:
			switch (u8UsbInterfaceAlternateSetting)
  9079e0:	1869ec        	l32r	a8, 8e2190 <athos_indirection_table_install+0xc1c>
  9079e3:	288100        	l16ui	a8, a8, 0
  9079e6:	658002        	bnez	a8, 9079ec <vUsbFIFO_EPxCfg_FS_patch+0x20>
                        case 0:

				/* snapped.... */

				/* patch up this ep6_fs config */
				vUSBFIFO_EP6Cfg_FS_patch();
  9079e9:	5bffe7        	call8	907988 <vUSBFIFO_EP6Cfg_FS_patch>
  9079ec:	d10f      	retw.n
	...

009079f0 <bSet_configuration_patch>:
	}
	/* mCHECK_STACK(); */
}

BOOLEAN bSet_configuration_patch(void)
{
  9079f0:	6c1004        	entry	a1, 32
	/* do some defaul configuration */
	bSet_configuration();
  9079f3:	5b7058        	call8	8e3b54 <bSet_configuration>

	/* overwrite defaul FIFO configuration for FullSpeed USB */
	if ((mLOW_BYTE(mDEV_REQ_VALUE()) != 0) && !mUsbHighSpeedST())
  9079f6:	1269ed        	l32r	a2, 8e21ac <athos_indirection_table_install+0xc38>
  9079f9:	222007        	l8ui	a2, a2, 7
  9079fc:	c82a      	beqz.n	a2, 907a0a <bSet_configuration_patch+0x1a>

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  9079fe:	126937        	l32r	a2, 8e1edc <athos_indirection_table_install+0x968>
  907a01:	222000        	l8ui	a2, a2, 0
  907a04:	792f02        	bbsi	a2, 25, 907a0a <bSet_configuration_patch+0x1a>
			vUsbFIFO_EPxCfg_FS_patch();
  907a07:	5bfff1        	call8	9079cc <vUsbFIFO_EPxCfg_FS_patch>

	eUsbCxFinishAction = ACT_DONE;
  907a0a:	1869ee        	l32r	a8, 8e21c4 <athos_indirection_table_install+0xc50>
  907a0d:	c021      	movi.n	a2, 1
  907a0f:	9280      	s32i.n	a2, a8, 0
	return TRUE;
}
  907a11:	d10f      	retw.n
	...

00907a14 <bStandardCommand_patch>:

extern BOOLEAN bStandardCommand(void);

BOOLEAN bStandardCommand_patch(void)
{
  907a14:	6c1004        	entry	a1, 32
	if (mDEV_REQ_REQ() == USB_SET_CONFIGURATION) {
  907a17:	1869ed        	l32r	a8, 8e21cc <athos_indirection_table_install+0xc58>
  907a1a:	298102        	l16ui	a9, a8, 4
  907a1d:	280a09        	movi	a8, 9
  907a20:	78992d        	bne	a9, a8, 907a51 <bStandardCommand_patch+0x3d>
		A_USB_SET_CONFIG();
  907a23:	186915        	l32r	a8, 8e1e78 <athos_indirection_table_install+0x904>
  907a26:	2a8226        	l32i	a10, a8, 152
  907a29:	0ba000        	callx8	a10

#if ENABLE_SWAP_DATA_MODE
		/* SWAP FUNCTION should be enabled while DMA engine
		 * is not working, the best place to enable it
		 * is before we trigger the DMA */
		MAGPIE_REG_USB_RX0_SWAP_DATA = 0x1;
  907a2c:	186955        	l32r	a8, 8e1f80 <athos_indirection_table_install+0xa0c>
  907a2f:	c0a1      	movi.n	a10, 1
  907a31:	0c0200        	memw
  907a34:	9a80      	s32i.n	a10, a8, 0
		MAGPIE_REG_USB_TX0_SWAP_DATA = 0x1;
  907a36:	186956        	l32r	a8, 8e1f90 <athos_indirection_table_install+0xa1c>
  907a39:	0c0200        	memw
  907a3c:	9a80      	s32i.n	a10, a8, 0

#if SYSTEM_MODULE_HP_EP5
		MAGPIE_REG_USB_RX1_SWAP_DATA = 0x1;
  907a3e:	186957        	l32r	a8, 8e1f9c <athos_indirection_table_install+0xa28>
  907a41:	0c0200        	memw
  907a44:	9a80      	s32i.n	a10, a8, 0
#endif

#if SYSTEM_MODULE_HP_EP6
		MAGPIE_REG_USB_RX2_SWAP_DATA = 0x1;
  907a46:	186958        	l32r	a8, 8e1fa8 <athos_indirection_table_install+0xa34>
  907a49:	0c0200        	memw
  907a4c:	9a80      	s32i.n	a10, a8, 0
#endif

#endif /* ENABLE_SWAP_DATA_MODE */
		return TRUE;
  907a4e:	600002        	j	907a54 <bStandardCommand_patch+0x40>
	} else
		return bStandardCommand();
  907a51:	5b7104        	call8	8e3e64 <bStandardCommand>
}
  907a54:	d2a0      	mov.n	a2, a10
  907a56:	d10f      	retw.n

00907a58 <bGet_descriptor_patch>:
#define EP3_INT_INTERVAL		19
#define EP4_TRANSFER_TYPE_OFFSET	21
#define EP4_INT_INTERVAL		22

BOOLEAN bGet_descriptor_patch(void)
{
  907a58:	6c1004        	entry	a1, 32
	if (mDEV_REQ_VALUE_HIGH() == 1)
  907a5b:	1369ed        	l32r	a3, 8e2210 <athos_indirection_table_install+0xc9c>
  907a5e:	223103        	l16ui	a2, a3, 6
  907a61:	028214        	srli	a2, a2, 8
  907a64:	692120        	bnei	a2, 1, 907a88 <bGet_descriptor_patch+0x30>
	{
		uint8_t *p = (uint8_t *)u8UsbDeviceDescriptor;

		/* Copy Usb Device Descriptor */
		ath_hal_memcpy(UsbDeviceDescriptorPatch, p,
  907a67:	1469f0        	l32r	a4, 8e2228 <athos_indirection_table_install+0xcb4>
  907a6a:	1269ef        	l32r	a2, 8e2228 <athos_indirection_table_install+0xcb4>
  907a6d:	8b40      	l32i.n	a11, a4, 0
  907a6f:	da20      	mov.n	a10, a2
  907a71:	c1c2      	movi.n	a12, 18
  907a73:	580034        	call8	907b44 <ath_hal_memcpy>
				sizeof(UsbDeviceDescriptorPatch));

		/* Change bcdDevice. we need it to detect if FW
		 * was uploaded. */
		UsbDeviceDescriptorPatch[BCD_DEVICE_OFFSET] =
  907a76:	c78f      	movi.n	a8, -1
  907a78:	282506        	s16i	a8, a2, 12
			BCD_DEVICE_FW_SIGNATURE;

		pu8DescriptorEX = UsbDeviceDescriptorPatch;
  907a7b:	1869f1        	l32r	a8, 8e2240 <athos_indirection_table_install+0xccc>
  907a7e:	9280      	s32i.n	a2, a8, 0
		u16TxRxCounter = mTABLE_LEN(u8UsbDeviceDescriptor[0]);
  907a80:	8240      	l32i.n	a2, a4, 0
  907a82:	242001        	l8ui	a4, a2, 1
  907a85:	600024        	j	907aad <bGet_descriptor_patch+0x55>
			u16TxRxCounter = mDEV_REQ_LENGTH();

		A_USB_EP0_TX_DATA();

		return TRUE;
	} else if (mDEV_REQ_VALUE_HIGH() == 2) {
  907a88:	69223d        	bnei	a2, 2, 907ac9 <bGet_descriptor_patch+0x71>
		uint8_t *p = (uint8_t *)u8ConfigDescriptorEX;

		/* Copy ConfigDescriptor */
		ath_hal_memcpy(ConfigDescriptorPatch, p,
  907a8b:	1269f4        	l32r	a2, 8e225c <athos_indirection_table_install+0xce8>
  907a8e:	1469f3        	l32r	a4, 8e225c <athos_indirection_table_install+0xce8>
  907a91:	2b2200        	l32i	a11, a2, 0
  907a94:	044a02        	or	a10, a4, a4
  907a97:	2c0a3c        	movi	a12, 60
  907a9a:	58002a        	call8	907b44 <ath_hal_memcpy>
				sizeof(ConfigDescriptorPatch));

		 /* place holder for EPx patches */

		if (mDEV_REQ_VALUE_LOW() == 0) {
  907a9d:	283007        	l8ui	a8, a3, 7
			/* configuration no: 0 */
			pu8DescriptorEX = ConfigDescriptorPatch;
			u16TxRxCounter = ConfigDescriptorPatch[1];
		} else
			return FALSE;
  907aa0:	c020      	movi.n	a2, 0
		ath_hal_memcpy(ConfigDescriptorPatch, p,
				sizeof(ConfigDescriptorPatch));

		 /* place holder for EPx patches */

		if (mDEV_REQ_VALUE_LOW() == 0) {
  907aa2:	728928        	bne	a8, a2, 907ace <bGet_descriptor_patch+0x76>
			/* configuration no: 0 */
			pu8DescriptorEX = ConfigDescriptorPatch;
  907aa5:	1269f1        	l32r	a2, 8e226c <athos_indirection_table_install+0xcf8>
  907aa8:	9420      	s32i.n	a4, a2, 0
			u16TxRxCounter = ConfigDescriptorPatch[1];
  907aaa:	244101        	l16ui	a4, a4, 2
  907aad:	1269f2        	l32r	a2, 8e2278 <athos_indirection_table_install+0xd04>
		} else
			return FALSE;

		if (u16TxRxCounter > mDEV_REQ_LENGTH())
  907ab0:	233105        	l16ui	a3, a3, 10
		 /* place holder for EPx patches */

		if (mDEV_REQ_VALUE_LOW() == 0) {
			/* configuration no: 0 */
			pu8DescriptorEX = ConfigDescriptorPatch;
			u16TxRxCounter = ConfigDescriptorPatch[1];
  907ab3:	242500        	s16i	a4, a2, 0
		} else
			return FALSE;

		if (u16TxRxCounter > mDEV_REQ_LENGTH())
  907ab6:	743b02        	bgeu	a3, a4, 907abc <bGet_descriptor_patch+0x64>
			u16TxRxCounter = mDEV_REQ_LENGTH();
  907ab9:	232500        	s16i	a3, a2, 0

		A_USB_EP0_TX_DATA();
  907abc:	126915        	l32r	a2, 8e1f10 <athos_indirection_table_install+0x99c>
  907abf:	222235        	l32i	a2, a2, 212
  907ac2:	0b2000        	callx8	a2
		return TRUE;
  907ac5:	c021      	movi.n	a2, 1
  907ac7:	d10f      	retw.n
	} else
		return bGet_descriptor();
  907ac9:	5b6ff4        	call8	8e3a9c <bGet_descriptor>
  907acc:	d2a0      	mov.n	a2, a10
}
  907ace:	d10f      	retw.n

00907ad0 <ath_hal_getuptime>:
#include<ah_internal.h>
#include "ah_osdep.h"

a_uint32_t __ahdecl
ath_hal_getuptime(struct ath_hal *ah)
{
  907ad0:	6c1004        	entry	a1, 32
	return MSEC_TO_TICK(msecs);
}
static inline unsigned long
__adf_os_getuptime(void)
{
    return MSEC_TO_TICK(A_MILLISECONDS());;      
  907ad3:	186915        	l32r	a8, 8e1f28 <athos_indirection_table_install+0x9b4>
  907ad6:	2a823e        	l32i	a10, a8, 248
  907ad9:	0ba000        	callx8	a10
	return adf_os_getuptime();
}
  907adc:	d2a0      	mov.n	a2, a10
  907ade:	d10f      	retw.n

00907ae0 <_ath_hal_attach_tgt>:

struct ath_hal *
_ath_hal_attach_tgt(a_uint32_t devid, HAL_SOFTC sc,
		    adf_os_device_t dev, a_uint32_t flags, void* s)
{
  907ae0:	6c1006        	entry	a1, 48
	HAL_STATUS status;
	struct ath_hal *ah = ath_hal_attach_tgt(devid, sc, dev, flags, &status);
  907ae3:	db30      	mov.n	a11, a3
  907ae5:	dc40      	mov.n	a12, a4
  907ae7:	dd50      	mov.n	a13, a5
  907ae9:	de10      	mov.n	a14, a1
  907aeb:	da20      	mov.n	a10, a2
  907aed:	580c94        	call8	90ad40 <ath_hal_attach_tgt>
	adf_os_print(" ath_hal = %p \n",ah);
  907af0:	186915        	l32r	a8, 8e1f44 <athos_indirection_table_install+0x9d0>
struct ath_hal *
_ath_hal_attach_tgt(a_uint32_t devid, HAL_SOFTC sc,
		    adf_os_device_t dev, a_uint32_t flags, void* s)
{
	HAL_STATUS status;
	struct ath_hal *ah = ath_hal_attach_tgt(devid, sc, dev, flags, &status);
  907af3:	d2a0      	mov.n	a2, a10
	adf_os_print(" ath_hal = %p \n",ah);
  907af5:	288212        	l32i	a8, a8, 72
  907af8:	1a69f5        	l32r	a10, 8e22cc <athos_indirection_table_install+0xd58>
  907afb:	db20      	mov.n	a11, a2
  907afd:	0b8000        	callx8	a8
	*(HAL_STATUS *)s = status;
  907b00:	8810      	l32i.n	a8, a1, 0
  907b02:	9860      	s32i.n	a8, a6, 0
	return ah;
}
  907b04:	d10f      	retw.n
	...

00907b08 <ath_hal_delay>:
/*
 * Delay n microseconds.
 */
void __ahdecl
ath_hal_delay(a_int32_t n)
{
  907b08:	6c1004        	entry	a1, 32
}

static inline void
__adf_os_udelay(int usecs)
{
    A_DELAY_USECS(usecs);
  907b0b:	186915        	l32r	a8, 8e1f60 <athos_indirection_table_install+0x9ec>
  907b0e:	da20      	mov.n	a10, a2
  907b10:	28823b        	l32i	a8, a8, 236
  907b13:	0b8000        	callx8	a8
  907b16:	d10f      	retw.n

00907b18 <ath_hal_malloc>:
/*
 * Allocate/free memory.
 */
void * __ahdecl
ath_hal_malloc(adf_os_size_t size)
{
  907b18:	6c1004        	entry	a1, 32
  907b1b:	146915        	l32r	a4, 8e1f70 <athos_indirection_table_install+0x9fc>
  907b1e:	d320      	mov.n	a3, a2
  907b20:	224252        	l32i	a2, a4, 0x148
  907b23:	c0a0      	movi.n	a10, 0
  907b25:	db30      	mov.n	a11, a3
  907b27:	0b2000        	callx8	a2
  907b2a:	d2a0      	mov.n	a2, a10
	void *p;

	p = adf_os_mem_alloc(size);
	if (p)
  907b2c:	c8a8      	beqz.n	a10, 907b38 <ath_hal_malloc+0x20>
}
/* zero a memory buffer */
static inline void
__adf_os_mem_zero(void *buf, adf_os_size_t size)
{
    A_MEMZERO(buf,size);
  907b2e:	8444      	l32i.n	a4, a4, 16
  907b30:	c0b0      	movi.n	a11, 0
  907b32:	033c02        	or	a12, a3, a3
  907b35:	0b4000        	callx8	a4
		adf_os_mem_zero(p, size);

	return p;
}
  907b38:	d10f      	retw.n
	...

00907b3c <ath_hal_free>:

void __ahdecl
ath_hal_free(void* p)
{
  907b3c:	6c1004        	entry	a1, 32
  907b3f:	d10f      	retw.n
  907b41:	000000        	ill

00907b44 <ath_hal_memcpy>:
	adf_os_mem_free(p);
}

void * __ahdecl
ath_hal_memcpy(void *dst, const void *src, adf_os_size_t n)
{
  907b44:	6c1004        	entry	a1, 32
}

/* move a memory buffer */
static inline void 		__adf_os_mem_copy(void *dst, const void *src, adf_os_size_t size)
{
    A_MEMCPY(dst,src,size);    
  907b47:	186915        	l32r	a8, 8e1f9c <athos_indirection_table_install+0xa28>
  907b4a:	da20      	mov.n	a10, a2
  907b4c:	8885      	l32i.n	a8, a8, 20
  907b4e:	db30      	mov.n	a11, a3
  907b50:	dc40      	mov.n	a12, a4
  907b52:	0b8000        	callx8	a8
	adf_os_mem_copy(dst, src, n);
	return 0;
}
  907b55:	c020      	movi.n	a2, 0
  907b57:	d10f      	retw.n
  907b59:	000000        	ill

00907b5c <__adf_os_mem_alloc>:

#include "cmnos_api.h"
#include "Magpie_api.h"

static inline void *	__adf_os_mem_alloc(adf_os_size_t size)
{
  907b5c:	6c1004        	entry	a1, 32
//    return (malloc(size,M_DEVBUF,M_DONTWAIT | M_ZERO));
    return A_ALLOCRAM(size);
  907b5f:	186915        	l32r	a8, 8e1fb4 <athos_indirection_table_install+0xa40>
  907b62:	db20      	mov.n	a11, a2
  907b64:	288252        	l32i	a8, a8, 0x148
  907b67:	c0a0      	movi.n	a10, 0
  907b69:	0b8000        	callx8	a8
}
  907b6c:	d2a0      	mov.n	a2, a10
  907b6e:	d10f      	retw.n

00907b70 <__adf_os_mem_copy>:
    //free(buf,M_DEVBUF);
}

/* move a memory buffer */
static inline void 		__adf_os_mem_copy(void *dst, const void *src, adf_os_size_t size)
{
  907b70:	6c1004        	entry	a1, 32
    A_MEMCPY(dst,src,size);    
  907b73:	186915        	l32r	a8, 8e1fc8 <athos_indirection_table_install+0xa54>
  907b76:	da20      	mov.n	a10, a2
  907b78:	8885      	l32i.n	a8, a8, 20
  907b7a:	db30      	mov.n	a11, a3
  907b7c:	dc40      	mov.n	a12, a4
  907b7e:	0b8000        	callx8	a8
  907b81:	d10f      	retw.n
	...

00907b84 <__adf_os_mem_set>:
}

/* set a memory buffer */
static inline void
__adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
{
  907b84:	6c1004        	entry	a1, 32
	A_MEMSET(buf, b, size);
  907b87:	186915        	l32r	a8, 8e1fdc <athos_indirection_table_install+0xa68>
  907b8a:	da20      	mov.n	a10, a2
  907b8c:	8884      	l32i.n	a8, a8, 16
  907b8e:	db30      	mov.n	a11, a3
  907b90:	dc40      	mov.n	a12, a4
  907b92:	0b8000        	callx8	a8
  907b95:	d10f      	retw.n
	...

00907b98 <tgt_HTCRecv_uapsdhandler>:
	ath_tgt_send_beacon(sc, hdr_buf, buf, EndPt);
}

static void tgt_HTCRecv_uapsdhandler(HTC_ENDPOINT_ID EndPt, adf_nbuf_t hdr_buf,
				     adf_nbuf_t buf, void *ServiceCtx)
{
  907b98:	6c1004        	entry	a1, 32
  907b9b:	d10f      	retw.n
  907b9d:	000000        	ill

00907ba0 <dispatch_magpie_sys_cmds>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void dispatch_magpie_sys_cmds(void *pContext, A_UINT16 Command,
				     A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
  907ba0:	6c1004        	entry	a1, 32
	adf_os_assert(0);
  907ba3:	186915        	l32r	a8, 8e1ff8 <athos_indirection_table_install+0xa84>
  907ba6:	1a69f6        	l32r	a10, 8e2380 <athos_indirection_table_install+0xe0c>
  907ba9:	288212        	l32i	a8, a8, 72
  907bac:	1b69f7        	l32r	a11, 8e2388 <athos_indirection_table_install+0xe14>
  907baf:	0b8000        	callx8	a8
  907bb2:	18697a        	l32r	a8, 8e219c <athos_indirection_table_install+0xc28>
  907bb5:	0c0200        	memw
  907bb8:	8880      	l32i.n	a8, a8, 0
  907bba:	d10f      	retw.n

00907bbc <htc_setup_comp>:
/*****************/
/* Init / Deinit */
/*****************/

static void htc_setup_comp(void)
{
  907bbc:	6c1004        	entry	a1, 32
  907bbf:	d10f      	retw.n
  907bc1:	000000        	ill

00907bc4 <tgt_reg_service>:
	return HTC_SERVICE_SUCCESS;
}

static void tgt_reg_service(struct ath_softc_tgt *sc, HTC_SERVICE *svc,
			    int svcId, HTC_SERVICE_ProcessRecvMsg recvMsg)
{
  907bc4:	6c1004        	entry	a1, 32
	svc->ProcessRecvMsg = recvMsg;
	svc->ProcessSendBufferComplete = tgt_HTCSendCompleteHandler;
  907bc7:	1869f8        	l32r	a8, 8e23a8 <athos_indirection_table_install+0xe34>
	svc->ProcessConnect = tgt_ServiceConnect;
	svc->MaxSvcMsgSize = 1600;
	svc->TrailerSpcCheckLimit = 0;
	svc->ServiceID = svcId;
	svc->ServiceCtx = sc;
	HTC_RegisterService(sc->tgt_htc_handle, svc);
  907bca:	8a22      	l32i.n	a10, a2, 8

static void tgt_reg_service(struct ath_softc_tgt *sc, HTC_SERVICE *svc,
			    int svcId, HTC_SERVICE_ProcessRecvMsg recvMsg)
{
	svc->ProcessRecvMsg = recvMsg;
	svc->ProcessSendBufferComplete = tgt_HTCSendCompleteHandler;
  907bcc:	9832      	s32i.n	a8, a3, 8
	svc->ProcessConnect = tgt_ServiceConnect;
  907bce:	1869f9        	l32r	a8, 8e23b4 <athos_indirection_table_install+0xe40>
	return HTC_SERVICE_SUCCESS;
}

static void tgt_reg_service(struct ath_softc_tgt *sc, HTC_SERVICE *svc,
			    int svcId, HTC_SERVICE_ProcessRecvMsg recvMsg)
{
  907bd1:	db30      	mov.n	a11, a3
	svc->ProcessRecvMsg = recvMsg;
	svc->ProcessSendBufferComplete = tgt_HTCSendCompleteHandler;
	svc->ProcessConnect = tgt_ServiceConnect;
  907bd3:	9833      	s32i.n	a8, a3, 12
	svc->MaxSvcMsgSize = 1600;
  907bd5:	286a40        	movi	a8, 0x640
  907bd8:	28350a        	s16i	a8, a3, 20
	svc->TrailerSpcCheckLimit = 0;
  907bdb:	c080      	movi.n	a8, 0
  907bdd:	28350b        	s16i	a8, a3, 22
	svc->ServiceID = svcId;
	svc->ServiceCtx = sc;
	HTC_RegisterService(sc->tgt_htc_handle, svc);
  907be0:	186915        	l32r	a8, 8e2034 <athos_indirection_table_install+0xac0>
}

static void tgt_reg_service(struct ath_softc_tgt *sc, HTC_SERVICE *svc,
			    int svcId, HTC_SERVICE_ProcessRecvMsg recvMsg)
{
	svc->ProcessRecvMsg = recvMsg;
  907be3:	9531      	s32i.n	a5, a3, 4
	svc->ProcessConnect = tgt_ServiceConnect;
	svc->MaxSvcMsgSize = 1600;
	svc->TrailerSpcCheckLimit = 0;
	svc->ServiceID = svcId;
	svc->ServiceCtx = sc;
	HTC_RegisterService(sc->tgt_htc_handle, svc);
  907be5:	288280        	l32i	a8, a8, 0x200
	svc->ProcessRecvMsg = recvMsg;
	svc->ProcessSendBufferComplete = tgt_HTCSendCompleteHandler;
	svc->ProcessConnect = tgt_ServiceConnect;
	svc->MaxSvcMsgSize = 1600;
	svc->TrailerSpcCheckLimit = 0;
	svc->ServiceID = svcId;
  907be8:	243508        	s16i	a4, a3, 16
	svc->ServiceCtx = sc;
  907beb:	9236      	s32i.n	a2, a3, 24
	HTC_RegisterService(sc->tgt_htc_handle, svc);
  907bed:	0b8000        	callx8	a8
  907bf0:	d10f      	retw.n
	...

00907bf4 <tgt_HTCRecv_mgmthandler>:
{
}

static void tgt_HTCRecv_mgmthandler(HTC_ENDPOINT_ID EndPt, adf_nbuf_t hdr_buf,
				    adf_nbuf_t buf, void *ServiceCtx)
{
  907bf4:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)ServiceCtx;

	ath_tgt_send_mgt(sc,hdr_buf,buf,EndPt);
  907bf7:	da50      	mov.n	a10, a5
  907bf9:	db30      	mov.n	a11, a3
  907bfb:	dc40      	mov.n	a12, a4
  907bfd:	dd20      	mov.n	a13, a2
  907bff:	5818a0        	call8	90de80 <ath_tgt_send_mgt>
  907c02:	d10f      	retw.n

00907c04 <ath_tgt_rx_tasklet>:

	return 0;
}

static void ath_tgt_rx_tasklet(TQUEUE_ARG data)
{
  907c04:	6c1006        	entry	a1, 48
	struct ath_softc_tgt *sc  = (struct ath_softc_tgt *)data;
	struct ath_rx_buf *bf = NULL;
	struct ath_hal *ah = sc->sc_ah;
  907c07:	232d05        	addmi	a3, a2, 0x500
  907c0a:	863b      	l32i.n	a6, a3, 44
			continue;
		}

		asf_tailq_remove(&sc->sc_rxbuf, bf, bf_list);

		bf->bf_skb = NULL;
  907c0c:	c070      	movi.n	a7, 0
	struct rx_frame_header *rxhdr;
	struct ath_rx_status *rxstats;
	adf_nbuf_t skb = ADF_NBUF_NULL;

	do {
		bf = asf_tailq_first(&sc->sc_rxbuf);
  907c0e:	2322d5        	l32i	a3, a2, 0x354
		if (bf == NULL) {
  907c11:	643090        	beqz	a3, 907ca5 <ath_tgt_rx_tasklet+0xa1>
			break;
		}

		if (!(bf->bf_status & ATH_BUFSTATUS_DONE)) {
  907c14:	843f      	l32i.n	a4, a3, 60
  907c16:	7f4f02        	bbsi	a4, 31, 907c1c <ath_tgt_rx_tasklet+0x18>
  907c19:	600088        	j	907ca5 <ath_tgt_rx_tasklet+0xa1>
			break;
		}

		skb = bf->bf_skb;
  907c1c:	8538      	l32i.n	a5, a3, 32
		if (skb == NULL) {
  907c1e:	645ff2        	beqz	a5, 907c14 <ath_tgt_rx_tasklet+0x10>
			continue;
		}

		asf_tailq_remove(&sc->sc_rxbuf, bf, bf_list);
  907c21:	8439      	l32i.n	a4, a3, 36
  907c23:	883a      	l32i.n	a8, a3, 40
  907c25:	c843      	beqz.n	a4, 907c2c <ath_tgt_rx_tasklet+0x28>
  907c27:	984a      	s32i.n	a8, a4, 40
  907c29:	600002        	j	907c2f <ath_tgt_rx_tasklet+0x2b>
  907c2c:	2826d6        	s32i	a8, a2, 0x358
  907c2f:	883a      	l32i.n	a8, a3, 40
 *         or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_push_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_push_head(buf, size);
  907c31:	c2b8      	movi.n	a11, 40
  907c33:	9480      	s32i.n	a4, a8, 0

		bf->bf_skb = NULL;
  907c35:	273608        	s32i	a7, a3, 32
  907c38:	055a02        	or	a10, a5, a5
  907c3b:	5bfb3f        	call8	906938 <__adf_nbuf_push_head>
 * @param[in] size    buffer size
 */
static inline void
adf_os_mem_copy(void *dst, const void *src, adf_os_size_t size)
{
    __adf_os_mem_copy(dst, src, size);
  907c3e:	c2c8      	movi.n	a12, 40
  907c40:	2b3c40        	addi	a11, a3, 64
  907c43:	0aa402        	or	a4, a10, a10
  907c46:	5bffca        	call8	907b70 <__adf_os_mem_copy>
 * extend(0x00000012fffffffc, 0xfffffffa) == 0x00000012fffffffa
 * extend(0x00000012fffffffc, 0x00000002) == 0x0000001300000002  ! tsfhigh++
 */
static u_int64_t ath_extend_tsf(struct ath_softc_tgt *sc, u_int32_t rstamp)
{
	struct ath_hal *ah = sc->sc_ah;
  907c49:	292d05        	addmi	a9, a2, 0x500
  907c4c:	8a9b      	l32i.n	a10, a9, 44
						     sizeof(struct rx_frame_header));
		rxstats = (struct ath_rx_status *)(&rxhdr->rx_stats[0]);
		adf_os_mem_copy(rxstats, &(bf->bf_rx_status),
				sizeof(struct ath_rx_status));

		rxstats->rs_tstamp = ath_extend_tsf(sc, (u_int32_t)rxstats->rs_tstamp);
  907c4e:	8841      	l32i.n	a8, a4, 4
	struct ath_hal *ah = sc->sc_ah;
	u_int64_t tsf;
	u_int32_t tsf_low;
	a_int64_t tsf_delta;  /* signed int64 */

	tsf = ah->ah_getTsf64(ah);
  907c50:	29a21e        	l32i	a9, a10, 120
  907c53:	9810      	s32i.n	a8, a1, 0
  907c55:	0b9000        	callx8	a9
	tsf_low = tsf & 0xffffffffUL;

	tsf_delta = (a_int32_t)((rstamp - tsf_low) & 0xffffffffUL);
  907c58:	8810      	l32i.n	a8, a1, 0

	return (tsf + (u_int64_t)tsf_delta);
  907c5a:	c091      	movi.n	a9, 1
	a_int64_t tsf_delta;  /* signed int64 */

	tsf = ah->ah_getTsf64(ah);
	tsf_low = tsf & 0xffffffffUL;

	tsf_delta = (a_int32_t)((rstamp - tsf_low) & 0xffffffffUL);
  907c5c:	0b880c        	sub	a8, a8, a11

	return (tsf + (u_int64_t)tsf_delta);
  907c5f:	ab8b      	add.n	a11, a8, a11
  907c61:	08fc13        	srai	a12, a8, 31
  907c64:	78b301        	bltu	a11, a8, 907c69 <ath_tgt_rx_tasklet+0x65>
  907c67:	c090      	movi.n	a9, 0
  907c69:	aaca      	add.n	a10, a12, a10
  907c6b:	aa99      	add.n	a9, a9, a10
						     sizeof(struct rx_frame_header));
		rxstats = (struct ath_rx_status *)(&rxhdr->rx_stats[0]);
		adf_os_mem_copy(rxstats, &(bf->bf_rx_status),
				sizeof(struct ath_rx_status));

		rxstats->rs_tstamp = ath_extend_tsf(sc, (u_int32_t)rxstats->rs_tstamp);
  907c6d:	9b41      	s32i.n	a11, a4, 4
  907c6f:	9940      	s32i.n	a9, a4, 0

		HTC_SendMsg(sc->tgt_htc_handle, RX_ENDPOINT_ID, skb);
  907c71:	146915        	l32r	a4, 8e20c8 <athos_indirection_table_install+0xb54>
  907c74:	8a22      	l32i.n	a10, a2, 8
  907c76:	244284        	l32i	a4, a4, 0x210
  907c79:	dc50      	mov.n	a12, a5
  907c7b:	c0b3      	movi.n	a11, 3
  907c7d:	0b4000        	callx8	a4
		sc->sc_rx_stats.ast_rx_send++;
  907c80:	24227d        	l32i	a4, a2, 0x1f4

		bf->bf_status &= ~ATH_BUFSTATUS_DONE;
  907c83:	853f      	l32i.n	a5, a3, 60
				sizeof(struct ath_rx_status));

		rxstats->rs_tstamp = ath_extend_tsf(sc, (u_int32_t)rxstats->rs_tstamp);

		HTC_SendMsg(sc->tgt_htc_handle, RX_ENDPOINT_ID, skb);
		sc->sc_rx_stats.ast_rx_send++;
  907c85:	b144      	addi.n	a4, a4, 1
  907c87:	24267d        	s32i	a4, a2, 0x1f4

		bf->bf_status &= ~ATH_BUFSTATUS_DONE;
  907c8a:	c74e      	movi.n	a4, -2
  907c8c:	045401        	and	a4, a5, a4
  907c8f:	943f      	s32i.n	a4, a3, 60
		asf_tailq_insert_tail(&sc->sc_rxbuf, bf, bf_list);
  907c91:	2422d6        	l32i	a4, a2, 0x358
  907c94:	9739      	s32i.n	a7, a3, 36
  907c96:	943a      	s32i.n	a4, a3, 40
  907c98:	9340      	s32i.n	a3, a4, 0
  907c9a:	233c24        	addi	a3, a3, 36
  907c9d:	2326d6        	s32i	a3, a2, 0x358
  907ca0:	63ff6a        	j	907c0e <ath_tgt_rx_tasklet+0xa>
  907ca3:	000023        	excw

	} while(1);

	sc->sc_imask |= HAL_INT_RX;
  907ca6:	22c4c0        	s8i	a2, a12, 192
  907ca9:	b103      	addi.n	a3, a0, 1
  907cab:	bb02      	addi.n	a2, a0, 11
  907cad:	2b26c4        	s32i	a11, a2, 0x310
	ah->ah_setInterrupts(ah, sc->sc_imask);
  907cb0:	226228        	l32i	a2, a6, 160
  907cb3:	da60      	mov.n	a10, a6
  907cb5:	0b2000        	callx8	a2
  907cb8:	d10f      	retw.n
	...

00907cbc <ath_descdma_cleanup>:
}

static void ath_descdma_cleanup(struct ath_softc_tgt *sc,
				struct ath_descdma *dd,
				ath_bufhead *head, a_int32_t dir)
{
  907cbc:	6c1006        	entry	a1, 48
	struct ath_buf *bf;
	struct ieee80211_node_target *ni;

	asf_tailq_foreach(bf, head, bf_list) {
  907cbf:	8740      	l32i.n	a7, a4, 0
  907cc1:	60007d        	j	907d42 <ath_descdma_cleanup+0x86>
		if (adf_nbuf_queue_len(&bf->bf_skbhead) != 0) {
  907cc4:	267c14        	addi	a6, a7, 20
 * @return length of the queue
 */
static inline a_uint32_t
adf_nbuf_queue_len(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_len(head);
  907cc7:	da60      	mov.n	a10, a6
  907cc9:	5bfbff        	call8	906cc8 <__adf_nbuf_queue_len>
  907ccc:	d9a0      	mov.n	a9, a10
  907cce:	cbac      	beqz.n	a10, 907d0e <ath_descdma_cleanup+0x52>
static inline void
adf_nbuf_unmap(adf_os_device_t      osdev, 
               adf_os_dma_map_t     bmap, 
               adf_os_dma_dir_t     dir)
{
    __adf_nbuf_unmap(osdev, bmap, dir);
  907cd0:	2a2246        	l32i	a10, a2, 0x118
  907cd3:	2b7200        	l32i	a11, a7, 0
  907cd6:	055c02        	or	a12, a5, a5
  907cd9:	5bfb6b        	call8	906a88 <__adf_nbuf_unmap>
  907cdc:	600021        	j	907d01 <ath_descdma_cleanup+0x45>
  907cdf:	000018        	src	a0, a0, a0
			adf_nbuf_unmap(sc->sc_dev, bf->bf_dmamap, dir);
			while(adf_nbuf_queue_len(&bf->bf_skbhead) != 0) {
				ath_free_rx_skb(sc,
  907ce2:	69158b        	bnei	a1, 5, 907c71 <ath_tgt_rx_tasklet+0x6d>
  907ce5:	202982        	l16si	a0, a2, 0x104
  907ce8:	9eda      	s32i.n	a14, a13, 40
 * @return The head buf in the buf queue.
 */
static inline adf_nbuf_t
adf_nbuf_queue_remove(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_remove(head);
  907cea:	609911        	j	9115ff <_etext+0x24e6>
  907ced:	9b10      	s32i.n	a11, a1, 0
  907cef:	5bfb52        	call8	906a38 <__adf_nbuf_queue_remove>
  907cf2:	8b10      	l32i.n	a11, a1, 0
  907cf4:	8911      	l32i.n	a9, a1, 4
  907cf6:	0aac02        	or	a12, a10, a10
  907cf9:	0bba02        	or	a10, a11, a11
  907cfc:	c0b3      	movi.n	a11, 3
  907cfe:	0b9000        	callx8	a9
 * @return length of the queue
 */
static inline a_uint32_t
adf_nbuf_queue_len(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_len(head);
  907d01:	da60      	mov.n	a10, a6
  907d03:	5bfbf1        	call8	906cc8 <__adf_nbuf_queue_len>
	struct ieee80211_node_target *ni;

	asf_tailq_foreach(bf, head, bf_list) {
		if (adf_nbuf_queue_len(&bf->bf_skbhead) != 0) {
			adf_nbuf_unmap(sc->sc_dev, bf->bf_dmamap, dir);
			while(adf_nbuf_queue_len(&bf->bf_skbhead) != 0) {
  907d06:	65afd7        	bnez	a10, 907ce1 <ath_descdma_cleanup+0x25>
				ath_free_rx_skb(sc,
					adf_nbuf_queue_remove(&bf->bf_skbhead));
			}
			bf->bf_skb = NULL;
  907d09:	9a78      	s32i.n	a10, a7, 32
  907d0b:	600025        	j	907d34 <ath_descdma_cleanup+0x78>
		} else if (bf->bf_skb != NULL) {
  907d0e:	8678      	l32i.n	a6, a7, 32
  907d10:	ca60      	beqz.n	a6, 907d34 <ath_descdma_cleanup+0x78>
static inline void
adf_nbuf_unmap(adf_os_device_t      osdev, 
               adf_os_dma_map_t     bmap, 
               adf_os_dma_dir_t     dir)
{
    __adf_nbuf_unmap(osdev, bmap, dir);
  907d12:	2b7200        	l32i	a11, a7, 0
  907d15:	2a2246        	l32i	a10, a2, 0x118
  907d18:	055c02        	or	a12, a5, a5
  907d1b:	291601        	s32i	a9, a1, 4
  907d1e:	5bfb5a        	call8	906a88 <__adf_nbuf_unmap>
			adf_nbuf_unmap(sc->sc_dev,bf->bf_dmamap, dir);
			ath_free_rx_skb(sc, bf->bf_skb);
  907d21:	186915        	l32r	a8, 8e2178 <athos_indirection_table_install+0xc04>
  907d24:	8a20      	l32i.n	a10, a2, 0
  907d26:	26829e        	l32i	a6, a8, 0x278
  907d29:	8c78      	l32i.n	a12, a7, 32
  907d2b:	c0b3      	movi.n	a11, 3
  907d2d:	0b6000        	callx8	a6
			bf->bf_skb = NULL;
  907d30:	8911      	l32i.n	a9, a1, 4
  907d32:	9978      	s32i.n	a9, a7, 32
 * @param[in] dmap
 */
static inline void
adf_nbuf_dmamap_destroy(adf_os_device_t osdev, adf_os_dma_map_t dmap)
{
    __adf_nbuf_dmamap_destroy(osdev, dmap);
  907d34:	8b70      	l32i.n	a11, a7, 0
  907d36:	2a2246        	l32i	a10, a2, 0x118
		}

		adf_nbuf_dmamap_destroy(sc->sc_dev, bf->bf_dmamap);

		ni = bf->bf_node;
		bf->bf_node = NULL;
  907d39:	c060      	movi.n	a6, 0
  907d3b:	5bfb56        	call8	906a94 <__adf_nbuf_dmamap_destroy>
  907d3e:	9674      	s32i.n	a6, a7, 16
				ath_bufhead *head, a_int32_t dir)
{
	struct ath_buf *bf;
	struct ieee80211_node_target *ni;

	asf_tailq_foreach(bf, head, bf_list) {
  907d40:	8779      	l32i.n	a7, a7, 36
  907d42:	657f7e        	bnez	a7, 907cc4 <ath_descdma_cleanup+0x8>
	}

	adf_os_dmamem_free(sc->sc_dev, dd->dd_desc_len,
			   1, dd->dd_desc, dd->dd_desc_dmamap);

	asf_tailq_init(head);
  907d45:	9740      	s32i.n	a7, a4, 0
  907d47:	9441      	s32i.n	a4, a4, 4
 * @param[in] size  buffer size
 */
static inline void
adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
{
    __adf_os_mem_set(buf, b, size);
  907d49:	da30      	mov.n	a10, a3
  907d4b:	db70      	mov.n	a11, a7
  907d4d:	c1c8      	movi.n	a12, 24
  907d4f:	5bff8d        	call8	907b84 <__adf_os_mem_set>
  907d52:	d10f      	retw.n

00907d54 <__adf_os_init_bh$isra$4>:
									  void 				*arg)
{
	__adf_os_init_defer(work, func, arg);
}

static inline void	__adf_os_init_bh(adf_os_handle_t  hdl,
  907d54:	6c1004        	entry	a1, 32
									 __adf_os_bh_t		*bh,
									 adf_os_defer_fn_t	func,
									 void				*arg)
{
	//__adf_os_init_defer(bh, func, arg);
	A_TASKLET_INIT_TASK(func, arg, bh);
  907d57:	186915        	l32r	a8, 8e21ac <athos_indirection_table_install+0xc38>
  907d5a:	da30      	mov.n	a10, a3
  907d5c:	28826a        	l32i	a8, a8, 0x1a8
  907d5f:	db40      	mov.n	a11, a4
  907d61:	dc20      	mov.n	a12, a2
  907d63:	0b8000        	callx8	a8
  907d66:	d10f      	retw.n

00907d68 <__adf_os_sched_bh$isra$5>:
                                         __adf_os_work_t  * work)
{
    //taskqueue_drain(taskqueue_thread, &work->tsk);
}

static inline void __adf_os_sched_bh(adf_os_handle_t  hdl, 
  907d68:	6c1004        	entry	a1, 32
                                       __adf_os_bh_t  * bh)
{
    A_TASKLET_SCHEDULE(bh);
  907d6b:	186915        	l32r	a8, 8e21c0 <athos_indirection_table_install+0xc4c>
  907d6e:	da20      	mov.n	a10, a2
  907d70:	28826c        	l32i	a8, a8, 0x1b0
  907d73:	0b8000        	callx8	a8
  907d76:	d10f      	retw.n

00907d78 <ath_rxdesc_init>:
				       RX_HEADER_SPACE, align);
	return skb;
}

static a_int32_t ath_rxdesc_init(struct ath_softc_tgt *sc, struct ath_rx_desc *ds)
{
  907d78:	6c1006        	entry	a1, 48
	struct ath_hal *ah = sc->sc_ah;
  907d7b:	242d05        	addmi	a4, a2, 0x500
  907d7e:	854b      	l32i.n	a5, a4, 44
	struct ath_rx_desc *ds_held;
	a_uint8_t *anbdata;
	a_uint32_t anblen;

	if (!sc->sc_rxdesc_held) {
  907d80:	2422db        	l32i	a4, a2, 0x36c
		sc->sc_rxdesc_held = ds;
  907d83:	2326db        	s32i	a3, a2, 0x36c
	struct ath_hal *ah = sc->sc_ah;
	struct ath_rx_desc *ds_held;
	a_uint8_t *anbdata;
	a_uint32_t anblen;

	if (!sc->sc_rxdesc_held) {
  907d86:	cc43      	bnez.n	a4, 907d8d <ath_rxdesc_init+0x15>
  907d88:	60017c        	j	907f08 <ath_rxdesc_init+0x190>
  907d8b:	000029        	excw

	ds_held = sc->sc_rxdesc_held;
	sc->sc_rxdesc_held = ds;
	ds = ds_held;

	if (ds->ds_nbuf == ADF_NBUF_NULL) {
  907d8e:	403428        	excw
  907d91:	403523        	excw
  907d94:	403608        	excw
  907d97:	9910      	s32i.n	a9, a1, 0
  907d99:	008811        	slli	a8, a8, 16
  907d9c:	098802        	or	a8, a8, a9
  907d9f:	083311        	slli	a3, a3, 8
  907da2:	083302        	or	a3, a3, a8
  907da5:	284037        	l8ui	a8, a4, 55
  907da8:	038302        	or	a3, a8, a3
  907dab:	6530b6        	bnez	a3, 907e65 <ath_rxdesc_init+0xed>
static adf_nbuf_t ath_alloc_skb_align(struct ath_softc_tgt *sc,
				      a_uint32_t size, a_uint32_t align)
{
	adf_nbuf_t skb;

	skb = BUF_Pool_alloc_buf_align(sc->pool_handle, POOL_ID_WLAN_RX_BUF,
  907dae:	136915        	l32r	a3, 8e2204 <athos_indirection_table_install+0xc90>
  907db1:	8a20      	l32i.n	a10, a2, 0
  907db3:	23329d        	l32i	a3, a3, 0x274
  907db6:	2d2196        	l16ui	a13, a2, 0x12c
  907db9:	c3c0      	movi.n	a12, 48
  907dbb:	c0b3      	movi.n	a11, 3
  907dbd:	0b3000        	callx8	a3
	ds_held = sc->sc_rxdesc_held;
	sc->sc_rxdesc_held = ds;
	ds = ds_held;

	if (ds->ds_nbuf == ADF_NBUF_NULL) {
		ds->ds_nbuf = ath_alloc_skb_align(sc, sc->sc_rxbufsize, sc->sc_cachelsz);
  907dc0:	0a8357        	extui	a3, a10, 24, 8
  907dc3:	234434        	s8i	a3, a4, 52
  907dc6:	0a0357        	extui	a3, a10, 16, 8
  907dc9:	234435        	s8i	a3, a4, 53
  907dcc:	0a8347        	extui	a3, a10, 8, 8
  907dcf:	234436        	s8i	a3, a4, 54
  907dd2:	2a4437        	s8i	a10, a4, 55
static adf_nbuf_t ath_alloc_skb_align(struct ath_softc_tgt *sc,
				      a_uint32_t size, a_uint32_t align)
{
	adf_nbuf_t skb;

	skb = BUF_Pool_alloc_buf_align(sc->pool_handle, POOL_ID_WLAN_RX_BUF,
  907dd5:	dca0      	mov.n	a12, a10
	sc->sc_rxdesc_held = ds;
	ds = ds_held;

	if (ds->ds_nbuf == ADF_NBUF_NULL) {
		ds->ds_nbuf = ath_alloc_skb_align(sc, sc->sc_rxbufsize, sc->sc_cachelsz);
		if (ds->ds_nbuf == ADF_NBUF_NULL) {
  907dd7:	ccad      	bnez.n	a10, 907de8 <ath_rxdesc_init+0x70>
			sc->sc_rxdesc_held = ds;
			sc->sc_rx_stats.ast_rx_nobuf++;
  907dd9:	23227c        	l32i	a3, a2, 0x1f0
	ds = ds_held;

	if (ds->ds_nbuf == ADF_NBUF_NULL) {
		ds->ds_nbuf = ath_alloc_skb_align(sc, sc->sc_rxbufsize, sc->sc_cachelsz);
		if (ds->ds_nbuf == ADF_NBUF_NULL) {
			sc->sc_rxdesc_held = ds;
  907ddc:	2426db        	s32i	a4, a2, 0x36c
			sc->sc_rx_stats.ast_rx_nobuf++;
  907ddf:	b133      	addi.n	a3, a3, 1
  907de1:	23267c        	s32i	a3, a2, 0x1f0
			return ENOMEM;
  907de4:	c72f      	movi.n	a2, -1
  907de6:	d10f      	retw.n
		}
		adf_nbuf_map(sc->sc_dev, ds->ds_dmap, ds->ds_nbuf, ADF_OS_DMA_FROM_DEVICE);
  907de8:	294038        	l8ui	a9, a4, 56
  907deb:	284039        	l8ui	a8, a4, 57
  907dee:	23403a        	l8ui	a3, a4, 58
  907df1:	089910        	slli	a9, a9, 24
  907df4:	008811        	slli	a8, a8, 16
  907df7:	098802        	or	a8, a8, a9
  907dfa:	2b403b        	l8ui	a11, a4, 59
  907dfd:	083311        	slli	a3, a3, 8
  907e00:	083302        	or	a3, a3, a8
adf_nbuf_map(adf_os_device_t        osdev, 
             adf_os_dma_map_t       bmap, 
             adf_nbuf_t             buf, 
             adf_os_dma_dir_t       dir)
{
    return __adf_nbuf_map(osdev, bmap, buf, dir);
  907e03:	2a2246        	l32i	a10, a2, 0x118
  907e06:	03bb02        	or	a11, a11, a3
  907e09:	c0d1      	movi.n	a13, 1
  907e0b:	5bfb1c        	call8	906a7c <__adf_nbuf_map>
		adf_nbuf_dmamap_info(ds->ds_dmap, &ds->ds_dmap_info);
  907e0e:	294038        	l8ui	a9, a4, 56
  907e11:	284039        	l8ui	a8, a4, 57
  907e14:	23403a        	l8ui	a3, a4, 58
  907e17:	089910        	slli	a9, a9, 24
  907e1a:	008811        	slli	a8, a8, 16
  907e1d:	098802        	or	a8, a8, a9
  907e20:	2a403b        	l8ui	a10, a4, 59
  907e23:	083311        	slli	a3, a3, 8
  907e26:	083302        	or	a3, a3, a8
 * @param[out] sg   map info
 */
static inline void
adf_nbuf_dmamap_info(adf_os_dma_map_t bmap, adf_os_dmamap_info_t *sg)
{
    __adf_nbuf_dmamap_info(bmap, sg);
  907e29:	03aa02        	or	a10, a10, a3
  907e2c:	2b4c3c        	addi	a11, a4, 60
  907e2f:	5bfb1b        	call8	906a9c <__adf_nbuf_dmamap_info>
		ds->ds_data = ds->ds_dmap_info.dma_segs[0].paddr;
  907e32:	294040        	l8ui	a9, a4, 64
  907e35:	234041        	l8ui	a3, a4, 65
  907e38:	284042        	l8ui	a8, a4, 66
  907e3b:	089910        	slli	a9, a9, 24
  907e3e:	003311        	slli	a3, a3, 16
  907e41:	093302        	or	a3, a3, a9
  907e44:	088811        	slli	a8, a8, 8
  907e47:	038802        	or	a8, a8, a3
  907e4a:	234043        	l8ui	a3, a4, 67
  907e4d:	083802        	or	a8, a3, a8
  907e50:	088357        	extui	a3, a8, 24, 8
  907e53:	234404        	s8i	a3, a4, 4
  907e56:	080357        	extui	a3, a8, 16, 8
  907e59:	234405        	s8i	a3, a4, 5
  907e5c:	088347        	extui	a3, a8, 8, 8
  907e5f:	234406        	s8i	a3, a4, 6
  907e62:	284407        	s8i	a8, a4, 7
	}

	ds->ds_link = 0;
  907e65:	c080      	movi.n	a8, 0
  907e67:	284400        	s8i	a8, a4, 0
  907e6a:	284401        	s8i	a8, a4, 1
  907e6d:	284402        	s8i	a8, a4, 2
  907e70:	284403        	s8i	a8, a4, 3
	adf_nbuf_peek_header(ds->ds_nbuf, &anbdata, &anblen);
  907e73:	294034        	l8ui	a9, a4, 52
  907e76:	284035        	l8ui	a8, a4, 53
  907e79:	234036        	l8ui	a3, a4, 54
  907e7c:	089910        	slli	a9, a9, 24
  907e7f:	008811        	slli	a8, a8, 16
  907e82:	098802        	or	a8, a8, a9
  907e85:	2a4037        	l8ui	a10, a4, 55
  907e88:	083311        	slli	a3, a3, 8
  907e8b:	083302        	or	a3, a3, a8
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  907e8e:	03aa02        	or	a10, a10, a3
  907e91:	b41b      	addi.n	a11, a1, 4
  907e93:	dc10      	mov.n	a12, a1
  907e95:	5bfb82        	call8	906ca0 <__adf_nbuf_peek_header>

	ah->ah_setupRxDesc(ds, adf_nbuf_tailroom(ds->ds_nbuf), 0);
  907e98:	2a4034        	l8ui	a10, a4, 52
  907e9b:	294035        	l8ui	a9, a4, 53
  907e9e:	284036        	l8ui	a8, a4, 54
  907ea1:	08aa10        	slli	a10, a10, 24
  907ea4:	009911        	slli	a9, a9, 16
  907ea7:	0a9902        	or	a9, a9, a10
  907eaa:	088811        	slli	a8, a8, 8
  907ead:	2a4037        	l8ui	a10, a4, 55
  907eb0:	098802        	or	a8, a8, a9
 * @return amount of tail room 
 */
static inline a_uint32_t
adf_nbuf_tailroom(adf_nbuf_t buf)
{
    return (__adf_nbuf_tailroom(buf));
  907eb3:	08aa02        	or	a10, a10, a8
  907eb6:	235220        	l32i	a3, a5, 128
  907eb9:	5bfb6a        	call8	906c64 <__adf_nbuf_tailroom>
  907ebc:	dba0      	mov.n	a11, a10
  907ebe:	c0c0      	movi.n	a12, 0
  907ec0:	da40      	mov.n	a10, a4
  907ec2:	0b3000        	callx8	a3
  907ec5:	2a4048        	l8ui	a10, a4, 72
  907ec8:	294049        	l8ui	a9, a4, 73

	if (sc->sc_rxlink == NULL) {
		ah->ah_setRxDP(ah, ds->ds_daddr);
  907ecb:	08aa10        	slli	a10, a10, 24
  907ece:	009911        	slli	a9, a9, 16
  907ed1:	0a9a02        	or	a10, a9, a10
  907ed4:	29404a        	l8ui	a9, a4, 74
	ds->ds_link = 0;
	adf_nbuf_peek_header(ds->ds_nbuf, &anbdata, &anblen);

	ah->ah_setupRxDesc(ds, adf_nbuf_tailroom(ds->ds_nbuf), 0);

	if (sc->sc_rxlink == NULL) {
  907ed7:	2822ef        	l32i	a8, a2, 0x3bc
		ah->ah_setRxDP(ah, ds->ds_daddr);
  907eda:	089911        	slli	a9, a9, 8
  907edd:	0a9902        	or	a9, a9, a10
	ds->ds_link = 0;
	adf_nbuf_peek_header(ds->ds_nbuf, &anbdata, &anblen);

	ah->ah_setupRxDesc(ds, adf_nbuf_tailroom(ds->ds_nbuf), 0);

	if (sc->sc_rxlink == NULL) {
  907ee0:	cd81      	bnez.n	a8, 907ef5 <ath_rxdesc_init+0x17d>
		ah->ah_setRxDP(ah, ds->ds_daddr);
  907ee2:	2b404b        	l8ui	a11, a4, 75
  907ee5:	23521f        	l32i	a3, a5, 124
  907ee8:	da50      	mov.n	a10, a5
  907eea:	09bb02        	or	a11, a11, a9
  907eed:	0b3000        	callx8	a3
  907ef0:	600009        	j	907efd <ath_rxdesc_init+0x185>
  907ef3:	000023        	excw
	}
	else {
		*sc->sc_rxlink = ds->ds_daddr;
  907ef6:	404b09        	excw
  907ef9:	390299        	excw
  907efc:	8024      	l32i.n	a0, a2, 16
	}
	sc->sc_rxlink = &ds->ds_link;
  907efe:	26ef22        	s32ri	a6, a14, 136
	ah->ah_enableReceive(ah);
  907f01:	5225da        	call0	89166c <_bss_end+0x37e75c>
  907f04:	500b20        	call0	90ab88 <zfTurnOffPower_patch+0xd0>
  907f07:	00c020        	excw

	return 0;
}
  907f0a:	d10f      	retw.n

00907f0c <ath_pll_reset_ones$isra$9>:
	}

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &val[0], datalen);
}

static void ath_pll_reset_ones(struct ath_hal *ah)
  907f0c:	6c1004        	entry	a1, 32
{
	static uint8_t reset_pll = 0;

	if(reset_pll == 0) {
  907f0f:	1969fa        	l32r	a9, 8e26f8 <athos_indirection_table_install+0x1184>
  907f12:	289000        	l8ui	a8, a9, 0
  907f15:	ce87      	bnez.n	a8, 907f40 <ath_pll_reset_ones$isra$9+0x34>
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  907f17:	1869fb        	l32r	a8, 8e2704 <athos_indirection_table_install+0x1190>
			 ioread32_mac(0x786c) & (~0x6000000));

		iowrite32(MAGPIE_REG_RST_PWDN_CTRL_ADDR, 0x20);

#elif defined(PROJECT_MAGPIE) && !defined (FPGA)
		iowrite32_mac(0x7890,
  907f1a:	1a69fc        	l32r	a10, 8e270c <athos_indirection_table_install+0x1198>
  907f1d:	0c0200        	memw
  907f20:	8b80      	l32i.n	a11, a8, 0
  907f22:	0aba02        	or	a10, a11, a10
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  907f25:	0c0200        	memw
  907f28:	9a80      	s32i.n	a10, a8, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  907f2a:	0c0200        	memw
  907f2d:	8b80      	l32i.n	a11, a8, 0
			 ioread32_mac(0x7890) | 0x1800000);
		iowrite32_mac(0x7890,
  907f2f:	1a69fd        	l32r	a10, 8e2724 <athos_indirection_table_install+0x11b0>
  907f32:	0aba01        	and	a10, a11, a10
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  907f35:	0c0200        	memw
  907f38:	9a80      	s32i.n	a10, a8, 0
			 ioread32_mac(0x7890) & (~0x1800000));
#endif
		reset_pll = 1;
  907f3a:	280a01        	movi	a8, 1
  907f3d:	289400        	s8i	a8, a9, 0
  907f40:	d10f      	retw.n
	...

00907f44 <tgt_ServiceConnect>:
				  HTC_ENDPOINT_ID eid,
				  A_UINT8 *pDataIn,
				  a_int32_t LengthIn,
				  A_UINT8 *pDataOut,
				  a_int32_t *pLengthOut)
{
  907f44:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)pService->ServiceCtx;
  907f47:	8826      	l32i.n	a8, a2, 24

	switch(pService->ServiceID) {
  907f49:	222108        	l16ui	a2, a2, 16
  907f4c:	c098      	movi.n	a9, 8
  907f4e:	222dff        	addmi	a2, a2, 0xffffff00
  907f51:	02024f        	extui	a2, a2, 0, 16
  907f54:	729341        	bltu	a9, a2, 907f99 <tgt_ServiceConnect+0x55>
  907f57:	1969fe        	l32r	a9, 8e2750 <athos_indirection_table_install+0x11dc>
  907f5a:	09220a        	addx4	a2, a2, a9
  907f5d:	8220      	l32i.n	a2, a2, 0
  907f5f:	0a2000        	jx	a2
  907f62:	002386        	excw
	case WMI_CONTROL_SVC:
		sc->wmi_command_ep= eid;
  907f65:	3c6000        	excw
		break;
  907f68:	462386        	excw
	case WMI_BEACON_SVC:
		sc->beacon_ep= eid;
  907f6b:	3d6000        	excw
		break;
  907f6e:	402386        	excw
	case WMI_CAB_SVC:
		sc->cab_ep= eid;
  907f71:	3e6000        	excw
		break;
  907f74:	3a2386        	excw
	case WMI_UAPSD_SVC:
		sc->uapsd_ep= eid;
  907f77:	3f6000        	excw
		break;
  907f7a:	342386        	excw
	case WMI_MGMT_SVC:
		sc->mgmt_ep= eid;
  907f7d:	406000        	excw
		break;
  907f80:	2e2386        	excw
	case WMI_DATA_VO_SVC:
		sc->data_VO_ep = eid;
  907f83:	416000        	excw
		break;
  907f86:	282386        	excw
	case WMI_DATA_VI_SVC:
		sc->data_VI_ep = eid;
  907f89:	426000        	excw
		break;
  907f8c:	222386        	excw
	case WMI_DATA_BE_SVC:
		sc->data_BE_ep = eid;
  907f8f:	436000        	excw
		break;
  907f92:	1c2386        	l32r	a12, 8d0dac <_bss_end+0x3bde9c>
	case WMI_DATA_BK_SVC:
		sc->data_BK_ep = eid;
  907f95:	446000        	excw
		break;
  907f98:	161269        	l32r	a6, 8cc93c <_bss_end+0x3b9a2c>
	default:
		adf_os_assert(0);
  907f9b:	151a69        	l32r	a5, 8ce940 <_bss_end+0x3bba30>
  907f9e:	f6          	.byte 0xf6
  907f9f:	222212        	l32i	a2, a2, 72
  907fa2:	1b69ff        	l32r	a11, 8e27a0 <athos_indirection_table_install+0x122c>
  907fa5:	0b2000        	callx8	a2
  907fa8:	12697a        	l32r	a2, 8e2590 <athos_indirection_table_install+0x101c>
  907fab:	0c0200        	memw
  907fae:	8220      	l32i.n	a2, a2, 0
	}

	return HTC_SERVICE_SUCCESS;
}
  907fb0:	c020      	movi.n	a2, 0
  907fb2:	d10f      	retw.n

00907fb4 <ath_reg_read_filter>:

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static a_int32_t ath_reg_read_filter(struct ath_hal *ah, a_int32_t addr)
{
  907fb4:	6c1004        	entry	a1, 32
	if ((addr & 0xffffe000) == 0x2000) {
  907fb7:	196a00        	l32r	a9, 8e27b8 <athos_indirection_table_install+0x1244>
  907fba:	186a01        	l32r	a8, 8e27c0 <athos_indirection_table_install+0x124c>
  907fbd:	093901        	and	a9, a3, a9
  907fc0:	789935        	bne	a9, a8, 907ff9 <ath_reg_read_filter+0x45>
		/* SEEPROM registers */
		ioread32_mac(addr);
  907fc3:	186a02        	l32r	a8, 8e27cc <athos_indirection_table_install+0x1258>
		if (!ath_hal_wait(ah, 0x407c, 0x00030000, 0))
  907fc6:	1b6a03        	l32r	a11, 8e27d4 <athos_indirection_table_install+0x1260>

static a_int32_t ath_reg_read_filter(struct ath_hal *ah, a_int32_t addr)
{
	if ((addr & 0xffffe000) == 0x2000) {
		/* SEEPROM registers */
		ioread32_mac(addr);
  907fc9:	a838      	add.n	a8, a3, a8
		if (!ath_hal_wait(ah, 0x407c, 0x00030000, 0))
  907fcb:	1c6a04        	l32r	a12, 8e27dc <athos_indirection_table_install+0x1268>
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  907fce:	0c0200        	memw
  907fd1:	8880      	l32i.n	a8, a8, 0
  907fd3:	022a02        	or	a10, a2, a2
  907fd6:	2d0a00        	movi	a13, 0
  907fd9:	580b9c        	call8	90ae4c <ath_hal_wait>
  907fdc:	ccac      	bnez.n	a10, 907fec <ath_reg_read_filter+0x38>
			adf_os_print("SEEPROM Read fail: 0x%08x\n", addr);
  907fde:	126915        	l32r	a2, 8e2434 <athos_indirection_table_install+0xec0>
  907fe1:	1a6a05        	l32r	a10, 8e27f8 <athos_indirection_table_install+0x1284>
  907fe4:	222212        	l32i	a2, a2, 72
  907fe7:	db30      	mov.n	a11, a3
  907fe9:	0b2000        	callx8	a2
  907fec:	126a06        	l32r	a2, 8e2804 <athos_indirection_table_install+0x1290>
  907fef:	0c0200        	memw
  907ff2:	8220      	l32i.n	a2, a2, 0

		return ioread32_mac(0x407c) & 0x0000ffff;
  907ff4:	02024f        	extui	a2, a2, 0, 16
  907ff7:	d10f      	retw.n
	} else if (addr > 0xffff)
  907ff9:	126a07        	l32r	a2, 8e2818 <athos_indirection_table_install+0x12a4>
  907ffc:	732a04        	bge	a2, a3, 908004 <ath_reg_read_filter+0x50>
  907fff:	600006        	j	908009 <ath_reg_read_filter+0x55>
  908002:	000012        	srai	a0, a0, 0
		/* SoC registers */
		return ioread32(addr);
	else
		/* MAC registers */
		return ioread32_mac(addr);
  908005:	6a02a2        	blti	a0, 2, 907fab <tgt_ServiceConnect+0x67>
  908008:	330c02        	excw
  90800b:	008230        	excw
}
  90800e:	d10f      	retw.n

00908010 <tgt_HTCSendCompleteHandler>:
		asf_tailq_insert_tail(&sc->sc_rxdesc, ds_tmp, ds_list);
	}
}

static void tgt_HTCSendCompleteHandler(HTC_ENDPOINT_ID Endpt, adf_nbuf_t buf, void *ServiceCtx)
{
  908010:	6c1006        	entry	a1, 48
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)ServiceCtx;

	if (Endpt == RX_ENDPOINT_ID) {
  908013:	682302        	beqi	a2, 3, 908019 <tgt_HTCSendCompleteHandler+0x9>
  908016:	600124        	j	90813e <tgt_HTCSendCompleteHandler+0x12e>
		sc->sc_rx_stats.ast_rx_done++;
  908019:	22427e        	l32i	a2, a4, 0x1f8
}

static inline void
adf_nbuf_split_to_frag(adf_nbuf_t buf, adf_nbuf_queue_t *qhead)
{
    return __adf_nbuf_split_to_frag(buf, qhead);
  90801c:	da30      	mov.n	a10, a3
  90801e:	b122      	addi.n	a2, a2, 1
  908020:	22467e        	s32i	a2, a4, 0x1f8
  908023:	db10      	mov.n	a11, a1
  908025:	5bfad6        	call8	906b80 <__adf_nbuf_split_to_frag>
	struct ath_rx_desc *ds;
	adf_nbuf_t buf_tmp;
	adf_nbuf_queue_t nbuf_head;

	adf_nbuf_split_to_frag(buf, &nbuf_head);
	ds = asf_tailq_first(&sc->sc_rxdesc_idle);
  908028:	2242d7        	l32i	a2, a4, 0x35c

		if (buf_tmp == NULL) {
			break;
		}

		BUF_Pool_free_buf(sc->pool_handle, POOL_ID_WLAN_RX_BUF, buf_tmp);
  90802b:	136915        	l32r	a3, 8e2480 <athos_indirection_table_install+0xf0c>
  90802e:	600109        	j	90813b <tgt_HTCSendCompleteHandler+0x12b>
 * @return The head buf in the buf queue.
 */
static inline adf_nbuf_t
adf_nbuf_queue_remove(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_remove(head);
  908031:	da10      	mov.n	a10, a1
  908033:	5bfa81        	call8	906a38 <__adf_nbuf_queue_remove>
  908036:	dca0      	mov.n	a12, a10

	while (ds) {
		struct ath_rx_desc *ds_tmp;
		buf_tmp = adf_nbuf_queue_remove(&nbuf_head);

		if (buf_tmp == NULL) {
  908038:	64a102        	beqz	a10, 90813e <tgt_HTCSendCompleteHandler+0x12e>
			break;
		}

		BUF_Pool_free_buf(sc->pool_handle, POOL_ID_WLAN_RX_BUF, buf_tmp);
  90803b:	28329e        	l32i	a8, a3, 0x278
  90803e:	8a40      	l32i.n	a10, a4, 0
  908040:	c0b3      	movi.n	a11, 3
  908042:	0b8000        	callx8	a8

		ds_tmp = ds;
		ds = asf_tailq_next(ds, ds_list);
  908045:	29204c        	l8ui	a9, a2, 76
  908048:	28204d        	l8ui	a8, a2, 77
  90804b:	25204e        	l8ui	a5, a2, 78
  90804e:	089910        	slli	a9, a9, 24
  908051:	008811        	slli	a8, a8, 16
  908054:	098802        	or	a8, a8, a9
  908057:	085511        	slli	a5, a5, 8
  90805a:	085502        	or	a5, a5, a8
  90805d:	28204f        	l8ui	a8, a2, 79

		ath_rxdesc_init(sc, ds_tmp);
  908060:	044a02        	or	a10, a4, a4
  908063:	022b02        	or	a11, a2, a2
		}

		BUF_Pool_free_buf(sc->pool_handle, POOL_ID_WLAN_RX_BUF, buf_tmp);

		ds_tmp = ds;
		ds = asf_tailq_next(ds, ds_list);
  908066:	058502        	or	a5, a8, a5

		ath_rxdesc_init(sc, ds_tmp);
  908069:	5bff43        	call8	907d78 <ath_rxdesc_init>

		asf_tailq_remove(&sc->sc_rxdesc_idle, ds_tmp, ds_list);
  90806c:	2a204c        	l8ui	a10, a2, 76
  90806f:	29204d        	l8ui	a9, a2, 77
  908072:	28204e        	l8ui	a8, a2, 78
  908075:	08aa10        	slli	a10, a10, 24
  908078:	009911        	slli	a9, a9, 16
  90807b:	0a9902        	or	a9, a9, a10
  90807e:	088811        	slli	a8, a8, 8
  908081:	098802        	or	a8, a8, a9
  908084:	29204f        	l8ui	a9, a2, 79
  908087:	2a2051        	l8ui	a10, a2, 81
  90808a:	089802        	or	a8, a9, a8
  90808d:	292050        	l8ui	a9, a2, 80
  908090:	00aa11        	slli	a10, a10, 16
  908093:	089910        	slli	a9, a9, 24
  908096:	09aa02        	or	a10, a10, a9
  908099:	292052        	l8ui	a9, a2, 82
  90809c:	089911        	slli	a9, a9, 8
  90809f:	0a9902        	or	a9, a9, a10
  9080a2:	c98e      	beqz.n	a8, 9080c4 <tgt_HTCSendCompleteHandler+0xb4>
  9080a4:	2a2053        	l8ui	a10, a2, 83
  9080a7:	09a902        	or	a9, a10, a9
  9080aa:	098a57        	extui	a10, a9, 24, 8
  9080ad:	2a8450        	s8i	a10, a8, 80
  9080b0:	090a57        	extui	a10, a9, 16, 8
  9080b3:	2a8451        	s8i	a10, a8, 81
  9080b6:	098a47        	extui	a10, a9, 8, 8
  9080b9:	2a8452        	s8i	a10, a8, 82
  9080bc:	298453        	s8i	a9, a8, 83
  9080bf:	60000a        	j	9080cd <tgt_HTCSendCompleteHandler+0xbd>
  9080c2:	000028        	mull	a0, a0, a0
  9080c5:	205309        	excw
  9080c8:	8902      	l32i.n	a9, a0, 8
  9080ca:	2946d8        	s32i	a9, a4, 0x360
  9080cd:	2a2050        	l8ui	a10, a2, 80
  9080d0:	292051        	l8ui	a9, a2, 81
  9080d3:	282052        	l8ui	a8, a2, 82
  9080d6:	08aa10        	slli	a10, a10, 24
  9080d9:	009911        	slli	a9, a9, 16
  9080dc:	0a9902        	or	a9, a9, a10
  9080df:	088811        	slli	a8, a8, 8
  9080e2:	098802        	or	a8, a8, a9
  9080e5:	292053        	l8ui	a9, a2, 83
  9080e8:	2b204c        	l8ui	a11, a2, 76
  9080eb:	2a204d        	l8ui	a10, a2, 77
  9080ee:	089802        	or	a8, a9, a8
  9080f1:	29204e        	l8ui	a9, a2, 78
  9080f4:	08bb10        	slli	a11, a11, 24
  9080f7:	00aa11        	slli	a10, a10, 16
  9080fa:	0baa02        	or	a10, a10, a11
  9080fd:	089911        	slli	a9, a9, 8
  908100:	0a9902        	or	a9, a9, a10
  908103:	2a204f        	l8ui	a10, a2, 79
  908106:	09a902        	or	a9, a10, a9
  908109:	9980      	s32i.n	a9, a8, 0
		asf_tailq_insert_tail(&sc->sc_rxdesc, ds_tmp, ds_list);
  90810b:	c080      	movi.n	a8, 0
  90810d:	28244c        	s8i	a8, a2, 76
  908110:	28244d        	s8i	a8, a2, 77
  908113:	28244e        	s8i	a8, a2, 78
  908116:	28244f        	s8i	a8, a2, 79
  908119:	2842da        	l32i	a8, a4, 0x368
  90811c:	088957        	extui	a9, a8, 24, 8
  90811f:	292450        	s8i	a9, a2, 80
  908122:	080957        	extui	a9, a8, 16, 8
  908125:	292451        	s8i	a9, a2, 81
  908128:	088947        	extui	a9, a8, 8, 8
  90812b:	292452        	s8i	a9, a2, 82
  90812e:	282453        	s8i	a8, a2, 83
  908131:	9280      	s32i.n	a2, a8, 0
  908133:	222c4c        	addi	a2, a2, 76
  908136:	2246da        	s32i	a2, a4, 0x368
		}

		BUF_Pool_free_buf(sc->pool_handle, POOL_ID_WLAN_RX_BUF, buf_tmp);

		ds_tmp = ds;
		ds = asf_tailq_next(ds, ds_list);
  908139:	d250      	mov.n	a2, a5
	adf_nbuf_queue_t nbuf_head;

	adf_nbuf_split_to_frag(buf, &nbuf_head);
	ds = asf_tailq_first(&sc->sc_rxdesc_idle);

	while (ds) {
  90813b:	652ef2        	bnez	a2, 908031 <tgt_HTCSendCompleteHandler+0x21>
  90813e:	d10f      	retw.n

00908140 <ath_desc_free>:

#undef DS2PHYS
}

static void ath_desc_free(struct ath_softc_tgt *sc)
{
  908140:	6c1004        	entry	a1, 32
	asf_tailq_insert_tail(&sc->sc_txbuf, sc->sc_txbuf_held, bf_list);
  908143:	2822dc        	l32i	a8, a2, 0x370
  908146:	2922f1        	l32i	a9, a2, 0x3c4
  908149:	c0d0      	movi.n	a13, 0
  90814b:	9d89      	s32i.n	a13, a8, 36
  90814d:	998a      	s32i.n	a9, a8, 40
  90814f:	9890      	s32i.n	a8, a9, 0
  908151:	2822dc        	l32i	a8, a2, 0x370

	sc->sc_txbuf_held = NULL;
  908154:	2d26dc        	s32i	a13, a2, 0x370
#undef DS2PHYS
}

static void ath_desc_free(struct ath_softc_tgt *sc)
{
	asf_tailq_insert_tail(&sc->sc_txbuf, sc->sc_txbuf_held, bf_list);
  908157:	288c24        	addi	a8, a8, 36
  90815a:	2826f1        	s32i	a8, a2, 0x3c4

	sc->sc_txbuf_held = NULL;

	if (sc->sc_txdma.dd_desc_len != 0)
  90815d:	2822e7        	l32i	a8, a2, 0x39c
  908160:	7d8110        	beq	a8, a13, 908174 <ath_desc_free+0x34>
		ath_descdma_cleanup(sc, &sc->sc_txdma, (ath_bufhead *)&sc->sc_txbuf,
  908163:	2b3a8c        	movi	a11, 0x38c
  908166:	2c3ac0        	movi	a12, 0x3c0
  908169:	da20      	mov.n	a10, a2
  90816b:	0b2b08        	add	a11, a2, a11
  90816e:	0c2c08        	add	a12, a2, a12
  908171:	5bfed2        	call8	907cbc <ath_descdma_cleanup>
				    ADF_OS_DMA_TO_DEVICE);
	if (sc->sc_rxdma.dd_desc_len != 0)
  908174:	2822e1        	l32i	a8, a2, 0x384
  908177:	c88f      	beqz.n	a8, 90818a <ath_desc_free+0x4a>
		ath_descdma_cleanup(sc, &sc->sc_rxdma, (ath_bufhead *)&sc->sc_rxbuf,
  908179:	2b3a74        	movi	a11, 0x374
  90817c:	2c3a54        	movi	a12, 0x354
  90817f:	da20      	mov.n	a10, a2
  908181:	ab2b      	add.n	a11, a2, a11
  908183:	ac2c      	add.n	a12, a2, a12
  908185:	c0d1      	movi.n	a13, 1
  908187:	5bfecd        	call8	907cbc <ath_descdma_cleanup>
  90818a:	d10f      	retw.n

0090818c <ath_descdma_setup$constprop$22>:

/***********************/
/* Descriptor Handling */
/***********************/

static a_int32_t ath_descdma_setup(struct ath_softc_tgt *sc,
  90818c:	6c1006        	entry	a1, 48
  90818f:	9210      	s32i.n	a2, a1, 0
	a_int32_t i, bsize, error;
	a_uint8_t *bf_addr;
	a_uint8_t *ds_addr;

	dd->dd_name = name;
	dd->dd_desc_len = descSize * nbuf * ndesc;
  908191:	821c      	l32i.n	a2, a1, 48
adf_os_dmamem_alloc(adf_os_device_t     osdev, 
                    adf_os_size_t       size, 
                    a_bool_t            coherent, 
                    adf_os_dma_map_t   *dmap)
{
    return __adf_os_dmamem_alloc(osdev, size, coherent, dmap);
  908193:	8810      	l32i.n	a8, a1, 0
  908195:	062b28        	mull	a11, a2, a6
  908198:	2a8246        	l32i	a10, a8, 0x118
	struct ath_buf *bf;
	a_int32_t i, bsize, error;
	a_uint8_t *bf_addr;
	a_uint8_t *ds_addr;

	dd->dd_name = name;
  90819b:	9530      	s32i.n	a5, a3, 0
	dd->dd_desc_len = descSize * nbuf * ndesc;
  90819d:	9b34      	s32i.n	a11, a3, 16
  90819f:	c0c1      	movi.n	a12, 1
  9081a1:	b83d      	addi.n	a13, a3, 8

/***********************/
/* Descriptor Handling */
/***********************/

static a_int32_t ath_descdma_setup(struct ath_softc_tgt *sc,
  9081a3:	271601        	s32i	a7, a1, 4
  9081a6:	580ad5        	call8	90acfc <__adf_os_dmamem_alloc>
 * @return the (bus) address
 */
static inline adf_os_dma_addr_t
adf_os_dmamem_map2addr(adf_os_dma_map_t dmap)
{
    return(__adf_os_dmamem_map2addr(dmap));
  9081a9:	8532      	l32i.n	a5, a3, 8
	a_uint8_t *ds_addr;

	dd->dd_name = name;
	dd->dd_desc_len = descSize * nbuf * ndesc;

	dd->dd_desc = adf_os_dmamem_alloc(sc->sc_dev,
  9081ab:	9a31      	s32i.n	a10, a3, 4
				  dd->dd_desc_len, 1, &dd->dd_desc_dmamap);
	dd->dd_desc_paddr = adf_os_dmamem_map2addr(dd->dd_desc_dmamap);
  9081ad:	8551      	l32i.n	a5, a5, 4
  9081af:	9533      	s32i.n	a5, a3, 12
adf_os_dmamem_alloc(adf_os_device_t     osdev, 
                    adf_os_size_t       size, 
                    a_bool_t            coherent, 
                    adf_os_dma_map_t   *dmap)
{
    return __adf_os_dmamem_alloc(osdev, size, coherent, dmap);
  9081b1:	d2a0      	mov.n	a2, a10
	if (dd->dd_desc == NULL) {
  9081b3:	64a05f        	beqz	a10, 908216 <ath_descdma_setup$constprop$22+0x8a>
		error = -ENOMEM;
		goto fail;
	}
	ds = dd->dd_desc;

	bsize = bfSize * nbuf;
  9081b6:	8811      	l32i.n	a8, a1, 4
  9081b8:	068728        	mull	a7, a8, a6
 * @return Buffer pointer or NULL if there's not enough memory.
 */
static inline void *
adf_os_mem_alloc(adf_os_size_t size)
{
    return __adf_os_mem_alloc(size);
  9081bb:	da70      	mov.n	a10, a7
  9081bd:	5bfe67        	call8	907b5c <__adf_os_mem_alloc>
  9081c0:	d5a0      	mov.n	a5, a10
	bf = adf_os_mem_alloc(bsize);
	if (bf == NULL) {
  9081c2:	64a050        	beqz	a10, 908216 <ath_descdma_setup$constprop$22+0x8a>
 * @param[in] size  buffer size
 */
static inline void
adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
{
    __adf_os_mem_set(buf, b, size);
  9081c5:	dc70      	mov.n	a12, a7
  9081c7:	c0b0      	movi.n	a11, 0
  9081c9:	5bfe6e        	call8	907b84 <__adf_os_mem_set>
	dd->dd_bufptr = bf;

	bf_addr = (a_uint8_t *)bf;
	ds_addr = (a_uint8_t *)ds;

	asf_tailq_init(head);
  9081cc:	c090      	movi.n	a9, 0
	if (bf == NULL) {
		error = -ENOMEM;
		goto fail2;
	}
	adf_os_mem_set(bf, 0, bsize);
	dd->dd_bufptr = bf;
  9081ce:	9535      	s32i.n	a5, a3, 20

	bf_addr = (a_uint8_t *)bf;
	ds_addr = (a_uint8_t *)ds;

	asf_tailq_init(head);
  9081d0:	9940      	s32i.n	a9, a4, 0
  9081d2:	9441      	s32i.n	a4, a4, 4

	for (i = 0; i < nbuf; i++) {
  9081d4:	d790      	mov.n	a7, a9
  9081d6:	600035        	j	90820f <ath_descdma_setup$constprop$22+0x83>
  9081d9:	008810        	slli	a8, a8, 32
 */
static inline a_status_t
adf_nbuf_dmamap_create(adf_os_device_t osdev,
                       adf_os_dma_map_t *dmap)
{
    return (__adf_nbuf_dmamap_create(osdev, dmap));
  9081dc:	db50      	mov.n	a11, a5
  9081de:	2a8246        	l32i	a10, a8, 0x118
  9081e1:	5bfa1f        	call8	906a60 <__adf_nbuf_dmamap_create>
  9081e4:	dba0      	mov.n	a11, a10
		a_int32_t j;

		if (adf_nbuf_dmamap_create( sc->sc_dev, &bf->bf_dmamap) != A_STATUS_OK) {
  9081e6:	ceac      	bnez.n	a10, 908216 <ath_descdma_setup$constprop$22+0x8a>
			goto fail2;
		}

		bf->bf_desc = bf->bf_descarr = bf->bf_lastds = ds;
  9081e8:	925c      	s32i.n	a2, a5, 48
  9081ea:	925e      	s32i.n	a2, a5, 56
  9081ec:	925d      	s32i.n	a2, a5, 52
 * @param[in] head  buf queue head
 */
static inline void
adf_nbuf_queue_init(adf_nbuf_queue_t *head)
{
    __adf_nbuf_queue_init(head);
  9081ee:	2a5c14        	addi	a10, a5, 20
  9081f1:	9b12      	s32i.n	a11, a1, 8
  9081f3:	5bfab1        	call8	906cb8 <__adf_nbuf_queue_init>
			ATH_BUF_SET_DESC_PHY_ADDR_WITH_IDX(bf, j, (ds_addr + (j*descSize)));

		ATH_BUF_SET_DESC_PHY_ADDR(bf, ATH_BUF_GET_DESC_PHY_ADDR_WITH_IDX(bf, 0));

		adf_nbuf_queue_init(&bf->bf_skbhead);
		asf_tailq_insert_tail(head, bf, bf_list);
  9081f6:	8a41      	l32i.n	a10, a4, 4
  9081f8:	8b12      	l32i.n	a11, a1, 8

		bf_addr += bfSize;
  9081fa:	8811      	l32i.n	a8, a1, 4
			ATH_BUF_SET_DESC_PHY_ADDR_WITH_IDX(bf, j, (ds_addr + (j*descSize)));

		ATH_BUF_SET_DESC_PHY_ADDR(bf, ATH_BUF_GET_DESC_PHY_ADDR_WITH_IDX(bf, 0));

		adf_nbuf_queue_init(&bf->bf_skbhead);
		asf_tailq_insert_tail(head, bf, bf_list);
  9081fc:	9a5a      	s32i.n	a10, a5, 40
  9081fe:	9b59      	s32i.n	a11, a5, 36
  908200:	95a0      	s32i.n	a5, a10, 0
  908202:	2a5c24        	addi	a10, a5, 36

		bf_addr += bfSize;
  908205:	a855      	add.n	a5, a5, a8
		ds_addr += (ndesc * descSize);
  908207:	881c      	l32i.n	a8, a1, 48
			ATH_BUF_SET_DESC_PHY_ADDR_WITH_IDX(bf, j, (ds_addr + (j*descSize)));

		ATH_BUF_SET_DESC_PHY_ADDR(bf, ATH_BUF_GET_DESC_PHY_ADDR_WITH_IDX(bf, 0));

		adf_nbuf_queue_init(&bf->bf_skbhead);
		asf_tailq_insert_tail(head, bf, bf_list);
  908209:	9a41      	s32i.n	a10, a4, 4

		bf_addr += bfSize;
		ds_addr += (ndesc * descSize);
  90820b:	a822      	add.n	a2, a2, a8
	bf_addr = (a_uint8_t *)bf;
	ds_addr = (a_uint8_t *)ds;

	asf_tailq_init(head);

	for (i = 0; i < nbuf; i++) {
  90820d:	b177      	addi.n	a7, a7, 1
  90820f:	7672c7        	blt	a7, a6, 9081da <ath_descdma_setup$constprop$22+0x4e>
		ds_addr += (ndesc * descSize);
		bf = (struct ath_buf *)bf_addr;
		ds = (struct ath_desc *)ds_addr;
	}

	return 0;
  908212:	c020      	movi.n	a2, 0
  908214:	d10f      	retw.n
  908216:	da30      	mov.n	a10, a3
  908218:	c1c8      	movi.n	a12, 24
  90821a:	2b0a00        	movi	a11, 0
  90821d:	5bfe59        	call8	907b84 <__adf_os_mem_set>
fail2:
	adf_os_dmamem_free(sc->sc_dev, dd->dd_desc_len,
			   1, dd->dd_desc, dd->dd_desc_dmamap);
fail:
	adf_os_mem_set(dd, 0, sizeof(*dd));
	adf_os_assert(0);
  908220:	126915        	l32r	a2, 8e2674 <athos_indirection_table_install+0x1100>
  908223:	1b6a08        	l32r	a11, 8e2a44 <athos_indirection_table_install+0x14d0>
  908226:	222212        	l32i	a2, a2, 72
  908229:	1a69f6        	l32r	a10, 8e2a04 <athos_indirection_table_install+0x1490>
  90822c:	0b2000        	callx8	a2
  90822f:	12697a        	l32r	a2, 8e2818 <athos_indirection_table_install+0x12a4>
  908232:	0c0200        	memw
  908235:	8220      	l32i.n	a2, a2, 0
	return error;
  908237:	c021      	movi.n	a2, 1

#undef DS2PHYS
}
  908239:	d10f      	retw.n
	...

0090823c <tgt_HTCRecvMessageHandler>:
}

static void tgt_HTCRecvMessageHandler(HTC_ENDPOINT_ID EndPt,
				      adf_nbuf_t hdr_buf, adf_nbuf_t buf,
				      void *ServiceCtx)
{
  90823c:	6c1006        	entry	a1, 48
	a_uint32_t len;
	ath_data_hdr_t *dh;
	struct ath_node_target *an;
	struct ath_atx_tid *tid;

	if (!hdr_buf) {
  90823f:	cd32      	bnez.n	a3, 908255 <tgt_HTCRecvMessageHandler+0x19>
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  908241:	da40      	mov.n	a10, a4
  908243:	b41b      	addi.n	a11, a1, 4
  908245:	dc10      	mov.n	a12, a1
  908247:	5bfa96        	call8	906ca0 <__adf_nbuf_peek_header>
 *         or NULL if there is not sufficient data to pull.
 */
static inline a_uint8_t *
adf_nbuf_pull_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_pull_head(buf, size);
  90824a:	da40      	mov.n	a10, a4
  90824c:	c0bc      	movi.n	a11, 12
  90824e:	5bf9c5        	call8	906964 <__adf_nbuf_pull_head>
  908251:	600009        	j	90825e <tgt_HTCRecvMessageHandler+0x22>
  908254:	00da30        	excw
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  908257:	b41b      	addi.n	a11, a1, 4
  908259:	dc10      	mov.n	a12, a1
  90825b:	5bfa91        	call8	906ca0 <__adf_nbuf_peek_header>
		adf_nbuf_pull_head(buf, sizeof(ath_data_hdr_t));
	} else {
		adf_nbuf_peek_header(hdr_buf, &data, &len);
	}

	adf_os_assert(len >= sizeof(ath_data_hdr_t));
  90825e:	8310      	l32i.n	a3, a1, 0
  908260:	c06b      	movi.n	a6, 11
  908262:	736316        	bltu	a6, a3, 90827c <tgt_HTCRecvMessageHandler+0x40>
  908265:	136915        	l32r	a3, 8e26bc <athos_indirection_table_install+0x1148>
  908268:	1a69f6        	l32r	a10, 8e2a40 <athos_indirection_table_install+0x14cc>
  90826b:	233212        	l32i	a3, a3, 72
  90826e:	1b6a09        	l32r	a11, 8e2a94 <athos_indirection_table_install+0x1520>
  908271:	0b3000        	callx8	a3
  908274:	13697a        	l32r	a3, 8e285c <athos_indirection_table_install+0x12e8>
  908277:	0c0200        	memw
  90827a:	8330      	l32i.n	a3, a3, 0
	dh = (ath_data_hdr_t *)data;
  90827c:	8311      	l32i.n	a3, a1, 4
	an = &sc->sc_sta[dh->ni_index];
	tid = ATH_AN_2_TID(an, dh->tidno);

	sc->sc_tx_stats.tx_tgt++;

	bf = ath_tgt_tx_prepare(sc, buf, dh);
  90827e:	db40      	mov.n	a11, a4
	}

	adf_os_assert(len >= sizeof(ath_data_hdr_t));
	dh = (ath_data_hdr_t *)data;

	an = &sc->sc_sta[dh->ni_index];
  908280:	283001        	l8ui	a8, a3, 1
	tid = ATH_AN_2_TID(an, dh->tidno);
  908283:	293003        	l8ui	a9, a3, 3
	}

	adf_os_assert(len >= sizeof(ath_data_hdr_t));
	dh = (ath_data_hdr_t *)data;

	an = &sc->sc_sta[dh->ni_index];
  908286:	0a8611        	slli	a6, a8, 6
  908289:	a866      	add.n	a6, a6, a8
  90828b:	086809        	addx2	a8, a6, a8
  90828e:	265a30        	movi	a6, 0x530
  908291:	06880a        	addx4	a8, a8, a6
	tid = ATH_AN_2_TID(an, dh->tidno);
  908294:	0c9611        	slli	a6, a9, 4
	}

	adf_os_assert(len >= sizeof(ath_data_hdr_t));
	dh = (ath_data_hdr_t *)data;

	an = &sc->sc_sta[dh->ni_index];
  908297:	a858      	add.n	a8, a5, a8
	tid = ATH_AN_2_TID(an, dh->tidno);
  908299:	09660c        	sub	a6, a6, a9
  90829c:	08660a        	addx4	a6, a6, a8

	sc->sc_tx_stats.tx_tgt++;
  90829f:	28525b        	l32i	a8, a5, 0x16c

	bf = ath_tgt_tx_prepare(sc, buf, dh);
  9082a2:	da50      	mov.n	a10, a5
	dh = (ath_data_hdr_t *)data;

	an = &sc->sc_sta[dh->ni_index];
	tid = ATH_AN_2_TID(an, dh->tidno);

	sc->sc_tx_stats.tx_tgt++;
  9082a4:	288c01        	addi	a8, a8, 1
  9082a7:	28565b        	s32i	a8, a5, 0x16c

	bf = ath_tgt_tx_prepare(sc, buf, dh);
  9082aa:	033c02        	or	a12, a3, a3
  9082ad:	581635        	call8	90db84 <ath_tgt_tx_prepare>

	adf_os_assert(len >= sizeof(ath_data_hdr_t));
	dh = (ath_data_hdr_t *)data;

	an = &sc->sc_sta[dh->ni_index];
	tid = ATH_AN_2_TID(an, dh->tidno);
  9082b0:	266c2c        	addi	a6, a6, 44

	sc->sc_tx_stats.tx_tgt++;

	bf = ath_tgt_tx_prepare(sc, buf, dh);
  9082b3:	dba0      	mov.n	a11, a10
	if (!bf) {
  9082b5:	ccaf      	bnez.n	a10, 9082c8 <tgt_HTCRecvMessageHandler+0x8c>
		ath_free_tx_skb(sc->tgt_htc_handle,EndPt,buf);
  9082b7:	136915        	l32r	a3, 8e270c <athos_indirection_table_install+0x1198>
  9082ba:	8a52      	l32i.n	a10, a5, 8
  9082bc:	233282        	l32i	a3, a3, 0x208
  9082bf:	db20      	mov.n	a11, a2
  9082c1:	dc40      	mov.n	a12, a4
  9082c3:	0b3000        	callx8	a3
  9082c6:	d10f      	retw.n
		return;
	}

	bf->bf_endpt = EndPt;
  9082c8:	22a623        	s32i	a2, a10, 140
	bf->bf_cookie = dh->cookie;
  9082cb:	22300a        	l8ui	a2, a3, 10
  9082ce:	22a492        	s8i	a2, a10, 146

	if (tid->flag & TID_AGGR_ENABLED)
  9082d1:	226036        	l8ui	a2, a6, 54
		ath_tgt_handle_aggr(sc, bf);
  9082d4:	da50      	mov.n	a10, a5
	}

	bf->bf_endpt = EndPt;
	bf->bf_cookie = dh->cookie;

	if (tid->flag & TID_AGGR_ENABLED)
  9082d6:	7e2707        	bbci	a2, 30, 9082e1 <tgt_HTCRecvMessageHandler+0xa5>
		ath_tgt_handle_aggr(sc, bf);
  9082d9:	581a8b        	call8	90ed08 <ath_tgt_handle_aggr>
  9082dc:	d10f      	retw.n
  9082de:	000000        	ill
	else
		ath_tgt_handle_normal(sc, bf);
  9082e1:	5817ec        	call8	90e294 <ath_tgt_handle_normal>
  9082e4:	d10f      	retw.n
	...

009082e8 <tgt_HTCRecv_cabhandler>:
}

static void tgt_HTCRecv_cabhandler(HTC_ENDPOINT_ID EndPt, adf_nbuf_t hdr_buf,
				   adf_nbuf_t buf, void *ServiceCtx)
{
  9082e8:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)ServiceCtx;
	struct ath_hal *ah = sc->sc_ah;
  9082eb:	285d05        	addmi	a8, a5, 0x500
  9082ee:	8a8b      	l32i.n	a10, a8, 44
	a_uint64_t tsf;
	a_uint32_t tmp;

#ifdef ATH_ENABLE_CABQ
	tsf = ah->ah_getTsf64(ah);
  9082f0:	28a21e        	l32i	a8, a10, 120
  9082f3:	0b8000        	callx8	a8
	tmp = tsf - sc->sc_swba_tsf;
  9082f6:	285d16        	addmi	a8, a5, 0x1600
  9082f9:	888d      	l32i.n	a8, a8, 52

	if ( tmp > ATH_CABQ_HANDLING_THRESHOLD ) {
  9082fb:	196a0a        	l32r	a9, 8e2b24 <athos_indirection_table_install+0x15b0>
	a_uint64_t tsf;
	a_uint32_t tmp;

#ifdef ATH_ENABLE_CABQ
	tsf = ah->ah_getTsf64(ah);
	tmp = tsf - sc->sc_swba_tsf;
  9082fe:	08bb0c        	sub	a11, a11, a8

	if ( tmp > ATH_CABQ_HANDLING_THRESHOLD ) {
  908301:	7b9b11        	bgeu	a9, a11, 908316 <tgt_HTCRecv_cabhandler+0x2e>
		HTC_ReturnBuffers(sc->tgt_htc_handle, EndPt, buf);
  908304:	136915        	l32r	a3, 8e2758 <athos_indirection_table_install+0x11e4>
  908307:	8a52      	l32i.n	a10, a5, 8
  908309:	233282        	l32i	a3, a3, 0x208
  90830c:	db20      	mov.n	a11, a2
  90830e:	044c02        	or	a12, a4, a4
  908311:	0b3000        	callx8	a3
  908314:	d10f      	retw.n
		return;
	}

	tgt_HTCRecvMessageHandler(EndPt, hdr_buf, buf, ServiceCtx);
  908316:	da20      	mov.n	a10, a2
  908318:	db30      	mov.n	a11, a3
  90831a:	dc40      	mov.n	a12, a4
  90831c:	dd50      	mov.n	a13, a5
  90831e:	5bffc7        	call8	90823c <tgt_HTCRecvMessageHandler>
  908321:	d10f      	retw.n
	...

00908324 <wmi_event>:

}

void wmi_event(wmi_handle_t handle, WMI_EVENT_ID evt_id,
	       void *buffer, a_int32_t Length)
{
  908324:	6c1004        	entry	a1, 32
	adf_nbuf_t netbuf = ADF_NBUF_NULL;
	a_uint8_t *pData;

	netbuf = WMI_AllocEvent(handle, WMI_EVT_CLASS_CMD_EVENT,
  908327:	176915        	l32r	a7, 8e277c <athos_indirection_table_install+0x1208>
  90832a:	da20      	mov.n	a10, a2
  90832c:	26728d        	l32i	a6, a7, 0x234
  90832f:	c0b0      	movi.n	a11, 0
  908331:	b45c      	addi.n	a12, a5, 4
  908333:	0b6000        	callx8	a6
  908336:	d6a0      	mov.n	a6, a10
				sizeof(WMI_CMD_HDR) + Length);

	if (netbuf == ADF_NBUF_NULL) {
  908338:	65a00a        	bnez	a10, 908346 <wmi_event+0x22>
		adf_os_print("Buf null\n");
  90833b:	227212        	l32i	a2, a7, 72
  90833e:	1a6a0b        	l32r	a10, 8e2b6c <athos_indirection_table_install+0x15f8>
  908341:	0b2000        	callx8	a2
  908344:	d10f      	retw.n
		return;
	}

	if (buffer != NULL && Length != 0 && Length < WMI_SVC_MAX_BUFFERED_EVENT_SIZE) {
  908346:	c952      	beqz.n	a5, 90835c <wmi_event+0x38>
  908348:	c940      	beqz.n	a4, 90835c <wmi_event+0x38>
  90834a:	270a63        	movi	a7, 99
  90834d:	75720b        	blt	a7, a5, 90835c <wmi_event+0x38>
 *         put, or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_put_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_put_tail(buf, size);
  908350:	db50      	mov.n	a11, a5
  908352:	5bfa37        	call8	906c30 <__adf_nbuf_put_tail>
 * @param[in] size    buffer size
 */
static inline void
adf_os_mem_copy(void *dst, const void *src, adf_os_size_t size)
{
    __adf_os_mem_copy(dst, src, size);
  908355:	db40      	mov.n	a11, a4
  908357:	dc50      	mov.n	a12, a5
  908359:	5bfe05        	call8	907b70 <__adf_os_mem_copy>
		pData = adf_nbuf_put_tail(netbuf, Length);
		adf_os_mem_copy(pData, buffer, Length);
	}

	WMI_SendEvent(handle, netbuf, evt_id, 0, Length);
  90835c:	146915        	l32r	a4, 8e27b0 <athos_indirection_table_install+0x123c>
  90835f:	da20      	mov.n	a10, a2
  908361:	24428e        	l32i	a4, a4, 0x238
  908364:	db60      	mov.n	a11, a6
  908366:	030c4f        	extui	a12, a3, 0, 16
  908369:	c0d0      	movi.n	a13, 0
  90836b:	de50      	mov.n	a14, a5
  90836d:	0b4000        	callx8	a4
  908370:	d10f      	retw.n
	...

00908374 <ath_fatal_tasklet>:

	return ADF_OS_IRQ_HANDLED;
}

static void ath_fatal_tasklet(TQUEUE_ARG data )
{
  908374:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)data;

	wmi_event(sc->tgt_wmi_handle, WMI_FATAL_EVENTID, NULL, 0);
  908377:	c0c0      	movi.n	a12, 0
  908379:	8a23      	l32i.n	a10, a2, 12
  90837b:	1b6a0c        	l32r	a11, 8e2bac <athos_indirection_table_install+0x1638>
  90837e:	0ccd02        	or	a13, a12, a12
  908381:	5bffe8        	call8	908324 <wmi_event>
  908384:	d10f      	retw.n
	...

00908388 <ath_bmiss_tasklet>:
}

static void ath_bmiss_tasklet(TQUEUE_ARG data)
{
  908388:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)data;

	wmi_event(sc->tgt_wmi_handle, WMI_BMISS_EVENTID, NULL, 0);
  90838b:	c0c0      	movi.n	a12, 0
  90838d:	8a23      	l32i.n	a10, a2, 12
  90838f:	1b6a0d        	l32r	a11, 8e2bc4 <athos_indirection_table_install+0x1650>
  908392:	0ccd02        	or	a13, a12, a12
  908395:	5bffe3        	call8	908324 <wmi_event>
  908398:	d10f      	retw.n
	...

0090839c <ath_intr>:
/**********************/
/* Interrupt Handling */
/**********************/

adf_os_irq_resp_t ath_intr(adf_drv_handle_t hdl)
{
  90839c:	6c100c        	entry	a1, 96
  90839f:	d320      	mov.n	a3, a2
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)hdl;
	struct ath_hal *ah = sc->sc_ah;
  9083a1:	222d05        	addmi	a2, a2, 0x500
  9083a4:	822b      	l32i.n	a2, a2, 44
  9083a6:	9218      	s32i.n	a2, a1, 32
	HAL_INT status;

	if (sc->sc_invalid)
  9083a8:	243249        	l32i	a4, a3, 0x124
  9083ab:	126a0e        	l32r	a2, 8e2be4 <athos_indirection_table_install+0x1670>
  9083ae:	024401        	and	a4, a4, a2
  9083b1:	644005        	beqz	a4, 9083ba <ath_intr+0x1e>
		return ADF_OS_IRQ_NONE;
  9083b4:	c020      	movi.n	a2, 0
  9083b6:	d10f      	retw.n
  9083b8:	000085        	excw

	if (!ah->ah_isInterruptPending(ah))
  9083bb:	182252        	l32r	a8, 8d0d04 <_bss_end+0x3bddf4>
  9083be:	26da50        	movi	a6, 0xfffffd50
  9083c1:	0b2000        	callx8	a2
  9083c4:	64afec        	beqz	a10, 9083b4 <ath_intr+0x18>
		return ADF_OS_IRQ_NONE;

	ah->ah_getPendingInterrupts(ah, &status);
  9083c7:	225227        	l32i	a2, a5, 156
  9083ca:	8a18      	l32i.n	a10, a1, 32
  9083cc:	2b1c18        	addi	a11, a1, 24
  9083cf:	0b2000        	callx8	a2

	status &= sc->sc_imask;
  9083d2:	8216      	l32i.n	a2, a1, 24
  9083d4:	2532c4        	l32i	a5, a3, 0x310
  9083d7:	025201        	and	a2, a5, a2
  9083da:	9216      	s32i.n	a2, a1, 24

	if (status & HAL_INT_FATAL) {
  9083dc:	712619        	bbci	a2, 1, 9083f9 <ath_intr+0x5d>
		ah->ah_setInterrupts(ah, 0);
  9083df:	8918      	l32i.n	a9, a1, 32
  9083e1:	db40      	mov.n	a11, a4
  9083e3:	229228        	l32i	a2, a9, 160
  9083e6:	099a02        	or	a10, a9, a9
  9083e9:	0b2000        	callx8	a2
 * @param[in] bh    bottom instance
 */
static inline void 
adf_os_sched_bh(adf_os_handle_t hdl, adf_os_bh_t *bh)
{
    __adf_os_sched_bh(hdl, bh);
  9083ec:	2a3a44        	movi	a10, 0x344
  9083ef:	aa3a      	add.n	a10, a3, a10
  9083f1:	5bfe5d        	call8	907d68 <__adf_os_sched_bh$isra$5>

		if (status & HAL_INT_CST)
			sc->sc_int_stats.ast_cst++;
	}

	return ADF_OS_IRQ_HANDLED;
  9083f4:	c021      	movi.n	a2, 1
  9083f6:	d10f      	retw.n
  9083f8:	007f26        	excw

	if (status & HAL_INT_FATAL) {
		ah->ah_setInterrupts(ah, 0);
		ATH_SCHEDULE_TQUEUE(sc->sc_dev, &sc->sc_fataltq);
	} else {
		if (status & HAL_INT_SWBA) {
  9083fb:	478418        	excw
			WMI_SWBA_EVENT swbaEvt;
			struct ath_txq *txq = ATH_TXQ(sc, 8);

			swbaEvt.tsf = ah->ah_getTsf64(ah);
  9083fe:	22421e        	l32i	a2, a4, 120
  908401:	da40      	mov.n	a10, a4
  908403:	0b2000        	callx8	a2
			swbaEvt.beaconPendingCount = ah->ah_numTxPending(ah, sc->sc_bhalq);
  908406:	8518      	l32i.n	a5, a1, 32
	} else {
		if (status & HAL_INT_SWBA) {
			WMI_SWBA_EVENT swbaEvt;
			struct ath_txq *txq = ATH_TXQ(sc, 8);

			swbaEvt.tsf = ah->ah_getTsf64(ah);
  908408:	9a13      	s32i.n	a10, a1, 12
  90840a:	9b14      	s32i.n	a11, a1, 16
			swbaEvt.beaconPendingCount = ah->ah_numTxPending(ah, sc->sc_bhalq);
  90840c:	243d01        	addmi	a4, a3, 0x100
  90840f:	825b      	l32i.n	a2, a5, 44
  908411:	2b401c        	l8ui	a11, a4, 28
  908414:	da50      	mov.n	a10, a5
  908416:	0b2000        	callx8	a2
  908419:	2a1414        	s8i	a10, a1, 20
			sc->sc_swba_tsf = ah->ah_getTsf64(ah);
  90841c:	22521e        	l32i	a2, a5, 120
  90841f:	2a1208        	l32i	a10, a1, 32
  908422:	0b2000        	callx8	a2
  908425:	223d16        	addmi	a2, a3, 0x1600
  908428:	9a2c      	s32i.n	a10, a2, 48
  90842a:	9b2d      	s32i.n	a11, a2, 52

			wmi_event(sc->tgt_wmi_handle,
  90842c:	8a33      	l32i.n	a10, a3, 12
  90842e:	1b6a0f        	l32r	a11, 8e2c6c <athos_indirection_table_install+0x16f8>
  908431:	bc1c      	addi.n	a12, a1, 12
  908433:	c0d9      	movi.n	a13, 9
  908435:	5bffbb        	call8	908324 <wmi_event>
	ah->ah_stopTxDma(ah, txq->axq_qnum);
}

static void owltgt_txq_drain(struct ath_softc_tgt *sc, struct ath_txq *txq)
{
	owltgt_tx_processq(sc, txq, OWL_TXQ_STOPPED);
  908438:	2b4acc        	movi	a11, 0x4cc
  90843b:	da30      	mov.n	a10, a3
  90843d:	ab3b      	add.n	a11, a3, a11
  90843f:	c0c1      	movi.n	a12, 1
  908441:	5819ee        	call8	90ebfc <owltgt_tx_processq>
				  sizeof(WMI_SWBA_EVENT));

			ath_tx_draintxq(sc, txq);
		}

		if (status & HAL_INT_RXORN)
  908444:	8216      	l32i.n	a2, a1, 24
  908446:	7a2707        	bbci	a2, 26, 908451 <ath_intr+0xb5>
			sc->sc_int_stats.ast_rxorn++;
  908449:	24324d        	l32i	a4, a3, 0x134
  90844c:	b144      	addi.n	a4, a4, 1
  90844e:	24364d        	s32i	a4, a3, 0x134

		if (status & HAL_INT_RXEOL)
  908451:	7b2708        	bbci	a2, 27, 90845d <ath_intr+0xc1>
			sc->sc_int_stats.ast_rxeol++;
  908454:	24324e        	l32i	a4, a3, 0x138
  908457:	244c01        	addi	a4, a4, 1
  90845a:	24364e        	s32i	a4, a3, 0x138

		if (status & (HAL_INT_RX | HAL_INT_RXEOL | HAL_INT_RXORN)) {
  90845d:	c341      	movi.n	a4, 49
  90845f:	742802        	bany	a2, a4, 908465 <ath_intr+0xc9>
  908462:	60062a        	j	908a90 <ath_intr+0x6f4>
			if (status & HAL_INT_RX)
  908465:	7f2707        	bbci	a2, 31, 908470 <ath_intr+0xd4>
				sc->sc_int_stats.ast_rx++;
  908468:	22324c        	l32i	a2, a3, 0x130
  90846b:	b122      	addi.n	a2, a2, 1
  90846d:	22364c        	s32i	a2, a3, 0x130
	}
}

static void ath_uapsd_processtriggers(struct ath_softc_tgt *sc)
{
	struct ath_hal *ah = sc->sc_ah;
  908470:	223d05        	addmi	a2, a3, 0x500
  908473:	862b      	l32i.n	a6, a2, 44

#define	PA2DESC(_sc, _pa)						\
	((struct ath_desc *)((caddr_t)(_sc)->sc_rxdma.dd_desc +		\
			     ((_pa) - (_sc)->sc_rxdma.dd_desc_paddr)))

	tsf = ah->ah_getTsf64(ah);
  908475:	22621e        	l32i	a2, a6, 120
  908478:	da60      	mov.n	a10, a6
  90847a:	0b2000        	callx8	a2
	bf = asf_tailq_first(&sc->sc_rxbuf);

	ds = asf_tailq_first(&sc->sc_rxdesc);
  90847d:	2f32d9        	l32i	a15, a3, 0x364
#define	PA2DESC(_sc, _pa)						\
	((struct ath_desc *)((caddr_t)(_sc)->sc_rxdma.dd_desc +		\
			     ((_pa) - (_sc)->sc_rxdma.dd_desc_paddr)))

	tsf = ah->ah_getTsf64(ah);
	bf = asf_tailq_first(&sc->sc_rxbuf);
  908480:	2432d5        	l32i	a4, a3, 0x354

	ds = asf_tailq_first(&sc->sc_rxdesc);
	ds_head = ds;
  908483:	d8f0      	mov.n	a8, a15
  908485:	6005d2        	j	908a5b <ath_intr+0x6bf>
  908488:	00196a        	excw

	while(ds) {
		++cnt;

		if (cnt == ath_numrxbufs - 1) {
  90848b:	10b177        	l32r	a0, 8f4a68 <memset+0xdc20>
  90848e:	8290      	l32i.n	a2, a9, 0
  908490:	b022      	addi.n	a2, a2, -1
  908492:	727102        	beq	a7, a2, 908498 <ath_intr+0xfc>
  908495:	600268        	j	908701 <ath_intr+0x365>
			adf_os_print("VERY LONG PACKET!!!!!\n");
  908498:	126915        	l32r	a2, 8e28ec <athos_indirection_table_install+0x1378>
  90849b:	1a6a11        	l32r	a10, 8e2ce0 <athos_indirection_table_install+0x176c>
  90849e:	242212        	l32i	a4, a2, 72
  9084a1:	981c      	s32i.n	a8, a1, 48
  9084a3:	9f1b      	s32i.n	a15, a1, 44
  9084a5:	0b4000        	callx8	a4
  9084a8:	881c      	l32i.n	a8, a1, 48
  9084aa:	8f1b      	l32i.n	a15, a1, 44
  9084ac:	60024a        	j	9086fa <ath_intr+0x35e>
  9084af:	002680        	excw
			ds_tail = ds;
			ds_tmp = ds_head;
			while (ds_tmp) {
				struct ath_rx_desc *ds_rmv;
				adf_nbuf_unmap(sc->sc_dev, ds_tmp->ds_dmap, ADF_OS_DMA_FROM_DEVICE);
  9084b2:	382580        	excw
  9084b5:	392480        	excw
  9084b8:	3a0866        	excw
  9084bb:	100055        	l32r	a0, 8c8610 <_bss_end+0x3b5700>
  9084be:	112b80        	l32r	a1, 8d32c0 <_bss_end+0x3c03b0>
  9084c1:	3b0655        	excw
  9084c4:	020844        	extui	a8, a2, 0, 5
  9084c7:	110544        	l32r	a1, 8c99d8 <_bss_end+0x3b6ac8>
  9084ca:	022a32        	sext	a10, a2, 9
static inline void
adf_nbuf_unmap(adf_os_device_t      osdev, 
               adf_os_dma_map_t     bmap, 
               adf_os_dma_dir_t     dir)
{
    __adf_nbuf_unmap(osdev, bmap, dir);
  9084cd:	4604bb        	excw
  9084d0:	02c0c1        	excw
  9084d3:	981c      	s32i.n	a8, a1, 48
  9084d5:	9f1b      	s32i.n	a15, a1, 44
  9084d7:	5bf96c        	call8	906a88 <__adf_nbuf_unmap>
				ds_rmv = ds_tmp;
				ds_tmp = asf_tailq_next(ds_tmp, ds_list);
  9084da:	881c      	l32i.n	a8, a1, 48

				if (ds_tmp == NULL) {
  9084dc:	8f1b      	l32i.n	a15, a1, 44
			ds_tmp = ds_head;
			while (ds_tmp) {
				struct ath_rx_desc *ds_rmv;
				adf_nbuf_unmap(sc->sc_dev, ds_tmp->ds_dmap, ADF_OS_DMA_FROM_DEVICE);
				ds_rmv = ds_tmp;
				ds_tmp = asf_tailq_next(ds_tmp, ds_list);
  9084de:	26804c        	l8ui	a6, a8, 76
  9084e1:	25804d        	l8ui	a5, a8, 77
  9084e4:	24804e        	l8ui	a4, a8, 78
  9084e7:	086610        	slli	a6, a6, 24
  9084ea:	005511        	slli	a5, a5, 16
  9084ed:	065502        	or	a5, a5, a6
  9084f0:	084411        	slli	a4, a4, 8
  9084f3:	054402        	or	a4, a4, a5
  9084f6:	25804f        	l8ui	a5, a8, 79
  9084f9:	045402        	or	a4, a5, a4

				if (ds_tmp == NULL) {
  9084fc:	654021        	bnez	a4, 908521 <ath_intr+0x185>
					adf_os_print("ds_tmp is NULL\n");
  9084ff:	252212        	l32i	a5, a2, 72
  908502:	1a6a12        	l32r	a10, 8e2d4c <athos_indirection_table_install+0x17d8>
  908505:	0b5000        	callx8	a5
					adf_os_assert(0);
  908508:	1a69f6        	l32r	a10, 8e2ce0 <athos_indirection_table_install+0x176c>
  90850b:	252212        	l32i	a5, a2, 72
  90850e:	1b6a13        	l32r	a11, 8e2d5c <athos_indirection_table_install+0x17e8>
  908511:	0b5000        	callx8	a5
  908514:	15697a        	l32r	a5, 8e2afc <athos_indirection_table_install+0x1588>
  908517:	8f1b      	l32i.n	a15, a1, 44
  908519:	0c0200        	memw
  90851c:	8550      	l32i.n	a5, a5, 0
  90851e:	28120c        	l32i	a8, a1, 48
				}

				BUF_Pool_free_buf(sc->pool_handle, POOL_ID_WLAN_RX_BUF, ds_rmv->ds_nbuf);
  908521:	278034        	l8ui	a7, a8, 52
  908524:	258035        	l8ui	a5, a8, 53
  908527:	268036        	l8ui	a6, a8, 54
  90852a:	087710        	slli	a7, a7, 24
  90852d:	005511        	slli	a5, a5, 16
  908530:	075502        	or	a5, a5, a7
  908533:	086611        	slli	a6, a6, 8
  908536:	056602        	or	a6, a6, a5
  908539:	156915        	l32r	a5, 8e2990 <athos_indirection_table_install+0x141c>
  90853c:	2c8037        	l8ui	a12, a8, 55
  90853f:	25529e        	l32i	a5, a5, 0x278
  908542:	8a30      	l32i.n	a10, a3, 0
  908544:	06cc02        	or	a12, a12, a6
  908547:	9f1b      	s32i.n	a15, a1, 44
  908549:	c0b3      	movi.n	a11, 3
  90854b:	981c      	s32i.n	a8, a1, 48
  90854d:	0b5000        	callx8	a5
				ds_rmv->ds_nbuf = ADF_NBUF_NULL;
  908550:	881c      	l32i.n	a8, a1, 48
  908552:	c050      	movi.n	a5, 0
  908554:	258434        	s8i	a5, a8, 52
  908557:	258435        	s8i	a5, a8, 53
  90855a:	258436        	s8i	a5, a8, 54
  90855d:	258437        	s8i	a5, a8, 55

				if (ath_rxdesc_init(sc, ds_rmv) == 0) {
  908560:	db80      	mov.n	a11, a8
  908562:	da30      	mov.n	a10, a3
  908564:	981c      	s32i.n	a8, a1, 48
  908566:	5bfe04        	call8	907d78 <ath_rxdesc_init>
  908569:	881c      	l32i.n	a8, a1, 48
  90856b:	8f1b      	l32i.n	a15, a1, 44
  90856d:	25804c        	l8ui	a5, a8, 76
  908570:	26804d        	l8ui	a6, a8, 77
					asf_tailq_remove(&sc->sc_rxdesc, ds_rmv, ds_list);
  908573:	085510        	slli	a5, a5, 24
  908576:	006611        	slli	a6, a6, 16
  908579:	056602        	or	a6, a6, a5
  90857c:	25804e        	l8ui	a5, a8, 78
  90857f:	278051        	l8ui	a7, a8, 81
  908582:	085511        	slli	a5, a5, 8
  908585:	065502        	or	a5, a5, a6
  908588:	26804f        	l8ui	a6, a8, 79
  90858b:	007711        	slli	a7, a7, 16
  90858e:	056502        	or	a5, a6, a5
  908591:	268050        	l8ui	a6, a8, 80
  908594:	086610        	slli	a6, a6, 24
  908597:	067702        	or	a7, a7, a6
  90859a:	268052        	l8ui	a6, a8, 82
  90859d:	086611        	slli	a6, a6, 8
  9085a0:	076602        	or	a6, a6, a7
				}

				BUF_Pool_free_buf(sc->pool_handle, POOL_ID_WLAN_RX_BUF, ds_rmv->ds_nbuf);
				ds_rmv->ds_nbuf = ADF_NBUF_NULL;

				if (ath_rxdesc_init(sc, ds_rmv) == 0) {
  9085a3:	65a099        	bnez	a10, 908640 <ath_intr+0x2a4>
					asf_tailq_remove(&sc->sc_rxdesc, ds_rmv, ds_list);
  9085a6:	c95e      	beqz.n	a5, 9085c8 <ath_intr+0x22c>
  9085a8:	278053        	l8ui	a7, a8, 83
  9085ab:	067602        	or	a6, a7, a6
  9085ae:	068757        	extui	a7, a6, 24, 8
  9085b1:	275450        	s8i	a7, a5, 80
  9085b4:	060757        	extui	a7, a6, 16, 8
  9085b7:	275451        	s8i	a7, a5, 81
  9085ba:	068747        	extui	a7, a6, 8, 8
  9085bd:	275452        	s8i	a7, a5, 82
  9085c0:	265453        	s8i	a6, a5, 83
  9085c3:	60000a        	j	9085d1 <ath_intr+0x235>
  9085c6:	000025        	excw
  9085c9:	8053      	l32i.n	a0, a5, 12
  9085cb:	065602        	or	a6, a5, a6
  9085ce:	2636da        	s32i	a6, a3, 0x368
  9085d1:	278050        	l8ui	a7, a8, 80
  9085d4:	268051        	l8ui	a6, a8, 81
  9085d7:	258052        	l8ui	a5, a8, 82
  9085da:	087710        	slli	a7, a7, 24
  9085dd:	006611        	slli	a6, a6, 16
  9085e0:	076602        	or	a6, a6, a7
  9085e3:	085511        	slli	a5, a5, 8
  9085e6:	065502        	or	a5, a5, a6
  9085e9:	268053        	l8ui	a6, a8, 83
  9085ec:	2a804c        	l8ui	a10, a8, 76
  9085ef:	27804d        	l8ui	a7, a8, 77
  9085f2:	056502        	or	a5, a6, a5
  9085f5:	26804e        	l8ui	a6, a8, 78
  9085f8:	08aa10        	slli	a10, a10, 24
  9085fb:	007711        	slli	a7, a7, 16
  9085fe:	0a7702        	or	a7, a7, a10
  908601:	086611        	slli	a6, a6, 8
  908604:	076602        	or	a6, a6, a7
  908607:	27804f        	l8ui	a7, a8, 79
  90860a:	067602        	or	a6, a7, a6
  90860d:	9650      	s32i.n	a6, a5, 0
					asf_tailq_insert_tail(&sc->sc_rxdesc, ds_rmv, ds_list);
  90860f:	c050      	movi.n	a5, 0
  908611:	25844c        	s8i	a5, a8, 76
  908614:	25844d        	s8i	a5, a8, 77
  908617:	25844e        	s8i	a5, a8, 78
  90861a:	25844f        	s8i	a5, a8, 79
  90861d:	2532da        	l32i	a5, a3, 0x368
  908620:	058657        	extui	a6, a5, 24, 8
  908623:	268450        	s8i	a6, a8, 80
  908626:	050657        	extui	a6, a5, 16, 8
  908629:	268451        	s8i	a6, a8, 81
  90862c:	058647        	extui	a6, a5, 8, 8
  90862f:	258453        	s8i	a5, a8, 83
  908632:	268452        	s8i	a6, a8, 82
  908635:	9850      	s32i.n	a8, a5, 0
  908637:	258c4c        	addi	a5, a8, 76
  90863a:	2536da        	s32i	a5, a3, 0x368
  90863d:	600094        	j	9086d5 <ath_intr+0x339>
				}
				else {
					asf_tailq_remove(&sc->sc_rxdesc, ds_rmv, ds_list);
  908640:	c95c      	beqz.n	a5, 908660 <ath_intr+0x2c4>
  908642:	278053        	l8ui	a7, a8, 83
  908645:	067602        	or	a6, a7, a6
  908648:	068757        	extui	a7, a6, 24, 8
  90864b:	275450        	s8i	a7, a5, 80
  90864e:	060757        	extui	a7, a6, 16, 8
  908651:	275451        	s8i	a7, a5, 81
  908654:	068747        	extui	a7, a6, 8, 8
  908657:	275452        	s8i	a7, a5, 82
  90865a:	265453        	s8i	a6, a5, 83
  90865d:	600008        	j	908669 <ath_intr+0x2cd>
  908660:	258053        	l8ui	a5, a8, 83
  908663:	065602        	or	a6, a5, a6
  908666:	2636da        	s32i	a6, a3, 0x368
  908669:	278050        	l8ui	a7, a8, 80
  90866c:	268051        	l8ui	a6, a8, 81
  90866f:	258052        	l8ui	a5, a8, 82
  908672:	087710        	slli	a7, a7, 24
  908675:	006611        	slli	a6, a6, 16
  908678:	076602        	or	a6, a6, a7
  90867b:	085511        	slli	a5, a5, 8
  90867e:	065502        	or	a5, a5, a6
  908681:	268053        	l8ui	a6, a8, 83
  908684:	2a804c        	l8ui	a10, a8, 76
  908687:	27804d        	l8ui	a7, a8, 77
  90868a:	056502        	or	a5, a6, a5
  90868d:	26804e        	l8ui	a6, a8, 78
  908690:	08aa10        	slli	a10, a10, 24
  908693:	007711        	slli	a7, a7, 16
  908696:	0a7702        	or	a7, a7, a10
  908699:	086611        	slli	a6, a6, 8
  90869c:	076602        	or	a6, a6, a7
  90869f:	27804f        	l8ui	a7, a8, 79
  9086a2:	067602        	or	a6, a7, a6
  9086a5:	9650      	s32i.n	a6, a5, 0
					asf_tailq_insert_tail(&sc->sc_rxdesc_idle, ds_rmv, ds_list);
  9086a7:	c050      	movi.n	a5, 0
  9086a9:	25844c        	s8i	a5, a8, 76
  9086ac:	25844d        	s8i	a5, a8, 77
  9086af:	25844e        	s8i	a5, a8, 78
  9086b2:	25844f        	s8i	a5, a8, 79
  9086b5:	2532d8        	l32i	a5, a3, 0x360
  9086b8:	058657        	extui	a6, a5, 24, 8
  9086bb:	268450        	s8i	a6, a8, 80
  9086be:	050657        	extui	a6, a5, 16, 8
  9086c1:	268451        	s8i	a6, a8, 81
  9086c4:	058647        	extui	a6, a5, 8, 8
  9086c7:	258453        	s8i	a5, a8, 83
  9086ca:	268452        	s8i	a6, a8, 82
  9086cd:	9850      	s32i.n	a8, a5, 0
  9086cf:	258c4c        	addi	a5, a8, 76
  9086d2:	2536d8        	s32i	a5, a3, 0x360
				}

				if (ds_rmv == ds_tail) {
  9086d5:	7f891f        	bne	a8, a15, 9086f8 <ath_intr+0x35c>
			if (status & HAL_INT_RX)
				sc->sc_int_stats.ast_rx++;

			ath_uapsd_processtriggers(sc);

			sc->sc_imask &= ~HAL_INT_RX;
  9086d8:	2232c4        	l32i	a2, a3, 0x310
			ah->ah_setInterrupts(ah, sc->sc_imask);
  9086db:	8418      	l32i.n	a4, a1, 32
			if (status & HAL_INT_RX)
				sc->sc_int_stats.ast_rx++;

			ath_uapsd_processtriggers(sc);

			sc->sc_imask &= ~HAL_INT_RX;
  9086dd:	c7be      	movi.n	a11, -2
  9086df:	02bb01        	and	a11, a11, a2
			ah->ah_setInterrupts(ah, sc->sc_imask);
  9086e2:	224228        	l32i	a2, a4, 160
			if (status & HAL_INT_RX)
				sc->sc_int_stats.ast_rx++;

			ath_uapsd_processtriggers(sc);

			sc->sc_imask &= ~HAL_INT_RX;
  9086e5:	2b36c4        	s32i	a11, a3, 0x310
			ah->ah_setInterrupts(ah, sc->sc_imask);
  9086e8:	da40      	mov.n	a10, a4
  9086ea:	0b2000        	callx8	a2
  9086ed:	2a3a14        	movi	a10, 0x314
  9086f0:	aa3a      	add.n	a10, a3, a10
  9086f2:	5bfd9d        	call8	907d68 <__adf_os_sched_bh$isra$5>
  9086f5:	600397        	j	908a90 <ath_intr+0x6f4>
			ds_tmp = ds_head;
			while (ds_tmp) {
				struct ath_rx_desc *ds_rmv;
				adf_nbuf_unmap(sc->sc_dev, ds_tmp->ds_dmap, ADF_OS_DMA_FROM_DEVICE);
				ds_rmv = ds_tmp;
				ds_tmp = asf_tailq_next(ds_tmp, ds_list);
  9086f8:	d840      	mov.n	a8, a4

		if (cnt == ath_numrxbufs - 1) {
			adf_os_print("VERY LONG PACKET!!!!!\n");
			ds_tail = ds;
			ds_tmp = ds_head;
			while (ds_tmp) {
  9086fa:	658db2        	bnez	a8, 9084b0 <ath_intr+0x114>
  9086fd:	63ffd7        	j	9086d8 <ath_intr+0x33c>
  908700:	002af0        	excw
				}
			}
			break;
		}

		if (ds->ds_link == 0) {
  908703:	0022f0        	excw
  908706:	012ef0        	excw
  908709:	0208aa        	excw
  90870c:	100022        	l32r	a0, 8c8794 <_bss_end+0x3b5884>
  90870f:	110a22        	l32r	a1, 8caf98 <_bss_end+0x3b8088>
  908712:	0208ee        	excw
  908715:	1102ee        	l32r	a1, 8c92d0 <_bss_end+0x3b63c0>
  908718:	0222f0        	excw
  90871b:	030e2e        	excw
  90871e:	0264ef        	excw
  908721:	b582      	addi.n	a2, a8, 5
			break;
		}

		if (bf->bf_status & ATH_BUFSTATUS_DONE) {
  908723:	4f7f27        	excw
  908726:	026003        	xor	a0, a6, a2
  908729:	5f2af0        	call12	8d32ec <_bss_end+0x3c03dc>
			continue;
		}

		retval = ah->ah_procRxDescFast(ah, ds, ds->ds_daddr,
  90872c:	4822f0        	excw
  90872f:	4908aa        	excw
  908732:	100022        	l32r	a0, 8c87bc <_bss_end+0x3b58ac>
  908735:	110a22        	l32r	a1, 8cafc0 <_bss_end+0x3b80b0>
  908738:	022af0        	excw
  90873b:	4a2932        	excw
						PA2DESC(sc, ds->ds_link), &bf->bf_rx_status);
  90873e:	e0          	.byte 0xe0
  90873f:	2d32de        	l32i	a13, a3, 0x378

		if (bf->bf_status & ATH_BUFSTATUS_DONE) {
			continue;
		}

		retval = ah->ah_procRxDescFast(ah, ds, ds->ds_daddr,
  908742:	2cf04b        	l8ui	a12, a15, 75
  908745:	08aa11        	slli	a10, a10, 8
  908748:	02a202        	or	a2, a10, a2
						PA2DESC(sc, ds->ds_link), &bf->bf_rx_status);
  90874b:	09dd0c        	sub	a13, a13, a9

		if (bf->bf_status & ATH_BUFSTATUS_DONE) {
			continue;
		}

		retval = ah->ah_procRxDescFast(ah, ds, ds->ds_daddr,
  90874e:	296222        	l32i	a9, a6, 136
  908751:	dbf0      	mov.n	a11, a15
  908753:	02cc02        	or	a12, a12, a2
  908756:	aedd      	add.n	a13, a13, a14
  908758:	9f1b      	s32i.n	a15, a1, 44
  90875a:	066a02        	or	a10, a6, a6
  90875d:	2e4c40        	addi	a14, a4, 64
  908760:	981c      	s32i.n	a8, a1, 48
  908762:	0b9000        	callx8	a9
						PA2DESC(sc, ds->ds_link), &bf->bf_rx_status);
		if (HAL_EINPROGRESS == retval) {
  908765:	220a0f        	movi	a2, 15
  908768:	2f120b        	l32i	a15, a1, 44
  90876b:	72a902        	bne	a10, a2, 908771 <ath_intr+0x3d5>
  90876e:	63ff66        	j	9086d8 <ath_intr+0x33c>
			break;
		}

		if (adf_nbuf_len(ds->ds_nbuf) == 0) {
  908771:	2bf034        	l8ui	a11, a15, 52
  908774:	2af035        	l8ui	a10, a15, 53
  908777:	22f036        	l8ui	a2, a15, 54
  90877a:	08bb10        	slli	a11, a11, 24
  90877d:	00aa11        	slli	a10, a10, 16
  908780:	0baa02        	or	a10, a10, a11
  908783:	082211        	slli	a2, a2, 8
  908786:	0a2202        	or	a2, a2, a10
  908789:	2af037        	l8ui	a10, a15, 55
 * @return The total length of this buf.
 */
static inline adf_os_size_t
adf_nbuf_len(adf_nbuf_t buf)
{
    return (__adf_nbuf_len(buf));
  90878c:	02aa02        	or	a10, a10, a2
  90878f:	5bf93c        	call8	906c80 <__adf_nbuf_len>
  908792:	881c      	l32i.n	a8, a1, 48
  908794:	8f1b      	l32i.n	a15, a1, 44
  908796:	65a027        	bnez	a10, 9087c1 <ath_intr+0x425>
			adf_nbuf_put_tail(ds->ds_nbuf, bf->bf_rx_status.rs_datalen);
  908799:	2bf034        	l8ui	a11, a15, 52
  90879c:	2af035        	l8ui	a10, a15, 53
  90879f:	22f036        	l8ui	a2, a15, 54
  9087a2:	08bb10        	slli	a11, a11, 24
  9087a5:	00aa11        	slli	a10, a10, 16
  9087a8:	0baa02        	or	a10, a10, a11
  9087ab:	082211        	slli	a2, a2, 8
  9087ae:	0a2202        	or	a2, a2, a10
  9087b1:	2af037        	l8ui	a10, a15, 55
 *         put, or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_put_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_put_tail(buf, size);
  9087b4:	2b4124        	l16ui	a11, a4, 72
  9087b7:	02aa02        	or	a10, a10, a2
  9087ba:	5bf91d        	call8	906c30 <__adf_nbuf_put_tail>
  9087bd:	8f1b      	l32i.n	a15, a1, 44
  9087bf:	881c      	l32i.n	a8, a1, 48
		}

		frame_len += bf->bf_rx_status.rs_datalen;
  9087c1:	224124        	l16ui	a2, a4, 72

		if (bf->bf_rx_status.rs_more == 0) {
  9087c4:	2d4056        	l8ui	a13, a4, 86

		if (adf_nbuf_len(ds->ds_nbuf) == 0) {
			adf_nbuf_put_tail(ds->ds_nbuf, bf->bf_rx_status.rs_datalen);
		}

		frame_len += bf->bf_rx_status.rs_datalen;
  9087c7:	a255      	add.n	a5, a5, a2
  9087c9:	05054f        	extui	a5, a5, 0, 16

		if (bf->bf_rx_status.rs_more == 0) {
  9087cc:	65d29c        	bnez	a13, 908a6c <ath_intr+0x6d0>
 * @param[in] head  buf queue head
 */
static inline void
adf_nbuf_queue_init(adf_nbuf_queue_t *head)
{
    __adf_nbuf_queue_init(head);
  9087cf:	da10      	mov.n	a10, a1
  9087d1:	981c      	s32i.n	a8, a1, 48
  9087d3:	9d1a      	s32i.n	a13, a1, 40
  9087d5:	9f1b      	s32i.n	a15, a1, 44
  9087d7:	5bf938        	call8	906cb8 <__adf_nbuf_queue_init>
			adf_nbuf_queue_init(&nbuf_head);

			cnt = 0;

			ds_tail = ds;
			ds = asf_tailq_next(ds, ds_list);
  9087da:	8f1b      	l32i.n	a15, a1, 44
			while (ds_tmp) {
				struct ath_rx_desc *ds_rmv;

				adf_nbuf_unmap(sc->sc_dev, ds_tmp->ds_dmap, ADF_OS_DMA_FROM_DEVICE);
				adf_nbuf_queue_add(&nbuf_head, ds_tmp->ds_nbuf);
				ds_tmp->ds_nbuf = ADF_NBUF_NULL;
  9087dc:	8d1a      	l32i.n	a13, a1, 40
			adf_nbuf_queue_init(&nbuf_head);

			cnt = 0;

			ds_tail = ds;
			ds = asf_tailq_next(ds, ds_list);
  9087de:	2af04c        	l8ui	a10, a15, 76
  9087e1:	27f04d        	l8ui	a7, a15, 77
  9087e4:	22f04e        	l8ui	a2, a15, 78
  9087e7:	08aa10        	slli	a10, a10, 24
  9087ea:	007711        	slli	a7, a7, 16
  9087ed:	0a7702        	or	a7, a7, a10
  9087f0:	082211        	slli	a2, a2, 8
  9087f3:	072202        	or	a2, a2, a7
  9087f6:	27f04f        	l8ui	a7, a15, 79
  9087f9:	881c      	l32i.n	a8, a1, 48
  9087fb:	027202        	or	a2, a7, a2
  9087fe:	9219      	s32i.n	a2, a1, 36
			while (ds_tmp) {
				struct ath_rx_desc *ds_rmv;

				adf_nbuf_unmap(sc->sc_dev, ds_tmp->ds_dmap, ADF_OS_DMA_FROM_DEVICE);
				adf_nbuf_queue_add(&nbuf_head, ds_tmp->ds_nbuf);
				ds_tmp->ds_nbuf = ADF_NBUF_NULL;
  908800:	d2d0      	mov.n	a2, a13
  908802:	60025e        	j	908a64 <ath_intr+0x6c8>
			ds_head = asf_tailq_next(ds_tail, ds_list);

			while (ds_tmp) {
				struct ath_rx_desc *ds_rmv;

				adf_nbuf_unmap(sc->sc_dev, ds_tmp->ds_dmap, ADF_OS_DMA_FROM_DEVICE);
  908805:	2b8038        	l8ui	a11, a8, 56
  908808:	2a8039        	l8ui	a10, a8, 57
  90880b:	27803a        	l8ui	a7, a8, 58
  90880e:	08bb10        	slli	a11, a11, 24
  908811:	00aa11        	slli	a10, a10, 16
  908814:	0baa02        	or	a10, a10, a11
  908817:	087711        	slli	a7, a7, 8
  90881a:	2b803b        	l8ui	a11, a8, 59
  90881d:	0a7702        	or	a7, a7, a10
static inline void
adf_nbuf_unmap(adf_os_device_t      osdev, 
               adf_os_dma_map_t     bmap, 
               adf_os_dma_dir_t     dir)
{
    __adf_nbuf_unmap(osdev, bmap, dir);
  908820:	2a3246        	l32i	a10, a3, 0x118
  908823:	07bb02        	or	a11, a11, a7
  908826:	c0c1      	movi.n	a12, 1
  908828:	2f160b        	s32i	a15, a1, 44
  90882b:	28160c        	s32i	a8, a1, 48
  90882e:	5bf896        	call8	906a88 <__adf_nbuf_unmap>
				adf_nbuf_queue_add(&nbuf_head, ds_tmp->ds_nbuf);
  908831:	881c      	l32i.n	a8, a1, 48
  908833:	2b8034        	l8ui	a11, a8, 52
  908836:	2a8035        	l8ui	a10, a8, 53
  908839:	278036        	l8ui	a7, a8, 54
  90883c:	08bb10        	slli	a11, a11, 24
  90883f:	00aa11        	slli	a10, a10, 16
  908842:	0baa02        	or	a10, a10, a11
  908845:	087711        	slli	a7, a7, 8
  908848:	2b8037        	l8ui	a11, a8, 55
  90884b:	0a7702        	or	a7, a7, a10
 * @param[in] buf   buf
 */
static inline void
adf_nbuf_queue_add(adf_nbuf_queue_t *head, adf_nbuf_t buf)
{
    __adf_nbuf_queue_add(head, buf);
  90884e:	07bb02        	or	a11, a11, a7
  908851:	da10      	mov.n	a10, a1
  908853:	5bf871        	call8	906a18 <__adf_nbuf_queue_add>
				ds_tmp->ds_nbuf = ADF_NBUF_NULL;
  908856:	881c      	l32i.n	a8, a1, 48

				ds_rmv = ds_tmp;
				ds_tmp = asf_tailq_next(ds_tmp, ds_list);
  908858:	2b804c        	l8ui	a11, a8, 76
  90885b:	2a804d        	l8ui	a10, a8, 77
  90885e:	27804e        	l8ui	a7, a8, 78
  908861:	08bb10        	slli	a11, a11, 24
  908864:	00aa11        	slli	a10, a10, 16
  908867:	0baa02        	or	a10, a10, a11
  90886a:	087711        	slli	a7, a7, 8
  90886d:	0a7702        	or	a7, a7, a10
  908870:	2a804f        	l8ui	a10, a8, 79
			while (ds_tmp) {
				struct ath_rx_desc *ds_rmv;

				adf_nbuf_unmap(sc->sc_dev, ds_tmp->ds_dmap, ADF_OS_DMA_FROM_DEVICE);
				adf_nbuf_queue_add(&nbuf_head, ds_tmp->ds_nbuf);
				ds_tmp->ds_nbuf = ADF_NBUF_NULL;
  908873:	228434        	s8i	a2, a8, 52
  908876:	228435        	s8i	a2, a8, 53
  908879:	228436        	s8i	a2, a8, 54
  90887c:	228437        	s8i	a2, a8, 55

				ds_rmv = ds_tmp;
				ds_tmp = asf_tailq_next(ds_tmp, ds_list);
  90887f:	07a702        	or	a7, a10, a7
				if (ds_tmp == NULL) {
  908882:	8f1b      	l32i.n	a15, a1, 44
  908884:	65701d        	bnez	a7, 9088a5 <ath_intr+0x509>
					adf_os_assert(0);
  908887:	1a6915        	l32r	a10, 8e2cdc <athos_indirection_table_install+0x1768>
  90888a:	1b6a13        	l32r	a11, 8e30d8 <athos_indirection_table_install+0x1b64>
  90888d:	2ca212        	l32i	a12, a10, 72
  908890:	1a69f6        	l32r	a10, 8e3068 <athos_indirection_table_install+0x1af4>
  908893:	28160c        	s32i	a8, a1, 48
  908896:	0bc000        	callx8	a12
  908899:	1a697a        	l32r	a10, 8e2e84 <athos_indirection_table_install+0x1910>
  90889c:	8f1b      	l32i.n	a15, a1, 44
  90889e:	0c0200        	memw
  9088a1:	8aa0      	l32i.n	a10, a10, 0
  9088a3:	881c      	l32i.n	a8, a1, 48
				}

				if (ath_rxdesc_init(sc, ds_rmv) == 0) {
  9088a5:	db80      	mov.n	a11, a8
  9088a7:	da30      	mov.n	a10, a3
  9088a9:	981c      	s32i.n	a8, a1, 48
  9088ab:	9f1b      	s32i.n	a15, a1, 44
  9088ad:	5bfd32        	call8	907d78 <ath_rxdesc_init>
  9088b0:	881c      	l32i.n	a8, a1, 48
  9088b2:	8f1b      	l32i.n	a15, a1, 44
  9088b4:	2c804c        	l8ui	a12, a8, 76
  9088b7:	2b804d        	l8ui	a11, a8, 77
					asf_tailq_remove(&sc->sc_rxdesc, ds_rmv, ds_list);
  9088ba:	08cc10        	slli	a12, a12, 24
  9088bd:	00bb11        	slli	a11, a11, 16
  9088c0:	0cbb02        	or	a11, a11, a12
				ds_tmp = asf_tailq_next(ds_tmp, ds_list);
				if (ds_tmp == NULL) {
					adf_os_assert(0);
				}

				if (ath_rxdesc_init(sc, ds_rmv) == 0) {
  9088c3:	65a0bd        	bnez	a10, 908984 <ath_intr+0x5e8>
					asf_tailq_remove(&sc->sc_rxdesc, ds_rmv, ds_list);
  9088c6:	2a804e        	l8ui	a10, a8, 78
  9088c9:	2c8051        	l8ui	a12, a8, 81
  9088cc:	08aa11        	slli	a10, a10, 8
  9088cf:	0baa02        	or	a10, a10, a11
  9088d2:	2b804f        	l8ui	a11, a8, 79
  9088d5:	00cc11        	slli	a12, a12, 16
  9088d8:	0aba02        	or	a10, a11, a10
  9088db:	2b8050        	l8ui	a11, a8, 80
  9088de:	08bb10        	slli	a11, a11, 24
  9088e1:	0bcc02        	or	a12, a12, a11
  9088e4:	2b8052        	l8ui	a11, a8, 82
  9088e7:	08bb11        	slli	a11, a11, 8
  9088ea:	0cbb02        	or	a11, a11, a12
  9088ed:	c9ac      	beqz.n	a10, 90890d <ath_intr+0x571>
  9088ef:	2c8053        	l8ui	a12, a8, 83
  9088f2:	0bcb02        	or	a11, a12, a11
  9088f5:	0b8c57        	extui	a12, a11, 24, 8
  9088f8:	2ca450        	s8i	a12, a10, 80
  9088fb:	0b0c57        	extui	a12, a11, 16, 8
  9088fe:	2ca451        	s8i	a12, a10, 81
  908901:	0b8c47        	extui	a12, a11, 8, 8
  908904:	2ca452        	s8i	a12, a10, 82
  908907:	2ba453        	s8i	a11, a10, 83
  90890a:	600008        	j	908916 <ath_intr+0x57a>
  90890d:	2a8053        	l8ui	a10, a8, 83
  908910:	0bab02        	or	a11, a10, a11
  908913:	2b36da        	s32i	a11, a3, 0x368
  908916:	2c8050        	l8ui	a12, a8, 80
  908919:	2b8051        	l8ui	a11, a8, 81
  90891c:	2a8052        	l8ui	a10, a8, 82
  90891f:	08cc10        	slli	a12, a12, 24
  908922:	00bb11        	slli	a11, a11, 16
  908925:	0cbb02        	or	a11, a11, a12
  908928:	08aa11        	slli	a10, a10, 8
  90892b:	0baa02        	or	a10, a10, a11
  90892e:	2b8053        	l8ui	a11, a8, 83
  908931:	2e804c        	l8ui	a14, a8, 76
  908934:	2c804d        	l8ui	a12, a8, 77
  908937:	0aba02        	or	a10, a11, a10
  90893a:	2b804e        	l8ui	a11, a8, 78
  90893d:	08ee10        	slli	a14, a14, 24
  908940:	00cc11        	slli	a12, a12, 16
  908943:	0ecc02        	or	a12, a12, a14
  908946:	08bb11        	slli	a11, a11, 8
  908949:	0cbb02        	or	a11, a11, a12
  90894c:	2c804f        	l8ui	a12, a8, 79
  90894f:	0bcb02        	or	a11, a12, a11
  908952:	9ba0      	s32i.n	a11, a10, 0
					asf_tailq_insert_tail(&sc->sc_rxdesc, ds_rmv, ds_list);
  908954:	22844c        	s8i	a2, a8, 76
  908957:	22844d        	s8i	a2, a8, 77
  90895a:	22844e        	s8i	a2, a8, 78
  90895d:	22844f        	s8i	a2, a8, 79
  908960:	2a32da        	l32i	a10, a3, 0x368
  908963:	0a8b57        	extui	a11, a10, 24, 8
  908966:	2b8450        	s8i	a11, a8, 80
  908969:	0a0b57        	extui	a11, a10, 16, 8
  90896c:	2b8451        	s8i	a11, a8, 81
  90896f:	0a8b47        	extui	a11, a10, 8, 8
  908972:	2a8453        	s8i	a10, a8, 83
  908975:	2b8452        	s8i	a11, a8, 82
  908978:	98a0      	s32i.n	a8, a10, 0
  90897a:	2a8c4c        	addi	a10, a8, 76
  90897d:	2a36da        	s32i	a10, a3, 0x368
  908980:	6000bb        	j	908a3f <ath_intr+0x6a3>
  908983:	002a80        	excw
				}  else {
					asf_tailq_remove(&sc->sc_rxdesc, ds_rmv, ds_list);
  908986:	4e2c80        	excw
  908989:	5108aa        	call0	94ac34 <_etext+0x3bb1b>
  90898c:	110baa        	l32r	a1, 8cb834 <_bss_end+0x3b8924>
  90898f:	022b80        	excw
  908992:	4f00cc        	excw
  908995:	110aba        	l32r	a1, 8cb480 <_bss_end+0x3b8570>
  908998:	022b80        	excw
  90899b:	5008bb        	call0	90ac88 <_HIFusb_start_patch+0xc>
  90899e:	100bcc        	l32r	a0, 8cb8d0 <_bss_end+0x3b89c0>
  9089a1:	022b80        	excw
  9089a4:	5208bb        	call0	88ac94 <_bss_end+0x377d84>
  9089a7:	110cbb        	l32r	a1, 8cbc94 <_bss_end+0x3b8d84>
  9089aa:	02c9ad        	excw
  9089ad:	2c8053        	l8ui	a12, a8, 83
  9089b0:	0bcb02        	or	a11, a12, a11
  9089b3:	0b8c57        	extui	a12, a11, 24, 8
  9089b6:	2ca450        	s8i	a12, a10, 80
  9089b9:	0b0c57        	extui	a12, a11, 16, 8
  9089bc:	2ca451        	s8i	a12, a10, 81
  9089bf:	0b8c47        	extui	a12, a11, 8, 8
  9089c2:	2ca452        	s8i	a12, a10, 82
  9089c5:	2ba453        	s8i	a11, a10, 83
  9089c8:	600009        	j	9089d5 <ath_intr+0x639>
  9089cb:	002a80        	excw
  9089ce:	530bab        	call0	8cb87c <_bss_end+0x3b896c>
  9089d1:	022b36        	minu	a11, a2, a2
  9089d4:	da2c      	excw
  9089d6:	8050      	l32i.n	a0, a5, 0
  9089d8:	2b8051        	l8ui	a11, a8, 81
  9089db:	2a8052        	l8ui	a10, a8, 82
  9089de:	08cc10        	slli	a12, a12, 24
  9089e1:	00bb11        	slli	a11, a11, 16
  9089e4:	0cbb02        	or	a11, a11, a12
  9089e7:	08aa11        	slli	a10, a10, 8
  9089ea:	0baa02        	or	a10, a10, a11
  9089ed:	2b8053        	l8ui	a11, a8, 83
  9089f0:	2e804c        	l8ui	a14, a8, 76
  9089f3:	2c804d        	l8ui	a12, a8, 77
  9089f6:	0aba02        	or	a10, a11, a10
  9089f9:	2b804e        	l8ui	a11, a8, 78
  9089fc:	08ee10        	slli	a14, a14, 24
  9089ff:	00cc11        	slli	a12, a12, 16
  908a02:	0ecc02        	or	a12, a12, a14
  908a05:	08bb11        	slli	a11, a11, 8
  908a08:	0cbb02        	or	a11, a11, a12
  908a0b:	2c804f        	l8ui	a12, a8, 79
  908a0e:	0bcb02        	or	a11, a12, a11
  908a11:	9ba0      	s32i.n	a11, a10, 0
					asf_tailq_insert_tail(&sc->sc_rxdesc_idle, ds_rmv, ds_list);
  908a13:	22844c        	s8i	a2, a8, 76
  908a16:	22844d        	s8i	a2, a8, 77
  908a19:	22844e        	s8i	a2, a8, 78
  908a1c:	22844f        	s8i	a2, a8, 79
  908a1f:	2a32d8        	l32i	a10, a3, 0x360
  908a22:	0a8b57        	extui	a11, a10, 24, 8
  908a25:	2b8450        	s8i	a11, a8, 80
  908a28:	0a0b57        	extui	a11, a10, 16, 8
  908a2b:	2b8451        	s8i	a11, a8, 81
  908a2e:	0a8b47        	extui	a11, a10, 8, 8
  908a31:	2a8453        	s8i	a10, a8, 83
  908a34:	2b8452        	s8i	a11, a8, 82
  908a37:	98a0      	s32i.n	a8, a10, 0
  908a39:	2a8c4c        	addi	a10, a8, 76
  908a3c:	2a36d8        	s32i	a10, a3, 0x360
				}

				if (ds_rmv == ds_tail) {
  908a3f:	7f891f        	bne	a8, a15, 908a62 <ath_intr+0x6c6>
					break;
				}
			}


			bf->bf_rx_status.rs_datalen = frame_len;
  908a42:	254524        	s16i	a5, a4, 72
}

static inline adf_nbuf_t
adf_nbuf_create_frm_frag(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_create_frm_frag(head);
  908a45:	da10      	mov.n	a10, a1
  908a47:	5bf824        	call8	906ad8 <__adf_nbuf_create_frm_frag>
			frame_len = 0;

			bf->bf_skb = adf_nbuf_create_frm_frag(&nbuf_head);

			bf->bf_status |= ATH_BUFSTATUS_DONE;
  908a4a:	874f      	l32i.n	a7, a4, 60
  908a4c:	c051      	movi.n	a5, 1
  908a4e:	057502        	or	a5, a7, a5

			ds_tail = ds;
			ds = asf_tailq_next(ds, ds_list);

			ds_tmp = ds_head;
			ds_head = asf_tailq_next(ds_tail, ds_list);
  908a51:	8819      	l32i.n	a8, a1, 36


			bf->bf_rx_status.rs_datalen = frame_len;
			frame_len = 0;

			bf->bf_skb = adf_nbuf_create_frm_frag(&nbuf_head);
  908a53:	9a48      	s32i.n	a10, a4, 32

			bf->bf_status |= ATH_BUFSTATUS_DONE;
  908a55:	954f      	s32i.n	a5, a4, 60

			bf = (struct ath_rx_buf *)asf_tailq_next(bf, bf_list);
  908a57:	8449      	l32i.n	a4, a4, 36
			adf_nbuf_queue_init(&nbuf_head);

			cnt = 0;

			ds_tail = ds;
			ds = asf_tailq_next(ds, ds_list);
  908a59:	df80      	mov.n	a15, a8
				}
			}


			bf->bf_rx_status.rs_datalen = frame_len;
			frame_len = 0;
  908a5b:	c050      	movi.n	a5, 0

		if (bf->bf_rx_status.rs_more == 0) {
			adf_nbuf_queue_t nbuf_head;
			adf_nbuf_queue_init(&nbuf_head);

			cnt = 0;
  908a5d:	d750      	mov.n	a7, a5
  908a5f:	600027        	j	908a8a <ath_intr+0x6ee>
				adf_nbuf_unmap(sc->sc_dev, ds_tmp->ds_dmap, ADF_OS_DMA_FROM_DEVICE);
				adf_nbuf_queue_add(&nbuf_head, ds_tmp->ds_nbuf);
				ds_tmp->ds_nbuf = ADF_NBUF_NULL;

				ds_rmv = ds_tmp;
				ds_tmp = asf_tailq_next(ds_tmp, ds_list);
  908a62:	d870      	mov.n	a8, a7
			ds = asf_tailq_next(ds, ds_list);

			ds_tmp = ds_head;
			ds_head = asf_tailq_next(ds_tail, ds_list);

			while (ds_tmp) {
  908a64:	658d9d        	bnez	a8, 908805 <ath_intr+0x469>
  908a67:	63ffd7        	j	908a42 <ath_intr+0x6a6>
  908a6a:	00002b        	mulsh	a0, a0, a0
			bf->bf_status |= ATH_BUFSTATUS_DONE;

			bf = (struct ath_rx_buf *)asf_tailq_next(bf, bf_list);
		}
		else {
			ds = asf_tailq_next(ds, ds_list);
  908a6d:	f0          	.byte 0xf0
  908a6e:	4c2af0        	excw
  908a71:	4d22f0        	excw
  908a74:	4e08bb        	excw
  908a77:	1000aa        	l32r	a0, 8c8d20 <_bss_end+0x3b5e10>
  908a7a:	110baa        	l32r	a1, 8cb924 <_bss_end+0x3b8a14>
  908a7d:	020822        	excw
  908a80:	112ff0        	l32r	a1, 8d4a40 <_bss_end+0x3c1b30>
  908a83:	4f0a22        	excw
  908a86:	0202ff        	excw
  908a89:	0265f9        	excw
	bf = asf_tailq_first(&sc->sc_rxbuf);

	ds = asf_tailq_first(&sc->sc_rxdesc);
	ds_head = ds;

	while(ds) {
  908a8c:	fb          	.byte 0xfb
  908a8d:	63fc47        	j	9086d8 <ath_intr+0x33c>
			ah->ah_setInterrupts(ah, sc->sc_imask);

			ATH_SCHEDULE_TQUEUE(sc->sc_dev, &sc->sc_rxtq);
		}

		if (status & HAL_INT_TXURN) {
  908a90:	8216      	l32i.n	a2, a1, 24
  908a92:	742712        	bbci	a2, 20, 908aa8 <ath_intr+0x70c>
			sc->sc_int_stats.ast_txurn++;
  908a95:	22324f        	l32i	a2, a3, 0x13c
			ah->ah_updateTxTrigLevel(ah, AH_TRUE);
  908a98:	8518      	l32i.n	a5, a1, 32

			ATH_SCHEDULE_TQUEUE(sc->sc_dev, &sc->sc_rxtq);
		}

		if (status & HAL_INT_TXURN) {
			sc->sc_int_stats.ast_txurn++;
  908a9a:	b122      	addi.n	a2, a2, 1
  908a9c:	22364f        	s32i	a2, a3, 0x13c
			ah->ah_updateTxTrigLevel(ah, AH_TRUE);
  908a9f:	8257      	l32i.n	a2, a5, 28
  908aa1:	da50      	mov.n	a10, a5
  908aa3:	c0b1      	movi.n	a11, 1
  908aa5:	0b2000        	callx8	a2
  908aa8:	2a5a1c        	movi	a10, 0x51c
  908aab:	aa3a      	add.n	a10, a3, a10
  908aad:	5bfcae        	call8	907d68 <__adf_os_sched_bh$isra$5>
		}

		ATH_SCHEDULE_TQUEUE(sc->sc_dev, &sc->sc_txtq);

		if (status & HAL_INT_BMISS) {
  908ab0:	8216      	l32i.n	a2, a1, 24
  908ab2:	7d2607        	bbci	a2, 13, 908abd <ath_intr+0x721>
  908ab5:	2a3a24        	movi	a10, 0x324
  908ab8:	aa3a      	add.n	a10, a3, a10
  908aba:	5bfcab        	call8	907d68 <__adf_os_sched_bh$isra$5>
			ATH_SCHEDULE_TQUEUE(sc->sc_dev, &sc->sc_bmisstq);
		}

		if (status & HAL_INT_GTT)
  908abd:	8416      	l32i.n	a4, a1, 24
  908abf:	724607        	bbci	a4, 2, 908aca <ath_intr+0x72e>
			sc->sc_int_stats.ast_txto++;
  908ac2:	223250        	l32i	a2, a3, 0x140
  908ac5:	b122      	addi.n	a2, a2, 1
  908ac7:	223650        	s32i	a2, a3, 0x140

		if (status & HAL_INT_CST)
			sc->sc_int_stats.ast_cst++;
	}

	return ADF_OS_IRQ_HANDLED;
  908aca:	c021      	movi.n	a2, 1
		}

		if (status & HAL_INT_GTT)
			sc->sc_int_stats.ast_txto++;

		if (status & HAL_INT_CST)
  908acc:	764608        	bbci	a4, 6, 908ad8 <ath_intr+0x73c>
			sc->sc_int_stats.ast_cst++;
  908acf:	243251        	l32i	a4, a3, 0x144
  908ad2:	024408        	add	a4, a4, a2
  908ad5:	243651        	s32i	a4, a3, 0x144
	}

	return ADF_OS_IRQ_HANDLED;
}
  908ad8:	d10f      	retw.n
	...

00908adc <wmi_cmd_rsp>:
	WMI_SendEvent(handle, netbuf, evt_id, 0, Length);
}

void wmi_cmd_rsp(void *pContext, WMI_COMMAND_ID cmd_id, A_UINT16 SeqNo,
		 void *buffer, a_int32_t Length)
{
  908adc:	6c1006        	entry	a1, 48
	adf_nbuf_t netbuf = ADF_NBUF_NULL;
	A_UINT8 *pData;

	netbuf = WMI_AllocEvent(pContext, WMI_EVT_CLASS_CMD_REPLY,
  908adf:	186915        	l32r	a8, 8e2f34 <athos_indirection_table_install+0x19c0>
  908ae2:	da20      	mov.n	a10, a2
  908ae4:	27828d        	l32i	a7, a8, 0x234
  908ae7:	c0b1      	movi.n	a11, 1
  908ae9:	9810      	s32i.n	a8, a1, 0
  908aeb:	b46c      	addi.n	a12, a6, 4
  908aed:	0b7000        	callx8	a7
	WMI_SendEvent(handle, netbuf, evt_id, 0, Length);
}

void wmi_cmd_rsp(void *pContext, WMI_COMMAND_ID cmd_id, A_UINT16 SeqNo,
		 void *buffer, a_int32_t Length)
{
  908af0:	04044f        	extui	a4, a4, 0, 16
	adf_nbuf_t netbuf = ADF_NBUF_NULL;
	A_UINT8 *pData;

	netbuf = WMI_AllocEvent(pContext, WMI_EVT_CLASS_CMD_REPLY,
  908af3:	d7a0      	mov.n	a7, a10
				sizeof(WMI_CMD_HDR) + Length);

	if (netbuf == ADF_NBUF_NULL) {
  908af5:	8810      	l32i.n	a8, a1, 0
  908af7:	cda5      	bnez.n	a10, 908b10 <wmi_cmd_rsp+0x34>
		adf_os_assert(0);
  908af9:	228212        	l32i	a2, a8, 72
  908afc:	1a69f6        	l32r	a10, 8e32d4 <athos_indirection_table_install+0x1d60>
  908aff:	1b6a14        	l32r	a11, 8e3350 <athos_indirection_table_install+0x1ddc>
  908b02:	0b2000        	callx8	a2
  908b05:	12697a        	l32r	a2, 8e30f0 <athos_indirection_table_install+0x1b7c>
  908b08:	0c0200        	memw
  908b0b:	8220      	l32i.n	a2, a2, 0
  908b0d:	d10f      	retw.n
  908b0f:	00c86c        	excw
		return;
	}

	if (Length != 0 && buffer != NULL) {
  908b12:	c85a      	beqz.n	a5, 908b20 <wmi_cmd_rsp+0x44>
 *         put, or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_put_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_put_tail(buf, size);
  908b14:	db60      	mov.n	a11, a6
  908b16:	5bf846        	call8	906c30 <__adf_nbuf_put_tail>
  908b19:	db50      	mov.n	a11, a5
  908b1b:	dc60      	mov.n	a12, a6
  908b1d:	5bfc14        	call8	907b70 <__adf_os_mem_copy>
		pData = (A_UINT8 *)adf_nbuf_put_tail(netbuf, Length);
		adf_os_mem_copy(pData, buffer, Length);
	}

	WMI_SendEvent(pContext, netbuf, cmd_id, SeqNo, Length);
  908b20:	156915        	l32r	a5, 8e2f74 <athos_indirection_table_install+0x1a00>
  908b23:	da20      	mov.n	a10, a2
  908b25:	25528e        	l32i	a5, a5, 0x238
  908b28:	db70      	mov.n	a11, a7
  908b2a:	030c4f        	extui	a12, a3, 0, 16
  908b2d:	dd40      	mov.n	a13, a4
  908b2f:	de60      	mov.n	a14, a6
  908b31:	0b5000        	callx8	a5
  908b34:	d10f      	retw.n
	...

00908b38 <ath_hal_reg_rmw_tgt>:
}

static void ath_hal_reg_rmw_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data,
				a_int32_t datalen)
{
  908b38:	6c1006        	entry	a1, 48
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  908b3b:	272d05        	addmi	a7, a2, 0x500
  908b3e:	887b      	l32i.n	a8, a7, 44
}

static void ath_hal_reg_rmw_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data,
				a_int32_t datalen)
{
  908b40:	03034f        	extui	a3, a3, 0, 16
  908b43:	04044f        	extui	a4, a4, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  908b46:	9810      	s32i.n	a8, a1, 0
	struct register_rmw *buf = (struct register_rmw *)data;
	int i;

	for (i = 0; i < datalen;
  908b48:	d750      	mov.n	a7, a5
  908b4a:	60003f        	j	908b8d <ath_hal_reg_rmw_tgt+0x55>
	     i += sizeof(struct register_rmw)) {
		a_uint32_t val;
		buf = (struct register_rmw *)(data + i);

		val = ath_reg_read_filter(ah, buf->reg);
  908b4d:	8b70      	l32i.n	a11, a7, 0
  908b4f:	8a10      	l32i.n	a10, a1, 0
  908b51:	5bfd18        	call8	907fb4 <ath_reg_read_filter>
		val &= ~buf->clr;
  908b54:	8972      	l32i.n	a9, a7, 8
  908b56:	c78f      	movi.n	a8, -1
  908b58:	098903        	xor	a9, a8, a9
		val |= buf->set;
  908b5b:	8b71      	l32i.n	a11, a7, 4
	     i += sizeof(struct register_rmw)) {
		a_uint32_t val;
		buf = (struct register_rmw *)(data + i);

		val = ath_reg_read_filter(ah, buf->reg);
		val &= ~buf->clr;
  908b5d:	09aa01        	and	a10, a10, a9
		val |= buf->set;
  908b60:	0baa02        	or	a10, a10, a11
		ath_hal_reg_write_filter(ah, buf->reg, val);
  908b63:	8970      	l32i.n	a9, a7, 0
}

static void ath_hal_reg_write_filter(struct ath_hal *ah,
			a_uint32_t reg, a_uint32_t val)
{
	if(reg > 0xffff) {
  908b65:	1b6a07        	l32r	a11, 8e3384 <athos_indirection_table_install+0x1e10>
  908b68:	79bb04        	bgeu	a11, a9, 908b70 <ath_hal_reg_rmw_tgt+0x38>
  908b6b:	600017        	j	908b86 <ath_hal_reg_rmw_tgt+0x4e>
  908b6e:	00001b        	sra	a0, a0
				flg = 1;
			}
		}
#endif
	} else {
		if(reg == 0x7014)
  908b71:	6a157b        	blti	a1, 5, 908bf0 <ath_rc_mask_tgt+0x4c>
  908b74:	990a      	s32i.n	a9, a0, 40
			ath_pll_reset_ones(ah);
  908b76:	9912      	s32i.n	a9, a1, 8
  908b78:	9a11      	s32i.n	a10, a1, 4
  908b7a:	5bfce4        	call8	907f0c <ath_pll_reset_ones$isra$9>
  908b7d:	8a11      	l32i.n	a10, a1, 4
  908b7f:	8912      	l32i.n	a9, a1, 8

		iowrite32_mac(reg, val);
  908b81:	1b6a02        	l32r	a11, 8e338c <athos_indirection_table_install+0x1e18>
  908b84:	ab99      	add.n	a9, a9, a11
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  908b86:	0c0200        	memw
  908b89:	9a90      	s32i.n	a10, a9, 0
  908b8b:	bc77      	addi.n	a7, a7, 12
	}

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_hal_reg_rmw_tgt(void *Context, A_UINT16 Command,
  908b8d:	05790c        	sub	a9, a7, a5
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
	struct register_rmw *buf = (struct register_rmw *)data;
	int i;

	for (i = 0; i < datalen;
  908b90:	7692b9        	blt	a9, a6, 908b4d <ath_hal_reg_rmw_tgt+0x15>
		val = ath_reg_read_filter(ah, buf->reg);
		val &= ~buf->clr;
		val |= buf->set;
		ath_hal_reg_write_filter(ah, buf->reg, val);
	}
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  908b93:	c0d0      	movi.n	a13, 0
  908b95:	8a23      	l32i.n	a10, a2, 12
  908b97:	db30      	mov.n	a11, a3
  908b99:	dc40      	mov.n	a12, a4
  908b9b:	ded0      	mov.n	a14, a13
  908b9d:	5bffcf        	call8	908adc <wmi_cmd_rsp>
  908ba0:	d10f      	retw.n
	...

00908ba4 <ath_rc_mask_tgt>:
	adf_os_assert(0);
}

static void ath_rc_mask_tgt(void *Context, A_UINT16 Command,
			    A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
  908ba4:	6c1004        	entry	a1, 32
	int idx, band, i;

	idx = wmi_data->vap_index;
	band = wmi_data->band;

	sc->sc_vap[idx].av_rate_mask[band] = adf_os_ntohl(wmi_data->mask);
  908ba7:	2e5002        	l8ui	a14, a5, 2
  908baa:	2d5003        	l8ui	a13, a5, 3
  908bad:	285004        	l8ui	a8, a5, 4
  908bb0:	08ee10        	slli	a14, a14, 24
  908bb3:	00dd11        	slli	a13, a13, 16
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_rate_mask_cmd *wmi_data = (struct wmi_rc_rate_mask_cmd *)buffer;
	int idx, band, i;

	idx = wmi_data->vap_index;
  908bb6:	295000        	l8ui	a9, a5, 0
	band = wmi_data->band;
  908bb9:	2a5001        	l8ui	a10, a5, 1

	sc->sc_vap[idx].av_rate_mask[band] = adf_os_ntohl(wmi_data->mask);
  908bbc:	0edd02        	or	a13, a13, a14
  908bbf:	255005        	l8ui	a5, a5, 5
  908bc2:	088811        	slli	a8, a8, 8
  908bc5:	0d8802        	or	a8, a8, a13
  908bc8:	085802        	or	a8, a5, a8
  908bcb:	0c9511        	slli	a5, a9, 4
  908bce:	a955      	add.n	a5, a5, a9
  908bd0:	aa5e      	add.n	a14, a5, a10
  908bd2:	2d5a70        	movi	a13, 0x570
  908bd5:	aded      	add.n	a13, a14, a13
  908bd7:	02dd0a        	addx4	a13, a13, a2
  908bda:	98d4      	s32i.n	a8, a13, 16
	adf_os_assert(0);
}

static void ath_rc_mask_tgt(void *Context, A_UINT16 Command,
			    A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
  908bdc:	030b4f        	extui	a11, a3, 0, 16
  908bdf:	040c4f        	extui	a12, a4, 0, 16
	idx = wmi_data->vap_index;
	band = wmi_data->band;

	sc->sc_vap[idx].av_rate_mask[band] = adf_os_ntohl(wmi_data->mask);

	if (sc->sc_vap[idx].av_rate_mask[band]) {
  908be2:	ca8a      	beqz.n	a8, 908c10 <ath_rc_mask_tgt+0x6c>
  908be4:	c050      	movi.n	a5, 0
		for (i = 0; i < RATE_TABLE_SIZE; i++) {
			if ((1 << i) & sc->sc_vap[idx].av_rate_mask[band]) {
  908be6:	c0d1      	movi.n	a13, 1
  908be8:	005104        	ssl	a5
  908beb:	00de1a        	sll	a14, a13
  908bee:	78e014        	bnone	a14, a8, 908c06 <ath_rc_mask_tgt+0x62>
				sc->sc_vap[idx].av_minrateidx[band] = i;
  908bf1:	0c9811        	slli	a8, a9, 4
  908bf4:	a989      	add.n	a9, a8, a9
  908bf6:	02990a        	addx4	a9, a9, a2
  908bf9:	186a16        	l32r	a8, 8e3454 <athos_indirection_table_install+0x1ee0>
  908bfc:	aa9a      	add.n	a10, a9, a10
  908bfe:	a8aa      	add.n	a10, a10, a8
  908c00:	25a408        	s8i	a5, a10, 8
				break;
  908c03:	600016        	j	908c1d <ath_rc_mask_tgt+0x79>
	band = wmi_data->band;

	sc->sc_vap[idx].av_rate_mask[band] = adf_os_ntohl(wmi_data->mask);

	if (sc->sc_vap[idx].av_rate_mask[band]) {
		for (i = 0; i < RATE_TABLE_SIZE; i++) {
  908c06:	b155      	addi.n	a5, a5, 1
  908c08:	695cdc        	bnei	a5, 32, 908be8 <ath_rc_mask_tgt+0x44>
  908c0b:	60000e        	j	908c1d <ath_rc_mask_tgt+0x79>
  908c0e:	000002        	or	a0, a0, a0
				sc->sc_vap[idx].av_minrateidx[band] = i;
				break;
			}
		}
	} else {
		sc->sc_vap[idx].av_minrateidx[band] = 0;
  908c11:	550a19        	call4	94b478 <_etext+0x3c35f>
  908c14:	6a16aa        	blti	a1, 6, 908bc2 <ath_rc_mask_tgt+0x1e>
  908c17:	5aa9aa        	call8	8b32c0 <_bss_end+0x3a03b0>
  908c1a:	28a408        	s8i	a8, a10, 8
	}

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  908c1d:	c0d0      	movi.n	a13, 0
  908c1f:	8a23      	l32i.n	a10, a2, 12
  908c21:	ded0      	mov.n	a14, a13
  908c23:	5bffae        	call8	908adc <wmi_cmd_rsp>
  908c26:	d10f      	retw.n

00908c28 <ath_rx_stats_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
}

static void ath_rx_stats_tgt(void *Context,A_UINT16 Command, A_UINT16 SeqNo,
			     A_UINT8 *data, a_int32_t datalen)
{
  908c28:	6c1006        	entry	a1, 48
		a_uint32_t   ast_rx_done;
	};

	struct fusion_stats stats;

	stats.ast_rx_nobuf = sc->sc_rx_stats.ast_rx_nobuf;
  908c2b:	28227c        	l32i	a8, a2, 0x1f0
	stats.ast_rx_send = sc->sc_rx_stats.ast_rx_send;
	stats.ast_rx_done = sc->sc_rx_stats.ast_rx_done;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  908c2e:	8a23      	l32i.n	a10, a2, 12
		a_uint32_t   ast_rx_done;
	};

	struct fusion_stats stats;

	stats.ast_rx_nobuf = sc->sc_rx_stats.ast_rx_nobuf;
  908c30:	9810      	s32i.n	a8, a1, 0
	stats.ast_rx_send = sc->sc_rx_stats.ast_rx_send;
  908c32:	28227d        	l32i	a8, a2, 0x1f4
	stats.ast_rx_done = sc->sc_rx_stats.ast_rx_done;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  908c35:	030b4f        	extui	a11, a3, 0, 16
	};

	struct fusion_stats stats;

	stats.ast_rx_nobuf = sc->sc_rx_stats.ast_rx_nobuf;
	stats.ast_rx_send = sc->sc_rx_stats.ast_rx_send;
  908c38:	9811      	s32i.n	a8, a1, 4
	stats.ast_rx_done = sc->sc_rx_stats.ast_rx_done;
  908c3a:	28227e        	l32i	a8, a2, 0x1f8

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  908c3d:	040c4f        	extui	a12, a4, 0, 16
  908c40:	dd10      	mov.n	a13, a1
  908c42:	c0ec      	movi.n	a14, 12

	struct fusion_stats stats;

	stats.ast_rx_nobuf = sc->sc_rx_stats.ast_rx_nobuf;
	stats.ast_rx_send = sc->sc_rx_stats.ast_rx_send;
	stats.ast_rx_done = sc->sc_rx_stats.ast_rx_done;
  908c44:	9812      	s32i.n	a8, a1, 8

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  908c46:	5bffa5        	call8	908adc <wmi_cmd_rsp>
  908c49:	d10f      	retw.n
	...

00908c4c <ath_tx_stats_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
}

static void ath_tx_stats_tgt(void *Context,A_UINT16 Command, A_UINT16 SeqNo,
			     A_UINT8 *data, a_int32_t datalen)
{
  908c4c:	6c100a        	entry	a1, 80
		a_uint32_t   tx_nobufs;
	};

	struct fusion_stats stats;

	stats.ast_tx_xretries = sc->sc_tx_stats.ast_tx_xretries;
  908c4f:	282252        	l32i	a8, a2, 0x148
	stats.ast_tx_longretry = sc->sc_tx_stats.ast_tx_longretry;
	stats.tx_qnull = sc->sc_tx_stats.tx_qnull;
	stats.tx_noskbs = sc->sc_tx_stats.tx_noskbs;
	stats.tx_nobufs = sc->sc_tx_stats.tx_nobufs;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  908c52:	8a23      	l32i.n	a10, a2, 12
		a_uint32_t   tx_nobufs;
	};

	struct fusion_stats stats;

	stats.ast_tx_xretries = sc->sc_tx_stats.ast_tx_xretries;
  908c54:	9810      	s32i.n	a8, a1, 0
	stats.ast_tx_fifoerr = sc->sc_tx_stats.ast_tx_fifoerr;
  908c56:	282253        	l32i	a8, a2, 0x14c
	stats.ast_tx_longretry = sc->sc_tx_stats.ast_tx_longretry;
	stats.tx_qnull = sc->sc_tx_stats.tx_qnull;
	stats.tx_noskbs = sc->sc_tx_stats.tx_noskbs;
	stats.tx_nobufs = sc->sc_tx_stats.tx_nobufs;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  908c59:	030b4f        	extui	a11, a3, 0, 16
	};

	struct fusion_stats stats;

	stats.ast_tx_xretries = sc->sc_tx_stats.ast_tx_xretries;
	stats.ast_tx_fifoerr = sc->sc_tx_stats.ast_tx_fifoerr;
  908c5c:	9811      	s32i.n	a8, a1, 4
	stats.ast_tx_filtered = sc->sc_tx_stats.ast_tx_filtered;
  908c5e:	282254        	l32i	a8, a2, 0x150
	stats.ast_tx_longretry = sc->sc_tx_stats.ast_tx_longretry;
	stats.tx_qnull = sc->sc_tx_stats.tx_qnull;
	stats.tx_noskbs = sc->sc_tx_stats.tx_noskbs;
	stats.tx_nobufs = sc->sc_tx_stats.tx_nobufs;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  908c61:	040c4f        	extui	a12, a4, 0, 16

	struct fusion_stats stats;

	stats.ast_tx_xretries = sc->sc_tx_stats.ast_tx_xretries;
	stats.ast_tx_fifoerr = sc->sc_tx_stats.ast_tx_fifoerr;
	stats.ast_tx_filtered = sc->sc_tx_stats.ast_tx_filtered;
  908c64:	9812      	s32i.n	a8, a1, 8
	stats.ast_tx_timer_exp = sc->sc_tx_stats.ast_tx_timer_exp;
  908c66:	282255        	l32i	a8, a2, 0x154
	stats.ast_tx_longretry = sc->sc_tx_stats.ast_tx_longretry;
	stats.tx_qnull = sc->sc_tx_stats.tx_qnull;
	stats.tx_noskbs = sc->sc_tx_stats.tx_noskbs;
	stats.tx_nobufs = sc->sc_tx_stats.tx_nobufs;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  908c69:	dd10      	mov.n	a13, a1
	struct fusion_stats stats;

	stats.ast_tx_xretries = sc->sc_tx_stats.ast_tx_xretries;
	stats.ast_tx_fifoerr = sc->sc_tx_stats.ast_tx_fifoerr;
	stats.ast_tx_filtered = sc->sc_tx_stats.ast_tx_filtered;
	stats.ast_tx_timer_exp = sc->sc_tx_stats.ast_tx_timer_exp;
  908c6b:	9813      	s32i.n	a8, a1, 12
	stats.ast_tx_shortretry = sc->sc_tx_stats.ast_tx_shortretry;
  908c6d:	282256        	l32i	a8, a2, 0x158
	stats.ast_tx_longretry = sc->sc_tx_stats.ast_tx_longretry;
	stats.tx_qnull = sc->sc_tx_stats.tx_qnull;
	stats.tx_noskbs = sc->sc_tx_stats.tx_noskbs;
	stats.tx_nobufs = sc->sc_tx_stats.tx_nobufs;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  908c70:	c2e4      	movi.n	a14, 36

	stats.ast_tx_xretries = sc->sc_tx_stats.ast_tx_xretries;
	stats.ast_tx_fifoerr = sc->sc_tx_stats.ast_tx_fifoerr;
	stats.ast_tx_filtered = sc->sc_tx_stats.ast_tx_filtered;
	stats.ast_tx_timer_exp = sc->sc_tx_stats.ast_tx_timer_exp;
	stats.ast_tx_shortretry = sc->sc_tx_stats.ast_tx_shortretry;
  908c72:	9814      	s32i.n	a8, a1, 16
	stats.ast_tx_longretry = sc->sc_tx_stats.ast_tx_longretry;
  908c74:	282257        	l32i	a8, a2, 0x15c
  908c77:	9815      	s32i.n	a8, a1, 20
	stats.tx_qnull = sc->sc_tx_stats.tx_qnull;
  908c79:	28225c        	l32i	a8, a2, 0x170
  908c7c:	9816      	s32i.n	a8, a1, 24
	stats.tx_noskbs = sc->sc_tx_stats.tx_noskbs;
  908c7e:	282276        	l32i	a8, a2, 0x1d8
  908c81:	9817      	s32i.n	a8, a1, 28
	stats.tx_nobufs = sc->sc_tx_stats.tx_nobufs;
  908c83:	282277        	l32i	a8, a2, 0x1dc
  908c86:	281608        	s32i	a8, a1, 32

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  908c89:	5bff94        	call8	908adc <wmi_cmd_rsp>
  908c8c:	d10f      	retw.n
	...

00908c90 <ath_int_stats_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_int_stats_tgt(void *Context,A_UINT16 Command, A_UINT16 SeqNo,
			      A_UINT8 *data, a_int32_t datalen)
{
  908c90:	6c1008        	entry	a1, 64
		a_uint32_t ast_cst;
	};

	struct fusion_stats stats;

	stats.ast_rx = sc->sc_int_stats.ast_rx;
  908c93:	28224c        	l32i	a8, a2, 0x130
	stats.ast_rxeol = sc->sc_int_stats.ast_rxeol;
	stats.ast_txurn = sc->sc_int_stats.ast_txurn;
	stats.ast_txto = sc->sc_int_stats.ast_txto;
	stats.ast_cst = sc->sc_int_stats.ast_cst;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  908c96:	8a23      	l32i.n	a10, a2, 12
		a_uint32_t ast_cst;
	};

	struct fusion_stats stats;

	stats.ast_rx = sc->sc_int_stats.ast_rx;
  908c98:	9810      	s32i.n	a8, a1, 0
	stats.ast_rxorn = sc->sc_int_stats.ast_rxorn;
  908c9a:	28224d        	l32i	a8, a2, 0x134
	stats.ast_rxeol = sc->sc_int_stats.ast_rxeol;
	stats.ast_txurn = sc->sc_int_stats.ast_txurn;
	stats.ast_txto = sc->sc_int_stats.ast_txto;
	stats.ast_cst = sc->sc_int_stats.ast_cst;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  908c9d:	030b4f        	extui	a11, a3, 0, 16
	};

	struct fusion_stats stats;

	stats.ast_rx = sc->sc_int_stats.ast_rx;
	stats.ast_rxorn = sc->sc_int_stats.ast_rxorn;
  908ca0:	9811      	s32i.n	a8, a1, 4
	stats.ast_rxeol = sc->sc_int_stats.ast_rxeol;
  908ca2:	28224e        	l32i	a8, a2, 0x138
	stats.ast_txurn = sc->sc_int_stats.ast_txurn;
	stats.ast_txto = sc->sc_int_stats.ast_txto;
	stats.ast_cst = sc->sc_int_stats.ast_cst;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  908ca5:	040c4f        	extui	a12, a4, 0, 16

	struct fusion_stats stats;

	stats.ast_rx = sc->sc_int_stats.ast_rx;
	stats.ast_rxorn = sc->sc_int_stats.ast_rxorn;
	stats.ast_rxeol = sc->sc_int_stats.ast_rxeol;
  908ca8:	9812      	s32i.n	a8, a1, 8
	stats.ast_txurn = sc->sc_int_stats.ast_txurn;
  908caa:	28224f        	l32i	a8, a2, 0x13c
	stats.ast_txto = sc->sc_int_stats.ast_txto;
	stats.ast_cst = sc->sc_int_stats.ast_cst;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  908cad:	dd10      	mov.n	a13, a1
	struct fusion_stats stats;

	stats.ast_rx = sc->sc_int_stats.ast_rx;
	stats.ast_rxorn = sc->sc_int_stats.ast_rxorn;
	stats.ast_rxeol = sc->sc_int_stats.ast_rxeol;
	stats.ast_txurn = sc->sc_int_stats.ast_txurn;
  908caf:	9813      	s32i.n	a8, a1, 12
	stats.ast_txto = sc->sc_int_stats.ast_txto;
  908cb1:	282250        	l32i	a8, a2, 0x140
	stats.ast_cst = sc->sc_int_stats.ast_cst;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  908cb4:	c1e8      	movi.n	a14, 24

	stats.ast_rx = sc->sc_int_stats.ast_rx;
	stats.ast_rxorn = sc->sc_int_stats.ast_rxorn;
	stats.ast_rxeol = sc->sc_int_stats.ast_rxeol;
	stats.ast_txurn = sc->sc_int_stats.ast_txurn;
	stats.ast_txto = sc->sc_int_stats.ast_txto;
  908cb6:	9814      	s32i.n	a8, a1, 16
	stats.ast_cst = sc->sc_int_stats.ast_cst;
  908cb8:	282251        	l32i	a8, a2, 0x144
  908cbb:	9815      	s32i.n	a8, a1, 20

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  908cbd:	5bff87        	call8	908adc <wmi_cmd_rsp>
  908cc0:	d10f      	retw.n
	...

00908cc4 <ath_node_update_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_node_update_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  908cc4:	6c1004        	entry	a1, 32

	node->ni_htcap = adf_os_ntohs(node->ni_htcap);
	node->ni_flags = adf_os_ntohs(node->ni_flags);
	node->ni_maxampdu = adf_os_ntohs(node->ni_maxampdu);

	adf_os_mem_copy(&(sc->sc_sta[node_index].ni), node,
  908cc7:	29500c        	l8ui	a9, a5, 12
  908cca:	265a30        	movi	a6, 0x530
  908ccd:	0a9711        	slli	a7, a9, 6
  908cd0:	a977      	add.n	a7, a7, a9
  908cd2:	097909        	addx2	a9, a7, a9
  908cd5:	0e9711        	slli	a7, a9, 2
  908cd8:	a67a      	add.n	a10, a7, a6
  908cda:	aa2a      	add.n	a10, a2, a10
  908cdc:	db50      	mov.n	a11, a5
  908cde:	b8aa      	addi.n	a10, a10, 8
  908ce0:	c1c6      	movi.n	a12, 22
  908ce2:	5bfba3        	call8	907b70 <__adf_os_mem_copy>
			NODE_TARGET_SIZE);

	vap_index = sc->sc_sta[node_index].ni.ni_vapindex;
	sc->sc_sta[node_index].ni.ni_vap = &(sc->sc_vap[vap_index].av_vap);
  908ce5:	a728      	add.n	a8, a2, a7
	node->ni_maxampdu = adf_os_ntohs(node->ni_maxampdu);

	adf_os_mem_copy(&(sc->sc_sta[node_index].ni), node,
			NODE_TARGET_SIZE);

	vap_index = sc->sc_sta[node_index].ni.ni_vapindex;
  908ce7:	a686      	add.n	a6, a8, a6
	sc->sc_sta[node_index].ni.ni_vap = &(sc->sc_vap[vap_index].av_vap);
  908ce9:	256015        	l8ui	a5, a6, 21
  908cec:	275a50        	movi	a7, 0x550
  908cef:	0c5611        	slli	a6, a5, 4
  908cf2:	a565      	add.n	a5, a6, a5
  908cf4:	166a17        	l32r	a6, 8e3550 <_HIFusb_start+0xb0>
  908cf7:	a787      	add.n	a7, a8, a7
  908cf9:	06550a        	addx4	a5, a5, a6
  908cfc:	a525      	add.n	a5, a2, a5
  908cfe:	b855      	addi.n	a5, a5, 8
  908d00:	9572      	s32i.n	a5, a7, 8

	sc->sc_sta[node_index].ni.ni_txseqmgmt = 0;
  908d02:	255a40        	movi	a5, 0x540
  908d05:	a588      	add.n	a8, a8, a5
	sc->sc_sta[node_index].ni.ni_iv16 = 0;
	sc->sc_sta[node_index].ni.ni_iv32 = 0;
  908d07:	c0e0      	movi.n	a14, 0
			NODE_TARGET_SIZE);

	vap_index = sc->sc_sta[node_index].ni.ni_vapindex;
	sc->sc_sta[node_index].ni.ni_vap = &(sc->sc_vap[vap_index].av_vap);

	sc->sc_sta[node_index].ni.ni_txseqmgmt = 0;
  908d09:	c050      	movi.n	a5, 0
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_node_update_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  908d0b:	03034f        	extui	a3, a3, 0, 16
  908d0e:	04044f        	extui	a4, a4, 0, 16

	sc->sc_sta[node_index].ni.ni_txseqmgmt = 0;
	sc->sc_sta[node_index].ni.ni_iv16 = 0;
	sc->sc_sta[node_index].ni.ni_iv32 = 0;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  908d11:	8a23      	l32i.n	a10, a2, 12
			NODE_TARGET_SIZE);

	vap_index = sc->sc_sta[node_index].ni.ni_vapindex;
	sc->sc_sta[node_index].ni.ni_vap = &(sc->sc_vap[vap_index].av_vap);

	sc->sc_sta[node_index].ni.ni_txseqmgmt = 0;
  908d13:	258508        	s16i	a5, a8, 16
	sc->sc_sta[node_index].ni.ni_iv16 = 0;
  908d16:	258509        	s16i	a5, a8, 18
	sc->sc_sta[node_index].ni.ni_iv32 = 0;
  908d19:	9e85      	s32i.n	a14, a8, 20

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  908d1b:	db30      	mov.n	a11, a3
  908d1d:	dc40      	mov.n	a12, a4
  908d1f:	dde0      	mov.n	a13, a14
  908d21:	5bff6e        	call8	908adc <wmi_cmd_rsp>
  908d24:	d10f      	retw.n
	...

00908d28 <ath_detach_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_detach_tgt(void *Context, A_UINT16 Command, A_UINT16 SeqNo,
				 A_UINT8 *data, a_int32_t datalen)
{
  908d28:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  908d2b:	252d05        	addmi	a5, a2, 0x500
  908d2e:	855b      	l32i.n	a5, a5, 44

	ath_desc_free(sc);
  908d30:	022a02        	or	a10, a2, a2
  908d33:	5bfd03        	call8	908140 <ath_desc_free>
	ah->ah_detach(ah);
  908d36:	8856      	l32i.n	a8, a5, 24
  908d38:	da50      	mov.n	a10, a5
  908d3a:	0b8000        	callx8	a8
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_detach_tgt(void *Context, A_UINT16 Command, A_UINT16 SeqNo,
				 A_UINT8 *data, a_int32_t datalen)
{
  908d3d:	03034f        	extui	a3, a3, 0, 16
  908d40:	04044f        	extui	a4, a4, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;

	ath_desc_free(sc);
	ah->ah_detach(ah);
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  908d43:	c0d0      	movi.n	a13, 0
  908d45:	8a23      	l32i.n	a10, a2, 12
  908d47:	db30      	mov.n	a11, a3
  908d49:	dc40      	mov.n	a12, a4
  908d4b:	ded0      	mov.n	a14, a13
  908d4d:	5bff63        	call8	908adc <wmi_cmd_rsp>
  908d50:	d10f      	retw.n
	...

00908d54 <ath_enable_aggr_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &ver, sizeof(ver));
}

static void ath_enable_aggr_tgt(void *Context,A_UINT16 Command, A_UINT16 SeqNo,
				A_UINT8 *data, a_int32_t datalen)
{
  908d54:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_aggr_info *aggr = (struct ath_aggr_info *)data;
	a_uint8_t nodeindex = aggr->nodeindex;
  908d57:	2d5000        	l8ui	a13, a5, 0
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &ver, sizeof(ver));
}

static void ath_enable_aggr_tgt(void *Context,A_UINT16 Command, A_UINT16 SeqNo,
				A_UINT8 *data, a_int32_t datalen)
{
  908d5a:	03034f        	extui	a3, a3, 0, 16
  908d5d:	04044f        	extui	a4, a4, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_aggr_info *aggr = (struct ath_aggr_info *)data;
	a_uint8_t nodeindex = aggr->nodeindex;
	a_uint8_t tidno = aggr->tidno;
  908d60:	285001        	l8ui	a8, a5, 1
	struct ath_node_target *an = NULL ;
	struct ath_atx_tid  *tid = NULL;

	if (nodeindex >= TARGET_NODE_MAX) {
  908d63:	6fd866        	bgeui	a13, 8, 908dcd <ath_enable_aggr_tgt+0x79>
		goto done;
	}

	an = &sc->sc_sta[nodeindex];
  908d66:	0adb11        	slli	a11, a13, 6
  908d69:	adbb      	add.n	a11, a11, a13
  908d6b:	295a30        	movi	a9, 0x530
  908d6e:	0dbb09        	addx2	a11, a11, a13
  908d71:	09bb0a        	addx4	a11, a11, a9
  908d74:	ab2b      	add.n	a11, a2, a11
  908d76:	b8bb      	addi.n	a11, a11, 8
	if (!an->an_valid) {
  908d78:	29bd02        	addmi	a9, a11, 0x200
  908d7b:	299004        	l8ui	a9, a9, 4
  908d7e:	64904b        	beqz	a9, 908dcd <ath_enable_aggr_tgt+0x79>
		goto done;
	}

	if (tidno >= WME_NUM_TID) {
  908d81:	6e8813        	bltui	a8, 8, 908d98 <ath_enable_aggr_tgt+0x44>
		adf_os_print("[%s] enable_aggr with invalid tid %d(node = %d)\n",
  908d84:	156915        	l32r	a5, 8e31d8 <athos_indirection_table_install+0x1c64>
  908d87:	1b6a19        	l32r	a11, 8e35ec <_HIFusb_start+0x14c>
  908d8a:	255212        	l32i	a5, a5, 72
  908d8d:	1a6a18        	l32r	a10, 8e35f0 <_HIFusb_start+0x150>
  908d90:	dc80      	mov.n	a12, a8
  908d92:	0b5000        	callx8	a5
			     __FUNCTION__, tidno, nodeindex);
		goto done;
  908d95:	600034        	j	908dcd <ath_enable_aggr_tgt+0x79>
	}

	tid = ATH_AN_2_TID(an, tidno);
  908d98:	0c8c11        	slli	a12, a8, 4
  908d9b:	08cc0c        	sub	a12, a12, a8

	if (aggr->aggr_enable) {
  908d9e:	255002        	l8ui	a5, a5, 2
		adf_os_print("[%s] enable_aggr with invalid tid %d(node = %d)\n",
			     __FUNCTION__, tidno, nodeindex);
		goto done;
	}

	tid = ATH_AN_2_TID(an, tidno);
  908da1:	0bcc0a        	addx4	a12, a12, a11
  908da4:	2ccc24        	addi	a12, a12, 36
  908da7:	c082      	movi.n	a8, 2

	if (aggr->aggr_enable) {
  908da9:	c85b      	beqz.n	a5, 908db8 <ath_enable_aggr_tgt+0x64>
		tid->flag |= TID_AGGR_ENABLED;
  908dab:	25c036        	l8ui	a5, a12, 54
  908dae:	085802        	or	a8, a5, a8
  908db1:	28c436        	s8i	a8, a12, 54
  908db4:	600015        	j	908dcd <ath_enable_aggr_tgt+0x79>
  908db7:	0025c0        	excw
	} else if ( tid->flag & TID_AGGR_ENABLED ) {
  908dba:	367850        	excw
  908dbd:	0ec78d        	excw
		tid->flag &= ~TID_AGGR_ENABLED;
  908dc0:	085501        	and	a5, a5, a8
  908dc3:	25c436        	s8i	a5, a12, 54
		ath_tgt_tx_cleanup(sc, an, tid, 1);
  908dc6:	da20      	mov.n	a10, a2
  908dc8:	c0d1      	movi.n	a13, 1
  908dca:	5817f8        	call8	90edac <ath_tgt_tx_cleanup>
	}
done:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  908dcd:	c0d0      	movi.n	a13, 0
  908dcf:	8a23      	l32i.n	a10, a2, 12
  908dd1:	db30      	mov.n	a11, a3
  908dd3:	dc40      	mov.n	a12, a4
  908dd5:	ded0      	mov.n	a14, a13
  908dd7:	5bff41        	call8	908adc <wmi_cmd_rsp>
  908dda:	d10f      	retw.n

00908ddc <ath_ic_update_tgt>:
}

static void ath_ic_update_tgt(void *Context,A_UINT16 Command, A_UINT16 SeqNo,
			      A_UINT8 *data, a_int32_t datalen)
{
  908ddc:	6c1004        	entry	a1, 32
  908ddf:	1a6a1a        	l32r	a10, 8e3648 <_HIFusb_start+0x1a8>
  908de2:	db50      	mov.n	a11, a5
  908de4:	0a2a08        	add	a10, a2, a10
  908de7:	c0c8      	movi.n	a12, 8
  908de9:	5bfb61        	call8	907b70 <__adf_os_mem_copy>
	struct ieee80211com_target *ic = (struct ieee80211com_target * )data;
	struct ieee80211com_target *ictgt = &sc->sc_ic ;

	adf_os_mem_copy(ictgt, ic, sizeof(struct  ieee80211com_target));

	ictgt->ic_ampdu_limit         = adf_os_ntohl(ic->ic_ampdu_limit);
  908dec:	8850      	l32i.n	a8, a5, 0
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_ic_update_tgt(void *Context,A_UINT16 Command, A_UINT16 SeqNo,
			      A_UINT8 *data, a_int32_t datalen)
{
  908dee:	03034f        	extui	a3, a3, 0, 16
  908df1:	04044f        	extui	a4, a4, 0, 16
	struct ieee80211com_target *ic = (struct ieee80211com_target * )data;
	struct ieee80211com_target *ictgt = &sc->sc_ic ;

	adf_os_mem_copy(ictgt, ic, sizeof(struct  ieee80211com_target));

	ictgt->ic_ampdu_limit         = adf_os_ntohl(ic->ic_ampdu_limit);
  908df4:	252d16        	addmi	a5, a2, 0x1600

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  908df7:	c0d0      	movi.n	a13, 0
  908df9:	8a23      	l32i.n	a10, a2, 12
	struct ieee80211com_target *ic = (struct ieee80211com_target * )data;
	struct ieee80211com_target *ictgt = &sc->sc_ic ;

	adf_os_mem_copy(ictgt, ic, sizeof(struct  ieee80211com_target));

	ictgt->ic_ampdu_limit         = adf_os_ntohl(ic->ic_ampdu_limit);
  908dfb:	9858      	s32i.n	a8, a5, 32

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  908dfd:	db30      	mov.n	a11, a3
  908dff:	dc40      	mov.n	a12, a4
  908e01:	ded0      	mov.n	a14, a13
  908e03:	5bff36        	call8	908adc <wmi_cmd_rsp>
  908e06:	d10f      	retw.n

00908e08 <handle_rc_rate_update_cmd>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void handle_rc_rate_update_cmd(void *Context, A_UINT16 Command,
				      A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
  908e08:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_rate_update_cmd *wmi_data = (struct wmi_rc_rate_update_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);

	ath_rate_node_update(sc, &sc->sc_sta[wmi_data->node_index],
  908e0b:	285000        	l8ui	a8, a5, 0
				      A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_rate_update_cmd *wmi_data = (struct wmi_rc_rate_update_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);
  908e0e:	2a5004        	l8ui	a10, a5, 4

	ath_rate_node_update(sc, &sc->sc_sta[wmi_data->node_index],
  908e11:	0a8b11        	slli	a11, a8, 6
  908e14:	a8bb      	add.n	a11, a11, a8
  908e16:	08bb09        	addx2	a11, a11, a8
  908e19:	295a30        	movi	a9, 0x530
				      A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_rate_update_cmd *wmi_data = (struct wmi_rc_rate_update_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);
  908e1c:	285005        	l8ui	a8, a5, 5

	ath_rate_node_update(sc, &sc->sc_sta[wmi_data->node_index],
  908e1f:	09bb0a        	addx4	a11, a11, a9
				      A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_rate_update_cmd *wmi_data = (struct wmi_rc_rate_update_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);
  908e22:	295006        	l8ui	a9, a5, 6
  908e25:	08aa10        	slli	a10, a10, 24
  908e28:	008811        	slli	a8, a8, 16
  908e2b:	0a8802        	or	a8, a8, a10
  908e2e:	2d5007        	l8ui	a13, a5, 7
  908e31:	089911        	slli	a9, a9, 8
  908e34:	089902        	or	a9, a9, a8

	ath_rate_node_update(sc, &sc->sc_sta[wmi_data->node_index],
  908e37:	2c5001        	l8ui	a12, a5, 1
  908e3a:	ab2b      	add.n	a11, a2, a11
  908e3c:	09dd02        	or	a13, a13, a9
  908e3f:	b85e      	addi.n	a14, a5, 8
  908e41:	da20      	mov.n	a10, a2
  908e43:	2bbc08        	addi	a11, a11, 8
  908e46:	58100b        	call8	90ce74 <ath_rate_node_update>
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void handle_rc_rate_update_cmd(void *Context, A_UINT16 Command,
				      A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
  908e49:	03034f        	extui	a3, a3, 0, 16
  908e4c:	04044f        	extui	a4, a4, 0, 16
	ath_rate_node_update(sc, &sc->sc_sta[wmi_data->node_index],
			     wmi_data->isNew,
			     capflag,
			     &wmi_data->rs);

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  908e4f:	c0d0      	movi.n	a13, 0
  908e51:	8a23      	l32i.n	a10, a2, 12
  908e53:	db30      	mov.n	a11, a3
  908e55:	dc40      	mov.n	a12, a4
  908e57:	ded0      	mov.n	a14, a13
  908e59:	5bff20        	call8	908adc <wmi_cmd_rsp>
  908e5c:	d10f      	retw.n
	...

00908e60 <handle_rc_state_change_cmd>:
}

static void handle_rc_state_change_cmd(void *Context, A_UINT16 Command,
				       A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)

{
  908e60:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_state_change_cmd *wmi_data = (struct wmi_rc_state_change_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);

	ath_rate_newstate(sc, &sc->sc_vap[wmi_data->vap_index].av_vap,
  908e63:	285000        	l8ui	a8, a5, 0
  908e66:	196a17        	l32r	a9, 8e36c4 <_HIFusb_start+0x224>
  908e69:	0c8b11        	slli	a11, a8, 4

{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_state_change_cmd *wmi_data = (struct wmi_rc_state_change_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);
  908e6c:	2a5004        	l8ui	a10, a5, 4

	ath_rate_newstate(sc, &sc->sc_vap[wmi_data->vap_index].av_vap,
  908e6f:	a8bb      	add.n	a11, a11, a8

{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_state_change_cmd *wmi_data = (struct wmi_rc_state_change_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);
  908e71:	285005        	l8ui	a8, a5, 5

	ath_rate_newstate(sc, &sc->sc_vap[wmi_data->vap_index].av_vap,
  908e74:	09bb0a        	addx4	a11, a11, a9

{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_state_change_cmd *wmi_data = (struct wmi_rc_state_change_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);
  908e77:	295006        	l8ui	a9, a5, 6
  908e7a:	08aa10        	slli	a10, a10, 24
  908e7d:	008811        	slli	a8, a8, 16
  908e80:	0a8802        	or	a8, a8, a10
  908e83:	2d5007        	l8ui	a13, a5, 7
  908e86:	089911        	slli	a9, a9, 8
  908e89:	089902        	or	a9, a9, a8

	ath_rate_newstate(sc, &sc->sc_vap[wmi_data->vap_index].av_vap,
  908e8c:	2c5001        	l8ui	a12, a5, 1
  908e8f:	ab2b      	add.n	a11, a2, a11
  908e91:	09dd02        	or	a13, a13, a9
  908e94:	b85e      	addi.n	a14, a5, 8
  908e96:	da20      	mov.n	a10, a2
  908e98:	b8bb      	addi.n	a11, a11, 8
  908e9a:	580ffb        	call8	90ce88 <ath_rate_newstate>
}

static void handle_rc_state_change_cmd(void *Context, A_UINT16 Command,
				       A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)

{
  908e9d:	03034f        	extui	a3, a3, 0, 16
  908ea0:	04044f        	extui	a4, a4, 0, 16
	ath_rate_newstate(sc, &sc->sc_vap[wmi_data->vap_index].av_vap,
			  wmi_data->vap_state,
			  capflag,
			  &wmi_data->rs);

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  908ea3:	c0d0      	movi.n	a13, 0
  908ea5:	8a23      	l32i.n	a10, a2, 12
  908ea7:	db30      	mov.n	a11, a3
  908ea9:	dc40      	mov.n	a12, a4
  908eab:	ded0      	mov.n	a14, a13
  908ead:	5bff0b        	call8	908adc <wmi_cmd_rsp>
  908eb0:	d10f      	retw.n
	...

00908eb4 <ath_hal_reg_write_tgt>:
	}
}

static void ath_hal_reg_write_tgt(void *Context, A_UINT16 Command,
				  A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  908eb4:	6c1006        	entry	a1, 48
  908eb7:	030b4f        	extui	a11, a3, 0, 16
  908eba:	040c4f        	extui	a12, a4, 0, 16
	struct registerWrite {
		a_uint32_t reg;
		a_uint32_t val;
	}*t;

	for (i = 0; i < datalen; i += sizeof(struct registerWrite)) {
  908ebd:	d750      	mov.n	a7, a5
  908ebf:	60002a        	j	908eed <ath_hal_reg_write_tgt+0x39>
		t = (struct registerWrite *)(data+i);

		ath_hal_reg_write_filter(ah, t->reg, t->val);
  908ec2:	8370      	l32i.n	a3, a7, 0
}

static void ath_hal_reg_write_filter(struct ath_hal *ah,
			a_uint32_t reg, a_uint32_t val)
{
	if(reg > 0xffff) {
  908ec4:	186a07        	l32r	a8, 8e36e0 <_HIFusb_start+0x240>
	}*t;

	for (i = 0; i < datalen; i += sizeof(struct registerWrite)) {
		t = (struct registerWrite *)(data+i);

		ath_hal_reg_write_filter(ah, t->reg, t->val);
  908ec7:	8471      	l32i.n	a4, a7, 4
}

static void ath_hal_reg_write_filter(struct ath_hal *ah,
			a_uint32_t reg, a_uint32_t val)
{
	if(reg > 0xffff) {
  908ec9:	738b03        	bgeu	a8, a3, 908ed0 <ath_hal_reg_write_tgt+0x1c>
  908ecc:	600016        	j	908ee6 <ath_hal_reg_write_tgt+0x32>
  908ecf:	00186a        	excw
				flg = 1;
			}
		}
#endif
	} else {
		if(reg == 0x7014)
  908ed2:	157839        	l32r	a5, 8e6fb8 <memset+0x170>
  908ed5:	0a9b10        	slli	a11, a9, 22
			ath_pll_reset_ones(ah);
  908ed8:	9c11      	s32i.n	a12, a1, 4
  908eda:	5bfc0c        	call8	907f0c <ath_pll_reset_ones$isra$9>
  908edd:	8c11      	l32i.n	a12, a1, 4
  908edf:	8b10      	l32i.n	a11, a1, 0

		iowrite32_mac(reg, val);
  908ee1:	186a02        	l32r	a8, 8e36ec <_HIFusb_isr_handler+0x8>
  908ee4:	a833      	add.n	a3, a3, a8
  908ee6:	0c0200        	memw
  908ee9:	9430      	s32i.n	a4, a3, 0
  908eeb:	b877      	addi.n	a7, a7, 8
	}
}

static void ath_hal_reg_write_tgt(void *Context, A_UINT16 Command,
  908eed:	05730c        	sub	a3, a7, a5
	struct registerWrite {
		a_uint32_t reg;
		a_uint32_t val;
	}*t;

	for (i = 0; i < datalen; i += sizeof(struct registerWrite)) {
  908ef0:	7632ce        	blt	a3, a6, 908ec2 <ath_hal_reg_write_tgt+0xe>
		t = (struct registerWrite *)(data+i);

		ath_hal_reg_write_filter(ah, t->reg, t->val);
	}

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  908ef3:	c0d0      	movi.n	a13, 0
  908ef5:	8a23      	l32i.n	a10, a2, 12
  908ef7:	ded0      	mov.n	a14, a13
  908ef9:	5bfef8        	call8	908adc <wmi_cmd_rsp>
  908efc:	d10f      	retw.n
	...

00908f00 <ath_hal_reg_read_tgt>:
		return ioread32_mac(addr);
}

static void ath_hal_reg_read_tgt(void *Context, A_UINT16 Command,
				 A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  908f00:	6c1016        	entry	a1, 176
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  908f03:	272d05        	addmi	a7, a2, 0x500
  908f06:	887b      	l32i.n	a8, a7, 44
		return ioread32_mac(addr);
}

static void ath_hal_reg_read_tgt(void *Context, A_UINT16 Command,
				 A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  908f08:	03034f        	extui	a3, a3, 0, 16
  908f0b:	04044f        	extui	a4, a4, 0, 16
	struct ath_hal *ah = sc->sc_ah;
	a_uint32_t addr;
	a_uint32_t val[32];
	int i;

	for (i = 0; i < datalen; i += sizeof(a_int32_t)) {
  908f0e:	c070      	movi.n	a7, 0
  908f10:	600019        	j	908f2d <ath_hal_reg_read_tgt+0x2d>
  908f13:	00a759        	extui	a7, a0, 26, 10
		addr = *(a_uint32_t *)(data + i);
		addr = adf_os_ntohl(addr);

		val[i/sizeof(a_int32_t)] =
			adf_os_ntohl(ath_reg_read_filter(ah, addr));
  908f16:	8b90      	l32i.n	a11, a9, 0
  908f18:	da80      	mov.n	a10, a8
  908f1a:	281620        	s32i	a8, a1, 128
  908f1d:	5bfc25        	call8	907fb4 <ath_reg_read_filter>

	for (i = 0; i < datalen; i += sizeof(a_int32_t)) {
		addr = *(a_uint32_t *)(data + i);
		addr = adf_os_ntohl(addr);

		val[i/sizeof(a_int32_t)] =
  908f20:	072914        	srli	a9, a7, 2
  908f23:	01990a        	addx4	a9, a9, a1
	else
		/* MAC registers */
		return ioread32_mac(addr);
}

static void ath_hal_reg_read_tgt(void *Context, A_UINT16 Command,
  908f26:	281220        	l32i	a8, a1, 128

	for (i = 0; i < datalen; i += sizeof(a_int32_t)) {
		addr = *(a_uint32_t *)(data + i);
		addr = adf_os_ntohl(addr);

		val[i/sizeof(a_int32_t)] =
  908f29:	9a90      	s32i.n	a10, a9, 0
	else
		/* MAC registers */
		return ioread32_mac(addr);
}

static void ath_hal_reg_read_tgt(void *Context, A_UINT16 Command,
  908f2b:	b477      	addi.n	a7, a7, 4
	struct ath_hal *ah = sc->sc_ah;
	a_uint32_t addr;
	a_uint32_t val[32];
	int i;

	for (i = 0; i < datalen; i += sizeof(a_int32_t)) {
  908f2d:	7672e3        	blt	a7, a6, 908f14 <ath_hal_reg_read_tgt+0x14>

		val[i/sizeof(a_int32_t)] =
			adf_os_ntohl(ath_reg_read_filter(ah, addr));
	}

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &val[0], datalen);
  908f30:	8a23      	l32i.n	a10, a2, 12
  908f32:	db30      	mov.n	a11, a3
  908f34:	dc40      	mov.n	a12, a4
  908f36:	dd10      	mov.n	a13, a1
  908f38:	de60      	mov.n	a14, a6
  908f3a:	5bfee8        	call8	908adc <wmi_cmd_rsp>
  908f3d:	d10f      	retw.n
	...

00908f40 <ath_vap_create_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_vap_create_tgt(void *Context, A_UINT16 Command, A_UINT16 SeqNo,
			       A_UINT8 *data, a_int32_t datalen)
{
  908f40:	6c1004        	entry	a1, 32
	vap->iv_rtsthreshold    = adf_os_ntohs(vap->iv_rtsthreshold);
	vap->iv_opmode          = adf_os_ntohl(vap->iv_opmode);

	vap_index = vap->iv_vapindex;

	adf_os_assert(sc->sc_vap[vap_index].av_valid == 0);
  908f43:	265000        	l8ui	a6, a5, 0
  908f46:	196a16        	l32r	a9, 8e37a0 <_HIFusb_isr_handler+0xbc>
  908f49:	0c6811        	slli	a8, a6, 4
  908f4c:	a688      	add.n	a8, a8, a6
  908f4e:	02880a        	addx4	a8, a8, a2
  908f51:	a988      	add.n	a8, a8, a9
  908f53:	28800a        	l8ui	a8, a8, 10
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_vap_create_tgt(void *Context, A_UINT16 Command, A_UINT16 SeqNo,
			       A_UINT8 *data, a_int32_t datalen)
{
  908f56:	03034f        	extui	a3, a3, 0, 16
  908f59:	04044f        	extui	a4, a4, 0, 16
	vap->iv_rtsthreshold    = adf_os_ntohs(vap->iv_rtsthreshold);
	vap->iv_opmode          = adf_os_ntohl(vap->iv_opmode);

	vap_index = vap->iv_vapindex;

	adf_os_assert(sc->sc_vap[vap_index].av_valid == 0);
  908f5c:	c985      	beqz.n	a8, 908f75 <ath_vap_create_tgt+0x35>
  908f5e:	186915        	l32r	a8, 8e33b4 <athos_indirection_table_install+0x1e40>
  908f61:	1a69f6        	l32r	a10, 8e373c <_HIFusb_isr_handler+0x58>
  908f64:	288212        	l32i	a8, a8, 72
  908f67:	1b6a1b        	l32r	a11, 8e37d4 <_HIFusb_isr_handler+0xf0>
  908f6a:	0b8000        	callx8	a8
  908f6d:	18697a        	l32r	a8, 8e3558 <_HIFusb_start+0xb8>
  908f70:	0c0200        	memw
  908f73:	8880      	l32i.n	a8, a8, 0

	adf_os_mem_copy(&(sc->sc_vap[vap_index].av_vap), vap,
  908f75:	0c6811        	slli	a8, a6, 4
  908f78:	a686      	add.n	a6, a8, a6
  908f7a:	1a6a17        	l32r	a10, 8e37d8 <_HIFusb_isr_handler+0xf4>
  908f7d:	0e6611        	slli	a6, a6, 2
  908f80:	aa6a      	add.n	a10, a6, a10
  908f82:	aa2a      	add.n	a10, a2, a10
  908f84:	db50      	mov.n	a11, a5
  908f86:	b8aa      	addi.n	a10, a10, 8
  908f88:	c0cc      	movi.n	a12, 12
  908f8a:	5bfaf9        	call8	907b70 <__adf_os_mem_copy>
			VAP_TARGET_SIZE);

	sc->sc_vap[vap_index].av_bcbuf = asf_tailq_first(&(sc->sc_bbuf));
  908f8d:	282d16        	addmi	a8, a2, 0x1600
  908f90:	156a1c        	l32r	a5, 8e3800 <HIFusb_DescTraceDump+0x18>
  908f93:	a626      	add.n	a6, a2, a6
  908f95:	888a      	l32i.n	a8, a8, 40
  908f97:	a565      	add.n	a5, a6, a5
  908f99:	9853      	s32i.n	a8, a5, 12
	sc->sc_vap[vap_index].av_valid = 1;
  908f9b:	156a16        	l32r	a5, 8e37f4 <HIFusb_DescTraceDump+0xc>

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  908f9e:	c0d0      	movi.n	a13, 0

	adf_os_mem_copy(&(sc->sc_vap[vap_index].av_vap), vap,
			VAP_TARGET_SIZE);

	sc->sc_vap[vap_index].av_bcbuf = asf_tailq_first(&(sc->sc_bbuf));
	sc->sc_vap[vap_index].av_valid = 1;
  908fa0:	a566      	add.n	a6, a6, a5
  908fa2:	c051      	movi.n	a5, 1
  908fa4:	25640a        	s8i	a5, a6, 10

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  908fa7:	8a23      	l32i.n	a10, a2, 12
  908fa9:	db30      	mov.n	a11, a3
  908fab:	dc40      	mov.n	a12, a4
  908fad:	ded0      	mov.n	a14, a13
  908faf:	5bfecb        	call8	908adc <wmi_cmd_rsp>
  908fb2:	d10f      	retw.n

00908fb4 <ath_vap_delete_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_vap_delete_tgt(void *Context, A_UINT16 Command,
			       A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  908fb4:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	a_uint8_t vap_index;

	vap_index = *(a_uint8_t *)data;
  908fb7:	295000        	l8ui	a9, a5, 0
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_vap_delete_tgt(void *Context, A_UINT16 Command,
			       A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  908fba:	030b4f        	extui	a11, a3, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	a_uint8_t vap_index;

	vap_index = *(a_uint8_t *)data;

	sc->sc_vap[vap_index].av_valid = 0;
  908fbd:	0c9811        	slli	a8, a9, 4
  908fc0:	a988      	add.n	a8, a8, a9
  908fc2:	136a16        	l32r	a3, 8e381c <HIFusb_DescTraceDump+0x34>
  908fc5:	02880a        	addx4	a8, a8, a2
  908fc8:	a383      	add.n	a3, a8, a3
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_vap_delete_tgt(void *Context, A_UINT16 Command,
			       A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  908fca:	040c4f        	extui	a12, a4, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	a_uint8_t vap_index;

	vap_index = *(a_uint8_t *)data;

	sc->sc_vap[vap_index].av_valid = 0;
  908fcd:	c040      	movi.n	a4, 0
  908fcf:	24340a        	s8i	a4, a3, 10
	sc->sc_vap[vap_index].av_bcbuf = NULL;
  908fd2:	136a1c        	l32r	a3, 8e3844 <HIFusb_DescTraceDump+0x5c>

static void ath_node_vdelete_tgt(struct ath_softc_tgt *sc, a_uint8_t vap_index)
{
	a_int32_t i;

	for (i = 0; i < TARGET_NODE_MAX; i++) {
  908fd5:	1d6a1d        	l32r	a13, 8e384c <HIFusb_DescTraceDump+0x64>
	a_uint8_t vap_index;

	vap_index = *(a_uint8_t *)data;

	sc->sc_vap[vap_index].av_valid = 0;
	sc->sc_vap[vap_index].av_bcbuf = NULL;
  908fd8:	a383      	add.n	a3, a8, a3
  908fda:	c080      	movi.n	a8, 0
  908fdc:	9833      	s32i.n	a8, a3, 12
		ath_hal_reg_write_filter(ah, buf->reg, val);
	}
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_vap_delete_tgt(void *Context, A_UINT16 Command,
  908fde:	2f5a45        	movi	a15, 0x545
  908fe1:	237a3c        	movi	a3, 0x73c
{
	a_int32_t i;

	for (i = 0; i < TARGET_NODE_MAX; i++) {
		if(sc->sc_sta[i].ni.ni_vapindex == vap_index)
			sc->sc_sta[i].an_valid = 0;
  908fe4:	d480      	mov.n	a4, a8
  908fe6:	2e2a0c        	movi	a14, 0x20c
		ath_hal_reg_write_filter(ah, buf->reg, val);
	}
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_vap_delete_tgt(void *Context, A_UINT16 Command,
  908fe9:	a82a      	add.n	a10, a2, a8
  908feb:	afa5      	add.n	a5, a10, a15
static void ath_node_vdelete_tgt(struct ath_softc_tgt *sc, a_uint8_t vap_index)
{
	a_int32_t i;

	for (i = 0; i < TARGET_NODE_MAX; i++) {
		if(sc->sc_sta[i].ni.ni_vapindex == vap_index)
  908fed:	255000        	l8ui	a5, a5, 0
  908ff0:	795904        	bne	a5, a9, 908ff8 <ath_vap_delete_tgt+0x44>
		ath_hal_reg_write_filter(ah, buf->reg, val);
	}
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_vap_delete_tgt(void *Context, A_UINT16 Command,
  908ff3:	a3aa      	add.n	a10, a10, a3
{
	a_int32_t i;

	for (i = 0; i < TARGET_NODE_MAX; i++) {
		if(sc->sc_sta[i].ni.ni_vapindex == vap_index)
			sc->sc_sta[i].an_valid = 0;
  908ff5:	24a400        	s8i	a4, a10, 0
  908ff8:	ae88      	add.n	a8, a8, a14

static void ath_node_vdelete_tgt(struct ath_softc_tgt *sc, a_uint8_t vap_index)
{
	a_int32_t i;

	for (i = 0; i < TARGET_NODE_MAX; i++) {
  908ffa:	7d89eb        	bne	a8, a13, 908fe9 <ath_vap_delete_tgt+0x35>
	vap_index = *(a_uint8_t *)data;

	sc->sc_vap[vap_index].av_valid = 0;
	sc->sc_vap[vap_index].av_bcbuf = NULL;
	ath_node_vdelete_tgt(sc, vap_index);
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  908ffd:	c0d0      	movi.n	a13, 0
  908fff:	8a23      	l32i.n	a10, a2, 12
  909001:	ded0      	mov.n	a14, a13
  909003:	5bfeb6        	call8	908adc <wmi_cmd_rsp>
  909006:	d10f      	retw.n

00909008 <ath_node_cleanup_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_node_cleanup_tgt(void *Context, A_UINT16 Command,
				 A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  909008:	6c1004        	entry	a1, 32
	a_uint8_t node_index;
	a_uint8_t *nodedata;

	nodedata = (a_uint8_t *)data;
	node_index = *nodedata;
	sc->sc_sta[node_index].an_valid = 0;
  90900b:	285000        	l8ui	a8, a5, 0

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  90900e:	c0d0      	movi.n	a13, 0
	a_uint8_t node_index;
	a_uint8_t *nodedata;

	nodedata = (a_uint8_t *)data;
	node_index = *nodedata;
	sc->sc_sta[node_index].an_valid = 0;
  909010:	0a8911        	slli	a9, a8, 6
  909013:	a899      	add.n	a9, a9, a8
  909015:	089809        	addx2	a8, a9, a8
  909018:	02880a        	addx4	a8, a8, a2
  90901b:	297a30        	movi	a9, 0x730
  90901e:	a988      	add.n	a8, a8, a9
  909020:	c090      	movi.n	a9, 0
  909022:	29840c        	s8i	a9, a8, 12

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  909025:	8a23      	l32i.n	a10, a2, 12
  909027:	030b4f        	extui	a11, a3, 0, 16
  90902a:	040c4f        	extui	a12, a4, 0, 16
  90902d:	ded0      	mov.n	a14, a13
  90902f:	5bfeab        	call8	908adc <wmi_cmd_rsp>
  909032:	d10f      	retw.n

00909034 <ath_node_create_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_node_create_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  909034:	6c1004        	entry	a1, 32
	a_uint8_t vap_index;
	a_uint8_t node_index;

	node = (struct ieee80211_node_target *)data;

	node_index = node->ni_nodeindex;
  909037:	26500c        	l8ui	a6, a5, 12
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_node_create_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  90903a:	db50      	mov.n	a11, a5

	node->ni_htcap = adf_os_ntohs(node->ni_htcap);
	node->ni_flags = adf_os_ntohs(node->ni_flags);
	node->ni_maxampdu = adf_os_ntohs(node->ni_maxampdu);

	adf_os_mem_copy(&(sc->sc_sta[node_index].ni), node,
  90903c:	0a6511        	slli	a5, a6, 6
  90903f:	a655      	add.n	a5, a5, a6
  909041:	065509        	addx2	a5, a5, a6
  909044:	0e5511        	slli	a5, a5, 2
  909047:	275a30        	movi	a7, 0x530
  90904a:	a75a      	add.n	a10, a5, a7
  90904c:	aa2a      	add.n	a10, a2, a10
  90904e:	b8aa      	addi.n	a10, a10, 8
			NODE_TARGET_SIZE);

    	vap_index = sc->sc_sta[node_index].ni.ni_vapindex;
  909050:	a525      	add.n	a5, a2, a5
  909052:	2c0a16        	movi	a12, 22
  909055:	5bfac6        	call8	907b70 <__adf_os_mem_copy>
  909058:	a757      	add.n	a7, a5, a7
	sc->sc_sta[node_index].ni.ni_vap = &(sc->sc_vap[vap_index].av_vap);
  90905a:	287015        	l8ui	a8, a7, 21
  90905d:	295a50        	movi	a9, 0x550
  909060:	a955      	add.n	a5, a5, a9
  909062:	0c8911        	slli	a9, a8, 4
  909065:	a899      	add.n	a9, a9, a8
  909067:	186a17        	l32r	a8, 8e38c4 <HIFusb_DescTraceDump+0xdc>
  90906a:	0e9911        	slli	a9, a9, 2
  90906d:	a89a      	add.n	a10, a9, a8
  90906f:	aa2a      	add.n	a10, a2, a10
  909071:	b8aa      	addi.n	a10, a10, 8
  909073:	9a52      	s32i.n	a10, a5, 8
	if(sc->sc_sta[node_index].ni.ni_is_vapnode == 1)
  909075:	257016        	l8ui	a5, a7, 22
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_node_create_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  909078:	03034f        	extui	a3, a3, 0, 16
  90907b:	04044f        	extui	a4, a4, 0, 16
	adf_os_mem_copy(&(sc->sc_sta[node_index].ni), node,
			NODE_TARGET_SIZE);

    	vap_index = sc->sc_sta[node_index].ni.ni_vapindex;
	sc->sc_sta[node_index].ni.ni_vap = &(sc->sc_vap[vap_index].av_vap);
	if(sc->sc_sta[node_index].ni.ni_is_vapnode == 1)
  90907e:	695106        	bnei	a5, 1, 909088 <ath_node_create_tgt+0x54>
		sc->sc_vap[vap_index].av_vap.iv_nodeindex = node_index;
  909081:	a929      	add.n	a9, a2, a9
  909083:	a898      	add.n	a8, a9, a8
  909085:	268415        	s8i	a6, a8, 21

	sc->sc_sta[node_index].an_valid = 1;
  909088:	0a6511        	slli	a5, a6, 6
  90908b:	a655      	add.n	a5, a5, a6
  90908d:	065609        	addx2	a6, a5, a6
  909090:	0e6611        	slli	a6, a6, 2
  909093:	a625      	add.n	a5, a2, a6
  909095:	277a30        	movi	a7, 0x730
  909098:	a757      	add.n	a7, a5, a7
  90909a:	c081      	movi.n	a8, 1
  90909c:	28740c        	s8i	a8, a7, 12
	sc->sc_sta[node_index].ni.ni_txseqmgmt = 0;
	sc->sc_sta[node_index].ni.ni_iv16 = 0;
	sc->sc_sta[node_index].ni.ni_iv32 = 0;

	owl_tgt_node_init(&sc->sc_sta[node_index]);
  90909f:	2a5a30        	movi	a10, 0x530
	sc->sc_sta[node_index].ni.ni_vap = &(sc->sc_vap[vap_index].av_vap);
	if(sc->sc_sta[node_index].ni.ni_is_vapnode == 1)
		sc->sc_vap[vap_index].av_vap.iv_nodeindex = node_index;

	sc->sc_sta[node_index].an_valid = 1;
	sc->sc_sta[node_index].ni.ni_txseqmgmt = 0;
  9090a2:	285a40        	movi	a8, 0x540
  9090a5:	a858      	add.n	a8, a5, a8
	sc->sc_sta[node_index].ni.ni_iv16 = 0;
	sc->sc_sta[node_index].ni.ni_iv32 = 0;

	owl_tgt_node_init(&sc->sc_sta[node_index]);
  9090a7:	aa66      	add.n	a6, a6, a10
	sc->sc_sta[node_index].ni.ni_vap = &(sc->sc_vap[vap_index].av_vap);
	if(sc->sc_sta[node_index].ni.ni_is_vapnode == 1)
		sc->sc_vap[vap_index].av_vap.iv_nodeindex = node_index;

	sc->sc_sta[node_index].an_valid = 1;
	sc->sc_sta[node_index].ni.ni_txseqmgmt = 0;
  9090a9:	c050      	movi.n	a5, 0
  9090ab:	258508        	s16i	a5, a8, 16
	sc->sc_sta[node_index].ni.ni_iv16 = 0;
  9090ae:	258509        	s16i	a5, a8, 18
	sc->sc_sta[node_index].ni.ni_iv32 = 0;

	owl_tgt_node_init(&sc->sc_sta[node_index]);
  9090b1:	a62a      	add.n	a10, a2, a6
		sc->sc_vap[vap_index].av_vap.iv_nodeindex = node_index;

	sc->sc_sta[node_index].an_valid = 1;
	sc->sc_sta[node_index].ni.ni_txseqmgmt = 0;
	sc->sc_sta[node_index].ni.ni_iv16 = 0;
	sc->sc_sta[node_index].ni.ni_iv32 = 0;
  9090b3:	c050      	movi.n	a5, 0
  9090b5:	9585      	s32i.n	a5, a8, 20

	owl_tgt_node_init(&sc->sc_sta[node_index]);
  9090b7:	b8aa      	addi.n	a10, a10, 8
  9090b9:	5811dc        	call8	90d82c <owl_tgt_node_init>

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  9090bc:	8a23      	l32i.n	a10, a2, 12
  9090be:	db30      	mov.n	a11, a3
  9090c0:	dc40      	mov.n	a12, a4
  9090c2:	dd50      	mov.n	a13, a5
  9090c4:	de50      	mov.n	a14, a5
  9090c6:	5bfe85        	call8	908adc <wmi_cmd_rsp>
  9090c9:	d10f      	retw.n
	...

009090cc <ath_setcurmode_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_setcurmode_tgt(void *Context, A_UINT16 Command,
			       A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  9090cc:	6c1004        	entry	a1, 32
	a_uint16_t mode;

	mode= *((a_uint16_t *)data);
	mode = adf_os_ntohs(mode);

	ath_setcurmode(sc, mode);
  9090cf:	265100        	l16ui	a6, a5, 0
 * @param[in] size  buffer size
 */
static inline void
adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
{
    __adf_os_mem_set(buf, b, size);
  9090d2:	2a2a08        	movi	a10, 0x208
  9090d5:	0a2a08        	add	a10, a2, a10
  9090d8:	2b0aff        	movi	a11, 255
  9090db:	2c1a00        	movi	a12, 0x100
	const HAL_RATE_TABLE *rt;
	a_int32_t i;

	adf_os_mem_set(sc->sc_rixmap, 0xff, sizeof(sc->sc_rixmap));

	rt = sc->sc_rates[mode];
  9090de:	02650a        	addx4	a5, a6, a2
  9090e1:	5bfaa8        	call8	907b84 <__adf_os_mem_set>
  9090e4:	25527f        	l32i	a5, a5, 0x1fc
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_setcurmode_tgt(void *Context, A_UINT16 Command,
			       A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  9090e7:	03034f        	extui	a3, a3, 0, 16
  9090ea:	04044f        	extui	a4, a4, 0, 16
	a_int32_t i;

	adf_os_mem_set(sc->sc_rixmap, 0xff, sizeof(sc->sc_rixmap));

	rt = sc->sc_rates[mode];
	adf_os_assert(rt != NULL);
  9090ed:	cd55      	bnez.n	a5, 909106 <ath_setcurmode_tgt+0x3a>
  9090ef:	186915        	l32r	a8, 8e3544 <_HIFusb_start+0xa4>
  9090f2:	1a69f6        	l32r	a10, 8e38cc <HIFusb_DescTraceDump+0xe4>
  9090f5:	288212        	l32i	a8, a8, 72
  9090f8:	1b6a1e        	l32r	a11, 8e3970 <HIFusb_DescTraceDump+0x188>
  9090fb:	0b8000        	callx8	a8
  9090fe:	18697a        	l32r	a8, 8e36e8 <_HIFusb_isr_handler+0x4>
  909101:	0c0200        	memw
  909104:	8880      	l32i.n	a8, a8, 0
  909106:	d950      	mov.n	a9, a5
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_setcurmode_tgt(void *Context, A_UINT16 Command,
			       A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  909108:	c080      	movi.n	a8, 0
  90910a:	60000c        	j	90911a <ath_setcurmode_tgt+0x4e>

	rt = sc->sc_rates[mode];
	adf_os_assert(rt != NULL);

	for (i = 0; i < rt->rateCount; i++) {
		sc->sc_rixmap[rt->info[i].rateCode] = i;
  90910d:	2a9020        	l8ui	a10, a9, 32
  909110:	aa2a      	add.n	a10, a2, a10
  909112:	2aad02        	addmi	a10, a10, 0x200
  909115:	28a408        	s8i	a8, a10, 8
	adf_os_mem_set(sc->sc_rixmap, 0xff, sizeof(sc->sc_rixmap));

	rt = sc->sc_rates[mode];
	adf_os_assert(rt != NULL);

	for (i = 0; i < rt->rateCount; i++) {
  909118:	b188      	addi.n	a8, a8, 1
  90911a:	8a50      	l32i.n	a10, a5, 0
  90911c:	299c14        	addi	a9, a9, 20
  90911f:	7a82ea        	blt	a8, a10, 90910d <ath_setcurmode_tgt+0x41>
		sc->sc_rixmap[rt->info[i].rateCode] = i;
	}

	sc->sc_currates = rt;
	sc->sc_curmode = mode;
	sc->sc_protrix = ((mode == IEEE80211_MODE_11NG) ? 3 : 0);
  909122:	c0e0      	movi.n	a14, 0

	for (i = 0; i < rt->rateCount; i++) {
		sc->sc_rixmap[rt->info[i].rateCode] = i;
	}

	sc->sc_currates = rt;
  909124:	252681        	s32i	a5, a2, 0x204
	sc->sc_curmode = mode;
  909127:	2626c2        	s32i	a6, a2, 0x308
	sc->sc_protrix = ((mode == IEEE80211_MODE_11NG) ? 3 : 0);
  90912a:	c053      	movi.n	a5, 3
  90912c:	b066      	addi.n	a6, a6, -1
  90912e:	06e539        	movnez	a5, a14, a6
	mode= *((a_uint16_t *)data);
	mode = adf_os_ntohs(mode);

	ath_setcurmode(sc, mode);

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  909131:	8a23      	l32i.n	a10, a2, 12
		sc->sc_rixmap[rt->info[i].rateCode] = i;
	}

	sc->sc_currates = rt;
	sc->sc_curmode = mode;
	sc->sc_protrix = ((mode == IEEE80211_MODE_11NG) ? 3 : 0);
  909133:	262d03        	addmi	a6, a2, 0x300
  909136:	25640c        	s8i	a5, a6, 12
	mode= *((a_uint16_t *)data);
	mode = adf_os_ntohs(mode);

	ath_setcurmode(sc, mode);

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  909139:	db30      	mov.n	a11, a3
  90913b:	dc40      	mov.n	a12, a4
  90913d:	dde0      	mov.n	a13, a14
  90913f:	5bfe67        	call8	908adc <wmi_cmd_rsp>
  909142:	d10f      	retw.n

00909144 <ath_flushrecv_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo,NULL, 0);
}

static void ath_flushrecv_tgt(void *Context, A_UINT16 Command,
			      A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  909144:	6c1004        	entry	a1, 32
  909147:	03034f        	extui	a3, a3, 0, 16
  90914a:	04044f        	extui	a4, a4, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_rx_buf *bf;

	asf_tailq_foreach(bf, &sc->sc_rxbuf, bf_list)
  90914d:	2522d5        	l32i	a5, a2, 0x354
  909150:	60002e        	j	909182 <ath_flushrecv_tgt+0x3e>
  909153:	000000        	ill
		if (bf->bf_skb != NULL) {
  909156:	8658      	l32i.n	a6, a5, 32
  909158:	ca64      	beqz.n	a6, 909180 <ath_flushrecv_tgt+0x3c>
static inline void
adf_nbuf_unmap(adf_os_device_t      osdev, 
               adf_os_dma_map_t     bmap, 
               adf_os_dma_dir_t     dir)
{
    __adf_nbuf_unmap(osdev, bmap, dir);
  90915a:	8b50      	l32i.n	a11, a5, 0
  90915c:	2a2246        	l32i	a10, a2, 0x118
  90915f:	c0c1      	movi.n	a12, 1
  909161:	5bf649        	call8	906a88 <__adf_nbuf_unmap>
			adf_nbuf_unmap(sc->sc_dev, bf->bf_dmamap,
				       ADF_OS_DMA_FROM_DEVICE);
			ath_free_rx_skb(sc, adf_nbuf_queue_remove(&bf->bf_skbhead));
  909164:	186915        	l32r	a8, 8e35b8 <_HIFusb_start+0x118>
  909167:	8720      	l32i.n	a7, a2, 0
 * @return The head buf in the buf queue.
 */
static inline adf_nbuf_t
adf_nbuf_queue_remove(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_remove(head);
  909169:	2a5c14        	addi	a10, a5, 20
  90916c:	26829e        	l32i	a6, a8, 0x278
  90916f:	5bf632        	call8	906a38 <__adf_nbuf_queue_remove>
  909172:	dca0      	mov.n	a12, a10
  909174:	2b0a03        	movi	a11, 3
  909177:	da70      	mov.n	a10, a7
  909179:	0b6000        	callx8	a6
			bf->bf_skb = NULL;
  90917c:	c060      	movi.n	a6, 0
  90917e:	9658      	s32i.n	a6, a5, 32
			      A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_rx_buf *bf;

	asf_tailq_foreach(bf, &sc->sc_rxbuf, bf_list)
  909180:	8559      	l32i.n	a5, a5, 36
  909182:	655fd0        	bnez	a5, 909156 <ath_flushrecv_tgt+0x12>
				       ADF_OS_DMA_FROM_DEVICE);
			ath_free_rx_skb(sc, adf_nbuf_queue_remove(&bf->bf_skbhead));
			bf->bf_skb = NULL;
		}

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  909185:	8a23      	l32i.n	a10, a2, 12
  909187:	db30      	mov.n	a11, a3
  909189:	dc40      	mov.n	a12, a4
  90918b:	dd50      	mov.n	a13, a5
  90918d:	de50      	mov.n	a14, a5
  90918f:	5bfe53        	call8	908adc <wmi_cmd_rsp>
  909192:	d10f      	retw.n

00909194 <ath_stoprecv_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_stoprecv_tgt(void *Context, A_UINT16 Command,
			     A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  909194:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  909197:	252d05        	addmi	a5, a2, 0x500
  90919a:	855b      	l32i.n	a5, a5, 44
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_stoprecv_tgt(void *Context, A_UINT16 Command,
			     A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  90919c:	03034f        	extui	a3, a3, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;

	ah->ah_stopPcuReceive(ah);
  90919f:	285224        	l32i	a8, a5, 144
  9091a2:	055a02        	or	a10, a5, a5
  9091a5:	0b8000        	callx8	a8
	ah->ah_setRxFilter(ah, 0);
  9091a8:	8859      	l32i.n	a8, a5, 36
  9091aa:	da50      	mov.n	a10, a5
  9091ac:	c0b0      	movi.n	a11, 0
  9091ae:	0b8000        	callx8	a8
	ah->ah_stopDmaReceive(ah);
  9091b1:	285223        	l32i	a8, a5, 140
  9091b4:	da50      	mov.n	a10, a5
  9091b6:	0b8000        	callx8	a8

	sc->sc_rxlink = NULL;
  9091b9:	c0e0      	movi.n	a14, 0
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_stoprecv_tgt(void *Context, A_UINT16 Command,
			     A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  9091bb:	04044f        	extui	a4, a4, 0, 16
	ah->ah_stopPcuReceive(ah);
	ah->ah_setRxFilter(ah, 0);
	ah->ah_stopDmaReceive(ah);

	sc->sc_rxlink = NULL;
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  9091be:	8a23      	l32i.n	a10, a2, 12

	ah->ah_stopPcuReceive(ah);
	ah->ah_setRxFilter(ah, 0);
	ah->ah_stopDmaReceive(ah);

	sc->sc_rxlink = NULL;
  9091c0:	2e26ef        	s32i	a14, a2, 0x3bc
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  9091c3:	db30      	mov.n	a11, a3
  9091c5:	dc40      	mov.n	a12, a4
  9091c7:	dde0      	mov.n	a13, a14
  9091c9:	5bfe44        	call8	908adc <wmi_cmd_rsp>
  9091cc:	d10f      	retw.n
	...

009091d0 <ath_startrecv_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_startrecv_tgt(void *Context, A_UINT16 Command,
			      A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  9091d0:	6c1004        	entry	a1, 32
#undef PA2DESC
}

static a_int32_t ath_startrecv(struct ath_softc_tgt *sc)
{
	struct ath_hal *ah = sc->sc_ah;
  9091d3:	252d05        	addmi	a5, a2, 0x500
  9091d6:	865b      	l32i.n	a6, a5, 44
	struct ath_rx_desc *ds;

	sc->sc_rxbufsize = 1024+512+128;
  9091d8:	256a80        	movi	a5, 0x680
  9091db:	25264a        	s32i	a5, a2, 0x128
	sc->sc_rxlink = NULL;
  9091de:	c050      	movi.n	a5, 0
  9091e0:	2526ef        	s32i	a5, a2, 0x3bc

	sc->sc_rxdesc_held = NULL;
  9091e3:	2526db        	s32i	a5, a2, 0x36c
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_startrecv_tgt(void *Context, A_UINT16 Command,
			      A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  9091e6:	03034f        	extui	a3, a3, 0, 16
  9091e9:	04044f        	extui	a4, a4, 0, 16
	sc->sc_rxbufsize = 1024+512+128;
	sc->sc_rxlink = NULL;

	sc->sc_rxdesc_held = NULL;

	asf_tailq_foreach(ds, &sc->sc_rxdesc, ds_list) {
  9091ec:	2522d9        	l32i	a5, a2, 0x364
  9091ef:	600027        	j	90921a <ath_startrecv_tgt+0x4a>
		a_int32_t error = ath_rxdesc_init(sc, ds);
  9091f2:	da20      	mov.n	a10, a2
  9091f4:	db50      	mov.n	a11, a5
  9091f6:	5bfae0        	call8	907d78 <ath_rxdesc_init>
		if (error != 0) {
  9091f9:	65a049        	bnez	a10, 909246 <ath_startrecv_tgt+0x76>
	sc->sc_rxbufsize = 1024+512+128;
	sc->sc_rxlink = NULL;

	sc->sc_rxdesc_held = NULL;

	asf_tailq_foreach(ds, &sc->sc_rxdesc, ds_list) {
  9091fc:	2a504c        	l8ui	a10, a5, 76
  9091ff:	29504d        	l8ui	a9, a5, 77
  909202:	28504e        	l8ui	a8, a5, 78
  909205:	08aa10        	slli	a10, a10, 24
  909208:	009911        	slli	a9, a9, 16
  90920b:	0a9902        	or	a9, a9, a10
  90920e:	088811        	slli	a8, a8, 8
  909211:	25504f        	l8ui	a5, a5, 79
  909214:	098802        	or	a8, a8, a9
  909217:	085502        	or	a5, a5, a8
  90921a:	655fd4        	bnez	a5, 9091f2 <ath_startrecv_tgt+0x22>
			return error;
		}
	}

	ds = asf_tailq_first(&sc->sc_rxdesc);
	ah->ah_setRxDP(ah, ds->ds_daddr);
  90921d:	2522d9        	l32i	a5, a2, 0x364
  909220:	2a5048        	l8ui	a10, a5, 72
  909223:	295049        	l8ui	a9, a5, 73
  909226:	28504a        	l8ui	a8, a5, 74
  909229:	08aa10        	slli	a10, a10, 24
  90922c:	009911        	slli	a9, a9, 16
  90922f:	0a9902        	or	a9, a9, a10
  909232:	2b504b        	l8ui	a11, a5, 75
  909235:	088811        	slli	a8, a8, 8
  909238:	098802        	or	a8, a8, a9
  90923b:	25621f        	l32i	a5, a6, 124
  90923e:	da60      	mov.n	a10, a6
  909240:	08bb02        	or	a11, a11, a8
  909243:	0b5000        	callx8	a5
{

	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;

	ath_startrecv(sc);
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  909246:	c0d0      	movi.n	a13, 0
  909248:	8a23      	l32i.n	a10, a2, 12
  90924a:	db30      	mov.n	a11, a3
  90924c:	dc40      	mov.n	a12, a4
  90924e:	0dde02        	or	a14, a13, a13
  909251:	5bfe22        	call8	908adc <wmi_cmd_rsp>
  909254:	d10f      	retw.n
	...

00909258 <ath_draintxq_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_draintxq_tgt(void *Context, A_UINT16 Command,
			     A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  909258:	6c1004        	entry	a1, 32
	owltgt_txq_drain(sc, txq);
}

static void ath_draintxq(struct ath_softc_tgt *sc, HAL_BOOL drain_softq)
{
	struct ath_hal *ah = sc->sc_ah;
  90925b:	262d05        	addmi	a6, a2, 0x500
	a_uint16_t i;
	struct ath_txq *txq = NULL;
	struct ath_atx_tid *tid = NULL;

	ath_tx_status_clear(sc);
  90925e:	da20      	mov.n	a10, a2
	sc->sc_tx_draining = 1;
  909260:	252d01        	addmi	a5, a2, 0x100
	owltgt_txq_drain(sc, txq);
}

static void ath_draintxq(struct ath_softc_tgt *sc, HAL_BOOL drain_softq)
{
	struct ath_hal *ah = sc->sc_ah;
  909263:	27620b        	l32i	a7, a6, 44
	a_uint16_t i;
	struct ath_txq *txq = NULL;
	struct ath_atx_tid *tid = NULL;

	ath_tx_status_clear(sc);
  909266:	581182        	call8	90d870 <ath_tx_status_clear>
	sc->sc_tx_draining = 1;
  909269:	295024        	l8ui	a9, a5, 36
  90926c:	c480      	movi.n	a8, 64
  90926e:	089802        	or	a8, a9, a8
  909271:	285424        	s8i	a8, a5, 36

	ah->ah_stopTxDma(ah, sc->sc_bhalq);
  909274:	2b501c        	l8ui	a11, a5, 28
  909277:	28720d        	l32i	a8, a7, 52
  90927a:	077a02        	or	a10, a7, a7
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_draintxq_tgt(void *Context, A_UINT16 Command,
			     A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  90927d:	03034f        	extui	a3, a3, 0, 16
  909280:	04044f        	extui	a4, a4, 0, 16
	struct ath_atx_tid *tid = NULL;

	ath_tx_status_clear(sc);
	sc->sc_tx_draining = 1;

	ah->ah_stopTxDma(ah, sc->sc_bhalq);
  909283:	0b8000        	callx8	a8
  909286:	c050      	movi.n	a5, 0

	for (i = 0; i < HAL_NUM_TX_QUEUES; i++)
		if (ATH_TXQ_SETUP(sc, i))
  909288:	272d03        	addmi	a7, a2, 0x300
  90928b:	2770c8        	l8ui	a7, a7, 200
  90928e:	005004        	ssr	a5
  909291:	07071b        	sra	a7, a7
  909294:	7f7710        	bbci	a7, 31, 9092a8 <ath_draintxq_tgt+0x50>
			ath_tx_stopdma(sc, ATH_TXQ(sc, i));
  909297:	285c1e        	addi	a8, a5, 30
/* TX */
/******/

static void ath_tx_stopdma(struct ath_softc_tgt *sc, struct ath_txq *txq)
{
	struct ath_hal *ah = sc->sc_ah;
  90929a:	8a6b      	l32i.n	a10, a6, 44

	ah->ah_stopTxDma(ah, sc->sc_bhalq);

	for (i = 0; i < HAL_NUM_TX_QUEUES; i++)
		if (ATH_TXQ_SETUP(sc, i))
			ath_tx_stopdma(sc, ATH_TXQ(sc, i));
  90929c:	0b8811        	slli	a8, a8, 5

static void ath_tx_stopdma(struct ath_softc_tgt *sc, struct ath_txq *txq)
{
	struct ath_hal *ah = sc->sc_ah;

	ah->ah_stopTxDma(ah, txq->axq_qnum);
  90929f:	a828      	add.n	a8, a2, a8
  9092a1:	87ad      	l32i.n	a7, a10, 52
  9092a3:	8b83      	l32i.n	a11, a8, 12
  9092a5:	0b7000        	callx8	a7
  9092a8:	b155      	addi.n	a5, a5, 1
	ath_tx_status_clear(sc);
	sc->sc_tx_draining = 1;

	ah->ah_stopTxDma(ah, sc->sc_bhalq);

	for (i = 0; i < HAL_NUM_TX_QUEUES; i++)
  9092aa:	6959da        	bnei	a5, 10, 909288 <ath_draintxq_tgt+0x30>
  9092ad:	c050      	movi.n	a5, 0
			txq = ATH_TXQ(sc,i);
			while (!asf_tailq_empty(&txq->axq_tidq)){
				TAILQ_DEQ(&txq->axq_tidq, tid, tid_qelem);
				if(tid == NULL)
					break;
				tid->sched = AH_FALSE;
  9092af:	d650      	mov.n	a6, a5
	for (i = 0; i < HAL_NUM_TX_QUEUES; i++)
		if (ATH_TXQ_SETUP(sc, i))
			ath_tx_stopdma(sc, ATH_TXQ(sc, i));

	for (i = 0; i < HAL_NUM_TX_QUEUES; i++)
		if (ATH_TXQ_SETUP(sc, i)) {
  9092b1:	272d03        	addmi	a7, a2, 0x300
  9092b4:	2770c8        	l8ui	a7, a7, 200
  9092b7:	005004        	ssr	a5
  9092ba:	07071b        	sra	a7, a7
  9092bd:	7f7f08        	bbsi	a7, 31, 9092c9 <ath_draintxq_tgt+0x71>
  9092c0:	b155      	addi.n	a5, a5, 1

	for (i = 0; i < HAL_NUM_TX_QUEUES; i++)
		if (ATH_TXQ_SETUP(sc, i))
			ath_tx_stopdma(sc, ATH_TXQ(sc, i));

	for (i = 0; i < HAL_NUM_TX_QUEUES; i++)
  9092c2:	6959eb        	bnei	a5, 10, 9092b1 <ath_draintxq_tgt+0x59>
  9092c5:	600039        	j	909302 <ath_draintxq_tgt+0xaa>
  9092c8:	00275c        	extui	a7, a0, 18, 13
		if (ATH_TXQ_SETUP(sc, i)) {
			owltgt_tx_processq(sc, ATH_TXQ(sc,i), OWL_TXQ_STOPPED);
  9092cb:	1e0b77        	l32r	a14, 8cc0a8 <_bss_end+0x3b9198>
  9092ce:	11a727        	l32r	a1, 8f2f6c <memset+0xc124>
  9092d1:	bc77      	addi.n	a7, a7, 12
  9092d3:	da20      	mov.n	a10, a2
  9092d5:	db70      	mov.n	a11, a7
  9092d7:	c0c1      	movi.n	a12, 1
  9092d9:	581648        	call8	90ebfc <owltgt_tx_processq>
  9092dc:	60001a        	j	9092fa <ath_draintxq_tgt+0xa2>
  9092df:	0089b9        	excw

			txq = ATH_TXQ(sc,i);
			while (!asf_tailq_empty(&txq->axq_tidq)){
				TAILQ_DEQ(&txq->axq_tidq, tid, tid_qelem);
  9092e2:	8aba      	l32i.n	a10, a11, 40
  9092e4:	c894      	beqz.n	a9, 9092ec <ath_draintxq_tgt+0x94>
  9092e6:	9a9a      	s32i.n	a10, a9, 40
  9092e8:	600002        	j	9092ee <ath_draintxq_tgt+0x96>
  9092eb:	009a77        	excw
  9092ee:	8aba      	l32i.n	a10, a11, 40
  9092f0:	99a0      	s32i.n	a9, a10, 0
				if(tid == NULL)
					break;
				tid->sched = AH_FALSE;
  9092f2:	26b435        	s8i	a6, a11, 53
				ath_tgt_tid_drain(sc,tid);
  9092f5:	da20      	mov.n	a10, a2
  9092f7:	581217        	call8	90db54 <ath_tgt_tid_drain>
	for (i = 0; i < HAL_NUM_TX_QUEUES; i++)
		if (ATH_TXQ_SETUP(sc, i)) {
			owltgt_tx_processq(sc, ATH_TXQ(sc,i), OWL_TXQ_STOPPED);

			txq = ATH_TXQ(sc,i);
			while (!asf_tailq_empty(&txq->axq_tidq)){
  9092fa:	8b76      	l32i.n	a11, a7, 24
  9092fc:	65bfe0        	bnez	a11, 9092e0 <ath_draintxq_tgt+0x88>
  9092ff:	63ffbd        	j	9092c0 <ath_draintxq_tgt+0x68>
				tid->sched = AH_FALSE;
				ath_tgt_tid_drain(sc,tid);
			}
		}

	sc->sc_tx_draining = 0;
  909302:	252d01        	addmi	a5, a2, 0x100
  909305:	275024        	l8ui	a7, a5, 36
  909308:	26fabf        	movi	a6, -65
  90930b:	067601        	and	a6, a7, a6
  90930e:	265424        	s8i	a6, a5, 36
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	HAL_BOOL b = (HAL_BOOL) *(a_int32_t *)data;

	ath_draintxq(Context, b);
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  909311:	c0d0      	movi.n	a13, 0
  909313:	8a23      	l32i.n	a10, a2, 12
  909315:	db30      	mov.n	a11, a3
  909317:	dc40      	mov.n	a12, a4
  909319:	ded0      	mov.n	a14, a13
  90931b:	5bfdf0        	call8	908adc <wmi_cmd_rsp>
  90931e:	d10f      	retw.n

00909320 <ath_tx_draintxq_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_tx_draintxq_tgt(void *Context, A_UINT16 Command, A_UINT16 SeqNo,
				A_UINT8 *data, a_int32_t datalen)
{
  909320:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	a_uint32_t q = *(a_uint32_t *)data;
	struct ath_txq *txq = NULL;

	q = adf_os_ntohl(q);
	txq = ATH_TXQ(sc, q);
  909323:	8b50      	l32i.n	a11, a5, 0
	ah->ah_stopTxDma(ah, txq->axq_qnum);
}

static void owltgt_txq_drain(struct ath_softc_tgt *sc, struct ath_txq *txq)
{
	owltgt_tx_processq(sc, txq, OWL_TXQ_STOPPED);
  909325:	da20      	mov.n	a10, a2
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	a_uint32_t q = *(a_uint32_t *)data;
	struct ath_txq *txq = NULL;

	q = adf_os_ntohl(q);
	txq = ATH_TXQ(sc, q);
  909327:	2bbc1e        	addi	a11, a11, 30
  90932a:	0bbb11        	slli	a11, a11, 5
  90932d:	ab2b      	add.n	a11, a2, a11
	ah->ah_stopTxDma(ah, txq->axq_qnum);
}

static void owltgt_txq_drain(struct ath_softc_tgt *sc, struct ath_txq *txq)
{
	owltgt_tx_processq(sc, txq, OWL_TXQ_STOPPED);
  90932f:	2bbc0c        	addi	a11, a11, 12
  909332:	2c0a01        	movi	a12, 1
  909335:	581631        	call8	90ebfc <owltgt_tx_processq>
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_tx_draintxq_tgt(void *Context, A_UINT16 Command, A_UINT16 SeqNo,
				A_UINT8 *data, a_int32_t datalen)
{
  909338:	03034f        	extui	a3, a3, 0, 16
  90933b:	04044f        	extui	a4, a4, 0, 16

	q = adf_os_ntohl(q);
	txq = ATH_TXQ(sc, q);

	ath_tx_draintxq(sc, txq);
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  90933e:	c0d0      	movi.n	a13, 0
  909340:	8a23      	l32i.n	a10, a2, 12
  909342:	db30      	mov.n	a11, a3
  909344:	dc40      	mov.n	a12, a4
  909346:	0dde02        	or	a14, a13, a13
  909349:	5bfde4        	call8	908adc <wmi_cmd_rsp>
  90934c:	d10f      	retw.n
	...

00909350 <ath_aborttx_dma_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_aborttx_dma_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  909350:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  909353:	282d05        	addmi	a8, a2, 0x500
  909356:	8a8b      	l32i.n	a10, a8, 44
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_aborttx_dma_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  909358:	03034f        	extui	a3, a3, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;

	ah->ah_abortTxDma(sc->sc_ah);
  90935b:	28a20e        	l32i	a8, a10, 56
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_aborttx_dma_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  90935e:	04044f        	extui	a4, a4, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;

	ah->ah_abortTxDma(sc->sc_ah);
  909361:	0b8000        	callx8	a8
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  909364:	c0d0      	movi.n	a13, 0
  909366:	8a23      	l32i.n	a10, a2, 12
  909368:	db30      	mov.n	a11, a3
  90936a:	dc40      	mov.n	a12, a4
  90936c:	ded0      	mov.n	a14, a13
  90936e:	5bfddb        	call8	908adc <wmi_cmd_rsp>
  909371:	d10f      	retw.n
	...

00909374 <ath_stop_tx_dma_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_stop_tx_dma_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  909374:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  909377:	292d05        	addmi	a9, a2, 0x500
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_stop_tx_dma_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  90937a:	03034f        	extui	a3, a3, 0, 16
  90937d:	04044f        	extui	a4, a4, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  909380:	8a9b      	l32i.n	a10, a9, 44
	a_uint32_t q;

	if (data)
  909382:	c850      	beqz.n	a5, 909386 <ath_stop_tx_dma_tgt+0x12>
		q = *(a_uint32_t *)data;
  909384:	8b50      	l32i.n	a11, a5, 0

	q = adf_os_ntohl(q);
	ah->ah_stopTxDma(ah, q);
  909386:	85ad      	l32i.n	a5, a10, 52
  909388:	0b5000        	callx8	a5
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  90938b:	c0d0      	movi.n	a13, 0
  90938d:	8a23      	l32i.n	a10, a2, 12
  90938f:	db30      	mov.n	a11, a3
  909391:	dc40      	mov.n	a12, a4
  909393:	ded0      	mov.n	a14, a13
  909395:	5bfdd1        	call8	908adc <wmi_cmd_rsp>
  909398:	d10f      	retw.n
	...

0090939c <ath_aborttxq_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_aborttxq_tgt(void *Context, A_UINT16 Command,
			     A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  90939c:	6c1004        	entry	a1, 32
  90939f:	03034f        	extui	a3, a3, 0, 16
  9093a2:	04044f        	extui	a4, a4, 0, 16
  9093a5:	250a00        	movi	a5, 0

	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	a_uint16_t i;

	for (i = 0; i < HAL_NUM_TX_QUEUES; i++) {
		if (ATH_TXQ_SETUP(sc, i))
  9093a8:	282d03        	addmi	a8, a2, 0x300
  9093ab:	2880c8        	l8ui	a8, a8, 200
  9093ae:	005004        	ssr	a5
  9093b1:	08081b        	sra	a8, a8
  9093b4:	7f8710        	bbci	a8, 31, 9093c8 <ath_aborttxq_tgt+0x2c>
			ath_tx_draintxq(sc, ATH_TXQ(sc,i));
  9093b7:	2b5c1e        	addi	a11, a5, 30
  9093ba:	0bbb11        	slli	a11, a11, 5
  9093bd:	ab2b      	add.n	a11, a2, a11
	ah->ah_stopTxDma(ah, txq->axq_qnum);
}

static void owltgt_txq_drain(struct ath_softc_tgt *sc, struct ath_txq *txq)
{
	owltgt_tx_processq(sc, txq, OWL_TXQ_STOPPED);
  9093bf:	da20      	mov.n	a10, a2
  9093c1:	bcbb      	addi.n	a11, a11, 12
  9093c3:	c0c1      	movi.n	a12, 1
  9093c5:	58160d        	call8	90ebfc <owltgt_tx_processq>
  9093c8:	b155      	addi.n	a5, a5, 1
{

	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	a_uint16_t i;

	for (i = 0; i < HAL_NUM_TX_QUEUES; i++) {
  9093ca:	6959da        	bnei	a5, 10, 9093a8 <ath_aborttxq_tgt+0xc>
		if (ATH_TXQ_SETUP(sc, i))
			ath_tx_draintxq(sc, ATH_TXQ(sc,i));
	}

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  9093cd:	c0d0      	movi.n	a13, 0
  9093cf:	8a23      	l32i.n	a10, a2, 12
  9093d1:	db30      	mov.n	a11, a3
  9093d3:	dc40      	mov.n	a12, a4
  9093d5:	ded0      	mov.n	a14, a13
  9093d7:	5bfdc1        	call8	908adc <wmi_cmd_rsp>
  9093da:	d10f      	retw.n

009093dc <ath_init_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo,NULL, 0);
}

static void ath_init_tgt(void *Context, A_UINT16 Command,
			 A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  9093dc:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  9093df:	252d05        	addmi	a5, a2, 0x500
  9093e2:	855b      	l32i.n	a5, a5, 44

	sc->sc_imask = HAL_INT_RX | HAL_INT_TX
		| HAL_INT_RXEOL | HAL_INT_RXORN
		| HAL_INT_FATAL | HAL_INT_GLOBAL;

	sc->sc_imask |= HAL_INT_GTT;
  9093e4:	186a1f        	l32r	a8, 8e3c60 <bSet_configuration+0x10c>

	if (ath_hal_getcapability(ah, HAL_CAP_HT))
  9093e7:	055a02        	or	a10, a5, a5

	sc->sc_imask = HAL_INT_RX | HAL_INT_TX
		| HAL_INT_RXEOL | HAL_INT_RXORN
		| HAL_INT_FATAL | HAL_INT_GLOBAL;

	sc->sc_imask |= HAL_INT_GTT;
  9093ea:	2826c4        	s32i	a8, a2, 0x310

	if (ath_hal_getcapability(ah, HAL_CAP_HT))
  9093ed:	c0b5      	movi.n	a11, 5
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo,NULL, 0);
}

static void ath_init_tgt(void *Context, A_UINT16 Command,
			 A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  9093ef:	03034f        	extui	a3, a3, 0, 16
  9093f2:	04044f        	extui	a4, a4, 0, 16
		| HAL_INT_RXEOL | HAL_INT_RXORN
		| HAL_INT_FATAL | HAL_INT_GLOBAL;

	sc->sc_imask |= HAL_INT_GTT;

	if (ath_hal_getcapability(ah, HAL_CAP_HT))
  9093f5:	580656        	call8	90ad50 <ath_hal_getcapability>
  9093f8:	c8aa      	beqz.n	a10, 909406 <ath_init_tgt+0x2a>
		sc->sc_imask |= HAL_INT_CST;
  9093fa:	2922c4        	l32i	a9, a2, 0x310
  9093fd:	186a20        	l32r	a8, 8e3c80 <bSet_configuration+0x12c>
  909400:	089802        	or	a8, a9, a8
  909403:	2826c4        	s32i	a8, a2, 0x310
#include <adf_os_irq_pvt.h>

static inline int
adf_os_setup_intr(adf_os_device_t  osdev, adf_os_drv_intr fn)
{
    return __adf_os_setup_intr(osdev, fn);
  909406:	2a2246        	l32i	a10, a2, 0x118
  909409:	1b6a21        	l32r	a11, 8e3c90 <bSet_configuration+0x13c>
  90940c:	580646        	call8	90ad28 <__adf_os_setup_intr>

	adf_os_setup_intr(sc->sc_dev, ath_intr);
	ah->ah_setInterrupts(ah, sc->sc_imask);
  90940f:	2b22c4        	l32i	a11, a2, 0x310
  909412:	285228        	l32i	a8, a5, 160
  909415:	da50      	mov.n	a10, a5
  909417:	0b8000        	callx8	a8

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  90941a:	c0d0      	movi.n	a13, 0
  90941c:	8a23      	l32i.n	a10, a2, 12
  90941e:	db30      	mov.n	a11, a3
  909420:	dc40      	mov.n	a12, a4
  909422:	0dde02        	or	a14, a13, a13
  909425:	5bfdad        	call8	908adc <wmi_cmd_rsp>
  909428:	d10f      	retw.n
	...

0090942c <ath_enable_intr_tgt>:
/* WMI Commands */
/****************/

static void ath_enable_intr_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  90942c:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  90942f:	292d05        	addmi	a9, a2, 0x500
/* WMI Commands */
/****************/

static void ath_enable_intr_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  909432:	03034f        	extui	a3, a3, 0, 16
  909435:	04044f        	extui	a4, a4, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  909438:	8a9b      	l32i.n	a10, a9, 44
	a_uint32_t intr;

	if (data)
  90943a:	645002        	beqz	a5, 909440 <ath_enable_intr_tgt+0x14>
		intr = (*(a_uint32_t *)data);
  90943d:	285200        	l32i	a8, a5, 0

	intr = adf_os_ntohl(intr);

	if (intr & HAL_INT_SWBA) {
  909440:	196953        	l32r	a9, 8e398c <HIFusb_DescTraceDump+0x1a4>
  909443:	2522c4        	l32i	a5, a2, 0x310
  909446:	798006        	bnone	a8, a9, 909450 <ath_enable_intr_tgt+0x24>
		sc->sc_imask |= HAL_INT_SWBA;
  909449:	095502        	or	a5, a5, a9
  90944c:	600006        	j	909456 <ath_enable_intr_tgt+0x2a>
  90944f:	00196a        	excw
	} else {
		sc->sc_imask &= ~HAL_INT_SWBA;
  909452:	220955        	l16si	a2, a0, 170
  909455:	012526        	excw
  909458:	c415      	movi.n	a1, 69
	}

	if (intr & HAL_INT_BMISS) {
  90945a:	6a2375        	blti	a2, 3, 9094d3 <handle_echo_command+0xb>
  90945d:	8008      	l32i.n	a0, a0, 32
		sc->sc_imask |= HAL_INT_BMISS;
  90945f:	2822c4        	l32i	a8, a2, 0x310
  909462:	058502        	or	a5, a8, a5
  909465:	2526c4        	s32i	a5, a2, 0x310
	}

	ah->ah_setInterrupts(ah, sc->sc_imask);
  909468:	2b22c4        	l32i	a11, a2, 0x310
  90946b:	25a228        	l32i	a5, a10, 160
  90946e:	0b5000        	callx8	a5
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo,NULL, 0);
  909471:	c0d0      	movi.n	a13, 0
  909473:	8a23      	l32i.n	a10, a2, 12
  909475:	db30      	mov.n	a11, a3
  909477:	dc40      	mov.n	a12, a4
  909479:	ded0      	mov.n	a14, a13
  90947b:	5bfd98        	call8	908adc <wmi_cmd_rsp>
  90947e:	d10f      	retw.n

00909480 <ath_disable_intr_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_disable_intr_tgt(void *Context, A_UINT16 Command,
				 A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  909480:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  909483:	282d05        	addmi	a8, a2, 0x500
  909486:	8a8b      	l32i.n	a10, a8, 44

	ah->ah_setInterrupts(ah, 0);
  909488:	2b0a00        	movi	a11, 0
  90948b:	28a228        	l32i	a8, a10, 160
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_disable_intr_tgt(void *Context, A_UINT16 Command,
				 A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  90948e:	03034f        	extui	a3, a3, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;

	ah->ah_setInterrupts(ah, 0);
  909491:	0b8000        	callx8	a8
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_disable_intr_tgt(void *Context, A_UINT16 Command,
				 A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  909494:	04044f        	extui	a4, a4, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;

	ah->ah_setInterrupts(ah, 0);
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo,NULL, 0);
  909497:	c0d0      	movi.n	a13, 0
  909499:	8a23      	l32i.n	a10, a2, 12
  90949b:	db30      	mov.n	a11, a3
  90949d:	dc40      	mov.n	a12, a4
  90949f:	ded0      	mov.n	a14, a13
  9094a1:	5bfd8e        	call8	908adc <wmi_cmd_rsp>
  9094a4:	d10f      	retw.n
	...

009094a8 <ath_get_tgt_version>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
}

static void ath_get_tgt_version(void *Context,A_UINT16 Command, A_UINT16 SeqNo,
				A_UINT8 *data, a_int32_t datalen)
{
  9094a8:	6c1006        	entry	a1, 48
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_fw_version ver;

	ver.major = ATH_VERSION_MAJOR;
  9094ab:	c081      	movi.n	a8, 1
	ver.minor = ATH_VERSION_MINOR;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &ver, sizeof(ver));
  9094ad:	8a23      	l32i.n	a10, a2, 12
				A_UINT8 *data, a_int32_t datalen)
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_fw_version ver;

	ver.major = ATH_VERSION_MAJOR;
  9094af:	281500        	s16i	a8, a1, 0
	ver.minor = ATH_VERSION_MINOR;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &ver, sizeof(ver));
  9094b2:	030b4f        	extui	a11, a3, 0, 16
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_fw_version ver;

	ver.major = ATH_VERSION_MAJOR;
	ver.minor = ATH_VERSION_MINOR;
  9094b5:	c084      	movi.n	a8, 4

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &ver, sizeof(ver));
  9094b7:	040c4f        	extui	a12, a4, 0, 16
  9094ba:	dd10      	mov.n	a13, a1
  9094bc:	c0e4      	movi.n	a14, 4
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_fw_version ver;

	ver.major = ATH_VERSION_MAJOR;
	ver.minor = ATH_VERSION_MINOR;
  9094be:	281501        	s16i	a8, a1, 2

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &ver, sizeof(ver));
  9094c1:	5bfd86        	call8	908adc <wmi_cmd_rsp>
  9094c4:	d10f      	retw.n
	...

009094c8 <handle_echo_command>:
	adf_os_mem_free(sc);
}

static void handle_echo_command(void *pContext, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
  9094c8:	6c1004        	entry	a1, 32
	wmi_cmd_rsp(pContext, WMI_ECHO_CMDID, SeqNo, buffer, Length);
  9094cb:	da20      	mov.n	a10, a2
  9094cd:	c0b1      	movi.n	a11, 1
  9094cf:	040c4f        	extui	a12, a4, 0, 16
  9094d2:	dd50      	mov.n	a13, a5
  9094d4:	de60      	mov.n	a14, a6
  9094d6:	5bfd81        	call8	908adc <wmi_cmd_rsp>
  9094d9:	d10f      	retw.n
	...

009094dc <ath_get_minrateidx>:
			sc->sc_sta[i].an_valid = 0;
	}
}

a_uint8_t ath_get_minrateidx(struct ath_softc_tgt *sc, struct ath_vap_target *avp)
{
  9094dc:	6c1004        	entry	a1, 32
	if (sc->sc_curmode == IEEE80211_MODE_11NG)
  9094df:	2822c2        	l32i	a8, a2, 0x308
  9094e2:	698104        	bnei	a8, 1, 9094ea <ath_get_minrateidx+0xe>
		return avp->av_minrateidx[0];
  9094e5:	223040        	l8ui	a2, a3, 64
  9094e8:	d10f      	retw.n
	else if (sc->sc_curmode == IEEE80211_MODE_11NA)
		return avp->av_minrateidx[1];

	return 0;
  9094ea:	c020      	movi.n	a2, 0

a_uint8_t ath_get_minrateidx(struct ath_softc_tgt *sc, struct ath_vap_target *avp)
{
	if (sc->sc_curmode == IEEE80211_MODE_11NG)
		return avp->av_minrateidx[0];
	else if (sc->sc_curmode == IEEE80211_MODE_11NA)
  9094ec:	728902        	bne	a8, a2, 9094f2 <ath_get_minrateidx+0x16>
		return avp->av_minrateidx[1];
  9094ef:	223041        	l8ui	a2, a3, 65

	return 0;
}
  9094f2:	d10f      	retw.n

009094f4 <tgt_HTCRecv_beaconhandler>:
#undef N
}

static void tgt_HTCRecv_beaconhandler(HTC_ENDPOINT_ID EndPt, adf_nbuf_t hdr_buf,
				      adf_nbuf_t buf, void *ServiceCtx)
{
  9094f4:	6c101c        	entry	a1, 224
}

static void ath_tgt_send_beacon(struct ath_softc_tgt *sc, adf_nbuf_t bc_hdr,
				adf_nbuf_t nbuf, HTC_ENDPOINT_ID EndPt)
{
	struct ath_hal *ah = sc->sc_ah;
  9094f7:	265d05        	addmi	a6, a5, 0x500
  9094fa:	866b      	l32i.n	a6, a6, 44
	ath_beacon_hdr_t *bhdr;
	struct ieee80211vap_target  *vap;
	a_uint32_t anblen;
	struct ieee80211_frame *wh;

	if (!bc_hdr) {
  9094fc:	cd35      	bnez.n	a3, 909515 <tgt_HTCRecv_beaconhandler+0x21>
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  9094fe:	231c20        	addi	a3, a1, 32
  909501:	da40      	mov.n	a10, a4
  909503:	2b3c74        	addi	a11, a3, 116
  909506:	2c3c70        	addi	a12, a3, 112
  909509:	5bf5e5        	call8	906ca0 <__adf_nbuf_peek_header>
		adf_nbuf_peek_header(nbuf, &anbdata, &anblen);
		bhdr = (ath_beacon_hdr_t *)anbdata;
  90950c:	271225        	l32i	a7, a1, 148
  90950f:	600011        	j	909524 <tgt_HTCRecv_beaconhandler+0x30>
  909512:	000000        	ill
	} else {
		adf_os_print("found bc_hdr! 0x%x\n", bc_hdr);
  909515:	186915        	l32r	a8, 8e396c <HIFusb_DescTraceDump+0x184>
  909518:	1a6a24        	l32r	a10, 8e3da8 <bSet_configuration+0x254>
  90951b:	288212        	l32i	a8, a8, 72
  90951e:	033b02        	or	a11, a3, a3
  909521:	0b8000        	callx8	a8
	}

	vap_index = bhdr->vap_index;
  909524:	277000        	l8ui	a7, a7, 0
	adf_os_assert(vap_index < TARGET_VAP_MAX);
  909527:	6e7216        	bltui	a7, 2, 909541 <tgt_HTCRecv_beaconhandler+0x4d>
  90952a:	136915        	l32r	a3, 8e3980 <HIFusb_DescTraceDump+0x198>
  90952d:	1a69f6        	l32r	a10, 8e3d08 <bSet_configuration+0x1b4>
  909530:	233212        	l32i	a3, a3, 72
  909533:	1b6a25        	l32r	a11, 8e3dc8 <bSet_configuration+0x274>
  909536:	0b3000        	callx8	a3
  909539:	13697a        	l32r	a3, 8e3b24 <bGet_descriptor+0x88>
  90953c:	0c0200        	memw
  90953f:	8330      	l32i.n	a3, a3, 0
 *         or NULL if there is not sufficient data to pull.
 */
static inline a_uint8_t *
adf_nbuf_pull_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_pull_head(buf, size);
  909541:	da40      	mov.n	a10, a4
  909543:	c0b4      	movi.n	a11, 4
  909545:	5bf507        	call8	906964 <__adf_nbuf_pull_head>
	vap = &sc->sc_vap[vap_index].av_vap;

	wh = (struct ieee80211_frame *)adf_nbuf_pull_head(nbuf,
						  sizeof(ath_beacon_hdr_t));

	bf = sc->sc_vap[vap_index].av_bcbuf;
  909548:	0c7311        	slli	a3, a7, 4
  90954b:	a733      	add.n	a3, a3, a7
  90954d:	186a1c        	l32r	a8, 8e3dc0 <bSet_configuration+0x26c>
  909550:	05330a        	addx4	a3, a3, a5
  909553:	a833      	add.n	a3, a3, a8
  909555:	8333      	l32i.n	a3, a3, 12
	adf_os_assert(bf);
  909557:	cd35      	bnez.n	a3, 909570 <tgt_HTCRecv_beaconhandler+0x7c>
  909559:	186915        	l32r	a8, 8e39b0 <HIFusb_DescTraceDump+0x1c8>
  90955c:	1a69f6        	l32r	a10, 8e3d34 <bSet_configuration+0x1e0>
  90955f:	288212        	l32i	a8, a8, 72
  909562:	1b6a25        	l32r	a11, 8e3df8 <bSet_configuration+0x2a4>
  909565:	0b8000        	callx8	a8
  909568:	18697a        	l32r	a8, 8e3b50 <bGet_descriptor+0xb4>
  90956b:	0c0200        	memw
  90956e:	8880      	l32i.n	a8, a8, 0
	bf->bf_endpt = EndPt;
  909570:	223623        	s32i	a2, a3, 140

	if (bf->bf_skb) {
  909573:	8238      	l32i.n	a2, a3, 32
  909575:	c92f      	beqz.n	a2, 909598 <tgt_HTCRecv_beaconhandler+0xa4>
static inline void
adf_nbuf_unmap(adf_os_device_t      osdev, 
               adf_os_dma_map_t     bmap, 
               adf_os_dma_dir_t     dir)
{
    __adf_nbuf_unmap(osdev, bmap, dir);
  909577:	2a5246        	l32i	a10, a5, 0x118
  90957a:	8b30      	l32i.n	a11, a3, 0
  90957c:	c0c0      	movi.n	a12, 0
  90957e:	5bf542        	call8	906a88 <__adf_nbuf_unmap>
 *         or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_push_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_push_head(buf, size);
  909581:	8a38      	l32i.n	a10, a3, 32
  909583:	c0b4      	movi.n	a11, 4
  909585:	5bf4ec        	call8	906938 <__adf_nbuf_push_head>
		adf_nbuf_unmap(sc->sc_dev, bf->bf_dmamap, ADF_OS_DMA_TO_DEVICE);
		adf_nbuf_push_head(bf->bf_skb, sizeof(ath_beacon_hdr_t));
		ath_free_tx_skb(sc->tgt_htc_handle, bf->bf_endpt, bf->bf_skb);
  909588:	126915        	l32r	a2, 8e39dc <HIFusb_DescTraceDump+0x1f4>
  90958b:	8a52      	l32i.n	a10, a5, 8
  90958d:	222282        	l32i	a2, a2, 0x208
  909590:	2b3223        	l32i	a11, a3, 140
  909593:	8c38      	l32i.n	a12, a3, 32
  909595:	0b2000        	callx8	a2
adf_nbuf_map(adf_os_device_t        osdev, 
             adf_os_dma_map_t       bmap, 
             adf_nbuf_t             buf, 
             adf_os_dma_dir_t       dir)
{
    return __adf_nbuf_map(osdev, bmap, buf, dir);
  909598:	8b30      	l32i.n	a11, a3, 0
  90959a:	2a5246        	l32i	a10, a5, 0x118
  90959d:	c0d0      	movi.n	a13, 0
  90959f:	dc40      	mov.n	a12, a4
	}

	bf->bf_skb = nbuf;
  9095a1:	9438      	s32i.n	a4, a3, 32
  9095a3:	5bf536        	call8	906a7c <__adf_nbuf_map>
 * @param[out] sg   map info
 */
static inline void
adf_nbuf_dmamap_info(adf_os_dma_map_t bmap, adf_os_dmamap_info_t *sg)
{
    __adf_nbuf_dmamap_info(bmap, sg);
  9095a6:	8a30      	l32i.n	a10, a3, 0
  9095a8:	b43b      	addi.n	a11, a3, 4
static void ath_beacon_setup(struct ath_softc_tgt *sc,
			     struct ath_tx_buf *bf,
			     struct ath_vap_target *avp)
{
	adf_nbuf_t skb = bf->bf_skb;
	struct ath_hal *ah = sc->sc_ah;
  9095aa:	225d05        	addmi	a2, a5, 0x500
  9095ad:	5bf53b        	call8	906a9c <__adf_nbuf_dmamap_info>
  9095b0:	822b      	l32i.n	a2, a2, 44
	struct ath_tx_desc *ds;
	a_int32_t flags;
	const HAL_RATE_TABLE *rt;
	a_uint8_t rix, rate;
	HAL_11N_RATE_SERIES series[4] = {{ 0 }};
  9095b2:	2c0a70        	movi	a12, 112
  9095b5:	2a1c20        	addi	a10, a1, 32
  9095b8:	c0b0      	movi.n	a11, 0
 */
static void ath_beacon_setup(struct ath_softc_tgt *sc,
			     struct ath_tx_buf *bf,
			     struct ath_vap_target *avp)
{
	adf_nbuf_t skb = bf->bf_skb;
  9095ba:	8438      	l32i.n	a4, a3, 32
	struct ath_hal *ah = sc->sc_ah;
  9095bc:	22162d        	s32i	a2, a1, 180
	struct ath_tx_desc *ds;
	a_int32_t flags;
	const HAL_RATE_TABLE *rt;
	a_uint8_t rix, rate;
	HAL_11N_RATE_SERIES series[4] = {{ 0 }};
  9095bf:	5b7622        	call8	8e6e48 <memset>

	flags = HAL_TXDESC_NOACK;

	ds = bf->bf_desc;
  9095c2:	883c      	l32i.n	a8, a3, 48
	ds->ds_link = 0;
  9095c4:	c090      	movi.n	a9, 0
  9095c6:	c0a0      	movi.n	a10, 0
  9095c8:	298400        	s8i	a9, a8, 0
  9095cb:	2a8401        	s8i	a10, a8, 1
  9095ce:	2a8402        	s8i	a10, a8, 2
  9095d1:	2a8403        	s8i	a10, a8, 3
	ds->ds_data = bf->bf_dmamap_info.dma_segs[0].paddr;
  9095d4:	2a3008        	l8ui	a10, a3, 8
	bf->bf_skb = nbuf;

	adf_nbuf_map(sc->sc_dev, bf->bf_dmamap, nbuf, ADF_OS_DMA_TO_DEVICE);
	adf_nbuf_dmamap_info(bf->bf_dmamap,&bf->bf_dmamap_info);

	ath_beacon_setup(sc, bf, &sc->sc_vap[vap_index]);
  9095d7:	0c7b11        	slli	a11, a7, 4

	flags = HAL_TXDESC_NOACK;

	ds = bf->bf_desc;
	ds->ds_link = 0;
	ds->ds_data = bf->bf_dmamap_info.dma_segs[0].paddr;
  9095da:	2a8404        	s8i	a10, a8, 4
  9095dd:	2a3009        	l8ui	a10, a3, 9
	bf->bf_skb = nbuf;

	adf_nbuf_map(sc->sc_dev, bf->bf_dmamap, nbuf, ADF_OS_DMA_TO_DEVICE);
	adf_nbuf_dmamap_info(bf->bf_dmamap,&bf->bf_dmamap_info);

	ath_beacon_setup(sc, bf, &sc->sc_vap[vap_index]);
  9095e0:	a7bb      	add.n	a11, a11, a7

	flags = HAL_TXDESC_NOACK;

	ds = bf->bf_desc;
	ds->ds_link = 0;
	ds->ds_data = bf->bf_dmamap_info.dma_segs[0].paddr;
  9095e2:	2a8405        	s8i	a10, a8, 5
  9095e5:	2a300a        	l8ui	a10, a3, 10
  9095e8:	2a8406        	s8i	a10, a8, 6
  9095eb:	2a300b        	l8ui	a10, a3, 11
  9095ee:	2a8407        	s8i	a10, a8, 7
	bf->bf_skb = nbuf;

	adf_nbuf_map(sc->sc_dev, bf->bf_dmamap, nbuf, ADF_OS_DMA_TO_DEVICE);
	adf_nbuf_dmamap_info(bf->bf_dmamap,&bf->bf_dmamap_info);

	ath_beacon_setup(sc, bf, &sc->sc_vap[vap_index]);
  9095f1:	1a6a17        	l32r	a10, 8e3e50 <bSet_configuration+0x2fc>

	ds = bf->bf_desc;
	ds->ds_link = 0;
	ds->ds_data = bf->bf_dmamap_info.dma_segs[0].paddr;

	rix = ath_get_minrateidx(sc, avp);
  9095f4:	28162b        	s32i	a8, a1, 172
	bf->bf_skb = nbuf;

	adf_nbuf_map(sc->sc_dev, bf->bf_dmamap, nbuf, ADF_OS_DMA_TO_DEVICE);
	adf_nbuf_dmamap_info(bf->bf_dmamap,&bf->bf_dmamap_info);

	ath_beacon_setup(sc, bf, &sc->sc_vap[vap_index]);
  9095f7:	0abb0a        	addx4	a11, a11, a10
  9095fa:	0b5b08        	add	a11, a5, a11

	ds = bf->bf_desc;
	ds->ds_link = 0;
	ds->ds_data = bf->bf_dmamap_info.dma_segs[0].paddr;

	rix = ath_get_minrateidx(sc, avp);
  9095fd:	b8bb      	addi.n	a11, a11, 8
  9095ff:	055a02        	or	a10, a5, a5
  909602:	29162c        	s32i	a9, a1, 176
  909605:	5bffb5        	call8	9094dc <ath_get_minrateidx>
	rt  = sc->sc_currates;
	rate = rt->info[rix].rateCode;
  909608:	275281        	l32i	a7, a5, 0x204
  90960b:	0aaa0a        	addx4	a10, a10, a10
  90960e:	07a70a        	addx4	a7, a10, a7
  909611:	227034        	l8ui	a2, a7, 52
 * @return The total length of this buf.
 */
static inline adf_os_size_t
adf_nbuf_len(adf_nbuf_t buf)
{
    return (__adf_nbuf_len(buf));
  909614:	da40      	mov.n	a10, a4
  909616:	221628        	s32i	a2, a1, 160

	ah->ah_setupTxDesc(ds
  909619:	22122d        	l32i	a2, a1, 180
  90961c:	c071      	movi.n	a7, 1
  90961e:	222217        	l32i	a2, a2, 92
  909621:	5bf597        	call8	906c80 <__adf_nbuf_len>
  909624:	29122c        	l32i	a9, a1, 176
  909627:	28122b        	l32i	a8, a1, 172
  90962a:	b4ab      	addi.n	a11, a10, 4
  90962c:	2a0aff        	movi	a10, 255
  90962f:	9a11      	s32i.n	a10, a1, 4
  909631:	2f1228        	l32i	a15, a1, 160
  909634:	c0a2      	movi.n	a10, 2
  909636:	9913      	s32i.n	a9, a1, 12
  909638:	9914      	s32i.n	a9, a1, 16
  90963a:	9a12      	s32i.n	a10, a1, 8
  90963c:	c1c8      	movi.n	a12, 24
  90963e:	da80      	mov.n	a10, a8
  909640:	c0d3      	movi.n	a13, 3
  909642:	c3ef      	movi.n	a14, 63
  909644:	9710      	s32i.n	a7, a1, 0
  909646:	0b2000        	callx8	a2
			    , HAL_TXKEYIX_INVALID
			    , flags
			    , 0
			    , 0);

	ah->ah_fillTxDesc(ds
  909649:	22122d        	l32i	a2, a1, 180
  90964c:	044a02        	or	a10, a4, a4
  90964f:	2f2218        	l32i	a15, a2, 96
  909652:	2f162a        	s32i	a15, a1, 168
  909655:	5bf58a        	call8	906c80 <__adf_nbuf_len>
  909658:	28122b        	l32i	a8, a1, 172
			   , asf_roundup(adf_nbuf_len(skb), 4)
  90965b:	b3aa      	addi.n	a10, a10, 3
			    , HAL_TXKEYIX_INVALID
			    , flags
			    , 0
			    , 0);

	ah->ah_fillTxDesc(ds
  90965d:	2f122a        	l32i	a15, a1, 168
			   , asf_roundup(adf_nbuf_len(skb), 4)
  909660:	0a2b14        	srli	a11, a10, 2
			    , HAL_TXKEYIX_INVALID
			    , flags
			    , 0
			    , 0);

	ah->ah_fillTxDesc(ds
  909663:	dc70      	mov.n	a12, a7
  909665:	dd70      	mov.n	a13, a7
  909667:	de80      	mov.n	a14, a8
  909669:	da80      	mov.n	a10, a8
  90966b:	0ebb11        	slli	a11, a11, 2
  90966e:	0bf000        	callx8	a15
			   , AH_TRUE
			   , AH_TRUE
			   , ds);

	series[0].Tries = 1;
	series[0].Rate = rate;
  909671:	241228        	l32i	a4, a1, 160
	series[0].ChSel = sc->sc_ic.ic_tx_chainmask;
	series[0].RateFlags = 0;
  909674:	29122c        	l32i	a9, a1, 176
			   , AH_TRUE
			   , AH_TRUE
			   , ds);

	series[0].Tries = 1;
	series[0].Rate = rate;
  909677:	9419      	s32i.n	a4, a1, 36
	series[0].ChSel = sc->sc_ic.ic_tx_chainmask;
  909679:	245d16        	addmi	a4, a5, 0x1600
  90967c:	244026        	l8ui	a4, a4, 38
	series[0].RateFlags = 0;
	ah->ah_set11nRateScenario(ds, 0, 0, series, 4, 0);
  90967f:	28122b        	l32i	a8, a1, 172
			   , AH_TRUE
			   , ds);

	series[0].Tries = 1;
	series[0].Rate = rate;
	series[0].ChSel = sc->sc_ic.ic_tx_chainmask;
  909682:	941b      	s32i.n	a4, a1, 44
	series[0].RateFlags = 0;
	ah->ah_set11nRateScenario(ds, 0, 0, series, 4, 0);
  909684:	24122d        	l32i	a4, a1, 180
  909687:	da80      	mov.n	a10, a8
  909689:	224210        	l32i	a2, a4, 64
  90968c:	db90      	mov.n	a11, a9
  90968e:	dc90      	mov.n	a12, a9
			   , ds);

	series[0].Tries = 1;
	series[0].Rate = rate;
	series[0].ChSel = sc->sc_ic.ic_tx_chainmask;
	series[0].RateFlags = 0;
  909690:	991c      	s32i.n	a9, a1, 48
	ah->ah_set11nRateScenario(ds, 0, 0, series, 4, 0);
  909692:	2d1c20        	addi	a13, a1, 32
  909695:	2e0a04        	movi	a14, 4
  909698:	df90      	mov.n	a15, a9
			   , asf_roundup(adf_nbuf_len(skb), 4)
			   , AH_TRUE
			   , AH_TRUE
			   , ds);

	series[0].Tries = 1;
  90969a:	271608        	s32i	a7, a1, 32
	series[0].Rate = rate;
	series[0].ChSel = sc->sc_ic.ic_tx_chainmask;
	series[0].RateFlags = 0;
	ah->ah_set11nRateScenario(ds, 0, 0, series, 4, 0);
  90969d:	0b2000        	callx8	a2

	adf_nbuf_map(sc->sc_dev, bf->bf_dmamap, nbuf, ADF_OS_DMA_TO_DEVICE);
	adf_nbuf_dmamap_info(bf->bf_dmamap,&bf->bf_dmamap_info);

	ath_beacon_setup(sc, bf, &sc->sc_vap[vap_index]);
	ah->ah_stopTxDma(ah, sc->sc_bhalq);
  9096a0:	255d01        	addmi	a5, a5, 0x100
  9096a3:	826d      	l32i.n	a2, a6, 52
  9096a5:	2b501c        	l8ui	a11, a5, 28
  9096a8:	da60      	mov.n	a10, a6
  9096aa:	0b2000        	callx8	a2
	ah->ah_setTxDP(ah, sc->sc_bhalq, ATH_BUF_GET_DESC_PHY_ADDR(bf));
  9096ad:	2b501c        	l8ui	a11, a5, 28
  9096b0:	826a      	l32i.n	a2, a6, 40
  9096b2:	8c3c      	l32i.n	a12, a3, 48
  9096b4:	da60      	mov.n	a10, a6
  9096b6:	0b2000        	callx8	a2
	ah->ah_startTxDma(ah, sc->sc_bhalq);
  9096b9:	2b501c        	l8ui	a11, a5, 28
  9096bc:	826c      	l32i.n	a2, a6, 48
  9096be:	066a02        	or	a10, a6, a6
  9096c1:	0b2000        	callx8	a2
  9096c4:	d10f      	retw.n
	...

009096c8 <ath_tgt_attach>:
	/* Start HTC messages exchange */
	HTC_Ready(sc->tgt_htc_handle);
}

a_int32_t ath_tgt_attach(a_uint32_t devid, struct ath_softc_tgt *sc, adf_os_device_t osdev)
{
  9096c8:	6c100e        	entry	a1, 112
 * @return int
 */
static inline int 
__adf_os_pci_config_read8(adf_os_device_t osdev, int offset, a_uint8_t *val)
{
    (*val) = wlan_pci_config_read(offset, 1);
  9096cb:	2b0a01        	movi	a11, 1
  9096ce:	2a0a0c        	movi	a10, 12
  9096d1:	580130        	call8	909b94 <wlan_pci_config_read>
  9096d4:	0a0a47        	extui	a10, a10, 0, 8
	a_uint8_t csz;

	adf_os_pci_config_read8(osdev, ATH_PCI_CACHE_LINE_SIZE, &csz);

	if (csz == 0)
		csz = 16;
  9096d7:	c160      	movi.n	a6, 16
  9096d9:	0a6a38        	moveqz	a10, a6, a10
	sc->sc_cachelsz = csz << 2;
  9096dc:	0ea511        	slli	a5, a10, 2
 */
static inline void 
adf_os_init_bh(adf_os_handle_t  hdl, adf_os_bh_t  *bh,
               adf_os_defer_fn_t  func,void  *arg)
{
    __adf_os_init_bh(hdl, bh, func, arg);
  9096df:	1b6a26        	l32r	a11, 8e3f78 <bStandardCommand+0x114>
  9096e2:	2a3a14        	movi	a10, 0x314

	sc->sc_dev = osdev;
  9096e5:	243646        	s32i	a4, a3, 0x118
	sc->sc_hdl = osdev;
  9096e8:	243645        	s32i	a4, a3, 0x114
  9096eb:	aa3a      	add.n	a10, a3, a10
  9096ed:	dc30      	mov.n	a12, a3

	adf_os_pci_config_read8(osdev, ATH_PCI_CACHE_LINE_SIZE, &csz);

	if (csz == 0)
		csz = 16;
	sc->sc_cachelsz = csz << 2;
  9096ef:	253596        	s16i	a5, a3, 0x12c
  9096f2:	5bf998        	call8	907d54 <__adf_os_init_bh$isra$4>
  9096f5:	1b6a27        	l32r	a11, 8e3f94 <bStandardCommand+0x130>
  9096f8:	2a5a1c        	movi	a10, 0x51c
  9096fb:	0a3a08        	add	a10, a3, a10
  9096fe:	033c02        	or	a12, a3, a3
  909701:	5bf994        	call8	907d54 <__adf_os_init_bh$isra$4>
  909704:	1b6a28        	l32r	a11, 8e3fa4 <bStandardCommand+0x140>
  909707:	2a3a24        	movi	a10, 0x324
  90970a:	aa3a      	add.n	a10, a3, a10
  90970c:	dc30      	mov.n	a12, a3
  90970e:	5bf991        	call8	907d54 <__adf_os_init_bh$isra$4>
  909711:	1b6a29        	l32r	a11, 8e3fb8 <bStandardCommand+0x154>
  909714:	2a3a44        	movi	a10, 0x344
  909717:	0a3a08        	add	a10, a3, a10
  90971a:	033c02        	or	a12, a3, a3
  90971d:	5bf98d        	call8	907d54 <__adf_os_init_bh$isra$4>
	ATH_INIT_TQUEUE(sc->sc_dev, &sc->sc_txtq, owl_tgt_tx_tasklet, sc);
	ATH_INIT_TQUEUE(sc->sc_dev, &sc->sc_bmisstq, ath_bmiss_tasklet, sc);
	ATH_INIT_TQUEUE(sc->sc_dev, &sc->sc_fataltq, ath_fatal_tasklet, sc);

	flags |= AH_USE_EEPROM;
	ah = _ath_hal_attach_tgt(devid, sc, sc->sc_dev, flags, &status);
  909720:	2c3246        	l32i	a12, a3, 0x118
  909723:	da20      	mov.n	a10, a2
  909725:	033b02        	or	a11, a3, a3
  909728:	c0d1      	movi.n	a13, 1
  90972a:	2e1c34        	addi	a14, a1, 52
  90972d:	5bf8ec        	call8	907ae0 <_ath_hal_attach_tgt>
  909730:	0aa402        	or	a4, a10, a10
	if (ah == NULL) {
  909733:	64a3d7        	beqz	a10, 909b0e <ath_tgt_attach+0x446>
	HTC_CONFIG htc_conf;
	WMI_SVC_CONFIG wmiConfig;
	WMI_DISPATCH_TABLE *Magpie_Sys_Commands_Tbl;

	/* Init dynamic buf pool */
	sc->pool_handle = BUF_Pool_init(sc->sc_hdl);
  909736:	126915        	l32r	a2, 8e3b8c <bSet_configuration+0x38>
	ah = _ath_hal_attach_tgt(devid, sc, sc->sc_dev, flags, &status);
	if (ah == NULL) {
		error = ENXIO;
		goto bad;
	}
	sc->sc_ah = ah;
  909739:	273d05        	addmi	a7, a3, 0x500
	HTC_CONFIG htc_conf;
	WMI_SVC_CONFIG wmiConfig;
	WMI_DISPATCH_TABLE *Magpie_Sys_Commands_Tbl;

	/* Init dynamic buf pool */
	sc->pool_handle = BUF_Pool_init(sc->sc_hdl);
  90973c:	252299        	l32i	a5, a2, 0x264
	ah = _ath_hal_attach_tgt(devid, sc, sc->sc_dev, flags, &status);
	if (ah == NULL) {
		error = ENXIO;
		goto bad;
	}
	sc->sc_ah = ah;
  90973f:	2a760b        	s32i	a10, a7, 44
	HTC_CONFIG htc_conf;
	WMI_SVC_CONFIG wmiConfig;
	WMI_DISPATCH_TABLE *Magpie_Sys_Commands_Tbl;

	/* Init dynamic buf pool */
	sc->pool_handle = BUF_Pool_init(sc->sc_hdl);
  909742:	2a3245        	l32i	a10, a3, 0x114
  909745:	0b5000        	callx8	a5

	/* Init target-side HIF */
	sc->tgt_hif_handle = HIF_init(0);
  909748:	252270        	l32i	a5, a2, 0x1c0
	HTC_CONFIG htc_conf;
	WMI_SVC_CONFIG wmiConfig;
	WMI_DISPATCH_TABLE *Magpie_Sys_Commands_Tbl;

	/* Init dynamic buf pool */
	sc->pool_handle = BUF_Pool_init(sc->sc_hdl);
  90974b:	2a3600        	s32i	a10, a3, 0

	/* Init target-side HIF */
	sc->tgt_hif_handle = HIF_init(0);
  90974e:	2a0a00        	movi	a10, 0
  909751:	0b5000        	callx8	a5

	/* Init target-side HTC */
	htc_conf.HIFHandle = sc->tgt_hif_handle;
	htc_conf.CreditSize = 320;
  909754:	251a40        	movi	a5, 0x140
  909757:	9514      	s32i.n	a5, a1, 16
	htc_conf.CreditNumber = ATH_TXBUF;
  909759:	c25d      	movi.n	a5, 45
  90975b:	9515      	s32i.n	a5, a1, 20
	htc_conf.OSHandle = sc->sc_hdl;
  90975d:	253245        	l32i	a5, a3, 0x114

	/* Init dynamic buf pool */
	sc->pool_handle = BUF_Pool_init(sc->sc_hdl);

	/* Init target-side HIF */
	sc->tgt_hif_handle = HIF_init(0);
  909760:	9a31      	s32i.n	a10, a3, 4

	/* Init target-side HTC */
	htc_conf.HIFHandle = sc->tgt_hif_handle;
	htc_conf.CreditSize = 320;
	htc_conf.CreditNumber = ATH_TXBUF;
	htc_conf.OSHandle = sc->sc_hdl;
  909762:	9516      	s32i.n	a5, a1, 24
	htc_conf.PoolHandle = sc->pool_handle;
  909764:	8530      	l32i.n	a5, a3, 0

	/* Init target-side HIF */
	sc->tgt_hif_handle = HIF_init(0);

	/* Init target-side HTC */
	htc_conf.HIFHandle = sc->tgt_hif_handle;
  909766:	9a17      	s32i.n	a10, a1, 28
	htc_conf.CreditSize = 320;
	htc_conf.CreditNumber = ATH_TXBUF;
	htc_conf.OSHandle = sc->sc_hdl;
	htc_conf.PoolHandle = sc->pool_handle;
  909768:	9518      	s32i.n	a5, a1, 32
	sc->tgt_htc_handle = HTC_init(htc_setup_comp, &htc_conf);
  90976a:	1a6a2a        	l32r	a10, 8e4014 <bStandardCommand+0x1b0>
  90976d:	25227e        	l32i	a5, a2, 0x1f8
  909770:	a61b      	add.n	a11, a1, a6
  909772:	0b5000        	callx8	a5
#if defined(PROJECT_MAGPIE)
	init_htc_handle = sc->tgt_htc_handle;
  909775:	156969        	l32r	a5, 8e3d1c <bSet_configuration+0x1c8>
#endif

	tgt_reg_service(sc, &sc->htc_beacon_service, WMI_BEACON_SVC, tgt_HTCRecv_beaconhandler);
  909778:	1d6a2b        	l32r	a13, 8e4024 <bStandardCommand+0x1c0>
	htc_conf.CreditNumber = ATH_TXBUF;
	htc_conf.OSHandle = sc->sc_hdl;
	htc_conf.PoolHandle = sc->pool_handle;
	sc->tgt_htc_handle = HTC_init(htc_setup_comp, &htc_conf);
#if defined(PROJECT_MAGPIE)
	init_htc_handle = sc->tgt_htc_handle;
  90977b:	9a50      	s32i.n	a10, a5, 0
#endif

	tgt_reg_service(sc, &sc->htc_beacon_service, WMI_BEACON_SVC, tgt_HTCRecv_beaconhandler);
  90977d:	a63b      	add.n	a11, a3, a6
	htc_conf.HIFHandle = sc->tgt_hif_handle;
	htc_conf.CreditSize = 320;
	htc_conf.CreditNumber = ATH_TXBUF;
	htc_conf.OSHandle = sc->sc_hdl;
	htc_conf.PoolHandle = sc->pool_handle;
	sc->tgt_htc_handle = HTC_init(htc_setup_comp, &htc_conf);
  90977f:	9a32      	s32i.n	a10, a3, 8
#if defined(PROJECT_MAGPIE)
	init_htc_handle = sc->tgt_htc_handle;
#endif

	tgt_reg_service(sc, &sc->htc_beacon_service, WMI_BEACON_SVC, tgt_HTCRecv_beaconhandler);
  909781:	2c1a01        	movi	a12, 0x101
  909784:	da30      	mov.n	a10, a3
  909786:	5bf90f        	call8	907bc4 <tgt_reg_service>
	tgt_reg_service(sc, &sc->htc_cab_service, WMI_CAB_SVC, tgt_HTCRecv_cabhandler);
  909789:	1d6a2c        	l32r	a13, 8e403c <bStandardCommand+0x1d8>
  90978c:	033a02        	or	a10, a3, a3
  90978f:	2b3c2c        	addi	a11, a3, 44
  909792:	2c1a02        	movi	a12, 0x102
  909795:	5bf90b        	call8	907bc4 <tgt_reg_service>
	tgt_reg_service(sc, &sc->htc_uapsd_service, WMI_UAPSD_SVC, tgt_HTCRecv_uapsdhandler);
  909798:	1d6a2d        	l32r	a13, 8e404c <bStandardCommand+0x1e8>
  90979b:	da30      	mov.n	a10, a3
  90979d:	2b3c48        	addi	a11, a3, 72
  9097a0:	2c1a03        	movi	a12, 0x103
  9097a3:	5bf908        	call8	907bc4 <tgt_reg_service>
	tgt_reg_service(sc, &sc->htc_mgmt_service, WMI_MGMT_SVC, tgt_HTCRecv_mgmthandler);
  9097a6:	1d6a2e        	l32r	a13, 8e4060 <bStandardCommand+0x1fc>
  9097a9:	033a02        	or	a10, a3, a3
  9097ac:	2b3c64        	addi	a11, a3, 100
  9097af:	2c1a04        	movi	a12, 0x104
  9097b2:	5bf904        	call8	907bc4 <tgt_reg_service>
	tgt_reg_service(sc, &sc->htc_data_BE_service, WMI_DATA_BE_SVC, tgt_HTCRecvMessageHandler);
  9097b5:	156a2f        	l32r	a5, 8e4074 <bStandardCommand+0x210>
  9097b8:	2b0ab8        	movi	a11, 184
  9097bb:	dd50      	mov.n	a13, a5
  9097bd:	da30      	mov.n	a10, a3
  9097bf:	0b3b08        	add	a11, a3, a11
  9097c2:	2c1a07        	movi	a12, 0x107
  9097c5:	5bf8ff        	call8	907bc4 <tgt_reg_service>
	tgt_reg_service(sc, &sc->htc_data_BK_service, WMI_DATA_BK_SVC, tgt_HTCRecvMessageHandler);
  9097c8:	2b0ad4        	movi	a11, 212
  9097cb:	dd50      	mov.n	a13, a5
  9097cd:	da30      	mov.n	a10, a3
  9097cf:	0b3b08        	add	a11, a3, a11
  9097d2:	2c1a08        	movi	a12, 0x108
  9097d5:	5bf8fb        	call8	907bc4 <tgt_reg_service>
	tgt_reg_service(sc, &sc->htc_data_VI_service, WMI_DATA_VI_SVC, tgt_HTCRecvMessageHandler);
  9097d8:	2b0a9c        	movi	a11, 156
  9097db:	dd50      	mov.n	a13, a5
  9097dd:	da30      	mov.n	a10, a3
  9097df:	0b3b08        	add	a11, a3, a11
  9097e2:	2c1a06        	movi	a12, 0x106
  9097e5:	5bf8f7        	call8	907bc4 <tgt_reg_service>
	tgt_reg_service(sc, &sc->htc_data_VO_service, WMI_DATA_VO_SVC, tgt_HTCRecvMessageHandler);
  9097e8:	2b0a80        	movi	a11, 128
  9097eb:	dd50      	mov.n	a13, a5
  9097ed:	ab3b      	add.n	a11, a3, a11
  9097ef:	2c1a05        	movi	a12, 0x105
  9097f2:	033a02        	or	a10, a3, a3
  9097f5:	5bf8f3        	call8	907bc4 <tgt_reg_service>
 * @return Buffer pointer or NULL if there's not enough memory.
 */
static inline void *
adf_os_mem_alloc(adf_os_size_t size)
{
    return __adf_os_mem_alloc(size);
  9097f8:	da60      	mov.n	a10, a6
  9097fa:	5bf8d8        	call8	907b5c <__adf_os_mem_alloc>
}
/* zero a memory buffer */
static inline void
__adf_os_mem_zero(void *buf, adf_os_size_t size)
{
    A_MEMZERO(buf,size);
  9097fd:	8824      	l32i.n	a8, a2, 16
  9097ff:	dc60      	mov.n	a12, a6
  909801:	c0b0      	movi.n	a11, 0
  909803:	d5a0      	mov.n	a5, a10
  909805:	0b8000        	callx8	a8

	/* Init target-side WMI */
	Magpie_Sys_Commands_Tbl = (WMI_DISPATCH_TABLE *)adf_os_mem_alloc(sizeof(WMI_DISPATCH_TABLE));
	adf_os_mem_zero(Magpie_Sys_Commands_Tbl, sizeof(WMI_DISPATCH_TABLE));
	Magpie_Sys_Commands_Tbl->NumberOfEntries = WMI_DISPATCH_ENTRY_COUNT(Magpie_Sys_DispatchEntries);
  909808:	c280      	movi.n	a8, 32
  90980a:	9852      	s32i.n	a8, a5, 8
	Magpie_Sys_Commands_Tbl->pTable = Magpie_Sys_DispatchEntries;
  90980c:	186a30        	l32r	a8, 8e40cc <bStandardCommand+0x268>
  90980f:	dc60      	mov.n	a12, a6
  909811:	9853      	s32i.n	a8, a5, 12
  909813:	8824      	l32i.n	a8, a2, 16
  909815:	c0b0      	movi.n	a11, 0
  909817:	2a1c24        	addi	a10, a1, 36
  90981a:	0b8000        	callx8	a8

	adf_os_mem_zero(&wmiConfig, sizeof(WMI_SVC_CONFIG));
	wmiConfig.HtcHandle = sc->tgt_htc_handle;
  90981d:	8632      	l32i.n	a6, a3, 8
	wmiConfig.PoolHandle = sc->pool_handle;
	wmiConfig.MaxCmdReplyEvts = ATH_WMI_MAX_CMD_REPLY;
	wmiConfig.MaxEventEvts = ATH_WMI_MAX_EVENTS;

	sc->tgt_wmi_handle = WMI_Init(&wmiConfig);
  90981f:	2a1c24        	addi	a10, a1, 36
	adf_os_mem_zero(Magpie_Sys_Commands_Tbl, sizeof(WMI_DISPATCH_TABLE));
	Magpie_Sys_Commands_Tbl->NumberOfEntries = WMI_DISPATCH_ENTRY_COUNT(Magpie_Sys_DispatchEntries);
	Magpie_Sys_Commands_Tbl->pTable = Magpie_Sys_DispatchEntries;

	adf_os_mem_zero(&wmiConfig, sizeof(WMI_SVC_CONFIG));
	wmiConfig.HtcHandle = sc->tgt_htc_handle;
  909822:	9619      	s32i.n	a6, a1, 36
	wmiConfig.PoolHandle = sc->pool_handle;
  909824:	8630      	l32i.n	a6, a3, 0
  909826:	961a      	s32i.n	a6, a1, 40
	wmiConfig.MaxCmdReplyEvts = ATH_WMI_MAX_CMD_REPLY;
  909828:	c062      	movi.n	a6, 2
  90982a:	961b      	s32i.n	a6, a1, 44
	wmiConfig.MaxEventEvts = ATH_WMI_MAX_EVENTS;
  90982c:	c068      	movi.n	a6, 8
  90982e:	961c      	s32i.n	a6, a1, 48

	sc->tgt_wmi_handle = WMI_Init(&wmiConfig);
  909830:	26228b        	l32i	a6, a2, 0x22c
  909833:	0b6000        	callx8	a6
  909836:	9a33      	s32i.n	a10, a3, 12
	Magpie_Sys_Commands_Tbl->pContext = sc;
	WMI_RegisterDispatchTable(sc->tgt_wmi_handle, Magpie_Sys_Commands_Tbl);
  909838:	26228c        	l32i	a6, a2, 0x230
  90983b:	db50      	mov.n	a11, a5
	wmiConfig.PoolHandle = sc->pool_handle;
	wmiConfig.MaxCmdReplyEvts = ATH_WMI_MAX_CMD_REPLY;
	wmiConfig.MaxEventEvts = ATH_WMI_MAX_EVENTS;

	sc->tgt_wmi_handle = WMI_Init(&wmiConfig);
	Magpie_Sys_Commands_Tbl->pContext = sc;
  90983d:	9351      	s32i.n	a3, a5, 4
	WMI_RegisterDispatchTable(sc->tgt_wmi_handle, Magpie_Sys_Commands_Tbl);
  90983f:	0b6000        	callx8	a6

	HTC_NotifyTargetInserted(sc->tgt_htc_handle);

	/* Start HTC messages exchange */
	HTC_Ready(sc->tgt_htc_handle);
  909842:	8a32      	l32i.n	a10, a3, 8
  909844:	222281        	l32i	a2, a2, 0x204
	}
	sc->sc_ah = ah;

	tgt_hif_htc_wmi_init(sc);

	sc->sc_bhalq = HAL_NUM_TX_QUEUES - 1;
  909847:	c059      	movi.n	a5, 9
	WMI_RegisterDispatchTable(sc->tgt_wmi_handle, Magpie_Sys_Commands_Tbl);

	HTC_NotifyTargetInserted(sc->tgt_htc_handle);

	/* Start HTC messages exchange */
	HTC_Ready(sc->tgt_htc_handle);
  909849:	0b2000        	callx8	a2
	return (tsf + (u_int64_t)tsf_delta);
}

static a_int32_t ath_rate_setup(struct ath_softc_tgt *sc, a_uint32_t mode)
{
	struct ath_hal *ah = sc->sc_ah;
  90984c:	8a7b      	l32i.n	a10, a7, 44
	}
	sc->sc_ah = ah;

	tgt_hif_htc_wmi_init(sc);

	sc->sc_bhalq = HAL_NUM_TX_QUEUES - 1;
  90984e:	223d01        	addmi	a2, a3, 0x100
  909851:	25241c        	s8i	a5, a2, 28
	struct ath_hal *ah = sc->sc_ah;
	const HAL_RATE_TABLE *rt;

	switch (mode) {
	case IEEE80211_MODE_11NA:
		sc->sc_rates[mode] = ah->ah_getRateTable(ah, HAL_MODE_11NA);
  909854:	82a5      	l32i.n	a2, a10, 20
  909856:	1b6a31        	l32r	a11, 8e411c <bStandardCommand+0x2b8>
  909859:	0b2000        	callx8	a2
  90985c:	2a367f        	s32i	a10, a3, 0x1fc
	return (tsf + (u_int64_t)tsf_delta);
}

static a_int32_t ath_rate_setup(struct ath_softc_tgt *sc, a_uint32_t mode)
{
	struct ath_hal *ah = sc->sc_ah;
  90985f:	8a7b      	l32i.n	a10, a7, 44
	switch (mode) {
	case IEEE80211_MODE_11NA:
		sc->sc_rates[mode] = ah->ah_getRateTable(ah, HAL_MODE_11NA);
		break;
	case IEEE80211_MODE_11NG:
		sc->sc_rates[mode] = ah->ah_getRateTable(ah, HAL_MODE_11NG);
  909861:	1b6a32        	l32r	a11, 8e412c <bStandardCommand+0x2c8>
  909864:	82a5      	l32i.n	a2, a10, 20
  909866:	0b2000        	callx8	a2
  909869:	2a3680        	s32i	a10, a3, 0x200
	sc->sc_bhalq = HAL_NUM_TX_QUEUES - 1;

	ath_rate_setup(sc, IEEE80211_MODE_11NA);
	ath_rate_setup(sc, IEEE80211_MODE_11NG);

	sc->sc_rc = ath_rate_attach(sc);
  90986c:	da30      	mov.n	a10, a3
  90986e:	580d57        	call8	90cdcc <ath_rate_attach>
  909871:	2a3648        	s32i	a10, a3, 0x120
	if (sc->sc_rc == NULL) {
  909874:	64a296        	beqz	a10, 909b0e <ath_tgt_attach+0x446>

	/* Start HTC messages exchange */
	HTC_Ready(sc->tgt_htc_handle);
}

a_int32_t ath_tgt_attach(a_uint32_t devid, struct ath_softc_tgt *sc, adf_os_device_t osdev)
  909877:	156a1d        	l32r	a5, 8e40ec <bStandardCommand+0x288>
  90987a:	d230      	mov.n	a2, a3
  90987c:	a535      	add.n	a5, a3, a5
  90987e:	277a40        	movi	a7, 0x740
		error = EIO;
		goto bad2;
	}

	for (i=0; i < TARGET_NODE_MAX; i++) {
		sc->sc_sta[i].an_rcnode = adf_os_mem_alloc(sc->sc_rc->arc_space);
  909881:	263248        	l32i	a6, a3, 0x120
  909884:	2a6200        	l32i	a10, a6, 0

	/* Start HTC messages exchange */
	HTC_Ready(sc->tgt_htc_handle);
}

a_int32_t ath_tgt_attach(a_uint32_t devid, struct ath_softc_tgt *sc, adf_os_device_t osdev)
  909887:	a726      	add.n	a6, a2, a7
  909889:	5bf8b4        	call8	907b5c <__adf_os_mem_alloc>
		error = EIO;
		goto bad2;
	}

	for (i=0; i < TARGET_NODE_MAX; i++) {
		sc->sc_sta[i].an_rcnode = adf_os_mem_alloc(sc->sc_rc->arc_space);
  90988c:	9a60      	s32i.n	a10, a6, 0
  90988e:	262a0c        	movi	a6, 0x20c
  909891:	a622      	add.n	a2, a2, a6
	if (sc->sc_rc == NULL) {
		error = EIO;
		goto bad2;
	}

	for (i=0; i < TARGET_NODE_MAX; i++) {
  909893:	7529ea        	bne	a2, a5, 909881 <ath_tgt_attach+0x1b9>
	((_dd)->dd_desc_paddr + ((caddr_t)(_ds) - (caddr_t)(_dd)->dd_desc))

	a_int32_t error;
	struct ath_tx_buf *bf;

	if(ath_numrxbufs == -1)
  909896:	126a10        	l32r	a2, 8e40d8 <bStandardCommand+0x274>
  909899:	8520      	l32i.n	a5, a2, 0
  90989b:	695005        	bnei	a5, -1, 9098a4 <ath_tgt_attach+0x1dc>
		ath_numrxbufs = ATH_RXBUF;
  90989e:	250a14        	movi	a5, 20
  9098a1:	252600        	s32i	a5, a2, 0

	if (ath_numrxdescs == -1)
  9098a4:	126a33        	l32r	a2, 8e4170 <bStandardCommand+0x30c>
  9098a7:	8520      	l32i.n	a5, a2, 0
  9098a9:	695003        	bnei	a5, -1, 9098b0 <ath_tgt_attach+0x1e8>
		ath_numrxdescs = ATH_RXDESC;
  9098ac:	c154      	movi.n	a5, 20
  9098ae:	9520      	s32i.n	a5, a2, 0

	error = ath_descdma_setup(sc, &sc->sc_rxdma, (ath_bufhead *)&sc->sc_rxbuf,
  9098b0:	176a33        	l32r	a7, 8e417c <bStandardCommand+0x318>
  9098b3:	c524      	movi.n	a2, 84
  9098b5:	263a74        	movi	a6, 0x374
  9098b8:	253a54        	movi	a5, 0x354
  9098bb:	9210      	s32i.n	a2, a1, 0
  9098bd:	a636      	add.n	a6, a3, a6
  9098bf:	a535      	add.n	a5, a3, a5
  9098c1:	1d6a34        	l32r	a13, 8e4194 <bStandardCommand+0x330>
  9098c4:	8e70      	l32i.n	a14, a7, 0
  9098c6:	da30      	mov.n	a10, a3
  9098c8:	066b02        	or	a11, a6, a6
  9098cb:	055c02        	or	a12, a5, a5
  9098ce:	2f0a68        	movi	a15, 104
  9098d1:	5bfa2e        	call8	90818c <ath_descdma_setup$constprop$22>
				  "rx", ath_numrxdescs, 1,
				  sizeof(struct ath_rx_buf),
				  sizeof(struct ath_rx_desc));
	if (error != 0)
  9098d4:	65a236        	bnez	a10, 909b0e <ath_tgt_attach+0x446>
	a_uint32_t i;
	struct ath_descdma *dd = &sc->sc_rxdma;
	struct ath_rx_desc *ds = (struct ath_rx_desc *)dd->dd_desc;
	struct ath_rx_desc *ds_prev = NULL;

	asf_tailq_init(&sc->sc_rxdesc);
  9098d7:	283a64        	movi	a8, 0x364
  9098da:	a838      	add.n	a8, a3, a8
  9098dc:	2836da        	s32i	a8, a3, 0x368
	asf_tailq_init(&sc->sc_rxdesc_idle);
  9098df:	283a5c        	movi	a8, 0x35c
  9098e2:	a838      	add.n	a8, a3, a8
  9098e4:	2836d8        	s32i	a8, a3, 0x360
	if (error != 0)
		return error;

	a_uint32_t i;
	struct ath_descdma *dd = &sc->sc_rxdma;
	struct ath_rx_desc *ds = (struct ath_rx_desc *)dd->dd_desc;
  9098e7:	2232de        	l32i	a2, a3, 0x378
	struct ath_rx_desc *ds_prev = NULL;

	asf_tailq_init(&sc->sc_rxdesc);
  9098ea:	2a36d9        	s32i	a10, a3, 0x364
	asf_tailq_init(&sc->sc_rxdesc_idle);
  9098ed:	2a36d7        	s32i	a10, a3, 0x35c
		return error;

	a_uint32_t i;
	struct ath_descdma *dd = &sc->sc_rxdma;
	struct ath_rx_desc *ds = (struct ath_rx_desc *)dd->dd_desc;
	struct ath_rx_desc *ds_prev = NULL;
  9098f0:	d8a0      	mov.n	a8, a10

	asf_tailq_init(&sc->sc_rxdesc);
	asf_tailq_init(&sc->sc_rxdesc_idle);

	for (i = 0; i < ath_numrxdescs; i++, ds++) {
  9098f2:	dca0      	mov.n	a12, a10
  9098f4:	6000d9        	j	9099d1 <ath_tgt_attach+0x309>
  9098f7:	00002b        	mulsh	a0, a0, a0

		if (ds->ds_nbuf != ADF_NBUF_NULL) {
  9098fa:	20342a        	s8i	a0, a3, 42
  9098fd:	203529        	s16i	a0, a3, 82
  909900:	203608        	s32i	a0, a3, 32
  909903:	bb10      	addi.n	a0, a1, 11
  909905:	00aa11        	slli	a10, a10, 16
  909908:	0baa02        	or	a10, a10, a11
  90990b:	089911        	slli	a9, a9, 8
  90990e:	0a9902        	or	a9, a9, a10
  909911:	2a2037        	l8ui	a10, a2, 55
  909914:	09a902        	or	a9, a10, a9
  909917:	64900e        	beqz	a9, 909929 <ath_tgt_attach+0x261>
			ds->ds_nbuf = ADF_NBUF_NULL;
  90991a:	290a00        	movi	a9, 0
  90991d:	292434        	s8i	a9, a2, 52
  909920:	292435        	s8i	a9, a2, 53
  909923:	292436        	s8i	a9, a2, 54
  909926:	292437        	s8i	a9, a2, 55
 */
static inline a_status_t
adf_nbuf_dmamap_create(adf_os_device_t osdev,
                       adf_os_dma_map_t *dmap)
{
    return (__adf_nbuf_dmamap_create(osdev, dmap));
  909929:	2a3246        	l32i	a10, a3, 0x118
  90992c:	2b2c38        	addi	a11, a2, 56
  90992f:	281611        	s32i	a8, a1, 68
  909932:	2c1610        	s32i	a12, a1, 64
  909935:	5bf44a        	call8	906a60 <__adf_nbuf_dmamap_create>
		}

		if (adf_nbuf_dmamap_create(sc->sc_dev, &ds->ds_dmap) != A_STATUS_OK) {
  909938:	281211        	l32i	a8, a1, 68
  90993b:	2c1210        	l32i	a12, a1, 64
  90993e:	64a01c        	beqz	a10, 90995e <ath_tgt_attach+0x296>
			adf_os_assert(0);
  909941:	196915        	l32r	a9, 8e3d98 <bSet_configuration+0x244>
  909944:	1a69f6        	l32r	a10, 8e411c <bStandardCommand+0x2b8>
  909947:	299212        	l32i	a9, a9, 72
  90994a:	1b6a35        	l32r	a11, 8e4220 <bStandardCommand+0x3bc>
  90994d:	0b9000        	callx8	a9
  909950:	19697a        	l32r	a9, 8e3f38 <bStandardCommand+0xd4>
  909953:	2c1210        	l32i	a12, a1, 64
  909956:	0c0200        	memw
  909959:	8990      	l32i.n	a9, a9, 0
  90995b:	281211        	l32i	a8, a1, 68
		}

		ds->ds_daddr = DS2PHYS(&sc->sc_rxdma, ds);
  90995e:	2932de        	l32i	a9, a3, 0x378
  909961:	2a32e0        	l32i	a10, a3, 0x380
  909964:	09290c        	sub	a9, a2, a9
  909967:	aa99      	add.n	a9, a9, a10
  909969:	098d57        	extui	a13, a9, 24, 8
  90996c:	090b57        	extui	a11, a9, 16, 8
  90996f:	098a47        	extui	a10, a9, 8, 8
  909972:	090947        	extui	a9, a9, 0, 8
  909975:	2d2448        	s8i	a13, a2, 72
  909978:	2b2449        	s8i	a11, a2, 73
  90997b:	2a244a        	s8i	a10, a2, 74
  90997e:	29244b        	s8i	a9, a2, 75

		if (ds_prev) {
  909981:	64800b        	beqz	a8, 909990 <ath_tgt_attach+0x2c8>
			ds_prev->ds_link = ds->ds_daddr;
  909984:	2d8400        	s8i	a13, a8, 0
  909987:	2b8401        	s8i	a11, a8, 1
  90998a:	2a8402        	s8i	a10, a8, 2
  90998d:	298403        	s8i	a9, a8, 3
		}

		ds->ds_link = 0;
  909990:	c080      	movi.n	a8, 0
  909992:	282400        	s8i	a8, a2, 0
  909995:	282401        	s8i	a8, a2, 1
  909998:	282402        	s8i	a8, a2, 2
  90999b:	282403        	s8i	a8, a2, 3
		ds_prev = ds;

		asf_tailq_insert_tail(&sc->sc_rxdesc, ds, ds_list);
  90999e:	28244c        	s8i	a8, a2, 76
  9099a1:	28244d        	s8i	a8, a2, 77
  9099a4:	28244e        	s8i	a8, a2, 78
  9099a7:	28244f        	s8i	a8, a2, 79
  9099aa:	2832da        	l32i	a8, a3, 0x368
	struct ath_rx_desc *ds_prev = NULL;

	asf_tailq_init(&sc->sc_rxdesc);
	asf_tailq_init(&sc->sc_rxdesc_idle);

	for (i = 0; i < ath_numrxdescs; i++, ds++) {
  9099ad:	b1cc      	addi.n	a12, a12, 1
		}

		ds->ds_link = 0;
		ds_prev = ds;

		asf_tailq_insert_tail(&sc->sc_rxdesc, ds, ds_list);
  9099af:	088957        	extui	a9, a8, 24, 8
  9099b2:	292450        	s8i	a9, a2, 80
  9099b5:	080957        	extui	a9, a8, 16, 8
  9099b8:	292451        	s8i	a9, a2, 81
  9099bb:	088947        	extui	a9, a8, 8, 8
  9099be:	282453        	s8i	a8, a2, 83
  9099c1:	292452        	s8i	a9, a2, 82
  9099c4:	9280      	s32i.n	a2, a8, 0
  9099c6:	282c4c        	addi	a8, a2, 76
  9099c9:	2836da        	s32i	a8, a3, 0x368
	struct ath_rx_desc *ds_prev = NULL;

	asf_tailq_init(&sc->sc_rxdesc);
	asf_tailq_init(&sc->sc_rxdesc_idle);

	for (i = 0; i < ath_numrxdescs; i++, ds++) {
  9099cc:	d820      	mov.n	a8, a2
  9099ce:	222c54        	addi	a2, a2, 84
  9099d1:	8970      	l32i.n	a9, a7, 0
  9099d3:	79cb02        	bgeu	a12, a9, 9099d9 <ath_tgt_attach+0x311>
  9099d6:	63ff1f        	j	9098f9 <ath_tgt_attach+0x231>
		ds_prev = ds;

		asf_tailq_insert_tail(&sc->sc_rxdesc, ds, ds_list);
	}

	error = ath_descdma_setup(sc, &sc->sc_txdma, (ath_bufhead *)&sc->sc_txbuf,
  9099d9:	273a8c        	movi	a7, 0x38c
  9099dc:	223ac0        	movi	a2, 0x3c0
  9099df:	290a88        	movi	a9, 136
  9099e2:	a737      	add.n	a7, a3, a7
  9099e4:	a232      	add.n	a2, a3, a2
  9099e6:	1d6a36        	l32r	a13, 8e42c0 <bStandardCommand+0x45c>
  9099e9:	9910      	s32i.n	a9, a1, 0
  9099eb:	da30      	mov.n	a10, a3
  9099ed:	db70      	mov.n	a11, a7
  9099ef:	dc20      	mov.n	a12, a2
  9099f1:	c2ee      	movi.n	a14, 46
  9099f3:	2f0a94        	movi	a15, 148
  9099f6:	291610        	s32i	a9, a1, 64
  9099f9:	5bf9e4        	call8	90818c <ath_descdma_setup$constprop$22>
  9099fc:	d8a0      	mov.n	a8, a10
				  "tx", ATH_TXBUF + 1, ATH_TXDESC,
				  sizeof(struct ath_tx_buf),
				  sizeof(struct ath_tx_desc));
	if (error != 0) {
  9099fe:	291210        	l32i	a9, a1, 64
  909a01:	c8a4      	beqz.n	a10, 909a09 <ath_tgt_attach+0x341>
  909a03:	60002e        	j	909a35 <ath_tgt_attach+0x36d>
  909a06:	000000        	ill
		ath_descdma_cleanup(sc, &sc->sc_rxdma, (ath_bufhead *)&sc->sc_rxbuf,
				    ADF_OS_DMA_FROM_DEVICE);
		return error;
	}

	error = ath_descdma_setup(sc, &sc->sc_bdma, (ath_bufhead *)&sc->sc_bbuf,
  909a09:	1c6a37        	l32r	a12, 8e42e8 <bStandardCommand+0x484>
  909a0c:	2b3aa4        	movi	a11, 0x3a4
  909a0f:	1d6a38        	l32r	a13, 8e42f0 <bStandardCommand+0x48c>
  909a12:	9910      	s32i.n	a9, a1, 0
  909a14:	da30      	mov.n	a10, a3
  909a16:	ab3b      	add.n	a11, a3, a11
  909a18:	ac3c      	add.n	a12, a3, a12
  909a1a:	c0e1      	movi.n	a14, 1
  909a1c:	2f0a94        	movi	a15, 148
  909a1f:	281611        	s32i	a8, a1, 68
  909a22:	5bf9da        	call8	90818c <ath_descdma_setup$constprop$22>
				  "beacon", ATH_BCBUF, 1,
				  sizeof(struct ath_tx_buf),
				  sizeof(struct ath_tx_desc));
	if (error != 0) {
  909a25:	281211        	l32i	a8, a1, 68
  909a28:	c9a8      	beqz.n	a10, 909a44 <ath_tgt_attach+0x37c>
		ath_descdma_cleanup(sc, &sc->sc_txdma, (ath_bufhead *)&sc->sc_txbuf,
  909a2a:	da30      	mov.n	a10, a3
  909a2c:	db70      	mov.n	a11, a7
  909a2e:	dc20      	mov.n	a12, a2
  909a30:	dd80      	mov.n	a13, a8
  909a32:	5bf8a2        	call8	907cbc <ath_descdma_cleanup>
				    ADF_OS_DMA_TO_DEVICE);
		ath_descdma_cleanup(sc, &sc->sc_rxdma, (ath_bufhead *)&sc->sc_rxbuf,
  909a35:	da30      	mov.n	a10, a3
  909a37:	db60      	mov.n	a11, a6
  909a39:	dc50      	mov.n	a12, a5
  909a3b:	c0d1      	movi.n	a13, 1
  909a3d:	5bf89f        	call8	907cbc <ath_descdma_cleanup>
  909a40:	6000ca        	j	909b0e <ath_tgt_attach+0x446>
  909a43:	002232        	sext	a2, a2, 7
				    ADF_OS_DMA_FROM_DEVICE);
		return error;
	}

	bf = asf_tailq_first(&sc->sc_txbuf);
  909a46:	f0          	.byte 0xf0
	bf->bf_isaggr = bf->bf_isretried = bf->bf_retries = 0;
  909a47:	c65f      	movi.n	a5, -17
  909a49:	262087        	l8ui	a6, a2, 135
  909a4c:	2a2486        	s8i	a10, a2, 134
  909a4f:	056501        	and	a5, a6, a5
  909a52:	26fadf        	movi	a6, -33
  909a55:	065501        	and	a5, a5, a6
  909a58:	252487        	s8i	a5, a2, 135
	asf_tailq_remove(&sc->sc_txbuf, bf, bf_list);
  909a5b:	8529      	l32i.n	a5, a2, 36
  909a5d:	862a      	l32i.n	a6, a2, 40
  909a5f:	c856      	beqz.n	a5, 909a69 <ath_tgt_attach+0x3a1>
  909a61:	965a      	s32i.n	a6, a5, 40
  909a63:	600005        	j	909a6c <ath_tgt_attach+0x3a4>
  909a66:	000000        	ill
  909a69:	2636f1        	s32i	a6, a3, 0x3c4
  909a6c:	862a      	l32i.n	a6, a2, 40
	error = ath_desc_alloc(sc);
	if (error != 0) {
		goto bad;
	}

	BUF_Pool_create_pool(sc->pool_handle, POOL_ID_WLAN_RX_BUF, ath_numrxdescs, 1664);
  909a6e:	c0b3      	movi.n	a11, 3
		return error;
	}

	bf = asf_tailq_first(&sc->sc_txbuf);
	bf->bf_isaggr = bf->bf_isretried = bf->bf_retries = 0;
	asf_tailq_remove(&sc->sc_txbuf, bf, bf_list);
  909a70:	9560      	s32i.n	a5, a6, 0

	sc->sc_txbuf_held = bf;
  909a72:	2236dc        	s32i	a2, a3, 0x370
	error = ath_desc_alloc(sc);
	if (error != 0) {
		goto bad;
	}

	BUF_Pool_create_pool(sc->pool_handle, POOL_ID_WLAN_RX_BUF, ath_numrxdescs, 1664);
  909a75:	156a33        	l32r	a5, 8e4344 <bStandardCommand+0x4e0>
  909a78:	126915        	l32r	a2, 8e3ecc <bStandardCommand+0x68>
  909a7b:	2a3200        	l32i	a10, a3, 0
  909a7e:	22229b        	l32i	a2, a2, 0x26c
  909a81:	2c5200        	l32i	a12, a5, 0
  909a84:	2d6a80        	movi	a13, 0x680
  909a87:	0b2000        	callx8	a2
static void ath_tgt_txq_setup(struct ath_softc_tgt *sc)
{
	a_int32_t qnum;
	struct ath_txq *txq;

	sc->sc_txqsetup=0;
  909a8a:	c050      	movi.n	a5, 0
  909a8c:	223d03        	addmi	a2, a3, 0x300
  909a8f:	2524c8        	s8i	a5, a2, 200

	for (qnum=0;qnum<HAL_NUM_TX_QUEUES;qnum++) {
  909a92:	c050      	movi.n	a5, 0
		txq= &sc->sc_txq[qnum];
		txq->axq_qnum = qnum;
		txq->axq_link = NULL;
  909a94:	d750      	mov.n	a7, a5
		asf_tailq_init(&txq->axq_q);
		txq->axq_depth = 0;
		txq->axq_linkbuf = NULL;
		asf_tailq_init(&txq->axq_tidq);
		sc->sc_txqsetup |= 1<<qnum;
  909a96:	2a0a01        	movi	a10, 1
	struct ath_txq *txq;

	sc->sc_txqsetup=0;

	for (qnum=0;qnum<HAL_NUM_TX_QUEUES;qnum++) {
		txq= &sc->sc_txq[qnum];
  909a99:	285c1e        	addi	a8, a5, 30
  909a9c:	0b8811        	slli	a8, a8, 5
  909a9f:	a838      	add.n	a8, a3, a8
		txq->axq_qnum = qnum;
		txq->axq_link = NULL;
		asf_tailq_init(&txq->axq_q);
  909aa1:	298c14        	addi	a9, a8, 20

	sc->sc_txqsetup=0;

	for (qnum=0;qnum<HAL_NUM_TX_QUEUES;qnum++) {
		txq= &sc->sc_txq[qnum];
		txq->axq_qnum = qnum;
  909aa4:	9583      	s32i.n	a5, a8, 12
		txq->axq_link = NULL;
		asf_tailq_init(&txq->axq_q);
  909aa6:	9986      	s32i.n	a9, a8, 24
	struct ath_txq *txq;

	sc->sc_txqsetup=0;

	for (qnum=0;qnum<HAL_NUM_TX_QUEUES;qnum++) {
		txq= &sc->sc_txq[qnum];
  909aa8:	bc86      	addi.n	a6, a8, 12
		txq->axq_qnum = qnum;
		txq->axq_link = NULL;
  909aaa:	9784      	s32i.n	a7, a8, 16
		asf_tailq_init(&txq->axq_q);
  909aac:	9785      	s32i.n	a7, a8, 20
		txq->axq_depth = 0;
  909aae:	9787      	s32i.n	a7, a8, 28
		txq->axq_linkbuf = NULL;
  909ab0:	9788      	s32i.n	a7, a8, 32
		asf_tailq_init(&txq->axq_tidq);
  909ab2:	9789      	s32i.n	a7, a8, 36
  909ab4:	288c24        	addi	a8, a8, 36
  909ab7:	9867      	s32i.n	a8, a6, 28
		sc->sc_txqsetup |= 1<<qnum;
  909ab9:	263d03        	addmi	a6, a3, 0x300
  909abc:	2860c8        	l8ui	a8, a6, 200
  909abf:	005104        	ssl	a5
  909ac2:	00a91a        	sll	a9, a10
  909ac5:	089802        	or	a8, a9, a8
  909ac8:	2864c8        	s8i	a8, a6, 200
	a_int32_t qnum;
	struct ath_txq *txq;

	sc->sc_txqsetup=0;

	for (qnum=0;qnum<HAL_NUM_TX_QUEUES;qnum++) {
  909acb:	b155      	addi.n	a5, a5, 1
		txq= &sc->sc_txq[qnum];
		txq->axq_qnum = qnum;
		txq->axq_link = NULL;
  909acd:	c020      	movi.n	a2, 0
	a_int32_t qnum;
	struct ath_txq *txq;

	sc->sc_txqsetup=0;

	for (qnum=0;qnum<HAL_NUM_TX_QUEUES;qnum++) {
  909acf:	6959c6        	bnei	a5, 10, 909a99 <ath_tgt_attach+0x3d1>
		txq->axq_linkbuf = NULL;
		asf_tailq_init(&txq->axq_tidq);
		sc->sc_txqsetup |= 1<<qnum;
	}

	sc->sc_uapsdq  = &sc->sc_txq[UAPSDQ_NUM];
  909ad2:	264aec        	movi	a6, 0x4ec
  909ad5:	253d05        	addmi	a5, a3, 0x500
  909ad8:	a636      	add.n	a6, a3, a6
  909ada:	965d      	s32i.n	a6, a5, 52
	sc->sc_cabq    = &sc->sc_txq[CABQ_NUM];
  909adc:	264acc        	movi	a6, 0x4cc
  909adf:	a636      	add.n	a6, a3, a6
  909ae1:	965c      	s32i.n	a6, a5, 48

	sc->sc_ac2q[WME_AC_BE]  = &sc->sc_txq[0];
  909ae3:	263acc        	movi	a6, 0x3cc
  909ae6:	a636      	add.n	a6, a3, a6
  909ae8:	9653      	s32i.n	a6, a5, 12
	sc->sc_ac2q[WME_AC_BK]  = &sc->sc_txq[1];
  909aea:	263aec        	movi	a6, 0x3ec
  909aed:	a636      	add.n	a6, a3, a6
  909aef:	9654      	s32i.n	a6, a5, 16
	sc->sc_ac2q[WME_AC_VI]  = &sc->sc_txq[2];
  909af1:	264a0c        	movi	a6, 0x40c
  909af4:	a636      	add.n	a6, a3, a6
  909af6:	9655      	s32i.n	a6, a5, 20
	sc->sc_ac2q[WME_AC_VO]  = &sc->sc_txq[3];
  909af8:	264a2c        	movi	a6, 0x42c
  909afb:	a636      	add.n	a6, a3, a6
	}

	BUF_Pool_create_pool(sc->pool_handle, POOL_ID_WLAN_RX_BUF, ath_numrxdescs, 1664);

	ath_tgt_txq_setup(sc);
	sc->sc_imask =0;
  909afd:	2236c4        	s32i	a2, a3, 0x310
	ah->ah_setInterrupts(ah, 0);
  909b00:	234228        	l32i	a3, a4, 160
	sc->sc_cabq    = &sc->sc_txq[CABQ_NUM];

	sc->sc_ac2q[WME_AC_BE]  = &sc->sc_txq[0];
	sc->sc_ac2q[WME_AC_BK]  = &sc->sc_txq[1];
	sc->sc_ac2q[WME_AC_VI]  = &sc->sc_txq[2];
	sc->sc_ac2q[WME_AC_VO]  = &sc->sc_txq[3];
  909b03:	9656      	s32i.n	a6, a5, 24

	BUF_Pool_create_pool(sc->pool_handle, POOL_ID_WLAN_RX_BUF, ath_numrxdescs, 1664);

	ath_tgt_txq_setup(sc);
	sc->sc_imask =0;
	ah->ah_setInterrupts(ah, 0);
  909b05:	da40      	mov.n	a10, a4
  909b07:	db20      	mov.n	a11, a2
  909b09:	0b3000        	callx8	a3
  909b0c:	d10f      	retw.n

	return 0;
bad:
bad2:
	ath_desc_free(sc);
  909b0e:	da30      	mov.n	a10, a3
  909b10:	5bf98b        	call8	908140 <ath_desc_free>
	if (ah)
  909b13:	c845      	beqz.n	a4, 909b1c <ath_tgt_attach+0x454>
		ah->ah_detach(ah);
  909b15:	8246      	l32i.n	a2, a4, 24
  909b17:	da40      	mov.n	a10, a4
  909b19:	0b2000        	callx8	a2
}
  909b1c:	d10f      	retw.n
	...

00909b20 <ath_detach>:
	HIF_shutdown(sc->tgt_hif_handle);
	BUF_Pool_shutdown(sc->pool_handle);
}

a_int32_t ath_detach(struct ath_softc_tgt *sc)
{
  909b20:	6c1004        	entry	a1, 32

static void tgt_hif_htc_wmi_shutdown(struct ath_softc_tgt *sc)
{
	HTC_NotifyTargetDetached(sc->tgt_htc_handle);

	WMI_Shutdown(sc->tgt_wmi_handle);
  909b23:	136915        	l32r	a3, 8e3f78 <bStandardCommand+0x114>
  909b26:	8a23      	l32i.n	a10, a2, 12
  909b28:	283292        	l32i	a8, a3, 0x248
  909b2b:	0b8000        	callx8	a8
	HTC_Shutdown(sc->tgt_htc_handle);
  909b2e:	8a22      	l32i.n	a10, a2, 8
  909b30:	28327f        	l32i	a8, a3, 0x1fc
  909b33:	0b8000        	callx8	a8
	HIF_shutdown(sc->tgt_hif_handle);
  909b36:	8a21      	l32i.n	a10, a2, 4
  909b38:	283271        	l32i	a8, a3, 0x1c4
  909b3b:	0b8000        	callx8	a8
	BUF_Pool_shutdown(sc->pool_handle);
  909b3e:	8a20      	l32i.n	a10, a2, 0
  909b40:	23329a        	l32i	a3, a3, 0x268
  909b43:	0b3000        	callx8	a3
}

a_int32_t ath_detach(struct ath_softc_tgt *sc)
{
	tgt_hif_htc_wmi_shutdown(sc);
}
  909b46:	d10f      	retw.n

00909b48 <wlan_pci_module_init>:
adf_drv_info_t* g_wlan_drv = NULL;
adf_drv_handle_t g_wlan_drv_handle = NULL;
adf_os_drv_intr g_wlan_intr = NULL;

void wlan_pci_module_init(void)
{
  909b48:	6c1004        	entry	a1, 32
	if (g_pci_init_func != NULL) {
  909b4b:	186a39        	l32r	a8, 8e4430 <bStandardCommand+0x5cc>
  909b4e:	8a80      	l32i.n	a10, a8, 0
  909b50:	c8a1      	beqz.n	a10, 909b55 <wlan_pci_module_init+0xd>
		g_pci_init_func();
  909b52:	0ba000        	callx8	a10
  909b55:	d10f      	retw.n
	...

00909b58 <wlan_pci_register_drv>:
	}
}

void wlan_pci_register_drv(adf_drv_info_t *drv)
{
  909b58:	6c1004        	entry	a1, 32
	g_wlan_drv = drv;
  909b5b:	186a3a        	l32r	a8, 8e4444 <bStandardCommand+0x5e0>
  909b5e:	9280      	s32i.n	a2, a8, 0
  909b60:	d10f      	retw.n
	...

00909b64 <wlan_pci_config_write>:
mem_fail:
	return;        
}

int wlan_pci_config_write(int offset, a_uint32_t val, int width)
{
  909b64:	6c1006        	entry	a1, 48
#if MAGPIE_ENABLE_PCIE == 1    
	unsigned long addr = ( PCI_CONFIG_BASE_ADDR + offset ) & 0xfffffffc;
  909b67:	1a6a3b        	l32r	a10, 8e4454 <bStandardCommand+0x5f0>
  909b6a:	c78c      	movi.n	a8, -4
  909b6c:	aa2a      	add.n	a10, a2, a10
  909b6e:	08aa01        	and	a10, a10, a8
	A_UINT8 *ptr = (A_UINT8 *)addr;   
	A_UINT8 *valptr = (A_UINT8 *)&val; 
	int idx = offset & 0x3;
  909b71:	020241        	extui	a2, a2, 0, 2
mem_fail:
	return;        
}

int wlan_pci_config_write(int offset, a_uint32_t val, int width)
{
  909b74:	9310      	s32i.n	a3, a1, 0
	return;
mem_fail:
	return;        
}

int wlan_pci_config_write(int offset, a_uint32_t val, int width)
  909b76:	b319      	addi.n	a9, a1, 3
	A_UINT8 *ptr = (A_UINT8 *)addr;   
	A_UINT8 *valptr = (A_UINT8 *)&val; 
	int idx = offset & 0x3;
	int i;
    
	for (i = 0; i < width; i++) {
  909b78:	c080      	movi.n	a8, 0
	return;
mem_fail:
	return;        
}

int wlan_pci_config_write(int offset, a_uint32_t val, int width)
  909b7a:	a2a2      	add.n	a2, a10, a2
	A_UINT8 *ptr = (A_UINT8 *)addr;   
	A_UINT8 *valptr = (A_UINT8 *)&val; 
	int idx = offset & 0x3;
	int i;
    
	for (i = 0; i < width; i++) {
  909b7c:	60000c        	j	909b8c <wlan_pci_config_write+0x28>
  909b7f:	002b90        	l32e	a0, a2, -20
		ptr[idx + i] = valptr[3-i];
  909b82:	00a82a        	muluh	a8, a10, a0
  909b85:	2ba400        	s8i	a11, a10, 0
	A_UINT8 *ptr = (A_UINT8 *)addr;   
	A_UINT8 *valptr = (A_UINT8 *)&val; 
	int idx = offset & 0x3;
	int i;
    
	for (i = 0; i < width; i++) {
  909b88:	b188      	addi.n	a8, a8, 1
  909b8a:	b099      	addi.n	a9, a9, -1
  909b8c:	7482f0        	blt	a8, a4, 909b80 <wlan_pci_config_write+0x1c>
		ptr[idx + i] = valptr[3-i];
	}            
#endif
    
	return 0;    
}
  909b8f:	c020      	movi.n	a2, 0
  909b91:	d10f      	retw.n
	...

00909b94 <wlan_pci_config_read>:

int wlan_pci_config_read(int offset, int width)
{
  909b94:	6c1006        	entry	a1, 48
#if MAGPIE_ENABLE_PCIE == 0    
	return 0;    
#else
	unsigned long addr = ( PCI_CONFIG_BASE_ADDR + offset ) & 0xfffffffc;
  909b97:	186a3b        	l32r	a8, 8e4484 <bStandardCommand+0x620>
  909b9a:	c79c      	movi.n	a9, -4
  909b9c:	a828      	add.n	a8, a2, a8
  909b9e:	098801        	and	a8, a8, a9
	unsigned long value = *((unsigned long *)addr);
  909ba1:	8880      	l32i.n	a8, a8, 0
	A_UINT8 *ptr = (A_UINT8 *)&value;   
	int idx = offset & 0x3;
  909ba3:	020941        	extui	a9, a2, 0, 2
{
#if MAGPIE_ENABLE_PCIE == 0    
	return 0;    
#else
	unsigned long addr = ( PCI_CONFIG_BASE_ADDR + offset ) & 0xfffffffc;
	unsigned long value = *((unsigned long *)addr);
  909ba6:	9810      	s32i.n	a8, a1, 0
#endif
    
	return 0;    
}

int wlan_pci_config_read(int offset, int width)
  909ba8:	09190c        	sub	a9, a1, a9
	A_UINT8 *ptr = (A_UINT8 *)&value;   
	int idx = offset & 0x3;
	int result = 0;
	int i;
    
	for (i = 0; i < width; i++) {
  909bab:	c080      	movi.n	a8, 0
#endif
    
	return 0;    
}

int wlan_pci_config_read(int offset, int width)
  909bad:	b399      	addi.n	a9, a9, 3
#else
	unsigned long addr = ( PCI_CONFIG_BASE_ADDR + offset ) & 0xfffffffc;
	unsigned long value = *((unsigned long *)addr);
	A_UINT8 *ptr = (A_UINT8 *)&value;   
	int idx = offset & 0x3;
	int result = 0;
  909baf:	d280      	mov.n	a2, a8
	int i;
    
	for (i = 0; i < width; i++) {
  909bb1:	600012        	j	909bc7 <wlan_pci_config_read+0x33>
		result |= (ptr[ 3 - (idx + i)] << (8*i));
  909bb4:	2b9000        	l8ui	a11, a9, 0
#endif
    
	return 0;    
}

int wlan_pci_config_read(int offset, int width)
  909bb7:	0d8a11        	slli	a10, a8, 3
	int idx = offset & 0x3;
	int result = 0;
	int i;
    
	for (i = 0; i < width; i++) {
		result |= (ptr[ 3 - (idx + i)] << (8*i));
  909bba:	00a104        	ssl	a10
  909bbd:	00ba1a        	sll	a10, a11
  909bc0:	0a2202        	or	a2, a2, a10
	A_UINT8 *ptr = (A_UINT8 *)&value;   
	int idx = offset & 0x3;
	int result = 0;
	int i;
    
	for (i = 0; i < width; i++) {
  909bc3:	b188      	addi.n	a8, a8, 1
  909bc5:	b099      	addi.n	a9, a9, -1
  909bc7:	7382e9        	blt	a8, a3, 909bb4 <wlan_pci_config_read+0x20>
		result |= (ptr[ 3 - (idx + i)] << (8*i));
	}            
    
	return result;    
#endif    
}
  909bca:	d10f      	retw.n

00909bcc <wlan_pci_probe>:

#define ATHEROS_VENDOR_ID 0x168c
#define AR5416_DEVID_PCIE 0x24 	

void wlan_pci_probe(void)
{
  909bcc:	6c100a        	entry	a1, 80
	__adf_softc_t           *sc;
	adf_os_resource_t       drv_res = {0};
  909bcf:	c0b0      	movi.n	a11, 0
  909bd1:	2c0a18        	movi	a12, 24
  909bd4:	011a02        	or	a10, a1, a1
  909bd7:	5b749c        	call8	8e6e48 <memset>
	adf_os_attach_data_t    drv_data = {{0}};   
  909bda:	c1c0      	movi.n	a12, 16
  909bdc:	2b0a00        	movi	a11, 0
  909bdf:	2a1c18        	addi	a10, a1, 24
  909be2:	5b7499        	call8	8e6e48 <memset>
	int vendor_id;
	int device_id;

	A_PRINTF("<wlan_pci_probe>: Attaching the driver\n");
  909be5:	126915        	l32r	a2, 8e403c <bStandardCommand+0x1d8>
  909be8:	1a6a3c        	l32r	a10, 8e44d8 <bStandardCommand+0x674>
  909beb:	232212        	l32i	a3, a2, 72
  909bee:	0b3000        	callx8	a3

#if MAGPIE_ENABLE_PCIE == 0
	vendor_id = ATHEROS_VENDOR_ID;
	device_id = AR5416_DEVID_PCIE;
#else    
	vendor_id = wlan_pci_config_read(0, 2);
  909bf1:	c0b2      	movi.n	a11, 2
  909bf3:	c0a0      	movi.n	a10, 0
  909bf5:	5bffe7        	call8	909b94 <wlan_pci_config_read>
  909bf8:	d3a0      	mov.n	a3, a10
	device_id = wlan_pci_config_read(2, 2);
  909bfa:	c0a2      	movi.n	a10, 2
  909bfc:	dba0      	mov.n	a11, a10
  909bfe:	5bffe5        	call8	909b94 <wlan_pci_config_read>
  909c01:	0aac02        	or	a12, a10, a10
#endif    
	A_PRINTF("<wlan_pci_probe>: Vendor id 0x%x Dev id 0x%x\n", vendor_id, device_id);    
  909c04:	282212        	l32i	a8, a2, 72
  909c07:	1a6a3d        	l32r	a10, 8e44fc <bStandardCommand+0x698>
  909c0a:	033b02        	or	a11, a3, a3
  909c0d:	0b8000        	callx8	a8
    
	if (vendor_id != ATHEROS_VENDOR_ID) {
  909c10:	186a3e        	l32r	a8, 8e4508 <bStandardCommand+0x6a4>
  909c13:	783109        	beq	a3, a8, 909c20 <wlan_pci_probe+0x54>
		A_PRINTF("<wlan_pci_probe>: Atheros card not found\n"); 
  909c16:	222212        	l32i	a2, a2, 72
  909c19:	1a6a3f        	l32r	a10, 8e4518 <bStandardCommand+0x6b4>
  909c1c:	600012        	j	909c32 <wlan_pci_probe+0x66>
  909c1f:	002822        	excw
	}
            
	/**
	 * Allocate the sc & zero down
	 */
	sc = A_ALLOCRAM(sizeof(__adf_softc_t));
  909c22:	52c0a0        	call0	8b9ea4 <_bss_end+0x3a6f94>
  909c25:	c0b4      	movi.n	a11, 4
  909c27:	0b8000        	callx8	a8
	if (!sc) {
  909c2a:	ccaa      	bnez.n	a10, 909c38 <wlan_pci_probe+0x6c>
		A_PRINTF("Cannot malloc softc\n");
  909c2c:	222212        	l32i	a2, a2, 72
  909c2f:	1a6a40        	l32r	a10, 8e4530 <bStandardCommand+0x6cc>
  909c32:	0b2000        	callx8	a2
  909c35:	d10f      	retw.n
  909c37:	00c224        	excw
		goto mem_fail;
	}
    
#define AR5416_DEVID_PCIE 0x24 		

	drv_data.pci.device    = AR5416_DEVID_PCIE;
  909c3a:	9217      	s32i.n	a2, a1, 28
    
	drv_res.start  = (a_uint32_t) 0;
	drv_res.end    = 0;
	drv_res.type   = ADF_OS_RESOURCE_TYPE_MEM;
        
	g_wlan_drv_handle = g_wlan_drv->drv_attach(&drv_res, 1, &drv_data, NULL);
  909c3c:	126a3a        	l32r	a2, 8e4524 <bStandardCommand+0x6c0>
    
#define AR5416_DEVID_PCIE 0x24 		

	drv_data.pci.device    = AR5416_DEVID_PCIE;
	drv_data.pci.vendor    = 0x168c;
	drv_data.pci.subvendor = 0;
  909c3f:	c0d0      	movi.n	a13, 0
    
	drv_res.start  = (a_uint32_t) 0;
	drv_res.end    = 0;
	drv_res.type   = ADF_OS_RESOURCE_TYPE_MEM;
        
	g_wlan_drv_handle = g_wlan_drv->drv_attach(&drv_res, 1, &drv_data, NULL);
  909c41:	8220      	l32i.n	a2, a2, 0
	drv_data.pci.device    = AR5416_DEVID_PCIE;
	drv_data.pci.vendor    = 0x168c;
	drv_data.pci.subvendor = 0;
	drv_data.pci.subdevice = 0;
    
	drv_res.start  = (a_uint32_t) 0;
  909c43:	186a41        	l32r	a8, 8e4548 <bStandardCommand+0x6e4>
  909c46:	196a41        	l32r	a9, 8e454c <bStandardCommand+0x6e8>
	}
    
#define AR5416_DEVID_PCIE 0x24 		

	drv_data.pci.device    = AR5416_DEVID_PCIE;
	drv_data.pci.vendor    = 0x168c;
  909c49:	9316      	s32i.n	a3, a1, 24
	drv_data.pci.subvendor = 0;
  909c4b:	9d18      	s32i.n	a13, a1, 32
	drv_data.pci.subdevice = 0;
  909c4d:	9d19      	s32i.n	a13, a1, 36
    
	drv_res.start  = (a_uint32_t) 0;
	drv_res.end    = 0;
	drv_res.type   = ADF_OS_RESOURCE_TYPE_MEM;
        
	g_wlan_drv_handle = g_wlan_drv->drv_attach(&drv_res, 1, &drv_data, NULL);
  909c4f:	8220      	l32i.n	a2, a2, 0
	drv_data.pci.device    = AR5416_DEVID_PCIE;
	drv_data.pci.vendor    = 0x168c;
	drv_data.pci.subvendor = 0;
	drv_data.pci.subdevice = 0;
    
	drv_res.start  = (a_uint32_t) 0;
  909c51:	9810      	s32i.n	a8, a1, 0
  909c53:	9911      	s32i.n	a9, a1, 4
	drv_res.end    = 0;
  909c55:	9812      	s32i.n	a8, a1, 8
  909c57:	9913      	s32i.n	a9, a1, 12
	drv_res.type   = ADF_OS_RESOURCE_TYPE_MEM;
  909c59:	9d14      	s32i.n	a13, a1, 16
        
	g_wlan_drv_handle = g_wlan_drv->drv_attach(&drv_res, 1, &drv_data, NULL);
  909c5b:	da10      	mov.n	a10, a1
  909c5d:	c0b1      	movi.n	a11, 1
  909c5f:	2c1c18        	addi	a12, a1, 24
  909c62:	0b2000        	callx8	a2
  909c65:	126a42        	l32r	a2, 8e4570 <bStandardCommand+0x70c>
  909c68:	9a20      	s32i.n	a10, a2, 0
  909c6a:	d10f      	retw.n

00909c6c <wlan_pci_isr>:
	return result;    
#endif    
}

void wlan_pci_isr()
{
  909c6c:	6c1004        	entry	a1, 32
	if (g_wlan_intr != NULL && g_wlan_drv_handle != NULL) {
  909c6f:	186a43        	l32r	a8, 8e457c <bStandardCommand+0x718>
  909c72:	8880      	l32i.n	a8, a8, 0
  909c74:	c888      	beqz.n	a8, 909c80 <wlan_pci_isr+0x14>
  909c76:	196a42        	l32r	a9, 8e4580 <bStandardCommand+0x71c>
  909c79:	8a90      	l32i.n	a10, a9, 0
  909c7b:	c8a1      	beqz.n	a10, 909c80 <wlan_pci_isr+0x14>
		g_wlan_intr(g_wlan_drv_handle);
  909c7d:	0b8000        	callx8	a8
  909c80:	d10f      	retw.n
	...

00909c84 <_HTC_Shutdown>:
    
	return pHTC;
}

LOCAL void _HTC_Shutdown(htc_handle_t htcHandle)
{
  909c84:	6c1004        	entry	a1, 32
  909c87:	d10f      	retw.n
  909c89:	000000        	ill

00909c8c <_HTC_RegisterService>:
    
	adf_os_mem_free(pHTC);
}

LOCAL void _HTC_RegisterService(htc_handle_t htcHandle, HTC_SERVICE *pService)
{
  909c8c:	6c1004        	entry	a1, 32
	HTC_CONTEXT *pHTC = (HTC_CONTEXT *)htcHandle;
    
        /* add it to the list */
	pService->pNext = pHTC->pServiceList;
  909c8f:	282290        	l32i	a8, a2, 0x240
  909c92:	9830      	s32i.n	a8, a3, 0
	pHTC->pServiceList = pService;
  909c94:	232690        	s32i	a3, a2, 0x240
  909c97:	d10f      	retw.n
  909c99:	000000        	ill

00909c9c <_HTC_GetReservedHeadroom>:
void _HTC_ResumeRecv(HTC_ENDPOINT_ID EndpointID)
{
}

int _HTC_GetReservedHeadroom(htc_handle_t htcHandle)
{
  909c9c:	6c1004        	entry	a1, 32
	HTC_CONTEXT *pHTC = (HTC_CONTEXT *)htcHandle;  
    
	return HTC_HDR_LENGTH + HIF_get_reserved_headroom(pHTC->hifHandle);
  909c9f:	186915        	l32r	a8, 8e40f4 <bStandardCommand+0x290>
  909ca2:	2a229a        	l32i	a10, a2, 0x268
  909ca5:	28827a        	l32i	a8, a8, 0x1e8
  909ca8:	0b8000        	callx8	a8
}
  909cab:	b8a2      	addi.n	a2, a10, 8
  909cad:	d10f      	retw.n
	...

00909cb0 <HTCSendDoneHandler>:
		HTCCheckAndSendCreditReport(pHTC, HTC_ANY_ENDPOINT_MASK,NULL,ENDPOINT_MAX);
	}  
}

LOCAL void HTCSendDoneHandler(adf_nbuf_t buf, void *context)
{
  909cb0:	6c1004        	entry	a1, 32
 * @return data pointer to typecast into your priv structure
 */
static inline a_uint8_t *
adf_nbuf_get_priv(adf_nbuf_t buf)
{
    return (__adf_nbuf_get_priv(buf));
  909cb3:	022a02        	or	a10, a2, a2
  909cb6:	5bf350        	call8	9069f8 <__adf_nbuf_get_priv>
	A_UINT8 current_eid;
	HTC_CONTEXT *pHTC = (HTC_CONTEXT *)context;
	HTC_BUF_CONTEXT *ctx;
      
	ctx = (HTC_BUF_CONTEXT *)adf_nbuf_get_priv(buf);
	current_eid = ctx->end_point;
  909cb9:	24a000        	l8ui	a4, a10, 0
 *         or NULL if there is not sufficient data to pull.
 */
static inline a_uint8_t *
adf_nbuf_pull_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_pull_head(buf, size);
  909cbc:	c0b8      	movi.n	a11, 8
  909cbe:	022a02        	or	a10, a2, a2
  909cc1:	5bf328        	call8	906964 <__adf_nbuf_pull_head>
	/* Walk through the buffers and fixup the ones we used for HTC headers.
	 * The buffer list may contain more than one string of HTC buffers comprising of an
	 * HTC message so we need to check every buffer */            
	adf_nbuf_pull_head(buf, HTC_HDR_LENGTH);
                   
	pHTC->Endpoints[current_eid].pService->
  909cc4:	044809        	addx2	a8, a4, a4
  909cc7:	03830b        	addx8	a3, a8, a3
  909cca:	8832      	l32i.n	a8, a3, 8
		ProcessSendBufferComplete(current_eid, 
  909ccc:	da40      	mov.n	a10, a4
  909cce:	8982      	l32i.n	a9, a8, 8
  909cd0:	8c86      	l32i.n	a12, a8, 24
  909cd2:	022b02        	or	a11, a2, a2
  909cd5:	0b9000        	callx8	a9
  909cd8:	d10f      	retw.n
	...

00909cdc <HTC_AssembleBuffers>:
	if ((pEndpoint)->ConnectionFlags & HTC_CONNECT_FLAGS_REDUCE_CREDIT_DRIBBLE) { \
		AdjustCreditThreshold((pEndpoint));			\
	}    

LOCAL void HTC_AssembleBuffers(HTC_CONTEXT *pHTC, int Count, int Size)
{
  909cdc:	6c1004        	entry	a1, 32
	BUF_Pool_create_pool(pHTC->PoolHandle, POOL_ID_HTC_CONTROL, Count, Size);       
  909cdf:	186915        	l32r	a8, 8e4134 <bStandardCommand+0x2d0>
  909ce2:	2a229b        	l32i	a10, a2, 0x26c
  909ce5:	28829b        	l32i	a8, a8, 0x26c
  909ce8:	c0b0      	movi.n	a11, 0
  909cea:	dc30      	mov.n	a12, a3
  909cec:	dd40      	mov.n	a13, a4
  909cee:	0b8000        	callx8	a8
  909cf1:	d10f      	retw.n
	...

00909cf4 <_HTC_Init>:
}

LOCAL htc_handle_t _HTC_Init(HTC_SETUP_COMPLETE_CB SetupComplete,
                             HTC_CONFIG *pConfig)
{
  909cf4:	6c1006        	entry	a1, 48
#include "Magpie_api.h"

static inline void *	__adf_os_mem_alloc(adf_os_size_t size)
{
//    return (malloc(size,M_DEVBUF,M_DONTWAIT | M_ZERO));
    return A_ALLOCRAM(size);
  909cf7:	146915        	l32r	a4, 8e414c <bStandardCommand+0x2e8>
  909cfa:	022502        	or	a5, a2, a2
  909cfd:	224252        	l32i	a2, a4, 0x148
  909d00:	2b2a74        	movi	a11, 0x274
  909d03:	c0a0      	movi.n	a10, 0
  909d05:	0b2000        	callx8	a2
}
/* zero a memory buffer */
static inline void
__adf_os_mem_zero(void *buf, adf_os_size_t size)
{
    A_MEMZERO(buf,size);
  909d08:	8844      	l32i.n	a8, a4, 16
  909d0a:	2c2a74        	movi	a12, 0x274
  909d0d:	c0b0      	movi.n	a11, 0
#include "Magpie_api.h"

static inline void *	__adf_os_mem_alloc(adf_os_size_t size)
{
//    return (malloc(size,M_DEVBUF,M_DONTWAIT | M_ZERO));
    return A_ALLOCRAM(size);
  909d0f:	d2a0      	mov.n	a2, a10
}
/* zero a memory buffer */
static inline void
__adf_os_mem_zero(void *buf, adf_os_size_t size)
{
    A_MEMZERO(buf,size);
  909d11:	0b8000        	callx8	a8
    
        pHTC = (HTC_CONTEXT *)adf_os_mem_alloc(sizeof(HTC_CONTEXT));
    
	adf_os_mem_zero(pHTC, sizeof(HTC_CONTEXT));

	pHTC->OSHandle = pConfig->OSHandle;
  909d14:	8832      	l32i.n	a8, a3, 8
	pHTC->PoolHandle = pConfig->PoolHandle;
	pHTC->hifHandle = pConfig->HIFHandle;
  909d16:	8a33      	l32i.n	a10, a3, 12
    
        pHTC = (HTC_CONTEXT *)adf_os_mem_alloc(sizeof(HTC_CONTEXT));
    
	adf_os_mem_zero(pHTC, sizeof(HTC_CONTEXT));

	pHTC->OSHandle = pConfig->OSHandle;
  909d18:	9820      	s32i.n	a8, a2, 0
	pHTC->PoolHandle = pConfig->PoolHandle;
  909d1a:	8834      	l32i.n	a8, a3, 16
	hifCBConfig.send_buf_done = A_INDIR(htc._HTC_SendDoneHandler);
	hifCBConfig.recv_buf = A_INDIR(htc._HTC_MsgRecvHandler);
	hifCBConfig.context = pHTC;
    
	/* initialize hardware layer */
	HIF_register_callback(pConfig->HIFHandle, &hifCBConfig);
  909d1c:	db10      	mov.n	a11, a1
        pHTC = (HTC_CONTEXT *)adf_os_mem_alloc(sizeof(HTC_CONTEXT));
    
	adf_os_mem_zero(pHTC, sizeof(HTC_CONTEXT));

	pHTC->OSHandle = pConfig->OSHandle;
	pHTC->PoolHandle = pConfig->PoolHandle;
  909d1e:	28269b        	s32i	a8, a2, 0x26c
	pHTC->hifHandle = pConfig->HIFHandle;
                        
	hifCBConfig.send_buf_done = A_INDIR(htc._HTC_SendDoneHandler);
  909d21:	284287        	l32i	a8, a4, 0x21c
    
	adf_os_mem_zero(pHTC, sizeof(HTC_CONTEXT));

	pHTC->OSHandle = pConfig->OSHandle;
	pHTC->PoolHandle = pConfig->PoolHandle;
	pHTC->hifHandle = pConfig->HIFHandle;
  909d24:	2a269a        	s32i	a10, a2, 0x268
                        
	hifCBConfig.send_buf_done = A_INDIR(htc._HTC_SendDoneHandler);
  909d27:	9810      	s32i.n	a8, a1, 0
	hifCBConfig.recv_buf = A_INDIR(htc._HTC_MsgRecvHandler);
  909d29:	284286        	l32i	a8, a4, 0x218
	hifCBConfig.context = pHTC;
  909d2c:	9212      	s32i.n	a2, a1, 8
	pHTC->OSHandle = pConfig->OSHandle;
	pHTC->PoolHandle = pConfig->PoolHandle;
	pHTC->hifHandle = pConfig->HIFHandle;
                        
	hifCBConfig.send_buf_done = A_INDIR(htc._HTC_SendDoneHandler);
	hifCBConfig.recv_buf = A_INDIR(htc._HTC_MsgRecvHandler);
  909d2e:	9811      	s32i.n	a8, a1, 4
	hifCBConfig.context = pHTC;
    
	/* initialize hardware layer */
	HIF_register_callback(pConfig->HIFHandle, &hifCBConfig);
  909d30:	284272        	l32i	a8, a4, 0x1c8
  909d33:	0b8000        	callx8	a8
        /* see if the host wants us to override the number of ctrl buffers */
	pHTC->NumBuffersForCreditRpts = 0;
    
	if (0 == pHTC->NumBuffersForCreditRpts) {
		/* nothing to override, simply set default */
		pHTC->NumBuffersForCreditRpts = HTC_DEFAULT_NUM_CTRL_BUFFERS; 
  909d36:	c086      	movi.n	a8, 6
  909d38:	282696        	s32i	a8, a2, 0x258
	}    
    
	pHTC->MaxEpPendingCreditRpts = 0;
    
	if (0 == pHTC->MaxEpPendingCreditRpts) {
		pHTC->MaxEpPendingCreditRpts = HTC_DEFAULT_MAX_EP_PENDING_CREDIT_REPORTS;    
  909d3b:	c083      	movi.n	a8, 3
  909d3d:	282699        	s32i	a8, a2, 0x264
	}
	/* calculate the total allocation size based on the number of credit report buffers */
	pHTC->CtrlBufferAllocSize = MIN_CREDIT_BUFFER_ALLOC_SIZE * pHTC->NumBuffersForCreditRpts;
  909d40:	280ad8        	movi	a8, 216
  909d43:	282697        	s32i	a8, a2, 0x25c
	/* we need at least enough buffer space for 1 ctrl message */
	pHTC->CtrlBufferAllocSize = A_MAX(pHTC->CtrlBufferAllocSize,MAX_HTC_SETUP_MSG_SIZE);
    
	/* save the size of each buffer/credit we will receive */
	pHTC->RecvBufferSize = pConfig->CreditSize; //RecvBufferSize;
  909d46:	8830      	l32i.n	a8, a3, 0
	pHTC->TotalCredits = pConfig->CreditNumber;
  909d48:	8331      	l32i.n	a3, a3, 4
	pHTC->CtrlBufferAllocSize = MIN_CREDIT_BUFFER_ALLOC_SIZE * pHTC->NumBuffersForCreditRpts;
	/* we need at least enough buffer space for 1 ctrl message */
	pHTC->CtrlBufferAllocSize = A_MAX(pHTC->CtrlBufferAllocSize,MAX_HTC_SETUP_MSG_SIZE);
    
	/* save the size of each buffer/credit we will receive */
	pHTC->RecvBufferSize = pConfig->CreditSize; //RecvBufferSize;
  909d4a:	282691        	s32i	a8, a2, 0x244
	pHTC->TotalCredits = pConfig->CreditNumber;
  909d4d:	232694        	s32i	a3, a2, 0x250
	pHTC->TotalCreditsAssigned = 0;
  909d50:	c030      	movi.n	a3, 0
  909d52:	232695        	s32i	a3, a2, 0x254
     
	/* setup the pseudo service that handles HTC control messages */
	pHTC->HTCControlService.ProcessRecvMsg = A_INDIR(htc._HTC_ControlSvcProcessMsg);
  909d55:	234288        	l32i	a3, a4, 0x220
	pHTC->HTCControlService.ProcessSendBufferComplete = A_INDIR(htc._HTC_ControlSvcProcessSendComplete);
	pHTC->HTCControlService.TrailerSpcCheckLimit = HTC_CTRL_BUFFER_CHECK_SIZE;
  909d58:	c18c      	movi.n	a8, 28
	pHTC->RecvBufferSize = pConfig->CreditSize; //RecvBufferSize;
	pHTC->TotalCredits = pConfig->CreditNumber;
	pHTC->TotalCreditsAssigned = 0;
     
	/* setup the pseudo service that handles HTC control messages */
	pHTC->HTCControlService.ProcessRecvMsg = A_INDIR(htc._HTC_ControlSvcProcessMsg);
  909d5a:	23268a        	s32i	a3, a2, 0x228
	pHTC->HTCControlService.ProcessSendBufferComplete = A_INDIR(htc._HTC_ControlSvcProcessSendComplete);
  909d5d:	234289        	l32i	a3, a4, 0x224
	pHTC->HTCControlService.MaxSvcMsgSize = MAX_HTC_SETUP_MSG_SIZE;
	pHTC->HTCControlService.ServiceCtx = pHTC;
    
	/* automatically register this pseudo service to endpoint 1 */
	pHTC->Endpoints[ENDPOINT0].pService = &pHTC->HTCControlService;
	HIF_get_default_pipe(pHTC->hifHandle, &pHTC->Endpoints[ENDPOINT0].UpLinkPipeID, 
  909d60:	2a229a        	l32i	a10, a2, 0x268
	pHTC->TotalCredits = pConfig->CreditNumber;
	pHTC->TotalCreditsAssigned = 0;
     
	/* setup the pseudo service that handles HTC control messages */
	pHTC->HTCControlService.ProcessRecvMsg = A_INDIR(htc._HTC_ControlSvcProcessMsg);
	pHTC->HTCControlService.ProcessSendBufferComplete = A_INDIR(htc._HTC_ControlSvcProcessSendComplete);
  909d63:	23268b        	s32i	a3, a2, 0x22c
	pHTC->HTCControlService.TrailerSpcCheckLimit = HTC_CTRL_BUFFER_CHECK_SIZE;
  909d66:	232d02        	addmi	a3, a2, 0x200
  909d69:	28351d        	s16i	a8, a3, 58
	pHTC->HTCControlService.MaxSvcMsgSize = MAX_HTC_SETUP_MSG_SIZE;
  909d6c:	c480      	movi.n	a8, 64
  909d6e:	28351c        	s16i	a8, a3, 56
	pHTC->HTCControlService.ServiceCtx = pHTC;
    
	/* automatically register this pseudo service to endpoint 1 */
	pHTC->Endpoints[ENDPOINT0].pService = &pHTC->HTCControlService;
  909d71:	232a24        	movi	a3, 0x224
  909d74:	032308        	add	a3, a2, a3
  909d77:	9322      	s32i.n	a3, a2, 8
	HIF_get_default_pipe(pHTC->hifHandle, &pHTC->Endpoints[ENDPOINT0].UpLinkPipeID, 
  909d79:	23427c        	l32i	a3, a4, 0x1f0
  909d7c:	2b2c19        	addi	a11, a2, 25
  909d7f:	2c2c18        	addi	a12, a2, 24
	/* setup the pseudo service that handles HTC control messages */
	pHTC->HTCControlService.ProcessRecvMsg = A_INDIR(htc._HTC_ControlSvcProcessMsg);
	pHTC->HTCControlService.ProcessSendBufferComplete = A_INDIR(htc._HTC_ControlSvcProcessSendComplete);
	pHTC->HTCControlService.TrailerSpcCheckLimit = HTC_CTRL_BUFFER_CHECK_SIZE;
	pHTC->HTCControlService.MaxSvcMsgSize = MAX_HTC_SETUP_MSG_SIZE;
	pHTC->HTCControlService.ServiceCtx = pHTC;
  909d82:	22268f        	s32i	a2, a2, 0x23c
    
	/* automatically register this pseudo service to endpoint 1 */
	pHTC->Endpoints[ENDPOINT0].pService = &pHTC->HTCControlService;
	HIF_get_default_pipe(pHTC->hifHandle, &pHTC->Endpoints[ENDPOINT0].UpLinkPipeID, 
  909d85:	0b3000        	callx8	a3
			     &pHTC->Endpoints[ENDPOINT0].DownLinkPipeID);
    
	/* Initialize control pipe so we could receive the HTC control packets */
	// @TODO: msg size!
	HIF_config_pipe(pHTC->hifHandle, pHTC->Endpoints[ENDPOINT0].UpLinkPipeID, 1);    
  909d88:	2a229a        	l32i	a10, a2, 0x268
  909d8b:	234275        	l32i	a3, a4, 0x1d4
  909d8e:	2b2019        	l8ui	a11, a2, 25
  909d91:	c0c1      	movi.n	a12, 1
  909d93:	0b3000        	callx8	a3
    
	/* set the first free endpoint */
	pHTC->CurrentEpIndex = ENDPOINT1;
  909d96:	c031      	movi.n	a3, 1
  909d98:	232688        	s32i	a3, a2, 0x220
	pHTC->SetupCompleteCb = SetupComplete;
    
        /* setup buffers for just the setup phase, we only need 1 buffer to handle
	 * setup */
	HTC_AssembleBuffers(pHTC, 4, MAX_HTC_SETUP_MSG_SIZE);
  909d9b:	da20      	mov.n	a10, a2
	// @TODO: msg size!
	HIF_config_pipe(pHTC->hifHandle, pHTC->Endpoints[ENDPOINT0].UpLinkPipeID, 1);    
    
	/* set the first free endpoint */
	pHTC->CurrentEpIndex = ENDPOINT1;
	pHTC->SetupCompleteCb = SetupComplete;
  909d9d:	252693        	s32i	a5, a2, 0x24c
    
        /* setup buffers for just the setup phase, we only need 1 buffer to handle
	 * setup */
	HTC_AssembleBuffers(pHTC, 4, MAX_HTC_SETUP_MSG_SIZE);
  909da0:	c0b4      	movi.n	a11, 4
  909da2:	2c0a40        	movi	a12, 64
  909da5:	5bffcd        	call8	909cdc <HTC_AssembleBuffers>
   
	/* start hardware layer so that we can queue buffers */
	HIF_start(pHTC->hifHandle);
  909da8:	2a229a        	l32i	a10, a2, 0x268
  909dab:	234274        	l32i	a3, a4, 0x1d0
  909dae:	0b3000        	callx8	a3
    
	return pHTC;
}
  909db1:	d10f      	retw.n
	...

00909db4 <_HTC_PauseRecv>:
	pHTCHdr->PayloadLen = adf_os_htons(totsz);  
	HIF_send_buffer(pHTC->hifHandle, pHTC->Endpoints[EndpointID].DownLinkPipeID, pBuffers);       
}

void _HTC_PauseRecv(HTC_ENDPOINT_ID EndpointID)
{
  909db4:	6c1004        	entry	a1, 32
  909db7:	d10f      	retw.n
  909db9:	000000        	ill

00909dbc <_HTC_ResumeRecv>:
}

void _HTC_ResumeRecv(HTC_ENDPOINT_ID EndpointID)
{
  909dbc:	6c1004        	entry	a1, 32
  909dbf:	d10f      	retw.n
  909dc1:	000000        	ill

00909dc4 <htc_module_install>:
    
	return HTC_HDR_LENGTH + HIF_get_reserved_headroom(pHTC->hifHandle);
}

void htc_module_install(struct htc_apis *pAPIs)
{   
  909dc4:	6c1004        	entry	a1, 32
	pAPIs->_HTC_Init = _HTC_Init;
  909dc7:	186a44        	l32r	a8, 8e46d8 <bStandardCommand+0x874>
  909dca:	9820      	s32i.n	a8, a2, 0
	pAPIs->_HTC_ReturnBuffers = _HTC_ReturnBuffers;
  909dcc:	186a45        	l32r	a8, 8e46e0 <bStandardCommand+0x87c>
  909dcf:	9824      	s32i.n	a8, a2, 16
	pAPIs->_HTC_ReturnBuffersList = _HTC_ReturnBuffersList;
  909dd1:	186a46        	l32r	a8, 8e46ec <bStandardCommand+0x888>
  909dd4:	9825      	s32i.n	a8, a2, 20
	pAPIs->_HTC_Ready = _HTC_Ready;
  909dd6:	186a47        	l32r	a8, 8e46f4 <bStandardCommand+0x890>
  909dd9:	9823      	s32i.n	a8, a2, 12
	pAPIs->_HTC_RegisterService = _HTC_RegisterService;
  909ddb:	186a48        	l32r	a8, 8e46fc <bStandardCommand+0x898>
  909dde:	9822      	s32i.n	a8, a2, 8
	pAPIs->_HTC_SendMsg = _HTC_SendMsg;   
  909de0:	186a49        	l32r	a8, 8e4704 <bStandardCommand+0x8a0>
  909de3:	9826      	s32i.n	a8, a2, 24
	pAPIs->_HTC_Shutdown = _HTC_Shutdown;
  909de5:	186a4a        	l32r	a8, 8e4710 <bStandardCommand+0x8ac>
  909de8:	9821      	s32i.n	a8, a2, 4
	pAPIs->_HTC_GetReservedHeadroom = _HTC_GetReservedHeadroom;
  909dea:	186a4b        	l32r	a8, 8e4718 <bStandardCommand+0x8b4>
  909ded:	9827      	s32i.n	a8, a2, 28
	pAPIs->_HTC_MsgRecvHandler = HTCMsgRecvHandler;
  909def:	186a4c        	l32r	a8, 8e4720 <bStandardCommand+0x8bc>
  909df2:	9828      	s32i.n	a8, a2, 32
	pAPIs->_HTC_SendDoneHandler = HTCSendDoneHandler;
  909df4:	186a4d        	l32r	a8, 8e4728 <bStandardCommand+0x8c4>
  909df7:	9829      	s32i.n	a8, a2, 36
	pAPIs->_HTC_ControlSvcProcessMsg = HTCControlSvcProcessMsg;
  909df9:	186a4e        	l32r	a8, 8e4734 <bStandardCommand+0x8d0>
  909dfc:	982a      	s32i.n	a8, a2, 40
	pAPIs->_HTC_ControlSvcProcessSendComplete = HTCControlSvcProcessSendComplete;
  909dfe:	186a4f        	l32r	a8, 8e473c <bStandardCommand+0x8d8>
  909e01:	982b      	s32i.n	a8, a2, 44
  909e03:	d10f      	retw.n
  909e05:	000000        	ill

00909e08 <HTCFreeMsgBuffer>:
}

/* free message to the free list */
LOCAL void HTCFreeMsgBuffer(HTC_CONTEXT *pHTC, adf_nbuf_t buf) 
{
  909e08:	6c1004        	entry	a1, 32
	BUF_Pool_free_buf(pHTC->PoolHandle, POOL_ID_HTC_CONTROL, buf);      
  909e0b:	186915        	l32r	a8, 8e4260 <bStandardCommand+0x3fc>
  909e0e:	2a229b        	l32i	a10, a2, 0x26c
  909e11:	28829e        	l32i	a8, a8, 0x278
  909e14:	c0b0      	movi.n	a11, 0
  909e16:	033c02        	or	a12, a3, a3
  909e19:	0b8000        	callx8	a8
  909e1c:	d10f      	retw.n
	...

00909e20 <HTCAllocMsgBuffer>:
}

/* HTC control message allocator (also used for empty frames to send trailer options) */
LOCAL adf_nbuf_t HTCAllocMsgBuffer(HTC_CONTEXT *pHTC)
{
  909e20:	6c1004        	entry	a1, 32
	return BUF_Pool_alloc_buf(pHTC->PoolHandle,
  909e23:	186915        	l32r	a8, 8e4278 <bStandardCommand+0x414>
  909e26:	24229b        	l32i	a4, a2, 0x26c
  909e29:	23829c        	l32i	a3, a8, 0x270
  909e2c:	288285        	l32i	a8, a8, 0x214
  909e2f:	da20      	mov.n	a10, a2
  909e31:	0b8000        	callx8	a8
  909e34:	dca0      	mov.n	a12, a10
  909e36:	c0b0      	movi.n	a11, 0
  909e38:	da40      	mov.n	a10, a4
  909e3a:	0b3000        	callx8	a3
				  POOL_ID_HTC_CONTROL,
				  HTC_GetReservedHeadroom(pHTC));   
}
  909e3d:	d2a0      	mov.n	a2, a10
  909e3f:	d10f      	retw.n
  909e41:	000000        	ill

00909e44 <_HTC_Ready>:
	pService->pNext = pHTC->pServiceList;
	pHTC->pServiceList = pService;
}

LOCAL void _HTC_Ready(htc_handle_t htcHandle)
{
  909e44:	6c1004        	entry	a1, 32
	adf_nbuf_t pBuffer;
	HTC_READY_MSG *pReady;
	a_uint8_t *addr;
	HTC_CONTEXT *pHTC = (HTC_CONTEXT *)htcHandle;
    
	pBuffer = HTCAllocMsgBuffer(pHTC);
  909e47:	022a02        	or	a10, a2, a2
  909e4a:	5bfff5        	call8	909e20 <HTCAllocMsgBuffer>
 *         put, or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_put_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_put_tail(buf, size);
  909e4d:	c0b8      	movi.n	a11, 8
  909e4f:	d4a0      	mov.n	a4, a10
  909e51:	5bf377        	call8	906c30 <__adf_nbuf_put_tail>
	/* an optimization... the header length is chosen to
	 * be aligned on a 16 bit bounday, the fields in the message are designed to
	 * be aligned */
	addr = adf_nbuf_put_tail(pBuffer, sizeof(HTC_READY_MSG));       
	pReady = (HTC_READY_MSG *)addr;     
	A_MEMZERO(pReady,sizeof(HTC_READY_MSG));  
  909e54:	156915        	l32r	a5, 8e42a8 <bStandardCommand+0x444>
  909e57:	c0b0      	movi.n	a11, 0
  909e59:	8854      	l32i.n	a8, a5, 16
  909e5b:	c0c8      	movi.n	a12, 8
  909e5d:	d3a0      	mov.n	a3, a10
  909e5f:	0b8000        	callx8	a8
	pReady->MessageID = adf_os_htons(HTC_MSG_READY_ID);
  909e62:	c0b0      	movi.n	a11, 0
  909e64:	c081      	movi.n	a8, 1
  909e66:	2b3400        	s8i	a11, a3, 0
  909e69:	283401        	s8i	a8, a3, 1
	pReady->CreditSize = adf_os_htons((A_UINT16)pHTC->RecvBufferSize);
  909e6c:	282291        	l32i	a8, a2, 0x244
	pReady->CreditCount = adf_os_htons((A_UINT16)pHTC->TotalCredits);
	pReady->MaxEndpoints = ENDPOINT_MAX;
       
	/* send out the message */
	HTC_SendMsg(pHTC, ENDPOINT0, pBuffer);
  909e6f:	da20      	mov.n	a10, a2
	 * be aligned */
	addr = adf_nbuf_put_tail(pBuffer, sizeof(HTC_READY_MSG));       
	pReady = (HTC_READY_MSG *)addr;     
	A_MEMZERO(pReady,sizeof(HTC_READY_MSG));  
	pReady->MessageID = adf_os_htons(HTC_MSG_READY_ID);
	pReady->CreditSize = adf_os_htons((A_UINT16)pHTC->RecvBufferSize);
  909e71:	08084f        	extui	a8, a8, 0, 16
  909e74:	088914        	srli	a9, a8, 8
  909e77:	293404        	s8i	a9, a3, 4
  909e7a:	283405        	s8i	a8, a3, 5
	pReady->CreditCount = adf_os_htons((A_UINT16)pHTC->TotalCredits);
  909e7d:	282294        	l32i	a8, a2, 0x250
	pReady->MaxEndpoints = ENDPOINT_MAX;
       
	/* send out the message */
	HTC_SendMsg(pHTC, ENDPOINT0, pBuffer);
  909e80:	dc40      	mov.n	a12, a4
	addr = adf_nbuf_put_tail(pBuffer, sizeof(HTC_READY_MSG));       
	pReady = (HTC_READY_MSG *)addr;     
	A_MEMZERO(pReady,sizeof(HTC_READY_MSG));  
	pReady->MessageID = adf_os_htons(HTC_MSG_READY_ID);
	pReady->CreditSize = adf_os_htons((A_UINT16)pHTC->RecvBufferSize);
	pReady->CreditCount = adf_os_htons((A_UINT16)pHTC->TotalCredits);
  909e82:	08084f        	extui	a8, a8, 0, 16
  909e85:	088914        	srli	a9, a8, 8
  909e88:	283403        	s8i	a8, a3, 3
	pReady->MaxEndpoints = ENDPOINT_MAX;
  909e8b:	c186      	movi.n	a8, 22
	addr = adf_nbuf_put_tail(pBuffer, sizeof(HTC_READY_MSG));       
	pReady = (HTC_READY_MSG *)addr;     
	A_MEMZERO(pReady,sizeof(HTC_READY_MSG));  
	pReady->MessageID = adf_os_htons(HTC_MSG_READY_ID);
	pReady->CreditSize = adf_os_htons((A_UINT16)pHTC->RecvBufferSize);
	pReady->CreditCount = adf_os_htons((A_UINT16)pHTC->TotalCredits);
  909e8d:	293402        	s8i	a9, a3, 2
	pReady->MaxEndpoints = ENDPOINT_MAX;
  909e90:	283406        	s8i	a8, a3, 6
       
	/* send out the message */
	HTC_SendMsg(pHTC, ENDPOINT0, pBuffer);
  909e93:	235284        	l32i	a3, a5, 0x210
  909e96:	0b3000        	callx8	a3
  909e99:	d10f      	retw.n
	...

00909e9c <HTCCheckAndSendCreditReport>:
				  HTC_GetReservedHeadroom(pHTC));   
}

LOCAL void HTCCheckAndSendCreditReport(HTC_CONTEXT *pHTC, A_UINT32 EpMask,
				       HTC_ENDPOINT *pEndpoint, HTC_ENDPOINT_ID Eid)
{
  909e9c:	6c1004        	entry	a1, 32
	adf_nbuf_t pCredBuffer;
	HTC_BUF_CONTEXT *ctx;    
        
	do {
		/* check if host needs credits */
		if (!(pHTC->EpHostNeedsCreditMap & EpMask)) {
  909e9f:	282285        	l32i	a8, a2, 0x214
  909ea2:	78305a        	bnone	a3, a8, 909f00 <HTCCheckAndSendCreditReport+0x64>
			/* host does not need any credits for this set */
			break;    
		}
		/* check if any are pending */
		if (!(pHTC->EpCreditPendingMap & EpMask)) {
  909ea5:	282286        	l32i	a8, a2, 0x218
  909ea8:	783054        	bnone	a3, a8, 909f00 <HTCCheckAndSendCreditReport+0x64>
			/* nothing to send up */
			break;    
		}  
		/* was an endpoint specified? */
		if (pEndpoint != NULL) {
  909eab:	c945      	beqz.n	a4, 909ec4 <HTCCheckAndSendCreditReport+0x28>
			/* see if a threshold is in effect for this endpoint */
			if (pEndpoint->CreditReturnThreshhold != 0) {
  909ead:	234904        	l16si	a3, a4, 8
  909eb0:	c834      	beqz.n	a3, 909eb8 <HTCCheckAndSendCreditReport+0x1c>
				if (pEndpoint->CreditsToReturn < pEndpoint->CreditReturnThreshhold) {
  909eb2:	284900        	l16si	a8, a4, 0
  909eb5:	738247        	blt	a8, a3, 909f00 <HTCCheckAndSendCreditReport+0x64>
					 * back to the host */
					break;
				}
			}
         
			if (pEndpoint->PendingCreditReports >= pHTC->MaxEpPendingCreditRpts) {
  909eb8:	8844      	l32i.n	a8, a4, 16
  909eba:	232299        	l32i	a3, a2, 0x264
  909ebd:	738203        	blt	a8, a3, 909ec4 <HTCCheckAndSendCreditReport+0x28>
  909ec0:	600009        	j	909ecd <HTCCheckAndSendCreditReport+0x31>
  909ec3:	00da20        	excw
		}
        
		/* if we get here we have some credits to send up */
                        
		/* allocate a message buffer for the trailer */
		pCredBuffer = HTCAllocMsgBuffer(pHTC);
  909ec6:	5bffd6        	call8	909e20 <HTCAllocMsgBuffer>
  909ec9:	d3a0      	mov.n	a3, a10
		if (NULL == pCredBuffer) {
  909ecb:	ccae      	bnez.n	a10, 909edd <HTCCheckAndSendCreditReport+0x41>
			/* no buffers left to send an empty message with trailers, host will just
			 * have to wait until we get our endpoint 0 messages back.. */
			/* mark that we need to send an update as soon as we can get a buffer back */
			pHTC->StateFlags |= HTC_SEND_CREDIT_UPDATE_SOON;
  909ecd:	242292        	l32i	a4, a2, 0x248
  909ed0:	c032      	movi.n	a3, 2
  909ed2:	034302        	or	a3, a4, a3
  909ed5:	232692        	s32i	a3, a2, 0x248
  909ed8:	d10f      	retw.n
  909eda:	000000        	ill
 * @return data pointer to typecast into your priv structure
 */
static inline a_uint8_t *
adf_nbuf_get_priv(adf_nbuf_t buf)
{
    return (__adf_nbuf_get_priv(buf));
  909edd:	5bf2c6        	call8	9069f8 <__adf_nbuf_get_priv>
			break;    
		}
        
		ctx = (HTC_BUF_CONTEXT *)adf_nbuf_get_priv(pCredBuffer);
		if (pEndpoint != NULL) {
  909ee0:	c84d      	beqz.n	a4, 909ef1 <HTCCheckAndSendCreditReport+0x55>
			/* keep track of pending reports */
			pEndpoint->PendingCreditReports++; 
  909ee2:	8844      	l32i.n	a8, a4, 16
  909ee4:	b188      	addi.n	a8, a8, 1
  909ee6:	9844      	s32i.n	a8, a4, 16
			/* save the endpoint in order to decrement the count when the send completes */
			ctx->htc_flags = Eid | HTC_FLAGS_CREDIT_RPT;
  909ee8:	240a20        	movi	a4, 32
  909eeb:	045502        	or	a5, a5, a4
  909eee:	25a401        	s8i	a5, a10, 1
		}   
            
		/* this is an empty message, the HTC_SendMsg will tack on a trailer in the remaining
		 * space, NOTE: no need to flush the cache, the header and trailers are assembled
		 * using uncached addresses */
		HTC_SendMsg(pHTC, ENDPOINT0, pCredBuffer);    
  909ef1:	146915        	l32r	a4, 8e4348 <bStandardCommand+0x4e4>
  909ef4:	da20      	mov.n	a10, a2
  909ef6:	244284        	l32i	a4, a4, 0x210
  909ef9:	c0b0      	movi.n	a11, 0
  909efb:	dc30      	mov.n	a12, a3
  909efd:	0b4000        	callx8	a4
  909f00:	d10f      	retw.n
	...

00909f04 <HTCControlSvcProcessSendComplete>:
}

/* callback when endpoint 0 send buffers are completed */
LOCAL void HTCControlSvcProcessSendComplete(HTC_ENDPOINT_ID EndpointID,
					    adf_nbuf_t pBuffers, void *arg)
{
  909f04:	6c1004        	entry	a1, 32
  909f07:	da30      	mov.n	a10, a3
  909f09:	5bf2bb        	call8	9069f8 <__adf_nbuf_get_priv>
	HTC_ENDPOINT_ID creditRptEndpoint;
    
	ctx = (HTC_BUF_CONTEXT *)adf_nbuf_get_priv(pBuffers);       
    
	/* put them back into the pool */
	if ( ctx->htc_flags & HTC_FLAGS_CREDIT_RPT ) {   
  909f0c:	28a001        	l8ui	a8, a10, 1
  909f0f:	7a870e        	bbci	a8, 26, 909f21 <HTCControlSvcProcessSendComplete+0x1d>
		/* extract the endpoint number that requested this credit report */ 
		creditRptEndpoint = ctx->htc_flags & HTC_FLAGS_CRPT_EP_MASK;    
  909f12:	080844        	extui	a8, a8, 0, 5
		pHTC->Endpoints[creditRptEndpoint].PendingCreditReports--;  
  909f15:	088809        	addx2	a8, a8, a8
  909f18:	04880b        	addx8	a8, a8, a4
  909f1b:	8985      	l32i.n	a9, a8, 20
  909f1d:	b099      	addi.n	a9, a9, -1
  909f1f:	9985      	s32i.n	a9, a8, 20
	}
    
	HTCFreeMsgBuffer(pHTC, pBuffers);
  909f21:	db30      	mov.n	a11, a3
  909f23:	da40      	mov.n	a10, a4
  909f25:	5bffb8        	call8	909e08 <HTCFreeMsgBuffer>
   
	if (pHTC->StateFlags & HTC_SEND_CREDIT_UPDATE_SOON) {
  909f28:	234292        	l32i	a3, a4, 0x248
  909f2b:	7e3712        	bbci	a3, 30, 909f41 <HTCControlSvcProcessSendComplete+0x3d>
		/* this flag is set when the host could not send a credit report
		 * because we ran out of HTC control buffers */
		pHTC->StateFlags &= ~HTC_SEND_CREDIT_UPDATE_SOON;
  909f2e:	c78d      	movi.n	a8, -3
  909f30:	083301        	and	a3, a3, a8
  909f33:	234692        	s32i	a3, a4, 0x248
		/* send out a report if anything is pending */
		HTCCheckAndSendCreditReport(pHTC, HTC_ANY_ENDPOINT_MASK,NULL,ENDPOINT_MAX);
  909f36:	da40      	mov.n	a10, a4
  909f38:	c7bf      	movi.n	a11, -1
  909f3a:	c0c0      	movi.n	a12, 0
  909f3c:	c1d6      	movi.n	a13, 22
  909f3e:	5bffd7        	call8	909e9c <HTCCheckAndSendCreditReport>
  909f41:	d10f      	retw.n
	...

00909f44 <ReturnBuffers>:
	/* now we need to wait for service connection requests */
}

LOCAL void ReturnBuffers(htc_handle_t htcHandle, HTC_ENDPOINT_ID EndpointID,
			 adf_nbuf_t pBuffers, A_BOOL sendCreditFlag)
{   
  909f44:	6c1004        	entry	a1, 32
 *         or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_push_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_push_head(buf, size);
  909f47:	044a02        	or	a10, a4, a4
  909f4a:	2b0a08        	movi	a11, 8
  909f4d:	5bf27a        	call8	906938 <__adf_nbuf_push_head>
    
	/* supply some head-room again */
	adf_nbuf_push_head(pBuffers, HTC_HDR_LENGTH);
              
	/* enqueue all buffers to the single mailbox */
	HIF_return_recv_buf(pHTC->hifHandle, pHTC->Endpoints[EndpointID].UpLinkPipeID, pBuffers);    
  909f50:	186915        	l32r	a8, 8e43a4 <bStandardCommand+0x540>
  909f53:	033609        	addx2	a6, a3, a3
  909f56:	02660b        	addx8	a6, a6, a2
  909f59:	288277        	l32i	a8, a8, 0x1dc
  909f5c:	2a229a        	l32i	a10, a2, 0x268
  909f5f:	2b6019        	l8ui	a11, a6, 25
  909f62:	044c02        	or	a12, a4, a4
  909f65:	0b8000        	callx8	a8
     
	if (pHTC->StateFlags & HTC_STATE_SETUP_COMPLETE) {       
  909f68:	242292        	l32i	a4, a2, 0x248
  909f6b:	7f472d        	bbci	a4, 31, 909f9c <ReturnBuffers+0x58>
		A_UINT32    epCreditMask = (1 << EndpointID);
		/* we are running normally */
		/* update pending credit counts with the number of buffers that were added */
		pHTC->Endpoints[EndpointID].CreditsToReturn += (A_INT16)nbufs;
  909f6e:	246102        	l16ui	a4, a6, 4
              
	/* enqueue all buffers to the single mailbox */
	HIF_return_recv_buf(pHTC->hifHandle, pHTC->Endpoints[EndpointID].UpLinkPipeID, pBuffers);    
     
	if (pHTC->StateFlags & HTC_STATE_SETUP_COMPLETE) {       
		A_UINT32    epCreditMask = (1 << EndpointID);
  909f71:	c0b1      	movi.n	a11, 1
		/* we are running normally */
		/* update pending credit counts with the number of buffers that were added */
		pHTC->Endpoints[EndpointID].CreditsToReturn += (A_INT16)nbufs;
  909f73:	b144      	addi.n	a4, a4, 1
  909f75:	246502        	s16i	a4, a6, 4
		pHTC->Endpoints[EndpointID].CreditsConsumed -= (A_INT16)nbufs;  
  909f78:	246107        	l16ui	a4, a6, 14
              
	/* enqueue all buffers to the single mailbox */
	HIF_return_recv_buf(pHTC->hifHandle, pHTC->Endpoints[EndpointID].UpLinkPipeID, pBuffers);    
     
	if (pHTC->StateFlags & HTC_STATE_SETUP_COMPLETE) {       
		A_UINT32    epCreditMask = (1 << EndpointID);
  909f7b:	003104        	ssl	a3
  909f7e:	00bb1a        	sll	a11, a11
		/* we are running normally */
		/* update pending credit counts with the number of buffers that were added */
		pHTC->Endpoints[EndpointID].CreditsToReturn += (A_INT16)nbufs;
		pHTC->Endpoints[EndpointID].CreditsConsumed -= (A_INT16)nbufs;  
  909f81:	b044      	addi.n	a4, a4, -1
  909f83:	246507        	s16i	a4, a6, 14
		/* update bit map that this endpoint has non-zero credits */
		pHTC->EpCreditPendingMap |= epCreditMask; 
  909f86:	242286        	l32i	a4, a2, 0x218
  909f89:	0b4402        	or	a4, a4, a11
  909f8c:	242686        	s32i	a4, a2, 0x218

		if (sendCreditFlag) {
  909f8f:	c951      	beqz.n	a5, 909fa4 <ReturnBuffers+0x60>
			HTCCheckAndSendCreditReport(pHTC, epCreditMask,&pHTC->Endpoints[EndpointID],EndpointID);
  909f91:	da20      	mov.n	a10, a2
  909f93:	b46c      	addi.n	a12, a6, 4
  909f95:	dd30      	mov.n	a13, a3
  909f97:	5bffc1        	call8	909e9c <HTCCheckAndSendCreditReport>
  909f9a:	d10f      	retw.n
	} else {
		/* we have not started yet so all return operations are simply adding buffers
		 * to the interface at startup, so we can keep track of how many total 
		 * credits we get */
		/* update global count that will be returned to the host */
		pHTC->TotalCredits += nbufs;
  909f9c:	232294        	l32i	a3, a2, 0x250
  909f9f:	b133      	addi.n	a3, a3, 1
  909fa1:	232694        	s32i	a3, a2, 0x250
  909fa4:	d10f      	retw.n
	...

00909fa8 <_HTC_ReturnBuffers>:
	HTCCheckAndSendCreditReport(pHTC, (1 << EndpointID),&pHTC->Endpoints[EndpointID],EndpointID);
}

LOCAL void _HTC_ReturnBuffers(htc_handle_t htcHandle, HTC_ENDPOINT_ID EndpointID,
			      adf_nbuf_t pBuffers)
{
  909fa8:	6c1004        	entry	a1, 32
	ReturnBuffers(htcHandle, EndpointID, pBuffers, TRUE);
  909fab:	da20      	mov.n	a10, a2
  909fad:	db30      	mov.n	a11, a3
  909faf:	dc40      	mov.n	a12, a4
  909fb1:	c0d1      	movi.n	a13, 1
  909fb3:	5bffe4        	call8	909f44 <ReturnBuffers>
  909fb6:	d10f      	retw.n

00909fb8 <_HTC_ReturnBuffersList>:
}

LOCAL void _HTC_ReturnBuffersList(htc_handle_t htcHandle,
				  HTC_ENDPOINT_ID EndpointID,
				  adf_nbuf_queue_t bufHead)
{
  909fb8:	6c1006        	entry	a1, 48
 * @return first buffer in queue
 */
static inline adf_nbuf_t 
adf_nbuf_queue_first(adf_nbuf_queue_t *head)
{
    return (__adf_nbuf_queue_first(head));
  909fbb:	da10      	mov.n	a10, a1
  909fbd:	9410      	s32i.n	a4, a1, 0
  909fbf:	9511      	s32i.n	a5, a1, 4
  909fc1:	9612      	s32i.n	a6, a1, 8
  909fc3:	5bf343        	call8	906cd0 <__adf_nbuf_queue_first>
  909fc6:	d4a0      	mov.n	a4, a10
	adf_nbuf_t netbuf, tmpNbuf;

	/* retrieve each nbuf in the queue */
	netbuf = adf_nbuf_queue_first(&bufHead);

	while (netbuf) {
  909fc8:	600014        	j	909fe0 <_HTC_ReturnBuffersList+0x28>
  909fcb:	00da40        	extui	a10, a0, 13, 1
 * @return next buffer/packet
 */
static inline adf_nbuf_t
adf_nbuf_queue_next(adf_nbuf_t buf)
{
    return (__adf_nbuf_queue_next(buf));
  909fce:	5bf342        	call8	906cd8 <__adf_nbuf_queue_next>
  909fd1:	d5a0      	mov.n	a5, a10

		tmpNbuf = netbuf;
		netbuf = adf_nbuf_queue_next(netbuf);

		ReturnBuffers(htcHandle, EndpointID, tmpNbuf, FALSE);
  909fd3:	dc40      	mov.n	a12, a4
  909fd5:	da20      	mov.n	a10, a2
  909fd7:	db30      	mov.n	a11, a3
  909fd9:	c0d0      	movi.n	a13, 0
  909fdb:	5bffda        	call8	909f44 <ReturnBuffers>
	netbuf = adf_nbuf_queue_first(&bufHead);

	while (netbuf) {

		tmpNbuf = netbuf;
		netbuf = adf_nbuf_queue_next(netbuf);
  909fde:	d450      	mov.n	a4, a5
	adf_nbuf_t netbuf, tmpNbuf;

	/* retrieve each nbuf in the queue */
	netbuf = adf_nbuf_queue_first(&bufHead);

	while (netbuf) {
  909fe0:	654fe8        	bnez	a4, 909fcc <_HTC_ReturnBuffersList+0x14>
		netbuf = adf_nbuf_queue_next(netbuf);

		ReturnBuffers(htcHandle, EndpointID, tmpNbuf, FALSE);
	}

	HTCCheckAndSendCreditReport(pHTC, (1 << EndpointID),&pHTC->Endpoints[EndpointID],EndpointID);
  909fe3:	033c09        	addx2	a12, a3, a3
  909fe6:	02cc0b        	addx8	a12, a12, a2
  909fe9:	c0b1      	movi.n	a11, 1
  909feb:	da20      	mov.n	a10, a2
  909fed:	003104        	ssl	a3
  909ff0:	00bb1a        	sll	a11, a11
  909ff3:	b4cc      	addi.n	a12, a12, 4
  909ff5:	dd30      	mov.n	a13, a3
  909ff7:	5bffa9        	call8	909e9c <HTCCheckAndSendCreditReport>
  909ffa:	d10f      	retw.n

00909ffc <HTCProcessConnectMsg>:
	} while (FALSE);      
}
        
/* called in response to the arrival of a service connection message */
LOCAL void HTCProcessConnectMsg(HTC_CONTEXT *pHTC, HTC_CONNECT_SERVICE_MSG *pMsg)
{
  909ffc:	6c1008        	entry	a1, 64
	HTC_SERVICE *pService = pHTC->pServiceList;
	A_UINT8 connectStatus = HTC_SERVICE_NOT_FOUND;
	adf_nbuf_t pBuffer;
	HTC_CONNECT_SERVICE_RESPONSE_MSG *pRspMsg;
	int metaDataOutLen = 0;
  909fff:	c060      	movi.n	a6, 0
  90a001:	9610      	s32i.n	a6, a1, 0
	A_UINT16 serviceId = adf_os_ntohs(pMsg->ServiceID);
    
	pBuffer = HTCAllocMsgBuffer(pHTC);
  90a003:	da20      	mov.n	a10, a2
	HTC_SERVICE *pService = pHTC->pServiceList;
	A_UINT8 connectStatus = HTC_SERVICE_NOT_FOUND;
	adf_nbuf_t pBuffer;
	HTC_CONNECT_SERVICE_RESPONSE_MSG *pRspMsg;
	int metaDataOutLen = 0;
	A_UINT16 serviceId = adf_os_ntohs(pMsg->ServiceID);
  90a005:	243003        	l8ui	a4, a3, 3
  90a008:	273002        	l8ui	a7, a3, 2
}
        
/* called in response to the arrival of a service connection message */
LOCAL void HTCProcessConnectMsg(HTC_CONTEXT *pHTC, HTC_CONNECT_SERVICE_MSG *pMsg)
{
	HTC_SERVICE *pService = pHTC->pServiceList;
  90a00b:	252290        	l32i	a5, a2, 0x240
	adf_nbuf_t pBuffer;
	HTC_CONNECT_SERVICE_RESPONSE_MSG *pRspMsg;
	int metaDataOutLen = 0;
	A_UINT16 serviceId = adf_os_ntohs(pMsg->ServiceID);
    
	pBuffer = HTCAllocMsgBuffer(pHTC);
  90a00e:	5bff84        	call8	909e20 <HTCAllocMsgBuffer>
 *         put, or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_put_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_put_tail(buf, size);
  90a011:	c0ba      	movi.n	a11, 10
  90a013:	9a14      	s32i.n	a10, a1, 16
  90a015:	5bf306        	call8	906c30 <__adf_nbuf_put_tail>
	/* note : this will be aligned */
	pRspMsg = (HTC_CONNECT_SERVICE_RESPONSE_MSG *)
                adf_nbuf_put_tail(pBuffer, sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
                                 
	A_MEMZERO(pRspMsg,sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
  90a018:	196915        	l32r	a9, 8e446c <bStandardCommand+0x608>
	HTC_SERVICE *pService = pHTC->pServiceList;
	A_UINT8 connectStatus = HTC_SERVICE_NOT_FOUND;
	adf_nbuf_t pBuffer;
	HTC_CONNECT_SERVICE_RESPONSE_MSG *pRspMsg;
	int metaDataOutLen = 0;
	A_UINT16 serviceId = adf_os_ntohs(pMsg->ServiceID);
  90a01b:	087711        	slli	a7, a7, 8
	pBuffer = HTCAllocMsgBuffer(pHTC);
	/* note : this will be aligned */
	pRspMsg = (HTC_CONNECT_SERVICE_RESPONSE_MSG *)
                adf_nbuf_put_tail(pBuffer, sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
                                 
	A_MEMZERO(pRspMsg,sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
  90a01e:	8994      	l32i.n	a9, a9, 16
  90a020:	db60      	mov.n	a11, a6
  90a022:	c0ca      	movi.n	a12, 10
	HTC_SERVICE *pService = pHTC->pServiceList;
	A_UINT8 connectStatus = HTC_SERVICE_NOT_FOUND;
	adf_nbuf_t pBuffer;
	HTC_CONNECT_SERVICE_RESPONSE_MSG *pRspMsg;
	int metaDataOutLen = 0;
	A_UINT16 serviceId = adf_os_ntohs(pMsg->ServiceID);
  90a024:	074702        	or	a7, a4, a7
  90a027:	d4a0      	mov.n	a4, a10
	pBuffer = HTCAllocMsgBuffer(pHTC);
	/* note : this will be aligned */
	pRspMsg = (HTC_CONNECT_SERVICE_RESPONSE_MSG *)
                adf_nbuf_put_tail(pBuffer, sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
                                 
	A_MEMZERO(pRspMsg,sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
  90a029:	0b9000        	callx8	a9
	pRspMsg->MessageID = adf_os_htons(HTC_MSG_CONNECT_SERVICE_RESPONSE_ID);
  90a02c:	c083      	movi.n	a8, 3
  90a02e:	284401        	s8i	a8, a4, 1
	/* reflect the service ID for this connect attempt */
	pRspMsg->ServiceID = adf_os_htons(serviceId);
  90a031:	078814        	srli	a8, a7, 8
  90a034:	284402        	s8i	a8, a4, 2
	/* note : this will be aligned */
	pRspMsg = (HTC_CONNECT_SERVICE_RESPONSE_MSG *)
                adf_nbuf_put_tail(pBuffer, sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
                                 
	A_MEMZERO(pRspMsg,sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
	pRspMsg->MessageID = adf_os_htons(HTC_MSG_CONNECT_SERVICE_RESPONSE_ID);
  90a037:	264400        	s8i	a6, a4, 0
	/* reflect the service ID for this connect attempt */
	pRspMsg->ServiceID = adf_os_htons(serviceId);
  90a03a:	274403        	s8i	a7, a4, 3

	while (pService) {
        
		if (pHTC->CurrentEpIndex >= ENDPOINT_MAX) {
  90a03d:	c185      	movi.n	a8, 21
	A_MEMZERO(pRspMsg,sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
	pRspMsg->MessageID = adf_os_htons(HTC_MSG_CONNECT_SERVICE_RESPONSE_ID);
	/* reflect the service ID for this connect attempt */
	pRspMsg->ServiceID = adf_os_htons(serviceId);

	while (pService) {
  90a03f:	600079        	j	90a0bc <HTCProcessConnectMsg+0xc0>
  90a042:	00002b        	mulsh	a0, a0, a0
        
		if (pHTC->CurrentEpIndex >= ENDPOINT_MAX) {
  90a045:	22887b        	excw
  90a048:	827b      	l32i.n	a2, a7, 44
			/* no more endpoints */
			connectStatus = HTC_SERVICE_NO_RESOURCES;
			break;    
		}

		if (serviceId == pService->ServiceID) {
  90a04a:	295108        	l16ui	a9, a5, 16
  90a04d:	779969        	bne	a9, a7, 90a0ba <HTCProcessConnectMsg+0xbe>
			A_UINT8 *pMetaDataOut;
            
			/* outgoing meta data resides in the space after the response message */
			pMetaDataOut = ((A_UINT8 *)pRspMsg) + sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG);
            
			if (pMsg->ServiceMetaLength != 0) {
  90a050:	2d3008        	l8ui	a13, a3, 8
				/* the meta data follows the connect service message */
				pMetaDataIN = ((A_UINT8 *)pMsg) + sizeof(HTC_CONNECT_SERVICE_MSG);
  90a053:	ba37      	addi.n	a7, a3, 10
  90a055:	c0c0      	movi.n	a12, 0
  90a057:	0d7c39        	movnez	a12, a7, a13
			}

			/* call the connect callback with the endpoint to use and pointers to meta data */
			connectStatus = pService->ProcessConnect(pService,
  90a05a:	8753      	l32i.n	a7, a5, 12
  90a05c:	da50      	mov.n	a10, a5
  90a05e:	ba4e      	addi.n	a14, a4, 10
  90a060:	df10      	mov.n	a15, a1
  90a062:	0b7000        	callx8	a7
  90a065:	d8a0      	mov.n	a8, a10
								 pMsg->ServiceMetaLength,
								 pMetaDataOut,
								 &metaDataOutLen);
            
			/* check if the service accepted this connection request */
			if (HTC_SERVICE_SUCCESS == connectStatus) {
  90a067:	65a05d        	bnez	a10, 90a0c8 <HTCProcessConnectMsg+0xcc>
				/* set the length of the response meta data going back to the host */
				pRspMsg->ServiceMetaLength = (A_UINT8)metaDataOutLen;
  90a06a:	8710      	l32i.n	a7, a1, 0
  90a06c:	274408        	s8i	a7, a4, 8
				/* set the endpoint ID the host will now communicate over */
				pRspMsg->EndpointID = pHTC->CurrentEpIndex;
  90a06f:	272288        	l32i	a7, a2, 0x220
  90a072:	274405        	s8i	a7, a4, 5
				/* return the maximum message size for this service */
				pRspMsg->MaxMsgSize = adf_os_htons((A_UINT16)pService->MaxSvcMsgSize);
  90a075:	275014        	l8ui	a7, a5, 20
  90a078:	274406        	s8i	a7, a4, 6
  90a07b:	275015        	l8ui	a7, a5, 21
  90a07e:	274407        	s8i	a7, a4, 7
				/* assign this endpoint to this service, this will be used in routing messages */
				pHTC->Endpoints[pHTC->CurrentEpIndex].pService = pService;
  90a081:	272288        	l32i	a7, a2, 0x220
  90a084:	077909        	addx2	a9, a7, a7
  90a087:	02990b        	addx8	a9, a9, a2
  90a08a:	9592      	s32i.n	a5, a9, 8
				/* set connection flags */
				pHTC->Endpoints[pHTC->CurrentEpIndex].ConnectionFlags = pMsg->ConnectionFlags;
  90a08c:	2a3004        	l8ui	a10, a3, 4
  90a08f:	2b3005        	l8ui	a11, a3, 5
  90a092:	08aa11        	slli	a10, a10, 8
  90a095:	0aba02        	or	a10, a11, a10
  90a098:	2a9508        	s16i	a10, a9, 16
                
				pHTC->Endpoints[pHTC->CurrentEpIndex].DownLinkPipeID = pMsg->DownLinkPipeID;
  90a09b:	2a3006        	l8ui	a10, a3, 6
				pHTC->Endpoints[pHTC->CurrentEpIndex].UpLinkPipeID = pMsg->UpLinkPipeID;
                
				/* mark that we are now connected */
				pService->ServiceFlags |= HTC_SERVICE_FLAGS_CONNECTED;
				/* bump up our index, this EP is now in use */
				pHTC->CurrentEpIndex++;   
  90a09e:	b177      	addi.n	a7, a7, 1
				/* assign this endpoint to this service, this will be used in routing messages */
				pHTC->Endpoints[pHTC->CurrentEpIndex].pService = pService;
				/* set connection flags */
				pHTC->Endpoints[pHTC->CurrentEpIndex].ConnectionFlags = pMsg->ConnectionFlags;
                
				pHTC->Endpoints[pHTC->CurrentEpIndex].DownLinkPipeID = pMsg->DownLinkPipeID;
  90a0a0:	2a9418        	s8i	a10, a9, 24
				pHTC->Endpoints[pHTC->CurrentEpIndex].UpLinkPipeID = pMsg->UpLinkPipeID;
  90a0a3:	233007        	l8ui	a3, a3, 7
  90a0a6:	239419        	s8i	a3, a9, 25
                
				/* mark that we are now connected */
				pService->ServiceFlags |= HTC_SERVICE_FLAGS_CONNECTED;
  90a0a9:	295109        	l16ui	a9, a5, 18
  90a0ac:	c031      	movi.n	a3, 1
  90a0ae:	039302        	or	a3, a9, a3
  90a0b1:	235509        	s16i	a3, a5, 18
				/* bump up our index, this EP is now in use */
				pHTC->CurrentEpIndex++;   
  90a0b4:	272688        	s32i	a7, a2, 0x220
  90a0b7:	60000d        	j	90a0c8 <HTCProcessConnectMsg+0xcc>
			}

			break;
		}       
        
		pService = pService->pNext;   
  90a0ba:	8550      	l32i.n	a5, a5, 0
	A_MEMZERO(pRspMsg,sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
	pRspMsg->MessageID = adf_os_htons(HTC_MSG_CONNECT_SERVICE_RESPONSE_ID);
	/* reflect the service ID for this connect attempt */
	pRspMsg->ServiceID = adf_os_htons(serviceId);

	while (pService) {
  90a0bc:	655f84        	bnez	a5, 90a044 <HTCProcessConnectMsg+0x48>
        
/* called in response to the arrival of a service connection message */
LOCAL void HTCProcessConnectMsg(HTC_CONTEXT *pHTC, HTC_CONNECT_SERVICE_MSG *pMsg)
{
	HTC_SERVICE *pService = pHTC->pServiceList;
	A_UINT8 connectStatus = HTC_SERVICE_NOT_FOUND;
  90a0bf:	c081      	movi.n	a8, 1
  90a0c1:	600003        	j	90a0c8 <HTCProcessConnectMsg+0xcc>
  90a0c4:	0000c0        	excw

	while (pService) {
        
		if (pHTC->CurrentEpIndex >= ENDPOINT_MAX) {
			/* no more endpoints */
			connectStatus = HTC_SERVICE_NO_RESOURCES;
  90a0c7:	8313      	l32i.n	a3, a1, 12
	}
                   
	pRspMsg->Status = connectStatus;    
    
	/* send out the response message */
	HTC_SendMsg(pHTC, ENDPOINT0, pBuffer); 
  90a0c9:	691528        	bnei	a1, 5, 90a0f5 <HTCProcessConfigPipeMsg+0x19>
		}       
        
		pService = pService->pNext;   
	}
                   
	pRspMsg->Status = connectStatus;    
  90a0cc:	440423        	excw
    
	/* send out the response message */
	HTC_SendMsg(pHTC, ENDPOINT0, pBuffer); 
  90a0cf:	32848c        	excw
  90a0d2:	14da20        	l32r	a4, 900954 <memset+0x19b0c>
  90a0d5:	c0b0      	movi.n	a11, 0
  90a0d7:	0b3000        	callx8	a3
  90a0da:	d10f      	retw.n

0090a0dc <HTCProcessConfigPipeMsg>:
}

LOCAL void HTCProcessConfigPipeMsg(HTC_CONTEXT *pHTC, HTC_CONFIG_PIPE_MSG *pMsg)
{
  90a0dc:	6c1004        	entry	a1, 32
	adf_nbuf_t pBuffer;
	HTC_CONFIG_PIPE_RESPONSE_MSG *pRspMsg;
        
	pBuffer = HTCAllocMsgBuffer(pHTC);
  90a0df:	022a02        	or	a10, a2, a2
  90a0e2:	5bff4f        	call8	909e20 <HTCAllocMsgBuffer>
  90a0e5:	c0b4      	movi.n	a11, 4
  90a0e7:	d6a0      	mov.n	a6, a10
  90a0e9:	5bf2d1        	call8	906c30 <__adf_nbuf_put_tail>
       
	/* note : this will be aligned */
	pRspMsg = (HTC_CONFIG_PIPE_RESPONSE_MSG *)
                adf_nbuf_put_tail(pBuffer, sizeof(HTC_CONFIG_PIPE_RESPONSE_MSG));    
              
	A_MEMZERO(pRspMsg,sizeof(HTC_CONFIG_PIPE_RESPONSE_MSG));
  90a0ec:	156915        	l32r	a5, 8e4540 <bStandardCommand+0x6dc>
  90a0ef:	c0b0      	movi.n	a11, 0
  90a0f1:	8754      	l32i.n	a7, a5, 16
  90a0f3:	c0c4      	movi.n	a12, 4
  90a0f5:	d4a0      	mov.n	a4, a10
  90a0f7:	0b7000        	callx8	a7
    
	pRspMsg->MessageID = adf_os_htons(HTC_MSG_CONFIG_PIPE_RESPONSE_ID);
  90a0fa:	c086      	movi.n	a8, 6
  90a0fc:	c070      	movi.n	a7, 0
  90a0fe:	274400        	s8i	a7, a4, 0
  90a101:	284401        	s8i	a8, a4, 1
	/* reflect the service ID for this connect attempt */
	pRspMsg->PipeID = pMsg->PipeID;
  90a104:	283002        	l8ui	a8, a3, 2
  90a107:	284402        	s8i	a8, a4, 2

	if ( HIF_is_pipe_supported(pHTC->hifHandle, pMsg->PipeID) ) {
  90a10a:	285278        	l32i	a8, a5, 0x1e0
  90a10d:	2a229a        	l32i	a10, a2, 0x268
  90a110:	2b3002        	l8ui	a11, a3, 2
  90a113:	0b8000        	callx8	a8
  90a116:	c9a2      	beqz.n	a10, 90a12c <HTCProcessConfigPipeMsg+0x50>
		pRspMsg->Status = 0;            
  90a118:	274403        	s8i	a7, a4, 3
	} else {
		pRspMsg->Status = 1; 
		goto config_done;
	}

	if ( (pHTC->TotalCreditsAssigned + pMsg->CreditCount) <= pHTC->TotalCredits ) {
  90a11b:	283003        	l8ui	a8, a3, 3
  90a11e:	272295        	l32i	a7, a2, 0x254
  90a121:	a787      	add.n	a7, a8, a7
  90a123:	282294        	l32i	a8, a2, 0x250
  90a126:	77821e        	blt	a8, a7, 90a148 <HTCProcessConfigPipeMsg+0x6c>
  90a129:	600005        	j	90a132 <HTCProcessConfigPipeMsg+0x56>
	pRspMsg->PipeID = pMsg->PipeID;

	if ( HIF_is_pipe_supported(pHTC->hifHandle, pMsg->PipeID) ) {
		pRspMsg->Status = 0;            
	} else {
		pRspMsg->Status = 1; 
  90a12c:	c031      	movi.n	a3, 1
  90a12e:	600018        	j	90a14a <HTCProcessConfigPipeMsg+0x6e>
  90a131:	002726        	excw
		goto config_done;
	}

	if ( (pHTC->TotalCreditsAssigned + pMsg->CreditCount) <= pHTC->TotalCredits ) {
		pHTC->TotalCreditsAssigned += pMsg->CreditCount;
  90a134:	9524      	s32i.n	a5, a2, 16
	} else {
		pRspMsg->Status = 2;
		goto config_done;
	}
    
	HIF_config_pipe(pHTC->hifHandle, pMsg->PipeID, pMsg->CreditCount);
  90a136:	52752a        	call0	8a75e0 <_bss_end+0x3946d0>
  90a139:	229a2b        	movi	a2, 0xfffff92b
  90a13c:	30022c        	excw
  90a13f:	30030b        	excw
  90a142:	400060        	excw
  90a145:	000500        	syscall
	}

	if ( (pHTC->TotalCreditsAssigned + pMsg->CreditCount) <= pHTC->TotalCredits ) {
		pHTC->TotalCreditsAssigned += pMsg->CreditCount;
	} else {
		pRspMsg->Status = 2;
  90a148:	c032      	movi.n	a3, 2
  90a14a:	234403        	s8i	a3, a4, 3
    
	HIF_config_pipe(pHTC->hifHandle, pMsg->PipeID, pMsg->CreditCount);
    
config_done:      
	/* send out the response message */
	HTC_SendMsg(pHTC, ENDPOINT0, pBuffer);             
  90a14d:	136915        	l32r	a3, 8e45a4 <bStandardCommand+0x740>
  90a150:	da20      	mov.n	a10, a2
  90a152:	233284        	l32i	a3, a3, 0x210
  90a155:	c0b0      	movi.n	a11, 0
  90a157:	dc60      	mov.n	a12, a6
  90a159:	0b3000        	callx8	a3
  90a15c:	d10f      	retw.n
	...

0090a160 <HTCControlSvcProcessMsg>:
}

/* process an incomming control message from the host */
LOCAL void HTCControlSvcProcessMsg(HTC_ENDPOINT_ID EndpointID, adf_nbuf_t hdr_buf,
				   adf_nbuf_t pBuffers, void *arg)
{  
  90a160:	6c1006        	entry	a1, 48
	a_uint8_t *anbdata;
	a_uint32_t anblen;
	HTC_CONTEXT *pHTC = (HTC_CONTEXT *)arg;
	HTC_UNKNOWN_MSG  *pMsg;
	
	adf_os_assert(hdr_buf == ADF_NBUF_NULL);
  90a163:	c935      	beqz.n	a3, 90a17c <HTCControlSvcProcessMsg+0x1c>
  90a165:	136915        	l32r	a3, 8e45bc <bStandardCommand+0x758>
  90a168:	1a6a50        	l32r	a10, 8e4aa8 <mUsbEPinHighBandSet+0x108>
  90a16b:	233212        	l32i	a3, a3, 72
  90a16e:	1b6a51        	l32r	a11, 8e4ab4 <mUsbEPinHighBandSet+0x114>
  90a171:	0b3000        	callx8	a3
  90a174:	13697a        	l32r	a3, 8e475c <bStandardCommand+0x8f8>
  90a177:	0c0200        	memw
  90a17a:	8330      	l32i.n	a3, a3, 0
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  90a17c:	b41b      	addi.n	a11, a1, 4
  90a17e:	da40      	mov.n	a10, a4
  90a180:	dc10      	mov.n	a12, a1
  90a182:	5bf2c7        	call8	906ca0 <__adf_nbuf_peek_header>

	/* we assume buffers are aligned such that we can access the message
	 * parameters directly*/
	adf_nbuf_peek_header(pBuffers, &anbdata, &anblen);
	pMsg = (HTC_UNKNOWN_MSG *)anbdata;
  90a185:	8b11      	l32i.n	a11, a1, 4
    
	/* we cannot handle fragmented messages across buffers */
    
	switch ( adf_os_ntohs(pMsg->MessageID) ) {        
  90a187:	28b000        	l8ui	a8, a11, 0
  90a18a:	23b001        	l8ui	a3, a11, 1
  90a18d:	088811        	slli	a8, a8, 8
  90a190:	083802        	or	a8, a3, a8
		break;            
        case HTC_MSG_SETUP_COMPLETE_ID:
                /* the host has indicated that it has completed all
		   setup tasks and we can now let the services take over to
		   run the rest of the application */
		setupComplete = TRUE;  
  90a193:	c031      	movi.n	a3, 1
	adf_nbuf_peek_header(pBuffers, &anbdata, &anblen);
	pMsg = (HTC_UNKNOWN_MSG *)anbdata;
    
	/* we cannot handle fragmented messages across buffers */
    
	switch ( adf_os_ntohs(pMsg->MessageID) ) {        
  90a195:	688417        	beqi	a8, 4, 90a1b0 <HTCControlSvcProcessMsg+0x50>
  90a198:	68850d        	beqi	a8, 5, 90a1a9 <HTCControlSvcProcessMsg+0x49>
  90a19b:	688202        	beqi	a8, 2, 90a1a1 <HTCControlSvcProcessMsg+0x41>
  90a19e:	60000c        	j	90a1ae <HTCControlSvcProcessMsg+0x4e>
        case HTC_MSG_CONNECT_SERVICE_ID:
		HTCProcessConnectMsg(pHTC, (HTC_CONNECT_SERVICE_MSG *)pMsg); 
  90a1a1:	da50      	mov.n	a10, a5
  90a1a3:	5bff96        	call8	909ffc <HTCProcessConnectMsg>
  90a1a6:	600004        	j	90a1ae <HTCControlSvcProcessMsg+0x4e>
		break;
        case HTC_MSG_CONFIG_PIPE_ID:
		HTCProcessConfigPipeMsg(pHTC, (HTC_CONFIG_PIPE_MSG *)pMsg); 
  90a1a9:	da50      	mov.n	a10, a5
  90a1ab:	5bffcc        	call8	90a0dc <HTCProcessConfigPipeMsg>

/* process an incomming control message from the host */
LOCAL void HTCControlSvcProcessMsg(HTC_ENDPOINT_ID EndpointID, adf_nbuf_t hdr_buf,
				   adf_nbuf_t pBuffers, void *arg)
{  
	A_BOOL setupComplete = FALSE;
  90a1ae:	c030      	movi.n	a3, 0
		break;
        default:
		;
	}  
        
	if (pHTC->StateFlags & HTC_STATE_SETUP_COMPLETE) {
  90a1b0:	285292        	l32i	a8, a5, 0x248
  90a1b3:	166915        	l32r	a6, 8e4608 <bStandardCommand+0x7a4>
  90a1b6:	7f8710        	bbci	a8, 31, 90a1ca <HTCControlSvcProcessMsg+0x6a>
		/* recycle buffer only if we are fully running */
		HTC_ReturnBuffers(pHTC, ENDPOINT0,pBuffers);
  90a1b9:	226282        	l32i	a2, a6, 0x208
  90a1bc:	da50      	mov.n	a10, a5
  90a1be:	c0b0      	movi.n	a11, 0
  90a1c0:	dc40      	mov.n	a12, a4
  90a1c2:	0b2000        	callx8	a2
  90a1c5:	60001c        	j	90a1e5 <HTCControlSvcProcessMsg+0x85>
  90a1c8:	0000c0        	excw
 *         or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_push_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_push_head(buf, size);
  90a1cb:	b8da      	addi.n	a10, a13, 8
  90a1cd:	400222        	excw
	} else {
		/* supply some head-room again */
		adf_nbuf_push_head(pBuffers, HTC_HDR_LENGTH);
            
		/* otherwise return the packet back to mbox */
		HIF_return_recv_buf(pHTC->hifHandle, pHTC->Endpoints[EndpointID].UpLinkPipeID, pBuffers);        
  90a1d0:	095bf1        	excw
  90a1d3:	d905      	excw
  90a1d5:	220b26        	l32ai	a2, a0, 152
  90a1d8:	62772a        	j	8f1906 <memset+0xaabe>
  90a1db:	529a2b        	call0	8b0a88 <_bss_end+0x39db78>
  90a1de:	2019dc        	l16si	a0, a1, 0x1b8
  90a1e1:	400b60        	excw
  90a1e4:	00c931        	excw
	}

	if (setupComplete) {        
		/* mark that setup has completed */
		pHTC->StateFlags |= HTC_STATE_SETUP_COMPLETE; 
  90a1e7:	235292        	l32i	a3, a5, 0x248
  90a1ea:	c021      	movi.n	a2, 1
  90a1ec:	023202        	or	a2, a3, a2
  90a1ef:	225692        	s32i	a2, a5, 0x248
		if (pHTC->SetupCompleteCb != NULL) {
  90a1f2:	225293        	l32i	a2, a5, 0x24c
  90a1f5:	c821      	beqz.n	a2, 90a1fa <HTCControlSvcProcessMsg+0x9a>
			pHTC->SetupCompleteCb();
  90a1f7:	0b2000        	callx8	a2
  90a1fa:	d10f      	retw.n

0090a1fc <AdjustCreditThreshold>:
					  buf, 
					  pHTC->Endpoints[current_eid].pService->ServiceCtx);
}

LOCAL void AdjustCreditThreshold(HTC_ENDPOINT  *pEndpoint)
{
  90a1fc:	6c1004        	entry	a1, 32
	A_INT16 creditsOutstanding = pEndpoint->CreditsToReturn + pEndpoint->CreditsConsumed;
  90a1ff:	292105        	l16ui	a9, a2, 10
  90a202:	282100        	l16ui	a8, a2, 0
  90a205:	a898      	add.n	a8, a9, a8
        /* set the new threshold based on the number of credits that have been consumed
         * and which have not been returned by the app.
         * Note: it is okay for this threshold to be zero which indicates no threshold 
         * is in use */    
	switch (pEndpoint->ConnectionFlags & HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_MASK) {
  90a207:	292106        	l16ui	a9, a2, 12
					  pHTC->Endpoints[current_eid].pService->ServiceCtx);
}

LOCAL void AdjustCreditThreshold(HTC_ENDPOINT  *pEndpoint)
{
	A_INT16 creditsOutstanding = pEndpoint->CreditsToReturn + pEndpoint->CreditsConsumed;
  90a20a:	088832        	sext	a8, a8, 15
        /* set the new threshold based on the number of credits that have been consumed
         * and which have not been returned by the app.
         * Note: it is okay for this threshold to be zero which indicates no threshold 
         * is in use */    
	switch (pEndpoint->ConnectionFlags & HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_MASK) {
  90a20d:	090941        	extui	a9, a9, 0, 2
  90a210:	689108        	beqi	a9, 1, 90a21c <AdjustCreditThreshold+0x20>
  90a213:	c89e      	beqz.n	a9, 90a225 <AdjustCreditThreshold+0x29>
  90a215:	69920f        	bnei	a9, 2, 90a228 <AdjustCreditThreshold+0x2c>
  90a218:	600006        	j	90a222 <AdjustCreditThreshold+0x26>
  90a21b:	000818        	src	a8, a0, a0
        case HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_ONE_FOURTH :
		creditsOutstanding >>= 2;
		break;                    
        case HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_ONE_HALF :
		creditsOutstanding >>= 1;
  90a21e:	126000        	l32r	a2, 8e2220 <athos_indirection_table_install+0xcac>
		break;
  90a221:	050888        	excw
        case HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_THREE_FOURTHS :  
		creditsOutstanding = (creditsOutstanding * 3) >> 2;                  
  90a224:	090828        	mull	a8, a0, a9
  90a227:	122825        	l32r	a2, 8d42bc <_bss_end+0x3c13ac>
		break;
		/* default case is unity */    
	}
    
	pEndpoint->CreditReturnThreshhold = creditsOutstanding;
  90a22a:	04d10f        	subx8	a1, a13, a4
  90a22d:	000000        	ill

0090a230 <_HTC_SendMsg>:
	ReturnBuffers(htcHandle, EndpointID, pBuffers, TRUE);
}
 
LOCAL void _HTC_SendMsg(htc_handle_t htcHandle, HTC_ENDPOINT_ID EndpointID,
			adf_nbuf_t pBuffers)
{
  90a230:	6c1008        	entry	a1, 64
 * @return data pointer to typecast into your priv structure
 */
static inline a_uint8_t *
adf_nbuf_get_priv(adf_nbuf_t buf)
{
    return (__adf_nbuf_get_priv(buf));
  90a233:	044a02        	or	a10, a4, a4
  90a236:	5bf1f0        	call8	9069f8 <__adf_nbuf_get_priv>
  90a239:	d6a0      	mov.n	a6, a10
 * @return The total length of this buf.
 */
static inline adf_os_size_t
adf_nbuf_len(adf_nbuf_t buf)
{
    return (__adf_nbuf_len(buf));
  90a23b:	da40      	mov.n	a10, a4
  90a23d:	5bf290        	call8	906c80 <__adf_nbuf_len>
 *         or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_push_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_push_head(buf, size);
  90a240:	c0b8      	movi.n	a11, 8
 * @return The total length of this buf.
 */
static inline adf_os_size_t
adf_nbuf_len(adf_nbuf_t buf)
{
    return (__adf_nbuf_len(buf));
  90a242:	d7a0      	mov.n	a7, a10
 *         or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_push_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_push_head(buf, size);
  90a244:	da40      	mov.n	a10, a4
  90a246:	5bf1bc        	call8	906938 <__adf_nbuf_push_head>
	 * Note: in HTCSendDoneHandler(), we undo this so that the caller get's it's buffer
	 * back untainted */   
	pHTCHdr = (HTC_FRAME_HDR *)adf_nbuf_push_head(pBuffers, HTC_HDR_LENGTH);
    
	/* flag that this is the header buffer that was modified */
	ctx->htc_flags |= HTC_FLAGS_BUF_HDR;   
  90a249:	296001        	l8ui	a9, a6, 1
  90a24c:	c480      	movi.n	a8, 64
  90a24e:	089802        	or	a8, a9, a8
  90a251:	286401        	s8i	a8, a6, 1
	/* mark where this buffer came from */
	ctx->end_point = EndpointID;      
  90a254:	030847        	extui	a8, a3, 0, 8
  90a257:	286400        	s8i	a8, a6, 0
	/* the header start is ALWAYS aligned since we DMA it directly */

        /* set some fields, the rest of them will be filled below when we check for
	 * trailer space */
	pHTCHdr->Flags = 0;
  90a25a:	c060      	movi.n	a6, 0
  90a25c:	26a401        	s8i	a6, a10, 1
	pHTCHdr->EndpointID = EndpointID;    
  90a25f:	28a400        	s8i	a8, a10, 0
		HTC_RECORD_HDR    *pRecHdr;
		int               pipeMaxLen;
		A_UINT32          roomForPipeMaxLen;
                          
		/* figure out how much room the last buffer can spare */
		pipeMaxLen = HIF_get_max_msg_len(pHTC->hifHandle,
  90a262:	166915        	l32r	a6, 8e46b8 <bStandardCommand+0x854>
  90a265:	033809        	addx2	a8, a3, a3
  90a268:	02880b        	addx8	a8, a8, a2
  90a26b:	2b8018        	l8ui	a11, a8, 24
  90a26e:	266279        	l32i	a6, a6, 0x1e4
  90a271:	d5a0      	mov.n	a5, a10
  90a273:	2a229a        	l32i	a10, a2, 0x268
  90a276:	0b6000        	callx8	a6
  90a279:	d6a0      	mov.n	a6, a10
 * @return amount of head room
 */
static inline a_uint32_t
adf_nbuf_headroom(adf_nbuf_t buf)
{
    return (__adf_nbuf_headroom(buf));
  90a27b:	da40      	mov.n	a10, a4
  90a27d:	5bf276        	call8	906c58 <__adf_nbuf_headroom>
						 pHTC->Endpoints[EndpointID].DownLinkPipeID);
		roomForPipeMaxLen = pipeMaxLen - adf_nbuf_headroom(pBuffers) - adf_nbuf_len(pBuffers);
  90a280:	0a660c        	sub	a6, a6, a10
 * @return The total length of this buf.
 */
static inline adf_os_size_t
adf_nbuf_len(adf_nbuf_t buf)
{
    return (__adf_nbuf_len(buf));
  90a283:	da40      	mov.n	a10, a4
  90a285:	5bf27e        	call8	906c80 <__adf_nbuf_len>
  90a288:	0a660c        	sub	a6, a6, a10
 * @return amount of tail room 
 */
static inline a_uint32_t
adf_nbuf_tailroom(adf_nbuf_t buf)
{
    return (__adf_nbuf_tailroom(buf));
  90a28b:	da40      	mov.n	a10, a4
  90a28d:	5bf275        	call8	906c64 <__adf_nbuf_tailroom>
		if ( roomForPipeMaxLen < 0 ) {
			roomForPipeMaxLen = 0;
		}
                        
		room = adf_os_min( adf_nbuf_tailroom(pBuffers), roomForPipeMaxLen);
  90a290:	dd60      	mov.n	a13, a6
  90a292:	76ab06        	bgeu	a10, a6, 90a29c <_HTC_SendMsg+0x6c>
  90a295:	da40      	mov.n	a10, a4
  90a297:	5bf273        	call8	906c64 <__adf_nbuf_tailroom>
  90a29a:	dda0      	mov.n	a13, a10
		if (room < (int)(sizeof(HTC_CREDIT_REPORT) + sizeof(HTC_RECORD_HDR))) {
  90a29c:	6bd402        	bgei	a13, 4, 90a2a2 <_HTC_SendMsg+0x72>
  90a29f:	6000bd        	j	90a360 <_HTC_SendMsg+0x130>
		/* note, a record header only has 8 bit fields, so this is safe.
		 * we need an uncached pointer here too */            
		totalReportBytes = 0;
        
		/* get a copy */        
		creditsPendingMap = pHTC->EpCreditPendingMap;   
  90a2a2:	262286        	l32i	a6, a2, 0x218
                           
		/* test pending map to see if we can send a report , if any
		 * credits are available, we might as well send them on the 
		 * unused space in the buffer */
		if (creditsPendingMap) { 
  90a2a5:	6460b7        	beqz	a6, 90a360 <_HTC_SendMsg+0x130>
 *         put, or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_put_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_put_tail(buf, size);
  90a2a8:	da40      	mov.n	a10, a4
  90a2aa:	c0b2      	movi.n	a11, 2
  90a2ac:	9d15      	s32i.n	a13, a1, 20
  90a2ae:	5bf260        	call8	906c30 <__adf_nbuf_put_tail>
			pRecHdr = (HTC_RECORD_HDR *)adf_nbuf_put_tail(pBuffers,
							      sizeof(HTC_RECORD_HDR));
            
			/* set the ID, the length will be updated with the number of credit reports we
			 * can fit (see below) */
			pRecHdr->RecordID = HTC_RECORD_CREDITS;
  90a2b1:	c081      	movi.n	a8, 1
  90a2b3:	28a400        	s8i	a8, a10, 0
			pRecHdr->Length = 0;
  90a2b6:	c080      	movi.n	a8, 0
  90a2b8:	28a401        	s8i	a8, a10, 1
			/* the credit report follows the record header */         
			totalReportBytes += sizeof(HTC_RECORD_HDR);
			room -= sizeof(HTC_RECORD_HDR);
  90a2bb:	8d15      	l32i.n	a13, a1, 20
  90a2bd:	dea0      	mov.n	a14, a10
  90a2bf:	2ddcfe        	addi	a13, a13, -2
  90a2c2:	dc20      	mov.n	a12, a2
			/* set the ID, the length will be updated with the number of credit reports we
			 * can fit (see below) */
			pRecHdr->RecordID = HTC_RECORD_CREDITS;
			pRecHdr->Length = 0;
			/* the credit report follows the record header */         
			totalReportBytes += sizeof(HTC_RECORD_HDR);
  90a2c4:	c092      	movi.n	a9, 2
			room -= sizeof(HTC_RECORD_HDR);
            
			/* walkthrough pending credits map and build the records */
			for (i = 0; 
  90a2c6:	c080      	movi.n	a8, 0
  90a2c8:	600077        	j	90a343 <_HTC_SendMsg+0x113>
  90a2cb:	00c0a1        	excw
			     (creditsPendingMap != 0) && (room >= (int)sizeof(HTC_CREDIT_REPORT)); 
			     i++) {                
				compareMask = (1 << i);
  90a2ce:	008104        	ssl	a8
  90a2d1:	00af1a        	sll	a15, a10
				if (compareMask & creditsPendingMap) {
  90a2d4:	76f066        	bnone	a15, a6, 90a33e <_HTC_SendMsg+0x10e>
  90a2d7:	c0b2      	movi.n	a11, 2
  90a2d9:	da40      	mov.n	a10, a4
  90a2db:	9811      	s32i.n	a8, a1, 4
  90a2dd:	9912      	s32i.n	a9, a1, 8
  90a2df:	9c14      	s32i.n	a12, a1, 16
  90a2e1:	9d15      	s32i.n	a13, a1, 20
  90a2e3:	9e13      	s32i.n	a14, a1, 12
  90a2e5:	9f10      	s32i.n	a15, a1, 0
  90a2e7:	5bf252        	call8	906c30 <__adf_nbuf_put_tail>
									    sizeof(HTC_CREDIT_REPORT));
                                    
					/* clear pending mask, we are going to return all these credits */
					creditsPendingMap &= ~(compareMask);
					/* add this record */
					pCreditRpt->EndpointID = i;
  90a2ea:	8811      	l32i.n	a8, a1, 4
                        
					pCreditRpt = (HTC_CREDIT_REPORT *)adf_nbuf_put_tail(pBuffers,
									    sizeof(HTC_CREDIT_REPORT));
                                    
					/* clear pending mask, we are going to return all these credits */
					creditsPendingMap &= ~(compareMask);
  90a2ec:	8f10      	l32i.n	a15, a1, 0
					/* add this record */
					pCreditRpt->EndpointID = i;
  90a2ee:	28a400        	s8i	a8, a10, 0
					pCreditRpt->Credits = (A_UINT8)pHTC->Endpoints[i].CreditsToReturn;
  90a2f1:	8c14      	l32i.n	a12, a1, 16
                        
					pCreditRpt = (HTC_CREDIT_REPORT *)adf_nbuf_put_tail(pBuffers,
									    sizeof(HTC_CREDIT_REPORT));
                                    
					/* clear pending mask, we are going to return all these credits */
					creditsPendingMap &= ~(compareMask);
  90a2f3:	c7bf      	movi.n	a11, -1
  90a2f5:	0fbf03        	xor	a15, a11, a15
					/* add this record */
					pCreditRpt->EndpointID = i;
					pCreditRpt->Credits = (A_UINT8)pHTC->Endpoints[i].CreditsToReturn;
  90a2f8:	2bc102        	l16ui	a11, a12, 4
                        
					pCreditRpt = (HTC_CREDIT_REPORT *)adf_nbuf_put_tail(pBuffers,
									    sizeof(HTC_CREDIT_REPORT));
                                    
					/* clear pending mask, we are going to return all these credits */
					creditsPendingMap &= ~(compareMask);
  90a2fb:	0f6601        	and	a6, a6, a15
					/* add this record */
					pCreditRpt->EndpointID = i;
					pCreditRpt->Credits = (A_UINT8)pHTC->Endpoints[i].CreditsToReturn;
  90a2fe:	2ba401        	s8i	a11, a10, 1
					/* remove pending credits, we always send deltas */
					pHTC->Endpoints[i].CreditsToReturn = 0; 
  90a301:	c0a0      	movi.n	a10, 0
  90a303:	2ac502        	s16i	a10, a12, 4
					/* adjust new threshold for this endpoint if needed */
					CHECK_AND_ADJUST_CREDIT_THRESHOLD(&pHTC->Endpoints[i]);
  90a306:	2ac108        	l16ui	a10, a12, 16
  90a309:	8912      	l32i.n	a9, a1, 8
  90a30b:	8d15      	l32i.n	a13, a1, 20
  90a30d:	8e13      	l32i.n	a14, a1, 12
  90a30f:	7da71a        	bbci	a10, 29, 90a32d <_HTC_SendMsg+0xfd>
  90a312:	088a09        	addx2	a10, a8, a8
  90a315:	02aa0b        	addx8	a10, a10, a2
  90a318:	b4aa      	addi.n	a10, a10, 4
  90a31a:	9811      	s32i.n	a8, a1, 4
  90a31c:	2c1604        	s32i	a12, a1, 16
  90a31f:	5bffb7        	call8	90a1fc <AdjustCreditThreshold>
  90a322:	8e13      	l32i.n	a14, a1, 12
  90a324:	8d15      	l32i.n	a13, a1, 20
  90a326:	8c14      	l32i.n	a12, a1, 16
  90a328:	8912      	l32i.n	a9, a1, 8
  90a32a:	281201        	l32i	a8, a1, 4
					/* update this record length */
					pRecHdr->Length += sizeof(HTC_CREDIT_REPORT);
  90a32d:	2ae001        	l8ui	a10, a14, 1
					room -= sizeof(HTC_CREDIT_REPORT);
  90a330:	2ddcfe        	addi	a13, a13, -2
					/* remove pending credits, we always send deltas */
					pHTC->Endpoints[i].CreditsToReturn = 0; 
					/* adjust new threshold for this endpoint if needed */
					CHECK_AND_ADJUST_CREDIT_THRESHOLD(&pHTC->Endpoints[i]);
					/* update this record length */
					pRecHdr->Length += sizeof(HTC_CREDIT_REPORT);
  90a333:	b2aa      	addi.n	a10, a10, 2
  90a335:	2ae401        	s8i	a10, a14, 1
					room -= sizeof(HTC_CREDIT_REPORT);
					totalReportBytes += sizeof(HTC_CREDIT_REPORT);
  90a338:	299c02        	addi	a9, a9, 2

					if ( room < sizeof(HTC_CREDIT_REPORT) ) {
  90a33b:	6ed20a        	bltui	a13, 2, 90a349 <_HTC_SendMsg+0x119>
			room -= sizeof(HTC_RECORD_HDR);
            
			/* walkthrough pending credits map and build the records */
			for (i = 0; 
			     (creditsPendingMap != 0) && (room >= (int)sizeof(HTC_CREDIT_REPORT)); 
			     i++) {                
  90a33e:	b188      	addi.n	a8, a8, 1
  90a340:	2ccc18        	addi	a12, a12, 24
			totalReportBytes += sizeof(HTC_RECORD_HDR);
			room -= sizeof(HTC_RECORD_HDR);
            
			/* walkthrough pending credits map and build the records */
			for (i = 0; 
			     (creditsPendingMap != 0) && (room >= (int)sizeof(HTC_CREDIT_REPORT)); 
  90a343:	6ad202        	blti	a13, 2, 90a349 <_HTC_SendMsg+0x119>
			/* the credit report follows the record header */         
			totalReportBytes += sizeof(HTC_RECORD_HDR);
			room -= sizeof(HTC_RECORD_HDR);
            
			/* walkthrough pending credits map and build the records */
			for (i = 0; 
  90a346:	656f82        	bnez	a6, 90a2cc <_HTC_SendMsg+0x9c>
					}
				}
			}
            
			/* update new pending credits map */       
			pHTC->EpCreditPendingMap = creditsPendingMap;
  90a349:	262686        	s32i	a6, a2, 0x218
		}
        
		if (totalReportBytes <= 0) {
  90a34c:	6a9110        	blti	a9, 1, 90a360 <_HTC_SendMsg+0x130>
		 */
        
		/* set header option bytes */ 
		pHTCHdr->ControlBytes[0] = totalReportBytes;
		/* HTC frame contains a trailer */
		pHTCHdr->Flags |= HTC_FLAGS_RECV_TRAILER;
  90a34f:	285001        	l8ui	a8, a5, 1
  90a352:	c062      	movi.n	a6, 2
  90a354:	068602        	or	a6, a8, a6
		 * The trailer can have at most 1 credit record with up to 32  reports in the record.
		 * The trailer can have at most 1 lookahead record with only 1 lookahead report in the record.
		 */
        
		/* set header option bytes */ 
		pHTCHdr->ControlBytes[0] = totalReportBytes;
  90a357:	295404        	s8i	a9, a5, 4
		/* HTC frame contains a trailer */
		pHTCHdr->Flags |= HTC_FLAGS_RECV_TRAILER;
  90a35a:	265401        	s8i	a6, a5, 1
		/* increment total size by the reports we added */
		totsz += totalReportBytes;
  90a35d:	097708        	add	a7, a7, a9
          
	if (totsz == 0) {
	}
    
	/* set length for message (this includes any reports that were added above) */
	pHTCHdr->PayloadLen = adf_os_htons(totsz);  
  90a360:	07074f        	extui	a7, a7, 0, 16
  90a363:	078614        	srli	a6, a7, 8
  90a366:	265402        	s8i	a6, a5, 2
  90a369:	275403        	s8i	a7, a5, 3
	HIF_send_buffer(pHTC->hifHandle, pHTC->Endpoints[EndpointID].DownLinkPipeID, pBuffers);       
  90a36c:	033309        	addx2	a3, a3, a3
  90a36f:	156915        	l32r	a5, 8e47c4 <bStandardCommand+0x960>
  90a372:	02330b        	addx8	a3, a3, a2
  90a375:	255276        	l32i	a5, a5, 0x1d8
  90a378:	2a229a        	l32i	a10, a2, 0x268
  90a37b:	2b3018        	l8ui	a11, a3, 24
  90a37e:	044c02        	or	a12, a4, a4
  90a381:	0b5000        	callx8	a5
  90a384:	d10f      	retw.n
	...

0090a388 <HTCMsgRecvHandler>:

}
            
/* callback from the mailbox hardware layer when a full message arrives */
LOCAL void HTCMsgRecvHandler(adf_nbuf_t hdr_buf, adf_nbuf_t buffer, void *context)
{
  90a388:	6c1008        	entry	a1, 64
	HTC_CONTEXT *pHTC = (HTC_CONTEXT *)context;
	adf_nbuf_t tmp_nbuf;
                
	if (hdr_buf == ADF_NBUF_NULL) {
		/* HTC hdr is not in the hdr_buf */
		tmp_nbuf = buffer;
  90a38b:	d530      	mov.n	a5, a3
  90a38d:	022539        	movnez	a5, a2, a2
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  90a390:	da50      	mov.n	a10, a5
  90a392:	b41b      	addi.n	a11, a1, 4
  90a394:	dc10      	mov.n	a12, a1
  90a396:	5bf242        	call8	906ca0 <__adf_nbuf_peek_header>
	else {
		tmp_nbuf = hdr_buf;
	}
                
	adf_nbuf_peek_header(tmp_nbuf, &anbdata, &anblen);        
	pHTCHdr = (HTC_FRAME_HDR *)anbdata; 
  90a399:	8911      	l32i.n	a9, a1, 4
	HTC_CONTEXT *pHTC = (HTC_CONTEXT *)context;
	adf_nbuf_t tmp_nbuf;
                
	if (hdr_buf == ADF_NBUF_NULL) {
		/* HTC hdr is not in the hdr_buf */
		tmp_nbuf = buffer;
  90a39b:	d750      	mov.n	a7, a5
	eid = pHTCHdr->EndpointID; 
    
	pEndpoint = &pHTC->Endpoints[eid];
	eidMask = 1 << eid;

	if (pHTCHdr->Flags & HTC_FLAGS_CREDIT_REDISTRIBUTION) {
  90a39d:	259001        	l8ui	a5, a9, 1
	adf_nbuf_peek_header(tmp_nbuf, &anbdata, &anblen);        
	pHTCHdr = (HTC_FRAME_HDR *)anbdata; 
      
	totsz = adf_os_ntohs(pHTCHdr->PayloadLen); 
    
	eid = pHTCHdr->EndpointID; 
  90a3a0:	269000        	l8ui	a6, a9, 0
    
	pEndpoint = &pHTC->Endpoints[eid];
	eidMask = 1 << eid;

	if (pHTCHdr->Flags & HTC_FLAGS_CREDIT_REDISTRIBUTION) {
  90a3a3:	7d5f76        	bbsi	a5, 29, 90a41d <HTCMsgRecvHandler+0x95>
      
	totsz = adf_os_ntohs(pHTCHdr->PayloadLen); 
    
	eid = pHTCHdr->EndpointID; 
    
	pEndpoint = &pHTC->Endpoints[eid];
  90a3a6:	066509        	addx2	a5, a6, a6
		 * Byte 0 */
		RedistributeCredit(tmp_nbuf, pHTCHdr->ControlBytes[0]);
		return;
	}

	if (pHTC->StateFlags & HTC_STATE_SETUP_COMPLETE) {
  90a3a9:	284292        	l32i	a8, a4, 0x248
      
	totsz = adf_os_ntohs(pHTCHdr->PayloadLen); 
    
	eid = pHTCHdr->EndpointID; 
    
	pEndpoint = &pHTC->Endpoints[eid];
  90a3ac:	04550b        	addx8	a5, a5, a4
  90a3af:	b455      	addi.n	a5, a5, 4
		 * Byte 0 */
		RedistributeCredit(tmp_nbuf, pHTCHdr->ControlBytes[0]);
		return;
	}

	if (pHTC->StateFlags & HTC_STATE_SETUP_COMPLETE) {
  90a3b1:	7f8707        	bbci	a8, 31, 90a3bc <HTCMsgRecvHandler+0x34>
		/* after setup we keep track of credit consumption to allow us to
		 * adjust thresholds to reduce credit dribbling */  
		pEndpoint->CreditsConsumed ++;
  90a3b4:	285105        	l16ui	a8, a5, 10
  90a3b7:	b188      	addi.n	a8, a8, 1
  90a3b9:	285505        	s16i	a8, a5, 10
	/* from the design document, we put the endpoint into a "host-needs-credit" state
	 * when we receive a frame with the NEED_CREDIT_UPDATE flag set .
	 * if the host received credits through an opportunistic path, then it can
	 * issue a another frame with this bit cleared, this signals the target to clear
	 * the "host-needs-credit" state */    
	if (pHTCHdr->Flags & HTC_FLAGS_NEED_CREDIT_UPDATE) {
  90a3bc:	299001        	l8ui	a9, a9, 1
	totsz = adf_os_ntohs(pHTCHdr->PayloadLen); 
    
	eid = pHTCHdr->EndpointID; 
    
	pEndpoint = &pHTC->Endpoints[eid];
	eidMask = 1 << eid;
  90a3bf:	c081      	movi.n	a8, 1
	/* from the design document, we put the endpoint into a "host-needs-credit" state
	 * when we receive a frame with the NEED_CREDIT_UPDATE flag set .
	 * if the host received credits through an opportunistic path, then it can
	 * issue a another frame with this bit cleared, this signals the target to clear
	 * the "host-needs-credit" state */    
	if (pHTCHdr->Flags & HTC_FLAGS_NEED_CREDIT_UPDATE) {
  90a3c1:	090940        	extui	a9, a9, 0, 1
	totsz = adf_os_ntohs(pHTCHdr->PayloadLen); 
    
	eid = pHTCHdr->EndpointID; 
    
	pEndpoint = &pHTC->Endpoints[eid];
	eidMask = 1 << eid;
  90a3c4:	006104        	ssl	a6
  90a3c7:	00881a        	sll	a8, a8
  90a3ca:	2a4285        	l32i	a10, a4, 0x214
	/* from the design document, we put the endpoint into a "host-needs-credit" state
	 * when we receive a frame with the NEED_CREDIT_UPDATE flag set .
	 * if the host received credits through an opportunistic path, then it can
	 * issue a another frame with this bit cleared, this signals the target to clear
	 * the "host-needs-credit" state */    
	if (pHTCHdr->Flags & HTC_FLAGS_NEED_CREDIT_UPDATE) {
  90a3cd:	c997      	beqz.n	a9, 90a3e8 <HTCMsgRecvHandler+0x60>
		/* the host is running low (or is out) of credits on this
		 * endpoint, update mask */
		pHTC->EpHostNeedsCreditMap |= eidMask; 
  90a3cf:	08aa02        	or	a10, a10, a8
		/* check and set new threshold since host has reached a low credit situation */
		CHECK_AND_ADJUST_CREDIT_THRESHOLD(pEndpoint);                          
  90a3d2:	295106        	l16ui	a9, a5, 12
	 * issue a another frame with this bit cleared, this signals the target to clear
	 * the "host-needs-credit" state */    
	if (pHTCHdr->Flags & HTC_FLAGS_NEED_CREDIT_UPDATE) {
		/* the host is running low (or is out) of credits on this
		 * endpoint, update mask */
		pHTC->EpHostNeedsCreditMap |= eidMask; 
  90a3d5:	2a4685        	s32i	a10, a4, 0x214
		/* check and set new threshold since host has reached a low credit situation */
		CHECK_AND_ADJUST_CREDIT_THRESHOLD(pEndpoint);                          
  90a3d8:	7d971a        	bbci	a9, 29, 90a3f6 <HTCMsgRecvHandler+0x6e>
  90a3db:	da50      	mov.n	a10, a5
  90a3dd:	9814      	s32i.n	a8, a1, 16
  90a3df:	5bff87        	call8	90a1fc <AdjustCreditThreshold>
  90a3e2:	8814      	l32i.n	a8, a1, 16
  90a3e4:	60000e        	j	90a3f6 <HTCMsgRecvHandler+0x6e>
  90a3e7:	00c7bf        	excw
	} else {
		/* clear the flag */
		pHTC->EpHostNeedsCreditMap &= ~(eidMask);       
  90a3ea:	08bb03        	xor	a11, a11, a8
  90a3ed:	0baa01        	and	a10, a10, a11
  90a3f0:	2a4685        	s32i	a10, a4, 0x214
		pEndpoint->CreditReturnThreshhold = 0; 
  90a3f3:	295504        	s16i	a9, a5, 8
 *         or NULL if there is not sufficient data to pull.
 */
static inline a_uint8_t *
adf_nbuf_pull_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_pull_head(buf, size);
  90a3f6:	da70      	mov.n	a10, a7
  90a3f8:	c0b8      	movi.n	a11, 8
  90a3fa:	281604        	s32i	a8, a1, 16
  90a3fd:	5bf159        	call8	906964 <__adf_nbuf_pull_head>
	 *        as the result of parsing this message.  In either case, if there are
	 *        pending credits and the host needs them, a credit report will be sent either through 
	 *        the response message trailer or a NULL message through HTC_ReturnBuffers().
	 */       
        
	pEndpoint->pService->ProcessRecvMsg(eid, hdr_buf, buffer, pEndpoint->pService->ServiceCtx);
  90a400:	8751      	l32i.n	a7, a5, 4
  90a402:	da60      	mov.n	a10, a6
  90a404:	8d76      	l32i.n	a13, a7, 24
  90a406:	8971      	l32i.n	a9, a7, 4
  90a408:	db20      	mov.n	a11, a2
  90a40a:	033c02        	or	a12, a3, a3
  90a40d:	0b9000        	callx8	a9

	/* Calls to HTC_ReturnBuffers drives the endpoint credit reporting state machine. 
	 * We do not want to delay credits for too long in the event that the application is 
	 * holding onto buffers for excessive periods of time.  This gives us "some" better
	 * opportunities to send up credits. */
	HTCCheckAndSendCreditReport(pHTC, eidMask, pEndpoint, eid); 
  90a410:	8814      	l32i.n	a8, a1, 16
  90a412:	da40      	mov.n	a10, a4
  90a414:	db80      	mov.n	a11, a8
  90a416:	dc50      	mov.n	a12, a5
  90a418:	dd60      	mov.n	a13, a6
  90a41a:	5bfea0        	call8	909e9c <HTCCheckAndSendCreditReport>
  90a41d:	d10f      	retw.n
	...

0090a420 <RedistributeCredit>:
	pEndpoint->CreditReturnThreshhold = creditsOutstanding;
    
}

LOCAL void RedistributeCredit(adf_nbuf_t buf, int toPipeId)
{
  90a420:	6c1004        	entry	a1, 32
  90a423:	d10f      	retw.n
  90a425:	000000        	ill

0090a428 <WMIServiceConnect>:
                                 HTC_ENDPOINT_ID eid, 
                                 A_UINT8 *pDataIn, 
                                 int LengthIn,
                                 A_UINT8 *pDataOut,
                                 int *pLengthOut)
{
  90a428:	6c1004        	entry	a1, 32
	WMI_SVC_CONTEXT *pWMI = (WMI_SVC_CONTEXT *)pService->ServiceCtx;
    
        /* save the eid to use */
	pWMI->ControlEp = eid;
  90a42b:	8826      	l32i.n	a8, a2, 24
  90a42d:	938a      	s32i.n	a3, a8, 40
	return HTC_SERVICE_SUCCESS;
}
  90a42f:	c020      	movi.n	a2, 0
  90a431:	d10f      	retw.n
	...

0090a434 <_WMI_GetPendingEventsCount>:
    
	return pWMI;
}

static int _WMI_GetPendingEventsCount(wmi_handle_t handle)
{
  90a434:	6c1004        	entry	a1, 32
	WMI_SVC_CONTEXT *pWMI = (WMI_SVC_CONTEXT *)handle;
	return pWMI->PendingEvents;
}
  90a437:	8222      	l32i.n	a2, a2, 8
  90a439:	d10f      	retw.n
	...

0090a43c <_WMI_GetControlEp>:

static int  _WMI_GetControlEp(wmi_handle_t handle)
{
  90a43c:	6c1004        	entry	a1, 32
	WMI_SVC_CONTEXT *pWMI = (WMI_SVC_CONTEXT *)handle;
	return pWMI->ControlEp;
}
  90a43f:	822a      	l32i.n	a2, a2, 40
  90a441:	d10f      	retw.n
	...

0090a444 <_WMI_RegisterDispatchTable>:

static void _WMI_RegisterDispatchTable(wmi_handle_t handle,
				       WMI_DISPATCH_TABLE *pDispatchTable)
{
  90a444:	6c1004        	entry	a1, 32
	WMI_SVC_CONTEXT *pWMI = (WMI_SVC_CONTEXT *)handle;
    
	if (NULL == pWMI->pDispatchHead) {
  90a447:	882b      	l32i.n	a8, a2, 44
  90a449:	cc83      	bnez.n	a8, 90a450 <_WMI_RegisterDispatchTable+0xc>
		pWMI->pDispatchHead = pDispatchTable;
  90a44b:	932b      	s32i.n	a3, a2, 44
  90a44d:	600003        	j	90a454 <_WMI_RegisterDispatchTable+0x10>
		pWMI->pDispatchTail = pDispatchTable;        
	} else {
		/* link to the tail */
		pWMI->pDispatchTail->pNext = pDispatchTable;
  90a450:	882c      	l32i.n	a8, a2, 48
  90a452:	9380      	s32i.n	a3, a8, 0
		pWMI->pDispatchTail = pDispatchTable;        
  90a454:	932c      	s32i.n	a3, a2, 48
  90a456:	d10f      	retw.n

0090a458 <_WMI_Shutdown>:
	
	HTC_SendMsg(pWMI->HtcHandle, pWMI->ControlEp, pEvt);    
}

static void _WMI_Shutdown(wmi_handle_t handle)
{
  90a458:	6c1004        	entry	a1, 32
  90a45b:	d10f      	retw.n
  90a45d:	000000        	ill

0090a460 <WMIRecvMessageHandler>:

#include "wmi_internal.h"

static void WMIRecvMessageHandler(HTC_ENDPOINT_ID EndPt, adf_nbuf_t hdr_buf,
				  adf_nbuf_t pHTCBuf, void *arg)
{
  90a460:	6c1006        	entry	a1, 48
	int length;
	a_uint8_t *anbdata;
	a_uint32_t anblen;
	WMI_CMD_HDR *cmdHdr;
            
	adf_os_assert(hdr_buf == ADF_NBUF_NULL);
  90a463:	643016        	beqz	a3, 90a47d <WMIRecvMessageHandler+0x1d>
  90a466:	136915        	l32r	a3, 8e48bc <bStandardCommand+0xa58>
  90a469:	1a6a52        	l32r	a10, 8e4db4 <mUsbEPinHighBandSet+0x414>
  90a46c:	233212        	l32i	a3, a3, 72
  90a46f:	1b6a53        	l32r	a11, 8e4dbc <mUsbEPinHighBandSet+0x41c>
  90a472:	0b3000        	callx8	a3
  90a475:	13697a        	l32r	a3, 8e4a60 <mUsbEPinHighBandSet+0xc0>
  90a478:	0c0200        	memw
  90a47b:	8330      	l32i.n	a3, a3, 0
 * @return The total length of this buf.
 */
static inline adf_os_size_t
adf_nbuf_len(adf_nbuf_t buf)
{
    return (__adf_nbuf_len(buf));
  90a47d:	da40      	mov.n	a10, a4
  90a47f:	5bf200        	call8	906c80 <__adf_nbuf_len>
  90a482:	d3a0      	mov.n	a3, a10

	do {
		length = adf_nbuf_len(pHTCBuf);
		if (length < sizeof(WMI_CMD_HDR)) {
  90a484:	6ea465        	bltui	a10, 4, 90a4ed <WMIRecvMessageHandler+0x8d>
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  90a487:	b41b      	addi.n	a11, a1, 4
  90a489:	dc10      	mov.n	a12, a1
  90a48b:	da40      	mov.n	a10, a4
  90a48d:	5bf204        	call8	906ca0 <__adf_nbuf_peek_header>
		adf_nbuf_peek_header(pHTCBuf, &anbdata, &anblen);
        
		pCurrentTable = pWMI->pDispatchHead;
		length = length - sizeof(WMI_CMD_HDR);
        
		cmdHdr = (WMI_CMD_HDR *)anbdata;
  90a490:	8d11      	l32i.n	a13, a1, 4
		}

		adf_nbuf_peek_header(pHTCBuf, &anbdata, &anblen);
        
		pCurrentTable = pWMI->pDispatchHead;
		length = length - sizeof(WMI_CMD_HDR);
  90a492:	2e3cfc        	addi	a14, a3, -4
        
		cmdHdr = (WMI_CMD_HDR *)anbdata;
		cmd = adf_os_ntohs(cmdHdr->commandId);
  90a495:	2bd000        	l8ui	a11, a13, 0
  90a498:	23d001        	l8ui	a3, a13, 1
		seq = adf_os_ntohs(cmdHdr->seqNo);
  90a49b:	2cd002        	l8ui	a12, a13, 2
        
		pCurrentTable = pWMI->pDispatchHead;
		length = length - sizeof(WMI_CMD_HDR);
        
		cmdHdr = (WMI_CMD_HDR *)anbdata;
		cmd = adf_os_ntohs(cmdHdr->commandId);
  90a49e:	08bb11        	slli	a11, a11, 8
  90a4a1:	0b3b02        	or	a11, a3, a11
		seq = adf_os_ntohs(cmdHdr->seqNo);
  90a4a4:	23d003        	l8ui	a3, a13, 3
  90a4a7:	08cc11        	slli	a12, a12, 8
			break;    
		}

		adf_nbuf_peek_header(pHTCBuf, &anbdata, &anblen);
        
		pCurrentTable = pWMI->pDispatchHead;
  90a4aa:	885b      	l32i.n	a8, a5, 44
		length = length - sizeof(WMI_CMD_HDR);
        
		cmdHdr = (WMI_CMD_HDR *)anbdata;
		cmd = adf_os_ntohs(cmdHdr->commandId);
		seq = adf_os_ntohs(cmdHdr->seqNo);
  90a4ac:	0c3c02        	or	a12, a3, a12
        
		pCmdBuffer = anbdata + sizeof(WMI_CMD_HDR); 
  90a4af:	b4dd      	addi.n	a13, a13, 4
		pCmdHandler = NULL;
        
		while (pCurrentTable != NULL) {
  90a4b1:	600035        	j	90a4ea <WMIRecvMessageHandler+0x8a>
            
			pContext = pCurrentTable->pContext;
  90a4b4:	8a81      	l32i.n	a10, a8, 4
			pCurrentEntry = pCurrentTable->pTable;
  90a4b6:	8983      	l32i.n	a9, a8, 12
        
			/* scan table entries */
			for (i = 0; i < pCurrentTable->NumberOfEntries; i++, pCurrentEntry++) {
  90a4b8:	8382      	l32i.n	a3, a8, 8
  90a4ba:	c0f0      	movi.n	a15, 0
  90a4bc:	600018        	j	90a4d8 <WMIRecvMessageHandler+0x78>
  90a4bf:	002691        	excw
				if (pCurrentEntry->CmdID == cmd) {
  90a4c2:	027b69        	excw
  90a4c5:	0d2391        	excw
					/* found a match */
					pCmdHandler = pCurrentEntry->pCmdHandler;
        
					/* optionally check length */
					if ((pCurrentEntry->CheckLength != 0) &&
  90a4c8:	038f90        	l32e	a3, a8, -4
  90a4cb:	c931      	beqz.n	a3, 90a4e0 <WMIRecvMessageHandler+0x80>
  90a4cd:	73e217        	blt	a14, a3, 90a4e8 <WMIRecvMessageHandler+0x88>
  90a4d0:	60000c        	j	90a4e0 <WMIRecvMessageHandler+0x80>
  90a4d3:	00b1ff        	excw
            
			pContext = pCurrentTable->pContext;
			pCurrentEntry = pCurrentTable->pTable;
        
			/* scan table entries */
			for (i = 0; i < pCurrentTable->NumberOfEntries; i++, pCurrentEntry++) {
  90a4d6:	b899      	addi.n	a9, a9, 8
  90a4d8:	73f2e4        	blt	a15, a3, 90a4c0 <WMIRecvMessageHandler+0x60>
  90a4db:	600009        	j	90a4e8 <WMIRecvMessageHandler+0x88>
  90a4de:	0000c8        	excw
					/* end search */                
					break;    
				}                        
			} 
            
			if (pCmdHandler != NULL) {
  90a4e1:	f4          	.byte 0xf4
		}
            
		/* if we get here, we have a command handler to dispatch */
                
		/* call dispatch function */
		pCmdHandler(pContext, cmd, seq, pCmdBuffer, length);
  90a4e2:	0bf000        	callx8	a15
  90a4e5:	600004        	j	90a4ed <WMIRecvMessageHandler+0x8d>
				/* found a handler */
				break;
			}
                
			/* scan next table */
			pCurrentTable = pCurrentTable->pNext;
  90a4e8:	8880      	l32i.n	a8, a8, 0
		seq = adf_os_ntohs(cmdHdr->seqNo);
        
		pCmdBuffer = anbdata + sizeof(WMI_CMD_HDR); 
		pCmdHandler = NULL;
        
		while (pCurrentTable != NULL) {
  90a4ea:	658fc6        	bnez	a8, 90a4b4 <WMIRecvMessageHandler+0x54>
        /* Invalidate the buffer (including HTC header). Note : we only need to invalidate up to the portion
	 * that was used (cache invalidate will also round up to the nearest cache line).  
	 * The rest of the buffer should still be coherent.
	 * */

	HTC_ReturnBuffers(pWMI->HtcHandle, EndPt, pHTCBuf);         
  90a4ed:	136915        	l32r	a3, 8e4944 <mUsbFIFOConfig+0x10>
  90a4f0:	8a50      	l32i.n	a10, a5, 0
  90a4f2:	233282        	l32i	a3, a3, 0x208
  90a4f5:	db20      	mov.n	a11, a2
  90a4f7:	dc40      	mov.n	a12, a4
  90a4f9:	0b3000        	callx8	a3
  90a4fc:	d10f      	retw.n
	...

0090a500 <_WMI_SendCompleteHandler>:
}

/* send completion handler when any HTC buffers are returned */
static void _WMI_SendCompleteHandler(HTC_ENDPOINT_ID Endpt, adf_nbuf_t pHTCBuf, void *arg)
{
  90a500:	6c1004        	entry	a1, 32
 * @return data pointer to typecast into your priv structure
 */
static inline a_uint8_t *
adf_nbuf_get_priv(adf_nbuf_t buf)
{
    return (__adf_nbuf_get_priv(buf));
  90a503:	da30      	mov.n	a10, a3
  90a505:	5bf13c        	call8	9069f8 <__adf_nbuf_get_priv>
		poolId = POOL_ID_WMI_SVC_EVENT;
	} else {
		poolId = POOL_ID_WMI_SVC_CMD_REPLY;
	}
        
	BUF_Pool_free_buf(pWMI->PoolHandle, poolId, pHTCBuf);
  90a508:	186915        	l32r	a8, 8e495c <mUsbEPMxPtSzHigh+0x8>
	WMI_BUF_CONTEXT *ctx;
	BUF_POOL_ID poolId;
    
	ctx = (WMI_BUF_CONTEXT *)adf_nbuf_get_priv(pHTCBuf);
        
	if ( ctx->EventClass == WMI_EVT_CLASS_CMD_EVENT ) {
  90a50b:	8ca1      	l32i.n	a12, a10, 4
		poolId = POOL_ID_WMI_SVC_EVENT;
	} else {
		poolId = POOL_ID_WMI_SVC_CMD_REPLY;
	}
        
	BUF_Pool_free_buf(pWMI->PoolHandle, poolId, pHTCBuf);
  90a50d:	c092      	movi.n	a9, 2
  90a50f:	28829e        	l32i	a8, a8, 0x278
  90a512:	8a41      	l32i.n	a10, a4, 4
  90a514:	c0b1      	movi.n	a11, 1
  90a516:	0c9b38        	moveqz	a11, a9, a12
  90a519:	dc30      	mov.n	a12, a3
  90a51b:	0b8000        	callx8	a8
  90a51e:	d10f      	retw.n

0090a520 <_WMI_AllocEvent>:
	}
}

static adf_nbuf_t _WMI_AllocEvent(wmi_handle_t handle, WMI_EVT_CLASS EventClass,
				  int Length)
{     
  90a520:	6c1004        	entry	a1, 32
		poolId = POOL_ID_WMI_SVC_EVENT;
	} else {
		poolId = POOL_ID_WMI_SVC_CMD_REPLY;
	}
    
	buf = BUF_Pool_alloc_buf(pWMI->PoolHandle, 
  90a523:	186915        	l32r	a8, 8e4978 <mUsbEPMxPtSzHigh+0x24>
	WMI_SVC_CONTEXT *pWMI = (WMI_SVC_CONTEXT *)handle;
	adf_nbuf_t buf;
	WMI_BUF_CONTEXT *ctx;
    
	if ( EventClass == WMI_EVT_CLASS_CMD_EVENT ) {
		poolId = POOL_ID_WMI_SVC_EVENT;
  90a526:	c051      	movi.n	a5, 1
  90a528:	c042      	movi.n	a4, 2
  90a52a:	035439        	movnez	a4, a5, a3
	} else {
		poolId = POOL_ID_WMI_SVC_CMD_REPLY;
	}
    
	buf = BUF_Pool_alloc_buf(pWMI->PoolHandle, 
  90a52d:	8a20      	l32i.n	a10, a2, 0
  90a52f:	25829c        	l32i	a5, a8, 0x270
  90a532:	288285        	l32i	a8, a8, 0x214
  90a535:	8621      	l32i.n	a6, a2, 4
  90a537:	0b8000        	callx8	a8
  90a53a:	b4ac      	addi.n	a12, a10, 4
  90a53c:	044b02        	or	a11, a4, a4
  90a53f:	066a02        	or	a10, a6, a6
  90a542:	0b5000        	callx8	a5
  90a545:	d2a0      	mov.n	a2, a10
				 poolId, 
				 sizeof(WMI_CMD_HDR) + HTC_GetReservedHeadroom(pWMI->HtcHandle));
     
	if ( buf != NULL ) {
  90a547:	c8a3      	beqz.n	a10, 90a54e <_WMI_AllocEvent+0x2e>
  90a549:	5bf12b        	call8	9069f8 <__adf_nbuf_get_priv>
		ctx = (WMI_BUF_CONTEXT *)adf_nbuf_get_priv(buf);
		ctx->EventClass = EventClass;
  90a54c:	93a1      	s32i.n	a3, a10, 4
	}
	return buf;
}
  90a54e:	d10f      	retw.n

0090a550 <_WMI_SendEvent>:

static void _WMI_SendEvent(wmi_handle_t handle, adf_nbuf_t pEvt, 
                           A_UINT16 EventId, A_UINT16 SeqNo, int Length)
{
  90a550:	6c1004        	entry	a1, 32
 *         or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_push_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_push_head(buf, size);
  90a553:	033a02        	or	a10, a3, a3
  90a556:	2b0a04        	movi	a11, 4
  90a559:	5bf0f7        	call8	906938 <__adf_nbuf_push_head>
  90a55c:	04044f        	extui	a4, a4, 0, 16
  90a55f:	05054f        	extui	a5, a5, 0, 16
	WMI_SVC_CONTEXT *pWMI = (WMI_SVC_CONTEXT *)handle;
	A_UINT8 *pBuffer;
        
	pBuffer = adf_nbuf_push_head(pEvt, sizeof(WMI_CMD_HDR));
	A_SET_UINT16_FIELD(pBuffer, WMI_CMD_HDR, commandId, adf_os_htons(EventId));        
  90a562:	24a401        	s8i	a4, a10, 1
  90a565:	048814        	srli	a8, a4, 8
	A_SET_UINT16_FIELD(pBuffer, WMI_CMD_HDR, seqNo, adf_os_htons(SeqNo));
  90a568:	058414        	srli	a4, a5, 8
  90a56b:	24a402        	s8i	a4, a10, 2
	
	HTC_SendMsg(pWMI->HtcHandle, pWMI->ControlEp, pEvt);    
  90a56e:	146915        	l32r	a4, 8e49c4 <mUsbEPinHighBandSet+0x24>
{
	WMI_SVC_CONTEXT *pWMI = (WMI_SVC_CONTEXT *)handle;
	A_UINT8 *pBuffer;
        
	pBuffer = adf_nbuf_push_head(pEvt, sizeof(WMI_CMD_HDR));
	A_SET_UINT16_FIELD(pBuffer, WMI_CMD_HDR, commandId, adf_os_htons(EventId));        
  90a571:	28a400        	s8i	a8, a10, 0
	A_SET_UINT16_FIELD(pBuffer, WMI_CMD_HDR, seqNo, adf_os_htons(SeqNo));
  90a574:	25a403        	s8i	a5, a10, 3
	
	HTC_SendMsg(pWMI->HtcHandle, pWMI->ControlEp, pEvt);    
  90a577:	244284        	l32i	a4, a4, 0x210
  90a57a:	8a20      	l32i.n	a10, a2, 0
  90a57c:	8b2a      	l32i.n	a11, a2, 40
  90a57e:	033c02        	or	a12, a3, a3
  90a581:	0b4000        	callx8	a4
  90a584:	d10f      	retw.n
	...

0090a588 <_WMI_Init>:
}

/**************  public APIS ********************************************/
    
static wmi_handle_t _WMI_Init(WMI_SVC_CONFIG *pWmiConfig)
{
  90a588:	6c1004        	entry	a1, 32
#include "Magpie_api.h"

static inline void *	__adf_os_mem_alloc(adf_os_size_t size)
{
//    return (malloc(size,M_DEVBUF,M_DONTWAIT | M_ZERO));
    return A_ALLOCRAM(size);
  90a58b:	136915        	l32r	a3, 8e49e0 <mUsbEPinHighBandSet+0x40>
  90a58e:	d420      	mov.n	a4, a2
  90a590:	223252        	l32i	a2, a3, 0x148
  90a593:	c0a0      	movi.n	a10, 0
  90a595:	c3b8      	movi.n	a11, 56
  90a597:	0b2000        	callx8	a2
  90a59a:	d2a0      	mov.n	a2, a10
	WMI_SVC_CONTEXT *pWMI = NULL;
	int eventSize = WMI_SVC_MAX_BUFFERED_EVENT_SIZE + sizeof(WMI_CMD_HDR) + HTC_HDR_SZ;
    
	pWMI = (WMI_SVC_CONTEXT *)adf_os_mem_alloc(sizeof(WMI_SVC_CONTEXT));
	if (pWMI == NULL) {
  90a59c:	64a055        	beqz	a10, 90a5f5 <_WMI_Init+0x6d>
		return NULL;    
	}
        
	pWMI->pDispatchHead = NULL;
  90a59f:	c080      	movi.n	a8, 0
  90a5a1:	98ab      	s32i.n	a8, a10, 44
	pWMI->PoolHandle = pWmiConfig->PoolHandle;
	pWMI->HtcHandle = pWmiConfig->HtcHandle;    
  90a5a3:	8840      	l32i.n	a8, a4, 0
	if (pWMI == NULL) {
		return NULL;    
	}
        
	pWMI->pDispatchHead = NULL;
	pWMI->PoolHandle = pWmiConfig->PoolHandle;
  90a5a5:	8a41      	l32i.n	a10, a4, 4
	pWMI->HtcHandle = pWmiConfig->HtcHandle;    
                                         
	BUF_Pool_create_pool(pWmiConfig->PoolHandle, POOL_ID_WMI_SVC_CMD_REPLY, 
  90a5a7:	8c42      	l32i.n	a12, a4, 8
		return NULL;    
	}
        
	pWMI->pDispatchHead = NULL;
	pWMI->PoolHandle = pWmiConfig->PoolHandle;
	pWMI->HtcHandle = pWmiConfig->HtcHandle;    
  90a5a9:	9820      	s32i.n	a8, a2, 0
                                         
	BUF_Pool_create_pool(pWmiConfig->PoolHandle, POOL_ID_WMI_SVC_CMD_REPLY, 
  90a5ab:	28329b        	l32i	a8, a3, 0x26c
	if (pWMI == NULL) {
		return NULL;    
	}
        
	pWMI->pDispatchHead = NULL;
	pWMI->PoolHandle = pWmiConfig->PoolHandle;
  90a5ae:	9a21      	s32i.n	a10, a2, 4
	pWMI->HtcHandle = pWmiConfig->HtcHandle;    
                                         
	BUF_Pool_create_pool(pWmiConfig->PoolHandle, POOL_ID_WMI_SVC_CMD_REPLY, 
  90a5b0:	2b0a01        	movi	a11, 1
  90a5b3:	2d0a70        	movi	a13, 112
  90a5b6:	0b8000        	callx8	a8
			     pWmiConfig->MaxCmdReplyEvts, eventSize);
        
	BUF_Pool_create_pool(pWmiConfig->PoolHandle, POOL_ID_WMI_SVC_EVENT, 
  90a5b9:	28329b        	l32i	a8, a3, 0x26c
  90a5bc:	8a41      	l32i.n	a10, a4, 4
  90a5be:	8c43      	l32i.n	a12, a4, 12
  90a5c0:	c0b2      	movi.n	a11, 2
  90a5c2:	2d0a70        	movi	a13, 112
  90a5c5:	0b8000        	callx8	a8
            
	/* NOTE: since RAM allocation is zero-initialized, there is nothing to do for the 
	 * direct event pool */
     
        /* register the WMI control service */
	pWMI->WMIControlService.ProcessRecvMsg = A_INDIR(wmi_svc_api._WMI_RecvMessageHandler);
  90a5c8:	283293        	l32i	a8, a3, 0x24c
         * in size.  Any WMI event that supplies a data buffer must insure that the space in the buffer
         * is at least this size. */
	pWMI->WMIControlService.TrailerSpcCheckLimit = WMI_SVC_MAX_BUFFERED_EVENT_SIZE; 
	pWMI->WMIControlService.ServiceID = WMI_CONTROL_SVC;
	pWMI->WMIControlService.ServiceCtx = pWMI;
	HTC_RegisterService(pWmiConfig->HtcHandle, &pWMI->WMIControlService);
  90a5cb:	8a40      	l32i.n	a10, a4, 0
            
	/* NOTE: since RAM allocation is zero-initialized, there is nothing to do for the 
	 * direct event pool */
     
        /* register the WMI control service */
	pWMI->WMIControlService.ProcessRecvMsg = A_INDIR(wmi_svc_api._WMI_RecvMessageHandler);
  90a5cd:	9824      	s32i.n	a8, a2, 16
	pWMI->WMIControlService.ProcessSendBufferComplete = A_INDIR(wmi_svc_api._WMI_SendCompleteHandler);
  90a5cf:	283290        	l32i	a8, a3, 0x240
         * in size.  Any WMI event that supplies a data buffer must insure that the space in the buffer
         * is at least this size. */
	pWMI->WMIControlService.TrailerSpcCheckLimit = WMI_SVC_MAX_BUFFERED_EVENT_SIZE; 
	pWMI->WMIControlService.ServiceID = WMI_CONTROL_SVC;
	pWMI->WMIControlService.ServiceCtx = pWMI;
	HTC_RegisterService(pWmiConfig->HtcHandle, &pWMI->WMIControlService);
  90a5d2:	bc2b      	addi.n	a11, a2, 12
	/* NOTE: since RAM allocation is zero-initialized, there is nothing to do for the 
	 * direct event pool */
     
        /* register the WMI control service */
	pWMI->WMIControlService.ProcessRecvMsg = A_INDIR(wmi_svc_api._WMI_RecvMessageHandler);
	pWMI->WMIControlService.ProcessSendBufferComplete = A_INDIR(wmi_svc_api._WMI_SendCompleteHandler);
  90a5d4:	9825      	s32i.n	a8, a2, 20
	pWMI->WMIControlService.ProcessConnect = A_INDIR(wmi_svc_api._WMI_ServiceConnect);
  90a5d6:	283294        	l32i	a8, a3, 0x250
         * in size.  Any WMI event that supplies a data buffer must insure that the space in the buffer
         * is at least this size. */
	pWMI->WMIControlService.TrailerSpcCheckLimit = WMI_SVC_MAX_BUFFERED_EVENT_SIZE; 
	pWMI->WMIControlService.ServiceID = WMI_CONTROL_SVC;
	pWMI->WMIControlService.ServiceCtx = pWMI;
	HTC_RegisterService(pWmiConfig->HtcHandle, &pWMI->WMIControlService);
  90a5d9:	233280        	l32i	a3, a3, 0x200
	 * direct event pool */
     
        /* register the WMI control service */
	pWMI->WMIControlService.ProcessRecvMsg = A_INDIR(wmi_svc_api._WMI_RecvMessageHandler);
	pWMI->WMIControlService.ProcessSendBufferComplete = A_INDIR(wmi_svc_api._WMI_SendCompleteHandler);
	pWMI->WMIControlService.ProcessConnect = A_INDIR(wmi_svc_api._WMI_ServiceConnect);
  90a5dc:	9826      	s32i.n	a8, a2, 24
	pWMI->WMIControlService.MaxSvcMsgSize = WMI_SVC_MSG_SIZE + sizeof(WMI_CMD_HDR);
  90a5de:	286a04        	movi	a8, 0x604
  90a5e1:	282510        	s16i	a8, a2, 32
        /* all buffers that are sent through the control endpoint are at least WMI_SVC_MAX_BUFFERED_EVENT_SIZE 
         * in size.  Any WMI event that supplies a data buffer must insure that the space in the buffer
         * is at least this size. */
	pWMI->WMIControlService.TrailerSpcCheckLimit = WMI_SVC_MAX_BUFFERED_EVENT_SIZE; 
  90a5e4:	280a64        	movi	a8, 100
  90a5e7:	282511        	s16i	a8, a2, 34
	pWMI->WMIControlService.ServiceID = WMI_CONTROL_SVC;
  90a5ea:	281a00        	movi	a8, 0x100
  90a5ed:	28250e        	s16i	a8, a2, 28
	pWMI->WMIControlService.ServiceCtx = pWMI;
  90a5f0:	9229      	s32i.n	a2, a2, 36
	HTC_RegisterService(pWmiConfig->HtcHandle, &pWMI->WMIControlService);
  90a5f2:	0b3000        	callx8	a3
    
	return pWMI;
}
  90a5f5:	d10f      	retw.n
	...

0090a5f8 <WMI_service_module_install>:

	adf_os_mem_free(pWMI);
}

void WMI_service_module_install(WMI_SVC_APIS *pTbl)
{
  90a5f8:	6c1004        	entry	a1, 32
	pTbl->_WMI_Init                     = _WMI_Init;
  90a5fb:	186a54        	l32r	a8, 8e4f4c <mUsbEPinHighBandSet+0x5ac>
  90a5fe:	9820      	s32i.n	a8, a2, 0
	pTbl->_WMI_RegisterDispatchTable    = _WMI_RegisterDispatchTable;
  90a600:	186a55        	l32r	a8, 8e4f54 <mUsbEPinHighBandSet+0x5b4>
  90a603:	9821      	s32i.n	a8, a2, 4
	pTbl->_WMI_AllocEvent               = _WMI_AllocEvent;
  90a605:	186a56        	l32r	a8, 8e4f60 <vbuf_module_install>
  90a608:	9822      	s32i.n	a8, a2, 8
	pTbl->_WMI_SendEvent                = _WMI_SendEvent;
  90a60a:	186a57        	l32r	a8, 8e4f68 <vbuf_module_install+0x8>
  90a60d:	9823      	s32i.n	a8, a2, 12
	pTbl->_WMI_SendCompleteHandler      = _WMI_SendCompleteHandler;
  90a60f:	186a58        	l32r	a8, 8e4f70 <vbuf_module_install+0x10>
  90a612:	9825      	s32i.n	a8, a2, 20
	pTbl->_WMI_GetPendingEventsCount    = _WMI_GetPendingEventsCount;
  90a614:	186a59        	l32r	a8, 8e4f78 <vbuf_module_install+0x18>
  90a617:	9824      	s32i.n	a8, a2, 16
	pTbl->_WMI_GetControlEp             = _WMI_GetControlEp;
  90a619:	186a5a        	l32r	a8, 8e4f84 <vbuf_module_install+0x24>
  90a61c:	9826      	s32i.n	a8, a2, 24
	pTbl->_WMI_Shutdown                 = _WMI_Shutdown;
  90a61e:	186a5b        	l32r	a8, 8e4f8c <vbuf_module_install+0x2c>
  90a621:	9827      	s32i.n	a8, a2, 28
	pTbl->_WMI_RecvMessageHandler       = WMIRecvMessageHandler;
  90a623:	186a5c        	l32r	a8, 8e4f94 <vbuf_module_install+0x34>
  90a626:	9828      	s32i.n	a8, a2, 32
	pTbl->_WMI_ServiceConnect           = WMIServiceConnect;
  90a628:	186a5d        	l32r	a8, 8e4f9c <vbuf_module_install+0x3c>
  90a62b:	9829      	s32i.n	a8, a2, 36
  90a62d:	d10f      	retw.n
	...

0090a630 <io32_rmw>:
	iowrite8(addr, val);
}

static inline void io32_rmw(volatile uint32_t addr,
			    const uint32_t set, const uint32_t clr)
{
  90a630:	6c1006        	entry	a1, 48
  90a633:	0c0200        	memw
  90a636:	9210      	s32i.n	a2, a1, 0
	uint32_t val;

	val = ioread32(addr);
  90a638:	0c0200        	memw
  90a63b:	8810      	l32i.n	a8, a1, 0
	val &= ~clr;
  90a63d:	c79f      	movi.n	a9, -1
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90a63f:	0c0200        	memw
  90a642:	8880      	l32i.n	a8, a8, 0
			    const uint32_t set, const uint32_t clr)
{
	uint32_t val;

	val = ioread32(addr);
	val &= ~clr;
  90a644:	049403        	xor	a4, a9, a4
  90a647:	084801        	and	a8, a4, a8
	val |= set;
	iowrite32(addr, val);
  90a64a:	0c0200        	memw
  90a64d:	8a10      	l32i.n	a10, a1, 0
{
	uint32_t val;

	val = ioread32(addr);
	val &= ~clr;
	val |= set;
  90a64f:	038302        	or	a3, a8, a3
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90a652:	0c0200        	memw
  90a655:	93a0      	s32i.n	a3, a10, 0
  90a657:	d10f      	retw.n
  90a659:	000000        	ill

0090a65c <_fw_restore_dma_fifo>:
	/* deassert eth_pll bypass mode and trigger update bit */
	io32_clr(MAGPIE_REG_ETH_PLL_BYPASS_ADDR, BIT4 | BIT0);
}

static void _fw_restore_dma_fifo(void)
{
  90a65c:	6c1004        	entry	a1, 32
	io32_clr(0x5601C, BIT18);
  90a65f:	1a6a5e        	l32r	a10, 8e4fd8 <vbuf_module_install+0x78>
  90a662:	1c6a23        	l32r	a12, 8e4ef0 <mUsbEPinHighBandSet+0x550>
  90a665:	c0b0      	movi.n	a11, 0
  90a667:	5bfff2        	call8	90a630 <io32_rmw>
    
	/* reset pcie_rc shift */
	io32_clr(0x50010, BIT10 | BIT8 | BIT7);
  90a66a:	126943        	l32r	a2, 8e4b78 <mUsbEPinHighBandSet+0x1d8>
  90a66d:	2b0a00        	movi	a11, 0
  90a670:	022a02        	or	a10, a2, a2
  90a673:	2c5a80        	movi	a12, 0x580
  90a676:	5bffee        	call8	90a630 <io32_rmw>
	A_DELAY_USECS(1);
  90a679:	136915        	l32r	a3, 8e4ad0 <mUsbEPinHighBandSet+0x130>
  90a67c:	c0a1      	movi.n	a10, 1
  90a67e:	28323b        	l32i	a8, a3, 236
  90a681:	0b8000        	callx8	a8
	io32_set(0x50010, BIT10 | BIT8 | BIT7);
  90a684:	da20      	mov.n	a10, a2
  90a686:	2b5a80        	movi	a11, 0x580
  90a689:	c0c0      	movi.n	a12, 0
  90a68b:	5bffe9        	call8	90a630 <io32_rmw>

	/* reset pci_rc phy */
	io32_set(MAGPIE_REG_RST_RESET_ADDR,
  90a68e:	da20      	mov.n	a10, a2
  90a690:	2b5ac0        	movi	a11, 0x5c0
  90a693:	c0c0      	movi.n	a12, 0
  90a695:	5bffe6        	call8	90a630 <io32_rmw>
		 PCI_RC_PHY_SHIFT_RESET_BIT
		 | PCI_RC_PLL_RESET_BIT | PCI_RC_PHY_RESET_BIT
		 | PCI_RC_RESET_BIT);
	A_DELAY_USECS(20);
  90a698:	22323b        	l32i	a2, a3, 236
  90a69b:	c1a4      	movi.n	a10, 20
  90a69d:	0b2000        	callx8	a2

	// enable dma swap function
	MAGPIE_REG_USB_RX0_SWAP_DATA = 0x1;
  90a6a0:	126955        	l32r	a2, 8e4bf4 <mUsbEPinHighBandSet+0x254>
  90a6a3:	c081      	movi.n	a8, 1
  90a6a5:	0c0200        	memw
  90a6a8:	9820      	s32i.n	a8, a2, 0
	MAGPIE_REG_USB_TX0_SWAP_DATA = 0x1;
  90a6aa:	126956        	l32r	a2, 8e4c04 <mUsbEPinHighBandSet+0x264>
  90a6ad:	0c0200        	memw
  90a6b0:	9820      	s32i.n	a8, a2, 0
	MAGPIE_REG_USB_RX1_SWAP_DATA = 0x1;
  90a6b2:	126957        	l32r	a2, 8e4c10 <mUsbEPinHighBandSet+0x270>
  90a6b5:	0c0200        	memw
  90a6b8:	9820      	s32i.n	a8, a2, 0
	MAGPIE_REG_USB_RX2_SWAP_DATA = 0x1;
  90a6ba:	126958        	l32r	a2, 8e4c1c <mUsbEPinHighBandSet+0x27c>
  90a6bd:	0c0200        	memw
  90a6c0:	9820      	s32i.n	a8, a2, 0
  90a6c2:	d10f      	retw.n

0090a6c4 <_fw_reset_dma_fifo>:
	A_PRINTF("0x4088  0x%x ......\n", ioread32(0x10ff4088));
	_fw_reset_dma_fifo();
}

static void _fw_reset_dma_fifo()
{
  90a6c4:	6c1012        	entry	a1, 144
  90a6c7:	126a5f        	l32r	a2, 8e5044 <vdesc_module_install+0x34>
{
	uint8_t val;

	val = ioread8(addr);
	val &= ~clr;
	val |= set;
  90a6ca:	c130      	movi.n	a3, 16

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  90a6cc:	242000        	l8ui	a4, a2, 0
	io8_set(0x100ae, 0x10);
	io8_set(0x100af, 0x10);
	A_PRINTF("_fw_reset_dma_fifo\n");
  90a6cf:	1a6a61        	l32r	a10, 8e5054 <vdesc_module_install+0x44>
  90a6d2:	040447        	extui	a4, a4, 0, 8
{
	uint8_t val;

	val = ioread8(addr);
	val &= ~clr;
	val |= set;
  90a6d5:	034402        	or	a4, a4, a3
  90a6d8:	040447        	extui	a4, a4, 0, 8
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  90a6db:	0c0200        	memw
  90a6de:	242400        	s8i	a4, a2, 0
  90a6e1:	126a60        	l32r	a2, 8e5064 <vdesc_module_install+0x54>

	// disable ep3 int enable, so that resume back won't send wdt magic pattern out!!!
	mUSB_STATUS_IN_INT_DISABLE();
  90a6e4:	250ac0        	movi	a5, 192

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  90a6e7:	242000        	l8ui	a4, a2, 0
  90a6ea:	040447        	extui	a4, a4, 0, 8
{
	uint8_t val;

	val = ioread8(addr);
	val &= ~clr;
	val |= set;
  90a6ed:	034302        	or	a3, a4, a3
  90a6f0:	030347        	extui	a3, a3, 0, 8
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  90a6f3:	0c0200        	memw
  90a6f6:	232400        	s8i	a3, a2, 0

static void _fw_reset_dma_fifo()
{
	io8_set(0x100ae, 0x10);
	io8_set(0x100af, 0x10);
	A_PRINTF("_fw_reset_dma_fifo\n");
  90a6f9:	126915        	l32r	a2, 8e4b50 <mUsbEPinHighBandSet+0x1b0>
  90a6fc:	232212        	l32i	a3, a2, 72
  90a6ff:	0b3000        	callx8	a3

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  90a702:	13695c        	l32r	a3, 8e4c74 <mUsbEPinHighBandSet+0x2d4>
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90a705:	166a62        	l32r	a6, 8e5090 <vdesc_module_install+0x80>

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  90a708:	243000        	l8ui	a4, a3, 0
	mUSB_STATUS_IN_INT_DISABLE();

	/* update magic pattern to indicate this is a suspend */
	iowrite32(WATCH_DOG_MAGIC_PATTERN_ADDR, SUS_MAGIC_PATTERN);

	A_PRINTF("org 0x4048  0x%x ......\n", ioread32(0x10ff4048));
  90a70b:	1a6a63        	l32r	a10, 8e5098 <vdesc_module_install+0x88>
  90a70e:	040447        	extui	a4, a4, 0, 8
	io8_set(0x100ae, 0x10);
	io8_set(0x100af, 0x10);
	A_PRINTF("_fw_reset_dma_fifo\n");

	// disable ep3 int enable, so that resume back won't send wdt magic pattern out!!!
	mUSB_STATUS_IN_INT_DISABLE();
  90a711:	054402        	or	a4, a4, a5
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  90a714:	0c0200        	memw
  90a717:	243400        	s8i	a4, a3, 0
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90a71a:	14691e        	l32r	a4, 8e4b94 <mUsbEPinHighBandSet+0x1f4>
  90a71d:	136919        	l32r	a3, 8e4b84 <mUsbEPinHighBandSet+0x1e4>
  90a720:	0c0200        	memw
  90a723:	9430      	s32i.n	a4, a3, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90a725:	0c0200        	memw
  90a728:	8b60      	l32i.n	a11, a6, 0

	/* update magic pattern to indicate this is a suspend */
	iowrite32(WATCH_DOG_MAGIC_PATTERN_ADDR, SUS_MAGIC_PATTERN);

	A_PRINTF("org 0x4048  0x%x ......\n", ioread32(0x10ff4048));
  90a72a:	232212        	l32i	a3, a2, 72
  90a72d:	0b3000        	callx8	a3
  90a730:	156a64        	l32r	a5, 8e50c0 <vdesc_module_install+0xb0>
	A_PRINTF("org 0x404C  0x%x ......\n", ioread32(0x10ff404C));
  90a733:	232212        	l32i	a3, a2, 72
  90a736:	0c0200        	memw
  90a739:	8b50      	l32i.n	a11, a5, 0
  90a73b:	1a6a65        	l32r	a10, 8e50d0 <vdesc_module_install+0xc0>
  90a73e:	0b3000        	callx8	a3
  90a741:	146a66        	l32r	a4, 8e50dc <vdesc_module_install+0xcc>
	A_PRINTF("org 0x4088  0x%x ......\n", ioread32(0x10ff4088));
  90a744:	232212        	l32i	a3, a2, 72
  90a747:	0c0200        	memw
  90a74a:	8b40      	l32i.n	a11, a4, 0
  90a74c:	1a6a67        	l32r	a10, 8e50e8 <vdesc_module_install+0xd8>
  90a74f:	0b3000        	callx8	a3
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90a752:	136a68        	l32r	a3, 8e50f4 <vdesc_module_install+0xe4>

	/* 1010.1010.1010.0110.1010 for UB94 */
	iowrite32(0x10ff4088, 0xaaa6a);
	iowrite32(0x10ff404C, 0x0);

	A_DELAY_USECS(1000);
  90a755:	28223b        	l32i	a8, a2, 236
  90a758:	0c0200        	memw
  90a75b:	234600        	s32i	a3, a4, 0
  90a75e:	230a00        	movi	a3, 0
  90a761:	0c0200        	memw
  90a764:	235600        	s32i	a3, a5, 0
  90a767:	2a3ae8        	movi	a10, 0x3e8
  90a76a:	0b8000        	callx8	a8
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90a76d:	0c0200        	memw
  90a770:	2b6200        	l32i	a11, a6, 0
	A_PRINTF("0x4048  0x%x ......\n", ioread32(0x10ff4048));
  90a773:	1a6a69        	l32r	a10, 8e5118 <vdesc_module_install+0x108>
  90a776:	262212        	l32i	a6, a2, 72
  90a779:	0b6000        	callx8	a6
  90a77c:	0c0200        	memw
  90a77f:	8b50      	l32i.n	a11, a5, 0
	A_PRINTF("0x404C  0x%x ......\n", ioread32(0x10ff404C));
  90a781:	1a6a6a        	l32r	a10, 8e512c <vdesc_module_install+0x11c>
  90a784:	252212        	l32i	a5, a2, 72
  90a787:	0b5000        	callx8	a5
  90a78a:	0c0200        	memw
  90a78d:	8b40      	l32i.n	a11, a4, 0
	A_PRINTF("0x4088  0x%x ......\n", ioread32(0x10ff4088));
  90a78f:	1a6a6b        	l32r	a10, 8e513c <vdesc_module_install+0x12c>
  90a792:	242212        	l32i	a4, a2, 72
  90a795:	0b4000        	callx8	a4
	volatile uint32_t default_data[9];
	uint32_t i=0;

	if(1)
	{
		A_PRINTF("turn_off_merlin_ep_start ......\n");
  90a798:	1a6a6c        	l32r	a10, 8e5148 <vdesc_module_install+0x138>
  90a79b:	242212        	l32i	a4, a2, 72
  90a79e:	0b4000        	callx8	a4
		A_DELAY_USECS(measure_time);
  90a7a1:	24223b        	l32i	a4, a2, 236
  90a7a4:	da30      	mov.n	a10, a3
  90a7a6:	0b4000        	callx8	a4
		default_data[0] = 0x9248fd00;
  90a7a9:	146a6d        	l32r	a4, 8e5160 <vdesc_module_install+0x150>
  90a7ac:	0c0200        	memw
  90a7af:	241612        	s32i	a4, a1, 72
		default_data[1] = 0x24924924;
  90a7b2:	146a6e        	l32r	a4, 8e516c <vdesc_module_install+0x15c>
  90a7b5:	0c0200        	memw
  90a7b8:	241613        	s32i	a4, a1, 76
		default_data[2] = 0xa8000019;
  90a7bb:	146a6f        	l32r	a4, 8e5178 <vdesc_module_install+0x168>
  90a7be:	0c0200        	memw
  90a7c1:	241614        	s32i	a4, a1, 80
		default_data[3] = 0x17160820;
  90a7c4:	146a70        	l32r	a4, 8e5184 <vdesc_module_install+0x174>
  90a7c7:	0c0200        	memw
  90a7ca:	241615        	s32i	a4, a1, 84
		default_data[4] = 0x25980560;
  90a7cd:	146a71        	l32r	a4, 8e5194 <vdesc_module_install+0x184>
  90a7d0:	0c0200        	memw
  90a7d3:	241616        	s32i	a4, a1, 88
		default_data[5] = 0xc1c00000;
  90a7d6:	146a72        	l32r	a4, 8e51a0 <vdesc_module_install+0x190>
  90a7d9:	0c0200        	memw
  90a7dc:	241617        	s32i	a4, a1, 92
		default_data[6] = 0x1aaabe40;
  90a7df:	146a73        	l32r	a4, 8e51ac <vdesc_module_install+0x19c>
  90a7e2:	0c0200        	memw
  90a7e5:	241618        	s32i	a4, a1, 96
		default_data[7] = 0xbe105554;
  90a7e8:	146a74        	l32r	a4, 8e51b8 <vdesc_module_install+0x1a8>
  90a7eb:	0c0200        	memw
  90a7ee:	241619        	s32i	a4, a1, 100
		default_data[8] = 0x00043007;
  90a7f1:	146a75        	l32r	a4, 8e51c8 <vdesc_module_install+0x1b8>
  90a7f4:	0c0200        	memw
  90a7f7:	24161a        	s32i	a4, a1, 104
        
		for(i=0; i<9; i++)
		{
			A_DELAY_USECS(10);
  90a7fa:	24223b        	l32i	a4, a2, 236
  90a7fd:	c0aa      	movi.n	a10, 10
  90a7ff:	0b4000        	callx8	a4
        
			iowrite32(0x10ff4040, default_data[i]);
  90a802:	01340a        	addx4	a4, a3, a1
  90a805:	0c0200        	memw
  90a808:	254212        	l32i	a5, a4, 72
  90a80b:	146a76        	l32r	a4, 8e51e4 <vdesc_module_install+0x1d4>
		default_data[5] = 0xc1c00000;
		default_data[6] = 0x1aaabe40;
		default_data[7] = 0xbe105554;
		default_data[8] = 0x00043007;
        
		for(i=0; i<9; i++)
  90a80e:	b133      	addi.n	a3, a3, 1
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90a810:	0c0200        	memw
  90a813:	254600        	s32i	a5, a4, 0
  90a816:	240a09        	movi	a4, 9
  90a819:	7439dd        	bne	a3, a4, 90a7fa <_fw_reset_dma_fifo+0x136>
		{
			A_DELAY_USECS(10);
        
			iowrite32(0x10ff4040, default_data[i]);
		}
		A_DELAY_USECS(10);
  90a81c:	23223b        	l32i	a3, a2, 236
  90a81f:	2a0a0a        	movi	a10, 10
  90a822:	0b3000        	callx8	a3
  90a825:	136a77        	l32r	a3, 8e5204 <vdesc_module_install+0x1f4>
  90a828:	c041      	movi.n	a4, 1
  90a82a:	0c0200        	memw
  90a82d:	9430      	s32i.n	a4, a3, 0
		iowrite32(0x10ff4044, BIT0);
		A_PRINTF("turn_off_merlin_ep_end ......\n");
  90a82f:	1a6a78        	l32r	a10, 8e5210 <vdesc_module_install+0x200>
  90a832:	232212        	l32i	a3, a2, 72
  90a835:	0b3000        	callx8	a3
	A_PRINTF("0x4088  0x%x ......\n", ioread32(0x10ff4088));
         
	// turn off merlin
	turn_off_merlin();
	// pcie ep
	A_PRINTF("turn_off_magpie_ep_start ......\n");
  90a838:	1a6a79        	l32r	a10, 8e521c <vdesc_module_install+0x20c>
  90a83b:	232212        	l32i	a3, a2, 72
  90a83e:	0b3000        	callx8	a3
	A_DELAY_USECS(measure_time);
  90a841:	22223b        	l32i	a2, a2, 236
  90a844:	c0a0      	movi.n	a10, 0
  90a846:	0b2000        	callx8	a2
	io32_set(0x40040, BIT0 | BIT1);
  90a849:	1a6a7a        	l32r	a10, 8e5234 <vdesc_module_install+0x224>
  90a84c:	c0b3      	movi.n	a11, 3
  90a84e:	2c0a00        	movi	a12, 0
  90a851:	5bff77        	call8	90a630 <io32_rmw>
{

	volatile uint32_t default_data[9];
	uint32_t i=0;

	default_data[0] = 0x9248fd00;
  90a854:	126a6d        	l32r	a2, 8e5208 <vdesc_module_install+0x1f8>
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90a857:	146a7b        	l32r	a4, 8e5244 <vdesc_module_install+0x234>
  90a85a:	0c0200        	memw
  90a85d:	9219      	s32i.n	a2, a1, 36
	default_data[1] = 0x24924924;
  90a85f:	126a6e        	l32r	a2, 8e5218 <vdesc_module_install+0x208>
	default_data[5] = 0xc1c00000;
	default_data[6] = 0x1aaabe40;
	default_data[7] = 0xbe105554;
	default_data[8] = 0x00043007;

	for(i=0; i<9; i++)
  90a862:	c030      	movi.n	a3, 0

	volatile uint32_t default_data[9];
	uint32_t i=0;

	default_data[0] = 0x9248fd00;
	default_data[1] = 0x24924924;
  90a864:	0c0200        	memw
  90a867:	921a      	s32i.n	a2, a1, 40
	default_data[2] = 0xa8000019;
  90a869:	126a6f        	l32r	a2, 8e5228 <vdesc_module_install+0x218>
  90a86c:	0c0200        	memw
  90a86f:	921b      	s32i.n	a2, a1, 44
	default_data[3] = 0x17160820;
  90a871:	126a70        	l32r	a2, 8e5234 <vdesc_module_install+0x224>
  90a874:	0c0200        	memw
  90a877:	921c      	s32i.n	a2, a1, 48
	default_data[4] = 0x25980560;
  90a879:	126a71        	l32r	a2, 8e5240 <vdesc_module_install+0x230>
  90a87c:	0c0200        	memw
  90a87f:	921d      	s32i.n	a2, a1, 52
	default_data[5] = 0xc1c00000;
  90a881:	126a72        	l32r	a2, 8e524c <vdesc_module_install+0x23c>
  90a884:	0c0200        	memw
  90a887:	22160e        	s32i	a2, a1, 56
	default_data[6] = 0x1aaabe40;
  90a88a:	126a73        	l32r	a2, 8e5258 <vdesc_module_install+0x248>
  90a88d:	0c0200        	memw
  90a890:	22160f        	s32i	a2, a1, 60
	default_data[7] = 0xbe105554;
  90a893:	126a74        	l32r	a2, 8e5264 <vdesc_module_install+0x254>
  90a896:	0c0200        	memw
  90a899:	221610        	s32i	a2, a1, 64
	default_data[8] = 0x00043007;
  90a89c:	126a75        	l32r	a2, 8e5270 <vdesc_module_install+0x260>
  90a89f:	0c0200        	memw
  90a8a2:	221611        	s32i	a2, a1, 68
  90a8a5:	0c0200        	memw
  90a8a8:	8240      	l32i.n	a2, a4, 0
	{
		// check for the done bit to be set 

		while (1)
		{
			if (ioread32(0x40028) & BIT31)
  90a8aa:	672ff7        	bgez	a2, 90a8a5 <_fw_reset_dma_fifo+0x1e1>
				break;
		}
        
		A_DELAY_USECS(1);
  90a8ad:	126915        	l32r	a2, 8e4d04 <mUsbEPinHighBandSet+0x364>
  90a8b0:	c0a1      	movi.n	a10, 1
  90a8b2:	25223b        	l32i	a5, a2, 236
  90a8b5:	0b5000        	callx8	a5
    
		iowrite32(0x40024, default_data[i]);
  90a8b8:	01350a        	addx4	a5, a3, a1
  90a8bb:	0c0200        	memw
  90a8be:	8659      	l32i.n	a6, a5, 36
  90a8c0:	156a7c        	l32r	a5, 8e52b0 <vdesc_module_install+0x2a0>
	default_data[5] = 0xc1c00000;
	default_data[6] = 0x1aaabe40;
	default_data[7] = 0xbe105554;
	default_data[8] = 0x00043007;

	for(i=0; i<9; i++)
  90a8c3:	b133      	addi.n	a3, a3, 1
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90a8c5:	0c0200        	memw
  90a8c8:	9650      	s32i.n	a6, a5, 0
  90a8ca:	c059      	movi.n	a5, 9
  90a8cc:	7539d5        	bne	a3, a5, 90a8a5 <_fw_reset_dma_fifo+0x1e1>
	// pcie ep
	A_PRINTF("turn_off_magpie_ep_start ......\n");
	A_DELAY_USECS(measure_time);
	io32_set(0x40040, BIT0 | BIT1);
	turn_off_phy();
	io32_clr(0x40040, BIT0 | BIT1);
  90a8cf:	136a7a        	l32r	a3, 8e52b8 <vdesc_module_install+0x2a8>
  90a8d2:	c051      	movi.n	a5, 1
  90a8d4:	c0b0      	movi.n	a11, 0
  90a8d6:	2c0a03        	movi	a12, 3
  90a8d9:	033a02        	or	a10, a3, a3
  90a8dc:	0c0200        	memw
  90a8df:	9540      	s32i.n	a5, a4, 0
  90a8e1:	5bff53        	call8	90a630 <io32_rmw>
	A_PRINTF("turn_off_magpie_ep_end ......\n");
  90a8e4:	1a6a7d        	l32r	a10, 8e52d8 <vdesc_module_install+0x2c8>
  90a8e7:	262212        	l32i	a6, a2, 72
  90a8ea:	0b6000        	callx8	a6

	// pcie rc 
	A_PRINTF("turn_off_magpie_rc_start ......\n");
  90a8ed:	1a6a7e        	l32r	a10, 8e52e8 <vdesc_module_install+0x2d8>
  90a8f0:	262212        	l32i	a6, a2, 72
  90a8f3:	0b6000        	callx8	a6
	A_DELAY_USECS(measure_time);
  90a8f6:	26223b        	l32i	a6, a2, 236
  90a8f9:	c0a0      	movi.n	a10, 0
  90a8fb:	0b6000        	callx8	a6
	io32_clr(0x40040, BIT0);
  90a8fe:	da30      	mov.n	a10, a3
  90a900:	2b0a00        	movi	a11, 0
  90a903:	055c02        	or	a12, a5, a5
  90a906:	5bff4a        	call8	90a630 <io32_rmw>
{
    
	volatile uint32_t default_data[9];
	uint32_t i=0;
    
	A_PRINTF("turn_off_phy_rc\n");
  90a909:	1a6a7f        	l32r	a10, 8e5308 <vdesc_module_install+0x2f8>
  90a90c:	222212        	l32i	a2, a2, 72
	default_data[5] = 0xc1c00000;
	default_data[6] = 0x1aaabe40;
	default_data[7] = 0xbe105554;
	default_data[8] = 0x00043007;
        
	for(i=0; i<9; i++)
  90a90f:	230a00        	movi	a3, 0
{
    
	volatile uint32_t default_data[9];
	uint32_t i=0;
    
	A_PRINTF("turn_off_phy_rc\n");
  90a912:	0b2000        	callx8	a2
    
	default_data[0] = 0x9248fd00;
  90a915:	126a6d        	l32r	a2, 8e52cc <vdesc_module_install+0x2bc>
  90a918:	0c0200        	memw
  90a91b:	9210      	s32i.n	a2, a1, 0
	default_data[1] = 0x24924924;
  90a91d:	126a6e        	l32r	a2, 8e52d8 <vdesc_module_install+0x2c8>
  90a920:	0c0200        	memw
  90a923:	9211      	s32i.n	a2, a1, 4
	default_data[2] = 0xa8000019;
  90a925:	126a6f        	l32r	a2, 8e52e4 <vdesc_module_install+0x2d4>
  90a928:	0c0200        	memw
  90a92b:	9212      	s32i.n	a2, a1, 8
	default_data[3] = 0x13160820;//PwdClk1MHz=0
  90a92d:	126a80        	l32r	a2, 8e5330 <vdesc_module_install+0x320>
  90a930:	0c0200        	memw
  90a933:	9213      	s32i.n	a2, a1, 12
	default_data[4] = 0x25980560;
  90a935:	126a71        	l32r	a2, 8e52fc <vdesc_module_install+0x2ec>
  90a938:	0c0200        	memw
  90a93b:	9214      	s32i.n	a2, a1, 16
	default_data[5] = 0xc1c00000;
  90a93d:	126a72        	l32r	a2, 8e5308 <vdesc_module_install+0x2f8>
  90a940:	0c0200        	memw
  90a943:	9215      	s32i.n	a2, a1, 20
	default_data[6] = 0x1aaabe40;
  90a945:	126a73        	l32r	a2, 8e5314 <vdesc_module_install+0x304>
  90a948:	0c0200        	memw
  90a94b:	9216      	s32i.n	a2, a1, 24
	default_data[7] = 0xbe105554;
  90a94d:	126a74        	l32r	a2, 8e5320 <vdesc_module_install+0x310>
  90a950:	0c0200        	memw
  90a953:	9217      	s32i.n	a2, a1, 28
	default_data[8] = 0x00043007;
  90a955:	126a75        	l32r	a2, 8e532c <vdesc_module_install+0x31c>
  90a958:	0c0200        	memw
  90a95b:	9218      	s32i.n	a2, a1, 32
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90a95d:	0c0200        	memw
  90a960:	8240      	l32i.n	a2, a4, 0
	{
		// check for the done bit to be set 
     
		while (1)
		{
			if (ioread32(0x40028) & BIT31)
  90a962:	672ff7        	bgez	a2, 90a95d <_fw_reset_dma_fifo+0x299>
				break;
		}

		A_DELAY_USECS(1);
  90a965:	126915        	l32r	a2, 8e4dbc <mUsbEPinHighBandSet+0x41c>
  90a968:	2a0a01        	movi	a10, 1
  90a96b:	25223b        	l32i	a5, a2, 236
  90a96e:	0b5000        	callx8	a5

		iowrite32(0x40024, default_data[i]);
  90a971:	01350a        	addx4	a5, a3, a1
  90a974:	0c0200        	memw
  90a977:	8650      	l32i.n	a6, a5, 0
  90a979:	156a7c        	l32r	a5, 8e536c <vdesc_module_install+0x35c>
	default_data[5] = 0xc1c00000;
	default_data[6] = 0x1aaabe40;
	default_data[7] = 0xbe105554;
	default_data[8] = 0x00043007;
        
	for(i=0; i<9; i++)
  90a97c:	b133      	addi.n	a3, a3, 1
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90a97e:	0c0200        	memw
  90a981:	9650      	s32i.n	a6, a5, 0
  90a983:	c059      	movi.n	a5, 9
  90a985:	7539d4        	bne	a3, a5, 90a95d <_fw_reset_dma_fifo+0x299>
	// pcie rc 
	A_PRINTF("turn_off_magpie_rc_start ......\n");
	A_DELAY_USECS(measure_time);
	io32_clr(0x40040, BIT0);
	turn_off_phy_rc();
	A_PRINTF("turn_off_magpie_rc_end ......down\n");
  90a988:	232212        	l32i	a3, a2, 72
  90a98b:	c061      	movi.n	a6, 1
  90a98d:	1a6a81        	l32r	a10, 8e5394 <vdesc_module_install+0x384>
  90a990:	0c0200        	memw
  90a993:	9640      	s32i.n	a6, a4, 0
  90a995:	0b3000        	callx8	a3
	A_DELAY_USECS(measure_time);
  90a998:	23223b        	l32i	a3, a2, 236
  90a99b:	c0a0      	movi.n	a10, 0
  90a99d:	0b3000        	callx8	a3
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90a9a0:	136a82        	l32r	a3, 8e53a8 <vdesc_module_install+0x398>

	A_PRINTF("0x4001C  %p ......\n", ioread32(0x4001c));
  90a9a3:	1a6a83        	l32r	a10, 8e53b0 <vdesc_module_install+0x3a0>
  90a9a6:	0c0200        	memw
  90a9a9:	8b30      	l32i.n	a11, a3, 0
  90a9ab:	232212        	l32i	a3, a2, 72
  90a9ae:	0b3000        	callx8	a3
  90a9b1:	136a7a        	l32r	a3, 8e539c <vdesc_module_install+0x38c>
	A_PRINTF("0x40040  %p ......\n", ioread32(0x40040));
  90a9b4:	1a6a84        	l32r	a10, 8e53c4 <vdesc_module_install+0x3b4>
  90a9b7:	0c0200        	memw
  90a9ba:	8b30      	l32i.n	a11, a3, 0
  90a9bc:	232212        	l32i	a3, a2, 72
  90a9bf:	0b3000        	callx8	a3
  90a9c2:	136a5e        	l32r	a3, 8e533c <vdesc_module_install+0x32c>
    
	/* turn off pcie_pll - power down (bit16) */
	A_PRINTF(" before pwd PCIE PLL CFG:0x5601C: 0x%08x\n",
  90a9c5:	242212        	l32i	a4, a2, 72
  90a9c8:	0c0200        	memw
  90a9cb:	2b3200        	l32i	a11, a3, 0
  90a9ce:	1a6a85        	l32r	a10, 8e53e4 <vdesc_module_install+0x3d4>
  90a9d1:	0b4000        	callx8	a4
		 ioread32(0x5601C));
	io32_set(0x5601C, BIT18);
  90a9d4:	1b6a23        	l32r	a11, 8e5260 <vdesc_module_install+0x250>
  90a9d7:	033a02        	or	a10, a3, a3
  90a9da:	2c0a00        	movi	a12, 0
  90a9dd:	5bff14        	call8	90a630 <io32_rmw>
  90a9e0:	0c0200        	memw
  90a9e3:	8b30      	l32i.n	a11, a3, 0
	A_PRINTF(" after pwd PCIE PLL CFG:0x5601C:  0x%08x\n",
  90a9e5:	1a6a86        	l32r	a10, 8e5400 <vdesc_module_install+0x3f0>
  90a9e8:	232212        	l32i	a3, a2, 72
  90a9eb:	0b3000        	callx8	a3
		 ioread32(0x5601C));

	/* set everything to reset state?, requested by Oligo */
	io32_set(0x50010, BIT13 | BIT12
  90a9ee:	146943        	l32r	a4, 8e4efc <mUsbEPinHighBandSet+0x55c>
  90a9f1:	1b6a87        	l32r	a11, 8e5410 <vdesc_module_install+0x400>
  90a9f4:	2c0a00        	movi	a12, 0
  90a9f7:	da40      	mov.n	a10, a4
  90a9f9:	5bff0d        	call8	90a630 <io32_rmw>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90a9fc:	156a88        	l32r	a5, 8e541c <vdesc_module_install+0x40c>
  90a9ff:	230a00        	movi	a3, 0
  90aa02:	0c0200        	memw
  90aa05:	9350      	s32i.n	a3, a5, 0
		 | BIT11 | BIT9 | BIT7 | BIT6);

	iowrite32(0x5C000, 0);

	A_DELAY_USECS(10);
  90aa07:	25223b        	l32i	a5, a2, 236
  90aa0a:	2a0a0a        	movi	a10, 10
  90aa0d:	0b5000        	callx8	a5
  90aa10:	156952        	l32r	a5, 8e4f58 <mUsbEPinHighBandSet+0x5b8>

	/* reset usb DMA controller */
	iowrite32_usb(ZM_SOC_USB_DMA_RESET_OFFSET, 0x0);

	io32_set(0x50010, BIT4);
  90aa13:	c1b0      	movi.n	a11, 16
  90aa15:	dc30      	mov.n	a12, a3
  90aa17:	da40      	mov.n	a10, a4
  90aa19:	0c0200        	memw
  90aa1c:	9350      	s32i.n	a3, a5, 0
  90aa1e:	5bff04        	call8	90a630 <io32_rmw>
	A_DELAY_USECS(5);
  90aa21:	22223b        	l32i	a2, a2, 236
  90aa24:	c0a5      	movi.n	a10, 5
  90aa26:	0b2000        	callx8	a2
	io32_clr(0x50010, BIT4);
  90aa29:	da40      	mov.n	a10, a4
  90aa2b:	033b02        	or	a11, a3, a3
  90aa2e:	2c0a10        	movi	a12, 16
  90aa31:	5bfeff        	call8	90a630 <io32_rmw>
  90aa34:	0c0200        	memw
  90aa37:	9650      	s32i.n	a6, a5, 0
  90aa39:	d10f      	retw.n
	...

0090aa3c <_fw_usb_suspend_reboot>:

BOOLEAN bEepromExist = TRUE;
BOOLEAN bJumptoFlash = FALSE;

void _fw_usb_suspend_reboot()
{
  90aa3c:	6c1004        	entry	a1, 32
	/* reset usb/wlan dma */
	_fw_reset_dma_fifo();
  90aa3f:	5bff21        	call8	90a6c4 <_fw_reset_dma_fifo>

	/* restore gpio setting and usb/wlan dma state */
	_fw_restore_dma_fifo();
  90aa42:	5bff06        	call8	90a65c <_fw_restore_dma_fifo>
  90aa45:	12694a        	l32r	a2, 8e4f70 <vbuf_module_install+0x10>
  90aa48:	c181      	movi.n	a8, 17
  90aa4a:	0c0200        	memw
  90aa4d:	282600        	s32i	a8, a2, 0

	/* set clock to bypass mode - 40Mhz from XTAL */
	iowrite32(MAGPIE_REG_CPU_PLL_BYPASS_ADDR, BIT0 | BIT4);

	A_DELAY_USECS(100); /* wait for stable */
  90aa50:	126915        	l32r	a2, 8e4ea4 <mUsbEPinHighBandSet+0x504>
  90aa53:	2a0a64        	movi	a10, 100
  90aa56:	28223b        	l32i	a8, a2, 236
  90aa59:	0b8000        	callx8	a8
  90aa5c:	196953        	l32r	a9, 8e4fa8 <vbuf_module_install+0x48>
  90aa5f:	18694b        	l32r	a8, 8e4f8c <vbuf_module_install+0x2c>

	iowrite32(MAGPIE_REG_CPU_PLL_ADDR, BIT16);

	A_DELAY_USECS(100); /* wait for stable */
  90aa62:	2a0a64        	movi	a10, 100
  90aa65:	0c0200        	memw
  90aa68:	9980      	s32i.n	a9, a8, 0
  90aa6a:	28223b        	l32i	a8, a2, 236
  90aa6d:	0b8000        	callx8	a8
	A_UART_HWINIT((40*1000*1000), 19200);
  90aa70:	28221a        	l32i	a8, a2, 104
  90aa73:	1a6916        	l32r	a10, 8e4ecc <mUsbEPinHighBandSet+0x52c>
  90aa76:	1b69d4        	l32r	a11, 8e51c8 <vdesc_module_install+0x1b8>
  90aa79:	0b8000        	callx8	a8

	A_CLOCK_INIT(40);
  90aa7c:	282238        	l32i	a8, a2, 224
  90aa7f:	c2a8      	movi.n	a10, 40
  90aa81:	0b8000        	callx8	a8

	if (!bEepromExist) { /* jump to flash boot (eeprom data in flash) */
  90aa84:	186918        	l32r	a8, 8e4ee4 <mUsbEPinHighBandSet+0x544>
  90aa87:	288100        	l16ui	a8, a8, 0
  90aa8a:	cd86      	bnez.n	a8, 90aaa4 <_fw_usb_suspend_reboot+0x68>
		bJumptoFlash = TRUE;
  90aa8c:	186917        	l32r	a8, 8e4ee8 <mUsbEPinHighBandSet+0x548>
  90aa8f:	c091      	movi.n	a9, 1
		A_PRINTF("Jump to Flash BOOT\n");
  90aa91:	222212        	l32i	a2, a2, 72
  90aa94:	1a6a89        	l32r	a10, 8e54b8 <vdesc_module_install+0x4a8>
	A_UART_HWINIT((40*1000*1000), 19200);

	A_CLOCK_INIT(40);

	if (!bEepromExist) { /* jump to flash boot (eeprom data in flash) */
		bJumptoFlash = TRUE;
  90aa97:	298500        	s16i	a9, a8, 0
		A_PRINTF("Jump to Flash BOOT\n");
  90aa9a:	0b2000        	callx8	a2
		app_start();
  90aa9d:	5bed58        	call8	906000 <app_start>
  90aaa0:	d10f      	retw.n
  90aaa2:	000028        	mull	a0, a0, a0
	} else {
		A_PRINTF("receive the suspend command...\n");
  90aaa5:	22121a        	l32i	a2, a1, 104
  90aaa8:	6a8a0b        	blti	a8, 12, 90aab7 <_fw_usb_suspend_reboot+0x7b>
  90aaab:	8000      	l32i.n	a0, a0, 0
		/* reboot..... */
		A_USB_JUMP_BOOT();
  90aaad:	22222c        	l32i	a2, a2, 176
  90aab0:	0b2000        	callx8	a2
  90aab3:	d10f      	retw.n
  90aab5:	000000        	ill

0090aab8 <zfTurnOffPower_patch>:
 *
 * . set suspend counter to non-zero value
 * . 
 */
void zfTurnOffPower_patch(void)
{
  90aab8:	6c1004        	entry	a1, 32
	A_PRINTF("+++ goto suspend ......\n");
  90aabb:	126915        	l32r	a2, 8e4f10 <mUsbEPinHighBandSet+0x570>
  90aabe:	1a6a8b        	l32r	a10, 8e54ec <vdesc_module_install+0x4dc>
  90aac1:	232212        	l32i	a3, a2, 72
  90aac4:	c151      	movi.n	a5, 17
  90aac6:	0b3000        	callx8	a3

	/* setting the go suspend here, power down right away */
	io32_set(0x10000, BIT3);
  90aac9:	136953        	l32r	a3, 8e5018 <vdesc_module_install+0x8>
  90aacc:	c0c0      	movi.n	a12, 0
  90aace:	c0b8      	movi.n	a11, 8
  90aad0:	da30      	mov.n	a10, a3
  90aad2:	5bfed7        	call8	90a630 <io32_rmw>

	A_DELAY_USECS(100);
  90aad5:	24223b        	l32i	a4, a2, 236
  90aad8:	2a0a64        	movi	a10, 100
  90aadb:	0b4000        	callx8	a4
  90aade:	14694a        	l32r	a4, 8e5008 <vbuf_module_install+0xa8>
	 *  5. set SUSPEND_ENABLE
	 */

	iowrite32(MAGPIE_REG_CPU_PLL_BYPASS_ADDR, BIT0 | BIT4);

	A_DELAY_USECS(100); // wait for stable
  90aae1:	2a0a64        	movi	a10, 100
  90aae4:	0c0200        	memw
  90aae7:	254600        	s32i	a5, a4, 0
  90aaea:	24223b        	l32i	a4, a2, 236
  90aaed:	0b4000        	callx8	a4
  90aaf0:	14694b        	l32r	a4, 8e501c <vdesc_module_install+0xc>

	iowrite32(MAGPIE_REG_CPU_PLL_ADDR, BIT16);

	A_DELAY_USECS(100); // wait for stable
  90aaf3:	2a0a64        	movi	a10, 100
  90aaf6:	0c0200        	memw
  90aaf9:	9340      	s32i.n	a3, a4, 0
  90aafb:	24223b        	l32i	a4, a2, 236
  90aafe:	0b4000        	callx8	a4

	A_UART_HWINIT((40*1000*1000), 19200);
  90ab01:	1b69d4        	l32r	a11, 8e5254 <vdesc_module_install+0x244>
  90ab04:	24221a        	l32i	a4, a2, 104
  90ab07:	1a6916        	l32r	a10, 8e4f60 <vbuf_module_install>
  90ab0a:	0b4000        	callx8	a4
	A_CLOCK_INIT(40);
  90ab0d:	242238        	l32i	a4, a2, 224
  90ab10:	c2a8      	movi.n	a10, 40
  90ab12:	0b4000        	callx8	a4

	io32_set(MAGPIE_REG_ETH_PLL_ADDR, BIT16);
  90ab15:	176a8c        	l32r	a7, 8e5548 <vdesc_module_install+0x538>
  90ab18:	db30      	mov.n	a11, a3
  90ab1a:	da70      	mov.n	a10, a7
  90ab1c:	c0c0      	movi.n	a12, 0
  90ab1e:	5bfec4        	call8	90a630 <io32_rmw>

	io32_set(MAGPIE_REG_ETH_PLL_BYPASS_ADDR, BIT4 | BIT0);
  90ab21:	166a8d        	l32r	a6, 8e5558 <vdesc_module_install+0x548>
  90ab24:	db50      	mov.n	a11, a5
  90ab26:	da60      	mov.n	a10, a6
  90ab28:	c0c0      	movi.n	a12, 0
  90ab2a:	5bfec1        	call8	90a630 <io32_rmw>

	io32_set(MAGPIE_REG_SUSPEND_ENABLE_ADDR, 0x10 << 8);
  90ab2d:	146a8e        	l32r	a4, 8e5568 <vdesc_module_install+0x558>
  90ab30:	1b6a8f        	l32r	a11, 8e556c <vdesc_module_install+0x55c>
  90ab33:	044a02        	or	a10, a4, a4
  90ab36:	2c0a00        	movi	a12, 0
  90ab39:	5bfebd        	call8	90a630 <io32_rmw>

	// TURN OFF ETH PLL
	_fw_power_off();

	//32clk wait for External ETH PLL stable
	A_DELAY_USECS(100);
  90ab3c:	22223b        	l32i	a2, a2, 236
  90ab3f:	2a0a64        	movi	a10, 100
  90ab42:	0b2000        	callx8	a2
  90ab45:	186a91        	l32r	a8, 8e558c <vdesc_module_install+0x57c>
  90ab48:	126a90        	l32r	a2, 8e5588 <vdesc_module_install+0x578>
    
	iowrite32(0x52000, 0x70303); /* read back 0x703f7 */
	iowrite32(0x52008, 0x0e91c); /* read back 0x1e948 */
    
	io32_set(MAGPIE_REG_SUSPEND_ENABLE_ADDR, BIT0);
  90ab4b:	da40      	mov.n	a10, a4
  90ab4d:	0c0200        	memw
  90ab50:	9820      	s32i.n	a8, a2, 0
  90ab52:	186a93        	l32r	a8, 8e55a0 <vdesc_module_install+0x590>
  90ab55:	126a92        	l32r	a2, 8e55a0 <vdesc_module_install+0x590>
  90ab58:	c0b1      	movi.n	a11, 1
  90ab5a:	0c0200        	memw
  90ab5d:	9820      	s32i.n	a8, a2, 0
  90ab5f:	c0c0      	movi.n	a12, 0
  90ab61:	5bfeb3        	call8	90a630 <io32_rmw>
     *  3. turn on ETH PLL
     *  4. disable ETH PLL bypass and update
     *  5. turn on pcie pll
     */    

	io32_clr(MAGPIE_REG_ETH_PLL_ADDR, BIT16);
  90ab64:	da70      	mov.n	a10, a7
  90ab66:	dc30      	mov.n	a12, a3
  90ab68:	c0b0      	movi.n	a11, 0
  90ab6a:	5bfeb1        	call8	90a630 <io32_rmw>

	/* deassert eth_pll bypass mode and trigger update bit */
	io32_clr(MAGPIE_REG_ETH_PLL_BYPASS_ADDR, BIT4 | BIT0);
  90ab6d:	066a02        	or	a10, a6, a6
  90ab70:	055c02        	or	a12, a5, a5
  90ab73:	2b0a00        	movi	a11, 0
  90ab76:	5bfeae        	call8	90a630 <io32_rmw>
	io32_set(MAGPIE_REG_SUSPEND_ENABLE_ADDR, BIT0);

	// wake up, and turn on cpu, eth, pcie and usb pll 
	_fw_power_on();
	// restore gpio and other settings
	_fw_restore_dma_fifo();
  90ab79:	5bfeb8        	call8	90a65c <_fw_restore_dma_fifo>

	/* clear suspend */
	io32_clr(MAGPIE_REG_SUSPEND_ENABLE_ADDR, BIT0);
  90ab7c:	da40      	mov.n	a10, a4
  90ab7e:	c0b0      	movi.n	a11, 0
  90ab80:	c0c1      	movi.n	a12, 1
  90ab82:	5bfeab        	call8	90a630 <io32_rmw>
	io32_clr(0x52028, BIT8 | BIT12 | BIT16);
  90ab85:	1a6a94        	l32r	a10, 8e55d8 <vdesc_module_install+0x5c8>
  90ab88:	1c6a95        	l32r	a12, 8e55dc <vdesc_module_install+0x5cc>
  90ab8b:	c0b0      	movi.n	a11, 0
  90ab8d:	5bfea8        	call8	90a630 <io32_rmw>
  90ab90:	d10f      	retw.n
	...

0090ab94 <zfResetUSBFIFO_patch>:
 * . turn off pcie pll
 * . reset all pcie/gmac related registers
 * . reset usb dma
 */
void zfResetUSBFIFO_patch(void)
{
  90ab94:	6c1004        	entry	a1, 32
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90ab97:	126a96        	l32r	a2, 8e55f0 <vdesc_module_install+0x5e0>
	A_PRINTF("0x9808  0x%x ......\n", ioread32(0x10ff9808));
  90ab9a:	1a6a97        	l32r	a10, 8e55f8 <vdesc_module_install+0x5e8>
  90ab9d:	0c0200        	memw
  90aba0:	2b2200        	l32i	a11, a2, 0
  90aba3:	126915        	l32r	a2, 8e4ff8 <vbuf_module_install+0x98>
  90aba6:	232212        	l32i	a3, a2, 72
  90aba9:	0b3000        	callx8	a3
  90abac:	1469fb        	l32r	a4, 8e5398 <vdesc_module_install+0x388>
	A_PRINTF("0x7890  0x%x ......\n", ioread32(0x10ff7890));
  90abaf:	136a98        	l32r	a3, 8e5610 <vdesc_module_install+0x600>
  90abb2:	282212        	l32i	a8, a2, 72
  90abb5:	0c0200        	memw
  90abb8:	2b4200        	l32i	a11, a4, 0
  90abbb:	da30      	mov.n	a10, a3
  90abbd:	0b8000        	callx8	a8
  90abc0:	0c0200        	memw
  90abc3:	8b40      	l32i.n	a11, a4, 0
	A_PRINTF("0x7890  0x%x ......\n", ioread32(0x10ff7890));
  90abc5:	242212        	l32i	a4, a2, 72
  90abc8:	da30      	mov.n	a10, a3
  90abca:	0b4000        	callx8	a4
  90abcd:	136a66        	l32r	a3, 8e5568 <vdesc_module_install+0x558>
	A_PRINTF("0x4088  0x%x ......\n", ioread32(0x10ff4088));
  90abd0:	222212        	l32i	a2, a2, 72
  90abd3:	0c0200        	memw
  90abd6:	8b30      	l32i.n	a11, a3, 0
  90abd8:	1a6a6b        	l32r	a10, 8e5584 <vdesc_module_install+0x574>
  90abdb:	0b2000        	callx8	a2
	_fw_reset_dma_fifo();
  90abde:	5bfeb9        	call8	90a6c4 <_fw_reset_dma_fifo>
  90abe1:	d10f      	retw.n
	...

0090abe4 <cmnos_clock_init_patch>:
extern a_uint32_t cticks;

// clock change 
//
void cmnos_clock_init_patch(a_uint32_t refclk)
{
  90abe4:	6c1004        	entry	a1, 32
    ref_clk = refclk;
  90abe7:	186a99        	l32r	a8, 8e564c <vdesc_module_install+0x63c>
  90abea:	9280      	s32i.n	a2, a8, 0
  90abec:	d10f      	retw.n
	...

0090abf0 <cmnos_refclk_speed_get_patch>:
}

// retrieve current clock setting
a_uint32_t cmnos_refclk_speed_get_patch(void)
{
  90abf0:	6c1004        	entry	a1, 32
    return ref_clk;
}
  90abf3:	186a99        	l32r	a8, 8e5658 <vdesc_module_install+0x648>
  90abf6:	8280      	l32i.n	a2, a8, 0
  90abf8:	d10f      	retw.n
	...

0090abfc <cmnos_delay_us_patch>:


// software emulate delay function
void cmnos_delay_us_patch(int us)
{
  90abfc:	6c1004        	entry	a1, 32
    a_uint32_t start_time = NOW();
  90abff:	5b6f56        	call8	8e6958 <xthal_get_ccount>
    unsigned int num_ticks = us*ref_clk; // system_freq == number of ticks per 1us
  90ac02:	186a99        	l32r	a8, 8e5668 <vdesc_module_install+0x658>


// software emulate delay function
void cmnos_delay_us_patch(int us)
{
    a_uint32_t start_time = NOW();
  90ac05:	d3a0      	mov.n	a3, a10
    unsigned int num_ticks = us*ref_clk; // system_freq == number of ticks per 1us
  90ac07:	288200        	l32i	a8, a8, 0
  90ac0a:	082228        	mull	a2, a2, a8
    
    while ( (NOW() - start_time) < num_ticks) {
  90ac0d:	5b6f52        	call8	8e6958 <xthal_get_ccount>
  90ac10:	03aa0c        	sub	a10, a10, a3
  90ac13:	72a3f6        	bltu	a10, a2, 90ac0d <cmnos_delay_us_patch+0x11>
        /* busy spin */
        ;
    }
}
  90ac16:	d10f      	retw.n

0090ac18 <cmnos_tick_patch>:


// software emulate microsecond ticks
void cmnos_tick_patch(void)
{
  90ac18:	6c1004        	entry	a1, 32
    static a_uint32_t last_tick = 0;
    a_uint32_t current_tick = NOW();
  90ac1b:	5b6f4f        	call8	8e6958 <xthal_get_ccount>
    a_uint32_t delta_tick;

    delta_tick = (A_UINT32 ) (current_tick - last_tick)/(ref_clk<<10);
  90ac1e:	186a99        	l32r	a8, 8e5684 <vdesc_module_install+0x674>
  90ac21:	126a9a        	l32r	a2, 8e568c <vdesc_module_install+0x67c>

// software emulate microsecond ticks
void cmnos_tick_patch(void)
{
    static a_uint32_t last_tick = 0;
    a_uint32_t current_tick = NOW();
  90ac24:	d3a0      	mov.n	a3, a10
    a_uint32_t delta_tick;

    delta_tick = (A_UINT32 ) (current_tick - last_tick)/(ref_clk<<10);
  90ac26:	8b80      	l32i.n	a11, a8, 0
  90ac28:	2a2200        	l32i	a10, a2, 0
  90ac2b:	06bb11        	slli	a11, a11, 10
  90ac2e:	0a3a0c        	sub	a10, a3, a10
  90ac31:	5b6f86        	call8	8e6a4c <__udivsi3>

    if( delta_tick > 0 )
  90ac34:	c8a0      	beqz.n	a10, 90ac38 <cmnos_tick_patch+0x20>
        last_tick = current_tick;
  90ac36:	9320      	s32i.n	a3, a2, 0

    cticks += delta_tick;
  90ac38:	126a9b        	l32r	a2, 8e56a4 <vdesc_module_install+0x694>
  90ac3b:	8320      	l32i.n	a3, a2, 0
  90ac3d:	a3aa      	add.n	a10, a10, a3
  90ac3f:	9a20      	s32i.n	a10, a2, 0
  90ac41:	d10f      	retw.n
	...

0090ac44 <cmnos_milliseconds_patch>:
}

// get current sysmem up time in milliseconds based
a_uint32_t cmnos_milliseconds_patch(void)
{
  90ac44:	6c1004        	entry	a1, 32
    cmnos_tick_patch();
  90ac47:	5bfff4        	call8	90ac18 <cmnos_tick_patch>
    
    return (cticks);
}
  90ac4a:	186a9b        	l32r	a8, 8e56b8 <vdesc_module_install+0x6a8>
  90ac4d:	8280      	l32i.n	a2, a8, 0
  90ac4f:	d10f      	retw.n
  90ac51:	000000        	ill

0090ac54 <_HIFusb_get_max_msg_len_patch>:

/*
 * -- support more than 64 bytes command on ep4 -- 
 */
int _HIFusb_get_max_msg_len_patch(hif_handle_t handle, int pipe)
{
  90ac54:	6c1004        	entry	a1, 32
  90ac57:	233cfd        	addi	a3, a3, -3
    switch(pipe) {
  90ac5a:	222a00        	movi	a2, 0x200
  90ac5d:	6e3202        	bltui	a3, 2, 90ac63 <_HIFusb_get_max_msg_len_patch+0xf>
  90ac60:	226a40        	movi	a2, 0x640
            return 512;
            
        default:
            return 1600;
    }
}
  90ac63:	d10f      	retw.n
  90ac65:	000000        	ill

0090ac68 <_HIFusb_isr_handler_patch>:

/*
 * -- move the usb_task to here --
 */
void _HIFusb_isr_handler_patch(hif_handle_t h)
{
  90ac68:	6c1004        	entry	a1, 32
    A_USB_FW_TASK();
  90ac6b:	186915        	l32r	a8, 8e50c0 <vdesc_module_install+0xb0>
  90ac6e:	28821e        	l32i	a8, a8, 120
  90ac71:	0b8000        	callx8	a8

    _HIFusb_isr_handler();
  90ac74:	5b629b        	call8	8e36e4 <_HIFusb_isr_handler>
  90ac77:	d10f      	retw.n
  90ac79:	000000        	ill

0090ac7c <_HIFusb_start_patch>:
 * - update DMA_START bit4 to 1
 * - update DESC_START_ADDR
 * - update DMA_START bit 0
 */
void _HIFusb_start_patch(hif_handle_t handle) 
{
  90ac7c:	6c1004        	entry	a1, 32
    MAGPIE_REG_USB_TX0_DMA_START = 0x0;
  90ac7f:	1c6a9c        	l32r	a12, 8e56f0 <vdesc_module_install+0x6e0>
  90ac82:	c080      	movi.n	a8, 0
    MAGPIE_REG_USB_RX0_DMA_START = 0x0;
  90ac84:	1b6a9d        	l32r	a11, 8e56f8 <vdesc_module_install+0x6e8>
 * - update DESC_START_ADDR
 * - update DMA_START bit 0
 */
void _HIFusb_start_patch(hif_handle_t handle) 
{
    MAGPIE_REG_USB_TX0_DMA_START = 0x0;
  90ac87:	0c0200        	memw
  90ac8a:	98c0      	s32i.n	a8, a12, 0
    MAGPIE_REG_USB_RX0_DMA_START = 0x0;
    MAGPIE_REG_USB_RX1_DMA_START = 0x0;
  90ac8c:	1a6a9e        	l32r	a10, 8e5704 <vdesc_module_install+0x6f4>
 * - update DMA_START bit 0
 */
void _HIFusb_start_patch(hif_handle_t handle) 
{
    MAGPIE_REG_USB_TX0_DMA_START = 0x0;
    MAGPIE_REG_USB_RX0_DMA_START = 0x0;
  90ac8f:	0c0200        	memw
  90ac92:	98b0      	s32i.n	a8, a11, 0
    MAGPIE_REG_USB_RX1_DMA_START = 0x0;
    MAGPIE_REG_USB_RX2_DMA_START = 0x0;
  90ac94:	196a9f        	l32r	a9, 8e5710 <vdesc_module_install+0x700>
 */
void _HIFusb_start_patch(hif_handle_t handle) 
{
    MAGPIE_REG_USB_TX0_DMA_START = 0x0;
    MAGPIE_REG_USB_RX0_DMA_START = 0x0;
    MAGPIE_REG_USB_RX1_DMA_START = 0x0;
  90ac97:	0c0200        	memw
  90ac9a:	98a0      	s32i.n	a8, a10, 0
    MAGPIE_REG_USB_RX2_DMA_START = 0x0;
  90ac9c:	0c0200        	memw
  90ac9f:	9890      	s32i.n	a8, a9, 0
    
    while( 1 )
    {
        if(!MAGPIE_REG_USB_TX0_DMA_START &&
  90aca1:	0c0200        	memw
  90aca4:	88c0      	l32i.n	a8, a12, 0
  90aca6:	658ff7        	bnez	a8, 90aca1 <_HIFusb_start_patch+0x25>
	   !MAGPIE_REG_USB_RX0_DMA_START &&
  90aca9:	0c0200        	memw
  90acac:	88b0      	l32i.n	a8, a11, 0
    MAGPIE_REG_USB_RX1_DMA_START = 0x0;
    MAGPIE_REG_USB_RX2_DMA_START = 0x0;
    
    while( 1 )
    {
        if(!MAGPIE_REG_USB_TX0_DMA_START &&
  90acae:	658fef        	bnez	a8, 90aca1 <_HIFusb_start_patch+0x25>
	   !MAGPIE_REG_USB_RX0_DMA_START &&
	   !MAGPIE_REG_USB_RX1_DMA_START &&
  90acb1:	0c0200        	memw
  90acb4:	88a0      	l32i.n	a8, a10, 0
    MAGPIE_REG_USB_RX2_DMA_START = 0x0;
    
    while( 1 )
    {
        if(!MAGPIE_REG_USB_TX0_DMA_START &&
	   !MAGPIE_REG_USB_RX0_DMA_START &&
  90acb6:	658fe7        	bnez	a8, 90aca1 <_HIFusb_start_patch+0x25>
	   !MAGPIE_REG_USB_RX1_DMA_START &&
	   !MAGPIE_REG_USB_RX2_DMA_START )
  90acb9:	0c0200        	memw
  90acbc:	8890      	l32i.n	a8, a9, 0
    
    while( 1 )
    {
        if(!MAGPIE_REG_USB_TX0_DMA_START &&
	   !MAGPIE_REG_USB_RX0_DMA_START &&
	   !MAGPIE_REG_USB_RX1_DMA_START &&
  90acbe:	658fdf        	bnez	a8, 90aca1 <_HIFusb_start_patch+0x25>
	   !MAGPIE_REG_USB_RX2_DMA_START )
        {
            MAGPIE_REG_USB_TX0_DMA_START = MAGPIE_REG_USB_TX0_DMA_START|BIT4; 
  90acc1:	0c0200        	memw
  90acc4:	8dc0      	l32i.n	a13, a12, 0
  90acc6:	c180      	movi.n	a8, 16
  90acc8:	08dd02        	or	a13, a13, a8
  90accb:	0c0200        	memw
  90acce:	9dc0      	s32i.n	a13, a12, 0
            MAGPIE_REG_USB_RX0_DMA_START = MAGPIE_REG_USB_RX0_DMA_START|BIT4;
  90acd0:	0c0200        	memw
  90acd3:	8cb0      	l32i.n	a12, a11, 0
  90acd5:	08cc02        	or	a12, a12, a8
  90acd8:	0c0200        	memw
  90acdb:	9cb0      	s32i.n	a12, a11, 0
            MAGPIE_REG_USB_RX1_DMA_START = MAGPIE_REG_USB_RX1_DMA_START|BIT4;
  90acdd:	0c0200        	memw
  90ace0:	8ba0      	l32i.n	a11, a10, 0
  90ace2:	08bb02        	or	a11, a11, a8
  90ace5:	0c0200        	memw
  90ace8:	9ba0      	s32i.n	a11, a10, 0
            MAGPIE_REG_USB_RX2_DMA_START = MAGPIE_REG_USB_RX2_DMA_START|BIT4;
  90acea:	0c0200        	memw
  90aced:	8a90      	l32i.n	a10, a9, 0
  90acef:	08a802        	or	a8, a10, a8
  90acf2:	0c0200        	memw
  90acf5:	9890      	s32i.n	a8, a9, 0
            break;
        }
    }
    _HIFusb_start();
  90acf7:	5b61ea        	call8	8e34a0 <_HIFusb_start>
  90acfa:	d10f      	retw.n

0090acfc <__adf_os_dmamem_alloc>:
 * @return void* (Virtual address)
 */
inline void*
__adf_os_dmamem_alloc(__adf_os_device_t osdev, adf_os_size_t size, 
                      a_bool_t coherent, __adf_os_dma_map_t *dmap)
{    
  90acfc:	6c1004        	entry	a1, 32
    (*dmap) = A_ALLOCRAM(sizeof(struct __adf_dma_map));
  90acff:	146915        	l32r	a4, 8e5154 <vdesc_module_install+0x144>
  90ad02:	c0a0      	movi.n	a10, 0
  90ad04:	224252        	l32i	a2, a4, 0x148
  90ad07:	c0bc      	movi.n	a11, 12
  90ad09:	0b2000        	callx8	a2
  90ad0c:	9a50      	s32i.n	a10, a5, 0
  90ad0e:	d2a0      	mov.n	a2, a10
    
	if((*dmap) == NULL){
  90ad10:	c9a1      	beqz.n	a10, 90ad25 <__adf_os_dmamem_alloc+0x29>
		goto fail_malloc;
	}
	    
    (*dmap)->ds_addr = A_ALLOCRAM(size);
  90ad12:	244252        	l32i	a4, a4, 0x148
  90ad15:	c0a0      	movi.n	a10, 0
  90ad17:	db30      	mov.n	a11, a3
  90ad19:	0b4000        	callx8	a4
  90ad1c:	9a21      	s32i.n	a10, a2, 4
    (*dmap)->ds_len = size;
  90ad1e:	8250      	l32i.n	a2, a5, 0
  90ad20:	232504        	s16i	a3, a2, 8
    
    return (*dmap)->ds_addr;
  90ad23:	8221      	l32i.n	a2, a2, 4
    
fail_malloc: 
    return NULL;            
}
  90ad25:	d10f      	retw.n
	...

0090ad28 <__adf_os_setup_intr>:
 * @return int
 */

int
__adf_os_setup_intr(__adf_os_device_t  osdev, adf_os_drv_intr fn)
{
  90ad28:	6c1004        	entry	a1, 32
    g_wlan_intr = fn;
  90ad2b:	186a43        	l32r	a8, 8e5638 <vdesc_module_install+0x628>
    
    return 0;    
}
  90ad2e:	c020      	movi.n	a2, 0
 */

int
__adf_os_setup_intr(__adf_os_device_t  osdev, adf_os_drv_intr fn)
{
    g_wlan_intr = fn;
  90ad30:	9380      	s32i.n	a3, a8, 0
    
    return 0;    
}
  90ad32:	d10f      	retw.n

0090ad34 <__adf_os_free_intr>:
 * @param[in] dev
 * @param[in] sc
 */
void
__adf_os_free_intr(__adf_os_device_t osdev)
{
  90ad34:	6c1004        	entry	a1, 32
    g_wlan_intr = NULL;  
  90ad37:	186a43        	l32r	a8, 8e5644 <vdesc_module_install+0x634>
  90ad3a:	c090      	movi.n	a9, 0
  90ad3c:	9980      	s32i.n	a9, a8, 0
  90ad3e:	d10f      	retw.n

0090ad40 <ath_hal_attach_tgt>:

struct ath_hal*
ath_hal_attach_tgt(a_uint32_t devid,HAL_SOFTC sc,
		   adf_os_device_t dev,
		   a_uint32_t flags, HAL_STATUS *error)
{
  90ad40:	6c1004        	entry	a1, 32
	struct ath_hal *ah = AH_NULL;

	ah = ar5416Attach(sc, dev, error);
  90ad43:	da30      	mov.n	a10, a3
  90ad45:	db40      	mov.n	a11, a4
  90ad47:	dc60      	mov.n	a12, a6
  90ad49:	5804f8        	call8	90c12c <ar5416Attach>

	return ah;
}
  90ad4c:	d2a0      	mov.n	a2, a10
  90ad4e:	d10f      	retw.n

0090ad50 <ath_hal_getcapability>:

HAL_STATUS
ath_hal_getcapability(struct ath_hal *ah, HAL_CAPABILITY_TYPE type)
{
  90ad50:	6c1004        	entry	a1, 32
	const HAL_CAPABILITIES *pCap = &AH_PRIVATE(ah)->ah_caps;
	switch (type) {
  90ad53:	68310d        	beqi	a3, 1, 90ad64 <ath_hal_getcapability+0x14>
  90ad56:	c93e      	beqz.n	a3, 90ad78 <ath_hal_getcapability+0x28>
	case HAL_CAP_BSSIDMASK:
		return pCap->halBssIdMaskSupport ? HAL_OK : HAL_ENOTSUPP;
	case HAL_CAP_VEOL:
		return pCap->halVEOLSupport ? HAL_OK : HAL_ENOTSUPP;
	default:
		return HAL_EINVAL;
  90ad58:	233cfe        	addi	a3, a3, -2
  90ad5b:	c08d      	movi.n	a8, 13
  90ad5d:	c02c      	movi.n	a2, 12
  90ad5f:	038238        	moveqz	a2, a8, a3
  90ad62:	d10f      	retw.n
	const HAL_CAPABILITIES *pCap = &AH_PRIVATE(ah)->ah_caps;
	switch (type) {
	case HAL_CAP_TSF_ADJUST:
		return HAL_ENOTSUPP;
	case HAL_CAP_BSSIDMASK:
		return pCap->halBssIdMaskSupport ? HAL_OK : HAL_ENOTSUPP;
  90ad64:	28222b        	l32i	a8, a2, 172
  90ad67:	126a32        	l32r	a2, 8e5630 <vdesc_module_install+0x620>
  90ad6a:	c03d      	movi.n	a3, 13
  90ad6c:	028801        	and	a8, a8, a2
  90ad6f:	c020      	movi.n	a2, 0
  90ad71:	083238        	moveqz	a2, a3, a8
  90ad74:	d10f      	retw.n
  90ad76:	000028        	mull	a0, a0, a0
	case HAL_CAP_VEOL:
		return pCap->halVEOLSupport ? HAL_OK : HAL_ENOTSUPP;
  90ad79:	222b12        	l32ai	a2, a2, 72
  90ad7c:	6a3102        	blti	a3, 1, 90ad82 <ath_hal_getcapability+0x32>
  90ad7f:	8201      	l32i.n	a2, a0, 4
  90ad81:	c08d      	movi.n	a8, 13
  90ad83:	028338        	moveqz	a3, a8, a2
  90ad86:	d230      	mov.n	a2, a3
	default:
		return HAL_EINVAL;
	}
}
  90ad88:	d10f      	retw.n
	...

0090ad8c <ath_hal_computetxtime>:

a_uint16_t
ath_hal_computetxtime(struct ath_hal *ah,
		      const HAL_RATE_TABLE *rates, a_uint32_t frameLen, a_uint16_t rateix,
		      HAL_BOOL shortPreamble)
{
  90ad8c:	6c1004        	entry	a1, 32
  90ad8f:	05054f        	extui	a5, a5, 0, 16
	a_uint32_t bitsPerSymbol, numBits, numSymbols, phyTime, txTime;
	a_uint32_t kbps;

	kbps = rates->info[rateix].rateKbps;
  90ad92:	05550a        	addx4	a5, a5, a5
  90ad95:	03530a        	addx4	a3, a5, a3
  90ad98:	8b3c      	l32i.n	a11, a3, 48

	/*
	 * index can be invalid duting dynamic Turbo transitions.
	 */
	if(kbps == 0) return 0;
  90ad9a:	c020      	movi.n	a2, 0
  90ad9c:	72b155        	beq	a11, a2, 90adf5 <ath_hal_computetxtime+0x69>
	switch (rates->info[rateix].phy) {
  90ad9f:	253c20        	addi	a5, a3, 32
  90ada2:	285009        	l8ui	a8, a5, 9
  90ada5:	728107        	beq	a8, a2, 90adb0 <ath_hal_computetxtime+0x24>
  90ada8:	698246        	bnei	a8, 2, 90adf2 <ath_hal_computetxtime+0x66>
  90adab:	600028        	j	90add7 <ath_hal_computetxtime+0x4b>
  90adae:	000022        	excw

	case IEEE80211_T_CCK:
		phyTime = CCK_PREAMBLE_BITS + CCK_PLCP_BITS;
  90adb1:	0ac0c8        	excw
		if (shortPreamble && rates->info[rateix].shortPreamble)
  90adb4:	672650        	bgez	a2, 90b408 <ar5416SetupTxDesc_20+0x15c>
  90adb7:	15250a        	l32r	a5, 8d41e0 <_bss_end+0x3c12d0>
	 */
	if(kbps == 0) return 0;
	switch (rates->info[rateix].phy) {

	case IEEE80211_T_CCK:
		phyTime = CCK_PREAMBLE_BITS + CCK_PLCP_BITS;
  90adba:	600652        	j	90b410 <ar5416SetupTxDesc_20+0x164>
  90adbd:	390d45        	excw
		if (shortPreamble && rates->info[rateix].shortPreamble)
			phyTime >>= 1;
		numBits = frameLen << 3;
  90adc0:	110844        	l32r	a1, 8cced0 <_bss_end+0x3b9fc0>
		txTime = phyTime + ((numBits * 1000)/kbps);
  90adc3:	110544        	l32r	a1, 8cc2d4 <_bss_end+0x3b93c4>
  90adc6:	0c054a        	extui	a5, a12, 0, 11
  90adc9:	0a0daa        	excw
  90adcc:	115b6f        	l32r	a1, 8e1b88 <athos_indirection_table_install+0x614>
  90adcf:	1fbaaa        	l32r	a15, 8f9878 <memset+0x12a30>
		/* TODO: make sure the same value of txTime can use in all device */
		if (ath_hal_getcapability(ah, HAL_CAP_HT) != HAL_OK)
			txTime = txTime + CCK_SIFS_TIME;
  90add2:	a2a2      	add.n	a2, a10, a2
  90add4:	60001a        	j	90adf2 <ath_hal_computetxtime+0x66>
		break;
	case IEEE80211_T_OFDM:
		/* full rate channel */
		bitsPerSymbol   = (kbps * OFDM_SYMBOL_TIME) / 1000;
  90add7:	126aa0        	l32r	a2, 8e5858 <vdesc_module_install+0x848>
  90adda:	0ebb11        	slli	a11, a11, 2
  90addd:	02bb2a        	muluh	a11, a11, a2
  90ade0:	0b6b14        	srli	a11, a11, 6
		HALASSERT(bitsPerSymbol != 0);

		numBits = OFDM_PLCP_BITS + (frameLen << 3);
		numSymbols = asf_howmany(numBits, bitsPerSymbol);
  90ade3:	2abc15        	addi	a10, a11, 21
  90ade6:	0a4a0b        	addx8	a10, a4, a10
  90ade9:	5b6f18        	call8	8e6a4c <__udivsi3>
		txTime = OFDM_PREAMBLE_TIME + (numSymbols * OFDM_SYMBOL_TIME);
  90adec:	0eaa11        	slli	a10, a10, 2
		/* TODO: make sure the same value of txTime can use in all device */
		if (ath_hal_getcapability(ah, HAL_CAP_HT) != HAL_OK)
			txTime = txTime + OFDM_SIFS_TIME;
  90adef:	22ac24        	addi	a2, a10, 36
		break;
	default:
		txTime = 0;
		break;
	}
	return txTime;
  90adf2:	02024f        	extui	a2, a2, 0, 16
}
  90adf5:	d10f      	retw.n
	...

0090adf8 <ath_hal_get_curmode>:
#undef OFDM_SYMBOL_TIME

#ifdef MAGPIE_MERLIN
a_uint32_t 
ath_hal_get_curmode(struct ath_hal *ah, HAL_CHANNEL_INTERNAL *chan)
{
  90adf8:	6c1004        	entry	a1, 32
	if (!chan)
		return HAL_MODE_11NG;
  90adfb:	126a32        	l32r	a2, 8e56c4 <vdesc_module_install+0x6b4>

#ifdef MAGPIE_MERLIN
a_uint32_t 
ath_hal_get_curmode(struct ath_hal *ah, HAL_CHANNEL_INTERNAL *chan)
{
	if (!chan)
  90adfe:	643046        	beqz	a3, 90ae48 <ath_hal_get_curmode+0x50>
		return HAL_MODE_11NG;

	if (IS_CHAN_NA(chan))
  90ae01:	8831      	l32i.n	a8, a3, 4
  90ae03:	19693c        	l32r	a9, 8e52f4 <vdesc_module_install+0x2e4>
		return HAL_MODE_11NA; 
  90ae06:	126a31        	l32r	a2, 8e56cc <vdesc_module_install+0x6bc>
ath_hal_get_curmode(struct ath_hal *ah, HAL_CHANNEL_INTERNAL *chan)
{
	if (!chan)
		return HAL_MODE_11NG;

	if (IS_CHAN_NA(chan))
  90ae09:	098301        	and	a3, a8, a9
  90ae0c:	793138        	beq	a3, a9, 90ae48 <ath_hal_get_curmode+0x50>
		return HAL_MODE_11NA; 

	if (IS_CHAN_A(chan))
  90ae0f:	221a40        	movi	a2, 0x140
  90ae12:	028301        	and	a3, a8, a2
  90ae15:	72312d        	beq	a3, a2, 90ae46 <ath_hal_get_curmode+0x4e>
		return HAL_MODE_11A;

	if (IS_CHAN_NG(chan))
  90ae18:	196aa1        	l32r	a9, 8e589c <vdesc_module_install+0x88c>
#ifdef MAGPIE_MERLIN
a_uint32_t 
ath_hal_get_curmode(struct ath_hal *ah, HAL_CHANNEL_INTERNAL *chan)
{
	if (!chan)
		return HAL_MODE_11NG;
  90ae1b:	126a32        	l32r	a2, 8e56e4 <vdesc_module_install+0x6d4>
		return HAL_MODE_11NA; 

	if (IS_CHAN_A(chan))
		return HAL_MODE_11A;

	if (IS_CHAN_NG(chan))
  90ae1e:	098301        	and	a3, a8, a9
  90ae21:	793123        	beq	a3, a9, 90ae48 <ath_hal_get_curmode+0x50>
		return HAL_MODE_11NG;

	if (IS_CHAN_G(chan))
  90ae24:	290ad0        	movi	a9, 208
  90ae27:	098901        	and	a9, a8, a9
  90ae2a:	230ac0        	movi	a3, 192
		return HAL_MODE_11G;
  90ae2d:	c028      	movi.n	a2, 8
		return HAL_MODE_11A;

	if (IS_CHAN_NG(chan))
		return HAL_MODE_11NG;

	if (IS_CHAN_G(chan))
  90ae2f:	739115        	beq	a9, a3, 90ae48 <ath_hal_get_curmode+0x50>
		return HAL_MODE_11G;

	if (IS_CHAN_B(chan))
  90ae32:	290aa0        	movi	a9, 160
  90ae35:	098801        	and	a8, a8, a9
		return HAL_MODE_11B;
  90ae38:	136a32        	l32r	a3, 8e5700 <vdesc_module_install+0x6f0>
  90ae3b:	09890c        	sub	a9, a8, a9
  90ae3e:	c024      	movi.n	a2, 4
  90ae40:	093239        	movnez	a2, a3, a9
  90ae43:	d10f      	retw.n
  90ae45:	00c021        	excw

	HALASSERT(0);
	return HAL_MODE_11NG;
}
  90ae48:	d10f      	retw.n
	...

0090ae4c <ath_hal_wait>:

#endif

HAL_BOOL
ath_hal_wait(struct ath_hal *ah, a_uint32_t reg, a_uint32_t mask, a_uint32_t val)
{
  90ae4c:	6c1004        	entry	a1, 32
				return AH_TRUE;
			OS_DELAY(10);
		}
	} else {
		for (i = 0; i < AH_TIMEOUT_11G; i++) {
			if ((ioread32_mac(reg) & mask) == val)
  90ae4f:	186a02        	l32r	a8, 8e5658 <vdesc_module_install+0x648>

#endif

HAL_BOOL
ath_hal_wait(struct ath_hal *ah, a_uint32_t reg, a_uint32_t mask, a_uint32_t val)
{
  90ae52:	223ae8        	movi	a2, 0x3e8
				return AH_TRUE;
			OS_DELAY(10);
		}
	} else {
		for (i = 0; i < AH_TIMEOUT_11G; i++) {
			if ((ioread32_mac(reg) & mask) == val)
  90ae55:	083308        	add	a3, a3, a8
  90ae58:	0c0200        	memw
  90ae5b:	8830      	l32i.n	a8, a3, 0
  90ae5d:	084801        	and	a8, a4, a8
  90ae60:	75810d        	beq	a8, a5, 90ae71 <ath_hal_wait+0x25>
				return AH_TRUE;
			OS_DELAY(10);
  90ae63:	2a0a0a        	movi	a10, 10
  90ae66:	222cff        	addi	a2, a2, -1
  90ae69:	5bf327        	call8	907b08 <ath_hal_delay>
			if ((ioread32_mac(reg) & mask) == val)
				return AH_TRUE;
			OS_DELAY(10);
		}
	} else {
		for (i = 0; i < AH_TIMEOUT_11G; i++) {
  90ae6c:	652fe8        	bnez	a2, 90ae58 <ath_hal_wait+0xc>
  90ae6f:	d10f      	retw.n
			if ((ioread32_mac(reg) & mask) == val)
				return AH_TRUE;
  90ae71:	c021      	movi.n	a2, 1
	}
	return AH_FALSE;

#undef AH_TIMEOUT_11N
#undef AH_TIMEOUT_11G
}
  90ae73:	d10f      	retw.n
  90ae75:	000000        	ill

0090ae78 <ar5416IsInterruptPending>:
/**********************/
/* Interrupt Handling */
/**********************/

HAL_BOOL ar5416IsInterruptPending(struct ath_hal *ah)
{
  90ae78:	6c1004        	entry	a1, 32
	a_uint32_t host_isr;

	A_DELAY_USECS(1);
  90ae7b:	126915        	l32r	a2, 8e52d0 <vdesc_module_install+0x2c0>
  90ae7e:	c0a1      	movi.n	a10, 1
  90ae80:	22223b        	l32i	a2, a2, 236
  90ae83:	0b2000        	callx8	a2
  90ae86:	126aa2        	l32r	a2, 8e5910 <vdesc_module_install+0x900>
  90ae89:	0c0200        	memw
  90ae8c:	8820      	l32i.n	a8, a2, 0
	host_isr = ioread32_mac(AR_INTR_ASYNC_CAUSE);
	/*
	 * Some platforms trigger our ISR before applying power to
	 * the card, so make sure.
	 */
	return ((host_isr != AR_INTR_SPURIOUS) && (host_isr & AR_INTR_MAC_IRQ));
  90ae8e:	c020      	movi.n	a2, 0
  90ae90:	081940        	extui	a9, a8, 1, 1
  90ae93:	b188      	addi.n	a8, a8, 1
  90ae95:	089239        	movnez	a2, a9, a8
}
  90ae98:	d10f      	retw.n
	...

0090ae9c <ar5416SetInterrupts>:
	return AH_TRUE;
}

HAL_INT
ar5416SetInterrupts(struct ath_hal *ah, HAL_INT ints)
{
  90ae9c:	6c1004        	entry	a1, 32
  90ae9f:	d920      	mov.n	a9, a2
	struct ath_hal_5416 *ahp = AH5416(ah);
	a_uint32_t omask = ahp->ah_maskReg;
  90aea1:	222236        	l32i	a2, a2, 216
	a_uint32_t mask;

	if (omask & HAL_INT_GLOBAL) {
  90aea4:	672011        	bgez	a2, 90aeb9 <ar5416SetInterrupts+0x1d>
  90aea7:	186aa3        	l32r	a8, 8e5934 <vdesc_module_install+0x924>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90aeaa:	2a0a00        	movi	a10, 0
  90aead:	0c0200        	memw
  90aeb0:	2a8600        	s32i	a10, a8, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90aeb3:	0c0200        	memw
  90aeb6:	288200        	l32i	a8, a8, 0
		iowrite32_mac(AR_IER, AR_IER_DISABLE);
		(void) ioread32_mac(AR_IER);
	}

	mask = ints & HAL_INT_COMMON;
  90aeb9:	186aa4        	l32r	a8, 8e594c <vdesc_module_install+0x93c>
  90aebc:	083801        	and	a8, a3, a8
	if (ints & HAL_INT_TX) {
  90aebf:	793705        	bbci	a3, 25, 90aec8 <ar5416SetInterrupts+0x2c>
#else
		mask |= AR_IMR_TXOK;
		mask |= AR_IMR_TXDESC;
#endif
		mask |= AR_IMR_TXERR;
		mask |= AR_IMR_TXEOL;
  90aec2:	2a5ac0        	movi	a10, 0x5c0
  90aec5:	0a8802        	or	a8, a8, a10
	}
	if (ints & HAL_INT_RX) {
  90aec8:	7f3704        	bbci	a3, 31, 90aed0 <ar5416SetInterrupts+0x34>
		mask |= AR_IMR_RXERR;
#ifdef AR5416_INT_MITIGATION
		mask |=  AR_IMR_RXMINTR | AR_IMR_RXINTM;
#else
		mask |= AR_IMR_RXOK | AR_IMR_RXDESC;
  90aecb:	c0a7      	movi.n	a10, 7
  90aecd:	0a8802        	or	a8, a8, a10
#endif
	}

	if (ints & (HAL_INT_GTT | HAL_INT_CST)) {
  90aed0:	1a6aa5        	l32r	a10, 8e5964 <vdesc_module_install+0x954>
  90aed3:	7a3005        	bnone	a3, a10, 90aedc <ar5416SetInterrupts+0x40>
		mask |= AR_IMR_BCNMISC;
  90aed6:	1a6aa6        	l32r	a10, 8e5970 <vdesc_module_install+0x960>
  90aed9:	0a8802        	or	a8, a8, a10
  90aedc:	1a6aa7        	l32r	a10, 8e5978 <vdesc_module_install+0x968>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90aedf:	0c0200        	memw
  90aee2:	98a0      	s32i.n	a8, a10, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90aee4:	0c0200        	memw
  90aee7:	88a0      	l32i.n	a8, a10, 0
	}

	iowrite32_mac(AR_IMR, mask);
	(void) ioread32_mac(AR_IMR);
	ahp->ah_maskReg = ints;
  90aee9:	239636        	s32i	a3, a9, 216

	/* Re-enable interrupts if they were enabled before. */
	if (ints & HAL_INT_GLOBAL) {
  90aeec:	673010        	bgez	a3, 90af00 <ar5416SetInterrupts+0x64>
  90aeef:	136aa3        	l32r	a3, 8e597c <vdesc_module_install+0x96c>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90aef2:	c081      	movi.n	a8, 1
  90aef4:	0c0200        	memw
  90aef7:	283600        	s32i	a8, a3, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90aefa:	0c0200        	memw
  90aefd:	233200        	l32i	a3, a3, 0
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90af00:	186aa8        	l32r	a8, 8e59a0 <vdesc_module_install+0x990>
  90af03:	c032      	movi.n	a3, 2
  90af05:	0c0200        	memw
  90af08:	9380      	s32i.n	a3, a8, 0
  90af0a:	186aa9        	l32r	a8, 8e59b0 <vdesc_module_install+0x9a0>
  90af0d:	0c0200        	memw
  90af10:	9380      	s32i.n	a3, a8, 0
  90af12:	186aab        	l32r	a8, 8e59c0 <vdesc_module_install+0x9b0>
  90af15:	136aaa        	l32r	a3, 8e59c0 <vdesc_module_install+0x9b0>
  90af18:	0c0200        	memw
  90af1b:	9830      	s32i.n	a8, a3, 0
	iowrite32_mac(AR_INTR_ASYNC_ENABLE, AR_INTR_MAC_IRQ);
	iowrite32_mac(AR_INTR_ASYNC_MASK, AR_INTR_MAC_IRQ);
	iowrite32_mac(AR_INTR_SYNC_ENABLE, AR_INTR_SYNC_ALL);

	return omask;
}
  90af1d:	d10f      	retw.n
	...

0090af20 <ar5416GetTsf64>:
/****************/

#define ATH9K_HTC_MAX_TSF_READ 3

u_int64_t ar5416GetTsf64(struct ath_hal *ah)
{
  90af20:	6c1004        	entry	a1, 32
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90af23:	186aac        	l32r	a8, 8e59d4 <vdesc_module_install+0x9c4>
  90af26:	196aad        	l32r	a9, 8e59dc <vdesc_module_install+0x9cc>
  90af29:	0c0200        	memw
  90af2c:	8a80      	l32i.n	a10, a8, 0
  90af2e:	0c0200        	memw
  90af31:	8390      	l32i.n	a3, a9, 0
  90af33:	0c0200        	memw
  90af36:	8280      	l32i.n	a2, a8, 0

	tsf_upper1 = ioread32_mac(AR_TSF_U32);
	for (i = 0; i < ATH9K_HTC_MAX_TSF_READ; i++) {
		tsf_lower = ioread32_mac(AR_TSF_L32);
		tsf_upper2 = ioread32_mac(AR_TSF_U32);
		if (tsf_upper2 == tsf_upper1)
  90af38:	7a2116        	beq	a2, a10, 90af52 <ar5416GetTsf64+0x32>
  90af3b:	0c0200        	memw
  90af3e:	8390      	l32i.n	a3, a9, 0
  90af40:	0c0200        	memw
  90af43:	8a80      	l32i.n	a10, a8, 0
  90af45:	72a109        	beq	a10, a2, 90af52 <ar5416GetTsf64+0x32>
  90af48:	0c0200        	memw
  90af4b:	8390      	l32i.n	a3, a9, 0
  90af4d:	0c0200        	memw
  90af50:	8280      	l32i.n	a2, a8, 0
			break;
		tsf_upper1 = tsf_upper2;
	}

	return (((u_int64_t)tsf_upper2 << 32) | tsf_lower);
}
  90af52:	d10f      	retw.n

0090af54 <ar5416SetRxDP>:

/******/
/* RX */
/******/
void ar5416SetRxDP(struct ath_hal *ah, a_uint32_t rxdp)
{
  90af54:	6c1004        	entry	a1, 32
  90af57:	186aae        	l32r	a8, 8e5a10 <vdesc_module_install+0xa00>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90af5a:	0c0200        	memw
  90af5d:	9380      	s32i.n	a3, a8, 0
  90af5f:	d10f      	retw.n
  90af61:	000000        	ill

0090af64 <ar5416EnableReceive>:
			     & ~AR_RXCFG_ZLFDMA);
	}
}

void ar5416EnableReceive(struct ath_hal *ah)
{
  90af64:	6c1004        	entry	a1, 32
  90af67:	186aaf        	l32r	a8, 8e5a24 <vdesc_module_install+0xa14>
  90af6a:	c094      	movi.n	a9, 4
  90af6c:	0c0200        	memw
  90af6f:	9980      	s32i.n	a9, a8, 0
  90af71:	d10f      	retw.n
	...

0090af74 <ar5416StopPcuReceive>:
	iowrite32_mac(AR_CR, AR_CR_RXE);
}

void ar5416StopPcuReceive(struct ath_hal *ah)
{
  90af74:	6c1004        	entry	a1, 32
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90af77:	186ab0        	l32r	a8, 8e5a38 <vdesc_module_install+0xa28>
	OS_REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_RX_DIS);
  90af7a:	c290      	movi.n	a9, 32
  90af7c:	0c0200        	memw
  90af7f:	8a80      	l32i.n	a10, a8, 0
  90af81:	09a902        	or	a9, a10, a9
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90af84:	0c0200        	memw
  90af87:	9980      	s32i.n	a9, a8, 0
  90af89:	d10f      	retw.n
	...

0090af8c <ar5416SetupRxDesc_20>:
}

HAL_BOOL ar5416SetupRxDesc_20(struct ath_rx_desc *ds,
			      a_uint32_t size, a_uint32_t flags)
{
  90af8c:	6c1004        	entry	a1, 32
	struct ar5416_desc *ads = AR5416DESC(ds);

	HALASSERT((size &~ AR_BufLen) == 0);

	ads->ds_ctl1 = size & AR_BufLen;
  90af8f:	03084b        	extui	a8, a3, 0, 12
	if (flags & HAL_RXDESC_INTREQ)
  90af92:	7a4f16        	bbsi	a4, 26, 90afac <ar5416SetupRxDesc_20+0x20>
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	HALASSERT((size &~ AR_BufLen) == 0);

	ads->ds_ctl1 = size & AR_BufLen;
  90af95:	088957        	extui	a9, a8, 24, 8
  90af98:	29240c        	s8i	a9, a2, 12
  90af9b:	088814        	srli	a8, a8, 8
  90af9e:	c090      	movi.n	a9, 0
  90afa0:	29240d        	s8i	a9, a2, 13
  90afa3:	28240e        	s8i	a8, a2, 14
  90afa6:	23240f        	s8i	a3, a2, 15
  90afa9:	60001a        	j	90afc7 <ar5416SetupRxDesc_20+0x3b>
	if (flags & HAL_RXDESC_INTREQ)
		ads->ds_ctl1 |= AR_RxIntrReq;
  90afac:	136a01        	l32r	a3, 8e57b0 <vdesc_module_install+0x7a0>
  90afaf:	038802        	or	a8, a8, a3
  90afb2:	088357        	extui	a3, a8, 24, 8
  90afb5:	23240c        	s8i	a3, a2, 12
  90afb8:	080357        	extui	a3, a8, 16, 8
  90afbb:	23240d        	s8i	a3, a2, 13
  90afbe:	088347        	extui	a3, a8, 8, 8
  90afc1:	23240e        	s8i	a3, a2, 14
  90afc4:	28240f        	s8i	a8, a2, 15

	/* this should be enough */
	ads->ds_rxstatus8 &= ~AR_RxDone;
  90afc7:	292030        	l8ui	a9, a2, 48
  90afca:	232031        	l8ui	a3, a2, 49
  90afcd:	282032        	l8ui	a8, a2, 50
  90afd0:	089910        	slli	a9, a9, 24
  90afd3:	003311        	slli	a3, a3, 16
  90afd6:	093302        	or	a3, a3, a9
  90afd9:	088811        	slli	a8, a8, 8
  90afdc:	038802        	or	a8, a8, a3
  90afdf:	232033        	l8ui	a3, a2, 51
  90afe2:	083802        	or	a8, a3, a8
  90afe5:	c73e      	movi.n	a3, -2
  90afe7:	038801        	and	a8, a8, a3
  90afea:	088357        	extui	a3, a8, 24, 8
  90afed:	232430        	s8i	a3, a2, 48
  90aff0:	080357        	extui	a3, a8, 16, 8
  90aff3:	232431        	s8i	a3, a2, 49
  90aff6:	088347        	extui	a3, a8, 8, 8
  90aff9:	232432        	s8i	a3, a2, 50
  90affc:	282433        	s8i	a8, a2, 51

	return AH_TRUE;
}
  90afff:	c021      	movi.n	a2, 1
  90b001:	d10f      	retw.n
	...

0090b004 <ar5416ProcRxDescFast_20>:

HAL_STATUS ar5416ProcRxDescFast_20(struct ath_hal *ah, struct ath_rx_desc *ds,
				   a_uint32_t pa, struct ath_desc *nds,
				   struct ath_rx_status *rx_stats)
{
  90b004:	6c1004        	entry	a1, 32
	struct ar5416_desc ads;
	struct ar5416_desc *adsp = AR5416DESC(ds);
	struct ar5416_desc *ands = AR5416DESC(nds);

	if ((adsp->ds_rxstatus8 & AR_RxDone) == 0)
  90b007:	293030        	l8ui	a9, a3, 48
  90b00a:	223031        	l8ui	a2, a3, 49
  90b00d:	283032        	l8ui	a8, a3, 50
  90b010:	089910        	slli	a9, a9, 24
  90b013:	002211        	slli	a2, a2, 16
  90b016:	092202        	or	a2, a2, a9
  90b019:	088811        	slli	a8, a8, 8
  90b01c:	028802        	or	a8, a8, a2
  90b01f:	223033        	l8ui	a2, a3, 51
  90b022:	082802        	or	a8, a2, a8
		return HAL_EINPROGRESS;
  90b025:	c02f      	movi.n	a2, 15
{
	struct ar5416_desc ads;
	struct ar5416_desc *adsp = AR5416DESC(ds);
	struct ar5416_desc *ands = AR5416DESC(nds);

	if ((adsp->ds_rxstatus8 & AR_RxDone) == 0)
  90b027:	7f8f02        	bbsi	a8, 31, 90b02d <ar5416ProcRxDescFast_20+0x29>
  90b02a:	6001be        	j	90b1ec <ar5416ProcRxDescFast_20+0x1e8>
	/*
	 * Given the use of a self-linked tail be very sure that the hw is
	 * done with this descriptor; the hw may have done this descriptor
	 * once and picked it up again...make sure the hw has moved on.
	 */
	if ((ands->ds_rxstatus8 & AR_RxDone) == 0
  90b02d:	255033        	l8ui	a5, a5, 51
  90b030:	7f5f0d        	bbsi	a5, 31, 90b041 <ar5416ProcRxDescFast_20+0x3d>
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90b033:	156aae        	l32r	a5, 8e5aec <vdesc_module_install+0xadc>
  90b036:	0c0200        	memw
  90b039:	8550      	l32i.n	a5, a5, 0
	    && ioread32_mac(AR_RXDP) == pa)
  90b03b:	745902        	bne	a5, a4, 90b041 <ar5416ProcRxDescFast_20+0x3d>
  90b03e:	6001aa        	j	90b1ec <ar5416ProcRxDescFast_20+0x1e8>
	 * Next we fill in all values in a caller passed stack variable.
	 * This reduces the number of uncached accesses.
	 * Do this copy here, after the check so that when the checks fail, we
	 * dont end up copying the entire stats uselessly.
	 */
	ads.u.rx = adsp->u.rx;
  90b041:	243010        	l8ui	a4, a3, 16
  90b044:	223011        	l8ui	a2, a3, 17
  90b047:	2a3012        	l8ui	a10, a3, 18
  90b04a:	084410        	slli	a4, a4, 24
  90b04d:	002211        	slli	a2, a2, 16
  90b050:	042202        	or	a2, a2, a4
  90b053:	08aa11        	slli	a10, a10, 8
  90b056:	02aa02        	or	a10, a10, a2
  90b059:	223013        	l8ui	a2, a3, 19
  90b05c:	243014        	l8ui	a4, a3, 20
  90b05f:	0a2a02        	or	a10, a2, a10
  90b062:	223015        	l8ui	a2, a3, 21
  90b065:	2b3016        	l8ui	a11, a3, 22
  90b068:	084410        	slli	a4, a4, 24
  90b06b:	002211        	slli	a2, a2, 16
  90b06e:	042202        	or	a2, a2, a4
  90b071:	08bb11        	slli	a11, a11, 8
  90b074:	02bb02        	or	a11, a11, a2
  90b077:	223017        	l8ui	a2, a3, 23
  90b07a:	243018        	l8ui	a4, a3, 24
  90b07d:	0b2b02        	or	a11, a2, a11
  90b080:	223019        	l8ui	a2, a3, 25
  90b083:	2c301a        	l8ui	a12, a3, 26
  90b086:	084410        	slli	a4, a4, 24
  90b089:	002211        	slli	a2, a2, 16
  90b08c:	042202        	or	a2, a2, a4
  90b08f:	08cc11        	slli	a12, a12, 8
  90b092:	02cc02        	or	a12, a12, a2
  90b095:	22301b        	l8ui	a2, a3, 27
  90b098:	25301c        	l8ui	a5, a3, 28
  90b09b:	24301d        	l8ui	a4, a3, 29
  90b09e:	0c2c02        	or	a12, a2, a12
  90b0a1:	22301e        	l8ui	a2, a3, 30
  90b0a4:	085510        	slli	a5, a5, 24
  90b0a7:	004411        	slli	a4, a4, 16
  90b0aa:	054402        	or	a4, a4, a5
  90b0ad:	082211        	slli	a2, a2, 8
  90b0b0:	042202        	or	a2, a2, a4
  90b0b3:	24301f        	l8ui	a4, a3, 31
  90b0b6:	253020        	l8ui	a5, a3, 32
  90b0b9:	024202        	or	a2, a4, a2
  90b0bc:	243021        	l8ui	a4, a3, 33
  90b0bf:	293022        	l8ui	a9, a3, 34
  90b0c2:	085510        	slli	a5, a5, 24
  90b0c5:	004411        	slli	a4, a4, 16
  90b0c8:	054402        	or	a4, a4, a5
  90b0cb:	089911        	slli	a9, a9, 8
  90b0ce:	049902        	or	a9, a9, a4
  90b0d1:	243023        	l8ui	a4, a3, 35
  90b0d4:	2d3024        	l8ui	a13, a3, 36
  90b0d7:	253025        	l8ui	a5, a3, 37
  90b0da:	094902        	or	a9, a4, a9
  90b0dd:	243026        	l8ui	a4, a3, 38
  90b0e0:	08dd10        	slli	a13, a13, 24
  90b0e3:	005511        	slli	a5, a5, 16
  90b0e6:	0d5502        	or	a5, a5, a13
  90b0e9:	084411        	slli	a4, a4, 8
  90b0ec:	054402        	or	a4, a4, a5
  90b0ef:	253027        	l8ui	a5, a3, 39
  90b0f2:	2e3028        	l8ui	a14, a3, 40
  90b0f5:	2d3029        	l8ui	a13, a3, 41
  90b0f8:	045402        	or	a4, a5, a4
  90b0fb:	25302a        	l8ui	a5, a3, 42
  90b0fe:	08ee10        	slli	a14, a14, 24
  90b101:	00dd11        	slli	a13, a13, 16
  90b104:	23302b        	l8ui	a3, a3, 43
  90b107:	0edd02        	or	a13, a13, a14
  90b10a:	085511        	slli	a5, a5, 8
  90b10d:	0d5502        	or	a5, a5, a13
  90b110:	053502        	or	a5, a3, a5

	rx_stats->rs_status = 0;
  90b113:	c030      	movi.n	a3, 0
  90b115:	23640a        	s8i	a3, a6, 10
	rx_stats->rs_flags = 0;
  90b118:	23641a        	s8i	a3, a6, 26

	rx_stats->rs_datalen = ads.ds_rxstatus1 & AR_DataLen;
  90b11b:	0b034b        	extui	a3, a11, 0, 12
  90b11e:	236504        	s16i	a3, a6, 8
	rx_stats->rs_tstamp =  ads.AR_RcvTimestamp;
  90b121:	c030      	movi.n	a3, 0
  90b123:	9360      	s32i.n	a3, a6, 0
  90b125:	9c61      	s32i.n	a12, a6, 4

	/* XXX what about KeyCacheMiss? */
	rx_stats->rs_rssi_combined = 
		MS(ads.ds_rxstatus4, AR_RxRSSICombined);
  90b127:	098357        	extui	a3, a9, 24, 8

	rx_stats->rs_datalen = ads.ds_rxstatus1 & AR_DataLen;
	rx_stats->rs_tstamp =  ads.AR_RcvTimestamp;

	/* XXX what about KeyCacheMiss? */
	rx_stats->rs_rssi_combined = 
  90b12a:	23640c        	s8i	a3, a6, 12
		MS(ads.ds_rxstatus4, AR_RxRSSICombined);
	rx_stats->rs_rssi_ctl0 = MS(ads.ds_rxstatus0, AR_RxRSSIAnt00);
	rx_stats->rs_rssi_ctl1 = MS(ads.ds_rxstatus0, AR_RxRSSIAnt01);
  90b12d:	0a8347        	extui	a3, a10, 8, 8
  90b130:	23640e        	s8i	a3, a6, 14
	rx_stats->rs_rssi_ctl2 = MS(ads.ds_rxstatus0, AR_RxRSSIAnt02);
  90b133:	0a0357        	extui	a3, a10, 16, 8
  90b136:	23640f        	s8i	a3, a6, 15
	rx_stats->rs_rssi_ext0 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt10);
	rx_stats->rs_rssi_ext1 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt11);
  90b139:	098347        	extui	a3, a9, 8, 8
  90b13c:	236411        	s8i	a3, a6, 17
	rx_stats->rs_rssi_ext2 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt12);
  90b13f:	090357        	extui	a3, a9, 16, 8
  90b142:	236412        	s8i	a3, a6, 18
	rx_stats->rs_tstamp =  ads.AR_RcvTimestamp;

	/* XXX what about KeyCacheMiss? */
	rx_stats->rs_rssi_combined = 
		MS(ads.ds_rxstatus4, AR_RxRSSICombined);
	rx_stats->rs_rssi_ctl0 = MS(ads.ds_rxstatus0, AR_RxRSSIAnt00);
  90b145:	2a640d        	s8i	a10, a6, 13
	rx_stats->rs_rssi_ctl1 = MS(ads.ds_rxstatus0, AR_RxRSSIAnt01);
	rx_stats->rs_rssi_ctl2 = MS(ads.ds_rxstatus0, AR_RxRSSIAnt02);
	rx_stats->rs_rssi_ext0 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt10);
  90b148:	296410        	s8i	a9, a6, 16
	rx_stats->rs_rssi_ext1 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt11);
	rx_stats->rs_rssi_ext2 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt12);
	if (ads.ds_rxstatus8 & AR_RxKeyIdxValid)
		rx_stats->rs_keyix = MS(ads.ds_rxstatus8, AR_KeyIdx);
  90b14b:	089346        	extui	a3, a8, 9, 7
	rx_stats->rs_rssi_ctl1 = MS(ads.ds_rxstatus0, AR_RxRSSIAnt01);
	rx_stats->rs_rssi_ctl2 = MS(ads.ds_rxstatus0, AR_RxRSSIAnt02);
	rx_stats->rs_rssi_ext0 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt10);
	rx_stats->rs_rssi_ext1 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt11);
	rx_stats->rs_rssi_ext2 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt12);
	if (ads.ds_rxstatus8 & AR_RxKeyIdxValid)
  90b14e:	778f02        	bbsi	a8, 23, 90b154 <ar5416ProcRxDescFast_20+0x150>
		rx_stats->rs_keyix = MS(ads.ds_rxstatus8, AR_KeyIdx);
	else
		rx_stats->rs_keyix = HAL_RXKEYIX_INVALID;
  90b151:	23faff        	movi	a3, -1
  90b154:	236413        	s8i	a3, a6, 19
	/* NB: caller expected to do rate table mapping */
	rx_stats->rs_rate = RXSTATUS_RATE(ah, (&ads));
	rx_stats->rs_more = (ads.ds_rxstatus1 & AR_RxMore) ? 1 : 0;

	rx_stats->rs_isaggr = (ads.ds_rxstatus8 & AR_RxAggr) ? 1 : 0;
  90b157:	081350        	extui	a3, a8, 17, 1
  90b15a:	236417        	s8i	a3, a6, 23
	rx_stats->rs_moreaggr = (ads.ds_rxstatus8 & AR_RxMoreAggr) ? 1 : 0;
  90b15d:	080350        	extui	a3, a8, 16, 1
	if (ads.ds_rxstatus8 & AR_RxKeyIdxValid)
		rx_stats->rs_keyix = MS(ads.ds_rxstatus8, AR_KeyIdx);
	else
		rx_stats->rs_keyix = HAL_RXKEYIX_INVALID;
	/* NB: caller expected to do rate table mapping */
	rx_stats->rs_rate = RXSTATUS_RATE(ah, (&ads));
  90b160:	0a8a57        	extui	a10, a10, 24, 8
	rx_stats->rs_more = (ads.ds_rxstatus1 & AR_RxMore) ? 1 : 0;
  90b163:	0bcb40        	extui	a11, a11, 12, 1

	rx_stats->rs_isaggr = (ads.ds_rxstatus8 & AR_RxAggr) ? 1 : 0;
	rx_stats->rs_moreaggr = (ads.ds_rxstatus8 & AR_RxMoreAggr) ? 1 : 0;
  90b166:	236418        	s8i	a3, a6, 24
	rx_stats->rs_flags  |= (ads.ds_rxstatus3 & AR_GI) ? HAL_RX_GI : 0;
	rx_stats->rs_flags  |= (ads.ds_rxstatus3 & AR_2040) ? HAL_RX_2040 : 0;
  90b169:	c032      	movi.n	a3, 2
	if (ads.ds_rxstatus8 & AR_RxKeyIdxValid)
		rx_stats->rs_keyix = MS(ads.ds_rxstatus8, AR_KeyIdx);
	else
		rx_stats->rs_keyix = HAL_RXKEYIX_INVALID;
	/* NB: caller expected to do rate table mapping */
	rx_stats->rs_rate = RXSTATUS_RATE(ah, (&ads));
  90b16b:	2a6414        	s8i	a10, a6, 20
	rx_stats->rs_more = (ads.ds_rxstatus1 & AR_RxMore) ? 1 : 0;
  90b16e:	2b6416        	s8i	a11, a6, 22

	rx_stats->rs_isaggr = (ads.ds_rxstatus8 & AR_RxAggr) ? 1 : 0;
	rx_stats->rs_moreaggr = (ads.ds_rxstatus8 & AR_RxMoreAggr) ? 1 : 0;
	rx_stats->rs_flags  |= (ads.ds_rxstatus3 & AR_GI) ? HAL_RX_GI : 0;
  90b171:	020a40        	extui	a10, a2, 0, 1
	rx_stats->rs_flags  |= (ads.ds_rxstatus3 & AR_2040) ? HAL_RX_2040 : 0;
  90b174:	c0b0      	movi.n	a11, 0
  90b176:	032201        	and	a2, a2, a3
  90b179:	c038      	movi.n	a3, 8
	rx_stats->rs_rate = RXSTATUS_RATE(ah, (&ads));
	rx_stats->rs_more = (ads.ds_rxstatus1 & AR_RxMore) ? 1 : 0;

	rx_stats->rs_isaggr = (ads.ds_rxstatus8 & AR_RxAggr) ? 1 : 0;
	rx_stats->rs_moreaggr = (ads.ds_rxstatus8 & AR_RxMoreAggr) ? 1 : 0;
	rx_stats->rs_flags  |= (ads.ds_rxstatus3 & AR_GI) ? HAL_RX_GI : 0;
  90b17b:	0eaa11        	slli	a10, a10, 2
	rx_stats->rs_flags  |= (ads.ds_rxstatus3 & AR_2040) ? HAL_RX_2040 : 0;
  90b17e:	02b338        	moveqz	a3, a11, a2
  90b181:	0a3302        	or	a3, a3, a10

	if (ads.ds_rxstatus8 & AR_PreDelimCRCErr)
  90b184:	798f02        	bbsi	a8, 25, 90b18a <ar5416ProcRxDescFast_20+0x186>
  90b187:	600004        	j	90b18f <ar5416ProcRxDescFast_20+0x18b>
		rx_stats->rs_flags |= HAL_RX_DELIM_CRC_PRE;
  90b18a:	c120      	movi.n	a2, 16
  90b18c:	023302        	or	a3, a3, a2
  90b18f:	23641a        	s8i	a3, a6, 26
	if (ads.ds_rxstatus8 & AR_PostDelimCRCErr)
  90b192:	7d860a        	bbci	a8, 13, 90b1a0 <ar5416ProcRxDescFast_20+0x19c>
		rx_stats->rs_flags |= HAL_RX_DELIM_CRC_POST;
  90b195:	23601a        	l8ui	a3, a6, 26
  90b198:	c220      	movi.n	a2, 32
  90b19a:	023202        	or	a2, a3, a2
  90b19d:	22641a        	s8i	a2, a6, 26
	if (ads.ds_rxstatus8 & AR_DecryptBusyErr)
  90b1a0:	71860a        	bbci	a8, 1, 90b1ae <ar5416ProcRxDescFast_20+0x1aa>
		rx_stats->rs_flags |= HAL_RX_DECRYPT_BUSY;
  90b1a3:	23601a        	l8ui	a3, a6, 26
  90b1a6:	c420      	movi.n	a2, 64
  90b1a8:	023202        	or	a2, a3, a2
  90b1ab:	22641a        	s8i	a2, a6, 26

	if ((ads.ds_rxstatus8 & AR_RxFrameOK) == 0) {
  90b1ae:	c032      	movi.n	a3, 2
  90b1b0:	73882f        	bany	a8, a3, 90b1e3 <ar5416ProcRxDescFast_20+0x1df>
		 * when a CRC error is detected, but these are specious.
		 * Consequently we filter them out here so we don't
		 * confuse and/or complicate drivers.
		 */
		if (ads.ds_rxstatus8 & AR_CRCErr)
			rx_stats->rs_status |= HAL_RXERR_CRC;
  90b1b3:	c021      	movi.n	a2, 1
		 * indicates however that you can also get Michael errors
		 * when a CRC error is detected, but these are specious.
		 * Consequently we filter them out here so we don't
		 * confuse and/or complicate drivers.
		 */
		if (ads.ds_rxstatus8 & AR_CRCErr)
  90b1b5:	7d8f27        	bbsi	a8, 29, 90b1e0 <ar5416ProcRxDescFast_20+0x1dc>
			rx_stats->rs_status |= HAL_RXERR_CRC;
		else if (ads.ds_rxstatus8 & AR_PHYErr) {
  90b1b8:	c120      	movi.n	a2, 16
  90b1ba:	728012        	bnone	a8, a2, 90b1d0 <ar5416ProcRxDescFast_20+0x1cc>
			a_uint32_t phyerr;

			rx_stats->rs_status |= HAL_RXERR_PHY;
			phyerr = MS(ads.ds_rxstatus8, AR_PHYErrCode);
  90b1bd:	126ab1        	l32r	a2, 8e5c84 <vdesc_module_install+0xc74>
		if (ads.ds_rxstatus8 & AR_CRCErr)
			rx_stats->rs_status |= HAL_RXERR_CRC;
		else if (ads.ds_rxstatus8 & AR_PHYErr) {
			a_uint32_t phyerr;

			rx_stats->rs_status |= HAL_RXERR_PHY;
  90b1c0:	23640a        	s8i	a3, a6, 10
			phyerr = MS(ads.ds_rxstatus8, AR_PHYErrCode);
  90b1c3:	028801        	and	a8, a8, a2
  90b1c6:	088814        	srli	a8, a8, 8
			rx_stats->rs_phyerr = phyerr;
  90b1c9:	28640b        	s8i	a8, a6, 11
  90b1cc:	600013        	j	90b1e3 <ar5416ProcRxDescFast_20+0x1df>
  90b1cf:	00c038        	moveqz	a0, a12, a0
		} else if (ads.ds_rxstatus8 & AR_DecryptCRCErr)
  90b1d2:	738007        	bnone	a8, a3, 90b1dd <ar5416ProcRxDescFast_20+0x1d9>
			rx_stats->rs_status |= HAL_RXERR_DECRYPT;
  90b1d5:	23640a        	s8i	a3, a6, 10
  90b1d8:	600007        	j	90b1e3 <ar5416ProcRxDescFast_20+0x1df>
  90b1db:	00007a        	excw
		else if (ads.ds_rxstatus8 & AR_MichaelErr)
  90b1de:	8702      	l32i.n	a7, a0, 8
			rx_stats->rs_status |= HAL_RXERR_MIC;
  90b1e0:	22640a        	s8i	a2, a6, 10
	}
	rx_stats->evm0=ads.AR_RxEVM0;
  90b1e3:	9967      	s32i.n	a9, a6, 28
	rx_stats->evm1=ads.AR_RxEVM1;
  90b1e5:	9468      	s32i.n	a4, a6, 32
	rx_stats->evm2=ads.AR_RxEVM2;
  90b1e7:	9569      	s32i.n	a5, a6, 36

	return HAL_OK;
  90b1e9:	220a00        	movi	a2, 0
}
  90b1ec:	d10f      	retw.n
	...

0090b1f0 <ar5416UpdateTxTrigLevel>:
/******/
/* TX */
/******/

HAL_BOOL ar5416UpdateTxTrigLevel(struct ath_hal *ah, HAL_BOOL bIncTrigLevel)
{
  90b1f0:	6c1004        	entry	a1, 32
        HAL_INT omask;

        /*
         * Disable interrupts while futzing with the fifo level.
         */
        omask = ar5416SetInterrupts(ah, ahp->ah_maskReg &~ HAL_INT_GLOBAL);
  90b1f3:	146ab2        	l32r	a4, 8e5cbc <vdesc_module_install+0xcac>
  90b1f6:	2b2236        	l32i	a11, a2, 216
  90b1f9:	da20      	mov.n	a10, a2
  90b1fb:	04bb01        	and	a11, a11, a4
  90b1fe:	5bff27        	call8	90ae9c <ar5416SetInterrupts>
  90b201:	146ab3        	l32r	a4, 8e5cd0 <vdesc_module_install+0xcc0>
  90b204:	dba0      	mov.n	a11, a10
  90b206:	0c0200        	memw
  90b209:	8840      	l32i.n	a8, a4, 0

	txcfg = ioread32_mac(AR_TXCFG);
        curLevel = MS(txcfg, AR_FTRIG);
  90b20b:	084445        	extui	a4, a8, 4, 6
        newLevel = curLevel;

        if (bIncTrigLevel)  {
  90b20e:	c83a      	beqz.n	a3, 90b21c <ar5416UpdateTxTrigLevel+0x2c>
		if (curLevel < MAX_TX_FIFO_THRESHOLD)
  90b210:	c39f      	movi.n	a9, 63
  90b212:	d340      	mov.n	a3, a4
  90b214:	794128        	beq	a4, a9, 90b240 <ar5416UpdateTxTrigLevel+0x50>
			newLevel ++;
  90b217:	b143      	addi.n	a3, a4, 1
  90b219:	600006        	j	90b223 <ar5416UpdateTxTrigLevel+0x33>
        } else if (curLevel > MIN_TX_FIFO_THRESHOLD)
  90b21c:	d340      	mov.n	a3, a4
  90b21e:	6e421e        	bltui	a4, 2, 90b240 <ar5416UpdateTxTrigLevel+0x50>
                newLevel--;
  90b221:	b043      	addi.n	a3, a4, -1
        if (newLevel != curLevel)
  90b223:	743119        	beq	a3, a4, 90b240 <ar5416UpdateTxTrigLevel+0x50>
		iowrite32_mac(AR_TXCFG,
  90b226:	0c3a11        	slli	a10, a3, 4
  90b229:	293af0        	movi	a9, 0x3f0
  90b22c:	09a901        	and	a9, a10, a9
  90b22f:	2aca0f        	movi	a10, 0xfffffc0f
  90b232:	0a8801        	and	a8, a8, a10
  90b235:	089802        	or	a8, a9, a8
  90b238:	196ab3        	l32r	a9, 8e5d04 <vdesc_module_install+0xcf4>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90b23b:	0c0200        	memw
  90b23e:	9890      	s32i.n	a8, a9, 0
			     (txcfg & ~AR_FTRIG) | SM(newLevel, AR_FTRIG));

        /* re-enable chip interrupts */
        ar5416SetInterrupts(ah, omask);
  90b240:	da20      	mov.n	a10, a2
  90b242:	5bff16        	call8	90ae9c <ar5416SetInterrupts>

        return (newLevel != curLevel);
  90b245:	04340c        	sub	a4, a3, a4
  90b248:	c081      	movi.n	a8, 1
  90b24a:	c020      	movi.n	a2, 0
  90b24c:	048239        	movnez	a2, a8, a4
}
  90b24f:	d10f      	retw.n
  90b251:	000000        	ill

0090b254 <ar5416SetTxDP>:

HAL_BOOL ar5416SetTxDP(struct ath_hal *ah, a_uint32_t q, a_uint32_t txdp)
{
  90b254:	6c1004        	entry	a1, 32
         * Make sure that TXE is deasserted before setting the TXDP.  If TXE
         * is still asserted, setting TXDP will have no effect.
         */
	HALASSERT((ioread32_mac(AR_Q_TXE) & (1 << q)) == 0);

	iowrite32_mac(AR_QTXDP(q), txdp);
  90b257:	186ab4        	l32r	a8, 8e5d28 <vdesc_module_install+0xd18>

        return AH_TRUE;
}
  90b25a:	c021      	movi.n	a2, 1
         * Make sure that TXE is deasserted before setting the TXDP.  If TXE
         * is still asserted, setting TXDP will have no effect.
         */
	HALASSERT((ioread32_mac(AR_Q_TXE) & (1 << q)) == 0);

	iowrite32_mac(AR_QTXDP(q), txdp);
  90b25c:	08330a        	addx4	a3, a3, a8
  90b25f:	0c0200        	memw
  90b262:	9430      	s32i.n	a4, a3, 0

        return AH_TRUE;
}
  90b264:	d10f      	retw.n
	...

0090b268 <ar5416StartTxDma>:

HAL_BOOL ar5416StartTxDma(struct ath_hal *ah, a_uint32_t q)
{
  90b268:	6c1004        	entry	a1, 32
        HALASSERT(AH5416(ah)->ah_txq[q].tqi_type != HAL_TX_QUEUE_INACTIVE);

        /* Check to be sure we're not enabling a q that has its TXD bit set. */
	HALASSERT((ioread32_mac(AR_Q_TXD) & (1 << q)) == 0);

	iowrite32_mac(AR_Q_TXE, 1 << q);
  90b26b:	c021      	movi.n	a2, 1
  90b26d:	186ab5        	l32r	a8, 8e5d44 <vdesc_module_install+0xd34>
  90b270:	003104        	ssl	a3
  90b273:	00231a        	sll	a3, a2
  90b276:	0c0200        	memw
  90b279:	9380      	s32i.n	a3, a8, 0

        return AH_TRUE;
}
  90b27b:	d10f      	retw.n
  90b27d:	000000        	ill

0090b280 <ar5416NumTxPending>:

a_uint32_t ar5416NumTxPending(struct ath_hal *ah, a_uint32_t q)
{
  90b280:	6c1004        	entry	a1, 32
        a_uint32_t npend;

        HALASSERT(q < AH_PRIVATE(ah)->ah_caps.halTotalQueues);
        HALASSERT(AH5416(ah)->ah_txq[q].tqi_type != HAL_TX_QUEUE_INACTIVE);

	npend = ioread32_mac(AR_QSTS(q))
  90b283:	126ab6        	l32r	a2, 8e5d5c <vdesc_module_install+0xd4c>
  90b286:	02320a        	addx4	a2, a3, a2
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90b289:	0c0200        	memw
  90b28c:	8220      	l32i.n	a2, a2, 0
  90b28e:	020241        	extui	a2, a2, 0, 2
		& AR_Q_STS_PEND_FR_CNT;
        if (npend == 0) {
  90b291:	cd24      	bnez.n	a2, 90b2a9 <ar5416NumTxPending+0x29>
  90b293:	186ab5        	l32r	a8, 8e5d68 <vdesc_module_install+0xd58>
  90b296:	0c0200        	memw
  90b299:	8980      	l32i.n	a9, a8, 0
                /*
                 * Pending frame count (PFC) can momentarily go to zero
                 * while TXE remains asserted.  In other words a PFC of
                 * zero is not sufficient to say that the queue has stopped.
                 */
		if (ioread32_mac(AR_Q_TXE) & (1 << q))
  90b29b:	c081      	movi.n	a8, 1
  90b29d:	003104        	ssl	a3
  90b2a0:	00831a        	sll	a3, a8
  90b2a3:	093301        	and	a3, a3, a9
  90b2a6:	038239        	movnez	a2, a8, a3
			iowrite32_mac(AR_Q_RDYTIMESHDN, 1 << q);
                }
        }
#endif
        return npend;
}
  90b2a9:	d10f      	retw.n
	...

0090b2ac <ar5416SetupTxDesc_20>:
			      a_uint32_t txRate0, a_uint32_t txTries0,
			      a_uint32_t keyIx,
			      a_uint32_t flags,
			      a_uint32_t rtsctsRate,
			      a_uint32_t rtsctsDuration)
{
  90b2ac:	6c1004        	entry	a1, 32
  90b2af:	d820      	mov.n	a8, a2

        struct ar5416_desc *ads = AR5416DESC(ds);

        (void) hdrLen;

        ads->ds_txstatus9 &= ~AR_TxDone;
  90b2b1:	2b205c        	l8ui	a11, a2, 92
  90b2b4:	22205d        	l8ui	a2, a2, 93
  90b2b7:	2a805e        	l8ui	a10, a8, 94
  90b2ba:	08bb10        	slli	a11, a11, 24
  90b2bd:	002211        	slli	a2, a2, 16
  90b2c0:	0b2202        	or	a2, a2, a11
  90b2c3:	08aa11        	slli	a10, a10, 8
  90b2c6:	02aa02        	or	a10, a10, a2
  90b2c9:	22805f        	l8ui	a2, a8, 95
			      a_uint32_t txRate0, a_uint32_t txTries0,
			      a_uint32_t keyIx,
			      a_uint32_t flags,
			      a_uint32_t rtsctsRate,
			      a_uint32_t rtsctsDuration)
{
  90b2cc:	891a      	l32i.n	a9, a1, 40

        struct ar5416_desc *ads = AR5416DESC(ds);

        (void) hdrLen;

        ads->ds_txstatus9 &= ~AR_TxDone;
  90b2ce:	0a2a02        	or	a10, a2, a10
  90b2d1:	c72e      	movi.n	a2, -2
  90b2d3:	02aa01        	and	a10, a10, a2
  90b2d6:	0a8257        	extui	a2, a10, 24, 8
  90b2d9:	22845c        	s8i	a2, a8, 92
  90b2dc:	0a0257        	extui	a2, a10, 16, 8
  90b2df:	22845d        	s8i	a2, a8, 93
  90b2e2:	0a8247        	extui	a2, a10, 8, 8
  90b2e5:	22845e        	s8i	a2, a8, 94

        if (txPower > 63)
		txPower=63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
		| (txPower << AR_XmitPower_S)
  90b2e8:	c32f      	movi.n	a2, 63
  90b2ea:	026636        	minu	a6, a6, a2
        HALASSERT((flags & RTSCTS) != RTSCTS);

        if (txPower > 63)
		txPower=63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
  90b2ed:	03034b        	extui	a3, a3, 0, 12
		| (txPower << AR_XmitPower_S)
  90b2f0:	006211        	slli	a2, a6, 16
  90b2f3:	032202        	or	a2, a2, a3
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
  90b2f6:	c2b0      	movi.n	a11, 32
  90b2f8:	136aa6        	l32r	a3, 8e5d90 <vdesc_module_install+0xd80>

        struct ar5416_desc *ads = AR5416DESC(ds);

        (void) hdrLen;

        ads->ds_txstatus9 &= ~AR_TxDone;
  90b2fb:	2a845f        	s8i	a10, a8, 95
        if (txPower > 63)
		txPower=63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
		| (txPower << AR_XmitPower_S)
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
  90b2fe:	0b9b01        	and	a11, a9, a11
  90b301:	c0a0      	movi.n	a10, 0
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
  90b303:	1e6ab7        	l32r	a14, 8e5de0 <vdesc_module_install+0xdd0>
        if (txPower > 63)
		txPower=63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
		| (txPower << AR_XmitPower_S)
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
  90b306:	0ba338        	moveqz	a3, a10, a11
  90b309:	032b02        	or	a11, a2, a3
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
  90b30c:	090340        	extui	a3, a9, 0, 1
  90b30f:	d2a0      	mov.n	a2, a10
  90b311:	03e239        	movnez	a2, a14, a3
  90b314:	02bb02        	or	a11, a11, a2
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0);
  90b317:	136ab8        	l32r	a3, 8e5df8 <vdesc_module_install+0xde8>
  90b31a:	c120      	movi.n	a2, 16
  90b31c:	029c01        	and	a12, a9, a2
  90b31f:	0ca338        	moveqz	a3, a10, a12
  90b322:	03bb02        	or	a11, a11, a3
        HALASSERT((flags & RTSCTS) != RTSCTS);

        if (txPower > 63)
		txPower=63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
  90b325:	0b8357        	extui	a3, a11, 24, 8
  90b328:	238408        	s8i	a3, a8, 8
  90b32b:	0b0357        	extui	a3, a11, 16, 8
  90b32e:	238409        	s8i	a3, a8, 9
  90b331:	0b8347        	extui	a3, a11, 8, 8
  90b334:	23840a        	s8i	a3, a8, 10
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0);

        ads->ds_ctl1 = (type << AR_FrameType_S)
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0);
  90b337:	c032      	movi.n	a3, 2
  90b339:	039c01        	and	a12, a9, a3
  90b33c:	0cae38        	moveqz	a14, a10, a12
		| (txPower << AR_XmitPower_S)
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0);

        ads->ds_ctl1 = (type << AR_FrameType_S)
  90b33f:	0c5510        	slli	a5, a5, 20
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0);
  90b342:	05ec02        	or	a12, a14, a5
		| (txPower << AR_XmitPower_S)
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0);

        ads->ds_ctl1 = (type << AR_FrameType_S)
  90b345:	0c8457        	extui	a4, a12, 24, 8
  90b348:	24840c        	s8i	a4, a8, 12
  90b34b:	0c0457        	extui	a4, a12, 16, 8
  90b34e:	24840d        	s8i	a4, a8, 13
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0);
        ads->ds_ctl2 = SM(txTries0, AR_XmitDataTries0);
  90b351:	8e18      	l32i.n	a14, a1, 32
		| (txPower << AR_XmitPower_S)
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0);

        ads->ds_ctl1 = (type << AR_FrameType_S)
  90b353:	0c8447        	extui	a4, a12, 8, 8
  90b356:	24840e        	s8i	a4, a8, 14
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0);
        ads->ds_ctl2 = SM(txTries0, AR_XmitDataTries0);
  90b359:	146aba        	l32r	a4, 8e5e44 <vdesc_module_install+0xe34>
  90b35c:	002104        	ssl	a2
  90b35f:	00ee1a        	sll	a14, a14
  90b362:	04ee01        	and	a14, a14, a4
  90b365:	0e8457        	extui	a4, a14, 24, 8
  90b368:	248410        	s8i	a4, a8, 16
  90b36b:	0e0457        	extui	a4, a14, 16, 8
  90b36e:	248411        	s8i	a4, a8, 17
        ads->ds_ctl3 = (txRate0 << AR_XmitRate0_S);
  90b371:	078457        	extui	a4, a7, 24, 8
  90b374:	248414        	s8i	a4, a8, 20
  90b377:	070457        	extui	a4, a7, 16, 8
  90b37a:	248415        	s8i	a4, a8, 21
  90b37d:	078447        	extui	a4, a7, 8, 8
        HALASSERT((flags & RTSCTS) != RTSCTS);

        if (txPower > 63)
		txPower=63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
  90b380:	2b840b        	s8i	a11, a8, 11
		| (txPower << AR_XmitPower_S)
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0);

        ads->ds_ctl1 = (type << AR_FrameType_S)
  90b383:	2c840f        	s8i	a12, a8, 15
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0);
        ads->ds_ctl2 = SM(txTries0, AR_XmitDataTries0);
  90b386:	2a8412        	s8i	a10, a8, 18
  90b389:	2a8413        	s8i	a10, a8, 19
        ads->ds_ctl3 = (txRate0 << AR_XmitRate0_S);
  90b38c:	248416        	s8i	a4, a8, 22
  90b38f:	278417        	s8i	a7, a8, 23

        ads->ds_ctl7 = SM(AR5416_LEGACY_CHAINMASK, AR_ChainSel0) 
  90b392:	2a8424        	s8i	a10, a8, 36
			      a_uint32_t txRate0, a_uint32_t txTries0,
			      a_uint32_t keyIx,
			      a_uint32_t flags,
			      a_uint32_t rtsctsRate,
			      a_uint32_t rtsctsDuration)
{
  90b395:	8f19      	l32i.n	a15, a1, 36
  90b397:	2d120b        	l32i	a13, a1, 44
        ads->ds_ctl1 = (type << AR_FrameType_S)
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0);
        ads->ds_ctl2 = SM(txTries0, AR_XmitDataTries0);
        ads->ds_ctl3 = (txRate0 << AR_XmitRate0_S);

        ads->ds_ctl7 = SM(AR5416_LEGACY_CHAINMASK, AR_ChainSel0) 
  90b39a:	238425        	s8i	a3, a8, 37
  90b39d:	228426        	s8i	a2, a8, 38
  90b3a0:	22fa84        	movi	a2, -124
  90b3a3:	228427        	s8i	a2, a8, 39
		| SM(AR5416_LEGACY_CHAINMASK, AR_ChainSel1)
		| SM(AR5416_LEGACY_CHAINMASK, AR_ChainSel2) 
		| SM(AR5416_LEGACY_CHAINMASK, AR_ChainSel3);

        if (keyIx != HAL_TXKEYIX_INVALID) {
  90b3a6:	220aff        	movi	a2, 255
  90b3a9:	72f13b        	beq	a15, a2, 90b3e8 <ar5416SetupTxDesc_20+0x13c>
                /* XXX validate key index */
                ads->ds_ctl1 |= SM(keyIx, AR_DestIdx);
  90b3ac:	126abb        	l32r	a2, 8e5e98 <vdesc_module_install+0xe88>
  90b3af:	03ff11        	slli	a15, a15, 13
  90b3b2:	02ff01        	and	a15, a15, a2
  90b3b5:	0fcc02        	or	a12, a12, a15
  90b3b8:	0c8257        	extui	a2, a12, 24, 8
  90b3bb:	22840c        	s8i	a2, a8, 12
  90b3be:	0c0257        	extui	a2, a12, 16, 8
  90b3c1:	22840d        	s8i	a2, a8, 13
  90b3c4:	0c8247        	extui	a2, a12, 8, 8
  90b3c7:	22840e        	s8i	a2, a8, 14
                ads->ds_ctl0 |= AR_DestIdxValid;
  90b3ca:	126abc        	l32r	a2, 8e5ebc <vdesc_module_install+0xeac>
		| SM(AR5416_LEGACY_CHAINMASK, AR_ChainSel2) 
		| SM(AR5416_LEGACY_CHAINMASK, AR_ChainSel3);

        if (keyIx != HAL_TXKEYIX_INVALID) {
                /* XXX validate key index */
                ads->ds_ctl1 |= SM(keyIx, AR_DestIdx);
  90b3cd:	2c840f        	s8i	a12, a8, 15
                ads->ds_ctl0 |= AR_DestIdxValid;
  90b3d0:	02bb02        	or	a11, a11, a2
  90b3d3:	0b8257        	extui	a2, a11, 24, 8
  90b3d6:	228408        	s8i	a2, a8, 8
  90b3d9:	0b0257        	extui	a2, a11, 16, 8
  90b3dc:	228409        	s8i	a2, a8, 9
  90b3df:	0b8247        	extui	a2, a11, 8, 8
  90b3e2:	22840a        	s8i	a2, a8, 10
  90b3e5:	2b840b        	s8i	a11, a8, 11
        }

        if (flags & RTSCTS) {
  90b3e8:	c03c      	movi.n	a3, 12
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
                ads->ds_ctl2 |= SM(rtsctsDuration, AR_BurstDur);
                ads->ds_ctl3 |= (rtsctsRate << AR_RTSCTSRate_S);
        }
        return AH_TRUE;
  90b3ea:	c021      	movi.n	a2, 1
                /* XXX validate key index */
                ads->ds_ctl1 |= SM(keyIx, AR_DestIdx);
                ads->ds_ctl0 |= AR_DestIdxValid;
        }

        if (flags & RTSCTS) {
  90b3ec:	739802        	bany	a9, a3, 90b3f2 <ar5416SetupTxDesc_20+0x146>
  90b3ef:	60009d        	j	90b490 <ar5416SetupTxDesc_20+0x1e4>
                if (!isValidTxRate(rtsctsRate)) {
  90b3f2:	1a6abd        	l32r	a10, 8e5ee8 <vdesc_module_install+0xed8>
  90b3f5:	00d004        	ssr	a13
  90b3f8:	0a0a1b        	sra	a10, a10
  90b3fb:	02aa01        	and	a10, a10, a2
  90b3fe:	64a08c        	beqz	a10, 90b48e <ar5416SetupTxDesc_20+0x1e2>
                        return AH_FALSE;
                }
                /* XXX validate rtsctsDuration */
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
  90b401:	2a8008        	l8ui	a10, a8, 8
  90b404:	2b8009        	l8ui	a11, a8, 9
  90b407:	23800a        	l8ui	a3, a8, 10
  90b40a:	08aa10        	slli	a10, a10, 24
  90b40d:	00bb11        	slli	a11, a11, 16
  90b410:	0abb02        	or	a11, a11, a10
  90b413:	083311        	slli	a3, a3, 8
  90b416:	2a800b        	l8ui	a10, a8, 11
  90b419:	0b3302        	or	a3, a3, a11
  90b41c:	03a302        	or	a3, a10, a3
  90b41f:	1c6a0e        	l32r	a12, 8e5c58 <vdesc_module_install+0xc48>
  90b422:	c0a8      	movi.n	a10, 8
  90b424:	0a9a01        	and	a10, a9, a10
  90b427:	c0b0      	movi.n	a11, 0
  90b429:	0abc38        	moveqz	a12, a11, a10
  90b42c:	dac0      	mov.n	a10, a12
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
  90b42e:	c0c4      	movi.n	a12, 4
  90b430:	0c9901        	and	a9, a9, a12
  90b433:	1c6ab9        	l32r	a12, 8e5f18 <vdesc_module_install+0xf08>
  90b436:	03aa02        	or	a10, a10, a3
  90b439:	09cb39        	movnez	a11, a12, a9
        if (flags & RTSCTS) {
                if (!isValidTxRate(rtsctsRate)) {
                        return AH_FALSE;
                }
                /* XXX validate rtsctsDuration */
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
  90b43c:	0baa02        	or	a10, a10, a11
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
                ads->ds_ctl2 |= SM(rtsctsDuration, AR_BurstDur);
  90b43f:	891c      	l32i.n	a9, a1, 48
        if (flags & RTSCTS) {
                if (!isValidTxRate(rtsctsRate)) {
                        return AH_FALSE;
                }
                /* XXX validate rtsctsDuration */
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
  90b441:	0a8357        	extui	a3, a10, 24, 8
  90b444:	238408        	s8i	a3, a8, 8
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
                ads->ds_ctl2 |= SM(rtsctsDuration, AR_BurstDur);
  90b447:	09094e        	extui	a9, a9, 0, 15
        if (flags & RTSCTS) {
                if (!isValidTxRate(rtsctsRate)) {
                        return AH_FALSE;
                }
                /* XXX validate rtsctsDuration */
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
  90b44a:	0a0357        	extui	a3, a10, 16, 8
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
                ads->ds_ctl2 |= SM(rtsctsDuration, AR_BurstDur);
  90b44d:	0e9902        	or	a9, a9, a14
        if (flags & RTSCTS) {
                if (!isValidTxRate(rtsctsRate)) {
                        return AH_FALSE;
                }
                /* XXX validate rtsctsDuration */
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
  90b450:	238409        	s8i	a3, a8, 9
  90b453:	0a8347        	extui	a3, a10, 8, 8
  90b456:	23840a        	s8i	a3, a8, 10
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
                ads->ds_ctl2 |= SM(rtsctsDuration, AR_BurstDur);
  90b459:	098357        	extui	a3, a9, 24, 8
  90b45c:	238410        	s8i	a3, a8, 16
                ads->ds_ctl3 |= (rtsctsRate << AR_RTSCTSRate_S);
  90b45f:	0cdd10        	slli	a13, a13, 20
                        return AH_FALSE;
                }
                /* XXX validate rtsctsDuration */
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
                ads->ds_ctl2 |= SM(rtsctsDuration, AR_BurstDur);
  90b462:	090357        	extui	a3, a9, 16, 8
                ads->ds_ctl3 |= (rtsctsRate << AR_RTSCTSRate_S);
  90b465:	07d702        	or	a7, a13, a7
                        return AH_FALSE;
                }
                /* XXX validate rtsctsDuration */
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
                ads->ds_ctl2 |= SM(rtsctsDuration, AR_BurstDur);
  90b468:	238411        	s8i	a3, a8, 17
  90b46b:	098346        	extui	a3, a9, 8, 7
  90b46e:	238412        	s8i	a3, a8, 18
                ads->ds_ctl3 |= (rtsctsRate << AR_RTSCTSRate_S);
  90b471:	078357        	extui	a3, a7, 24, 8
  90b474:	238414        	s8i	a3, a8, 20
  90b477:	070357        	extui	a3, a7, 16, 8
  90b47a:	238415        	s8i	a3, a8, 21
  90b47d:	078347        	extui	a3, a7, 8, 8
        if (flags & RTSCTS) {
                if (!isValidTxRate(rtsctsRate)) {
                        return AH_FALSE;
                }
                /* XXX validate rtsctsDuration */
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
  90b480:	2a840b        	s8i	a10, a8, 11
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
                ads->ds_ctl2 |= SM(rtsctsDuration, AR_BurstDur);
  90b483:	298413        	s8i	a9, a8, 19
                ads->ds_ctl3 |= (rtsctsRate << AR_RTSCTSRate_S);
  90b486:	238416        	s8i	a3, a8, 22
  90b489:	278417        	s8i	a7, a8, 23
  90b48c:	d10f      	retw.n
                ads->ds_ctl0 |= AR_DestIdxValid;
        }

        if (flags & RTSCTS) {
                if (!isValidTxRate(rtsctsRate)) {
                        return AH_FALSE;
  90b48e:	d2a0      	mov.n	a2, a10
                ads->ds_ctl3 |= (rtsctsRate << AR_RTSCTSRate_S);
        }
        return AH_TRUE;

#undef RTSCTS
}
  90b490:	d10f      	retw.n
	...

0090b494 <ar5416FillTxDesc_20>:

HAL_BOOL ar5416FillTxDesc_20(struct ath_tx_desc *ds,
			     a_uint32_t segLen, HAL_BOOL firstSeg, HAL_BOOL lastSeg,
			     const struct ath_tx_desc *ds0)
{
  90b494:	6c1004        	entry	a1, 32
        struct ar5416_desc *ads = AR5416DESC(ds);

        HALASSERT((segLen &~ AR_BufLen) == 0);

        if (firstSeg) {
  90b497:	644045        	beqz	a4, 90b4e0 <ar5416FillTxDesc_20+0x4c>
                /*
                 * First descriptor, don't clobber xmit control data
                 * setup by ar5416SetupTxDesc.
                 */
                ads->ds_ctl1 |= segLen | (lastSeg ? 0 : AR_TxMore);
  90b49a:	28200c        	l8ui	a8, a2, 12
  90b49d:	24200d        	l8ui	a4, a2, 13
  90b4a0:	26200e        	l8ui	a6, a2, 14
  90b4a3:	088810        	slli	a8, a8, 24
  90b4a6:	004411        	slli	a4, a4, 16
  90b4a9:	084402        	or	a4, a4, a8
  90b4ac:	086611        	slli	a6, a6, 8
  90b4af:	046602        	or	a6, a6, a4
  90b4b2:	24200f        	l8ui	a4, a2, 15
  90b4b5:	186a8f        	l32r	a8, 8e5ef4 <vdesc_module_install+0xee4>
  90b4b8:	064602        	or	a6, a4, a6
  90b4bb:	c040      	movi.n	a4, 0
  90b4bd:	058438        	moveqz	a4, a8, a5
  90b4c0:	063302        	or	a3, a3, a6
  90b4c3:	043302        	or	a3, a3, a4
  90b4c6:	038457        	extui	a4, a3, 24, 8
  90b4c9:	24240c        	s8i	a4, a2, 12
  90b4cc:	030457        	extui	a4, a3, 16, 8
  90b4cf:	24240d        	s8i	a4, a2, 13
  90b4d2:	038447        	extui	a4, a3, 8, 8
  90b4d5:	24240e        	s8i	a4, a2, 14
  90b4d8:	23240f        	s8i	a3, a2, 15
  90b4db:	6000cd        	j	90b5ac <ar5416FillTxDesc_20+0x118>
  90b4de:	000064        	excw
        } else if (lastSeg) {
  90b4e1:	508924        	call0	92d974 <_etext+0x1e85b>
                /*
                 * Last descriptor in a multi-descriptor frame,
                 * copy the multi-rate transmit parameters from
                 * the first frame for processing on completion.
                 */
                ads->ds_ctl0 = 0;
  90b4e4:	240824        	excw
  90b4e7:	240924        	l16si	a4, a0, 72
  90b4ea:	240a24        	movi	a4, 36
  90b4ed:	240b03        	l32ai	a4, a0, 12
                ads->ds_ctl1 = segLen;
  90b4f0:	8457      	l32i.n	a4, a5, 28
  90b4f2:	24240c        	s8i	a4, a2, 12
  90b4f5:	030457        	extui	a4, a3, 16, 8
  90b4f8:	24240d        	s8i	a4, a2, 13
  90b4fb:	038447        	extui	a4, a3, 8, 8
  90b4fe:	24240e        	s8i	a4, a2, 14
  90b501:	23240f        	s8i	a3, a2, 15
                ads->ds_ctl2 = AR5416DESC_CONST(ds0)->ds_ctl2;
  90b504:	256010        	l8ui	a5, a6, 16
  90b507:	246011        	l8ui	a4, a6, 17
  90b50a:	236012        	l8ui	a3, a6, 18
  90b50d:	085510        	slli	a5, a5, 24
  90b510:	004411        	slli	a4, a4, 16
  90b513:	054402        	or	a4, a4, a5
  90b516:	083311        	slli	a3, a3, 8
  90b519:	043302        	or	a3, a3, a4
  90b51c:	246013        	l8ui	a4, a6, 19
  90b51f:	034302        	or	a3, a4, a3
  90b522:	038457        	extui	a4, a3, 24, 8
  90b525:	242410        	s8i	a4, a2, 16
  90b528:	030457        	extui	a4, a3, 16, 8
  90b52b:	242411        	s8i	a4, a2, 17
  90b52e:	038447        	extui	a4, a3, 8, 8
  90b531:	242412        	s8i	a4, a2, 18
  90b534:	232413        	s8i	a3, a2, 19
                ads->ds_ctl3 = AR5416DESC_CONST(ds0)->ds_ctl3;
  90b537:	256014        	l8ui	a5, a6, 20
  90b53a:	246015        	l8ui	a4, a6, 21
  90b53d:	236016        	l8ui	a3, a6, 22
  90b540:	085510        	slli	a5, a5, 24
  90b543:	004411        	slli	a4, a4, 16
  90b546:	054402        	or	a4, a4, a5
  90b549:	083311        	slli	a3, a3, 8
  90b54c:	043302        	or	a3, a3, a4
  90b54f:	246017        	l8ui	a4, a6, 23
  90b552:	034302        	or	a3, a4, a3
  90b555:	038457        	extui	a4, a3, 24, 8
  90b558:	242414        	s8i	a4, a2, 20
  90b55b:	030457        	extui	a4, a3, 16, 8
  90b55e:	242415        	s8i	a4, a2, 21
  90b561:	038447        	extui	a4, a3, 8, 8
  90b564:	242416        	s8i	a4, a2, 22
  90b567:	232417        	s8i	a3, a2, 23
  90b56a:	60003e        	j	90b5ac <ar5416FillTxDesc_20+0x118>
        } else {
                /*
                 * Intermediate descriptor in a multi-descriptor frame.
                 */
                ads->ds_ctl0 = 0;
                ads->ds_ctl1 = segLen | AR_TxMore;
  90b56d:	146a8f        	l32r	a4, 8e5fac <vdesc_module_install+0xf9c>
                ads->ds_ctl3 = AR5416DESC_CONST(ds0)->ds_ctl3;
        } else {
                /*
                 * Intermediate descriptor in a multi-descriptor frame.
                 */
                ads->ds_ctl0 = 0;
  90b570:	252408        	s8i	a5, a2, 8
                ads->ds_ctl1 = segLen | AR_TxMore;
  90b573:	043302        	or	a3, a3, a4
  90b576:	038457        	extui	a4, a3, 24, 8
  90b579:	24240c        	s8i	a4, a2, 12
  90b57c:	030457        	extui	a4, a3, 16, 8
  90b57f:	24240d        	s8i	a4, a2, 13
  90b582:	038447        	extui	a4, a3, 8, 8
                ads->ds_ctl3 = AR5416DESC_CONST(ds0)->ds_ctl3;
        } else {
                /*
                 * Intermediate descriptor in a multi-descriptor frame.
                 */
                ads->ds_ctl0 = 0;
  90b585:	252409        	s8i	a5, a2, 9
  90b588:	25240a        	s8i	a5, a2, 10
  90b58b:	25240b        	s8i	a5, a2, 11
                ads->ds_ctl1 = segLen | AR_TxMore;
  90b58e:	24240e        	s8i	a4, a2, 14
  90b591:	23240f        	s8i	a3, a2, 15
                ads->ds_ctl2 = 0;
  90b594:	252410        	s8i	a5, a2, 16
  90b597:	252411        	s8i	a5, a2, 17
  90b59a:	252412        	s8i	a5, a2, 18
  90b59d:	252413        	s8i	a5, a2, 19
                ads->ds_ctl3 = 0;
  90b5a0:	252414        	s8i	a5, a2, 20
  90b5a3:	252415        	s8i	a5, a2, 21
  90b5a6:	252416        	s8i	a5, a2, 22
  90b5a9:	252417        	s8i	a5, a2, 23
        }
        ads->ds_txstatus0 = ads->ds_txstatus1 = 0;
  90b5ac:	c050      	movi.n	a5, 0
  90b5ae:	25243c        	s8i	a5, a2, 60
  90b5b1:	25243d        	s8i	a5, a2, 61
  90b5b4:	25243e        	s8i	a5, a2, 62
  90b5b7:	25243f        	s8i	a5, a2, 63
  90b5ba:	252438        	s8i	a5, a2, 56
  90b5bd:	252439        	s8i	a5, a2, 57
  90b5c0:	25243a        	s8i	a5, a2, 58
  90b5c3:	25243b        	s8i	a5, a2, 59

        return AH_TRUE;
}
  90b5c6:	c021      	movi.n	a2, 1
  90b5c8:	d10f      	retw.n
	...

0090b5cc <ar5416FillKeyTxDesc_20>:

HAL_BOOL ar5416FillKeyTxDesc_20(struct ath_tx_desc *ds,
				HAL_KEY_TYPE keyType)
{
  90b5cc:	6c1004        	entry	a1, 32
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl6 = SM(keyType, AR_EncrType);
  90b5cf:	186abe        	l32r	a8, 8e60c8 <vdesc_module_install+0x10b8>
  90b5d2:	063310        	slli	a3, a3, 26
  90b5d5:	083801        	and	a8, a3, a8
  90b5d8:	088857        	extui	a8, a8, 24, 8
  90b5db:	282420        	s8i	a8, a2, 32
  90b5de:	c080      	movi.n	a8, 0
  90b5e0:	282421        	s8i	a8, a2, 33
  90b5e3:	282422        	s8i	a8, a2, 34
  90b5e6:	282423        	s8i	a8, a2, 35
	return AH_TRUE;
}
  90b5e9:	c021      	movi.n	a2, 1
  90b5eb:	d10f      	retw.n
  90b5ed:	000000        	ill

0090b5f0 <ar5416Set11nTxDesc_20>:

void ar5416Set11nTxDesc_20(struct ath_tx_desc *ds,
			   a_uint32_t pktLen, HAL_PKT_TYPE type, a_uint32_t txPower,
			   a_uint32_t keyIx, HAL_KEY_TYPE keyType,
			   a_uint32_t flags)
{
  90b5f0:	6c1004        	entry	a1, 32
  90b5f3:	8818      	l32i.n	a8, a1, 32
  90b5f5:	c39f      	movi.n	a9, 63

	if (txPower > 63)
                txPower = 63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
		| (flags & HAL_TXDESC_VMF ? AR_VirtMoreFrag : 0)
  90b5f7:	2b1a00        	movi	a11, 0x100
  90b5fa:	1a6a8f        	l32r	a10, 8e6038 <vdesc_module_install+0x1028>
  90b5fd:	095536        	minu	a5, a5, a9
  90b600:	0b8b01        	and	a11, a8, a11
  90b603:	c090      	movi.n	a9, 0
  90b605:	0b9a38        	moveqz	a10, a9, a11
  90b608:	dba0      	mov.n	a11, a10
		| SM(txPower, AR_XmitPower)
  90b60a:	1a6ac1        	l32r	a10, 8e6110 <vdesc_module_install+0x1100>
  90b60d:	005511        	slli	a5, a5, 16
  90b610:	0a5501        	and	a5, a5, a10
        HALASSERT(isValidKeyType(keyType));

	if (txPower > 63)
                txPower = 63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
  90b613:	03034b        	extui	a3, a3, 0, 12
		| (flags & HAL_TXDESC_VMF ? AR_VirtMoreFrag : 0)
  90b616:	035502        	or	a5, a5, a3
		| SM(txPower, AR_XmitPower)
  90b619:	0b5502        	or	a5, a5, a11
		| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0)
  90b61c:	c0a4      	movi.n	a10, 4
  90b61e:	1b6ab9        	l32r	a11, 8e6104 <vdesc_module_install+0x10f4>
  90b621:	0a8a01        	and	a10, a8, a10
  90b624:	0a9b38        	moveqz	a11, a9, a10
  90b627:	0b5a02        	or	a10, a5, a11
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
  90b62a:	c250      	movi.n	a5, 32
  90b62c:	1b6aa6        	l32r	a11, 8e60c4 <vdesc_module_install+0x10b4>
  90b62f:	058501        	and	a5, a8, a5
  90b632:	059b38        	moveqz	a11, a9, a5
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
  90b635:	156ab7        	l32r	a5, 8e6114 <vdesc_module_install+0x1104>

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
		| (flags & HAL_TXDESC_VMF ? AR_VirtMoreFrag : 0)
		| SM(txPower, AR_XmitPower)
		| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0)
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
  90b638:	0baa02        	or	a10, a10, a11
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
  90b63b:	080b40        	extui	a11, a8, 0, 1
  90b63e:	0b9538        	moveqz	a5, a9, a11
  90b641:	05aa02        	or	a10, a10, a5
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0)
  90b644:	1b6ab8        	l32r	a11, 8e6124 <vdesc_module_install+0x1114>
  90b647:	c150      	movi.n	a5, 16
  90b649:	058501        	and	a5, a8, a5
  90b64c:	059b38        	moveqz	a11, a9, a5
  90b64f:	0baa02        	or	a10, a10, a11
		| (keyIx != HAL_TXKEYIX_INVALID ? AR_DestIdxValid : 0)
  90b652:	156abc        	l32r	a5, 8e6144 <vdesc_module_install+0x1134>
  90b655:	2b0aff        	movi	a11, 255
  90b658:	0b6c0c        	sub	a12, a6, a11
  90b65b:	0c9538        	moveqz	a5, a9, a12
  90b65e:	05aa02        	or	a10, a10, a5
		| (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0);
  90b661:	1c6a0e        	l32r	a12, 8e5e9c <vdesc_module_install+0xe8c>
  90b664:	c058      	movi.n	a5, 8
  90b666:	058501        	and	a5, a8, a5
  90b669:	059c38        	moveqz	a12, a9, a5
  90b66c:	0caa02        	or	a10, a10, a12
        HALASSERT(isValidKeyType(keyType));

	if (txPower > 63)
                txPower = 63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
  90b66f:	0a8557        	extui	a5, a10, 24, 8
  90b672:	252408        	s8i	a5, a2, 8
  90b675:	0a0557        	extui	a5, a10, 16, 8
  90b678:	252409        	s8i	a5, a2, 9
  90b67b:	0a8547        	extui	a5, a10, 8, 8
  90b67e:	25240a        	s8i	a5, a2, 10
  90b681:	2a240b        	s8i	a10, a2, 11
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0)
		| (keyIx != HAL_TXKEYIX_INVALID ? AR_DestIdxValid : 0)
		| (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0);

        ads->ds_ctl1 = (keyIx != HAL_TXKEYIX_INVALID ? SM(keyIx, AR_DestIdx) : 0)
  90b684:	7b6108        	beq	a6, a11, 90b690 <ar5416Set11nTxDesc_20+0xa0>
  90b687:	156abb        	l32r	a5, 8e6174 <vdesc_module_install+0x1164>
  90b68a:	036911        	slli	a9, a6, 13
  90b68d:	059901        	and	a9, a9, a5
		| SM(type, AR_FrameType)
  90b690:	1569a4        	l32r	a5, 8e5d20 <vdesc_module_install+0xd10>
  90b693:	0c4410        	slli	a4, a4, 20
  90b696:	054401        	and	a4, a4, a5
  90b699:	049902        	or	a9, a9, a4
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0)
  90b69c:	c052      	movi.n	a5, 2
  90b69e:	146ab7        	l32r	a4, 8e617c <vdesc_module_install+0x116c>
  90b6a1:	c0a0      	movi.n	a10, 0
  90b6a3:	058501        	and	a5, a8, a5
  90b6a6:	05a438        	moveqz	a4, a10, a5
  90b6a9:	049902        	or	a9, a9, a4
		| (flags & HAL_TXDESC_EXT_ONLY ? AR_ExtOnly : 0)
  90b6ac:	c450      	movi.n	a5, 64
  90b6ae:	146abf        	l32r	a4, 8e61ac <vdesc_module_install+0x119c>
  90b6b1:	058501        	and	a5, a8, a5
  90b6b4:	05a438        	moveqz	a4, a10, a5
  90b6b7:	049902        	or	a9, a9, a4
  90b6ba:	d540      	mov.n	a5, a4
		| (flags & HAL_TXDESC_EXT_AND_CTL ? AR_ExtAndCtl : 0);
  90b6bc:	240a80        	movi	a4, 128
  90b6bf:	048801        	and	a8, a8, a4
  90b6c2:	146ac0        	l32r	a4, 8e61c4 <vdesc_module_install+0x11b4>

        ads->ds_ctl6 = SM(keyType, AR_EncrType);
  90b6c5:	067710        	slli	a7, a7, 26

        ads->ds_ctl1 = (keyIx != HAL_TXKEYIX_INVALID ? SM(keyIx, AR_DestIdx) : 0)
		| SM(type, AR_FrameType)
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0)
		| (flags & HAL_TXDESC_EXT_ONLY ? AR_ExtOnly : 0)
		| (flags & HAL_TXDESC_EXT_AND_CTL ? AR_ExtAndCtl : 0);
  90b6c8:	08a438        	moveqz	a4, a10, a8
  90b6cb:	049802        	or	a8, a9, a4
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0)
		| (keyIx != HAL_TXKEYIX_INVALID ? AR_DestIdxValid : 0)
		| (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0);

        ads->ds_ctl1 = (keyIx != HAL_TXKEYIX_INVALID ? SM(keyIx, AR_DestIdx) : 0)
  90b6ce:	088457        	extui	a4, a8, 24, 8
  90b6d1:	24240c        	s8i	a4, a2, 12
  90b6d4:	080457        	extui	a4, a8, 16, 8
  90b6d7:	24240d        	s8i	a4, a2, 13
  90b6da:	088447        	extui	a4, a8, 8, 8
  90b6dd:	24240e        	s8i	a4, a2, 14
		| SM(type, AR_FrameType)
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0)
		| (flags & HAL_TXDESC_EXT_ONLY ? AR_ExtOnly : 0)
		| (flags & HAL_TXDESC_EXT_AND_CTL ? AR_ExtAndCtl : 0);

        ads->ds_ctl6 = SM(keyType, AR_EncrType);
  90b6e0:	146abe        	l32r	a4, 8e61d8 <vdesc_module_install+0x11c8>
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0)
		| (keyIx != HAL_TXKEYIX_INVALID ? AR_DestIdxValid : 0)
		| (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0);

        ads->ds_ctl1 = (keyIx != HAL_TXKEYIX_INVALID ? SM(keyIx, AR_DestIdx) : 0)
  90b6e3:	28240f        	s8i	a8, a2, 15
		| SM(type, AR_FrameType)
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0)
		| (flags & HAL_TXDESC_EXT_ONLY ? AR_ExtOnly : 0)
		| (flags & HAL_TXDESC_EXT_AND_CTL ? AR_ExtAndCtl : 0);

        ads->ds_ctl6 = SM(keyType, AR_EncrType);
  90b6e6:	047701        	and	a7, a7, a4
  90b6e9:	078757        	extui	a7, a7, 24, 8
  90b6ec:	272420        	s8i	a7, a2, 32
  90b6ef:	d4a0      	mov.n	a4, a10
  90b6f1:	2a2421        	s8i	a10, a2, 33
  90b6f4:	2a2422        	s8i	a10, a2, 34
  90b6f7:	2a2423        	s8i	a10, a2, 35
  90b6fa:	d10f      	retw.n

0090b6fc <ar5416Set11nRateScenario_20>:

void ar5416Set11nRateScenario_20(struct ath_tx_desc *ds,
				 a_uint32_t durUpdateEn, a_uint32_t rtsctsRate,
				 HAL_11N_RATE_SERIES series[], a_uint32_t nseries,
				 a_uint32_t flags)
{
  90b6fc:	6c1008        	entry	a1, 64
	(void)nseries;

	/*
	* Rate control settings override
	*/
	ds_ctl0 = ads->ds_ctl0;
  90b6ff:	282008        	l8ui	a8, a2, 8
  90b702:	262009        	l8ui	a6, a2, 9

void ar5416Set11nRateScenario_20(struct ath_tx_desc *ds,
				 a_uint32_t durUpdateEn, a_uint32_t rtsctsRate,
				 HAL_11N_RATE_SERIES series[], a_uint32_t nseries,
				 a_uint32_t flags)
{
  90b705:	9414      	s32i.n	a4, a1, 16
	(void)nseries;

	/*
	* Rate control settings override
	*/
	ds_ctl0 = ads->ds_ctl0;
  90b707:	24200a        	l8ui	a4, a2, 10
  90b70a:	088810        	slli	a8, a8, 24
  90b70d:	006611        	slli	a6, a6, 16
  90b710:	086602        	or	a6, a6, a8
  90b713:	084411        	slli	a4, a4, 8
  90b716:	064402        	or	a4, a4, a6
  90b719:	26200b        	l8ui	a6, a2, 11
  90b71c:	046402        	or	a4, a6, a4

	if (flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA)) {
  90b71f:	c06c      	movi.n	a6, 12
  90b721:	76701f        	bnone	a7, a6, 90b744 <ar5416Set11nRateScenario_20+0x48>
		if (flags & HAL_TXDESC_RTSENA) {
  90b724:	7d770c        	bbci	a7, 29, 90b734 <ar5416Set11nRateScenario_20+0x38>
			ds_ctl0 &= ~AR_CTSEnable;
  90b727:	166ab2        	l32r	a6, 8e61f0 <vdesc_module_install+0x11e0>
  90b72a:	064401        	and	a4, a4, a6
			ds_ctl0 |= AR_RTSEnable;
  90b72d:	166ab9        	l32r	a6, 8e6214 <vdesc_module_install+0x1204>
  90b730:	600009        	j	90b73d <ar5416Set11nRateScenario_20+0x41>
  90b733:	00166a        	excw
		} else {
			ds_ctl0 &= ~AR_RTSEnable;
  90b736:	c306      	movi.n	a0, 54
  90b738:	440116        	excw
			ds_ctl0 |= AR_CTSEnable;
  90b73b:	6a0e06        	blti	a0, 128, 90b745 <ar5416Set11nRateScenario_20+0x49>
  90b73e:	440260        	excw
  90b741:	000600        	rsil	a0, 0
		}
	} else {
		/* this line is only difference between merlin and k2
		 * Current one is for merlin */
		ds_ctl0 = (ds_ctl0 & ~(AR_RTSEnable | AR_CTSEnable));
  90b744:	166ac4        	l32r	a6, 8e6254 <vdesc_module_install+0x1244>
  90b747:	064401        	and	a4, a4, a6
	}

	ads->ds_ctl0 = ds_ctl0;
  90b74a:	048657        	extui	a6, a4, 24, 8
  90b74d:	262408        	s8i	a6, a2, 8
  90b750:	040657        	extui	a6, a4, 16, 8
  90b753:	262409        	s8i	a6, a2, 9
  90b756:	048647        	extui	a6, a4, 8, 8
  90b759:	26240a        	s8i	a6, a2, 10
  90b75c:	24240b        	s8i	a4, a2, 11

	ads->ds_ctl2 = set11nTries(series, 0)
  90b75f:	8650      	l32i.n	a6, a5, 0
  90b761:	176aba        	l32r	a7, 8e624c <vdesc_module_install+0x123c>
				   | set11nTries(series, 1)
  90b764:	8457      	l32i.n	a4, a5, 28
		ds_ctl0 = (ds_ctl0 & ~(AR_RTSEnable | AR_CTSEnable));
	}

	ads->ds_ctl0 = ds_ctl0;

	ads->ds_ctl2 = set11nTries(series, 0)
  90b766:	006611        	slli	a6, a6, 16
  90b769:	076601        	and	a6, a6, a7
				   | set11nTries(series, 1)
  90b76c:	1769a4        	l32r	a7, 8e5dfc <vdesc_module_install+0xdec>
  90b76f:	0c4410        	slli	a4, a4, 20
  90b772:	074401        	and	a4, a4, a7
  90b775:	046402        	or	a4, a6, a4
				   | set11nTries(series, 2)
				   | set11nTries(series, 3)
  90b778:	265215        	l32i	a6, a5, 84

	ads->ds_ctl0 = ds_ctl0;

	ads->ds_ctl2 = set11nTries(series, 0)
				   | set11nTries(series, 1)
				   | set11nTries(series, 2)
  90b77b:	176ac5        	l32r	a7, 8e6290 <vdesc_module_install+0x1280>
				   | set11nTries(series, 3)
  90b77e:	046610        	slli	a6, a6, 28

	ads->ds_ctl0 = ds_ctl0;

	ads->ds_ctl2 = set11nTries(series, 0)
				   | set11nTries(series, 1)
				   | set11nTries(series, 2)
  90b781:	064402        	or	a4, a4, a6
  90b784:	865e      	l32i.n	a6, a5, 56
				   | set11nTries(series, 3)
				   | (durUpdateEn ? AR_DurUpdateEn : 0);
  90b786:	c080      	movi.n	a8, 0

	ads->ds_ctl0 = ds_ctl0;

	ads->ds_ctl2 = set11nTries(series, 0)
				   | set11nTries(series, 1)
				   | set11nTries(series, 2)
  90b788:	086610        	slli	a6, a6, 24
				   | set11nTries(series, 3)
				   | (durUpdateEn ? AR_DurUpdateEn : 0);
  90b78b:	1c6a31        	l32r	a12, 8e6050 <vdesc_module_install+0x1040>

	ads->ds_ctl0 = ds_ctl0;

	ads->ds_ctl2 = set11nTries(series, 0)
				   | set11nTries(series, 1)
				   | set11nTries(series, 2)
  90b78e:	076601        	and	a6, a6, a7
				   | set11nTries(series, 3)
  90b791:	064402        	or	a4, a4, a6
				   | (durUpdateEn ? AR_DurUpdateEn : 0);
  90b794:	d680      	mov.n	a6, a8
  90b796:	03c639        	movnez	a6, a12, a3
  90b799:	064302        	or	a3, a4, a6
		ds_ctl0 = (ds_ctl0 & ~(AR_RTSEnable | AR_CTSEnable));
	}

	ads->ds_ctl0 = ds_ctl0;

	ads->ds_ctl2 = set11nTries(series, 0)
  90b79c:	038457        	extui	a4, a3, 24, 8
  90b79f:	242410        	s8i	a4, a2, 16
  90b7a2:	030457        	extui	a4, a3, 16, 8
  90b7a5:	242411        	s8i	a4, a2, 17
  90b7a8:	038447        	extui	a4, a3, 8, 8
  90b7ab:	242412        	s8i	a4, a2, 18
  90b7ae:	232413        	s8i	a3, a2, 19
				   | (durUpdateEn ? AR_DurUpdateEn : 0);

	ads->ds_ctl3 = set11nRate(series, 0)
				   | set11nRate(series, 1)
				   | set11nRate(series, 2)
				   | set11nRate(series, 3);
  90b7b1:	235216        	l32i	a3, a5, 88
				   | set11nTries(series, 1)
				   | set11nTries(series, 2)
				   | set11nTries(series, 3)
				   | (durUpdateEn ? AR_DurUpdateEn : 0);

	ads->ds_ctl3 = set11nRate(series, 0)
  90b7b4:	245007        	l8ui	a4, a5, 7
				   | set11nRate(series, 1)
				   | set11nRate(series, 2)
				   | set11nRate(series, 3);
  90b7b7:	083310        	slli	a3, a3, 24
				   | set11nTries(series, 2)
				   | set11nTries(series, 3)
				   | (durUpdateEn ? AR_DurUpdateEn : 0);

	ads->ds_ctl3 = set11nRate(series, 0)
				   | set11nRate(series, 1)
  90b7ba:	043302        	or	a3, a3, a4
  90b7bd:	8458      	l32i.n	a4, a5, 32
				   | set11nRate(series, 2)
  90b7bf:	166ac6        	l32r	a6, 8e62d8 <vdesc_module_install+0x12c8>
				   | set11nTries(series, 2)
				   | set11nTries(series, 3)
				   | (durUpdateEn ? AR_DurUpdateEn : 0);

	ads->ds_ctl3 = set11nRate(series, 0)
				   | set11nRate(series, 1)
  90b7c2:	084411        	slli	a4, a4, 8
  90b7c5:	04044f        	extui	a4, a4, 0, 16
				   | set11nRate(series, 2)
  90b7c8:	043302        	or	a3, a3, a4
  90b7cb:	845f      	l32i.n	a4, a5, 60
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
				   | set11nPktDurRTSCTS(series, 1);
  90b7cd:	176ac7        	l32r	a7, 8e62ec <vdesc_module_install+0x12dc>
				   | set11nTries(series, 3)
				   | (durUpdateEn ? AR_DurUpdateEn : 0);

	ads->ds_ctl3 = set11nRate(series, 0)
				   | set11nRate(series, 1)
				   | set11nRate(series, 2)
  90b7d0:	004411        	slli	a4, a4, 16
  90b7d3:	064401        	and	a4, a4, a6
				   | set11nRate(series, 3);
  90b7d6:	043302        	or	a3, a3, a4
				   | set11nTries(series, 1)
				   | set11nTries(series, 2)
				   | set11nTries(series, 3)
				   | (durUpdateEn ? AR_DurUpdateEn : 0);

	ads->ds_ctl3 = set11nRate(series, 0)
  90b7d9:	038457        	extui	a4, a3, 24, 8
  90b7dc:	242414        	s8i	a4, a2, 20
  90b7df:	030457        	extui	a4, a3, 16, 8
  90b7e2:	242415        	s8i	a4, a2, 21
  90b7e5:	038447        	extui	a4, a3, 8, 8
  90b7e8:	242416        	s8i	a4, a2, 22
  90b7eb:	232417        	s8i	a3, a2, 23
				   | set11nRate(series, 1)
				   | set11nRate(series, 2)
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
				   | set11nPktDurRTSCTS(series, 1);
  90b7ee:	8359      	l32i.n	a3, a5, 36
	ads->ds_ctl3 = set11nRate(series, 0)
				   | set11nRate(series, 1)
				   | set11nRate(series, 2)
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
  90b7f0:	8e54      	l32i.n	a14, a5, 16
  90b7f2:	8a52      	l32i.n	a10, a5, 8
				   | set11nPktDurRTSCTS(series, 1);
  90b7f4:	845b      	l32i.n	a4, a5, 44
  90b7f6:	003311        	slli	a3, a3, 16
	ads->ds_ctl3 = set11nRate(series, 0)
				   | set11nRate(series, 1)
				   | set11nRate(series, 2)
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
  90b7f9:	0e0940        	extui	a9, a14, 0, 1
  90b7fc:	0a0a4e        	extui	a10, a10, 0, 15
  90b7ff:	db80      	mov.n	a11, a8
				   | set11nPktDurRTSCTS(series, 1);
  90b801:	073301        	and	a3, a3, a7
  90b804:	1f6a0e        	l32r	a15, 8e603c <vdesc_module_install+0x102c>
	ads->ds_ctl3 = set11nRate(series, 0)
				   | set11nRate(series, 1)
				   | set11nRate(series, 2)
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
  90b807:	09cb39        	movnez	a11, a12, a9
				   | set11nPktDurRTSCTS(series, 1);
  90b80a:	040640        	extui	a6, a4, 0, 1
	ads->ds_ctl3 = set11nRate(series, 0)
				   | set11nRate(series, 1)
				   | set11nRate(series, 2)
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
  90b80d:	0a3302        	or	a3, a3, a10
				   | set11nPktDurRTSCTS(series, 1);
  90b810:	068f38        	moveqz	a15, a8, a6
  90b813:	0b3302        	or	a3, a3, a11
  90b816:	0f3302        	or	a3, a3, a15
	ads->ds_ctl3 = set11nRate(series, 0)
				   | set11nRate(series, 1)
				   | set11nRate(series, 2)
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
  90b819:	038657        	extui	a6, a3, 24, 8
  90b81c:	262418        	s8i	a6, a2, 24
  90b81f:	030657        	extui	a6, a3, 16, 8
  90b822:	262419        	s8i	a6, a2, 25
  90b825:	038647        	extui	a6, a3, 8, 8
  90b828:	26241a        	s8i	a6, a2, 26
  90b82b:	23241b        	s8i	a3, a2, 27
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
  90b82e:	235212        	l32i	a3, a5, 72
  90b831:	d680      	mov.n	a6, a8
  90b833:	030b40        	extui	a11, a3, 0, 1
  90b836:	0bc639        	movnez	a6, a12, a11
  90b839:	db60      	mov.n	a11, a6
				   | set11nPktDurRTSCTS(series, 3);
  90b83b:	265217        	l32i	a6, a5, 92
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
  90b83e:	2d5210        	l32i	a13, a5, 64
				   | set11nPktDurRTSCTS(series, 3);
  90b841:	2a5219        	l32i	a10, a5, 100
  90b844:	006611        	slli	a6, a6, 16
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
  90b847:	0d0d4e        	extui	a13, a13, 0, 15
				   | set11nPktDurRTSCTS(series, 3);
  90b84a:	076601        	and	a6, a6, a7
  90b84d:	1f6a0e        	l32r	a15, 8e6088 <vdesc_module_install+0x1078>
  90b850:	0a0940        	extui	a9, a10, 0, 1
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
  90b853:	0d6602        	or	a6, a6, a13
				   | set11nPktDurRTSCTS(series, 3);
  90b856:	098f38        	moveqz	a15, a8, a9
  90b859:	0b6602        	or	a6, a6, a11
  90b85c:	0f6602        	or	a6, a6, a15
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
  90b85f:	068757        	extui	a7, a6, 24, 8
  90b862:	27241c        	s8i	a7, a2, 28
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
  90b865:	c0d2      	movi.n	a13, 2
  90b867:	c0b4      	movi.n	a11, 4
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
  90b869:	060757        	extui	a7, a6, 16, 8
  90b86c:	27241d        	s8i	a7, a2, 29
  90b86f:	26241f        	s8i	a6, a2, 31
  90b872:	068747        	extui	a7, a6, 8, 8
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
  90b875:	d9d0      	mov.n	a9, a13
  90b877:	0be601        	and	a6, a14, a11
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
  90b87a:	27241e        	s8i	a7, a2, 30
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
  90b87d:	068938        	moveqz	a9, a8, a6
  90b880:	0e1740        	extui	a7, a14, 1, 1
  90b883:	079602        	or	a6, a9, a7
  90b886:	c098      	movi.n	a9, 8
  90b888:	176ac0        	l32r	a7, 8e6388 <_xtos_set_exception_handler+0x40>
  90b88b:	09ee01        	and	a14, a14, a9
  90b88e:	0e8738        	moveqz	a7, a8, a14
  90b891:	076602        	or	a6, a6, a7
  90b894:	8753      	l32i.n	a7, a5, 12
  90b896:	9612      	s32i.n	a6, a1, 8
  90b898:	00d104        	ssl	a13
  90b89b:	00771a        	sll	a7, a7
  90b89e:	c16c      	movi.n	a6, 28
  90b8a0:	067601        	and	a6, a7, a6
  90b8a3:	9613      	s32i.n	a6, a1, 12
				   | set11nRateFlags(series, 1)
  90b8a5:	c2f0      	movi.n	a15, 32
  90b8a7:	0d4601        	and	a6, a4, a13
  90b8aa:	068f38        	moveqz	a15, a8, a6
  90b8ad:	c4e0      	movi.n	a14, 64
  90b8af:	0b4601        	and	a6, a4, a11
  90b8b2:	068e38        	moveqz	a14, a8, a6
  90b8b5:	875a      	l32i.n	a7, a5, 40
  90b8b7:	166ab8        	l32r	a6, 8e6398 <_xtos_set_exception_handler+0x50>
  90b8ba:	094401        	and	a4, a4, a9
  90b8bd:	048638        	moveqz	a6, a8, a4
  90b8c0:	097711        	slli	a7, a7, 7
  90b8c3:	243a80        	movi	a4, 0x380
  90b8c6:	9e10      	s32i.n	a14, a1, 0
  90b8c8:	047701        	and	a7, a7, a4
				   | set11nRateFlags(series, 2)
  90b8cb:	2e4a00        	movi	a14, 0x400
  90b8ce:	0d3401        	and	a4, a3, a13
  90b8d1:	048e38        	moveqz	a14, a8, a4
  90b8d4:	146ac2        	l32r	a4, 8e63dc <_xtos_set_exception_handler+0x94>

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
				   | set11nRateFlags(series, 1)
  90b8d7:	9611      	s32i.n	a6, a1, 4
				   | set11nRateFlags(series, 2)
  90b8d9:	0b3601        	and	a6, a3, a11
  90b8dc:	068438        	moveqz	a4, a8, a6
  90b8df:	166abc        	l32r	a6, 8e63d0 <_xtos_set_exception_handler+0x88>
  90b8e2:	093301        	and	a3, a3, a9
  90b8e5:	038638        	moveqz	a6, a8, a3
  90b8e8:	d360      	mov.n	a3, a6
  90b8ea:	265211        	l32i	a6, a5, 68
  90b8ed:	9415      	s32i.n	a4, a1, 20
  90b8ef:	146ac8        	l32r	a4, 8e6410 <_xtos_set_exception_handler+0xc8>
  90b8f2:	046611        	slli	a6, a6, 12
  90b8f5:	046601        	and	a6, a6, a4
				   | set11nRateFlags(series, 3)
  90b8f8:	146a0e        	l32r	a4, 8e6130 <vdesc_module_install+0x1120>
  90b8fb:	09a901        	and	a9, a10, a9
  90b8fe:	098438        	moveqz	a4, a8, a9
  90b901:	d940      	mov.n	a9, a4
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
  90b903:	8413      	l32i.n	a4, a1, 12
				   | set11nRateFlags(series, 1)
				   | set11nRateFlags(series, 2)
				   | set11nRateFlags(series, 3)
  90b905:	0dad01        	and	a13, a10, a13
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
  90b908:	047702        	or	a7, a7, a4
				   | set11nRateFlags(series, 1)
  90b90b:	067602        	or	a6, a7, a6
				   | set11nRateFlags(series, 2)
				   | set11nRateFlags(series, 3)
  90b90e:	275218        	l32i	a7, a5, 96
  90b911:	156ac9        	l32r	a5, 8e6438 <_xtos_set_exception_handler+0xf0>
  90b914:	0f7710        	slli	a7, a7, 17
  90b917:	0d8c38        	moveqz	a12, a8, a13
				   | SM(rtsctsRate, AR_RTSCTSRate);
  90b91a:	8414      	l32i.n	a4, a1, 16
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
				   | set11nRateFlags(series, 1)
				   | set11nRateFlags(series, 2)
				   | set11nRateFlags(series, 3)
  90b91c:	1d6953        	l32r	a13, 8e5e68 <vdesc_module_install+0xe58>
  90b91f:	057501        	and	a5, a7, a5
  90b922:	0bab01        	and	a11, a10, a11

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
				   | set11nRateFlags(series, 1)
  90b925:	056602        	or	a6, a6, a5
				   | set11nRateFlags(series, 2)
				   | set11nRateFlags(series, 3)
				   | SM(rtsctsRate, AR_RTSCTSRate);
  90b928:	156aca        	l32r	a5, 8e6450 <_xtos_set_exception_handler+0x108>
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
				   | set11nRateFlags(series, 1)
				   | set11nRateFlags(series, 2)
				   | set11nRateFlags(series, 3)
  90b92b:	0b8d38        	moveqz	a13, a8, a11
				   | SM(rtsctsRate, AR_RTSCTSRate);
  90b92e:	0c4810        	slli	a8, a4, 20
  90b931:	058801        	and	a8, a8, a5

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
				   | set11nRateFlags(series, 1)
  90b934:	8512      	l32i.n	a5, a1, 8
  90b936:	086602        	or	a6, a6, a8
  90b939:	056602        	or	a6, a6, a5
				   | set11nRateFlags(series, 2)
  90b93c:	0f6f02        	or	a15, a6, a15
  90b93f:	8610      	l32i.n	a6, a1, 0
  90b941:	8411      	l32i.n	a4, a1, 4
  90b943:	06ff02        	or	a15, a15, a6
  90b946:	04ff02        	or	a15, a15, a4
				   | set11nRateFlags(series, 3)
  90b949:	8515      	l32i.n	a5, a1, 20
	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
				   | set11nRateFlags(series, 1)
				   | set11nRateFlags(series, 2)
  90b94b:	0efe02        	or	a14, a15, a14
				   | set11nRateFlags(series, 3)
  90b94e:	05e402        	or	a4, a14, a5
  90b951:	034302        	or	a3, a4, a3
  90b954:	0c3c02        	or	a12, a3, a12
  90b957:	0dcb02        	or	a11, a12, a13
				   | SM(rtsctsRate, AR_RTSCTSRate);
  90b95a:	09b902        	or	a9, a11, a9
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
  90b95d:	098357        	extui	a3, a9, 24, 8
  90b960:	232424        	s8i	a3, a2, 36
  90b963:	090357        	extui	a3, a9, 16, 8
  90b966:	232425        	s8i	a3, a2, 37
  90b969:	098347        	extui	a3, a9, 8, 8
  90b96c:	232426        	s8i	a3, a2, 38
  90b96f:	292427        	s8i	a9, a2, 39
  90b972:	d10f      	retw.n

0090b974 <ar5416Set11nAggrFirst_20>:
				   | SM(rtsctsRate, AR_RTSCTSRate);
}

void ar5416Set11nAggrFirst_20(struct ath_tx_desc *ds, a_uint32_t aggrLen,
			      a_uint32_t numDelims)
{
  90b974:	6c1004        	entry	a1, 32
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);
  90b977:	2a200c        	l8ui	a10, a2, 12
  90b97a:	29200d        	l8ui	a9, a2, 13
  90b97d:	28200e        	l8ui	a8, a2, 14
  90b980:	08aa10        	slli	a10, a10, 24
  90b983:	009911        	slli	a9, a9, 16
  90b986:	0a9902        	or	a9, a9, a10
  90b989:	088811        	slli	a8, a8, 8
  90b98c:	098802        	or	a8, a8, a9
  90b98f:	29200f        	l8ui	a9, a2, 15

	ads->ds_ctl6 &= ~(AR_AggrLen | AR_PadDelim);
  90b992:	2a2020        	l8ui	a10, a2, 32
void ar5416Set11nAggrFirst_20(struct ath_tx_desc *ds, a_uint32_t aggrLen,
			      a_uint32_t numDelims)
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);
  90b995:	089802        	or	a8, a9, a8
  90b998:	196acb        	l32r	a9, 8e64c4 <_xtos_set_exception_handler+0x17c>

	ads->ds_ctl6 &= ~(AR_AggrLen | AR_PadDelim);
  90b99b:	08aa10        	slli	a10, a10, 24
void ar5416Set11nAggrFirst_20(struct ath_tx_desc *ds, a_uint32_t aggrLen,
			      a_uint32_t numDelims)
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);
  90b99e:	098802        	or	a8, a8, a9
  90b9a1:	088957        	extui	a9, a8, 24, 8
  90b9a4:	29240c        	s8i	a9, a2, 12
  90b9a7:	080957        	extui	a9, a8, 16, 8
  90b9aa:	29240d        	s8i	a9, a2, 13
  90b9ad:	28240f        	s8i	a8, a2, 15
  90b9b0:	088947        	extui	a9, a8, 8, 8

	ads->ds_ctl6 &= ~(AR_AggrLen | AR_PadDelim);
  90b9b3:	282021        	l8ui	a8, a2, 33
void ar5416Set11nAggrFirst_20(struct ath_tx_desc *ds, a_uint32_t aggrLen,
			      a_uint32_t numDelims)
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);
  90b9b6:	29240e        	s8i	a9, a2, 14

	ads->ds_ctl6 &= ~(AR_AggrLen | AR_PadDelim);
  90b9b9:	292022        	l8ui	a9, a2, 34
  90b9bc:	008811        	slli	a8, a8, 16
  90b9bf:	0a8802        	or	a8, a8, a10
  90b9c2:	089911        	slli	a9, a9, 8
  90b9c5:	089902        	or	a9, a9, a8
  90b9c8:	282023        	l8ui	a8, a2, 35
	ads->ds_ctl6 |= SM(aggrLen, AR_AggrLen) |
  90b9cb:	03034f        	extui	a3, a3, 0, 16
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);

	ads->ds_ctl6 &= ~(AR_AggrLen | AR_PadDelim);
  90b9ce:	098902        	or	a9, a8, a9
  90b9d1:	186acc        	l32r	a8, 8e6504 <_xtos_set_exception_handler+0x1bc>
	ads->ds_ctl6 |= SM(aggrLen, AR_AggrLen) |
		SM(numDelims, AR_PadDelim);
  90b9d4:	0e4410        	slli	a4, a4, 18
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);

	ads->ds_ctl6 &= ~(AR_AggrLen | AR_PadDelim);
  90b9d7:	089901        	and	a9, a9, a8
	ads->ds_ctl6 |= SM(aggrLen, AR_AggrLen) |
  90b9da:	093902        	or	a9, a3, a9
		SM(numDelims, AR_PadDelim);
  90b9dd:	136acd        	l32r	a3, 8e6514 <_xtos_set_exception_handler+0x1cc>
  90b9e0:	034801        	and	a8, a4, a3
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);

	ads->ds_ctl6 &= ~(AR_AggrLen | AR_PadDelim);
	ads->ds_ctl6 |= SM(aggrLen, AR_AggrLen) |
  90b9e3:	089802        	or	a8, a9, a8
  90b9e6:	088357        	extui	a3, a8, 24, 8
  90b9e9:	232420        	s8i	a3, a2, 32
  90b9ec:	080357        	extui	a3, a8, 16, 8
  90b9ef:	232421        	s8i	a3, a2, 33
  90b9f2:	088347        	extui	a3, a8, 8, 8
  90b9f5:	232422        	s8i	a3, a2, 34
  90b9f8:	282423        	s8i	a8, a2, 35
  90b9fb:	d10f      	retw.n
  90b9fd:	000000        	ill

0090ba00 <ar5416Set11nAggrMiddle_20>:
		SM(numDelims, AR_PadDelim);
}

void ar5416Set11nAggrMiddle_20(struct ath_tx_desc *ds, a_uint32_t numDelims)
{
  90ba00:	6c1004        	entry	a1, 32
	struct ar5416_desc *ads = AR5416DESC(ds);
	a_uint32_t ctl6;

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);
  90ba03:	2a200c        	l8ui	a10, a2, 12
  90ba06:	29200d        	l8ui	a9, a2, 13
  90ba09:	28200e        	l8ui	a8, a2, 14
  90ba0c:	08aa10        	slli	a10, a10, 24
  90ba0f:	009911        	slli	a9, a9, 16
  90ba12:	0a9902        	or	a9, a9, a10
  90ba15:	088811        	slli	a8, a8, 8
  90ba18:	098802        	or	a8, a8, a9
  90ba1b:	29200f        	l8ui	a9, a2, 15

	/*
	 * We use a stack variable to manipulate ctl6 to reduce uncached 
	 * read modify, modfiy, write.
	 */
	ctl6 = ads->ds_ctl6;
  90ba1e:	2a2020        	l8ui	a10, a2, 32
void ar5416Set11nAggrMiddle_20(struct ath_tx_desc *ds, a_uint32_t numDelims)
{
	struct ar5416_desc *ads = AR5416DESC(ds);
	a_uint32_t ctl6;

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);
  90ba21:	089802        	or	a8, a9, a8
  90ba24:	196acb        	l32r	a9, 8e6550 <_xtos_set_exception_handler+0x208>

	/*
	 * We use a stack variable to manipulate ctl6 to reduce uncached 
	 * read modify, modfiy, write.
	 */
	ctl6 = ads->ds_ctl6;
  90ba27:	08aa10        	slli	a10, a10, 24
void ar5416Set11nAggrMiddle_20(struct ath_tx_desc *ds, a_uint32_t numDelims)
{
	struct ar5416_desc *ads = AR5416DESC(ds);
	a_uint32_t ctl6;

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);
  90ba2a:	098802        	or	a8, a8, a9
  90ba2d:	088957        	extui	a9, a8, 24, 8
  90ba30:	29240c        	s8i	a9, a2, 12
  90ba33:	080957        	extui	a9, a8, 16, 8
  90ba36:	29240d        	s8i	a9, a2, 13
  90ba39:	28240f        	s8i	a8, a2, 15
  90ba3c:	088947        	extui	a9, a8, 8, 8

	/*
	 * We use a stack variable to manipulate ctl6 to reduce uncached 
	 * read modify, modfiy, write.
	 */
	ctl6 = ads->ds_ctl6;
  90ba3f:	282021        	l8ui	a8, a2, 33
void ar5416Set11nAggrMiddle_20(struct ath_tx_desc *ds, a_uint32_t numDelims)
{
	struct ar5416_desc *ads = AR5416DESC(ds);
	a_uint32_t ctl6;

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);
  90ba42:	29240e        	s8i	a9, a2, 14

	/*
	 * We use a stack variable to manipulate ctl6 to reduce uncached 
	 * read modify, modfiy, write.
	 */
	ctl6 = ads->ds_ctl6;
  90ba45:	292022        	l8ui	a9, a2, 34
  90ba48:	008811        	slli	a8, a8, 16
  90ba4b:	0a8802        	or	a8, a8, a10
  90ba4e:	089911        	slli	a9, a9, 8
  90ba51:	089902        	or	a9, a9, a8
  90ba54:	282023        	l8ui	a8, a2, 35
	ctl6 &= ~AR_PadDelim;
  90ba57:	1a6ace        	l32r	a10, 8e6590 <strcmp+0x30>

	/*
	 * We use a stack variable to manipulate ctl6 to reduce uncached 
	 * read modify, modfiy, write.
	 */
	ctl6 = ads->ds_ctl6;
  90ba5a:	098902        	or	a9, a8, a9
	ctl6 &= ~AR_PadDelim;
	ctl6 |= SM(numDelims, AR_PadDelim);
  90ba5d:	186acd        	l32r	a8, 8e6594 <strcmp+0x34>
  90ba60:	0e3310        	slli	a3, a3, 18
	/*
	 * We use a stack variable to manipulate ctl6 to reduce uncached 
	 * read modify, modfiy, write.
	 */
	ctl6 = ads->ds_ctl6;
	ctl6 &= ~AR_PadDelim;
  90ba63:	0a9901        	and	a9, a9, a10
	ctl6 |= SM(numDelims, AR_PadDelim);
  90ba66:	083801        	and	a8, a3, a8
  90ba69:	098802        	or	a8, a8, a9
	ads->ds_ctl6 = ctl6;
  90ba6c:	088957        	extui	a9, a8, 24, 8
  90ba6f:	292420        	s8i	a9, a2, 32
  90ba72:	080957        	extui	a9, a8, 16, 8
  90ba75:	292421        	s8i	a9, a2, 33
  90ba78:	088947        	extui	a9, a8, 8, 8
  90ba7b:	292422        	s8i	a9, a2, 34
  90ba7e:	282423        	s8i	a8, a2, 35
  90ba81:	d10f      	retw.n
	...

0090ba84 <ar5416Set11nAggrLast_20>:
}

void ar5416Set11nAggrLast_20(struct ath_tx_desc *ds)
{
  90ba84:	6c1004        	entry	a1, 32
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= AR_IsAggr;
  90ba87:	2a200c        	l8ui	a10, a2, 12
  90ba8a:	29200d        	l8ui	a9, a2, 13
  90ba8d:	28200e        	l8ui	a8, a2, 14
  90ba90:	08aa10        	slli	a10, a10, 24
  90ba93:	009911        	slli	a9, a9, 16
  90ba96:	0a9902        	or	a9, a9, a10
  90ba99:	088811        	slli	a8, a8, 8
  90ba9c:	098802        	or	a8, a8, a9
  90ba9f:	29200f        	l8ui	a9, a2, 15
	ads->ds_ctl1 &= ~AR_MoreAggr;
	ads->ds_ctl6 &= ~AR_PadDelim;
  90baa2:	2a2020        	l8ui	a10, a2, 32

void ar5416Set11nAggrLast_20(struct ath_tx_desc *ds)
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= AR_IsAggr;
  90baa5:	089802        	or	a8, a9, a8
	ads->ds_ctl1 &= ~AR_MoreAggr;
  90baa8:	196acf        	l32r	a9, 8e65e4 <strcmp+0x84>
	ads->ds_ctl6 &= ~AR_PadDelim;
  90baab:	08aa10        	slli	a10, a10, 24
void ar5416Set11nAggrLast_20(struct ath_tx_desc *ds)
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= AR_IsAggr;
	ads->ds_ctl1 &= ~AR_MoreAggr;
  90baae:	098801        	and	a8, a8, a9
  90bab1:	196abc        	l32r	a9, 8e65a4 <strcmp+0x44>
  90bab4:	098802        	or	a8, a8, a9
  90bab7:	088957        	extui	a9, a8, 24, 8
  90baba:	29240c        	s8i	a9, a2, 12
  90babd:	080957        	extui	a9, a8, 16, 8
  90bac0:	29240d        	s8i	a9, a2, 13
  90bac3:	28240f        	s8i	a8, a2, 15
  90bac6:	088947        	extui	a9, a8, 8, 8
	ads->ds_ctl6 &= ~AR_PadDelim;
  90bac9:	282021        	l8ui	a8, a2, 33
void ar5416Set11nAggrLast_20(struct ath_tx_desc *ds)
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= AR_IsAggr;
	ads->ds_ctl1 &= ~AR_MoreAggr;
  90bacc:	29240e        	s8i	a9, a2, 14
	ads->ds_ctl6 &= ~AR_PadDelim;
  90bacf:	292022        	l8ui	a9, a2, 34
  90bad2:	008811        	slli	a8, a8, 16
  90bad5:	0a8802        	or	a8, a8, a10
  90bad8:	089911        	slli	a9, a9, 8
  90badb:	089902        	or	a9, a9, a8
  90bade:	282023        	l8ui	a8, a2, 35
  90bae1:	098902        	or	a9, a8, a9
  90bae4:	186ace        	l32r	a8, 8e661c <strcmp+0xbc>
  90bae7:	292423        	s8i	a9, a2, 35
  90baea:	089801        	and	a8, a9, a8
  90baed:	088a57        	extui	a10, a8, 24, 8
  90baf0:	2a2420        	s8i	a10, a2, 32
  90baf3:	080a57        	extui	a10, a8, 16, 8
  90baf6:	088847        	extui	a8, a8, 8, 8
  90baf9:	2a2421        	s8i	a10, a2, 33
  90bafc:	282422        	s8i	a8, a2, 34
  90baff:	d10f      	retw.n
  90bb01:	000000        	ill

0090bb04 <ar5416Clr11nAggr_20>:
}

void ar5416Clr11nAggr_20(struct ath_tx_desc *ds)
{
  90bb04:	6c1004        	entry	a1, 32
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 &= (~AR_IsAggr & ~AR_MoreAggr);
  90bb07:	2a200c        	l8ui	a10, a2, 12
  90bb0a:	28200d        	l8ui	a8, a2, 13
  90bb0d:	29200e        	l8ui	a9, a2, 14
  90bb10:	08aa10        	slli	a10, a10, 24
  90bb13:	008811        	slli	a8, a8, 16
  90bb16:	0a8802        	or	a8, a8, a10
  90bb19:	089911        	slli	a9, a9, 8
  90bb1c:	089902        	or	a9, a9, a8
  90bb1f:	28200f        	l8ui	a8, a2, 15
  90bb22:	098902        	or	a9, a8, a9
  90bb25:	186ad0        	l32r	a8, 8e6668 <strcmp+0x108>
  90bb28:	29240f        	s8i	a9, a2, 15
  90bb2b:	089801        	and	a8, a9, a8
  90bb2e:	088a57        	extui	a10, a8, 24, 8
  90bb31:	2a240c        	s8i	a10, a2, 12
  90bb34:	080a57        	extui	a10, a8, 16, 8
  90bb37:	088847        	extui	a8, a8, 8, 8
  90bb3a:	2a240d        	s8i	a10, a2, 13
  90bb3d:	28240e        	s8i	a8, a2, 14
  90bb40:	d10f      	retw.n
	...

0090bb44 <ar5416Set11nBurstDuration_20>:
}

void ar5416Set11nBurstDuration_20(struct ath_tx_desc *ds,
				  a_uint32_t burstDuration)
{
  90bb44:	6c1004        	entry	a1, 32
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl2 &= ~AR_BurstDur;
  90bb47:	2a2010        	l8ui	a10, a2, 16
  90bb4a:	292011        	l8ui	a9, a2, 17
  90bb4d:	282012        	l8ui	a8, a2, 18
  90bb50:	08aa10        	slli	a10, a10, 24
  90bb53:	009911        	slli	a9, a9, 16
  90bb56:	0a9902        	or	a9, a9, a10
  90bb59:	088811        	slli	a8, a8, 8
  90bb5c:	098802        	or	a8, a8, a9
  90bb5f:	292013        	l8ui	a9, a2, 19
	ads->ds_ctl2 |= SM(burstDuration, AR_BurstDur);
  90bb62:	03034e        	extui	a3, a3, 0, 15
void ar5416Set11nBurstDuration_20(struct ath_tx_desc *ds,
				  a_uint32_t burstDuration)
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl2 &= ~AR_BurstDur;
  90bb65:	089802        	or	a8, a9, a8
  90bb68:	196ad1        	l32r	a9, 8e66ac <strcmp+0x14c>
  90bb6b:	098801        	and	a8, a8, a9
	ads->ds_ctl2 |= SM(burstDuration, AR_BurstDur);
  90bb6e:	083802        	or	a8, a3, a8
  90bb71:	088957        	extui	a9, a8, 24, 8
  90bb74:	292410        	s8i	a9, a2, 16
  90bb77:	080957        	extui	a9, a8, 16, 8
  90bb7a:	292411        	s8i	a9, a2, 17
  90bb7d:	088947        	extui	a9, a8, 8, 8
  90bb80:	292412        	s8i	a9, a2, 18
  90bb83:	282413        	s8i	a8, a2, 19
  90bb86:	d10f      	retw.n

0090bb88 <ar5416Set11nVirtualMoreFrag_20>:
}

void ar5416Set11nVirtualMoreFrag_20(struct ath_tx_desc *ds,
				    a_uint32_t vmf)
{
  90bb88:	6c1004        	entry	a1, 32
  90bb8b:	282008        	l8ui	a8, a2, 8
  90bb8e:	292009        	l8ui	a9, a2, 9
	struct ar5416_desc *ads = AR5416DESC(ds);

	if (vmf) {
		ads->ds_ctl0 |= AR_VirtMoreFrag;
  90bb91:	088810        	slli	a8, a8, 24
  90bb94:	009911        	slli	a9, a9, 16
void ar5416Set11nVirtualMoreFrag_20(struct ath_tx_desc *ds,
				    a_uint32_t vmf)
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	if (vmf) {
  90bb97:	ca3d      	beqz.n	a3, 90bbc8 <ar5416Set11nVirtualMoreFrag_20+0x40>
		ads->ds_ctl0 |= AR_VirtMoreFrag;
  90bb99:	089902        	or	a9, a9, a8
  90bb9c:	28200a        	l8ui	a8, a2, 10
  90bb9f:	1a6a8f        	l32r	a10, 8e65dc <strcmp+0x7c>
  90bba2:	088811        	slli	a8, a8, 8
  90bba5:	098802        	or	a8, a8, a9
  90bba8:	29200b        	l8ui	a9, a2, 11
  90bbab:	089802        	or	a8, a9, a8
  90bbae:	0a8802        	or	a8, a8, a10
  90bbb1:	088957        	extui	a9, a8, 24, 8
  90bbb4:	292408        	s8i	a9, a2, 8
  90bbb7:	080957        	extui	a9, a8, 16, 8
  90bbba:	292409        	s8i	a9, a2, 9
  90bbbd:	088947        	extui	a9, a8, 8, 8
  90bbc0:	29240a        	s8i	a9, a2, 10
  90bbc3:	28240b        	s8i	a8, a2, 11
  90bbc6:	d10f      	retw.n
	} else {
		ads->ds_ctl0 &= ~AR_VirtMoreFrag;
  90bbc8:	089802        	or	a8, a9, a8
  90bbcb:	29200a        	l8ui	a9, a2, 10
  90bbce:	089911        	slli	a9, a9, 8
  90bbd1:	089902        	or	a9, a9, a8
  90bbd4:	28200b        	l8ui	a8, a2, 11
  90bbd7:	098902        	or	a9, a8, a9
  90bbda:	186ad2        	l32r	a8, 8e6724 <strcmp+0x1c4>
  90bbdd:	29240b        	s8i	a9, a2, 11
  90bbe0:	089801        	and	a8, a9, a8
  90bbe3:	088a57        	extui	a10, a8, 24, 8
  90bbe6:	2a2408        	s8i	a10, a2, 8
  90bbe9:	080a57        	extui	a10, a8, 16, 8
  90bbec:	088847        	extui	a8, a8, 8, 8
  90bbef:	2a2409        	s8i	a10, a2, 9
  90bbf2:	28240a        	s8i	a8, a2, 10
  90bbf5:	d10f      	retw.n
	...

0090bbf8 <ar5416StopTxDma>:

	return AH_TRUE;
}

HAL_BOOL ar5416StopTxDma(struct ath_hal*ah, a_uint32_t q)
{
  90bbf8:	6c1004        	entry	a1, 32
  90bbfb:	146ad3        	l32r	a4, 8e6748 <strcmp+0x1e8>
	
        HALASSERT(q < AH_PRIVATE(ah)->ah_caps.halTotalQueues);

        HALASSERT(AH5416(ah)->ah_txq[q].tqi_type != HAL_TX_QUEUE_INACTIVE);

	iowrite32_mac(AR_Q_TXD, 1 << q);
  90bbfe:	c081      	movi.n	a8, 1
  90bc00:	003104        	ssl	a3
  90bc03:	00881a        	sll	a8, a8
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90bc06:	0c0200        	memw
  90bc09:	9840      	s32i.n	a8, a4, 0
        for (i = 1000; i != 0; i--) {
  90bc0b:	243ae8        	movi	a4, 0x3e8
                if (ar5416NumTxPending(ah, q) == 0)
  90bc0e:	da20      	mov.n	a10, a2
  90bc10:	033b02        	or	a11, a3, a3
  90bc13:	5bfd9b        	call8	90b280 <ar5416NumTxPending>
  90bc16:	c8aa      	beqz.n	a10, 90bc24 <ar5416StopTxDma+0x2c>
                        break;
                OS_DELAY(100);        /* XXX get actual value */
  90bc18:	2a0a64        	movi	a10, 100
        HALASSERT(q < AH_PRIVATE(ah)->ah_caps.halTotalQueues);

        HALASSERT(AH5416(ah)->ah_txq[q].tqi_type != HAL_TX_QUEUE_INACTIVE);

	iowrite32_mac(AR_Q_TXD, 1 << q);
        for (i = 1000; i != 0; i--) {
  90bc1b:	244cff        	addi	a4, a4, -1
                if (ar5416NumTxPending(ah, q) == 0)
                        break;
                OS_DELAY(100);        /* XXX get actual value */
  90bc1e:	5befba        	call8	907b08 <ath_hal_delay>
        HALASSERT(q < AH_PRIVATE(ah)->ah_caps.halTotalQueues);

        HALASSERT(AH5416(ah)->ah_txq[q].tqi_type != HAL_TX_QUEUE_INACTIVE);

	iowrite32_mac(AR_Q_TXD, 1 << q);
        for (i = 1000; i != 0; i--) {
  90bc21:	654fe9        	bnez	a4, 90bc0e <ar5416StopTxDma+0x16>
  90bc24:	126ad3        	l32r	a2, 8e6770 <strcmp+0x210>
  90bc27:	c030      	movi.n	a3, 0
  90bc29:	0c0200        	memw
  90bc2c:	9320      	s32i.n	a3, a2, 0
                        break;
                OS_DELAY(100);        /* XXX get actual value */
        }

	iowrite32_mac(AR_Q_TXD, 0);
        return (i != 0);
  90bc2e:	c021      	movi.n	a2, 1
  90bc30:	043238        	moveqz	a2, a3, a4
}
  90bc33:	d10f      	retw.n
  90bc35:	000000        	ill

0090bc38 <ar5416AbortTxDma>:
#endif
        return npend;
}

HAL_BOOL ar5416AbortTxDma(struct ath_hal *ah)
{
  90bc38:	6c1004        	entry	a1, 32
  90bc3b:	136ad3        	l32r	a3, 8e6788 <strcmp+0x228>
  90bc3e:	243aff        	movi	a4, 0x3ff
  90bc41:	0c0200        	memw
  90bc44:	9430      	s32i.n	a4, a3, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90bc46:	136ad4        	l32r	a3, 8e6798 <strcmp+0x238>
	iowrite32_mac(AR_Q_TXD, AR_Q_TXD_M);

	/*
	 * set tx abort bits
	 */
	OS_REG_SET_BIT(ah, AR_PCU_MISC, (AR_PCU_FORCE_QUIET_COLL | AR_PCU_CLEAR_VMF));
  90bc49:	146ad5        	l32r	a4, 8e67a0 <strcmp+0x240>
  90bc4c:	0c0200        	memw
  90bc4f:	8830      	l32i.n	a8, a3, 0
  90bc51:	048402        	or	a4, a8, a4
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90bc54:	0c0200        	memw
  90bc57:	9430      	s32i.n	a4, a3, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90bc59:	136ab0        	l32r	a3, 8e671c <strcmp+0x1bc>
	OS_REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_FORCE_CH_IDLE_HIGH);
  90bc5c:	146ab9        	l32r	a4, 8e6740 <strcmp+0x1e0>
  90bc5f:	0c0200        	memw
  90bc62:	8830      	l32i.n	a8, a3, 0
  90bc64:	048402        	or	a4, a8, a4
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90bc67:	0c0200        	memw
  90bc6a:	9430      	s32i.n	a4, a3, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90bc6c:	136ad6        	l32r	a3, 8e67c4 <strcmp+0x264>
	OS_REG_SET_BIT(ah, AR_D_GBL_IFS_MISC, AR_D_GBL_IFS_MISC_IGNORE_BACKOFF);
  90bc6f:	146ac0        	l32r	a4, 8e6770 <strcmp+0x210>
  90bc72:	0c0200        	memw
  90bc75:	8830      	l32i.n	a8, a3, 0
  90bc77:	048402        	or	a4, a8, a4
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90bc7a:	0c0200        	memw
  90bc7d:	9430      	s32i.n	a4, a3, 0

	/*
	 * wait on all tx queues
	 */
	for (q = 0; q < AR_NUM_QCU; q++) {
  90bc7f:	c030      	movi.n	a3, 0
  90bc81:	60001b        	j	90bca0 <ar5416AbortTxDma+0x68>
  90bc84:	00da20        	excw
		for (i = 0; i < AR5416_ABORT_LOOPS; i++) {
			if (!ar5416NumTxPending(ah, q))
  90bc87:	db30      	mov.n	a11, a3
  90bc89:	5bfd7d        	call8	90b280 <ar5416NumTxPending>
  90bc8c:	64a05c        	beqz	a10, 90bcec <ar5416AbortTxDma+0xb4>
				break;

			OS_DELAY(AR5416_ABORT_WAIT);
  90bc8f:	2a0a05        	movi	a10, 5
  90bc92:	244cff        	addi	a4, a4, -1
  90bc95:	5bef9c        	call8	907b08 <ath_hal_delay>

	/*
	 * wait on all tx queues
	 */
	for (q = 0; q < AR_NUM_QCU; q++) {
		for (i = 0; i < AR5416_ABORT_LOOPS; i++) {
  90bc98:	654fe9        	bnez	a4, 90bc85 <ar5416AbortTxDma+0x4d>
				break;

			OS_DELAY(AR5416_ABORT_WAIT);
		}
		if (i == AR5416_ABORT_LOOPS) {
			return AH_FALSE;
  90bc9b:	d240      	mov.n	a2, a4
  90bc9d:	d10f      	retw.n
  90bc9f:	00243a        	movltz	a4, a2, a0
#endif
        return npend;
}

HAL_BOOL ar5416AbortTxDma(struct ath_hal *ah)
{
  90bca2:	e8          	.byte 0xe8
  90bca3:	63ffde        	j	90bc85 <ar5416AbortTxDma+0x4d>
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90bca6:	126ad4        	l32r	a2, 8e67f8 <strcmp+0x298>
	}

	/*
	 * clear tx abort bits
	 */
	OS_REG_CLR_BIT(ah, AR_PCU_MISC, (AR_PCU_FORCE_QUIET_COLL | AR_PCU_CLEAR_VMF));
  90bca9:	136ad7        	l32r	a3, 8e6808 <strcmp+0x2a8>
  90bcac:	0c0200        	memw
  90bcaf:	8420      	l32i.n	a4, a2, 0
  90bcb1:	034301        	and	a3, a4, a3
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90bcb4:	0c0200        	memw
  90bcb7:	9320      	s32i.n	a3, a2, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90bcb9:	126ab0        	l32r	a2, 8e677c <strcmp+0x21c>
	OS_REG_CLR_BIT(ah, AR_DIAG_SW, AR_DIAG_FORCE_CH_IDLE_HIGH);
  90bcbc:	136ac3        	l32r	a3, 8e67c8 <strcmp+0x268>
  90bcbf:	0c0200        	memw
  90bcc2:	8420      	l32i.n	a4, a2, 0
  90bcc4:	034301        	and	a3, a4, a3
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90bcc7:	0c0200        	memw
  90bcca:	9320      	s32i.n	a3, a2, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90bccc:	126ad6        	l32r	a2, 8e6824 <strcmp+0x2c4>
	OS_REG_CLR_BIT(ah, AR_D_GBL_IFS_MISC, AR_D_GBL_IFS_MISC_IGNORE_BACKOFF);
  90bccf:	136ad8        	l32r	a3, 8e6830 <strcmp+0x2d0>
  90bcd2:	0c0200        	memw
  90bcd5:	8420      	l32i.n	a4, a2, 0
  90bcd7:	034301        	and	a3, a4, a3
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90bcda:	0c0200        	memw
  90bcdd:	9320      	s32i.n	a3, a2, 0
  90bcdf:	126ad3        	l32r	a2, 8e682c <strcmp+0x2cc>
  90bce2:	0c0200        	memw
  90bce5:	9a20      	s32i.n	a10, a2, 0
	/*
	 * clear txd
	 */
	iowrite32_mac(AR_Q_TXD, 0);

	return AH_TRUE;
  90bce7:	c021      	movi.n	a2, 1
  90bce9:	d10f      	retw.n
  90bceb:	00b133        	excw
	OS_REG_SET_BIT(ah, AR_D_GBL_IFS_MISC, AR_D_GBL_IFS_MISC_IGNORE_BACKOFF);

	/*
	 * wait on all tx queues
	 */
	for (q = 0; q < AR_NUM_QCU; q++) {
  90bcee:	6939ae        	bnei	a3, 10, 90bca0 <ar5416AbortTxDma+0x68>
  90bcf1:	63ffb1        	j	90bca6 <ar5416AbortTxDma+0x6e>

0090bcf4 <ar5416StopDmaReceive>:
	iowrite32_mac(AR_RXDP, rxdp);
	HALASSERT(ioread32_mac(AR_RXDP) == rxdp);
}

HAL_BOOL ar5416StopDmaReceive(struct ath_hal *ah)
{
  90bcf4:	6c1004        	entry	a1, 32
  90bcf7:	186aaf        	l32r	a8, 8e67b4 <strcmp+0x254>
  90bcfa:	c290      	movi.n	a9, 32
  90bcfc:	0c0200        	memw
  90bcff:	9980      	s32i.n	a9, a8, 0
	iowrite32_mac(AR_CR, AR_CR_RXD); /* Set receive disable bit */
	if (!ath_hal_wait(ah, AR_CR, AR_CR_RXE, 0)) {
  90bd01:	da20      	mov.n	a10, a2
  90bd03:	c0b8      	movi.n	a11, 8
  90bd05:	c0c4      	movi.n	a12, 4
  90bd07:	c0d0      	movi.n	a13, 0
  90bd09:	5bfc50        	call8	90ae4c <ath_hal_wait>
  90bd0c:	c081      	movi.n	a8, 1
  90bd0e:	c020      	movi.n	a2, 0
  90bd10:	0a8239        	movnez	a2, a8, a10
		return AH_FALSE;
	} else {
		return AH_TRUE;
	}
}
  90bd13:	d10f      	retw.n
  90bd15:	000000        	ill

0090bd18 <ar5416Detach>:
		.ah_setInterrupts        = ar5416SetInterrupts,
	},
};

void ar5416Detach(struct ath_hal *ah)
{
  90bd18:	6c1004        	entry	a1, 32
	HALASSERT(ah != AH_NULL);
	ath_hal_free(ah);
  90bd1b:	da20      	mov.n	a10, a2
  90bd1d:	5bef87        	call8	907b3c <ath_hal_free>
  90bd20:	d10f      	retw.n
	...

0090bd24 <ar5416GetPendingInterrupts>:
	 */
	return ((host_isr != AR_INTR_SPURIOUS) && (host_isr & AR_INTR_MAC_IRQ));
}

HAL_BOOL ar5416GetPendingInterrupts(struct ath_hal *ah, HAL_INT *masked)
{
  90bd24:	6c1004        	entry	a1, 32
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90bd27:	186aa2        	l32r	a8, 8e67b0 <strcmp+0x250>
  90bd2a:	0c0200        	memw
  90bd2d:	8980      	l32i.n	a9, a8, 0
#ifndef AR9100
	HAL_BOOL fatal_int = AH_FALSE;
	a_uint32_t sync_cause;

	if (ioread32_mac(AR_INTR_ASYNC_CAUSE)
			& AR_INTR_MAC_IRQ) {
  90bd2f:	c082      	movi.n	a8, 2
  90bd31:	089801        	and	a8, a9, a8
	a_uint32_t isr;
#ifndef AR9100
	HAL_BOOL fatal_int = AH_FALSE;
	a_uint32_t sync_cause;

	if (ioread32_mac(AR_INTR_ASYNC_CAUSE)
  90bd34:	c980      	beqz.n	a8, 90bd48 <ar5416GetPendingInterrupts+0x24>
  90bd36:	186ad9        	l32r	a8, 8e689c <strcmp+0x33c>
  90bd39:	0c0200        	memw
  90bd3c:	8880      	l32i.n	a8, a8, 0
			& AR_INTR_MAC_IRQ) {
		if ((ioread32_mac(AR_RTC_STATUS)
				& AR_RTC_STATUS_M) != AR_RTC_STATUS_ON) {
  90bd3e:	080843        	extui	a8, a8, 0, 4
	HAL_BOOL fatal_int = AH_FALSE;
	a_uint32_t sync_cause;

	if (ioread32_mac(AR_INTR_ASYNC_CAUSE)
			& AR_INTR_MAC_IRQ) {
		if ((ioread32_mac(AR_RTC_STATUS)
  90bd41:	68820b        	beqi	a8, 2, 90bd50 <ar5416GetPendingInterrupts+0x2c>
  90bd44:	600013        	j	90bd5b <ar5416GetPendingInterrupts+0x37>
  90bd47:	009830        	excw
			*masked = 0;
			return AH_FALSE;
		}
	} else {
		*masked = 0;
		return AH_FALSE;
  90bd4a:	d280      	mov.n	a2, a8
  90bd4c:	d10f      	retw.n
  90bd4e:	000018        	src	a0, a0, a0
  90bd51:	6ada0c        	blti	a13, 12, 90bd61 <ar5416GetPendingInterrupts+0x3d>
  90bd54:	020088        	excw
  90bd57:	8069      	l32i.n	a0, a6, 36
	}
#endif
	isr = ioread32_mac(AR_ISR_RAC);
	if (isr == 0xffffffff) {
  90bd59:	8005      	l32i.n	a0, a0, 20
		*masked = 0;
  90bd5b:	c020      	movi.n	a2, 0
  90bd5d:	9230      	s32i.n	a2, a3, 0
  90bd5f:	d10f      	retw.n
		return AH_FALSE;
	}

	*masked = isr & HAL_INT_COMMON;
  90bd61:	1a6aa4        	l32r	a10, 8e67f4 <strcmp+0x294>
	if (isr & (AR_ISR_TXMINTR | AR_ISR_TXINTM)) {
		*masked |= HAL_INT_TX;
	}
#endif

	if (isr & AR_ISR_BCNMISC) {
  90bd64:	1b6aa6        	l32r	a11, 8e67fc <strcmp+0x29c>
	if (isr == 0xffffffff) {
		*masked = 0;
		return AH_FALSE;
	}

	*masked = isr & HAL_INT_COMMON;
  90bd67:	0a8a01        	and	a10, a8, a10
  90bd6a:	2a3600        	s32i	a10, a3, 0
	if (isr & (AR_ISR_TXMINTR | AR_ISR_TXINTM)) {
		*masked |= HAL_INT_TX;
	}
#endif

	if (isr & AR_ISR_BCNMISC) {
  90bd6d:	7b8021        	bnone	a8, a11, 90bd92 <ar5416GetPendingInterrupts+0x6e>
  90bd70:	196adb        	l32r	a9, 8e68dc <strcmp+0x37c>
  90bd73:	0c0200        	memw
  90bd76:	8990      	l32i.n	a9, a9, 0
		a_uint32_t s2_s;

		s2_s = ioread32_mac(AR_ISR_S2_S);

		if (s2_s & AR_ISR_S2_GTT) {
  90bd78:	7b9008        	bnone	a9, a11, 90bd84 <ar5416GetPendingInterrupts+0x60>
			*masked |= HAL_INT_GTT;
  90bd7b:	1b6ab8        	l32r	a11, 8e685c <strcmp+0x2fc>
  90bd7e:	0baa02        	or	a10, a10, a11
  90bd81:	2a3600        	s32i	a10, a3, 0
		}

		if (s2_s & AR_ISR_S2_CST) {
  90bd84:	79960a        	bbci	a9, 9, 90bd92 <ar5416GetPendingInterrupts+0x6e>
			*masked |= HAL_INT_CST;
  90bd87:	8a30      	l32i.n	a10, a3, 0
  90bd89:	196a20        	l32r	a9, 8e660c <strcmp+0xac>
  90bd8c:	09a902        	or	a9, a10, a9
  90bd8f:	293600        	s32i	a9, a3, 0
		}
	}

	if (isr & (AR_ISR_RXOK | AR_ISR_RXERR))
  90bd92:	c095      	movi.n	a9, 5
  90bd94:	798009        	bnone	a8, a9, 90bda1 <ar5416GetPendingInterrupts+0x7d>
		*masked |= HAL_INT_RX;
  90bd97:	8a30      	l32i.n	a10, a3, 0
  90bd99:	c091      	movi.n	a9, 1
  90bd9b:	09a902        	or	a9, a10, a9
  90bd9e:	293600        	s32i	a9, a3, 0
	if (isr & (AR_ISR_TXOK | AR_ISR_TXDESC | AR_ISR_TXERR | AR_ISR_TXEOL)) {
  90bda1:	295ac0        	movi	a9, 0x5c0
  90bda4:	79803c        	bnone	a8, a9, 90bde4 <ar5416GetPendingInterrupts+0xc0>
		struct ath_hal_5416 *ahp = AH5416(ah);
		a_uint32_t           s0_s, s1_s;

		*masked |= HAL_INT_TX;
  90bda7:	8930      	l32i.n	a9, a3, 0
  90bda9:	c480      	movi.n	a8, 64
  90bdab:	089802        	or	a8, a9, a8
  90bdae:	9830      	s32i.n	a8, a3, 0
  90bdb0:	136adc        	l32r	a3, 8e6920 <strcmp+0x3c0>
  90bdb3:	0c0200        	memw
  90bdb6:	8930      	l32i.n	a9, a3, 0
  90bdb8:	136add        	l32r	a3, 8e692c <strcmp+0x3cc>
  90bdbb:	0c0200        	memw
  90bdbe:	8830      	l32i.n	a8, a3, 0
		s0_s = ioread32_mac(AR_ISR_S0_S);
		s1_s = ioread32_mac(AR_ISR_S1_S);
		ahp->ah_intrTxqs |= MS(s0_s, AR_ISR_S0_QCU_TXOK);
		ahp->ah_intrTxqs |= MS(s0_s, AR_ISR_S0_QCU_TXDESC);
  90bdc0:	232239        	l32i	a3, a2, 228
		ahp->ah_intrTxqs |= MS(s1_s, AR_ISR_S1_QCU_TXERR);
  90bdc3:	098a02        	or	a10, a8, a9
		a_uint32_t           s0_s, s1_s;

		*masked |= HAL_INT_TX;
		s0_s = ioread32_mac(AR_ISR_S0_S);
		s1_s = ioread32_mac(AR_ISR_S1_S);
		ahp->ah_intrTxqs |= MS(s0_s, AR_ISR_S0_QCU_TXOK);
  90bdc6:	0a0a49        	extui	a10, a10, 0, 10
		ahp->ah_intrTxqs |= MS(s0_s, AR_ISR_S0_QCU_TXDESC);
  90bdc9:	03aa02        	or	a10, a10, a3
  90bdcc:	136ade        	l32r	a3, 8e6944 <strcmp+0x3e4>
  90bdcf:	039901        	and	a9, a9, a3
		ahp->ah_intrTxqs |= MS(s1_s, AR_ISR_S1_QCU_TXERR);
		ahp->ah_intrTxqs |= MS(s1_s, AR_ISR_S1_QCU_TXEOL);
  90bdd2:	038801        	and	a8, a8, a3

		*masked |= HAL_INT_TX;
		s0_s = ioread32_mac(AR_ISR_S0_S);
		s1_s = ioread32_mac(AR_ISR_S1_S);
		ahp->ah_intrTxqs |= MS(s0_s, AR_ISR_S0_QCU_TXOK);
		ahp->ah_intrTxqs |= MS(s0_s, AR_ISR_S0_QCU_TXDESC);
  90bdd5:	09095f        	extui	a9, a9, 16, 16
		ahp->ah_intrTxqs |= MS(s1_s, AR_ISR_S1_QCU_TXERR);
  90bdd8:	09a902        	or	a9, a10, a9
		ahp->ah_intrTxqs |= MS(s1_s, AR_ISR_S1_QCU_TXEOL);
  90bddb:	08085f        	extui	a8, a8, 16, 16
  90bdde:	089302        	or	a3, a9, a8
  90bde1:	232639        	s32i	a3, a2, 228
  90bde4:	136adf        	l32r	a3, 8e6960 <xthal_get_ccount+0x8>
	if (AH_TRUE == fatal_int) {
		iowrite32_mac(AR_INTR_SYNC_CAUSE_CLR, sync_cause);
		(void) ioread32_mac(AR_INTR_SYNC_CAUSE_CLR);
	}
#endif
	return AH_TRUE;
  90bde7:	c021      	movi.n	a2, 1
  90bde9:	0c0200        	memw
  90bdec:	8830      	l32i.n	a8, a3, 0

#ifndef AR9100
	sync_cause = ioread32_mac(AR_INTR_SYNC_CAUSE);
	fatal_int = ((sync_cause != AR_INTR_SPURIOUS) &&
		     (sync_cause & (AR_INTR_SYNC_HOST1_FATAL
		      | AR_INTR_SYNC_HOST1_PERR))) ? AH_TRUE : AH_FALSE;
  90bdee:	68800f        	beqi	a8, -1, 90be01 <ar5416GetPendingInterrupts+0xdd>
  90bdf1:	290a60        	movi	a9, 96
  90bdf4:	798009        	bnone	a8, a9, 90be01 <ar5416GetPendingInterrupts+0xdd>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90bdf7:	0c0200        	memw
  90bdfa:	9830      	s32i.n	a8, a3, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90bdfc:	0c0200        	memw
  90bdff:	8330      	l32i.n	a3, a3, 0
		iowrite32_mac(AR_INTR_SYNC_CAUSE_CLR, sync_cause);
		(void) ioread32_mac(AR_INTR_SYNC_CAUSE_CLR);
	}
#endif
	return AH_TRUE;
}
  90be01:	d10f      	retw.n
	...

0090be04 <ar5416SetRxFilter>:
		return AH_TRUE;
	}
}

void ar5416SetRxFilter(struct ath_hal *ah, a_uint32_t bits)
{
  90be04:	6c1004        	entry	a1, 32
	a_uint32_t phybits;
    
	iowrite32_mac(AR_RX_FILTER, (bits & 0xff) | AR_RX_COMPR_BAR);
  90be07:	284a00        	movi	a8, 0x400
  90be0a:	030947        	extui	a9, a3, 0, 8
  90be0d:	089902        	or	a9, a9, a8
	phybits = 0;
	if (bits & HAL_RX_FILTER_PHYRADAR)
  90be10:	1a6a01        	l32r	a10, 8e6614 <strcmp+0xb4>
  90be13:	186ae0        	l32r	a8, 8e6994 <xthal_get_intenable+0x14>
  90be16:	0a3a01        	and	a10, a3, a10
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90be19:	0c0200        	memw
  90be1c:	9980      	s32i.n	a9, a8, 0
		phybits |= AR_PHY_ERR_RADAR;
  90be1e:	280a20        	movi	a8, 32
  90be21:	290a00        	movi	a9, 0
  90be24:	0a9838        	moveqz	a8, a9, a10
	if (bits & HAL_RX_FILTER_PHYERR)
  90be27:	773705        	bbci	a3, 23, 90be30 <ar5416SetRxFilter+0x2c>
		phybits |= AR_PHY_ERR_OFDM_TIMING | AR_PHY_ERR_CCK_TIMING;
  90be2a:	136ae1        	l32r	a3, 8e69b0 <__divsi3+0x18>
  90be2d:	038802        	or	a8, a8, a3
  90be30:	136ae2        	l32r	a3, 8e69b8 <__divsi3+0x20>
  90be33:	196ae3        	l32r	a9, 8e69c0 <__divsi3+0x28>
  90be36:	0c0200        	memw
  90be39:	9830      	s32i.n	a8, a3, 0
	iowrite32_mac(AR_PHY_ERR, phybits);
	if (phybits) {
  90be3b:	c88d      	beqz.n	a8, 90be4c <ar5416SetRxFilter+0x48>
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90be3d:	0c0200        	memw
  90be40:	8890      	l32i.n	a8, a9, 0
		iowrite32_mac(AR_RXCFG,
  90be42:	c130      	movi.n	a3, 16
  90be44:	038302        	or	a3, a8, a3
  90be47:	60000b        	j	90be56 <ar5416SetRxFilter+0x52>
  90be4a:	00000c        	sub	a0, a0, a0
  90be4d:	020088        	excw
  90be50:	90c6      	s32i.n	a0, a12, 24
			     ioread32_mac(AR_RXCFG)
			     | AR_RXCFG_ZLFDMA);
	} else {
		iowrite32_mac(AR_RXCFG,
  90be52:	3f0383        	excw
  90be55:	010c02        	or	a12, a0, a1
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90be58:	009390        	l32e	a0, a9, -52
  90be5b:	d10f      	retw.n
  90be5d:	000000        	ill

0090be60 <ar5416ProcTxDesc_20>:
	ads->ds_ctl6 = SM(keyType, AR_EncrType);
	return AH_TRUE;
}

HAL_STATUS ar5416ProcTxDesc_20(struct ath_hal *ah, struct ath_tx_desc *gds)
{
  90be60:	6c1004        	entry	a1, 32
        struct ar5416_desc *ads = AR5416DESC(gds);
        struct ath_tx_desc *ds = (struct ath_tx_desc *)gds;
        
        if ((ads->ds_txstatus9 & AR_TxDone) == 0)
  90be63:	2a305c        	l8ui	a10, a3, 92
  90be66:	28305d        	l8ui	a8, a3, 93
  90be69:	29305e        	l8ui	a9, a3, 94
  90be6c:	08aa10        	slli	a10, a10, 24
  90be6f:	008811        	slli	a8, a8, 16
  90be72:	0a8802        	or	a8, a8, a10
  90be75:	089911        	slli	a9, a9, 8
  90be78:	089902        	or	a9, a9, a8
  90be7b:	28305f        	l8ui	a8, a3, 95
  90be7e:	098902        	or	a9, a8, a9
                return HAL_EINPROGRESS;
  90be81:	c08f      	movi.n	a8, 15
HAL_STATUS ar5416ProcTxDesc_20(struct ath_hal *ah, struct ath_tx_desc *gds)
{
        struct ar5416_desc *ads = AR5416DESC(gds);
        struct ath_tx_desc *ds = (struct ath_tx_desc *)gds;
        
        if ((ads->ds_txstatus9 & AR_TxDone) == 0)
  90be83:	7f9f02        	bbsi	a9, 31, 90be89 <ar5416ProcTxDesc_20+0x29>
  90be86:	60029b        	j	90c125 <ar5416ProcTxDesc_20+0x2c5>
                return HAL_EINPROGRESS;

        ads->ds_txstatus9 &= ~AR_TxDone;
  90be89:	c78e      	movi.n	a8, -2
  90be8b:	089801        	and	a8, a9, a8
  90be8e:	088b57        	extui	a11, a8, 24, 8
  90be91:	2b345c        	s8i	a11, a3, 92
  90be94:	080b57        	extui	a11, a8, 16, 8
  90be97:	2b345d        	s8i	a11, a3, 93
  90be9a:	28345f        	s8i	a8, a3, 95
  90be9d:	088b47        	extui	a11, a8, 8, 8

        /* Update software copies of the HW status */
        ds->ds_txstat.ts_seqnum = MS(ads->ds_txstatus9, AR_SeqNum);
  90bea0:	09184b        	extui	a8, a9, 1, 12
        struct ath_tx_desc *ds = (struct ath_tx_desc *)gds;
        
        if ((ads->ds_txstatus9 & AR_TxDone) == 0)
                return HAL_EINPROGRESS;

        ads->ds_txstatus9 &= ~AR_TxDone;
  90bea3:	2b345e        	s8i	a11, a3, 94

        /* Update software copies of the HW status */
        ds->ds_txstat.ts_seqnum = MS(ads->ds_txstatus9, AR_SeqNum);
  90bea6:	088b14        	srli	a11, a8, 8
  90bea9:	2b3464        	s8i	a11, a3, 100
        ds->ds_txstat.ts_tstamp = ads->AR_SendTimestamp;
  90beac:	2c3040        	l8ui	a12, a3, 64
  90beaf:	2b3041        	l8ui	a11, a3, 65
                return HAL_EINPROGRESS;

        ads->ds_txstatus9 &= ~AR_TxDone;

        /* Update software copies of the HW status */
        ds->ds_txstat.ts_seqnum = MS(ads->ds_txstatus9, AR_SeqNum);
  90beb2:	283465        	s8i	a8, a3, 101
        ds->ds_txstat.ts_tstamp = ads->AR_SendTimestamp;
  90beb5:	283042        	l8ui	a8, a3, 66
  90beb8:	08cc10        	slli	a12, a12, 24
  90bebb:	00bb11        	slli	a11, a11, 16
  90bebe:	0cbb02        	or	a11, a11, a12
  90bec1:	088811        	slli	a8, a8, 8
  90bec4:	0b8802        	or	a8, a8, a11
  90bec7:	2b3043        	l8ui	a11, a3, 67
        struct ath_tx_desc *ds = (struct ath_tx_desc *)gds;
        
        if ((ads->ds_txstatus9 & AR_TxDone) == 0)
                return HAL_EINPROGRESS;

        ads->ds_txstatus9 &= ~AR_TxDone;
  90beca:	c0a0      	movi.n	a10, 0

        /* Update software copies of the HW status */
        ds->ds_txstat.ts_seqnum = MS(ads->ds_txstatus9, AR_SeqNum);
        ds->ds_txstat.ts_tstamp = ads->AR_SendTimestamp;
  90becc:	08b802        	or	a8, a11, a8
  90becf:	088b57        	extui	a11, a8, 24, 8
  90bed2:	2b3460        	s8i	a11, a3, 96
  90bed5:	080b57        	extui	a11, a8, 16, 8
  90bed8:	2b3461        	s8i	a11, a3, 97
  90bedb:	088b47        	extui	a11, a8, 8, 8
  90bede:	2b3462        	s8i	a11, a3, 98
        ds->ds_txstat.ts_status = 0;
  90bee1:	2a3466        	s8i	a10, a3, 102
        ds->ds_txstat.ts_flags  = 0;
  90bee4:	2a3467        	s8i	a10, a3, 103

        if (ads->ds_txstatus1 & AR_ExcessiveRetries)
  90bee7:	2b303c        	l8ui	a11, a3, 60
  90beea:	2a303d        	l8ui	a10, a3, 61

        ads->ds_txstatus9 &= ~AR_TxDone;

        /* Update software copies of the HW status */
        ds->ds_txstat.ts_seqnum = MS(ads->ds_txstatus9, AR_SeqNum);
        ds->ds_txstat.ts_tstamp = ads->AR_SendTimestamp;
  90beed:	283463        	s8i	a8, a3, 99
        ds->ds_txstat.ts_status = 0;
        ds->ds_txstat.ts_flags  = 0;

        if (ads->ds_txstatus1 & AR_ExcessiveRetries)
  90bef0:	28303e        	l8ui	a8, a3, 62
  90bef3:	08bb10        	slli	a11, a11, 24
  90bef6:	00aa11        	slli	a10, a10, 16
  90bef9:	0baa02        	or	a10, a10, a11
  90befc:	088811        	slli	a8, a8, 8
  90beff:	0a8802        	or	a8, a8, a10
  90bf02:	2a303f        	l8ui	a10, a3, 63
  90bf05:	08a802        	or	a8, a10, a8
  90bf08:	7e8704        	bbci	a8, 30, 90bf10 <ar5416ProcTxDesc_20+0xb0>
                ds->ds_txstat.ts_status |= HAL_TXERR_XRETRY;
  90bf0b:	c0a1      	movi.n	a10, 1
  90bf0d:	2a3466        	s8i	a10, a3, 102
        if (ads->ds_txstatus1 & AR_Filtered)
  90bf10:	7c870a        	bbci	a8, 28, 90bf1e <ar5416ProcTxDesc_20+0xbe>
                ds->ds_txstat.ts_status |= HAL_TXERR_FILT;
  90bf13:	2b3066        	l8ui	a11, a3, 102
  90bf16:	c0a2      	movi.n	a10, 2
  90bf18:	0aba02        	or	a10, a11, a10
  90bf1b:	2a3466        	s8i	a10, a3, 102
        if (ads->ds_txstatus1 & AR_FIFOUnderrun)
  90bf1e:	c0a4      	movi.n	a10, 4
  90bf20:	7a8008        	bnone	a8, a10, 90bf2c <ar5416ProcTxDesc_20+0xcc>
                ds->ds_txstat.ts_status |= HAL_TXERR_FIFO;
  90bf23:	2b3066        	l8ui	a11, a3, 102
  90bf26:	0aba02        	or	a10, a11, a10
  90bf29:	2a3466        	s8i	a10, a3, 102
        if (ads->ds_txstatus9 & AR_TxOpExceeded)
  90bf2c:	7e960a        	bbci	a9, 14, 90bf3a <ar5416ProcTxDesc_20+0xda>
		ds->ds_txstat.ts_status |= HAL_TXERR_XTXOP;
  90bf2f:	2a3066        	l8ui	a10, a3, 102
  90bf32:	c098      	movi.n	a9, 8
  90bf34:	09a902        	or	a9, a10, a9
  90bf37:	293466        	s8i	a9, a3, 102
        if (ads->ds_txstatus1 & AR_TxTimerExpired)
  90bf3a:	7c860a        	bbci	a8, 12, 90bf48 <ar5416ProcTxDesc_20+0xe8>
		ds->ds_txstat.ts_status |= HAL_TXERR_TIMER_EXPIRED;
  90bf3d:	2a3066        	l8ui	a10, a3, 102
  90bf40:	c190      	movi.n	a9, 16
  90bf42:	09a902        	or	a9, a10, a9
  90bf45:	293466        	s8i	a9, a3, 102

        if (ads->ds_txstatus1 & AR_DescCfgErr)
  90bf48:	7d8604        	bbci	a8, 13, 90bf50 <ar5416ProcTxDesc_20+0xf0>
		ds->ds_txstat.ts_flags |= HAL_TX_DESC_CFG_ERR;
  90bf4b:	c094      	movi.n	a9, 4
  90bf4d:	293467        	s8i	a9, a3, 103
        if (ads->ds_txstatus1 & AR_TxDataUnderrun) {
  90bf50:	7e8611        	bbci	a8, 14, 90bf65 <ar5416ProcTxDesc_20+0x105>
		ds->ds_txstat.ts_flags |= HAL_TX_DATA_UNDERRUN;
  90bf53:	293067        	l8ui	a9, a3, 103
  90bf56:	c088      	movi.n	a8, 8
  90bf58:	089802        	or	a8, a9, a8
  90bf5b:	283467        	s8i	a8, a3, 103
		ar5416UpdateTxTrigLevel(ah, AH_TRUE);
  90bf5e:	da20      	mov.n	a10, a2
  90bf60:	c0b1      	movi.n	a11, 1
  90bf62:	5bfca3        	call8	90b1f0 <ar5416UpdateTxTrigLevel>
	}
        if (ads->ds_txstatus1 & AR_TxDelimUnderrun) {
  90bf65:	28303d        	l8ui	a8, a3, 61
  90bf68:	7f8711        	bbci	a8, 31, 90bf7d <ar5416ProcTxDesc_20+0x11d>
		ds->ds_txstat.ts_flags |= HAL_TX_DELIM_UNDERRUN;
  90bf6b:	293067        	l8ui	a9, a3, 103
  90bf6e:	c180      	movi.n	a8, 16
  90bf70:	089802        	or	a8, a9, a8
  90bf73:	283467        	s8i	a8, a3, 103
		ar5416UpdateTxTrigLevel(ah, AH_TRUE);
  90bf76:	da20      	mov.n	a10, a2
  90bf78:	c0b1      	movi.n	a11, 1
  90bf7a:	5bfc9d        	call8	90b1f0 <ar5416UpdateTxTrigLevel>
	}
        if (ads->ds_txstatus0 & AR_TxBaStatus) {
  90bf7d:	283038        	l8ui	a8, a3, 56
  90bf80:	223039        	l8ui	a2, a3, 57
  90bf83:	29303a        	l8ui	a9, a3, 58
  90bf86:	088810        	slli	a8, a8, 24
  90bf89:	002211        	slli	a2, a2, 16
  90bf8c:	082202        	or	a2, a2, a8
  90bf8f:	089911        	slli	a9, a9, 8
  90bf92:	029902        	or	a9, a9, a2
  90bf95:	22303b        	l8ui	a2, a3, 59
  90bf98:	092902        	or	a9, a2, a9
  90bf9b:	719671        	bbci	a9, 1, 90c010 <ar5416ProcTxDesc_20+0x1b0>
		ds->ds_txstat.ts_flags |= HAL_TX_BA;
  90bf9e:	283067        	l8ui	a8, a3, 103
  90bfa1:	220a01        	movi	a2, 1
  90bfa4:	028202        	or	a2, a8, a2
  90bfa7:	223467        	s8i	a2, a3, 103
		ds->ds_txstat.ba_low = ads->AR_BaBitmapLow;
  90bfaa:	2a3044        	l8ui	a10, a3, 68
  90bfad:	223045        	l8ui	a2, a3, 69
  90bfb0:	283046        	l8ui	a8, a3, 70
  90bfb3:	08aa10        	slli	a10, a10, 24
  90bfb6:	002211        	slli	a2, a2, 16
  90bfb9:	0a2202        	or	a2, a2, a10
  90bfbc:	088811        	slli	a8, a8, 8
  90bfbf:	028802        	or	a8, a8, a2
  90bfc2:	223047        	l8ui	a2, a3, 71
		ds->ds_txstat.ba_high = ads->AR_BaBitmapHigh;
  90bfc5:	2a3048        	l8ui	a10, a3, 72
		ds->ds_txstat.ts_flags |= HAL_TX_DELIM_UNDERRUN;
		ar5416UpdateTxTrigLevel(ah, AH_TRUE);
	}
        if (ads->ds_txstatus0 & AR_TxBaStatus) {
		ds->ds_txstat.ts_flags |= HAL_TX_BA;
		ds->ds_txstat.ba_low = ads->AR_BaBitmapLow;
  90bfc8:	082802        	or	a8, a2, a8
  90bfcb:	088257        	extui	a2, a8, 24, 8
  90bfce:	223474        	s8i	a2, a3, 116
  90bfd1:	080257        	extui	a2, a8, 16, 8
  90bfd4:	223475        	s8i	a2, a3, 117
  90bfd7:	088247        	extui	a2, a8, 8, 8
  90bfda:	223476        	s8i	a2, a3, 118
		ds->ds_txstat.ba_high = ads->AR_BaBitmapHigh;
  90bfdd:	223049        	l8ui	a2, a3, 73
		ds->ds_txstat.ts_flags |= HAL_TX_DELIM_UNDERRUN;
		ar5416UpdateTxTrigLevel(ah, AH_TRUE);
	}
        if (ads->ds_txstatus0 & AR_TxBaStatus) {
		ds->ds_txstat.ts_flags |= HAL_TX_BA;
		ds->ds_txstat.ba_low = ads->AR_BaBitmapLow;
  90bfe0:	283477        	s8i	a8, a3, 119
		ds->ds_txstat.ba_high = ads->AR_BaBitmapHigh;
  90bfe3:	28304a        	l8ui	a8, a3, 74
  90bfe6:	08aa10        	slli	a10, a10, 24
  90bfe9:	002211        	slli	a2, a2, 16
  90bfec:	0a2202        	or	a2, a2, a10
  90bfef:	088811        	slli	a8, a8, 8
  90bff2:	028802        	or	a8, a8, a2
  90bff5:	22304b        	l8ui	a2, a3, 75
  90bff8:	082802        	or	a8, a2, a8
  90bffb:	088257        	extui	a2, a8, 24, 8
  90bffe:	223478        	s8i	a2, a3, 120
  90c001:	080257        	extui	a2, a8, 16, 8
  90c004:	223479        	s8i	a2, a3, 121
  90c007:	088247        	extui	a2, a8, 8, 8
  90c00a:	22347a        	s8i	a2, a3, 122
  90c00d:	28347b        	s8i	a8, a3, 123

        /*
         * Extract the transmit rate used and mark the rate as
         * ``alternate'' if it wasn't the series 0 rate.
         */
        ds->ds_txstat.ts_rate = MS(ads->ds_txstatus9, AR_FinalTxIdx);
  90c010:	28305c        	l8ui	a8, a3, 92
  90c013:	22305d        	l8ui	a2, a3, 93
  90c016:	088810        	slli	a8, a8, 24
  90c019:	002211        	slli	a2, a2, 16
  90c01c:	082202        	or	a2, a2, a8
  90c01f:	186ae4        	l32r	a8, 8e6bb0 <memcpy+0x4c>
        ds->ds_txstat.ts_rssi_combined = 
		MS(ads->ds_txstatus5, AR_TxRSSICombined);
  90c022:	2a304c        	l8ui	a10, a3, 76

        /*
         * Extract the transmit rate used and mark the rate as
         * ``alternate'' if it wasn't the series 0 rate.
         */
        ds->ds_txstat.ts_rate = MS(ads->ds_txstatus9, AR_FinalTxIdx);
  90c025:	082201        	and	a2, a2, a8
  90c028:	02525a        	extui	a2, a2, 21, 11
  90c02b:	223468        	s8i	a2, a3, 104
        ds->ds_txstat.ts_rssi_combined = 
		MS(ads->ds_txstatus5, AR_TxRSSICombined);
  90c02e:	22304d        	l8ui	a2, a3, 77
  90c031:	08aa10        	slli	a10, a10, 24
  90c034:	28304e        	l8ui	a8, a3, 78
  90c037:	002211        	slli	a2, a2, 16
  90c03a:	0a2202        	or	a2, a2, a10
        ds->ds_txstat.ts_rssi_ctl0 = MS(ads->ds_txstatus0, AR_TxRSSIAnt00);
        ds->ds_txstat.ts_rssi_ctl1 = MS(ads->ds_txstatus0, AR_TxRSSIAnt01);
  90c03d:	098a47        	extui	a10, a9, 8, 8
  90c040:	2a346b        	s8i	a10, a3, 107
         * Extract the transmit rate used and mark the rate as
         * ``alternate'' if it wasn't the series 0 rate.
         */
        ds->ds_txstat.ts_rate = MS(ads->ds_txstatus9, AR_FinalTxIdx);
        ds->ds_txstat.ts_rssi_combined = 
		MS(ads->ds_txstatus5, AR_TxRSSICombined);
  90c043:	088811        	slli	a8, a8, 8
        ds->ds_txstat.ts_rssi_ctl0 = MS(ads->ds_txstatus0, AR_TxRSSIAnt00);
        ds->ds_txstat.ts_rssi_ctl1 = MS(ads->ds_txstatus0, AR_TxRSSIAnt01);
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
  90c046:	1a6ac6        	l32r	a10, 8e6b60 <__udivsi3+0x114>
         * Extract the transmit rate used and mark the rate as
         * ``alternate'' if it wasn't the series 0 rate.
         */
        ds->ds_txstat.ts_rate = MS(ads->ds_txstatus9, AR_FinalTxIdx);
        ds->ds_txstat.ts_rssi_combined = 
		MS(ads->ds_txstatus5, AR_TxRSSICombined);
  90c049:	028802        	or	a8, a8, a2
  90c04c:	22304f        	l8ui	a2, a3, 79
        ds->ds_txstat.ts_rssi_ctl0 = MS(ads->ds_txstatus0, AR_TxRSSIAnt00);
  90c04f:	29346a        	s8i	a9, a3, 106
        ds->ds_txstat.ts_rssi_ctl1 = MS(ads->ds_txstatus0, AR_TxRSSIAnt01);
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
  90c052:	0a9901        	and	a9, a9, a10
         * Extract the transmit rate used and mark the rate as
         * ``alternate'' if it wasn't the series 0 rate.
         */
        ds->ds_txstat.ts_rate = MS(ads->ds_txstatus9, AR_FinalTxIdx);
        ds->ds_txstat.ts_rssi_combined = 
		MS(ads->ds_txstatus5, AR_TxRSSICombined);
  90c055:	082802        	or	a8, a2, a8
        ds->ds_txstat.ts_rssi_ctl0 = MS(ads->ds_txstatus0, AR_TxRSSIAnt00);
        ds->ds_txstat.ts_rssi_ctl1 = MS(ads->ds_txstatus0, AR_TxRSSIAnt01);
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
  90c058:	09095f        	extui	a9, a9, 16, 16
         * Extract the transmit rate used and mark the rate as
         * ``alternate'' if it wasn't the series 0 rate.
         */
        ds->ds_txstat.ts_rate = MS(ads->ds_txstatus9, AR_FinalTxIdx);
        ds->ds_txstat.ts_rssi_combined = 
		MS(ads->ds_txstatus5, AR_TxRSSICombined);
  90c05b:	088257        	extui	a2, a8, 24, 8
        ds->ds_txstat.ts_rssi_ctl0 = MS(ads->ds_txstatus0, AR_TxRSSIAnt00);
        ds->ds_txstat.ts_rssi_ctl1 = MS(ads->ds_txstatus0, AR_TxRSSIAnt01);
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
  90c05e:	29346c        	s8i	a9, a3, 108
        ds->ds_txstat.ts_rssi_ext0 = MS(ads->ds_txstatus5, AR_TxRSSIAnt10);
        ds->ds_txstat.ts_rssi_ext1 = MS(ads->ds_txstatus5, AR_TxRSSIAnt11);
  90c061:	088947        	extui	a9, a8, 8, 8
        /*
         * Extract the transmit rate used and mark the rate as
         * ``alternate'' if it wasn't the series 0 rate.
         */
        ds->ds_txstat.ts_rate = MS(ads->ds_txstatus9, AR_FinalTxIdx);
        ds->ds_txstat.ts_rssi_combined = 
  90c064:	223469        	s8i	a2, a3, 105
		MS(ads->ds_txstatus5, AR_TxRSSICombined);
        ds->ds_txstat.ts_rssi_ctl0 = MS(ads->ds_txstatus0, AR_TxRSSIAnt00);
        ds->ds_txstat.ts_rssi_ctl1 = MS(ads->ds_txstatus0, AR_TxRSSIAnt01);
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
        ds->ds_txstat.ts_rssi_ext0 = MS(ads->ds_txstatus5, AR_TxRSSIAnt10);
        ds->ds_txstat.ts_rssi_ext1 = MS(ads->ds_txstatus5, AR_TxRSSIAnt11);
  90c067:	29346e        	s8i	a9, a3, 110
        ds->ds_txstat.ts_rssi_ext2 = MS(ads->ds_txstatus5, AR_TxRSSIAnt12);
        ds->ds_txstat.evm0 = ads->AR_TxEVM0;
  90c06a:	22347c        	s8i	a2, a3, 124
        ds->ds_txstat.ts_rssi_ctl0 = MS(ads->ds_txstatus0, AR_TxRSSIAnt00);
        ds->ds_txstat.ts_rssi_ctl1 = MS(ads->ds_txstatus0, AR_TxRSSIAnt01);
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
        ds->ds_txstat.ts_rssi_ext0 = MS(ads->ds_txstatus5, AR_TxRSSIAnt10);
        ds->ds_txstat.ts_rssi_ext1 = MS(ads->ds_txstatus5, AR_TxRSSIAnt11);
        ds->ds_txstat.ts_rssi_ext2 = MS(ads->ds_txstatus5, AR_TxRSSIAnt12);
  90c06d:	080957        	extui	a9, a8, 16, 8
        ds->ds_txstat.evm0 = ads->AR_TxEVM0;
  90c070:	088247        	extui	a2, a8, 8, 8
        ds->ds_txstat.ts_rssi_ctl0 = MS(ads->ds_txstatus0, AR_TxRSSIAnt00);
        ds->ds_txstat.ts_rssi_ctl1 = MS(ads->ds_txstatus0, AR_TxRSSIAnt01);
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
        ds->ds_txstat.ts_rssi_ext0 = MS(ads->ds_txstatus5, AR_TxRSSIAnt10);
        ds->ds_txstat.ts_rssi_ext1 = MS(ads->ds_txstatus5, AR_TxRSSIAnt11);
        ds->ds_txstat.ts_rssi_ext2 = MS(ads->ds_txstatus5, AR_TxRSSIAnt12);
  90c073:	29346f        	s8i	a9, a3, 111
        ds->ds_txstat.evm0 = ads->AR_TxEVM0;
  90c076:	29347d        	s8i	a9, a3, 125
  90c079:	22347e        	s8i	a2, a3, 126
        ds->ds_txstat.evm1 = ads->AR_TxEVM1;
  90c07c:	293050        	l8ui	a9, a3, 80
  90c07f:	223051        	l8ui	a2, a3, 81
        ds->ds_txstat.ts_rssi_combined = 
		MS(ads->ds_txstatus5, AR_TxRSSICombined);
        ds->ds_txstat.ts_rssi_ctl0 = MS(ads->ds_txstatus0, AR_TxRSSIAnt00);
        ds->ds_txstat.ts_rssi_ctl1 = MS(ads->ds_txstatus0, AR_TxRSSIAnt01);
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
        ds->ds_txstat.ts_rssi_ext0 = MS(ads->ds_txstatus5, AR_TxRSSIAnt10);
  90c082:	28346d        	s8i	a8, a3, 109
        ds->ds_txstat.ts_rssi_ext1 = MS(ads->ds_txstatus5, AR_TxRSSIAnt11);
        ds->ds_txstat.ts_rssi_ext2 = MS(ads->ds_txstatus5, AR_TxRSSIAnt12);
        ds->ds_txstat.evm0 = ads->AR_TxEVM0;
  90c085:	28347f        	s8i	a8, a3, 127
        ds->ds_txstat.evm1 = ads->AR_TxEVM1;
  90c088:	283052        	l8ui	a8, a3, 82
  90c08b:	089910        	slli	a9, a9, 24
  90c08e:	002211        	slli	a2, a2, 16
  90c091:	092202        	or	a2, a2, a9
  90c094:	088811        	slli	a8, a8, 8
  90c097:	028802        	or	a8, a8, a2
  90c09a:	223053        	l8ui	a2, a3, 83
        ds->ds_txstat.evm2 = ads->AR_TxEVM2;
  90c09d:	293054        	l8ui	a9, a3, 84
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
        ds->ds_txstat.ts_rssi_ext0 = MS(ads->ds_txstatus5, AR_TxRSSIAnt10);
        ds->ds_txstat.ts_rssi_ext1 = MS(ads->ds_txstatus5, AR_TxRSSIAnt11);
        ds->ds_txstat.ts_rssi_ext2 = MS(ads->ds_txstatus5, AR_TxRSSIAnt12);
        ds->ds_txstat.evm0 = ads->AR_TxEVM0;
        ds->ds_txstat.evm1 = ads->AR_TxEVM1;
  90c0a0:	082802        	or	a8, a2, a8
  90c0a3:	088257        	extui	a2, a8, 24, 8
  90c0a6:	223480        	s8i	a2, a3, 128
  90c0a9:	080257        	extui	a2, a8, 16, 8
  90c0ac:	223481        	s8i	a2, a3, 129
  90c0af:	088247        	extui	a2, a8, 8, 8
  90c0b2:	223482        	s8i	a2, a3, 130
        ds->ds_txstat.evm2 = ads->AR_TxEVM2;
  90c0b5:	223055        	l8ui	a2, a3, 85
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
        ds->ds_txstat.ts_rssi_ext0 = MS(ads->ds_txstatus5, AR_TxRSSIAnt10);
        ds->ds_txstat.ts_rssi_ext1 = MS(ads->ds_txstatus5, AR_TxRSSIAnt11);
        ds->ds_txstat.ts_rssi_ext2 = MS(ads->ds_txstatus5, AR_TxRSSIAnt12);
        ds->ds_txstat.evm0 = ads->AR_TxEVM0;
        ds->ds_txstat.evm1 = ads->AR_TxEVM1;
  90c0b8:	283483        	s8i	a8, a3, 131
        ds->ds_txstat.evm2 = ads->AR_TxEVM2;
  90c0bb:	283056        	l8ui	a8, a3, 86
  90c0be:	089910        	slli	a9, a9, 24
  90c0c1:	002211        	slli	a2, a2, 16
  90c0c4:	092202        	or	a2, a2, a9
  90c0c7:	088811        	slli	a8, a8, 8
  90c0ca:	028802        	or	a8, a8, a2
  90c0cd:	223057        	l8ui	a2, a3, 87
  90c0d0:	082802        	or	a8, a2, a8
  90c0d3:	088257        	extui	a2, a8, 24, 8
  90c0d6:	223484        	s8i	a2, a3, 132
  90c0d9:	080257        	extui	a2, a8, 16, 8
  90c0dc:	223485        	s8i	a2, a3, 133
  90c0df:	088247        	extui	a2, a8, 8, 8
  90c0e2:	223486        	s8i	a2, a3, 134
        ds->ds_txstat.ts_shortretry = MS(ads->ds_txstatus1, AR_RTSFailCnt);
  90c0e5:	29303c        	l8ui	a9, a3, 60
  90c0e8:	22303d        	l8ui	a2, a3, 61
        ds->ds_txstat.ts_rssi_ext0 = MS(ads->ds_txstatus5, AR_TxRSSIAnt10);
        ds->ds_txstat.ts_rssi_ext1 = MS(ads->ds_txstatus5, AR_TxRSSIAnt11);
        ds->ds_txstat.ts_rssi_ext2 = MS(ads->ds_txstatus5, AR_TxRSSIAnt12);
        ds->ds_txstat.evm0 = ads->AR_TxEVM0;
        ds->ds_txstat.evm1 = ads->AR_TxEVM1;
        ds->ds_txstat.evm2 = ads->AR_TxEVM2;
  90c0eb:	283487        	s8i	a8, a3, 135
        ds->ds_txstat.ts_shortretry = MS(ads->ds_txstatus1, AR_RTSFailCnt);
  90c0ee:	28303e        	l8ui	a8, a3, 62
  90c0f1:	089910        	slli	a9, a9, 24
  90c0f4:	002211        	slli	a2, a2, 16
  90c0f7:	092202        	or	a2, a2, a9
  90c0fa:	088811        	slli	a8, a8, 8
  90c0fd:	028802        	or	a8, a8, a2
  90c100:	22303f        	l8ui	a2, a3, 63
  90c103:	082802        	or	a8, a2, a8
  90c106:	084243        	extui	a2, a8, 4, 4
  90c109:	223470        	s8i	a2, a3, 112
        ds->ds_txstat.ts_longretry = MS(ads->ds_txstatus1, AR_DataFailCnt);
  90c10c:	088243        	extui	a2, a8, 8, 4
  90c10f:	223471        	s8i	a2, a3, 113
        ds->ds_txstat.ts_virtcol = MS(ads->ds_txstatus1, AR_VirtRetryCnt);
  90c112:	126ae5        	l32r	a2, 8e6ca8 <memcpy+0x144>
  90c115:	028801        	and	a8, a8, a2
  90c118:	08c814        	srli	a8, a8, 12
        ds->ds_txstat.ts_antenna = 0;		/* ignored for owl */
  90c11b:	c020      	movi.n	a2, 0
        ds->ds_txstat.evm0 = ads->AR_TxEVM0;
        ds->ds_txstat.evm1 = ads->AR_TxEVM1;
        ds->ds_txstat.evm2 = ads->AR_TxEVM2;
        ds->ds_txstat.ts_shortretry = MS(ads->ds_txstatus1, AR_RTSFailCnt);
        ds->ds_txstat.ts_longretry = MS(ads->ds_txstatus1, AR_DataFailCnt);
        ds->ds_txstat.ts_virtcol = MS(ads->ds_txstatus1, AR_VirtRetryCnt);
  90c11d:	283472        	s8i	a8, a3, 114
        ds->ds_txstat.ts_antenna = 0;		/* ignored for owl */
  90c120:	223473        	s8i	a2, a3, 115
  90c123:	c080      	movi.n	a8, 0

        return HAL_OK;
}
  90c125:	d280      	mov.n	a2, a8
  90c127:	d10f      	retw.n
  90c129:	000000        	ill

0090c12c <ar5416Attach>:
	ath_hal_free(ah);
}

struct ath_hal *
ar5416Attach(HAL_SOFTC sc, adf_os_device_t dev, HAL_STATUS *status)
{
  90c12c:	6c1004        	entry	a1, 32
	struct ath_hal_5416 *ahp;
	struct ath_hal *ah;

	ahp = ath_hal_malloc(sizeof (struct ath_hal_5416));
  90c12f:	2a1a44        	movi	a10, 0x144
  90c132:	5bee79        	call8	907b18 <ath_hal_malloc>
	ath_hal_free(ah);
}

struct ath_hal *
ar5416Attach(HAL_SOFTC sc, adf_os_device_t dev, HAL_STATUS *status)
{
  90c135:	d520      	mov.n	a5, a2
	struct ath_hal_5416 *ahp;
	struct ath_hal *ah;

	ahp = ath_hal_malloc(sizeof (struct ath_hal_5416));
  90c137:	d2a0      	mov.n	a2, a10
	if (ahp == AH_NULL) {
  90c139:	cca4      	bnez.n	a10, 90c141 <ar5416Attach+0x15>
		*status = HAL_ENOMEM;
  90c13b:	c032      	movi.n	a3, 2
  90c13d:	9340      	s32i.n	a3, a4, 0
		return AH_NULL;
  90c13f:	d10f      	retw.n
	}
	ah = &ahp->ah_priv.h;

	OS_MEMCPY(&ahp->ah_priv, &ar5416hal_10, sizeof(struct ath_hal_private));
  90c141:	1b6ae6        	l32r	a11, 8e6cdc <memcpy+0x178>
  90c144:	2c0ad4        	movi	a12, 212
  90c147:	5bee7f        	call8	907b44 <ath_hal_memcpy>

	ah->ah_dev = dev;
  90c14a:	9322      	s32i.n	a3, a2, 8
	ah->ah_sc = sc;

	ah->ah_set11nTxDesc        = ar5416Set11nTxDesc_20;
  90c14c:	136ae7        	l32r	a3, 8e6ce8 <memcpy+0x184>
	ah = &ahp->ah_priv.h;

	OS_MEMCPY(&ahp->ah_priv, &ar5416hal_10, sizeof(struct ath_hal_private));

	ah->ah_dev = dev;
	ah->ah_sc = sc;
  90c14f:	9521      	s32i.n	a5, a2, 4

	ah->ah_set11nTxDesc        = ar5416Set11nTxDesc_20;
  90c151:	932f      	s32i.n	a3, a2, 60
	ah->ah_set11nRateScenario  = ar5416Set11nRateScenario_20;
  90c153:	136ae8        	l32r	a3, 8e6cf4 <memcpy+0x190>
  90c156:	232610        	s32i	a3, a2, 64
	ah->ah_set11nAggrFirst     = ar5416Set11nAggrFirst_20;
  90c159:	136ae9        	l32r	a3, 8e6d00 <memcpy+0x19c>
  90c15c:	232611        	s32i	a3, a2, 68
	ah->ah_set11nAggrMiddle    = ar5416Set11nAggrMiddle_20;
  90c15f:	136aea        	l32r	a3, 8e6d08 <memcpy+0x1a4>
  90c162:	232612        	s32i	a3, a2, 72
	ah->ah_set11nAggrLast      = ar5416Set11nAggrLast_20;
  90c165:	136aeb        	l32r	a3, 8e6d14 <memcpy+0x1b0>
  90c168:	232613        	s32i	a3, a2, 76
	ah->ah_clr11nAggr          = ar5416Clr11nAggr_20;
  90c16b:	136aec        	l32r	a3, 8e6d1c <memcpy+0x1b8>
  90c16e:	232614        	s32i	a3, a2, 80
	ah->ah_set11nBurstDuration = ar5416Set11nBurstDuration_20;
  90c171:	136aed        	l32r	a3, 8e6d28 <memcpy+0x1c4>
  90c174:	232615        	s32i	a3, a2, 84
	ah->ah_setupRxDesc         = ar5416SetupRxDesc_20;
  90c177:	136aee        	l32r	a3, 8e6d30 <memcpy+0x1cc>
  90c17a:	232620        	s32i	a3, a2, 128
	ah->ah_procRxDescFast      = ar5416ProcRxDescFast_20;
  90c17d:	136aef        	l32r	a3, 8e6d3c <memcpy+0x1d8>
  90c180:	232622        	s32i	a3, a2, 136
	ah->ah_setupTxDesc         = ar5416SetupTxDesc_20;
  90c183:	136af0        	l32r	a3, 8e6d44 <memcpy+0x1e0>
  90c186:	232617        	s32i	a3, a2, 92
	ah->ah_fillTxDesc          = ar5416FillTxDesc_20;
  90c189:	136af1        	l32r	a3, 8e6d50 <memcpy+0x1ec>
  90c18c:	232618        	s32i	a3, a2, 96
	ah->ah_fillKeyTxDesc       = ar5416FillKeyTxDesc_20;
  90c18f:	136af2        	l32r	a3, 8e6d58 <memcpy+0x1f4>
  90c192:	232619        	s32i	a3, a2, 100
	ah->ah_procTxDesc          = ar5416ProcTxDesc_20;
  90c195:	136af3        	l32r	a3, 8e6d64 <memcpy+0x200>
  90c198:	23261a        	s32i	a3, a2, 104
	ah->ah_set11nVirtualMoreFrag = ar5416Set11nVirtualMoreFrag_20;
  90c19b:	136af4        	l32r	a3, 8e6d6c <memcpy+0x208>
  90c19e:	232616        	s32i	a3, a2, 88

	return ah;
}
  90c1a1:	d10f      	retw.n
	...

0090c1a4 <ar5416GetRateTable>:
#undef  HT
#undef  HT_HGI

const HAL_RATE_TABLE *
ar5416GetRateTable(struct ath_hal *ah, a_uint32_t mode)
{
  90c1a4:	6c1004        	entry	a1, 32
		break;
	case HAL_MODE_11B:
		rt = &ar5416_11b_table;
		break;
	case HAL_MODE_11G:
		rt =  &ar5416_11g_table;
  90c1a7:	126af9        	l32r	a2, 8e6d8c <memcpy+0x228>

const HAL_RATE_TABLE *
ar5416GetRateTable(struct ath_hal *ah, a_uint32_t mode)
{
	HAL_RATE_TABLE *rt;
	switch (mode) {
  90c1aa:	683826        	beqi	a3, 8, 90c1d4 <ar5416GetRateTable+0x30>
  90c1ad:	c028      	movi.n	a2, 8
  90c1af:	73230d        	bltu	a2, a3, 90c1c0 <ar5416GetRateTable+0x1c>
	case HAL_MODE_11A:
		rt = &ar5416_11a_table;
  90c1b2:	126af6        	l32r	a2, 8e6d8c <memcpy+0x228>

const HAL_RATE_TABLE *
ar5416GetRateTable(struct ath_hal *ah, a_uint32_t mode)
{
	HAL_RATE_TABLE *rt;
	switch (mode) {
  90c1b5:	68311b        	beqi	a3, 1, 90c1d4 <ar5416GetRateTable+0x30>
	case HAL_MODE_11A:
		rt = &ar5416_11a_table;
		break;
	case HAL_MODE_11B:
		rt = &ar5416_11b_table;
  90c1b8:	126af5        	l32r	a2, 8e6d8c <memcpy+0x228>

const HAL_RATE_TABLE *
ar5416GetRateTable(struct ath_hal *ah, a_uint32_t mode)
{
	HAL_RATE_TABLE *rt;
	switch (mode) {
  90c1bb:	693413        	bnei	a3, 4, 90c1d2 <ar5416GetRateTable+0x2e>
  90c1be:	d10f      	retw.n
  90c1c0:	186a32        	l32r	a8, 8e6a88 <__udivsi3+0x3c>
		break;
	case HAL_MODE_11G:
		rt =  &ar5416_11g_table;
		break;
	case HAL_MODE_11NG:
		rt = &ar5416_11ng_table;
  90c1c3:	126af8        	l32r	a2, 8e6da4 <memcpy+0x240>

const HAL_RATE_TABLE *
ar5416GetRateTable(struct ath_hal *ah, a_uint32_t mode)
{
	HAL_RATE_TABLE *rt;
	switch (mode) {
  90c1c6:	78310a        	beq	a3, a8, 90c1d4 <ar5416GetRateTable+0x30>
  90c1c9:	186a31        	l32r	a8, 8e6a90 <__udivsi3+0x44>
		break;
	case HAL_MODE_11NG:
		rt = &ar5416_11ng_table;
		break;
	case HAL_MODE_11NA:
		rt = &ar5416_11na_table;
  90c1cc:	126af7        	l32r	a2, 8e6da8 <memcpy+0x244>

const HAL_RATE_TABLE *
ar5416GetRateTable(struct ath_hal *ah, a_uint32_t mode)
{
	HAL_RATE_TABLE *rt;
	switch (mode) {
  90c1cf:	783101        	beq	a3, a8, 90c1d4 <ar5416GetRateTable+0x30>
		break;
	case HAL_MODE_11NA:
		rt = &ar5416_11na_table;
		break;
	default:
		return AH_NULL;
  90c1d2:	c020      	movi.n	a2, 0
	}

	return rt;
}
  90c1d4:	d10f      	retw.n
	...

0090c1d8 <rcRateSetseries>:
static void
rcRateSetseries(const RATE_TABLE_11N *pRateTable ,
                struct ath_rc_series *series,
		A_UINT8 tries, A_UINT8 rix,
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
  90c1d8:	6c1004        	entry	a1, 32
	series->tries = tries;
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
  90c1db:	c0b0      	movi.n	a11, 0
  90c1dd:	c190      	movi.n	a9, 16
  90c1df:	06b938        	moveqz	a9, a11, a6
		(WLAN_RC_PHY_DS(pRateTable->info[rix].phy) ? ATH_RC_DS_FLAG : 0) | 
  90c1e2:	05560a        	addx4	a6, a5, a5
  90c1e5:	056609        	addx2	a6, a6, a5
  90c1e8:	02660a        	addx4	a6, a6, a2
rcRateSetseries(const RATE_TABLE_11N *pRateTable ,
                struct ath_rc_series *series,
		A_UINT8 tries, A_UINT8 rix,
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
	series->tries = tries;
  90c1eb:	243401        	s8i	a4, a3, 1
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
		(WLAN_RC_PHY_DS(pRateTable->info[rix].phy) ? ATH_RC_DS_FLAG : 0) | 
  90c1ee:	286010        	l8ui	a8, a6, 16
  90c1f1:	c76d      	movi.n	a6, -3
  90c1f3:	068601        	and	a6, a8, a6
static void
rcRateSetseries(const RATE_TABLE_11N *pRateTable ,
                struct ath_rc_series *series,
		A_UINT8 tries, A_UINT8 rix,
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
  90c1f6:	2a0a01        	movi	a10, 1
	series->tries = tries;
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
		(WLAN_RC_PHY_DS(pRateTable->info[rix].phy) ? ATH_RC_DS_FLAG : 0) | 
  90c1f9:	68650b        	beqi	a6, 5, 90c208 <rcRateSetseries+0x30>
  90c1fc:	260a09        	movi	a6, 9
  90c1ff:	768105        	beq	a8, a6, 90c208 <rcRateSetseries+0x30>
  90c202:	268cf5        	addi	a6, a8, -11
  90c205:	06ba39        	movnez	a10, a11, a6
                struct ath_rc_series *series,
		A_UINT8 tries, A_UINT8 rix,
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
	series->tries = tries;
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
  90c208:	09a602        	or	a6, a10, a9
		(WLAN_RC_PHY_DS(pRateTable->info[rix].phy) ? ATH_RC_DS_FLAG : 0) | 
		(WLAN_RC_PHY_40(pRateTable->info[rix].phy) ? ATH_RC_CW40_FLAG : 0) | 
  90c20b:	298cfa        	addi	a9, a8, -6
  90c20e:	090947        	extui	a9, a9, 0, 8
  90c211:	6e9219        	bltui	a9, 2, 90c22e <rcRateSetseries+0x56>
  90c214:	c0a0      	movi.n	a10, 0
  90c216:	2b8cf6        	addi	a11, a8, -10
  90c219:	c091      	movi.n	a9, 1
  90c21b:	0b9a38        	moveqz	a10, a9, a11
                struct ath_rc_series *series,
		A_UINT8 tries, A_UINT8 rix,
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
	series->tries = tries;
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
  90c21e:	ccac      	bnez.n	a10, 90c22e <rcRateSetseries+0x56>
  90c220:	c092      	movi.n	a9, 2
  90c222:	2b8cf5        	addi	a11, a8, -11
  90c225:	0ba939        	movnez	a9, a10, a11
  90c228:	600004        	j	90c230 <rcRateSetseries+0x58>
  90c22b:	000000        	ill
  90c22e:	c092      	movi.n	a9, 2
		(WLAN_RC_PHY_DS(pRateTable->info[rix].phy) ? ATH_RC_DS_FLAG : 0) | 
		(WLAN_RC_PHY_40(pRateTable->info[rix].phy) ? ATH_RC_CW40_FLAG : 0) | 
		(WLAN_RC_PHY_SGI(pRateTable->info[rix].phy) ? ATH_RC_HT40_SGI_FLAG : 0);
  90c230:	288cf8        	addi	a8, a8, -8
                struct ath_rc_series *series,
		A_UINT8 tries, A_UINT8 rix,
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
	series->tries = tries;
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
  90c233:	080847        	extui	a8, a8, 0, 8
  90c236:	096902        	or	a9, a6, a9
  90c239:	c0b0      	movi.n	a11, 0
  90c23b:	6f8402        	bgeui	a8, 4, 90c241 <rcRateSetseries+0x69>
  90c23e:	2b0a04        	movi	a11, 4
  90c241:	0b9902        	or	a9, a9, a11
		(WLAN_RC_PHY_DS(pRateTable->info[rix].phy) ? ATH_RC_DS_FLAG : 0) | 
		(WLAN_RC_PHY_40(pRateTable->info[rix].phy) ? ATH_RC_CW40_FLAG : 0) | 
		(WLAN_RC_PHY_SGI(pRateTable->info[rix].phy) ? ATH_RC_HT40_SGI_FLAG : 0);
#ifdef MAGPIE_MERLIN
	if (stbc) {
  90c244:	8618      	l32i.n	a6, a1, 32
                struct ath_rc_series *series,
		A_UINT8 tries, A_UINT8 rix,
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
	series->tries = tries;
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
  90c246:	293403        	s8i	a9, a3, 3
		(WLAN_RC_PHY_DS(pRateTable->info[rix].phy) ? ATH_RC_DS_FLAG : 0) | 
		(WLAN_RC_PHY_40(pRateTable->info[rix].phy) ? ATH_RC_CW40_FLAG : 0) | 
		(WLAN_RC_PHY_SGI(pRateTable->info[rix].phy) ? ATH_RC_HT40_SGI_FLAG : 0);
#ifdef MAGPIE_MERLIN
	if (stbc) {
  90c249:	c96b      	beqz.n	a6, 90c268 <rcRateSetseries+0x90>
		/* For now, only single stream STBC is supported */
		if (pRateTable->info[rix].rateCode >= 0x80 && 
  90c24b:	05560a        	addx4	a6, a5, a5
  90c24e:	056609        	addx2	a6, a6, a5
  90c251:	02660a        	addx4	a6, a6, a2
  90c254:	26601c        	l8ui	a6, a6, 28
  90c257:	266c80        	addi	a6, a6, -128
  90c25a:	060647        	extui	a6, a6, 0, 8
  90c25d:	6f6807        	bgeui	a6, 8, 90c268 <rcRateSetseries+0x90>
		    pRateTable->info[rix].rateCode <= 0x87)
		{
			series->flags |= ATH_RC_TX_STBC_FLAG;
  90c260:	c260      	movi.n	a6, 32
  90c262:	069902        	or	a9, a9, a6
  90c265:	293403        	s8i	a9, a3, 3
		}
	}
#endif
	series->rix = pRateTable->info[rix].baseIndex;
  90c268:	05560a        	addx4	a6, a5, a5
  90c26b:	056509        	addx2	a5, a6, a5
  90c26e:	02550a        	addx4	a5, a5, a2
  90c271:	225022        	l8ui	a2, a5, 34
  90c274:	223400        	s8i	a2, a3, 0
	series->max4msframelen = pRateTable->info[rix].max4msframelen;
  90c277:	825a      	l32i.n	a2, a5, 40
  90c279:	9231      	s32i.n	a2, a3, 4
	series->txrateKbps = pRateTable->info[rix].rateKbps;
  90c27b:	8255      	l32i.n	a2, a5, 20
  90c27d:	9232      	s32i.n	a2, a3, 8

	/* If the hardware is capable of multiple transmit chains (chainmask is 3, 5 or 7), 
	 * then choose the number of transmit chains dynamically based on entries in the rate table.
	 */
#ifndef ATH_ENABLE_WLAN_FOR_K2
	if(chainmask == 7)
  90c27f:	697705        	bnei	a7, 7, 90c288 <rcRateSetseries+0xb0>
		series->tx_chainmask = pRateTable->info[rix].txChainMask_3ch;
  90c282:	225027        	l8ui	a2, a5, 39
  90c285:	60000a        	j	90c293 <rcRateSetseries+0xbb>
	else if(chainmask == 1) 
  90c288:	697104        	bnei	a7, 1, 90c290 <rcRateSetseries+0xb8>
		series->tx_chainmask = 1;
  90c28b:	273402        	s8i	a7, a3, 2
  90c28e:	d10f      	retw.n
	else 
		series->tx_chainmask = pRateTable->info[rix].txChainMask_2ch;  /*Chainmask is 3 or 5*/
  90c290:	225026        	l8ui	a2, a5, 38
  90c293:	223402        	s8i	a2, a3, 2
  90c296:	d10f      	retw.n

0090c298 <rcIsValidPhyRate>:

/* Return true only for single stream */

static A_BOOL
rcIsValidPhyRate(A_UINT32 phy, A_UINT32 capflag, A_BOOL ignoreCW)
{
  90c298:	6c1004        	entry	a1, 32
  90c29b:	d820      	mov.n	a8, a2
	if (WLAN_RC_PHY_HT(phy) && !(capflag & WLAN_RC_HT_FLAG)) {
  90c29d:	6e2404        	bltui	a2, 4, 90c2a5 <rcIsValidPhyRate+0xd>
		return FALSE;
  90c2a0:	c020      	movi.n	a2, 0
/* Return true only for single stream */

static A_BOOL
rcIsValidPhyRate(A_UINT32 phy, A_UINT32 capflag, A_BOOL ignoreCW)
{
	if (WLAN_RC_PHY_HT(phy) && !(capflag & WLAN_RC_HT_FLAG)) {
  90c2a2:	7c3764        	bbci	a3, 28, 90c30a <rcIsValidPhyRate+0x72>
		return FALSE;
	}

	if (WLAN_RC_PHY_DS(phy) && !(capflag & WLAN_RC_DS_FLAG))  {
  90c2a5:	c72d      	movi.n	a2, -3
  90c2a7:	028201        	and	a2, a8, a2
  90c2aa:	682504        	beqi	a2, 5, 90c2b2 <rcIsValidPhyRate+0x1a>
  90c2ad:	c099      	movi.n	a9, 9
  90c2af:	792904        	bne	a2, a9, 90c2b7 <rcIsValidPhyRate+0x1f>

static A_BOOL
rcIsValidPhyRate(A_UINT32 phy, A_UINT32 capflag, A_BOOL ignoreCW)
{
	if (WLAN_RC_PHY_HT(phy) && !(capflag & WLAN_RC_HT_FLAG)) {
		return FALSE;
  90c2b2:	c020      	movi.n	a2, 0
	}

	if (WLAN_RC_PHY_DS(phy) && !(capflag & WLAN_RC_DS_FLAG))  {
  90c2b4:	7f3752        	bbci	a3, 31, 90c30a <rcIsValidPhyRate+0x72>
		return FALSE;
	}
	if (WLAN_RC_PHY_SGI(phy) && !(capflag & WLAN_RC_HT40_SGI_FLAG)) {
  90c2b7:	228cf8        	addi	a2, a8, -8
  90c2ba:	6f2404        	bgeui	a2, 4, 90c2c2 <rcIsValidPhyRate+0x2a>

static A_BOOL
rcIsValidPhyRate(A_UINT32 phy, A_UINT32 capflag, A_BOOL ignoreCW)
{
	if (WLAN_RC_PHY_HT(phy) && !(capflag & WLAN_RC_HT_FLAG)) {
		return FALSE;
  90c2bd:	c020      	movi.n	a2, 0
	}

	if (WLAN_RC_PHY_DS(phy) && !(capflag & WLAN_RC_DS_FLAG))  {
		return FALSE;
	}
	if (WLAN_RC_PHY_SGI(phy) && !(capflag & WLAN_RC_HT40_SGI_FLAG)) {
  90c2bf:	7d3747        	bbci	a3, 29, 90c30a <rcIsValidPhyRate+0x72>
		return FALSE;
	}

	if (!ignoreCW && WLAN_RC_PHY_HT(phy)) {
  90c2c2:	c020      	movi.n	a2, 0
  90c2c4:	c0a1      	movi.n	a10, 1
  90c2c6:	d520      	mov.n	a5, a2
  90c2c8:	04a538        	moveqz	a5, a10, a4
  90c2cb:	d450      	mov.n	a4, a5
  90c2cd:	725135        	beq	a5, a2, 90c306 <rcIsValidPhyRate+0x6e>
  90c2d0:	6e8432        	bltui	a8, 4, 90c306 <rcIsValidPhyRate+0x6e>
		if (WLAN_RC_PHY_40(phy) && !(capflag & WLAN_RC_40_FLAG)) {
  90c2d3:	298cfa        	addi	a9, a8, -6
  90c2d6:	6e920c        	bltui	a9, 2, 90c2e6 <rcIsValidPhyRate+0x4e>
  90c2d9:	2b8cf6        	addi	a11, a8, -10
  90c2dc:	0ba238        	moveqz	a2, a10, a11
  90c2df:	cc23      	bnez.n	a2, 90c2e6 <rcIsValidPhyRate+0x4e>
  90c2e1:	c02b      	movi.n	a2, 11
  90c2e3:	728904        	bne	a8, a2, 90c2eb <rcIsValidPhyRate+0x53>
			return FALSE;
  90c2e6:	c020      	movi.n	a2, 0
	if (WLAN_RC_PHY_SGI(phy) && !(capflag & WLAN_RC_HT40_SGI_FLAG)) {
		return FALSE;
	}

	if (!ignoreCW && WLAN_RC_PHY_HT(phy)) {
		if (WLAN_RC_PHY_40(phy) && !(capflag & WLAN_RC_40_FLAG)) {
  90c2e8:	7e371e        	bbci	a3, 30, 90c30a <rcIsValidPhyRate+0x72>
		if (!WLAN_RC_PHY_40(phy) && (capflag & WLAN_RC_40_FLAG)) {
			return FALSE;
		}
	}
    
	return TRUE;
  90c2eb:	c021      	movi.n	a2, 1
	if (!ignoreCW && WLAN_RC_PHY_HT(phy)) {
		if (WLAN_RC_PHY_40(phy) && !(capflag & WLAN_RC_40_FLAG)) {
			return FALSE;
		}

		if (!WLAN_RC_PHY_40(phy) && (capflag & WLAN_RC_40_FLAG)) {
  90c2ed:	6e9219        	bltui	a9, 2, 90c30a <rcIsValidPhyRate+0x72>
  90c2f0:	688916        	beqi	a8, 10, 90c30a <rcIsValidPhyRate+0x72>
  90c2f3:	c09b      	movi.n	a9, 11
  90c2f5:	798111        	beq	a8, a9, 90c30a <rcIsValidPhyRate+0x72>
  90c2f8:	002004        	ssr	a2
  90c2fb:	030319        	srl	a3, a3
  90c2fe:	023203        	xor	a2, a3, a2
  90c301:	020240        	extui	a2, a2, 0, 1
  90c304:	d10f      	retw.n
			return FALSE;
		}
	}
    
	return TRUE;
  90c306:	c021      	movi.n	a2, 1
  90c308:	d10f      	retw.n
}
  90c30a:	d10f      	retw.n

0090c30c <rcUpdate_ht$isra$4>:
		}
	}
}

static void
rcUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an, int txRate, 
  90c30c:	6c1006        	entry	a1, 48
  90c30f:	2c1119        	l16ui	a12, a1, 50
  90c312:	07094f        	extui	a9, a7, 0, 16
            A_BOOL Xretries, int retries, A_UINT8 curTxAnt, 
            A_UINT16 nFrames, A_UINT16 nBad)
{
	TX_RATE_CTRL *pRc;
	A_UINT32 nowMsec = A_MS_TICKGET();
  90c315:	c0a0      	movi.n	a10, 0
  90c317:	9912      	s32i.n	a9, a1, 8
  90c319:	9510      	s32i.n	a5, a1, 0
  90c31b:	9c13      	s32i.n	a12, a1, 12
  90c31d:	5bedec        	call8	907ad0 <ath_hal_getuptime>
	A_UINT8 lastPer;
	int rate,count;
	struct atheros_node *pSib = ATH_NODE_ATHEROS(an);
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  90c320:	252248        	l32i	a5, a2, 0x120
  90c323:	2222c2        	l32i	a2, a2, 0x308
{
	TX_RATE_CTRL *pRc;
	A_UINT32 nowMsec = A_MS_TICKGET();
	A_UINT8 lastPer;
	int rate,count;
	struct atheros_node *pSib = ATH_NODE_ATHEROS(an);
  90c326:	233282        	l32i	a3, a3, 0x208
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  90c329:	05220a        	addx4	a2, a2, a5
rcUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an, int txRate, 
            A_BOOL Xretries, int retries, A_UINT8 curTxAnt, 
            A_UINT16 nFrames, A_UINT16 nBad)
{
	TX_RATE_CTRL *pRc;
	A_UINT32 nowMsec = A_MS_TICKGET();
  90c32c:	d8a0      	mov.n	a8, a10
	A_UINT8 lastPer;
	int rate,count;
	struct atheros_node *pSib = ATH_NODE_ATHEROS(an);
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  90c32e:	8521      	l32i.n	a5, a2, 4
		100 * 7 / 8,    // 87.5
		100 * 8 / 9,    // 88.8
		100 * 9 / 10    // 90
	};

	if (!pSib)
  90c330:	8912      	l32i.n	a9, a1, 8
  90c332:	8b10      	l32i.n	a11, a1, 0
  90c334:	8c13      	l32i.n	a12, a1, 12
  90c336:	6431ce        	beqz	a3, 90c508 <rcUpdate_ht$isra$4+0x1fc>
	pRc = (TX_RATE_CTRL *)(pSib);

	ASSERT(retries >= 0 && retries < MAX_TX_RETRIES);
	ASSERT(txRate >= 0);
    
	if (txRate < 0) {
  90c339:	6641cb        	bltz	a4, 90c508 <rcUpdate_ht$isra$4+0x1fc>
		return;
	}

	lastPer = pRc->state[txRate].per;
  90c33c:	a437      	add.n	a7, a3, a4
  90c33e:	227000        	l8ui	a2, a7, 0

	if (Xretries) {
  90c341:	cbb0      	beqz.n	a11, 90c375 <rcUpdate_ht$isra$4+0x69>
		/* Update the PER. */
		if (Xretries == 1) {
  90c343:	69b111        	bnei	a11, 1, 90c358 <rcUpdate_ht$isra$4+0x4c>
			pRc->state[txRate].per += 30;
  90c346:	292c1e        	addi	a9, a2, 30
  90c349:	090947        	extui	a9, a9, 0, 8
			if (pRc->state[txRate].per > 100) {
  90c34c:	260a64        	movi	a6, 100
  90c34f:	79630d        	bltu	a6, a9, 90c360 <rcUpdate_ht$isra$4+0x54>
	lastPer = pRc->state[txRate].per;

	if (Xretries) {
		/* Update the PER. */
		if (Xretries == 1) {
			pRc->state[txRate].per += 30;
  90c352:	297400        	s8i	a9, a7, 0
  90c355:	60000a        	j	90c363 <rcUpdate_ht$isra$4+0x57>
			if (retries >= count) {
				retries = count - 1;
			}

			/* new_PER = 7/8*old_PER + 1/8*(currentPER) */
			pRc->state[txRate].per = (A_UINT8)(pRc->state[txRate].per - 
  90c358:	bc29      	addi.n	a9, a2, 12
  90c35a:	023614        	srli	a6, a2, 3
  90c35d:	06960c        	sub	a6, a9, a6
  90c360:	267400        	s8i	a6, a7, 0
						   (pRc->state[txRate].per / 8) + ((100) / 8));
		}

		/* Xretries == 1 or 2 */

		if (pRc->probeRate == txRate)
  90c363:	26302f        	l8ui	a6, a3, 47
  90c366:	746102        	beq	a6, a4, 90c36c <rcUpdate_ht$isra$4+0x60>
  90c369:	6000c3        	j	90c430 <rcUpdate_ht$isra$4+0x124>
			pRc->probeRate = 0;
  90c36c:	c060      	movi.n	a6, 0
  90c36e:	26342f        	s8i	a6, a3, 47
  90c371:	6000bb        	j	90c430 <rcUpdate_ht$isra$4+0x124>
  90c374:	00c0a9        	excw
  90c377:	0a6634        	min	a6, a6, a10
		count = sizeof(nRetry2PerLookup) / sizeof(nRetry2PerLookup[0]);
		if (retries >= count) {
			retries = count - 1;
		}

		if (nBad) {
  90c37a:	64c03f        	beqz	a12, 90c3bd <rcUpdate_ht$isra$4+0xb1>
			 * that part is 100 * nBad / nFrames, and it contributes
			 * 100 * nBad / (nFrames * (retries+1)) to the above
			 * PER.  The expression below is a simplified version
			 * of the sum of these two terms.
			 */
			if (nFrames > 0)
  90c37d:	649053        	beqz	a9, 90c3d4 <rcUpdate_ht$isra$4+0xc8>
				pRc->state[txRate].per = (A_UINT8)(pRc->state[txRate].per - 
					   (pRc->state[txRate].per / 8) + 
					   ((100*(retries*nFrames + nBad)/(nFrames*(retries+1))) / 8));
  90c380:	096a28        	mull	a10, a6, a9
  90c383:	b16b      	addi.n	a11, a6, 1
  90c385:	acaa      	add.n	a10, a10, a12
  90c387:	0aaa0a        	addx4	a10, a10, a10
  90c38a:	0b9b28        	mull	a11, a9, a11
			 * 100 * nBad / (nFrames * (retries+1)) to the above
			 * PER.  The expression below is a simplified version
			 * of the sum of these two terms.
			 */
			if (nFrames > 0)
				pRc->state[txRate].per = (A_UINT8)(pRc->state[txRate].per - 
  90c38d:	023d14        	srli	a13, a2, 3
					   (pRc->state[txRate].per / 8) + 
					   ((100*(retries*nFrames + nBad)/(nFrames*(retries+1))) / 8));
  90c390:	0aaa0a        	addx4	a10, a10, a10
			 * 100 * nBad / (nFrames * (retries+1)) to the above
			 * PER.  The expression below is a simplified version
			 * of the sum of these two terms.
			 */
			if (nFrames > 0)
				pRc->state[txRate].per = (A_UINT8)(pRc->state[txRate].per - 
  90c393:	0d2d0c        	sub	a13, a2, a13
					   (pRc->state[txRate].per / 8) + 
					   ((100*(retries*nFrames + nBad)/(nFrames*(retries+1))) / 8));
  90c396:	0eaa11        	slli	a10, a10, 2
  90c399:	9810      	s32i.n	a8, a1, 0
  90c39b:	9912      	s32i.n	a9, a1, 8
  90c39d:	9c13      	s32i.n	a12, a1, 12
  90c39f:	9d11      	s32i.n	a13, a1, 4
  90c3a1:	5b697d        	call8	8e6998 <__divsi3>
  90c3a4:	b7ab      	addi.n	a11, a10, 7
			 * 100 * nBad / (nFrames * (retries+1)) to the above
			 * PER.  The expression below is a simplified version
			 * of the sum of these two terms.
			 */
			if (nFrames > 0)
				pRc->state[txRate].per = (A_UINT8)(pRc->state[txRate].per - 
  90c3a6:	8d11      	l32i.n	a13, a1, 4
					   (pRc->state[txRate].per / 8) + 
					   ((100*(retries*nFrames + nBad)/(nFrames*(retries+1))) / 8));
  90c3a8:	0aba3a        	movltz	a10, a11, a10
  90c3ab:	0a3a12        	srai	a10, a10, 3
			 * 100 * nBad / (nFrames * (retries+1)) to the above
			 * PER.  The expression below is a simplified version
			 * of the sum of these two terms.
			 */
			if (nFrames > 0)
				pRc->state[txRate].per = (A_UINT8)(pRc->state[txRate].per - 
  90c3ae:	aadd      	add.n	a13, a13, a10
  90c3b0:	2d7400        	s8i	a13, a7, 0
  90c3b3:	8810      	l32i.n	a8, a1, 0
  90c3b5:	8912      	l32i.n	a9, a1, 8
  90c3b7:	8c13      	l32i.n	a12, a1, 12
  90c3b9:	600017        	j	90c3d4 <rcUpdate_ht$isra$4+0xc8>
  90c3bc:	001a6a        	excw
					   ((100*(retries*nFrames + nBad)/(nFrames*(retries+1))) / 8));
		} else {
			/* new_PER = 7/8*old_PER + 1/8*(currentPER) */

			pRc->state[txRate].per = (A_UINT8)(pRc->state[txRate].per - 
				   (pRc->state[txRate].per / 8) + (nRetry2PerLookup[retries] / 8));
  90c3bf:	fa          	.byte 0xfa
					   (pRc->state[txRate].per / 8) + 
					   ((100*(retries*nFrames + nBad)/(nFrames*(retries+1))) / 8));
		} else {
			/* new_PER = 7/8*old_PER + 1/8*(currentPER) */

			pRc->state[txRate].per = (A_UINT8)(pRc->state[txRate].per - 
  90c3c0:	023b14        	srli	a11, a2, 3
				   (pRc->state[txRate].per / 8) + (nRetry2PerLookup[retries] / 8));
  90c3c3:	0a6a0a        	addx4	a10, a6, a10
  90c3c6:	8aa0      	l32i.n	a10, a10, 0
					   (pRc->state[txRate].per / 8) + 
					   ((100*(retries*nFrames + nBad)/(nFrames*(retries+1))) / 8));
		} else {
			/* new_PER = 7/8*old_PER + 1/8*(currentPER) */

			pRc->state[txRate].per = (A_UINT8)(pRc->state[txRate].per - 
  90c3c8:	0b2b0c        	sub	a11, a2, a11
				   (pRc->state[txRate].per / 8) + (nRetry2PerLookup[retries] / 8));
  90c3cb:	0a3a14        	srli	a10, a10, 3
					   (pRc->state[txRate].per / 8) + 
					   ((100*(retries*nFrames + nBad)/(nFrames*(retries+1))) / 8));
		} else {
			/* new_PER = 7/8*old_PER + 1/8*(currentPER) */

			pRc->state[txRate].per = (A_UINT8)(pRc->state[txRate].per - 
  90c3ce:	0aba08        	add	a10, a11, a10
  90c3d1:	2a7400        	s8i	a10, a7, 0
		/*
		 * If we got at most one retry then increase the max rate if
		 * this was a probe.  Otherwise, ignore the probe.
		 */

		if (pRc->probeRate && pRc->probeRate == txRate) {
  90c3d4:	27302f        	l8ui	a7, a3, 47
  90c3d7:	cb79      	beqz.n	a7, 90c414 <rcUpdate_ht$isra$4+0x108>
  90c3d9:	747937        	bne	a7, a4, 90c414 <rcUpdate_ht$isra$4+0x108>
			if (retries > 0 || 2 * nBad > nFrames) {
  90c3dc:	6b6105        	bgei	a6, 1, 90c3e5 <rcUpdate_ht$isra$4+0xd9>
  90c3df:	0fcc11        	slli	a12, a12, 1
  90c3e2:	7c9a07        	bge	a9, a12, 90c3ed <rcUpdate_ht$isra$4+0xe1>
				 * any retries means the probe failed.  Also,
				 * if the attempt worked, but more than half
				 * the subframes were bad then also consider
				 * the probe a failure.
				 */
				pRc->probeRate = 0;
  90c3e5:	c070      	movi.n	a7, 0
  90c3e7:	27342f        	s8i	a7, a3, 47
  90c3ea:	600026        	j	90c414 <rcUpdate_ht$isra$4+0x108>
			} else {
				pRc->rateMaxPhy = pRc->probeRate;
  90c3ed:	24346d        	s8i	a4, a3, 109

				if (pRc->state[pRc->probeRate].per > 30) {
  90c3f0:	a436      	add.n	a6, a3, a4
  90c3f2:	276000        	l8ui	a7, a6, 0
  90c3f5:	c19e      	movi.n	a9, 30
  90c3f7:	779b05        	bgeu	a9, a7, 90c400 <rcUpdate_ht$isra$4+0xf4>
					pRc->state[pRc->probeRate].per = 20;
  90c3fa:	270a14        	movi	a7, 20
  90c3fd:	276400        	s8i	a7, a6, 0
				}

				pRc->probeRate = 0;
  90c400:	c060      	movi.n	a6, 0
  90c402:	26342f        	s8i	a6, a3, 47
				/*
				 * Since this probe succeeded, we allow the next probe
				 * twice as soon.  This allows the maxRate to move up
				 * faster if the probes are succesful.
				 */
				pRc->probeTime = nowMsec - pRateTable->probeInterval / 2;
  90c405:	265001        	l8ui	a6, a5, 1
  90c408:	061614        	srli	a6, a6, 1
  90c40b:	06860c        	sub	a6, a8, a6
  90c40e:	963d      	s32i.n	a6, a3, 52
  90c410:	600008        	j	90c41c <rcUpdate_ht$isra$4+0x110>
  90c413:	006a61        	excw
			}
		}

		if (retries > 0) {
  90c416:	04c060        	excw
			 *
			 * Later: if rssiAck is close to pRc->state[txRate].rssiThres
			 * and we see lots of retries, then we could increase
			 * pRc->state[txRate].rssiThres.
			 */
			pRc->hwMaxRetryPktCnt = 0;
  90c419:	600010        	j	90c42d <rcUpdate_ht$isra$4+0x121>
		} else {
			/*
			 * It worked with no retries.  First ignore bogus (small)
			 * rssiAck values.
			 */
			if (txRate == pRc->rateMaxPhy && pRc->hwMaxRetryPktCnt < 255) {
  90c41c:	26306d        	l8ui	a6, a3, 109
  90c41f:	76490d        	bne	a4, a6, 90c430 <rcUpdate_ht$isra$4+0x124>
  90c422:	263038        	l8ui	a6, a3, 56
  90c425:	270aff        	movi	a7, 255
  90c428:	776104        	beq	a6, a7, 90c430 <rcUpdate_ht$isra$4+0x124>
				pRc->hwMaxRetryPktCnt++;
  90c42b:	b166      	addi.n	a6, a6, 1
  90c42d:	263438        	s8i	a6, a3, 56
    
	/*
	 * If this rate looks bad (high PER) then stop using it for
	 * a while (except if we are probing).
	 */
	if (pRc->state[txRate].per >= 55 && txRate > 0 &&
  90c430:	a436      	add.n	a6, a3, a4
  90c432:	296000        	l8ui	a9, a6, 0
  90c435:	c366      	movi.n	a6, 54
  90c437:	796b4a        	bgeu	a6, a9, 90c485 <rcUpdate_ht$isra$4+0x179>
  90c43a:	644047        	beqz	a4, 90c485 <rcUpdate_ht$isra$4+0x179>
	    pRateTable->info[txRate].rateKbps <= 
            pRateTable->info[pRc->rateMaxPhy].rateKbps)
  90c43d:	26306d        	l8ui	a6, a3, 109
	/*
	 * If this rate looks bad (high PER) then stop using it for
	 * a while (except if we are probing).
	 */
	if (pRc->state[txRate].per >= 55 && txRate > 0 &&
	    pRateTable->info[txRate].rateKbps <= 
  90c440:	04470a        	addx4	a7, a4, a4
            pRateTable->info[pRc->rateMaxPhy].rateKbps)
  90c443:	066a0a        	addx4	a10, a6, a6
	/*
	 * If this rate looks bad (high PER) then stop using it for
	 * a while (except if we are probing).
	 */
	if (pRc->state[txRate].per >= 55 && txRate > 0 &&
	    pRateTable->info[txRate].rateKbps <= 
  90c446:	047709        	addx2	a7, a7, a4
            pRateTable->info[pRc->rateMaxPhy].rateKbps)
  90c449:	06a609        	addx2	a6, a10, a6
	/*
	 * If this rate looks bad (high PER) then stop using it for
	 * a while (except if we are probing).
	 */
	if (pRc->state[txRate].per >= 55 && txRate > 0 &&
	    pRateTable->info[txRate].rateKbps <= 
  90c44c:	05770a        	addx4	a7, a7, a5
            pRateTable->info[pRc->rateMaxPhy].rateKbps)
  90c44f:	05660a        	addx4	a6, a6, a5
    
	/*
	 * If this rate looks bad (high PER) then stop using it for
	 * a while (except if we are probing).
	 */
	if (pRc->state[txRate].per >= 55 && txRate > 0 &&
  90c452:	8775      	l32i.n	a7, a7, 20
  90c454:	8665      	l32i.n	a6, a6, 20
  90c456:	77632b        	bltu	a6, a7, 90c485 <rcUpdate_ht$isra$4+0x179>
  90c459:	040c47        	extui	a12, a4, 0, 8
rcGetNextLowerValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc,  
                          A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_INT8 i;

	for (i = 1; i < pRc->maxValidRate ; i++) {
  90c45c:	2a3039        	l8ui	a10, a3, 57
  90c45f:	d730      	mov.n	a7, a3
  90c461:	c061      	movi.n	a6, 1
  90c463:	600017        	j	90c47e <rcUpdate_ht$isra$4+0x172>
  90c466:	00002d        	excw
		if (pRc->validRateIndex[i] == curValidTxRate) {
  90c469:	703bb1        	bgeu	a3, a0, 90c41e <rcUpdate_ht$isra$4+0x112>
  90c46c:	66b177        	bltz	a11, 90c5e7 <rcSibUpdate_ht$constprop$6+0xdb>
  90c46f:	7cd90b        	bne	a13, a12, 90c47e <rcUpdate_ht$isra$4+0x172>
			*pNextIndex = pRc->validRateIndex[i-1];
  90c472:	ab3b      	add.n	a11, a3, a11
  90c474:	26b039        	l8ui	a6, a11, 57
  90c477:	26346d        	s8i	a6, a3, 109
  90c47a:	600005        	j	90c483 <rcUpdate_ht$isra$4+0x177>
  90c47d:	00db60        	excw
rcGetNextLowerValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc,  
                          A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_INT8 i;

	for (i = 1; i < pRc->maxValidRate ; i++) {
  90c480:	7a62e4        	blt	a6, a10, 90c468 <rcUpdate_ht$isra$4+0x15c>
	{
		rcGetNextLowerValidTxRate(pRateTable, pRc, (A_UINT8) txRate, 
					  &pRc->rateMaxPhy);

		/* Don't probe for a little while. */
		pRc->probeTime = nowMsec;
  90c483:	983d      	s32i.n	a8, a3, 52
	}

	/* Make sure the rates below this have lower PER */
	/* Monotonicity is kept only for rates below the current rate. */
	if (pRc->state[txRate].per < lastPer) {
  90c485:	729307        	bltu	a9, a2, 90c490 <rcUpdate_ht$isra$4+0x184>
			}
		}
	}

	/* Maintain monotonicity for rates above the current rate*/
	for (rate = txRate; rate < pRc->rateTableSize - 1; rate++) {
  90c488:	26302e        	l8ui	a6, a3, 46
  90c48b:	b069      	addi.n	a9, a6, -1
  90c48d:	60004b        	j	90c4dc <rcUpdate_ht$isra$4+0x1d0>
		}
	}
}

static void
rcUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an, int txRate, 
  90c490:	04490a        	addx4	a9, a4, a4
  90c493:	049909        	addx2	a9, a9, a4
  90c496:	05990a        	addx4	a9, a9, a5
	}

	/* Make sure the rates below this have lower PER */
	/* Monotonicity is kept only for rates below the current rate. */
	if (pRc->state[txRate].per < lastPer) {
		for (rate = txRate - 1; rate >= 0; rate--) {
  90c499:	b042      	addi.n	a2, a4, -1
		}
	}
}

static void
rcUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an, int txRate, 
  90c49b:	c060      	movi.n	a6, 0

	/* Make sure the rates below this have lower PER */
	/* Monotonicity is kept only for rates below the current rate. */
	if (pRc->state[txRate].per < lastPer) {
		for (rate = txRate - 1; rate >= 0; rate--) {
			if (pRateTable->info[rate].phy != pRateTable->info[txRate].phy) {
  90c49d:	db90      	mov.n	a11, a9
  90c49f:	600020        	j	90c4c3 <rcUpdate_ht$isra$4+0x1b7>
		}
	}
}

static void
rcUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an, int txRate, 
  90c4a2:	a697      	add.n	a7, a9, a6
  90c4a4:	277ce4        	addi	a7, a7, -28

	/* Make sure the rates below this have lower PER */
	/* Monotonicity is kept only for rates below the current rate. */
	if (pRc->state[txRate].per < lastPer) {
		for (rate = txRate - 1; rate >= 0; rate--) {
			if (pRateTable->info[rate].phy != pRateTable->info[txRate].phy) {
  90c4a7:	2a7000        	l8ui	a10, a7, 0
  90c4aa:	27b010        	l8ui	a7, a11, 16
  90c4ad:	77a9d7        	bne	a10, a7, 90c488 <rcUpdate_ht$isra$4+0x17c>
		}
	}
}

static void
rcUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an, int txRate, 
  90c4b0:	a237      	add.n	a7, a3, a2
		for (rate = txRate - 1; rate >= 0; rate--) {
			if (pRateTable->info[rate].phy != pRateTable->info[txRate].phy) {
				break;
			}

			if (pRc->state[rate].per > pRc->state[rate+1].per) {
  90c4b2:	2a7001        	l8ui	a10, a7, 1
  90c4b5:	2c7000        	l8ui	a12, a7, 0
  90c4b8:	7cab02        	bgeu	a10, a12, 90c4be <rcUpdate_ht$isra$4+0x1b2>
				pRc->state[rate].per = pRc->state[rate+1].per;
  90c4bb:	2a7400        	s8i	a10, a7, 0
	}

	/* Make sure the rates below this have lower PER */
	/* Monotonicity is kept only for rates below the current rate. */
	if (pRc->state[txRate].per < lastPer) {
		for (rate = txRate - 1; rate >= 0; rate--) {
  90c4be:	b022      	addi.n	a2, a2, -1
  90c4c0:	266cd4        	addi	a6, a6, -44
  90c4c3:	6920db        	bnei	a2, -1, 90c4a2 <rcUpdate_ht$isra$4+0x196>
  90c4c6:	63ffbe        	j	90c488 <rcUpdate_ht$isra$4+0x17c>
  90c4c9:	00b144        	extui	a1, a0, 11, 5
		}
	}
}

static void
rcUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an, int txRate, 
  90c4cc:	a432      	add.n	a2, a3, a4
  90c4ce:	b027      	addi.n	a7, a2, -1
		}
	}

	/* Maintain monotonicity for rates above the current rate*/
	for (rate = txRate; rate < pRc->rateTableSize - 1; rate++) {
		if (pRc->state[rate+1].per < pRc->state[rate].per) {
  90c4d0:	277000        	l8ui	a7, a7, 0
  90c4d3:	2a2000        	l8ui	a10, a2, 0
  90c4d6:	77ab02        	bgeu	a10, a7, 90c4dc <rcUpdate_ht$isra$4+0x1d0>
			pRc->state[rate+1].per = pRc->state[rate].per;
  90c4d9:	272400        	s8i	a7, a2, 0
			}
		}
	}

	/* Maintain monotonicity for rates above the current rate*/
	for (rate = txRate; rate < pRc->rateTableSize - 1; rate++) {
  90c4dc:	7942ea        	blt	a4, a9, 90c4ca <rcUpdate_ht$isra$4+0x1be>
			pRc->state[rate+1].per = pRc->state[rate].per;
		}
	}

	/* Every so often, we reduce the thresholds and PER (different for CCK and OFDM). */
	if (nowMsec - pRc->perDownTime >= pRateTable->rssiReduceInterval) {
  90c4df:	24321a        	l32i	a4, a3, 104
  90c4e2:	225002        	l8ui	a2, a5, 2
  90c4e5:	04840c        	sub	a4, a8, a4
  90c4e8:	72431c        	bltu	a4, a2, 90c508 <rcUpdate_ht$isra$4+0x1fc>
  90c4eb:	d230      	mov.n	a2, a3
  90c4ed:	60000e        	j	90c4ff <rcUpdate_ht$isra$4+0x1f3>
  90c4f0:	002420        	excw
		for (rate = 0; rate < pRc->rateTableSize; rate++) {
			pRc->state[rate].per = 7*pRc->state[rate].per/8;
  90c4f3:	000444        	extui	a4, a0, 0, 5
  90c4f6:	0f0434        	min	a4, a0, a15
  90c4f9:	122424        	l32r	a2, 8d558c <_bss_end+0x3c267c>
  90c4fc:	00b122        	excw
		}
	}
}

static void
rcUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an, int txRate, 
  90c4ff:	03240c        	sub	a4, a2, a3
		}
	}

	/* Every so often, we reduce the thresholds and PER (different for CCK and OFDM). */
	if (nowMsec - pRc->perDownTime >= pRateTable->rssiReduceInterval) {
		for (rate = 0; rate < pRc->rateTableSize; rate++) {
  90c502:	7642eb        	blt	a4, a6, 90c4f1 <rcUpdate_ht$isra$4+0x1e5>
			pRc->state[rate].per = 7*pRc->state[rate].per/8;
		}

		pRc->perDownTime = nowMsec;
  90c505:	28361a        	s32i	a8, a3, 104
  90c508:	d10f      	retw.n
	...

0090c50c <rcSibUpdate_ht$constprop$6>:
 *  (e.g. SME operation, wireless mode change)
 *
 *  It will determine which rates are valid for use.
 */
static void
rcSibUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an,
  90c50c:	6c1052        	entry	a1, 0x290
  90c50f:	d830      	mov.n	a8, a3
  90c511:	d350      	mov.n	a3, a5
	TX_RATE_CTRL *pRc = (TX_RATE_CTRL *)(pSib);
	PHY_STATE_CTRL mPhyCtrlState;  

	A_UINT8 i, j, k, hi = 0, htHi = 0;

	pRateTable = (RATE_TABLE_11N*)asc->hwRateTable[sc->sc_curmode];
  90c513:	252248        	l32i	a5, a2, 0x120
  90c516:	2222c2        	l32i	a2, a2, 0x308
static void
rcSibUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an,
	       A_UINT32 capflag, A_BOOL keepState, struct ieee80211_rate  *pRateSet)
{
	RATE_TABLE_11N *pRateTable = 0;
	struct atheros_node *pSib = ATH_NODE_ATHEROS(an);
  90c519:	268282        	l32i	a6, a8, 0x208
	TX_RATE_CTRL *pRc = (TX_RATE_CTRL *)(pSib);
	PHY_STATE_CTRL mPhyCtrlState;  

	A_UINT8 i, j, k, hi = 0, htHi = 0;

	pRateTable = (RATE_TABLE_11N*)asc->hwRateTable[sc->sc_curmode];
  90c51c:	05220a        	addx4	a2, a2, a5

	/* Initial rate table size. Will change depending on the working rate set */
	pRc->rateTableSize = MAX_TX_RATE_TBL;
  90c51f:	c25e      	movi.n	a5, 46
	TX_RATE_CTRL *pRc = (TX_RATE_CTRL *)(pSib);
	PHY_STATE_CTRL mPhyCtrlState;  

	A_UINT8 i, j, k, hi = 0, htHi = 0;

	pRateTable = (RATE_TABLE_11N*)asc->hwRateTable[sc->sc_curmode];
  90c521:	8221      	l32i.n	a2, a2, 4

	/* Initial rate table size. Will change depending on the working rate set */
	pRc->rateTableSize = MAX_TX_RATE_TBL;
  90c523:	25642e        	s8i	a5, a6, 46
  90c526:	c050      	movi.n	a5, 0

	/* Initialize thresholds according to the global rate table */
	for (i = 0 ; (i < pRc->rateTableSize) && (!keepState); i++) {
		pRc->state[i].per       = 0;
  90c528:	da50      	mov.n	a10, a5

	/* Initial rate table size. Will change depending on the working rate set */
	pRc->rateTableSize = MAX_TX_RATE_TBL;

	/* Initialize thresholds according to the global rate table */
	for (i = 0 ; (i < pRc->rateTableSize) && (!keepState); i++) {
  90c52a:	c27e      	movi.n	a7, 46
 *  (e.g. SME operation, wireless mode change)
 *
 *  It will determine which rates are valid for use.
 */
static void
rcSibUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an,
  90c52c:	a569      	add.n	a9, a6, a5
	/* Initial rate table size. Will change depending on the working rate set */
	pRc->rateTableSize = MAX_TX_RATE_TBL;

	/* Initialize thresholds according to the global rate table */
	for (i = 0 ; (i < pRc->rateTableSize) && (!keepState); i++) {
		pRc->state[i].per       = 0;
  90c52e:	2a9400        	s8i	a10, a9, 0
  90c531:	b155      	addi.n	a5, a5, 1

	/* Initial rate table size. Will change depending on the working rate set */
	pRc->rateTableSize = MAX_TX_RATE_TBL;

	/* Initialize thresholds according to the global rate table */
	for (i = 0 ; (i < pRc->rateTableSize) && (!keepState); i++) {
  90c533:	7759f5        	bne	a5, a7, 90c52c <rcSibUpdate_ht$constprop$6+0x20>
  90c536:	d760      	mov.n	a7, a6
rcInitValidTxMask(TX_RATE_CTRL *pRc)
{
	A_UINT8 i;

	for (i = 0; i < pRc->rateTableSize; i++) {
		pRc->validRateIndex[i] = FALSE;
  90c538:	c090      	movi.n	a9, 0
  90c53a:	b055      	addi.n	a5, a5, -1
  90c53c:	29743a        	s8i	a9, a7, 58
  90c53f:	050547        	extui	a5, a5, 0, 8
  90c542:	b177      	addi.n	a7, a7, 1
static void
rcInitValidTxMask(TX_RATE_CTRL *pRc)
{
	A_UINT8 i;

	for (i = 0; i < pRc->rateTableSize; i++) {
  90c544:	655ff2        	bnez	a5, 90c53a <rcSibUpdate_ht$constprop$6+0x2e>
  90c547:	211692        	s32i	a1, a1, 0x248
  90c54a:	d910      	mov.n	a9, a1
	/* Determine the valid rates */
	rcInitValidTxMask(pRc);

	for (i = 0; i < WLAN_RC_PHY_MAX; i++) {
		for (j = 0; j < MAX_TX_RATE_TBL; j++) {
			mPhyCtrlState.validPhyRateIndex[i][j] = 0;
  90c54c:	da50      	mov.n	a10, a5

	/* Determine the valid rates */
	rcInitValidTxMask(pRc);

	for (i = 0; i < WLAN_RC_PHY_MAX; i++) {
		for (j = 0; j < MAX_TX_RATE_TBL; j++) {
  90c54e:	c2be      	movi.n	a11, 46
			mPhyCtrlState.validPhyRateIndex[i][j] = 0;
  90c550:	dc50      	mov.n	a12, a5
  90c552:	600016        	j	90c56c <rcSibUpdate_ht$constprop$6+0x60>
 *  (e.g. SME operation, wireless mode change)
 *
 *  It will determine which rates are valid for use.
 */
static void
rcSibUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an,
  90c555:	a79d      	add.n	a13, a9, a7
	/* Determine the valid rates */
	rcInitValidTxMask(pRc);

	for (i = 0; i < WLAN_RC_PHY_MAX; i++) {
		for (j = 0; j < MAX_TX_RATE_TBL; j++) {
			mPhyCtrlState.validPhyRateIndex[i][j] = 0;
  90c557:	2ad40c        	s8i	a10, a13, 12
  90c55a:	b177      	addi.n	a7, a7, 1

	/* Determine the valid rates */
	rcInitValidTxMask(pRc);

	for (i = 0; i < WLAN_RC_PHY_MAX; i++) {
		for (j = 0; j < MAX_TX_RATE_TBL; j++) {
  90c55c:	7b79f5        	bne	a7, a11, 90c555 <rcSibUpdate_ht$constprop$6+0x49>
 *  (e.g. SME operation, wireless mode change)
 *
 *  It will determine which rates are valid for use.
 */
static void
rcSibUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an,
  90c55f:	a517      	add.n	a7, a1, a5

	for (i = 0; i < WLAN_RC_PHY_MAX; i++) {
		for (j = 0; j < MAX_TX_RATE_TBL; j++) {
			mPhyCtrlState.validPhyRateIndex[i][j] = 0;
		}   
		mPhyCtrlState.validPhyRateCount[i] = 0;
  90c561:	2c7400        	s8i	a12, a7, 0
  90c564:	b155      	addi.n	a5, a5, 1
  90c566:	299c2e        	addi	a9, a9, 46
	}

	/* Determine the valid rates */
	rcInitValidTxMask(pRc);

	for (i = 0; i < WLAN_RC_PHY_MAX; i++) {
  90c569:	685a04        	beqi	a5, 12, 90c571 <rcSibUpdate_ht$constprop$6+0x65>

	/* Initial rate table size. Will change depending on the working rate set */
	pRc->rateTableSize = MAX_TX_RATE_TBL;

	/* Initialize thresholds according to the global rate table */
	for (i = 0 ; (i < pRc->rateTableSize) && (!keepState); i++) {
  90c56c:	c070      	movi.n	a7, 0
  90c56e:	63ffe3        	j	90c555 <rcSibUpdate_ht$constprop$6+0x49>
			mPhyCtrlState.validPhyRateIndex[i][j] = 0;
		}   
		mPhyCtrlState.validPhyRateCount[i] = 0;
	}

	pRc->rcPhyMode = (capflag & WLAN_RC_40_FLAG);
  90c571:	c052      	movi.n	a5, 2
  90c573:	054901        	and	a9, a4, a5
  90c576:	040d40        	extui	a13, a4, 0, 1
  90c579:	291690        	s32i	a9, a1, 0x240
  90c57c:	29646c        	s8i	a9, a6, 108
  90c57f:	2d1693        	s32i	a13, a1, 0x24c

	if (pRateSet == NULL || !pRateSet->rates.rs_nrates) {
  90c582:	c834      	beqz.n	a3, 90c58a <rcSibUpdate_ht$constprop$6+0x7e>
  90c584:	273000        	l8ui	a7, a3, 0
  90c587:	657071        	bnez	a7, 90c5fc <rcSibUpdate_ht$constprop$6+0xf0>
static A_UINT8 rcSibInitValidRates(const RATE_TABLE_11N *pRateTable,
				   TX_RATE_CTRL *pRc,
				   A_UINT32 capflag,
				   PHY_STATE_CTRL *pPhyStateCtrl)
{
	A_UINT8 i, hi = 0;
  90c58a:	c050      	movi.n	a5, 0
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT8 valid;
    
	for (i = 0; i < pRateTable->rateCount; i++) {
  90c58c:	d350      	mov.n	a3, a5
  90c58e:	600060        	j	90c5f2 <rcSibUpdate_ht$constprop$6+0xe6>
  90c591:	0e3711        	slli	a7, a3, 2
		if (singleStream) {
			valid = pRateTable->info[i].validSingleStream;
  90c594:	a377      	add.n	a7, a7, a3
	A_UINT8 i, hi = 0;
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT8 valid;
    
	for (i = 0; i < pRateTable->rateCount; i++) {
		if (singleStream) {
  90c596:	281293        	l32i	a8, a1, 0x24c
			valid = pRateTable->info[i].validSingleStream;
  90c599:	037709        	addx2	a7, a7, a3
  90c59c:	02770a        	addx4	a7, a7, a2
	A_UINT8 i, hi = 0;
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT8 valid;
    
	for (i = 0; i < pRateTable->rateCount; i++) {
		if (singleStream) {
  90c59f:	cc85      	bnez.n	a8, 90c5a8 <rcSibUpdate_ht$constprop$6+0x9c>
			valid = pRateTable->info[i].validSingleStream;
  90c5a1:	28700b        	l8ui	a8, a7, 11
  90c5a4:	600003        	j	90c5ab <rcSibUpdate_ht$constprop$6+0x9f>
  90c5a7:	002870        	excw
		} else {
			valid = pRateTable->info[i].valid;
  90c5aa:	076981        	excw
		}
            
		if (valid == TRUE) {
  90c5ad:	3e0337        	excw
			A_UINT32 phy = pRateTable->info[i].phy;
  90c5b0:	0a0377        	excw
  90c5b3:	090277        	excw
  90c5b6:	0a2770        	excw
  90c5b9:	10044b        	l32r	a0, 8cd6e8 <_bss_end+0x3ba7d8>

			if (!rcIsValidPhyRate(phy, capflag, FALSE)) 
  90c5bc:	02da70        	excw
  90c5bf:	2c0a00        	movi	a12, 0
  90c5c2:	281699        	s32i	a8, a1, 0x264
  90c5c5:	5bff34        	call8	90c298 <rcIsValidPhyRate>
  90c5c8:	281299        	l32i	a8, a1, 0x264
  90c5cb:	c9ae      	beqz.n	a10, 90c5ed <rcSibUpdate_ht$constprop$6+0xe1>
				continue;

			pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = i;
  90c5cd:	a719      	add.n	a9, a1, a7
  90c5cf:	2a9000        	l8ui	a10, a9, 0
  90c5d2:	077b09        	addx2	a11, a7, a7
  90c5d5:	07b70f        	subx8	a7, a11, a7
  90c5d8:	0a7709        	addx2	a7, a7, a10
  90c5db:	a717      	add.n	a7, a1, a7
  90c5dd:	23740c        	s8i	a3, a7, 12
			pPhyStateCtrl->validPhyRateCount[phy] += 1;
  90c5e0:	b1aa      	addi.n	a10, a10, 1

static INLINE void
rcSetValidTxMask(TX_RATE_CTRL *pRc, A_UINT8 index, A_BOOL validTxRate)
{
	ASSERT(index < pRc->rateTableSize);
	pRc->validRateIndex[index] = validTxRate ? TRUE : FALSE;
  90c5e2:	a367      	add.n	a7, a6, a3

			if (!rcIsValidPhyRate(phy, capflag, FALSE)) 
				continue;

			pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = i;
			pPhyStateCtrl->validPhyRateCount[phy] += 1;
  90c5e4:	2a9400        	s8i	a10, a9, 0

static INLINE void
rcSetValidTxMask(TX_RATE_CTRL *pRc, A_UINT8 index, A_BOOL validTxRate)
{
	ASSERT(index < pRc->rateTableSize);
	pRc->validRateIndex[index] = validTxRate ? TRUE : FALSE;
  90c5e7:	28743a        	s8i	a8, a7, 58
			pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = i;
			pPhyStateCtrl->validPhyRateCount[phy] += 1;

			rcSetValidTxMask(pRc, i, TRUE);

			hi = A_MAX(hi, i);
  90c5ea:	035537        	maxu	a5, a5, a3
{
	A_UINT8 i, hi = 0;
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT8 valid;
    
	for (i = 0; i < pRateTable->rateCount; i++) {
  90c5ed:	b133      	addi.n	a3, a3, 1
  90c5ef:	030347        	extui	a3, a3, 0, 8
  90c5f2:	272000        	l8ui	a7, a2, 0
  90c5f5:	773398        	bltu	a3, a7, 90c591 <rcSibUpdate_ht$constprop$6+0x85>
  90c5f8:	6001de        	j	90c7da <rcSibUpdate_ht$constprop$6+0x2ce>
  90c5fb:	002a12        	srai	a10, a0, 2
			 * the validity (TRUE/TRUE_20/TRUE_40) flags
			 */

			if (((pRateSet->rs_rates[i] & 0x7F) == 
			     (pRateTable->info[j].dot11Rate & 0x7F))
			    && ((valid & WLAN_RC_CAP_MODE(capflag)) == 
  90c5fe:	90c0      	s32i.n	a0, a12, 0
                   struct ieee80211_rateset *pRateSet,
		   A_UINT32 capflag,
		   struct ath_node_target *an,
		   PHY_STATE_CTRL *pPhyStateCtrl)
{
	A_UINT8 i, j, hi = 0;
  90c600:	90c0      	s32i.n	a0, a12, 0
			 * the validity (TRUE/TRUE_20/TRUE_40) flags
			 */

			if (((pRateSet->rs_rates[i] & 0x7F) == 
			     (pRateTable->info[j].dot11Rate & 0x7F))
			    && ((valid & WLAN_RC_CAP_MODE(capflag)) == 
  90c602:	e8          	.byte 0xe8
  90c603:	c0d4      	movi.n	a13, 4
                   struct ieee80211_rateset *pRateSet,
		   A_UINT32 capflag,
		   struct ath_node_target *an,
		   PHY_STATE_CTRL *pPhyStateCtrl)
{
	A_UINT8 i, j, hi = 0;
  90c605:	291691        	s32i	a9, a1, 0x244
			 * the validity (TRUE/TRUE_20/TRUE_40) flags
			 */

			if (((pRateSet->rs_rates[i] & 0x7F) == 
			     (pRateTable->info[j].dot11Rate & 0x7F))
			    && ((valid & WLAN_RC_CAP_MODE(capflag)) == 
  90c608:	0e4e01        	and	a14, a4, a14
  90c60b:	0a5d38        	moveqz	a13, a5, a10
  90c60e:	6000c3        	j	90c6d5 <rcSibUpdate_ht$constprop$6+0x1c9>
		for (j = 0; j < pRateTable->rateCount; j++) {
			A_UINT32 phy = pRateTable->info[j].phy;
#ifdef MAGPIE_MERLIN
			struct atheros_node *pSib = ATH_NODE_ATHEROS(an);

			if (pSib->stbc) {
  90c611:	2b8282        	l32i	a11, a8, 0x208
	A_UINT32 valid;
       
	/* Use intersection of working rates and valid rates */
	for (i = 0; i < pRateSet->rs_nrates; i++) {
		for (j = 0; j < pRateTable->rateCount; j++) {
			A_UINT32 phy = pRateTable->info[j].phy;
  90c614:	077a0a        	addx4	a10, a7, a7
  90c617:	07aa09        	addx2	a10, a10, a7
#ifdef MAGPIE_MERLIN
			struct atheros_node *pSib = ATH_NODE_ATHEROS(an);

			if (pSib->stbc) {
  90c61a:	2bb21d        	l32i	a11, a11, 116
  90c61d:	1c6acb        	l32r	a12, 8e714c <memset+0x304>
	A_UINT32 valid;
       
	/* Use intersection of working rates and valid rates */
	for (i = 0; i < pRateSet->rs_nrates; i++) {
		for (j = 0; j < pRateTable->rateCount; j++) {
			A_UINT32 phy = pRateTable->info[j].phy;
  90c620:	02aa0a        	addx4	a10, a10, a2
  90c623:	25a010        	l8ui	a5, a10, 16
#ifdef MAGPIE_MERLIN
			struct atheros_node *pSib = ATH_NODE_ATHEROS(an);

			if (pSib->stbc) {
  90c626:	7cb006        	bnone	a11, a12, 90c630 <rcSibUpdate_ht$constprop$6+0x124>
				valid = pRateTable->info[j].validSTBC;
  90c629:	8ba3      	l32i.n	a11, a10, 12
  90c62b:	60000d        	j	90c63c <rcSibUpdate_ht$constprop$6+0x130>
  90c62e:	00002b        	mulsh	a0, a0, a0
			} else if (singleStream) {
  90c631:	1293cc        	l32r	a2, 8f1564 <memset+0xa71c>
  90c634:	b38b      	addi.n	a11, a8, 3
#else
			if (singleStream) {
#endif            
				valid = pRateTable->info[j].validSingleStream;
  90c636:	a260      	add.n	a0, a6, a2
  90c638:	00018b        	excw
			} else {
				valid = pRateTable->info[j].valid;
  90c63b:	a107      	add.n	a7, a0, a1
			 * We allow a rate only if its valid and the capflag matches one of
			 * the validity (TRUE/TRUE_20/TRUE_40) flags
			 */

			if (((pRateSet->rs_rates[i] & 0x7F) == 
			     (pRateTable->info[j].dot11Rate & 0x7F))
  90c63d:	7a0a07        	bge	a0, a10, 90c648 <rcSibUpdate_ht$constprop$6+0x13c>
  90c640:	aa09      	add.n	a9, a0, a10
  90c642:	02aa0a        	addx4	a10, a10, a2
			/*
			 * We allow a rate only if its valid and the capflag matches one of
			 * the validity (TRUE/TRUE_20/TRUE_40) flags
			 */

			if (((pRateSet->rs_rates[i] & 0x7F) == 
  90c645:	2cf000        	l8ui	a12, a15, 0
  90c648:	2aa01e        	l8ui	a10, a10, 30
  90c64b:	0aca03        	xor	a10, a12, a10
  90c64e:	0a0a46        	extui	a10, a10, 0, 7
  90c651:	65a064        	bnez	a10, 90c6b9 <rcSibUpdate_ht$constprop$6+0x1ad>
			     (pRateTable->info[j].dot11Rate & 0x7F))
			    && ((valid & WLAN_RC_CAP_MODE(capflag)) == 
  90c654:	c0a1      	movi.n	a10, 1
  90c656:	0eda39        	movnez	a10, a13, a14
  90c659:	0bab01        	and	a11, a10, a11
  90c65c:	c0a1      	movi.n	a10, 1
  90c65e:	0eda39        	movnez	a10, a13, a14
  90c661:	7ab954        	bne	a11, a10, 90c6b9 <rcSibUpdate_ht$constprop$6+0x1ad>
				WLAN_RC_CAP_MODE(capflag)) && !WLAN_RC_PHY_HT(phy)) {
  90c664:	6f5451        	bgeui	a5, 4, 90c6b9 <rcSibUpdate_ht$constprop$6+0x1ad>
				if (!rcIsValidPhyRate(phy, capflag, FALSE)) 
  90c667:	da50      	mov.n	a10, a5
  90c669:	db40      	mov.n	a11, a4
  90c66b:	2c0a00        	movi	a12, 0
  90c66e:	281699        	s32i	a8, a1, 0x264
  90c671:	291696        	s32i	a9, a1, 0x258
  90c674:	2d1695        	s32i	a13, a1, 0x254
  90c677:	2e1698        	s32i	a14, a1, 0x260
  90c67a:	2f1697        	s32i	a15, a1, 0x25c
  90c67d:	5bff06        	call8	90c298 <rcIsValidPhyRate>
  90c680:	281299        	l32i	a8, a1, 0x264
  90c683:	291296        	l32i	a9, a1, 0x258
  90c686:	2d1295        	l32i	a13, a1, 0x254
  90c689:	2e1298        	l32i	a14, a1, 0x260
  90c68c:	2f1297        	l32i	a15, a1, 0x25c
  90c68f:	caa6      	beqz.n	a10, 90c6b9 <rcSibUpdate_ht$constprop$6+0x1ad>
					continue;

				pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = j;
  90c691:	a51a      	add.n	a10, a1, a5
  90c693:	2ba000        	l8ui	a11, a10, 0
  90c696:	055c09        	addx2	a12, a5, a5
  90c699:	05c50f        	subx8	a5, a12, a5
  90c69c:	0b5509        	addx2	a5, a5, a11
  90c69f:	a515      	add.n	a5, a1, a5
  90c6a1:	27540c        	s8i	a7, a5, 12

static INLINE void
rcSetValidTxMask(TX_RATE_CTRL *pRc, A_UINT8 index, A_BOOL validTxRate)
{
	ASSERT(index < pRc->rateTableSize);
	pRc->validRateIndex[index] = validTxRate ? TRUE : FALSE;
  90c6a4:	c0c1      	movi.n	a12, 1
  90c6a6:	a765      	add.n	a5, a6, a7
  90c6a8:	2c543a        	s8i	a12, a5, 58

				pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = j;
				pPhyStateCtrl->validPhyRateCount[phy] += 1;

				rcSetValidTxMask(pRc, j, TRUE);
				hi = A_MAX(hi, j);
  90c6ab:	251291        	l32i	a5, a1, 0x244
				WLAN_RC_CAP_MODE(capflag)) && !WLAN_RC_PHY_HT(phy)) {
				if (!rcIsValidPhyRate(phy, capflag, FALSE)) 
					continue;

				pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = j;
				pPhyStateCtrl->validPhyRateCount[phy] += 1;
  90c6ae:	b1bb      	addi.n	a11, a11, 1

				rcSetValidTxMask(pRc, j, TRUE);
				hi = A_MAX(hi, j);
  90c6b0:	075537        	maxu	a5, a5, a7
				WLAN_RC_CAP_MODE(capflag)) && !WLAN_RC_PHY_HT(phy)) {
				if (!rcIsValidPhyRate(phy, capflag, FALSE)) 
					continue;

				pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = j;
				pPhyStateCtrl->validPhyRateCount[phy] += 1;
  90c6b3:	2ba400        	s8i	a11, a10, 0

				rcSetValidTxMask(pRc, j, TRUE);
				hi = A_MAX(hi, j);
  90c6b6:	251691        	s32i	a5, a1, 0x244
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT32 valid;
       
	/* Use intersection of working rates and valid rates */
	for (i = 0; i < pRateSet->rs_nrates; i++) {
		for (j = 0; j < pRateTable->rateCount; j++) {
  90c6b9:	b177      	addi.n	a7, a7, 1
  90c6bb:	070747        	extui	a7, a7, 0, 8
  90c6be:	600005        	j	90c6c7 <rcSibUpdate_ht$constprop$6+0x1bb>
			/*
			 * We allow a rate only if its valid and the capflag matches one of
			 * the validity (TRUE/TRUE_20/TRUE_40) flags
			 */

			if (((pRateSet->rs_rates[i] & 0x7F) == 
  90c6c1:	a93f      	add.n	a15, a3, a9
	A_UINT8 i, j, hi = 0;
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT32 valid;
       
	/* Use intersection of working rates and valid rates */
	for (i = 0; i < pRateSet->rs_nrates; i++) {
  90c6c3:	c070      	movi.n	a7, 0
			/*
			 * We allow a rate only if its valid and the capflag matches one of
			 * the validity (TRUE/TRUE_20/TRUE_40) flags
			 */

			if (((pRateSet->rs_rates[i] & 0x7F) == 
  90c6c5:	b1ff      	addi.n	a15, a15, 1
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT32 valid;
       
	/* Use intersection of working rates and valid rates */
	for (i = 0; i < pRateSet->rs_nrates; i++) {
		for (j = 0; j < pRateTable->rateCount; j++) {
  90c6c7:	252000        	l8ui	a5, a2, 0
  90c6ca:	757b02        	bgeu	a7, a5, 90c6d0 <rcSibUpdate_ht$constprop$6+0x1c4>
  90c6cd:	63ff40        	j	90c611 <rcSibUpdate_ht$constprop$6+0x105>
	A_UINT8 i, j, hi = 0;
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT32 valid;
       
	/* Use intersection of working rates and valid rates */
	for (i = 0; i < pRateSet->rs_nrates; i++) {
  90c6d0:	b199      	addi.n	a9, a9, 1
  90c6d2:	090947        	extui	a9, a9, 0, 8
  90c6d5:	253000        	l8ui	a5, a3, 0
  90c6d8:	7593e5        	bltu	a9, a5, 90c6c1 <rcSibUpdate_ht$constprop$6+0x1b5>
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	A_UINT8 *phtMcs = (A_UINT8*)&pRateSet->htrates;
	TX_RATE_CTRL *pRc = (TX_RATE_CTRL *)(pSib);
	PHY_STATE_CTRL mPhyCtrlState;  

	A_UINT8 i, j, k, hi = 0, htHi = 0;
  90c6db:	c090      	movi.n	a9, 0
	} else {
		/* Use intersection of working rates and valid rates */
		hi = rcSibSetValidRates(pRateTable, pRc, &(pRateSet->rates),
					capflag, an, &mPhyCtrlState);

		if (capflag & WLAN_RC_HT_FLAG) {
  90c6dd:	7c4f02        	bbsi	a4, 28, 90c6e3 <rcSibUpdate_ht$constprop$6+0x1d7>
  90c6e0:	6000f0        	j	90c7d4 <rcSibUpdate_ht$constprop$6+0x2c8>
			     != (pRateTable->info[j].dot11Rate & 0x7F)) 
			    || !WLAN_RC_PHY_HT(phy) 
			    || !WLAN_RC_PHY_HT_VALID(valid, capflag)
			    || ((pRateTable->info[j].dot11Rate == 15) && 
				(valid & TRUE_20) && 
				(capflag & WLAN_RC_WEP_TKIP_FLAG)) )
  90c6e3:	251a00        	movi	a5, 0x100
	       A_UINT32 capflag, A_BOOL keepState, struct ieee80211_rate  *pRateSet)
{
	RATE_TABLE_11N *pRateTable = 0;
	struct atheros_node *pSib = ATH_NODE_ATHEROS(an);
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	A_UINT8 *phtMcs = (A_UINT8*)&pRateSet->htrates;
  90c6e6:	233c1f        	addi	a3, a3, 31
			     != (pRateTable->info[j].dot11Rate & 0x7F)) 
			    || !WLAN_RC_PHY_HT(phy) 
			    || !WLAN_RC_PHY_HT_VALID(valid, capflag)
			    || ((pRateTable->info[j].dot11Rate == 15) && 
				(valid & TRUE_20) && 
				(capflag & WLAN_RC_WEP_TKIP_FLAG)) )
  90c6e9:	054501        	and	a5, a4, a5
	       A_UINT32 capflag, A_BOOL keepState, struct ieee80211_rate  *pRateSet)
{
	RATE_TABLE_11N *pRateTable = 0;
	struct atheros_node *pSib = ATH_NODE_ATHEROS(an);
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	A_UINT8 *phtMcs = (A_UINT8*)&pRateSet->htrates;
  90c6ec:	23169a        	s32i	a3, a1, 0x268
			     != (pRateTable->info[j].dot11Rate & 0x7F)) 
			    || !WLAN_RC_PHY_HT(phy) 
			    || !WLAN_RC_PHY_HT_VALID(valid, capflag)
			    || ((pRateTable->info[j].dot11Rate == 15) && 
				(valid & TRUE_20) && 
				(capflag & WLAN_RC_WEP_TKIP_FLAG)) )
  90c6ef:	251694        	s32i	a5, a1, 0x250
	       A_UINT32 capflag, A_BOOL keepState, struct ieee80211_rate  *pRateSet)
{
	RATE_TABLE_11N *pRateTable = 0;
	struct atheros_node *pSib = ATH_NODE_ATHEROS(an);
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	A_UINT8 *phtMcs = (A_UINT8*)&pRateSet->htrates;
  90c6f2:	d390      	mov.n	a3, a9
                           
			if (((((struct ieee80211_rateset *)pMcsSet)->rs_rates[i] & 0x7F) 
			     != (pRateTable->info[j].dot11Rate & 0x7F)) 
			    || !WLAN_RC_PHY_HT(phy) 
			    || !WLAN_RC_PHY_HT_VALID(valid, capflag)
			    || ((pRateTable->info[j].dot11Rate == 15) && 
  90c6f4:	c0ef      	movi.n	a14, 15
  90c6f6:	6000d1        	j	90c7cb <rcSibUpdate_ht$constprop$6+0x2bf>
		for (j = 0; j < pRateTable->rateCount; j++) {
			A_UINT32 phy = pRateTable->info[j].phy;
#ifdef MAGPIE_MERLIN
			struct atheros_node *pSib = ATH_NODE_ATHEROS(an);

			if (pSib->stbc) {
  90c6f9:	2b8282        	l32i	a11, a8, 0x208
	A_UINT8 valid;
    
	/* Use intersection of working rates and valid rates */
	for (i = 0; i <  ((struct ieee80211_rateset *)pMcsSet)->rs_nrates; i++) {
		for (j = 0; j < pRateTable->rateCount; j++) {
			A_UINT32 phy = pRateTable->info[j].phy;
  90c6fc:	077a0a        	addx4	a10, a7, a7
  90c6ff:	07aa09        	addx2	a10, a10, a7
#ifdef MAGPIE_MERLIN
			struct atheros_node *pSib = ATH_NODE_ATHEROS(an);

			if (pSib->stbc) {
  90c702:	2bb21d        	l32i	a11, a11, 116
  90c705:	1c6acb        	l32r	a12, 8e7234 <memset+0x3ec>
	A_UINT8 valid;
    
	/* Use intersection of working rates and valid rates */
	for (i = 0; i <  ((struct ieee80211_rateset *)pMcsSet)->rs_nrates; i++) {
		for (j = 0; j < pRateTable->rateCount; j++) {
			A_UINT32 phy = pRateTable->info[j].phy;
  90c708:	02aa0a        	addx4	a10, a10, a2
  90c70b:	25a010        	l8ui	a5, a10, 16
#ifdef MAGPIE_MERLIN
			struct atheros_node *pSib = ATH_NODE_ATHEROS(an);

			if (pSib->stbc) {
  90c70e:	7cb006        	bnone	a11, a12, 90c718 <rcSibUpdate_ht$constprop$6+0x20c>
				valid = pRateTable->info[j].validSTBC;
  90c711:	2aa00f        	l8ui	a10, a10, 15
  90c714:	600010        	j	90c728 <rcSibUpdate_ht$constprop$6+0x21c>
  90c717:	002d12        	srai	a13, a0, 2
			} else if (singleStream) {
  90c71a:	93cc      	s32i.n	a3, a12, 48
  90c71c:	d62a      	excw
#else
			if (singleStream) {
#endif
				valid = pRateTable->info[j].validSingleStream;
  90c71e:	a00b      	add.n	a11, a0, a0
  90c720:	600004        	j	90c728 <rcSibUpdate_ht$constprop$6+0x21c>
  90c723:	00002a        	muluh	a0, a0, a0
			} else {
				valid = pRateTable->info[j].valid;
  90c726:	a007      	add.n	a7, a0, a0
			}
                           
			if (((((struct ieee80211_rateset *)pMcsSet)->rs_rates[i] & 0x7F) 
			     != (pRateTable->info[j].dot11Rate & 0x7F)) 
  90c728:	077b0a        	addx4	a11, a7, a7
  90c72b:	07bb09        	addx2	a11, a11, a7
  90c72e:	02bb0a        	addx4	a11, a11, a2
  90c731:	2bb01e        	l8ui	a11, a11, 30
  90c734:	2cf000        	l8ui	a12, a15, 0
  90c737:	0cbc03        	xor	a12, a11, a12
				valid = pRateTable->info[j].validSingleStream;
			} else {
				valid = pRateTable->info[j].valid;
			}
                           
			if (((((struct ieee80211_rateset *)pMcsSet)->rs_rates[i] & 0x7F) 
  90c73a:	0c0c46        	extui	a12, a12, 0, 7
  90c73d:	65c06b        	bnez	a12, 90c7ac <rcSibUpdate_ht$constprop$6+0x2a0>
			     != (pRateTable->info[j].dot11Rate & 0x7F)) 
			    || !WLAN_RC_PHY_HT(phy) 
  90c740:	6e5468        	bltui	a5, 4, 90c7ac <rcSibUpdate_ht$constprop$6+0x2a0>
			    || !WLAN_RC_PHY_HT_VALID(valid, capflag)
  90c743:	c0d2      	movi.n	a13, 2
  90c745:	0dac01        	and	a12, a10, a13
  90c748:	c8c4      	beqz.n	a12, 90c750 <rcSibUpdate_ht$constprop$6+0x244>
  90c74a:	2d1290        	l32i	a13, a1, 0x240
  90c74d:	64d148        	beqz	a13, 90c899 <rcSibUpdate_ht$constprop$6+0x38d>
  90c750:	c0d4      	movi.n	a13, 4
  90c752:	7da056        	bnone	a10, a13, 90c7ac <rcSibUpdate_ht$constprop$6+0x2a0>
  90c755:	2d1290        	l32i	a13, a1, 0x240
  90c758:	64d050        	beqz	a13, 90c7ac <rcSibUpdate_ht$constprop$6+0x2a0>
			    || ((pRateTable->info[j].dot11Rate == 15) && 
  90c75b:	7eb907        	bne	a11, a14, 90c766 <rcSibUpdate_ht$constprop$6+0x25a>
  90c75e:	c8c4      	beqz.n	a12, 90c766 <rcSibUpdate_ht$constprop$6+0x25a>
				(valid & TRUE_20) && 
  90c760:	2d1294        	l32i	a13, a1, 0x250
  90c763:	65d045        	bnez	a13, 90c7ac <rcSibUpdate_ht$constprop$6+0x2a0>
				(capflag & WLAN_RC_WEP_TKIP_FLAG)) )
			{
				continue;
			}
    
			if (!rcIsValidPhyRate(phy, capflag, FALSE)) 
  90c766:	da50      	mov.n	a10, a5
  90c768:	db40      	mov.n	a11, a4
  90c76a:	2c0a00        	movi	a12, 0
  90c76d:	281699        	s32i	a8, a1, 0x264
  90c770:	291696        	s32i	a9, a1, 0x258
  90c773:	2e1698        	s32i	a14, a1, 0x260
  90c776:	2f1697        	s32i	a15, a1, 0x25c
  90c779:	5bfec7        	call8	90c298 <rcIsValidPhyRate>
  90c77c:	281299        	l32i	a8, a1, 0x264
  90c77f:	291296        	l32i	a9, a1, 0x258
  90c782:	2e1298        	l32i	a14, a1, 0x260
  90c785:	2f1297        	l32i	a15, a1, 0x25c
  90c788:	caa0      	beqz.n	a10, 90c7ac <rcSibUpdate_ht$constprop$6+0x2a0>
				continue;
    
			pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = j;
  90c78a:	a51a      	add.n	a10, a1, a5
  90c78c:	2ba000        	l8ui	a11, a10, 0
  90c78f:	055c09        	addx2	a12, a5, a5
  90c792:	05c50f        	subx8	a5, a12, a5
  90c795:	0b5509        	addx2	a5, a5, a11
  90c798:	a515      	add.n	a5, a1, a5
			pPhyStateCtrl->validPhyRateCount[phy] += 1;
  90c79a:	b1bb      	addi.n	a11, a11, 1
			}
    
			if (!rcIsValidPhyRate(phy, capflag, FALSE)) 
				continue;
    
			pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = j;
  90c79c:	27540c        	s8i	a7, a5, 12
			pPhyStateCtrl->validPhyRateCount[phy] += 1;
  90c79f:	2ba400        	s8i	a11, a10, 0

static INLINE void
rcSetValidTxMask(TX_RATE_CTRL *pRc, A_UINT8 index, A_BOOL validTxRate)
{
	ASSERT(index < pRc->rateTableSize);
	pRc->validRateIndex[index] = validTxRate ? TRUE : FALSE;
  90c7a2:	a765      	add.n	a5, a6, a7
  90c7a4:	c0a1      	movi.n	a10, 1
  90c7a6:	2a543a        	s8i	a10, a5, 58
    
			pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = j;
			pPhyStateCtrl->validPhyRateCount[phy] += 1;

			rcSetValidTxMask(pRc, j, TRUE);
			hi = A_MAX(hi, j);
  90c7a9:	079937        	maxu	a9, a9, a7
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT8 valid;
    
	/* Use intersection of working rates and valid rates */
	for (i = 0; i <  ((struct ieee80211_rateset *)pMcsSet)->rs_nrates; i++) {
		for (j = 0; j < pRateTable->rateCount; j++) {
  90c7ac:	b177      	addi.n	a7, a7, 1
  90c7ae:	070747        	extui	a7, a7, 0, 8
  90c7b1:	600008        	j	90c7bd <rcSibUpdate_ht$constprop$6+0x2b1>
				valid = pRateTable->info[j].validSingleStream;
			} else {
				valid = pRateTable->info[j].valid;
			}
                           
			if (((((struct ieee80211_rateset *)pMcsSet)->rs_rates[i] & 0x7F) 
  90c7b4:	2d129a        	l32i	a13, a1, 0x268
	A_UINT8 i, j, hi = 0;
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT8 valid;
    
	/* Use intersection of working rates and valid rates */
	for (i = 0; i <  ((struct ieee80211_rateset *)pMcsSet)->rs_nrates; i++) {
  90c7b7:	c070      	movi.n	a7, 0
				valid = pRateTable->info[j].validSingleStream;
			} else {
				valid = pRateTable->info[j].valid;
			}
                           
			if (((((struct ieee80211_rateset *)pMcsSet)->rs_rates[i] & 0x7F) 
  90c7b9:	a3df      	add.n	a15, a13, a3
  90c7bb:	b1ff      	addi.n	a15, a15, 1
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT8 valid;
    
	/* Use intersection of working rates and valid rates */
	for (i = 0; i <  ((struct ieee80211_rateset *)pMcsSet)->rs_nrates; i++) {
		for (j = 0; j < pRateTable->rateCount; j++) {
  90c7bd:	252000        	l8ui	a5, a2, 0
  90c7c0:	757b02        	bgeu	a7, a5, 90c7c6 <rcSibUpdate_ht$constprop$6+0x2ba>
  90c7c3:	63ff32        	j	90c6f9 <rcSibUpdate_ht$constprop$6+0x1ed>
	A_UINT8 i, j, hi = 0;
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT8 valid;
    
	/* Use intersection of working rates and valid rates */
	for (i = 0; i <  ((struct ieee80211_rateset *)pMcsSet)->rs_nrates; i++) {
  90c7c6:	b133      	addi.n	a3, a3, 1
  90c7c8:	030347        	extui	a3, a3, 0, 8
  90c7cb:	2d129a        	l32i	a13, a1, 0x268
  90c7ce:	25d000        	l8ui	a5, a13, 0
  90c7d1:	7533df        	bltu	a3, a5, 90c7b4 <rcSibUpdate_ht$constprop$6+0x2a8>
		if (capflag & WLAN_RC_HT_FLAG) {
			htHi = rcSibSetValidHtRates(pRateTable, pRc, phtMcs,
						    capflag, an, &mPhyCtrlState);
		}

		hi = A_MAX(hi, htHi);
  90c7d4:	231291        	l32i	a3, a1, 0x244
  90c7d7:	039537        	maxu	a5, a9, a3
	}

	pRc->rateTableSize = hi + 1;
	pRc->rateMaxPhy    = 0;
  90c7da:	c030      	movi.n	a3, 0
		}

		hi = A_MAX(hi, htHi);
	}

	pRc->rateTableSize = hi + 1;
  90c7dc:	b155      	addi.n	a5, a5, 1
	pRc->rateMaxPhy    = 0;
  90c7de:	23646d        	s8i	a3, a6, 109
  90c7e1:	c030      	movi.n	a3, 0
		}

		hi = A_MAX(hi, htHi);
	}

	pRc->rateTableSize = hi + 1;
  90c7e3:	25642e        	s8i	a5, a6, 46
	pRc->rateMaxPhy    = 0;
    
	ASSERT(pRc->rateTableSize <= MAX_TX_RATE_TBL);

	for (i = 0, k = 0; i < WLAN_RC_PHY_MAX; i++) {
  90c7e6:	d430      	mov.n	a4, a3
  90c7e8:	60004e        	j	90c83a <rcSibUpdate_ht$constprop$6+0x32e>
  90c7eb:	002d12        	srai	a13, a0, 2
 *  (e.g. SME operation, wireless mode change)
 *
 *  It will determine which rates are valid for use.
 */
static void
rcSibUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an,
  90c7ee:	92a9      	s32i.n	a2, a10, 36
    
	ASSERT(pRc->rateTableSize <= MAX_TX_RATE_TBL);

	for (i = 0, k = 0; i < WLAN_RC_PHY_MAX; i++) {
		for (j = 0; j < mPhyCtrlState.validPhyRateCount[i]; j++) {
			pRc->validRateIndex[k++] = mPhyCtrlState.validPhyRateIndex[i][j];
  90c7f0:	69a7d8        	bnei	a10, 7, 90c7cc <rcSibUpdate_ht$constprop$6+0x2c0>
  90c7f3:	28800c        	l8ui	a8, a8, 12
  90c7f6:	b177      	addi.n	a7, a7, 1
  90c7f8:	28943a        	s8i	a8, a9, 58
 *  (e.g. SME operation, wireless mode change)
 *
 *  It will determine which rates are valid for use.
 */
static void
rcSibUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an,
  90c7fb:	070847        	extui	a8, a7, 0, 8
  90c7fe:	a489      	add.n	a9, a8, a4
  90c800:	090947        	extui	a9, a9, 0, 8
	pRc->rateMaxPhy    = 0;
    
	ASSERT(pRc->rateTableSize <= MAX_TX_RATE_TBL);

	for (i = 0, k = 0; i < WLAN_RC_PHY_MAX; i++) {
		for (j = 0; j < mPhyCtrlState.validPhyRateCount[i]; j++) {
  90c803:	7583e5        	bltu	a8, a5, 90c7ec <rcSibUpdate_ht$constprop$6+0x2e0>
			pRc->validRateIndex[k++] = mPhyCtrlState.validPhyRateIndex[i][j];
		}   

		if (!rcIsValidPhyRate(i, pRateTable->initialRateMax, TRUE) ||
  90c806:	2b2003        	l8ui	a11, a2, 3
  90c809:	a454      	add.n	a4, a5, a4
  90c80b:	da30      	mov.n	a10, a3
  90c80d:	c0c1      	movi.n	a12, 1
  90c80f:	040447        	extui	a4, a4, 0, 8
  90c812:	5bfea1        	call8	90c298 <rcIsValidPhyRate>
  90c815:	c9a3      	beqz.n	a10, 90c82c <rcSibUpdate_ht$constprop$6+0x320>
  90c817:	645011        	beqz	a5, 90c82c <rcSibUpdate_ht$constprop$6+0x320>
		    !mPhyCtrlState.validPhyRateCount[i]) 
			continue;

		pRc->rateMaxPhy = mPhyCtrlState.validPhyRateIndex[i][j-1];	
  90c81a:	033709        	addx2	a7, a3, a3
  90c81d:	03770f        	subx8	a7, a7, a3
  90c820:	017709        	addx2	a7, a7, a1
  90c823:	057508        	add	a5, a7, a5
  90c826:	25500b        	l8ui	a5, a5, 11
  90c829:	25646d        	s8i	a5, a6, 109
  90c82c:	251292        	l32i	a5, a1, 0x248
  90c82f:	b133      	addi.n	a3, a3, 1
  90c831:	255c2e        	addi	a5, a5, 46
  90c834:	251692        	s32i	a5, a1, 0x248
	pRc->rateTableSize = hi + 1;
	pRc->rateMaxPhy    = 0;
    
	ASSERT(pRc->rateTableSize <= MAX_TX_RATE_TBL);

	for (i = 0, k = 0; i < WLAN_RC_PHY_MAX; i++) {
  90c837:	683a09        	beqi	a3, 12, 90c844 <rcSibUpdate_ht$constprop$6+0x338>
 *  (e.g. SME operation, wireless mode change)
 *
 *  It will determine which rates are valid for use.
 */
static void
rcSibUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an,
  90c83a:	a315      	add.n	a5, a1, a3
	pRc->rateMaxPhy    = 0;
    
	ASSERT(pRc->rateTableSize <= MAX_TX_RATE_TBL);

	for (i = 0, k = 0; i < WLAN_RC_PHY_MAX; i++) {
		for (j = 0; j < mPhyCtrlState.validPhyRateCount[i]; j++) {
  90c83c:	255000        	l8ui	a5, a5, 0
  90c83f:	c070      	movi.n	a7, 0
  90c841:	63ffb6        	j	90c7fb <rcSibUpdate_ht$constprop$6+0x2ef>
	}
    
	ASSERT(pRc->rateTableSize <= MAX_TX_RATE_TBL);
	ASSERT(k <= MAX_TX_RATE_TBL);

	pRc->rateMaxPhy = pRc->validRateIndex[k-4];
  90c844:	a463      	add.n	a3, a6, a4
  90c846:	233036        	l8ui	a3, a3, 54
	pRc->maxValidRate = k;
  90c849:	246439        	s8i	a4, a6, 57
	}
    
	ASSERT(pRc->rateTableSize <= MAX_TX_RATE_TBL);
	ASSERT(k <= MAX_TX_RATE_TBL);

	pRc->rateMaxPhy = pRc->validRateIndex[k-4];
  90c84c:	23646d        	s8i	a3, a6, 109
  90c84f:	60003c        	j	90c88f <rcSibUpdate_ht$constprop$6+0x383>
	A_UINT8 i,j;

	for (i=pRc->maxValidRate-1; i > 0; i--) {
		for (j=0; j <= i-1; j++) {
#ifdef MAGPIE_MERLIN      
			if (pRateTable->info[pRc->validRateIndex[j]].rateKbps >
  90c852:	a369      	add.n	a9, a6, a3
			    pRateTable->info[pRc->validRateIndex[j+1]].rateKbps)
  90c854:	b133      	addi.n	a3, a3, 1
  90c856:	a368      	add.n	a8, a6, a3
	A_UINT8 i,j;

	for (i=pRc->maxValidRate-1; i > 0; i--) {
		for (j=0; j <= i-1; j++) {
#ifdef MAGPIE_MERLIN      
			if (pRateTable->info[pRc->validRateIndex[j]].rateKbps >
  90c858:	25903a        	l8ui	a5, a9, 58
			    pRateTable->info[pRc->validRateIndex[j+1]].rateKbps)
  90c85b:	27803a        	l8ui	a7, a8, 58
	A_UINT8 i,j;

	for (i=pRc->maxValidRate-1; i > 0; i--) {
		for (j=0; j <= i-1; j++) {
#ifdef MAGPIE_MERLIN      
			if (pRateTable->info[pRc->validRateIndex[j]].rateKbps >
  90c85e:	055a0a        	addx4	a10, a5, a5
			    pRateTable->info[pRc->validRateIndex[j+1]].rateKbps)
  90c861:	077b0a        	addx4	a11, a7, a7
	A_UINT8 i,j;

	for (i=pRc->maxValidRate-1; i > 0; i--) {
		for (j=0; j <= i-1; j++) {
#ifdef MAGPIE_MERLIN      
			if (pRateTable->info[pRc->validRateIndex[j]].rateKbps >
  90c864:	05aa09        	addx2	a10, a10, a5
			    pRateTable->info[pRc->validRateIndex[j+1]].rateKbps)
  90c867:	07bb09        	addx2	a11, a11, a7
	A_UINT8 i,j;

	for (i=pRc->maxValidRate-1; i > 0; i--) {
		for (j=0; j <= i-1; j++) {
#ifdef MAGPIE_MERLIN      
			if (pRateTable->info[pRc->validRateIndex[j]].rateKbps >
  90c86a:	02aa0a        	addx4	a10, a10, a2
			    pRateTable->info[pRc->validRateIndex[j+1]].rateKbps)
  90c86d:	02bb0a        	addx4	a11, a11, a2
	A_UINT8 i,j;

	for (i=pRc->maxValidRate-1; i > 0; i--) {
		for (j=0; j <= i-1; j++) {
#ifdef MAGPIE_MERLIN      
			if (pRateTable->info[pRc->validRateIndex[j]].rateKbps >
  90c870:	8aa5      	l32i.n	a10, a10, 20
  90c872:	2bb205        	l32i	a11, a11, 20
  90c875:	299c30        	addi	a9, a9, 48
			    pRateTable->info[pRc->validRateIndex[j+1]].rateKbps)
  90c878:	288c30        	addi	a8, a8, 48
	A_UINT8 i,j;

	for (i=pRc->maxValidRate-1; i > 0; i--) {
		for (j=0; j <= i-1; j++) {
#ifdef MAGPIE_MERLIN      
			if (pRateTable->info[pRc->validRateIndex[j]].rateKbps >
  90c87b:	7abb05        	bgeu	a11, a10, 90c884 <rcSibUpdate_ht$constprop$6+0x378>
				    pRateTable->info[pRc->validRateIndex[j+1]].userRateKbps)
#endif
				{
					A_UINT8 tmp=0;
					tmp = pRc->validRateIndex[j];
					pRc->validRateIndex[j] = pRc->validRateIndex[j+1];
  90c87e:	27940a        	s8i	a7, a9, 10
					pRc->validRateIndex[j+1] = tmp;
  90c881:	25840a        	s8i	a5, a8, 10
rcSortValidRates(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc)
{
	A_UINT8 i,j;

	for (i=pRc->maxValidRate-1; i > 0; i--) {
		for (j=0; j <= i-1; j++) {
  90c884:	030347        	extui	a3, a3, 0, 8
  90c887:	600001        	j	90c88c <rcSibUpdate_ht$constprop$6+0x380>
static void
rcSortValidRates(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc)
{
	A_UINT8 i,j;

	for (i=pRc->maxValidRate-1; i > 0; i--) {
  90c88a:	c030      	movi.n	a3, 0
		for (j=0; j <= i-1; j++) {
  90c88c:	7432c2        	blt	a3, a4, 90c852 <rcSibUpdate_ht$constprop$6+0x346>
static void
rcSortValidRates(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc)
{
	A_UINT8 i,j;

	for (i=pRc->maxValidRate-1; i > 0; i--) {
  90c88f:	b044      	addi.n	a4, a4, -1
  90c891:	040447        	extui	a4, a4, 0, 8
  90c894:	654ff2        	bnez	a4, 90c88a <rcSibUpdate_ht$constprop$6+0x37e>
  90c897:	d10f      	retw.n
                           
			if (((((struct ieee80211_rateset *)pMcsSet)->rs_rates[i] & 0x7F) 
			     != (pRateTable->info[j].dot11Rate & 0x7F)) 
			    || !WLAN_RC_PHY_HT(phy) 
			    || !WLAN_RC_PHY_HT_VALID(valid, capflag)
			    || ((pRateTable->info[j].dot11Rate == 15) && 
  90c899:	7eb102        	beq	a11, a14, 90c89f <rcSibUpdate_ht$constprop$6+0x393>
  90c89c:	63fec6        	j	90c766 <rcSibUpdate_ht$constprop$6+0x25a>
  90c89f:	63febd        	j	90c760 <rcSibUpdate_ht$constprop$6+0x254>
	...

0090c8a4 <ath_rate_newassoc_11n>:
}

static void
ath_rate_newassoc_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, int isnew, 
		      unsigned int capflag, struct ieee80211_rate *rs)
{
  90c8a4:	6c1004        	entry	a1, 32
  90c8a7:	da20      	mov.n	a10, a2
  90c8a9:	db30      	mov.n	a11, a3
  90c8ab:	dc50      	mov.n	a12, a5
  90c8ad:	dd60      	mov.n	a13, a6
	if (isnew) {
  90c8af:	c949      	beqz.n	a4, 90c8cc <ath_rate_newassoc_11n+0x28>
#ifdef MAGPIE_MERLIN
		struct atheros_node *oan = ATH_NODE_ATHEROS(an);
  90c8b1:	283282        	l32i	a8, a3, 0x208
		/* Only MERLIN can send STBC */
		oan->stbc = (capflag & ATH_RC_TX_STBC_FLAG) ? 1 : 0;
  90c8b4:	055e40        	extui	a14, a5, 5, 1
  90c8b7:	2f8074        	l8ui	a15, a8, 116
  90c8ba:	29fa9f        	movi	a9, -97
  90c8bd:	0bee11        	slli	a14, a14, 5
  90c8c0:	09f901        	and	a9, a15, a9
  90c8c3:	0e9902        	or	a9, a9, a14
  90c8c6:	298474        	s8i	a9, a8, 116
#endif
		rcSibUpdate_ht(sc, an, capflag, 0, rs);
  90c8c9:	5bff10        	call8	90c50c <rcSibUpdate_ht$constprop$6>
  90c8cc:	d10f      	retw.n
	...

0090c8d0 <rcRateFind_11n>:
}

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
		    int numTries, int numRates, int stepDnInc,
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
  90c8d0:	6c100c        	entry	a1, 96
  90c8d3:	9217      	s32i.n	a2, a1, 28
	A_UINT8 i = 0; 
	A_UINT8 tryPerRate  = 0;
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
  90c8d5:	222248        	l32i	a2, a2, 0x120
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  90c8d8:	8817      	l32i.n	a8, a1, 28
		    int numTries, int numRates, int stepDnInc,
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
	A_UINT8 i = 0; 
	A_UINT8 tryPerRate  = 0;
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
  90c8da:	9218      	s32i.n	a2, a1, 32
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  90c8dc:	8918      	l32i.n	a9, a1, 32
  90c8de:	2282c2        	l32i	a2, a8, 0x308
}

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
		    int numTries, int numRates, int stepDnInc,
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
  90c8e1:	971c      	s32i.n	a7, a1, 48
  90c8e3:	931a      	s32i.n	a3, a1, 40
	A_UINT8 i = 0; 
	A_UINT8 tryPerRate  = 0;
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  90c8e5:	09220a        	addx4	a2, a2, a9
  90c8e8:	8221      	l32i.n	a2, a2, 4
	struct atheros_node *asn = ATH_NODE_ATHEROS(an);
  90c8ea:	881a      	l32i.n	a8, a1, 40
	A_UINT8 rix, nrix;
	A_UINT8 dot11Rate;
	WLAN_PHY phy;

	rix = rcRateFind_ht(sc, asn, pRateTable, (rcflag & ATH_RC_PROBE_ALLOWED) ? 1 : 0, 
  90c8ec:	891c      	l32i.n	a9, a1, 48
	A_INT8               index;
	TX_RATE_CTRL         *pRc = NULL;

	pRc = (TX_RATE_CTRL *)(pSib ? (pSib) : NULL);

	*isProbing = FALSE;
  90c8ee:	2d1219        	l32i	a13, a1, 100
}

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
		    int numTries, int numRates, int stepDnInc,
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
  90c8f1:	9419      	s32i.n	a4, a1, 36
	A_INT8               index;
	TX_RATE_CTRL         *pRc = NULL;

	pRc = (TX_RATE_CTRL *)(pSib ? (pSib) : NULL);

	*isProbing = FALSE;
  90c8f3:	c040      	movi.n	a4, 0
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
	A_UINT8 i = 0; 
	A_UINT8 tryPerRate  = 0;
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  90c8f5:	9214      	s32i.n	a2, a1, 16
	struct atheros_node *asn = ATH_NODE_ATHEROS(an);
	A_UINT8 rix, nrix;
	A_UINT8 dot11Rate;
	WLAN_PHY phy;

	rix = rcRateFind_ht(sc, asn, pRateTable, (rcflag & ATH_RC_PROBE_ALLOWED) ? 1 : 0, 
  90c8f7:	090940        	extui	a9, a9, 0, 1
{
	A_UINT8 i = 0; 
	A_UINT8 tryPerRate  = 0;
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
	struct atheros_node *asn = ATH_NODE_ATHEROS(an);
  90c8fa:	228282        	l32i	a2, a8, 0x208
	 *   0msec   <= dt <= 25msec:   don't derate
	 *   25msec  <= dt <= 185msec:  derate linearly from 0 to 10dB
	 *   185msec <= dt:             derate by 10dB
	 */

	nowMsec = A_MS_TICKGET();
  90c8fd:	da40      	mov.n	a10, a4
	A_INT8               index;
	TX_RATE_CTRL         *pRc = NULL;

	pRc = (TX_RATE_CTRL *)(pSib ? (pSib) : NULL);

	*isProbing = FALSE;
  90c8ff:	94d0      	s32i.n	a4, a13, 0
}

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
		    int numTries, int numRates, int stepDnInc,
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
  90c901:	951b      	s32i.n	a5, a1, 44
  90c903:	961d      	s32i.n	a6, a1, 52
  90c905:	231218        	l32i	a3, a1, 96
	struct atheros_node *asn = ATH_NODE_ATHEROS(an);
	A_UINT8 rix, nrix;
	A_UINT8 dot11Rate;
	WLAN_PHY phy;

	rix = rcRateFind_ht(sc, asn, pRateTable, (rcflag & ATH_RC_PROBE_ALLOWED) ? 1 : 0, 
  90c908:	9916      	s32i.n	a9, a1, 24
	 *   0msec   <= dt <= 25msec:   don't derate
	 *   25msec  <= dt <= 185msec:  derate linearly from 0 to 10dB
	 *   185msec <= dt:             derate by 10dB
	 */

	nowMsec = A_MS_TICKGET();
  90c90a:	5bec71        	call8	907ad0 <ath_hal_getuptime>
	 * Now look up the rate in the rssi table and return it.
	 * If no rates match then we return 0 (lowest rate)
	 */

	bestThruput = 0;
	maxIndex = pRc->maxValidRate-1;
  90c90d:	2e2039        	l8ui	a14, a2, 57
  90c910:	b0ef      	addi.n	a15, a14, -1
  90c912:	0f0f47        	extui	a15, a15, 0, 8
	}

	return rix;
}

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
  90c915:	00f532        	sext	a5, a15, 7
    
	/*
	 * Try the higher rate first. It will reduce memory moving time
	 * if we have very good channel characteristics.
	 */
	for (index = maxIndex; index >= minIndex ; index--) {
  90c918:	d840      	mov.n	a8, a4

	bestThruput = 0;
	maxIndex = pRc->maxValidRate-1;

	minIndex = 0;
	bestRate = minIndex;
  90c91a:	db40      	mov.n	a11, a4
	/*
	 * Now look up the rate in the rssi table and return it.
	 * If no rates match then we return 0 (lowest rate)
	 */

	bestThruput = 0;
  90c91c:	dc40      	mov.n	a12, a4
	}

	return rix;
}

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
  90c91e:	a525      	add.n	a5, a2, a5
		 * used to next lower rate, its PER would grow to
		 * 10-15 and we would be worse off then staying
		 * at the current rate.
		 */
		perThres = pRc->state[rate].per;
		if ( perThres < 12 ) {
  90c920:	c06b      	movi.n	a6, 11
			perThres = 12;
		}

		thisThruput = pRateTable->info[rate].userRateKbps * (100 - perThres);
  90c922:	270a64        	movi	a7, 100
  90c925:	60003e        	j	90c967 <rcRateFind_11n+0x97>
	}

	return rix;
}

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
  90c928:	a854      	add.n	a4, a5, a8
	 * if we have very good channel characteristics.
	 */
	for (index = maxIndex; index >= minIndex ; index--) {
		A_UINT8 perThres;
    
		rate = pRc->validRateIndex[index];
  90c92a:	29403a        	l8ui	a9, a4, 58
		if (rate > pRc->rateMaxPhy) {
  90c92d:	24206d        	l8ui	a4, a2, 109
  90c930:	794331        	bltu	a4, a9, 90c965 <rcRateFind_11n+0x95>
		}

		/* if the best throughput is already larger than the userRateKbps..
		 * then we could skip of rest of calculation.. 
		 */
		if( bestThruput >= pRateTable->info[rate].userRateKbps)
  90c933:	09940a        	addx4	a4, a9, a9
  90c936:	8d14      	l32i.n	a13, a1, 16
  90c938:	094409        	addx2	a4, a4, a9
  90c93b:	0d440a        	addx4	a4, a4, a13
  90c93e:	8446      	l32i.n	a4, a4, 24
  90c940:	74c30a        	bltu	a12, a4, 90c94e <rcRateFind_11n+0x7e>
	/*
	 * Must check the actual rate (rateKbps) to account for non-monoticity of
	 * 11g's rate table
	 */

	if (rate >= pRc->rateMaxPhy && probeAllowed) {
  90c943:	24206d        	l8ui	a4, a2, 109
  90c946:	74bb26        	bgeu	a11, a4, 90c970 <rcRateFind_11n+0xa0>
  90c949:	600027        	j	90c974 <rcRateFind_11n+0xa4>
  90c94c:	0000a9        	excw
		 * rate whose PER has decayed close to 0.  If we
		 * used to next lower rate, its PER would grow to
		 * 10-15 and we would be worse off then staying
		 * at the current rate.
		 */
		perThres = pRc->state[rate].per;
  90c94f:	2d2dd0        	addmi	a13, a2, 0xffffd000
  90c952:	007d63        	excw
		if ( perThres < 12 ) {
  90c955:	01c0dc        	excw
			perThres = 12;
		}

		thisThruput = pRateTable->info[rate].userRateKbps * (100 - perThres);
  90c958:	0d7d0c        	sub	a13, a7, a13
  90c95b:	04dd28        	mull	a13, a13, a4
		if (bestThruput <= thisThruput) {
  90c95e:	7cd303        	bltu	a13, a12, 90c965 <rcRateFind_11n+0x95>
  90c961:	db90      	mov.n	a11, a9
  90c963:	dcd0      	mov.n	a12, a13
  90c965:	b088      	addi.n	a8, a8, -1
	}

	return rix;
}

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
  90c967:	a8f4      	add.n	a4, a15, a8
    
	/*
	 * Try the higher rate first. It will reduce memory moving time
	 * if we have very good channel characteristics.
	 */
	for (index = maxIndex; index >= minIndex ; index--) {
  90c969:	7847bb        	bbci	a4, 24, 90c928 <rcRateFind_11n+0x58>
  90c96c:	63ffd3        	j	90c943 <rcRateFind_11n+0x73>
  90c96f:	008516        	excw
	/*
	 * Must check the actual rate (rateKbps) to account for non-monoticity of
	 * 11g's rate table
	 */

	if (rate >= pRc->rateMaxPhy && probeAllowed) {
  90c972:	ce56      	bnez.n	a5, 90c99c <rcRateFind_11n+0xcc>
  90c974:	d4b0      	mov.n	a4, a11
  90c976:	600047        	j	90c9c1 <rcRateFind_11n+0xf1>
                     A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_UINT8 i;

	for (i = 0; i < pRc->maxValidRate-1; i++) {
		if (pRc->validRateIndex[i] == curValidTxRate) {
  90c979:	a526      	add.n	a6, a2, a5
  90c97b:	27603a        	l8ui	a7, a6, 58
  90c97e:	747912        	bne	a7, a4, 90c994 <rcRateFind_11n+0xc4>
		rate = pRc->rateMaxPhy;

		/* Probe the next allowed phy state */
		/* FIXME: Check to make sure ratMax is checked properly */
		if (rcGetNextValidTxRate( pRateTable, pRc, rate, &nextRate) && 
		    (nowMsec - pRc->probeTime > pRateTable->probeInterval) &&
  90c981:	8814      	l32i.n	a8, a1, 16
{
	A_UINT8 i;

	for (i = 0; i < pRc->maxValidRate-1; i++) {
		if (pRc->validRateIndex[i] == curValidTxRate) {
			*pNextIndex = pRc->validRateIndex[i+1];
  90c983:	25603b        	l8ui	a5, a6, 59
		rate = pRc->rateMaxPhy;

		/* Probe the next allowed phy state */
		/* FIXME: Check to make sure ratMax is checked properly */
		if (rcGetNextValidTxRate( pRateTable, pRc, rate, &nextRate) && 
		    (nowMsec - pRc->probeTime > pRateTable->probeInterval) &&
  90c986:	862d      	l32i.n	a6, a2, 52
  90c988:	278001        	l8ui	a7, a8, 1
  90c98b:	06a60c        	sub	a6, a10, a6
	if (rate >= pRc->rateMaxPhy && probeAllowed) {
		rate = pRc->rateMaxPhy;

		/* Probe the next allowed phy state */
		/* FIXME: Check to make sure ratMax is checked properly */
		if (rcGetNextValidTxRate( pRateTable, pRc, rate, &nextRate) && 
  90c98e:	767316        	bltu	a7, a6, 90c9a8 <rcRateFind_11n+0xd8>
  90c991:	60002c        	j	90c9c1 <rcRateFind_11n+0xf1>
rcGetNextValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc, 
                     A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_UINT8 i;

	for (i = 0; i < pRc->maxValidRate-1; i++) {
  90c994:	b155      	addi.n	a5, a5, 1
  90c996:	050547        	extui	a5, a5, 0, 8
  90c999:	600003        	j	90c9a0 <rcRateFind_11n+0xd0>
	/*
	 * Must check the actual rate (rateKbps) to account for non-monoticity of
	 * 11g's rate table
	 */

	if (rate >= pRc->rateMaxPhy && probeAllowed) {
  90c99c:	c050      	movi.n	a5, 0
rcGetNextValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc, 
                     A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_UINT8 i;

	for (i = 0; i < pRc->maxValidRate-1; i++) {
  90c99e:	b0ee      	addi.n	a14, a14, -1
  90c9a0:	7e52d5        	blt	a5, a14, 90c979 <rcRateFind_11n+0xa9>
  90c9a3:	60001a        	j	90c9c1 <rcRateFind_11n+0xf1>
  90c9a6:	000026        	excw
		rate = pRc->rateMaxPhy;

		/* Probe the next allowed phy state */
		/* FIXME: Check to make sure ratMax is checked properly */
		if (rcGetNextValidTxRate( pRateTable, pRc, rate, &nextRate) && 
		    (nowMsec - pRc->probeTime > pRateTable->probeInterval) &&
  90c9a9:	2038c9        	excw
  90c9ac:	62c040        	j	8f89f0 <memset+0x11ba8>
		{
			rate                  = nextRate;
			pRc->probeRate        = rate;
			pRc->probeTime        = nowMsec;
			pRc->hwMaxRetryPktCnt = 0;
			*isProbing            = TRUE;
  90c9af:	291219        	l32i	a9, a1, 100
		    (pRc->hwMaxRetryPktCnt >= 1))
		{
			rate                  = nextRate;
			pRc->probeRate        = rate;
			pRc->probeTime        = nowMsec;
			pRc->hwMaxRetryPktCnt = 0;
  90c9b2:	242438        	s8i	a4, a2, 56
		if (rcGetNextValidTxRate( pRateTable, pRc, rate, &nextRate) && 
		    (nowMsec - pRc->probeTime > pRateTable->probeInterval) &&
		    (pRc->hwMaxRetryPktCnt >= 1))
		{
			rate                  = nextRate;
			pRc->probeRate        = rate;
  90c9b5:	25242f        	s8i	a5, a2, 47
			pRc->probeTime        = nowMsec;
			pRc->hwMaxRetryPktCnt = 0;
			*isProbing            = TRUE;
  90c9b8:	c041      	movi.n	a4, 1
		    (nowMsec - pRc->probeTime > pRateTable->probeInterval) &&
		    (pRc->hwMaxRetryPktCnt >= 1))
		{
			rate                  = nextRate;
			pRc->probeRate        = rate;
			pRc->probeTime        = nowMsec;
  90c9ba:	9a2d      	s32i.n	a10, a2, 52
			pRc->hwMaxRetryPktCnt = 0;
			*isProbing            = TRUE;
  90c9bc:	9490      	s32i.n	a4, a9, 0
{
	A_UINT8 i;

	for (i = 0; i < pRc->maxValidRate-1; i++) {
		if (pRc->validRateIndex[i] == curValidTxRate) {
			*pNextIndex = pRc->validRateIndex[i+1];
  90c9be:	055402        	or	a4, a5, a5
	 * Make sure rate is not higher than the allowed maximum.
	 * We should also enforce the min, but I suspect the min is
	 * normally 1 rather than 0 because of the rate 9 vs 6 issue
	 * in the old code.
	 */
	if (rate > (pRc->rateTableSize - 1)) {
  90c9c1:	25202e        	l8ui	a5, a2, 46
  90c9c4:	754204        	blt	a4, a5, 90c9cc <rcRateFind_11n+0xfc>
		rate = pRc->rateTableSize - 1;
  90c9c7:	b054      	addi.n	a4, a5, -1
  90c9c9:	040447        	extui	a4, a4, 0, 8
	}

	/* record selected rate, which is used to decide if we want to do fast frame */
	if (!(*isProbing) && pSib) {
  90c9cc:	2d1219        	l32i	a13, a1, 100
  90c9cf:	85d0      	l32i.n	a5, a13, 0
  90c9d1:	cd57      	bnez.n	a5, 90c9ec <rcRateFind_11n+0x11c>
		pSib->lastRateKbps = pRateTable->info[rate].rateKbps;
  90c9d3:	8614      	l32i.n	a6, a1, 16
  90c9d5:	04450a        	addx4	a5, a4, a4
  90c9d8:	045509        	addx2	a5, a5, a4
  90c9db:	06550a        	addx4	a5, a5, a6
		((struct atheros_softc*)sc->sc_rc)->currentTxRateKbps = pSib->lastRateKbps;
  90c9de:	8817      	l32i.n	a8, a1, 28
		rate = pRc->rateTableSize - 1;
	}

	/* record selected rate, which is used to decide if we want to do fast frame */
	if (!(*isProbing) && pSib) {
		pSib->lastRateKbps = pRateTable->info[rate].rateKbps;
  90c9e0:	8655      	l32i.n	a6, a5, 20
		((struct atheros_softc*)sc->sc_rc)->currentTxRateKbps = pSib->lastRateKbps;
  90c9e2:	258248        	l32i	a5, a8, 0x120
		rate = pRc->rateTableSize - 1;
	}

	/* record selected rate, which is used to decide if we want to do fast frame */
	if (!(*isProbing) && pSib) {
		pSib->lastRateKbps = pRateTable->info[rate].rateKbps;
  90c9e5:	26261c        	s32i	a6, a2, 112
		((struct atheros_softc*)sc->sc_rc)->currentTxRateKbps = pSib->lastRateKbps;
  90c9e8:	9654      	s32i.n	a6, a5, 16
		((struct atheros_softc*)sc->sc_rc)->currentTxRateIndex = rate;
  90c9ea:	9455      	s32i.n	a4, a5, 20

	rix = rcRateFind_ht(sc, asn, pRateTable, (rcflag & ATH_RC_PROBE_ALLOWED) ? 1 : 0, 
			    isProbe);
	nrix = rix;

	if ((rcflag & ATH_RC_PROBE_ALLOWED) && (*isProbe)) {
  90c9ec:	8916      	l32i.n	a9, a1, 24
  90c9ee:	649050        	beqz	a9, 90ca42 <rcRateFind_11n+0x172>
  90c9f1:	2d1219        	l32i	a13, a1, 100

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
		    int numTries, int numRates, int stepDnInc,
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
	A_UINT8 i = 0; 
  90c9f4:	c0e0      	movi.n	a14, 0

	rix = rcRateFind_ht(sc, asn, pRateTable, (rcflag & ATH_RC_PROBE_ALLOWED) ? 1 : 0, 
			    isProbe);
	nrix = rix;

	if ((rcflag & ATH_RC_PROBE_ALLOWED) && (*isProbe)) {
  90c9f6:	85d0      	l32i.n	a5, a13, 0
  90c9f8:	d640      	mov.n	a6, a4
  90c9fa:	7e5148        	beq	a5, a14, 90ca46 <rcRateFind_11n+0x176>
		/* set one try for probe rates. For the probes don't enable rts */
		rcRateSetseries(pRateTable, &series[i++], 1, nrix,
				FALSE, asc->tx_chainmask, asn->stbc);
  90c9fd:	25221d        	l32i	a5, a2, 116
			    isProbe);
	nrix = rix;

	if ((rcflag & ATH_RC_PROBE_ALLOWED) && (*isProbe)) {
		/* set one try for probe rates. For the probes don't enable rts */
		rcRateSetseries(pRateTable, &series[i++], 1, nrix,
  90ca00:	8a14      	l32i.n	a10, a1, 16
  90ca02:	05d551        	extui	a5, a5, 29, 2
  90ca05:	9510      	s32i.n	a5, a1, 0
  90ca07:	8518      	l32i.n	a5, a1, 32
  90ca09:	db30      	mov.n	a11, a3
  90ca0b:	8f53      	l32i.n	a15, a5, 12
  90ca0d:	c0c1      	movi.n	a12, 1
  90ca0f:	dd40      	mov.n	a13, a4
  90ca11:	5bfdf1        	call8	90c1d8 <rcRateSetseries>
               const RATE_TABLE_11N *pRateTable , 
               A_UINT8 rix, A_UINT16 stepDown, A_UINT16 minRate)
{
	A_UINT32                j;
	A_UINT8                 nextIndex;
	struct atheros_node     *pSib = ATH_NODE_ATHEROS(an);
  90ca14:	881a      	l32i.n	a8, a1, 40
rcGetNextLowerValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc,  
                          A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_INT8 i;

	for (i = 1; i < pRc->maxValidRate ; i++) {
  90ca16:	c051      	movi.n	a5, 1
               const RATE_TABLE_11N *pRateTable , 
               A_UINT8 rix, A_UINT16 stepDown, A_UINT16 minRate)
{
	A_UINT32                j;
	A_UINT8                 nextIndex;
	struct atheros_node     *pSib = ATH_NODE_ATHEROS(an);
  90ca18:	268282        	l32i	a6, a8, 0x208
rcGetNextLowerValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc,  
                          A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_INT8 i;

	for (i = 1; i < pRc->maxValidRate ; i++) {
  90ca1b:	286039        	l8ui	a8, a6, 57
  90ca1e:	d760      	mov.n	a7, a6
  90ca20:	600012        	j	90ca36 <rcRateFind_11n+0x166>
  90ca23:	002a70        	excw
		if (pRc->validRateIndex[i] == curValidTxRate) {
  90ca26:	3bb155        	excw
  90ca29:	b177      	addi.n	a7, a7, 1
  90ca2b:	74a907        	bne	a10, a4, 90ca36 <rcRateFind_11n+0x166>
			*pNextIndex = pRc->validRateIndex[i-1];
  90ca2e:	a966      	add.n	a6, a6, a9
  90ca30:	266039        	l8ui	a6, a6, 57
  90ca33:	600006        	j	90ca3d <rcRateFind_11n+0x16d>
rcGetNextLowerValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc,  
                          A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_INT8 i;

	for (i = 1; i < pRc->maxValidRate ; i++) {
  90ca36:	d950      	mov.n	a9, a5
  90ca38:	7852e8        	blt	a5, a8, 90ca24 <rcRateFind_11n+0x154>
  90ca3b:	d640      	mov.n	a6, a4
			    isProbe);
	nrix = rix;

	if ((rcflag & ATH_RC_PROBE_ALLOWED) && (*isProbe)) {
		/* set one try for probe rates. For the probes don't enable rts */
		rcRateSetseries(pRateTable, &series[i++], 1, nrix,
  90ca3d:	c0e1      	movi.n	a14, 1
  90ca3f:	600003        	j	90ca46 <rcRateFind_11n+0x176>

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
		    int numTries, int numRates, int stepDnInc,
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
	A_UINT8 i = 0; 
  90ca42:	8e16      	l32i.n	a14, a1, 24

	rix = rcRateFind_ht(sc, asn, pRateTable, (rcflag & ATH_RC_PROBE_ALLOWED) ? 1 : 0, 
			    isProbe);
	nrix = rix;

	if ((rcflag & ATH_RC_PROBE_ALLOWED) && (*isProbe)) {
  90ca44:	d640      	mov.n	a6, a4
		 * after the probe rate
		 */
		nrix = rcRateGetIndex( sc, an, pRateTable, nrix, 1, FALSE);
	}

	tryPerRate = (numTries/numRates);
  90ca46:	8b1b      	l32i.n	a11, a1, 44
  90ca48:	2a1209        	l32i	a10, a1, 36
  90ca4b:	9e1e      	s32i.n	a14, a1, 56
  90ca4d:	5b67d2        	call8	8e6998 <__divsi3>

	/* Set the choosen rate. No RTS for first series entry. */
	rcRateSetseries(pRateTable, &series[i++], tryPerRate,
  90ca50:	8e1e      	l32i.n	a14, a1, 56
		 * after the probe rate
		 */
		nrix = rcRateGetIndex( sc, an, pRateTable, nrix, 1, FALSE);
	}

	tryPerRate = (numTries/numRates);
  90ca52:	0a0947        	extui	a9, a10, 0, 8
  90ca55:	9916      	s32i.n	a9, a1, 24

	/* Set the choosen rate. No RTS for first series entry. */
	rcRateSetseries(pRateTable, &series[i++], tryPerRate,
  90ca57:	0fe811        	slli	a8, a14, 1
  90ca5a:	ae8b      	add.n	a11, a8, a14
			nrix, FALSE, asc->tx_chainmask, asn->stbc);
  90ca5c:	28221d        	l32i	a8, a2, 116
		 * after the probe rate
		 */
		nrix = rcRateGetIndex( sc, an, pRateTable, nrix, 1, FALSE);
	}

	tryPerRate = (numTries/numRates);
  90ca5f:	d7a0      	mov.n	a7, a10

	/* Set the choosen rate. No RTS for first series entry. */
	rcRateSetseries(pRateTable, &series[i++], tryPerRate,
  90ca61:	08d851        	extui	a8, a8, 29, 2
  90ca64:	9810      	s32i.n	a8, a1, 0
  90ca66:	8818      	l32i.n	a8, a1, 32
  90ca68:	8a14      	l32i.n	a10, a1, 16
  90ca6a:	8f83      	l32i.n	a15, a8, 12
  90ca6c:	b1e5      	addi.n	a5, a14, 1
  90ca6e:	dc90      	mov.n	a12, a9
  90ca70:	03bb0a        	addx4	a11, a11, a3
  90ca73:	066d02        	or	a13, a6, a6
  90ca76:	2e0a00        	movi	a14, 0
  90ca79:	5bfdd7        	call8	90c1d8 <rcRateSetseries>
  90ca7c:	050547        	extui	a5, a5, 0, 8
  90ca7f:	8919      	l32i.n	a9, a1, 36
	}

	return rix;
}

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
  90ca81:	07571c        	mul16u	a7, a5, a7
  90ca84:	07970c        	sub	a7, a9, a7
	for (; i < numRates; i++) {
		A_UINT8 tryNum;
		A_UINT8 minRate;

		tryNum  = ((i + 1) == numRates) ? numTries - (tryPerRate * i) : tryPerRate ;
		minRate = (((i + 1) == numRates) && (rcflag & ATH_RC_MINRATE_LASTRATE)) ? 1 : 0;
  90ca87:	891c      	l32i.n	a9, a1, 48
  90ca89:	070847        	extui	a8, a7, 0, 8
  90ca8c:	c072      	movi.n	a7, 2
  90ca8e:	079901        	and	a9, a9, a7
  90ca91:	9815      	s32i.n	a8, a1, 20
  90ca93:	9919      	s32i.n	a9, a1, 36
	/* Set the choosen rate. No RTS for first series entry. */
	rcRateSetseries(pRateTable, &series[i++], tryPerRate,
			nrix, FALSE, asc->tx_chainmask, asn->stbc);

	/* Fill in the other rates for multirate retry */
	for (; i < numRates; i++) {
  90ca95:	6000a4        	j	90cb3d <rcRateFind_11n+0x26d>
		A_UINT8 tryNum;
		A_UINT8 minRate;

		tryNum  = ((i + 1) == numRates) ? numTries - (tryPerRate * i) : tryPerRate ;
  90ca98:	891b      	l32i.n	a9, a1, 44
  90ca9a:	b157      	addi.n	a7, a5, 1
  90ca9c:	8c16      	l32i.n	a12, a1, 24
		minRate = (((i + 1) == numRates) && (rcflag & ATH_RC_MINRATE_LASTRATE)) ? 1 : 0;
  90ca9e:	c080      	movi.n	a8, 0
	/* Fill in the other rates for multirate retry */
	for (; i < numRates; i++) {
		A_UINT8 tryNum;
		A_UINT8 minRate;

		tryNum  = ((i + 1) == numRates) ? numTries - (tryPerRate * i) : tryPerRate ;
  90caa0:	79790a        	bne	a7, a9, 90caae <rcRateFind_11n+0x1de>
		minRate = (((i + 1) == numRates) && (rcflag & ATH_RC_MINRATE_LASTRATE)) ? 1 : 0;
  90caa3:	8919      	l32i.n	a9, a1, 36
  90caa5:	c081      	movi.n	a8, 1
  90caa7:	c0a0      	movi.n	a10, 0
  90caa9:	8c15      	l32i.n	a12, a1, 20
  90caab:	09a838        	moveqz	a8, a10, a9
               const RATE_TABLE_11N *pRateTable , 
               A_UINT8 rix, A_UINT16 stepDown, A_UINT16 minRate)
{
	A_UINT32                j;
	A_UINT8                 nextIndex;
	struct atheros_node     *pSib = ATH_NODE_ATHEROS(an);
  90caae:	891a      	l32i.n	a9, a1, 40
  90cab0:	279282        	l32i	a7, a9, 0x208
	TX_RATE_CTRL            *pRc = (TX_RATE_CTRL *)(pSib);
    
	if (minRate) {
  90cab3:	ca89      	beqz.n	a8, 90cae0 <rcRateFind_11n+0x210>
rcGetNextLowerValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc,  
                          A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_INT8 i;

	for (i = 1; i < pRc->maxValidRate ; i++) {
  90cab5:	2b7039        	l8ui	a11, a7, 57
  90cab8:	c490      	movi.n	a9, 64
  90caba:	da70      	mov.n	a10, a7
  90cabc:	c081      	movi.n	a8, 1
  90cabe:	600016        	j	90cad8 <rcRateFind_11n+0x208>
		if (pRc->validRateIndex[i] == curValidTxRate) {
  90cac1:	2ea03b        	l8ui	a14, a10, 59
  90cac4:	b188      	addi.n	a8, a8, 1
  90cac6:	b1aa      	addi.n	a10, a10, 1
  90cac8:	76e90c        	bne	a14, a6, 90cad8 <rcRateFind_11n+0x208>
			*pNextIndex = pRc->validRateIndex[i-1];
  90cacb:	ad7d      	add.n	a13, a7, a13
  90cacd:	b099      	addi.n	a9, a9, -1
  90cacf:	26d039        	l8ui	a6, a13, 57
	A_UINT8                 nextIndex;
	struct atheros_node     *pSib = ATH_NODE_ATHEROS(an);
	TX_RATE_CTRL            *pRc = (TX_RATE_CTRL *)(pSib);
    
	if (minRate) {
		for (j = RATE_TABLE_11N_SIZE; j > 0; j-- ) {
  90cad2:	659fe4        	bnez	a9, 90caba <rcRateFind_11n+0x1ea>
  90cad5:	600038        	j	90cb11 <rcRateFind_11n+0x241>
rcGetNextLowerValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc,  
                          A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_INT8 i;

	for (i = 1; i < pRc->maxValidRate ; i++) {
  90cad8:	dd80      	mov.n	a13, a8
  90cada:	7b82e3        	blt	a8, a11, 90cac1 <rcRateFind_11n+0x1f1>
  90cadd:	600030        	j	90cb11 <rcRateFind_11n+0x241>
		A_UINT8 minRate;

		tryNum  = ((i + 1) == numRates) ? numTries - (tryPerRate * i) : tryPerRate ;
		minRate = (((i + 1) == numRates) && (rcflag & ATH_RC_MINRATE_LASTRATE)) ? 1 : 0;

		nrix = rcRateGetIndex(sc, an, pRateTable, nrix, stepDnInc, minRate);
  90cae0:	881d      	l32i.n	a8, a1, 52
  90cae2:	080a4f        	extui	a10, a8, 0, 16
  90cae5:	60001c        	j	90cb05 <rcRateFind_11n+0x235>
                          A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_INT8 i;

	for (i = 1; i < pRc->maxValidRate ; i++) {
		if (pRc->validRateIndex[i] == curValidTxRate) {
  90cae8:	2e903b        	l8ui	a14, a9, 59
  90caeb:	b188      	addi.n	a8, a8, 1
  90caed:	b199      	addi.n	a9, a9, 1
  90caef:	76e909        	bne	a14, a6, 90cafc <rcRateFind_11n+0x22c>
			*pNextIndex = pRc->validRateIndex[i-1];
  90caf2:	ad7d      	add.n	a13, a7, a13
  90caf4:	26d039        	l8ui	a6, a13, 57
			} else {
				break;
			}
		}
	} else {
		for (j = stepDown; j > 0; j-- ) {
  90caf7:	b0aa      	addi.n	a10, a10, -1
  90caf9:	600008        	j	90cb05 <rcRateFind_11n+0x235>
rcGetNextLowerValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc,  
                          A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_INT8 i;

	for (i = 1; i < pRc->maxValidRate ; i++) {
  90cafc:	dd80      	mov.n	a13, a8
  90cafe:	7b82e6        	blt	a8, a11, 90cae8 <rcRateFind_11n+0x218>
  90cb01:	60000c        	j	90cb11 <rcRateFind_11n+0x241>
  90cb04:	00c8a8        	excw
  90cb07:	2b7039        	l8ui	a11, a7, 57
  90cb0a:	d970      	mov.n	a9, a7
  90cb0c:	c081      	movi.n	a8, 1
  90cb0e:	63ffea        	j	90cafc <rcRateFind_11n+0x22c>

		nrix = rcRateGetIndex(sc, an, pRateTable, nrix, stepDnInc, minRate);

		/* All other rates in the series have RTS enabled */
		rcRateSetseries(pRateTable, &series[i], tryNum,
				nrix, TRUE, asc->tx_chainmask, asn->stbc);
  90cb11:	27221d        	l32i	a7, a2, 116
		minRate = (((i + 1) == numRates) && (rcflag & ATH_RC_MINRATE_LASTRATE)) ? 1 : 0;

		nrix = rcRateGetIndex(sc, an, pRateTable, nrix, stepDnInc, minRate);

		/* All other rates in the series have RTS enabled */
		rcRateSetseries(pRateTable, &series[i], tryNum,
  90cb14:	8918      	l32i.n	a9, a1, 32
  90cb16:	07d751        	extui	a7, a7, 29, 2
  90cb19:	9710      	s32i.n	a7, a1, 0
  90cb1b:	055b09        	addx2	a11, a5, a5
  90cb1e:	8f93      	l32i.n	a15, a9, 12
  90cb20:	8a14      	l32i.n	a10, a1, 16
  90cb22:	03bb0a        	addx4	a11, a11, a3
  90cb25:	dd60      	mov.n	a13, a6
  90cb27:	c0e1      	movi.n	a14, 1
  90cb29:	5bfdab        	call8	90c1d8 <rcRateSetseries>
  90cb2c:	8815      	l32i.n	a8, a1, 20
  90cb2e:	8916      	l32i.n	a9, a1, 24
	/* Set the choosen rate. No RTS for first series entry. */
	rcRateSetseries(pRateTable, &series[i++], tryPerRate,
			nrix, FALSE, asc->tx_chainmask, asn->stbc);

	/* Fill in the other rates for multirate retry */
	for (; i < numRates; i++) {
  90cb30:	b155      	addi.n	a5, a5, 1
  90cb32:	09870c        	sub	a7, a8, a9
  90cb35:	070847        	extui	a8, a7, 0, 8
  90cb38:	050547        	extui	a5, a5, 0, 8
  90cb3b:	9815      	s32i.n	a8, a1, 20
  90cb3d:	891b      	l32i.n	a9, a1, 44
  90cb3f:	795a02        	bge	a5, a9, 90cb45 <rcRateFind_11n+0x275>
  90cb42:	63ff52        	j	90ca98 <rcRateFind_11n+0x1c8>
	 *    {MCS2, MCS1, MCS0, MCS0}.
	 * When first rate in series is MCS3 in HT20 @ 2.4GHz, series should look like:
	 *    {MCS3, MCS2, MCS1, MCS1}
	 * So, set fourth rate in series to be same as third one for above conditions.
	 */
	if (sc->sc_curmode == IEEE80211_MODE_11NG) {
  90cb45:	8817      	l32i.n	a8, a1, 28
  90cb47:	2282c2        	l32i	a2, a8, 0x308
  90cb4a:	69215a        	bnei	a2, 1, 90cba8 <rcRateFind_11n+0x2d8>
		dot11Rate = pRateTable->info[rix].dot11Rate;
  90cb4d:	04470a        	addx4	a7, a4, a4
  90cb50:	8914      	l32i.n	a9, a1, 16
  90cb52:	047709        	addx2	a7, a7, a4
  90cb55:	09770a        	addx4	a7, a7, a9
  90cb58:	26701e        	l8ui	a6, a7, 30
		phy = pRateTable->info[rix].phy;
  90cb5b:	277010        	l8ui	a7, a7, 16
		if (i == 4 &&
  90cb5e:	695446        	bnei	a5, 4, 90cba8 <rcRateFind_11n+0x2d8>
		    ((dot11Rate == 2 && phy == WLAN_RC_PHY_HT_40_SS) || 
  90cb61:	c050      	movi.n	a5, 0
  90cb63:	287cfa        	addi	a8, a7, -6
  90cb66:	da50      	mov.n	a10, a5
  90cb68:	082a38        	moveqz	a10, a2, a8
	 * So, set fourth rate in series to be same as third one for above conditions.
	 */
	if (sc->sc_curmode == IEEE80211_MODE_11NG) {
		dot11Rate = pRateTable->info[rix].dot11Rate;
		phy = pRateTable->info[rix].phy;
		if (i == 4 &&
  90cb6b:	0a0847        	extui	a8, a10, 0, 8
  90cb6e:	75810b        	beq	a8, a5, 90cb7d <rcRateFind_11n+0x2ad>
		    ((dot11Rate == 2 && phy == WLAN_RC_PHY_HT_40_SS) || 
  90cb71:	286cfe        	addi	a8, a6, -2
  90cb74:	085239        	movnez	a2, a5, a8
	 * So, set fourth rate in series to be same as third one for above conditions.
	 */
	if (sc->sc_curmode == IEEE80211_MODE_11NG) {
		dot11Rate = pRateTable->info[rix].dot11Rate;
		phy = pRateTable->info[rix].phy;
		if (i == 4 &&
  90cb77:	020247        	extui	a2, a2, 0, 8
  90cb7a:	75291a        	bne	a2, a5, 90cb98 <rcRateFind_11n+0x2c8>
		    ((dot11Rate == 2 && phy == WLAN_RC_PHY_HT_40_SS) || 
		     (dot11Rate == 3 && phy == WLAN_RC_PHY_HT_20_SS))) 
  90cb7d:	c020      	movi.n	a2, 0
  90cb7f:	277cfc        	addi	a7, a7, -4
  90cb82:	c051      	movi.n	a5, 1
  90cb84:	dd20      	mov.n	a13, a2
  90cb86:	075d38        	moveqz	a13, a5, a7
  90cb89:	0dd702        	or	a7, a13, a13
	 */
	if (sc->sc_curmode == IEEE80211_MODE_11NG) {
		dot11Rate = pRateTable->info[rix].dot11Rate;
		phy = pRateTable->info[rix].phy;
		if (i == 4 &&
		    ((dot11Rate == 2 && phy == WLAN_RC_PHY_HT_40_SS) || 
  90cb8c:	72d118        	beq	a13, a2, 90cba8 <rcRateFind_11n+0x2d8>
		     (dot11Rate == 3 && phy == WLAN_RC_PHY_HT_20_SS))) 
  90cb8f:	266cfd        	addi	a6, a6, -3
  90cb92:	065238        	moveqz	a2, a5, a6
	 */
	if (sc->sc_curmode == IEEE80211_MODE_11NG) {
		dot11Rate = pRateTable->info[rix].dot11Rate;
		phy = pRateTable->info[rix].phy;
		if (i == 4 &&
		    ((dot11Rate == 2 && phy == WLAN_RC_PHY_HT_40_SS) || 
  90cb95:	64200f        	beqz	a2, 90cba8 <rcRateFind_11n+0x2d8>
		     (dot11Rate == 3 && phy == WLAN_RC_PHY_HT_20_SS))) 
		{
			series[3].rix = series[2].rix;
  90cb98:	223018        	l8ui	a2, a3, 24
  90cb9b:	223424        	s8i	a2, a3, 36
			series[3].flags = series[2].flags;
  90cb9e:	22301b        	l8ui	a2, a3, 27
  90cba1:	223427        	s8i	a2, a3, 39
			series[3].max4msframelen = series[2].max4msframelen;
  90cba4:	8237      	l32i.n	a2, a3, 28
  90cba6:	923a      	s32i.n	a2, a3, 40
	/*
	 * 2009/02/06
	 * AP91 Kite: NetGear OTA location-4 downlink.
	 *            Enable RTS/CTS at MCS 3-0 for downlink throughput.
	 */
	if (sc->sc_curmode == IEEE80211_MODE_11NG) {
  90cba8:	8817      	l32i.n	a8, a1, 28
  90cbaa:	2282c2        	l32i	a2, a8, 0x308
  90cbad:	69211b        	bnei	a2, 1, 90cbcc <rcRateFind_11n+0x2fc>
		dot11Rate = pRateTable->info[rix].dot11Rate;
  90cbb0:	04420a        	addx4	a2, a4, a4
  90cbb3:	8914      	l32i.n	a9, a1, 16
  90cbb5:	042409        	addx2	a4, a2, a4
  90cbb8:	09440a        	addx4	a4, a4, a9
		if (dot11Rate <= 3 ) {
  90cbbb:	22401e        	l8ui	a2, a4, 30
  90cbbe:	6f240a        	bgeui	a2, 4, 90cbcc <rcRateFind_11n+0x2fc>
			series[0].flags |= ATH_RC_RTSCTS_FLAG;         
  90cbc1:	243003        	l8ui	a4, a3, 3
  90cbc4:	c120      	movi.n	a2, 16
  90cbc6:	024202        	or	a2, a4, a2
  90cbc9:	223403        	s8i	a2, a3, 3
  90cbcc:	d10f      	retw.n
	...

0090cbd0 <rcUpdate_11n>:
void rcUpdate_11n(struct ath_softc_tgt *sc, struct ath_node_target *an,
		  A_UINT8 curTxAnt, 
		  int finalTSIdx, int Xretries,
		  struct ath_rc_series rcs[], int nFrames, 
		  int nBad, int long_retry)
{
  90cbd0:	6c1008        	entry	a1, 64
  90cbd3:	d920      	mov.n	a9, a2
	A_UINT32 series = 0;
	A_UINT32 rix;
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  90cbd5:	2492c2        	l32i	a4, a9, 0x308
  90cbd8:	222248        	l32i	a2, a2, 0x120
void rcUpdate_11n(struct ath_softc_tgt *sc, struct ath_node_target *an,
		  A_UINT8 curTxAnt, 
		  int finalTSIdx, int Xretries,
		  struct ath_rc_series rcs[], int nFrames, 
		  int nBad, int long_retry)
{
  90cbdb:	d870      	mov.n	a8, a7
	A_UINT32 series = 0;
	A_UINT32 rix;
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  90cbdd:	02420a        	addx4	a2, a4, a2
  90cbe0:	8421      	l32i.n	a4, a2, 4
	struct atheros_node *pSib = ATH_NODE_ATHEROS(an);
  90cbe2:	223282        	l32i	a2, a3, 0x208
  90cbe5:	9215      	s32i.n	a2, a1, 20

	/*
	 * If the first rate is not the final index, there are intermediate rate failures
	 * to be processed.
	 */
	if (finalTSIdx != 0) {
  90cbe7:	6450aa        	beqz	a5, 90cc95 <rcUpdate_11n+0xc5>
				} else {
					rix = pRateTable->info[rcs[series].rix].baseIndex;
				}

				/* FIXME:XXXX, too many args! */
				rcUpdate_ht(sc, an, rix, Xretries? 1 : 2, rcs[series].tries, 
  90cbea:	c0a1      	movi.n	a10, 1
  90cbec:	9a14      	s32i.n	a10, a1, 16
  90cbee:	8b14      	l32i.n	a11, a1, 16
  90cbf0:	c0a2      	movi.n	a10, 2
  90cbf2:	06ab38        	moveqz	a11, a10, a6

	/*
	 * If the first rate is not the final index, there are intermediate rate failures
	 * to be processed.
	 */
	if (finalTSIdx != 0) {
  90cbf5:	c020      	movi.n	a2, 0
				} else {
					rix = pRateTable->info[rcs[series].rix].baseIndex;
				}

				/* FIXME:XXXX, too many args! */
				rcUpdate_ht(sc, an, rix, Xretries? 1 : 2, rcs[series].tries, 
  90cbf7:	9b14      	s32i.n	a11, a1, 16
  90cbf9:	60008c        	j	90cc89 <rcUpdate_11n+0xb9>
  90cbfc:	002e70        	excw
	 */
	if (finalTSIdx != 0) {

		/* Process intermediate rates that failed.*/
		for (series = 0; series < finalTSIdx ; series++) {
			if (rcs[series].tries != 0) {
  90cbff:	0164e0        	excw
  90cc02:	812b      	l32i.n	a1, a2, 44
				flags = rcs[series].flags;
  90cc04:	7003c0        	bltu	a0, a0, 90cbc8 <rcRateFind_11n+0x2f8>
				/* If HT40 and we have switched mode from 40 to 20 => don't update */
				if ((flags & ATH_RC_CW40_FLAG) && 
  90cc07:	c20c      	movi.n	a0, 44
  90cc09:	ba01      	addi.n	a1, a0, 10
  90cc0b:	c8a9      	beqz.n	a10, 90cc18 <rcUpdate_11n+0x48>
				    (pRc->rcPhyMode != (flags & ATH_RC_CW40_FLAG))) {
  90cc0d:	8d15      	l32i.n	a13, a1, 20
  90cc0f:	2cd06c        	l8ui	a12, a13, 108
		/* Process intermediate rates that failed.*/
		for (series = 0; series < finalTSIdx ; series++) {
			if (rcs[series].tries != 0) {
				flags = rcs[series].flags;
				/* If HT40 and we have switched mode from 40 to 20 => don't update */
				if ((flags & ATH_RC_CW40_FLAG) && 
  90cc12:	7ac102        	beq	a12, a10, 90cc18 <rcUpdate_11n+0x48>
  90cc15:	60010d        	j	90cd26 <rcUpdate_11n+0x156>
				    (pRc->rcPhyMode != (flags & ATH_RC_CW40_FLAG))) {
					return;
				}
				if ((flags & ATH_RC_CW40_FLAG) && (flags & ATH_RC_HT40_SGI_FLAG)) {
  90cc18:	c0c6      	movi.n	a12, 6
  90cc1a:	0cbc01        	and	a12, a11, a12
  90cc1d:	69c613        	bnei	a12, 6, 90cc34 <rcUpdate_11n+0x64>
					rix = pRateTable->info[rcs[series].rix].htIndex;
  90cc20:	2a7000        	l8ui	a10, a7, 0
  90cc23:	0aab0a        	addx4	a11, a10, a10
  90cc26:	0aba09        	addx2	a10, a11, a10
  90cc29:	04aa0a        	addx4	a10, a10, a4
  90cc2c:	2ca025        	l8ui	a12, a10, 37
  90cc2f:	600039        	j	90cc6c <rcUpdate_11n+0x9c>
  90cc32:	00007d        	excw
				} else if (flags & ATH_RC_HT40_SGI_FLAG) {
  90cc35:	b711      	addi.n	a1, a1, 7
					rix = pRateTable->info[rcs[series].rix].sgiIndex;
  90cc37:	2a7000        	l8ui	a10, a7, 0
  90cc3a:	0aab0a        	addx4	a11, a10, a10
  90cc3d:	0aba09        	addx2	a10, a11, a10
  90cc40:	04aa0a        	addx4	a10, a10, a4
  90cc43:	2ca024        	l8ui	a12, a10, 36
  90cc46:	600022        	j	90cc6c <rcUpdate_11n+0x9c>
				} else if (flags & ATH_RC_CW40_FLAG) {
  90cc49:	c9a0      	beqz.n	a10, 90cc5d <rcUpdate_11n+0x8d>
					rix = pRateTable->info[rcs[series].rix].cw40Index;
  90cc4b:	2a7000        	l8ui	a10, a7, 0
  90cc4e:	0aab0a        	addx4	a11, a10, a10
  90cc51:	0aba09        	addx2	a10, a11, a10
  90cc54:	04aa0a        	addx4	a10, a10, a4
  90cc57:	2ca023        	l8ui	a12, a10, 35
  90cc5a:	60000e        	j	90cc6c <rcUpdate_11n+0x9c>
				} else {
					rix = pRateTable->info[rcs[series].rix].baseIndex;
  90cc5d:	2a7000        	l8ui	a10, a7, 0
  90cc60:	0aab0a        	addx4	a11, a10, a10
  90cc63:	0aba09        	addx2	a10, a11, a10
  90cc66:	04aa0a        	addx4	a10, a10, a4
  90cc69:	2ca022        	l8ui	a12, a10, 34
				}

				/* FIXME:XXXX, too many args! */
				rcUpdate_ht(sc, an, rix, Xretries? 1 : 2, rcs[series].tries, 
  90cc6c:	2a1210        	l32i	a10, a1, 64
  90cc6f:	8d14      	l32i.n	a13, a1, 16
  90cc71:	0a0f4f        	extui	a15, a10, 0, 16
  90cc74:	9f10      	s32i.n	a15, a1, 0
  90cc76:	da90      	mov.n	a10, a9
  90cc78:	db30      	mov.n	a11, a3
  90cc7a:	9817      	s32i.n	a8, a1, 28
  90cc7c:	9916      	s32i.n	a9, a1, 24
  90cc7e:	5bfda3        	call8	90c30c <rcUpdate_ht$isra$4>
  90cc81:	8916      	l32i.n	a9, a1, 24
  90cc83:	8817      	l32i.n	a8, a1, 28
	 * to be processed.
	 */
	if (finalTSIdx != 0) {

		/* Process intermediate rates that failed.*/
		for (series = 0; series < finalTSIdx ; series++) {
  90cc85:	b122      	addi.n	a2, a2, 1
  90cc87:	bc77      	addi.n	a7, a7, 12
  90cc89:	752b02        	bgeu	a2, a5, 90cc8f <rcUpdate_11n+0xbf>
  90cc8c:	63ff6d        	j	90cbfd <rcUpdate_11n+0x2d>
  90cc8f:	600011        	j	90cca4 <rcUpdate_11n+0xd4>
  90cc92:	000000        	ill
		/*
		 * Handle the special case of MIMO PS burst, where the second aggregate is sent
		 *  out with only one rate and one try. Treating it as an excessive retry penalizes
		 * the rate inordinately.
		 */
		if (rcs[0].tries == 1 && Xretries == 1) {
  90cc95:	277001        	l8ui	a7, a7, 1
		  A_UINT8 curTxAnt, 
		  int finalTSIdx, int Xretries,
		  struct ath_rc_series rcs[], int nFrames, 
		  int nBad, int long_retry)
{
	A_UINT32 series = 0;
  90cc98:	d250      	mov.n	a2, a5
		/*
		 * Handle the special case of MIMO PS burst, where the second aggregate is sent
		 *  out with only one rate and one try. Treating it as an excessive retry penalizes
		 * the rate inordinately.
		 */
		if (rcs[0].tries == 1 && Xretries == 1) {
  90cc9a:	697106        	bnei	a7, 1, 90cca4 <rcUpdate_11n+0xd4>
			Xretries = 2;
  90cc9d:	b067      	addi.n	a7, a6, -1
  90cc9f:	c052      	movi.n	a5, 2
  90cca1:	075638        	moveqz	a6, a5, a7
		}
	}

	flags = rcs[series].flags;
  90cca4:	022209        	addx2	a2, a2, a2
  90cca7:	08280a        	addx4	a8, a2, a8
  90ccaa:	278003        	l8ui	a7, a8, 3
	/* If HT40 and we have switched mode from 40 to 20 => don't update */
	if ((flags & ATH_RC_CW40_FLAG) && 
  90ccad:	c052      	movi.n	a5, 2
  90ccaf:	057501        	and	a5, a7, a5
  90ccb2:	c856      	beqz.n	a5, 90ccbc <rcUpdate_11n+0xec>
	    (pRc->rcPhyMode != (flags & ATH_RC_CW40_FLAG))) {
  90ccb4:	8b15      	l32i.n	a11, a1, 20
  90ccb6:	22b06c        	l8ui	a2, a11, 108
		}
	}

	flags = rcs[series].flags;
	/* If HT40 and we have switched mode from 40 to 20 => don't update */
	if ((flags & ATH_RC_CW40_FLAG) && 
  90ccb9:	752969        	bne	a2, a5, 90cd26 <rcUpdate_11n+0x156>
	    (pRc->rcPhyMode != (flags & ATH_RC_CW40_FLAG))) {
		return;
	}
	if ((flags & ATH_RC_CW40_FLAG) && (flags & ATH_RC_HT40_SGI_FLAG)) {
  90ccbc:	c026      	movi.n	a2, 6
  90ccbe:	027201        	and	a2, a7, a2
  90ccc1:	692613        	bnei	a2, 6, 90ccd8 <rcUpdate_11n+0x108>
		rix = pRateTable->info[rcs[series].rix].htIndex;
  90ccc4:	228000        	l8ui	a2, a8, 0
  90ccc7:	02250a        	addx4	a5, a2, a2
  90ccca:	025209        	addx2	a2, a5, a2
  90cccd:	04240a        	addx4	a4, a2, a4
  90ccd0:	2c4025        	l8ui	a12, a4, 37
  90ccd3:	600035        	j	90cd0c <rcUpdate_11n+0x13c>
  90ccd6:	000022        	excw
  90ccd9:	8000      	l32i.n	a0, a0, 0
	} else if (flags & ATH_RC_HT40_SGI_FLAG) {
  90ccdb:	7d770e        	bbci	a7, 29, 90cced <rcUpdate_11n+0x11d>
		rix = pRateTable->info[rcs[series].rix].sgiIndex;
  90ccde:	02250a        	addx4	a5, a2, a2
  90cce1:	025209        	addx2	a2, a5, a2
  90cce4:	04240a        	addx4	a4, a2, a4
  90cce7:	2c4024        	l8ui	a12, a4, 36
  90ccea:	60001e        	j	90cd0c <rcUpdate_11n+0x13c>
	} else if (flags & ATH_RC_CW40_FLAG) {
  90cced:	c85f      	beqz.n	a5, 90cd00 <rcUpdate_11n+0x130>
		rix = pRateTable->info[rcs[series].rix].cw40Index;
  90ccef:	02250a        	addx4	a5, a2, a2
  90ccf2:	025209        	addx2	a2, a5, a2
  90ccf5:	04240a        	addx4	a4, a2, a4
  90ccf8:	2c4023        	l8ui	a12, a4, 35
  90ccfb:	60000d        	j	90cd0c <rcUpdate_11n+0x13c>
  90ccfe:	000002        	or	a0, a0, a0
	} else {
		rix = pRateTable->info[rcs[series].rix].baseIndex;
  90cd01:	250a02        	movi	a5, 2
  90cd04:	520904        	call0	88f118 <_bss_end+0x37c208>
  90cd07:	240a2c        	movi	a4, 44
  90cd0a:	402222        	excw
	}

	/* FIXME:XXXX, too many args! */
	rcUpdate_ht(sc, an, rix, Xretries, long_retry, curTxAnt, 
  90cd0d:	12112e        	l32r	a2, 8d11c8 <_bss_end+0x3be2b8>
  90cd10:	121202        	l32r	a2, 8d1518 <_bss_end+0x3be608>
  90cd13:	024f92        	excw
  90cd16:	102212        	l32r	a0, 8d5560 <_bss_end+0x3c2650>
  90cd19:	10da90        	l32r	a0, 90375c <memset+0x1c914>
  90cd1c:	db30      	mov.n	a11, a3
  90cd1e:	dd60      	mov.n	a13, a6
  90cd20:	020f4f        	extui	a15, a2, 0, 16
  90cd23:	5bfd7a        	call8	90c30c <rcUpdate_ht$isra$4>
  90cd26:	d10f      	retw.n

0090cd28 <ath_tx_status_update_rate>:

void ath_tx_status_update_rate(struct ath_softc_tgt *sc,
			       struct ath_rc_series rcs[],
			       int series,
			       WMI_TXSTATUS_EVENT *txs)
{
  90cd28:	6c1004        	entry	a1, 32
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];

	/* HT Rate */
	if (pRateTable->info[rcs[series].rix].rateCode & 0x80) {
  90cd2b:	044409        	addx2	a4, a4, a4
			       struct ath_rc_series rcs[],
			       int series,
			       WMI_TXSTATUS_EVENT *txs)
{
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  90cd2e:	282248        	l32i	a8, a2, 0x120

	/* HT Rate */
	if (pRateTable->info[rcs[series].rix].rateCode & 0x80) {
  90cd31:	03430a        	addx4	a3, a4, a3
			       struct ath_rc_series rcs[],
			       int series,
			       WMI_TXSTATUS_EVENT *txs)
{
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  90cd34:	2222c2        	l32i	a2, a2, 0x308

	/* HT Rate */
	if (pRateTable->info[rcs[series].rix].rateCode & 0x80) {
  90cd37:	293000        	l8ui	a9, a3, 0
			       struct ath_rc_series rcs[],
			       int series,
			       WMI_TXSTATUS_EVENT *txs)
{
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  90cd3a:	08220a        	addx4	a2, a2, a8
  90cd3d:	8821      	l32i.n	a8, a2, 4

	/* HT Rate */
	if (pRateTable->info[rcs[series].rix].rateCode & 0x80) {
  90cd3f:	09920a        	addx4	a2, a9, a9
  90cd42:	092209        	addx2	a2, a2, a9
  90cd45:	08220a        	addx4	a2, a2, a8
  90cd48:	24201c        	l8ui	a4, a2, 28
  90cd4b:	285000        	l8ui	a8, a5, 0
  90cd4e:	004432        	sext	a4, a4, 7
  90cd51:	222c10        	addi	a2, a2, 16
  90cd54:	674045        	bgez	a4, 90cd9d <ath_tx_status_update_rate+0x75>
		txs->txstatus[txs->cnt].ts_rate |= SM(pRateTable->info[rcs[series].rix].dot11Rate,
  90cd57:	088909        	addx2	a9, a8, a8
  90cd5a:	a959      	add.n	a9, a5, a9
  90cd5c:	22200e        	l8ui	a2, a2, 14
  90cd5f:	249002        	l8ui	a4, a9, 2
  90cd62:	020243        	extui	a2, a2, 0, 4
  90cd65:	042202        	or	a2, a2, a4
  90cd68:	229402        	s8i	a2, a9, 2
								       ATH9K_HTC_TXSTAT_RATE);
		txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_MCS;
  90cd6b:	229003        	l8ui	a2, a9, 3
  90cd6e:	c048      	movi.n	a4, 8
  90cd70:	042402        	or	a4, a2, a4
  90cd73:	249403        	s8i	a4, a9, 3

		if (rcs[series].flags & ATH_RC_CW40_FLAG)
  90cd76:	243003        	l8ui	a4, a3, 3
  90cd79:	7e4707        	bbci	a4, 30, 90cd84 <ath_tx_status_update_rate+0x5c>
			txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_CW40;
  90cd7c:	c148      	movi.n	a4, 24
  90cd7e:	042202        	or	a2, a2, a4
  90cd81:	229403        	s8i	a2, a9, 3

		if (rcs[series].flags & ATH_RC_HT40_SGI_FLAG)
  90cd84:	223003        	l8ui	a2, a3, 3
  90cd87:	7d2723        	bbci	a2, 29, 90cdae <ath_tx_status_update_rate+0x86>
			txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_SGI;
  90cd8a:	088809        	addx2	a8, a8, a8
  90cd8d:	a858      	add.n	a8, a5, a8
  90cd8f:	248003        	l8ui	a4, a8, 3
  90cd92:	c220      	movi.n	a2, 32
  90cd94:	024202        	or	a2, a4, a2
  90cd97:	228403        	s8i	a2, a8, 3
  90cd9a:	600010        	j	90cdae <ath_tx_status_update_rate+0x86>

	} else {
		txs->txstatus[txs->cnt].ts_rate |= SM(rcs[series].rix, ATH9K_HTC_TXSTAT_RATE);
  90cd9d:	088809        	addx2	a8, a8, a8
  90cda0:	a858      	add.n	a8, a5, a8
  90cda2:	228002        	l8ui	a2, a8, 2
  90cda5:	090943        	extui	a9, a9, 0, 4
  90cda8:	029902        	or	a9, a9, a2
  90cdab:	298402        	s8i	a9, a8, 2
	}

	if (rcs[series].flags & ATH_RC_RTSCTS_FLAG)
  90cdae:	223003        	l8ui	a2, a3, 3
  90cdb1:	7b2713        	bbci	a2, 27, 90cdc8 <ath_tx_status_update_rate+0xa0>
		txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_RTC_CTS;
  90cdb4:	225000        	l8ui	a2, a5, 0
  90cdb7:	022209        	addx2	a2, a2, a2
  90cdba:	a255      	add.n	a5, a5, a2
  90cdbc:	235003        	l8ui	a3, a5, 3
  90cdbf:	220a04        	movi	a2, 4
  90cdc2:	023202        	or	a2, a3, a2
  90cdc5:	225403        	s8i	a2, a5, 3
  90cdc8:	d10f      	retw.n
	...

0090cdcc <ath_rate_attach>:

}

struct ath_ratectrl *
ath_rate_attach(struct ath_softc_tgt *sc)
{
  90cdcc:	6c1004        	entry	a1, 32
  90cdcf:	136915        	l32r	a3, 8e7224 <memset+0x3dc>
  90cdd2:	c0a0      	movi.n	a10, 0
  90cdd4:	223252        	l32i	a2, a3, 0x148
  90cdd7:	c1b8      	movi.n	a11, 24
  90cdd9:	0b2000        	callx8	a2
  90cddc:	d2a0      	mov.n	a2, a10
	struct atheros_softc *asc;

	asc = adf_os_mem_alloc(sizeof(struct atheros_softc));
	if (asc == NULL)
  90cdde:	c9a6      	beqz.n	a10, 90cdf8 <ath_rate_attach+0x2c>

/* set a memory buffer */
static inline void
__adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
{
	A_MEMSET(buf, b, size);
  90cde0:	8334      	l32i.n	a3, a3, 16
  90cde2:	c0b0      	movi.n	a11, 0
  90cde4:	c1c8      	movi.n	a12, 24
  90cde6:	0b3000        	callx8	a3
		return NULL;

	adf_os_mem_set(asc, 0, sizeof(struct atheros_softc));
	asc->arc.arc_space = sizeof(struct atheros_node);
  90cde9:	230a78        	movi	a3, 120
  90cdec:	9320      	s32i.n	a3, a2, 0

	ar5416AttachRateTables(asc);
  90cdee:	da20      	mov.n	a10, a2

	asc->tx_chainmask = 1;
  90cdf0:	230a01        	movi	a3, 1
		return NULL;

	adf_os_mem_set(asc, 0, sizeof(struct atheros_softc));
	asc->arc.arc_space = sizeof(struct atheros_node);

	ar5416AttachRateTables(asc);
  90cdf3:	580887        	call8	90f010 <ar5416AttachRateTables>

	asc->tx_chainmask = 1;
  90cdf6:	9323      	s32i.n	a3, a2, 12
    
	return &asc->arc;
}
  90cdf8:	d10f      	retw.n
	...

0090cdfc <ath_rate_findrate>:
                  int numRates,
                  int stepDnInc,
                  unsigned int rcflag,
                  struct ath_rc_series series[],
                  int *isProbe)
{
  90cdfc:	6c1006        	entry	a1, 48
  90cdff:	881f      	l32i.n	a8, a1, 60
	*isProbe = 0;
  90ce01:	c0e0      	movi.n	a14, 0

	if (!numRates || !numTries) {
  90ce03:	c091      	movi.n	a9, 1
                  int stepDnInc,
                  unsigned int rcflag,
                  struct ath_rc_series series[],
                  int *isProbe)
{
	*isProbe = 0;
  90ce05:	9e80      	s32i.n	a14, a8, 0

	if (!numRates || !numTries) {
  90ce07:	079e38        	moveqz	a14, a9, a7
                  int numRates,
                  int stepDnInc,
                  unsigned int rcflag,
                  struct ath_rc_series series[],
                  int *isProbe)
{
  90ce0a:	dd70      	mov.n	a13, a7
  90ce0c:	da20      	mov.n	a10, a2
  90ce0e:	db30      	mov.n	a11, a3
  90ce10:	dc60      	mov.n	a12, a6
	*isProbe = 0;

	if (!numRates || !numTries) {
  90ce12:	cde0      	bnez.n	a14, 90ce26 <ath_rate_findrate+0x2a>
  90ce14:	06e939        	movnez	a9, a14, a6
  90ce17:	cc9b      	bnez.n	a9, 90ce26 <ath_rate_findrate+0x2a>
	*isProbe = 0;
	if (!numRates || !numTries) {
		return;
	}

	rcRateFind_11n(sc, an, numTries, numRates, stepDnInc, rcflag, series, isProbe);
  90ce19:	891e      	l32i.n	a9, a1, 56
  90ce1b:	8e1c      	l32i.n	a14, a1, 48
  90ce1d:	8f1d      	l32i.n	a15, a1, 52
  90ce1f:	9910      	s32i.n	a9, a1, 0
  90ce21:	9811      	s32i.n	a8, a1, 4
  90ce23:	5bfeab        	call8	90c8d0 <rcRateFind_11n>
  90ce26:	d10f      	retw.n

0090ce28 <ath_rate_tx_complete>:
ath_rate_tx_complete(struct ath_softc_tgt *sc,
		     struct ath_node_target *an,
		     struct ath_tx_desc *ds,
		     struct ath_rc_series rcs[], 
		     int nframes, int nbad)
{
  90ce28:	6c1006        	entry	a1, 48
			 int nframes, int nbad)
{
	int finalTSIdx = ds->ds_txstat.ts_rate;
	int tx_status = 0;

	if ((ds->ds_txstat.ts_status & HAL_TXERR_XRETRY) ||
  90ce2b:	294066        	l8ui	a9, a4, 102
  90ce2e:	c085      	movi.n	a8, 5
  90ce30:	089801        	and	a8, a9, a8
ath_rate_tx_complete(struct ath_softc_tgt *sc,
		     struct ath_node_target *an,
		     struct ath_tx_desc *ds,
		     struct ath_rc_series rcs[], 
		     int nframes, int nbad)
{
  90ce33:	da20      	mov.n	a10, a2
  90ce35:	db30      	mov.n	a11, a3
  90ce37:	df50      	mov.n	a15, a5
			 struct ath_node_target *an,
			 struct ath_tx_desc *ds,
			 struct ath_rc_series rcs[], 
			 int nframes, int nbad)
{
	int finalTSIdx = ds->ds_txstat.ts_rate;
  90ce39:	2d4068        	l8ui	a13, a4, 104

	if ((ds->ds_txstat.ts_status & HAL_TXERR_XRETRY) ||
	    (ds->ds_txstat.ts_status & HAL_TXERR_FIFO) || 
	    (ds->ds_txstat.ts_flags & HAL_TX_DATA_UNDERRUN) ||
	    (ds->ds_txstat.ts_flags & HAL_TX_DELIM_UNDERRUN)) {
		tx_status = 1;
  90ce3c:	c0e1      	movi.n	a14, 1
			 int nframes, int nbad)
{
	int finalTSIdx = ds->ds_txstat.ts_rate;
	int tx_status = 0;

	if ((ds->ds_txstat.ts_status & HAL_TXERR_XRETRY) ||
  90ce3e:	65800b        	bnez	a8, 90ce4d <ath_rate_tx_complete+0x25>
	    (ds->ds_txstat.ts_status & HAL_TXERR_FIFO) || 
	    (ds->ds_txstat.ts_flags & HAL_TX_DATA_UNDERRUN) ||
  90ce41:	2c4067        	l8ui	a12, a4, 103
  90ce44:	290a18        	movi	a9, 24
  90ce47:	09c901        	and	a9, a12, a9
  90ce4a:	098e38        	moveqz	a14, a8, a9
	    (ds->ds_txstat.ts_flags & HAL_TX_DELIM_UNDERRUN)) {
		tx_status = 1;
	}

	rcUpdate_11n(sc, an,
  90ce4d:	2c4073        	l8ui	a12, a4, 115
  90ce50:	9610      	s32i.n	a6, a1, 0
  90ce52:	9711      	s32i.n	a7, a1, 4
  90ce54:	244071        	l8ui	a4, a4, 113
  90ce57:	9412      	s32i.n	a4, a1, 8
  90ce59:	5bff5d        	call8	90cbd0 <rcUpdate_11n>
  90ce5c:	d10f      	retw.n
	...

0090ce60 <ath_rate_newassoc>:
}

void
ath_rate_newassoc(struct ath_softc_tgt *sc, struct ath_node_target *an, int isnew, 
		  unsigned int capflag, struct ieee80211_rate *rs)
{
  90ce60:	6c1004        	entry	a1, 32
	ath_rate_newassoc_11n(sc, an, isnew, capflag, rs);
  90ce63:	da20      	mov.n	a10, a2
  90ce65:	db30      	mov.n	a11, a3
  90ce67:	dc40      	mov.n	a12, a4
  90ce69:	dd50      	mov.n	a13, a5
  90ce6b:	de60      	mov.n	a14, a6
  90ce6d:	5bfe8d        	call8	90c8a4 <ath_rate_newassoc_11n>
  90ce70:	d10f      	retw.n
	...

0090ce74 <ath_rate_node_update>:
void ath_rate_node_update(struct ath_softc_tgt *sc,
			  struct ath_node_target *an,
			  a_int32_t isnew,
			  a_uint32_t capflag,
			  struct ieee80211_rate *rs)
{
  90ce74:	6c1004        	entry	a1, 32

void
ath_rate_newassoc(struct ath_softc_tgt *sc, struct ath_node_target *an, int isnew, 
		  unsigned int capflag, struct ieee80211_rate *rs)
{
	ath_rate_newassoc_11n(sc, an, isnew, capflag, rs);
  90ce77:	da20      	mov.n	a10, a2
  90ce79:	db30      	mov.n	a11, a3
  90ce7b:	dc40      	mov.n	a12, a4
  90ce7d:	dd50      	mov.n	a13, a5
  90ce7f:	de60      	mov.n	a14, a6
  90ce81:	5bfe88        	call8	90c8a4 <ath_rate_newassoc_11n>
  90ce84:	d10f      	retw.n
	...

0090ce88 <ath_rate_newstate>:
ath_rate_newstate(struct ath_softc_tgt *sc,
		  struct ieee80211vap_target *vap,
		  enum ieee80211_state state,
		  a_uint32_t capflag,
		  struct ieee80211_rate *rs)
{
  90ce88:	6c1004        	entry	a1, 32
	struct ieee80211_node_target *ni = vap->iv_bss;
	struct atheros_softc *asc = (struct atheros_softc *) sc->sc_rc;

	asc->tx_chainmask = sc->sc_ic.ic_tx_chainmask;
  90ce8b:	292d16        	addmi	a9, a2, 0x1600
  90ce8e:	282248        	l32i	a8, a2, 0x120
  90ce91:	299026        	l8ui	a9, a9, 38
		  struct ieee80211vap_target *vap,
		  enum ieee80211_state state,
		  a_uint32_t capflag,
		  struct ieee80211_rate *rs)
{
	struct ieee80211_node_target *ni = vap->iv_bss;
  90ce94:	8b34      	l32i.n	a11, a3, 16
ath_rate_newstate(struct ath_softc_tgt *sc,
		  struct ieee80211vap_target *vap,
		  enum ieee80211_state state,
		  a_uint32_t capflag,
		  struct ieee80211_rate *rs)
{
  90ce96:	da20      	mov.n	a10, a2
	struct ieee80211_node_target *ni = vap->iv_bss;
	struct atheros_softc *asc = (struct atheros_softc *) sc->sc_rc;

	asc->tx_chainmask = sc->sc_ic.ic_tx_chainmask;
  90ce98:	9983      	s32i.n	a9, a8, 12

void
ath_rate_newassoc(struct ath_softc_tgt *sc, struct ath_node_target *an, int isnew, 
		  unsigned int capflag, struct ieee80211_rate *rs)
{
	ath_rate_newassoc_11n(sc, an, isnew, capflag, rs);
  90ce9a:	c0c1      	movi.n	a12, 1
  90ce9c:	dd50      	mov.n	a13, a5
  90ce9e:	066e02        	or	a14, a6, a6
  90cea1:	5bfe80        	call8	90c8a4 <ath_rate_newassoc_11n>
  90cea4:	d10f      	retw.n
	...

0090cea8 <__adf_os_mem_copy>:
    //free(buf,M_DEVBUF);
}

/* move a memory buffer */
static inline void 		__adf_os_mem_copy(void *dst, const void *src, adf_os_size_t size)
{
  90cea8:	6c1004        	entry	a1, 32
    A_MEMCPY(dst,src,size);    
  90ceab:	186915        	l32r	a8, 8e7300 <memset+0x4b8>
  90ceae:	da20      	mov.n	a10, a2
  90ceb0:	8885      	l32i.n	a8, a8, 20
  90ceb2:	db30      	mov.n	a11, a3
  90ceb4:	dc40      	mov.n	a12, a4
  90ceb6:	0b8000        	callx8	a8
  90ceb9:	d10f      	retw.n
	...

0090cebc <ieee80211_anyhdrsize>:
/*
 * Like ieee80211_hdrsize, but handles any type of frame.
 */
static __inline a_int32_t
ieee80211_anyhdrsize(const void *data)
{
  90cebc:	6c1004        	entry	a1, 32
	const struct ieee80211_frame *wh = data;

	if ((wh->i_fc[0]&IEEE80211_FC0_TYPE_MASK) == IEEE80211_FC0_TYPE_CTL) {
  90cebf:	282000        	l8ui	a8, a2, 0
  90cec2:	c09c      	movi.n	a9, 12
  90cec4:	098901        	and	a9, a8, a9
  90cec7:	699415        	bnei	a9, 4, 90cee0 <ieee80211_anyhdrsize+0x24>
		switch (wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK) {
  90ceca:	22faf0        	movi	a2, -16
  90cecd:	028801        	and	a8, a8, a2
  90ced0:	220ac0        	movi	a2, 192
  90ced3:	728105        	beq	a8, a2, 90cedc <ieee80211_anyhdrsize+0x20>
  90ced6:	220ad0        	movi	a2, 208
  90ced9:	728927        	bne	a8, a2, 90cf04 <ieee80211_anyhdrsize+0x48>
		case IEEE80211_FC0_SUBTYPE_CTS:
		case IEEE80211_FC0_SUBTYPE_ACK:
			return sizeof(struct ieee80211_frame_ack);
  90cedc:	c02a      	movi.n	a2, 10
  90cede:	d10f      	retw.n
	const struct ieee80211_frame *wh = data;
	a_int32_t size = sizeof(struct ieee80211_frame);

	/* NB: we don't handle control frames */
	adf_os_assert((wh->i_fc[0]&IEEE80211_FC0_TYPE_MASK) != IEEE80211_FC0_TYPE_CTL);
	if ((wh->i_fc[1] & IEEE80211_FC1_DIR_MASK) == IEEE80211_FC1_DIR_DSTODS)
  90cee0:	2a2001        	l8ui	a10, a2, 1
 */
static __inline a_int32_t
ieee80211_hdrsize(const void *data)
{
	const struct ieee80211_frame *wh = data;
	a_int32_t size = sizeof(struct ieee80211_frame);
  90cee3:	c19e      	movi.n	a9, 30

	/* NB: we don't handle control frames */
	adf_os_assert((wh->i_fc[0]&IEEE80211_FC0_TYPE_MASK) != IEEE80211_FC0_TYPE_CTL);
	if ((wh->i_fc[1] & IEEE80211_FC1_DIR_MASK) == IEEE80211_FC1_DIR_DSTODS)
  90cee5:	0a0a41        	extui	a10, a10, 0, 2
 */
static __inline a_int32_t
ieee80211_hdrsize(const void *data)
{
	const struct ieee80211_frame *wh = data;
	a_int32_t size = sizeof(struct ieee80211_frame);
  90cee8:	2aacfd        	addi	a10, a10, -3
  90ceeb:	c128      	movi.n	a2, 24
  90ceed:	0a9238        	moveqz	a2, a9, a10

	/* NB: we don't handle control frames */
	adf_os_assert((wh->i_fc[0]&IEEE80211_FC0_TYPE_MASK) != IEEE80211_FC0_TYPE_CTL);
	if ((wh->i_fc[1] & IEEE80211_FC1_DIR_MASK) == IEEE80211_FC1_DIR_DSTODS)
		size += IEEE80211_ADDR_LEN;
	if (IEEE80211_QOS_HAS_SEQ(wh))
  90cef0:	29fa8c        	movi	a9, -116
  90cef3:	098801        	and	a8, a8, a9
		size += sizeof(a_uint16_t);
  90cef6:	2a0a88        	movi	a10, 136
  90cef9:	b229      	addi.n	a9, a2, 2
  90cefb:	0a880c        	sub	a8, a8, a10
  90cefe:	089238        	moveqz	a2, a9, a8
  90cf01:	d10f      	retw.n
  90cf03:	00c120        	excw
			return sizeof(struct ieee80211_frame_ack);
		}
		return sizeof(struct ieee80211_frame_min);
	} else
		return ieee80211_hdrsize(data);
}
  90cf06:	d10f      	retw.n

0090cf08 <owl_tgt_tid_init>:
	ath_rate_findrate(sc, an, 1, frameLen, 10, 4, 1,
			  ATH_RC_PROBE_ALLOWED, series, isProbe);
}

static void owl_tgt_tid_init(struct ath_atx_tid *tid)
{
  90cf08:	6c1004        	entry	a1, 32
	int i;

	tid->seq_start  = tid->seq_next = 0;
  90cf0b:	c090      	movi.n	a9, 0
	tid->baw_size   = WME_MAX_BA;
  90cf0d:	c480      	movi.n	a8, 64

static void owl_tgt_tid_init(struct ath_atx_tid *tid)
{
	int i;

	tid->seq_start  = tid->seq_next = 0;
  90cf0f:	292503        	s16i	a9, a2, 6
  90cf12:	292502        	s16i	a9, a2, 4
	tid->baw_size   = WME_MAX_BA;
  90cf15:	282504        	s16i	a8, a2, 8
	tid->baw_head   = tid->baw_tail = 0;
	tid->paused     = 0;
  90cf18:	292434        	s8i	a9, a2, 52
{
	int i;

	tid->seq_start  = tid->seq_next = 0;
	tid->baw_size   = WME_MAX_BA;
	tid->baw_head   = tid->baw_tail = 0;
  90cf1b:	c080      	movi.n	a8, 0
	tid->paused     = 0;
	tid->flag       = 0;
  90cf1d:	292436        	s8i	a9, a2, 54
	tid->sched      = AH_FALSE;
  90cf20:	292435        	s8i	a9, a2, 53

	asf_tailq_init(&tid->buf_q);
  90cf23:	292c2c        	addi	a9, a2, 44
{
	int i;

	tid->seq_start  = tid->seq_next = 0;
	tid->baw_size   = WME_MAX_BA;
	tid->baw_head   = tid->baw_tail = 0;
  90cf26:	9824      	s32i.n	a8, a2, 16
  90cf28:	9823      	s32i.n	a8, a2, 12
	tid->paused     = 0;
	tid->flag       = 0;
	tid->sched      = AH_FALSE;

	asf_tailq_init(&tid->buf_q);
  90cf2a:	982b      	s32i.n	a8, a2, 44
  90cf2c:	992c      	s32i.n	a9, a2, 48

	for (i = 0; i < ATH_TID_MAX_BUFS; i++) {
		TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, i);
  90cf2e:	2d0a01        	movi	a13, 1
  90cf31:	2cfaff        	movi	a12, -1
  90cf34:	085912        	srai	a9, a8, 5
  90cf37:	b499      	addi.n	a9, a9, 4
  90cf39:	02990a        	addx4	a9, a9, a2
  90cf3c:	008104        	ssl	a8
  90cf3f:	00da1a        	sll	a10, a13
  90cf42:	8b91      	l32i.n	a11, a9, 4
  90cf44:	0aca03        	xor	a10, a12, a10
  90cf47:	0baa01        	and	a10, a10, a11
  90cf4a:	9a91      	s32i.n	a10, a9, 4
	tid->flag       = 0;
	tid->sched      = AH_FALSE;

	asf_tailq_init(&tid->buf_q);

	for (i = 0; i < ATH_TID_MAX_BUFS; i++) {
  90cf4c:	b188      	addi.n	a8, a8, 1
  90cf4e:	698ee2        	bnei	a8, 128, 90cf34 <owl_tgt_tid_init+0x2c>
		TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, i);
	}
}
  90cf51:	d10f      	retw.n
	...

0090cf54 <ath_tgt_txq_add_ucast>:

	return 0;
}

static void ath_tgt_txq_add_ucast(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90cf54:	6c1006        	entry	a1, 48
	struct ath_hal *ah = sc->sc_ah;
  90cf57:	222d05        	addmi	a2, a2, 0x500
  90cf5a:	842b      	l32i.n	a4, a2, 44
	struct ath_txq *txq;
	HAL_STATUS status;
	volatile a_int32_t txe_val;

	adf_os_assert(bf);
  90cf5c:	cd35      	bnez.n	a3, 90cf75 <ath_tgt_txq_add_ucast+0x21>
  90cf5e:	126915        	l32r	a2, 8e73b4 <memset+0x56c>
  90cf61:	1a6afb        	l32r	a10, 8e7b50 <memset+0xd08>
  90cf64:	222212        	l32i	a2, a2, 72
  90cf67:	1b6afc        	l32r	a11, 8e7b58 <memset+0xd10>
  90cf6a:	0b2000        	callx8	a2
  90cf6d:	12697a        	l32r	a2, 8e7558 <memset+0x710>
  90cf70:	0c0200        	memw
  90cf73:	8220      	l32i.n	a2, a2, 0

	txq = bf->bf_txq;

	status = ah->ah_procTxDesc(ah, bf->bf_lastds);
  90cf75:	28421a        	l32i	a8, a4, 104
  90cf78:	8b3e      	l32i.n	a11, a3, 56
  90cf7a:	da40      	mov.n	a10, a4
	HAL_STATUS status;
	volatile a_int32_t txe_val;

	adf_os_assert(bf);

	txq = bf->bf_txq;
  90cf7c:	223220        	l32i	a2, a3, 128

	status = ah->ah_procTxDesc(ah, bf->bf_lastds);
  90cf7f:	0b8000        	callx8	a8

	ATH_TXQ_INSERT_TAIL(txq, bf, bf_list);
  90cf82:	c080      	movi.n	a8, 0
  90cf84:	9839      	s32i.n	a8, a3, 36
  90cf86:	8823      	l32i.n	a8, a2, 12
  90cf88:	983a      	s32i.n	a8, a3, 40
  90cf8a:	9380      	s32i.n	a3, a8, 0
  90cf8c:	283c24        	addi	a8, a3, 36
  90cf8f:	9823      	s32i.n	a8, a2, 12
  90cf91:	8824      	l32i.n	a8, a2, 16
  90cf93:	9325      	s32i.n	a3, a2, 20
  90cf95:	b188      	addi.n	a8, a8, 1
  90cf97:	9824      	s32i.n	a8, a2, 16

	if (txq->axq_link == NULL) {
  90cf99:	8821      	l32i.n	a8, a2, 4
  90cf9b:	cc89      	bnez.n	a8, 90cfa8 <ath_tgt_txq_add_ucast+0x54>
		ah->ah_setTxDP(ah, txq->axq_qnum, ATH_BUF_GET_DESC_PHY_ADDR(bf));
  90cf9d:	884a      	l32i.n	a8, a4, 40
  90cf9f:	da40      	mov.n	a10, a4
  90cfa1:	8b20      	l32i.n	a11, a2, 0
  90cfa3:	8c3c      	l32i.n	a12, a3, 48
  90cfa5:	600024        	j	90cfcd <ath_tgt_txq_add_ucast+0x79>
	} else {
		*txq->axq_link = ATH_BUF_GET_DESC_PHY_ADDR(bf);
  90cfa8:	8c3c      	l32i.n	a12, a3, 48
  90cfaa:	9c80      	s32i.n	a12, a8, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90cfac:	186ab5        	l32r	a8, 8e7a80 <memset+0xc38>

		txe_val = ioread32_mac(0x0840);
		if (!(txe_val & (1<< txq->axq_qnum)))
  90cfaf:	8b20      	l32i.n	a11, a2, 0
  90cfb1:	0c0200        	memw
  90cfb4:	8880      	l32i.n	a8, a8, 0
	if (txq->axq_link == NULL) {
		ah->ah_setTxDP(ah, txq->axq_qnum, ATH_BUF_GET_DESC_PHY_ADDR(bf));
	} else {
		*txq->axq_link = ATH_BUF_GET_DESC_PHY_ADDR(bf);

		txe_val = ioread32_mac(0x0840);
  90cfb6:	0c0200        	memw
  90cfb9:	9810      	s32i.n	a8, a1, 0
		if (!(txe_val & (1<< txq->axq_qnum)))
  90cfbb:	0c0200        	memw
  90cfbe:	8810      	l32i.n	a8, a1, 0
  90cfc0:	00b004        	ssr	a11
  90cfc3:	08081b        	sra	a8, a8
  90cfc6:	7f8f06        	bbsi	a8, 31, 90cfd0 <ath_tgt_txq_add_ucast+0x7c>
			ah->ah_setTxDP(ah, txq->axq_qnum, ATH_BUF_GET_DESC_PHY_ADDR(bf));
  90cfc9:	884a      	l32i.n	a8, a4, 40
  90cfcb:	da40      	mov.n	a10, a4
  90cfcd:	0b8000        	callx8	a8
	}

	txq->axq_link = &bf->bf_lastds->ds_link;
  90cfd0:	833e      	l32i.n	a3, a3, 56
	ah->ah_startTxDma(ah, txq->axq_qnum);
  90cfd2:	8b20      	l32i.n	a11, a2, 0
		txe_val = ioread32_mac(0x0840);
		if (!(txe_val & (1<< txq->axq_qnum)))
			ah->ah_setTxDP(ah, txq->axq_qnum, ATH_BUF_GET_DESC_PHY_ADDR(bf));
	}

	txq->axq_link = &bf->bf_lastds->ds_link;
  90cfd4:	9321      	s32i.n	a3, a2, 4
	ah->ah_startTxDma(ah, txq->axq_qnum);
  90cfd6:	834c      	l32i.n	a3, a4, 48
  90cfd8:	da40      	mov.n	a10, a4
  90cfda:	0b3000        	callx8	a3
  90cfdd:	d10f      	retw.n
	...

0090cfe0 <ath_update_stats>:
			     bf->bf_lastds, bf->bf_rcs, 1, 0);
}

static void
ath_update_stats(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90cfe0:	6c1004        	entry	a1, 32
	struct ath_tx_desc *ds = bf->bf_desc;
  90cfe3:	883c      	l32i.n	a8, a3, 48
	u_int32_t sr, lr;

	if (ds->ds_txstat.ts_status == 0) {
  90cfe5:	298066        	l8ui	a9, a8, 102
  90cfe8:	cd95      	bnez.n	a9, 90d001 <ath_update_stats+0x21>
		if (ds->ds_txstat.ts_rate & HAL_TXSTAT_ALTRATE)
  90cfea:	298068        	l8ui	a9, a8, 104
  90cfed:	009932        	sext	a9, a9, 7
  90cff0:	679042        	bgez	a9, 90d036 <ath_update_stats+0x56>
			sc->sc_tx_stats.ast_tx_altrate++;
  90cff3:	292259        	l32i	a9, a2, 0x164
  90cff6:	b199      	addi.n	a9, a9, 1
  90cff8:	292659        	s32i	a9, a2, 0x164
  90cffb:	600037        	j	90d036 <ath_update_stats+0x56>
  90cffe:	000000        	ill
	} else {
		if (ds->ds_txstat.ts_status & HAL_TXERR_XRETRY)
  90d001:	7f9707        	bbci	a9, 31, 90d00c <ath_update_stats+0x2c>
			sc->sc_tx_stats.ast_tx_xretries++;
  90d004:	292252        	l32i	a9, a2, 0x148
  90d007:	b199      	addi.n	a9, a9, 1
  90d009:	292652        	s32i	a9, a2, 0x148
		if (ds->ds_txstat.ts_status & HAL_TXERR_FIFO)
  90d00c:	298066        	l8ui	a9, a8, 102
  90d00f:	7d9707        	bbci	a9, 29, 90d01a <ath_update_stats+0x3a>
			sc->sc_tx_stats.ast_tx_fifoerr++;
  90d012:	292253        	l32i	a9, a2, 0x14c
  90d015:	b199      	addi.n	a9, a9, 1
  90d017:	292653        	s32i	a9, a2, 0x14c
		if (ds->ds_txstat.ts_status & HAL_TXERR_FILT)
  90d01a:	298066        	l8ui	a9, a8, 102
  90d01d:	7e9707        	bbci	a9, 30, 90d028 <ath_update_stats+0x48>
			sc->sc_tx_stats.ast_tx_filtered++;
  90d020:	292254        	l32i	a9, a2, 0x150
  90d023:	b199      	addi.n	a9, a9, 1
  90d025:	292654        	s32i	a9, a2, 0x150
		if (ds->ds_txstat.ts_status & HAL_TXERR_TIMER_EXPIRED)
  90d028:	298066        	l8ui	a9, a8, 102
  90d02b:	7b9707        	bbci	a9, 27, 90d036 <ath_update_stats+0x56>
			sc->sc_tx_stats.ast_tx_timer_exp++;
  90d02e:	292255        	l32i	a9, a2, 0x154
  90d031:	b199      	addi.n	a9, a9, 1
  90d033:	292655        	s32i	a9, a2, 0x154
	}
	sr = ds->ds_txstat.ts_shortretry;
	lr = ds->ds_txstat.ts_longretry;
  90d036:	298071        	l8ui	a9, a8, 113
	sc->sc_tx_stats.ast_tx_shortretry += sr;
  90d039:	2a2256        	l32i	a10, a2, 0x158
		if (ds->ds_txstat.ts_status & HAL_TXERR_FILT)
			sc->sc_tx_stats.ast_tx_filtered++;
		if (ds->ds_txstat.ts_status & HAL_TXERR_TIMER_EXPIRED)
			sc->sc_tx_stats.ast_tx_timer_exp++;
	}
	sr = ds->ds_txstat.ts_shortretry;
  90d03c:	288070        	l8ui	a8, a8, 112
	lr = ds->ds_txstat.ts_longretry;
	sc->sc_tx_stats.ast_tx_shortretry += sr;
  90d03f:	a8a8      	add.n	a8, a10, a8
  90d041:	282656        	s32i	a8, a2, 0x158
	sc->sc_tx_stats.ast_tx_longretry += lr;
  90d044:	282257        	l32i	a8, a2, 0x15c
  90d047:	a988      	add.n	a8, a8, a9
  90d049:	282657        	s32i	a8, a2, 0x15c
  90d04c:	d10f      	retw.n
	...

0090d050 <ath_tx_update_baw>:
	ath_tgt_tx_enqueue(txq, tid);
}

static void
ath_tx_update_baw(ath_atx_tid_t *tid, int seqno)
{
  90d050:	6c1004        	entry	a1, 32
	int index;
	int cindex;

	index  = ATH_BA_INDEX(tid->seq_start, seqno);
  90d053:	2a2102        	l16ui	a10, a2, 4
	cindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);
  90d056:	8823      	l32i.n	a8, a2, 12
ath_tx_update_baw(ath_atx_tid_t *tid, int seqno)
{
	int index;
	int cindex;

	index  = ATH_BA_INDEX(tid->seq_start, seqno);
  90d058:	0a330c        	sub	a3, a3, a10
  90d05b:	030a4b        	extui	a10, a3, 0, 12
	cindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);
  90d05e:	a8aa      	add.n	a10, a10, a8

	TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, cindex);
  90d060:	0a5941        	extui	a9, a10, 5, 2
  90d063:	c081      	movi.n	a8, 1
  90d065:	b499      	addi.n	a9, a9, 4
  90d067:	02990a        	addx4	a9, a9, a2
  90d06a:	c7bf      	movi.n	a11, -1
  90d06c:	00a104        	ssl	a10
  90d06f:	008a1a        	sll	a10, a8
  90d072:	0aba03        	xor	a10, a11, a10
  90d075:	8b91      	l32i.n	a11, a9, 4

	while (tid->baw_head != tid->baw_tail &&
  90d077:	8c24      	l32i.n	a12, a2, 16
	int cindex;

	index  = ATH_BA_INDEX(tid->seq_start, seqno);
	cindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);

	TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, cindex);
  90d079:	0baa01        	and	a10, a10, a11
  90d07c:	9a91      	s32i.n	a10, a9, 4

	while (tid->baw_head != tid->baw_tail &&
	       (!TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head))) {
  90d07e:	db80      	mov.n	a11, a8
	index  = ATH_BA_INDEX(tid->seq_start, seqno);
	cindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);

	TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, cindex);

	while (tid->baw_head != tid->baw_tail &&
  90d080:	600012        	j	90d096 <ath_tx_update_baw+0x46>
  90d083:	002921        	excw
	       (!TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head))) {
		INCR(tid->seq_start, IEEE80211_SEQ_MAX);
  90d086:	02b188        	excw
  90d089:	b199      	addi.n	a9, a9, 1
  90d08b:	09094b        	extui	a9, a9, 0, 12
		INCR(tid->baw_head, ATH_TID_MAX_BUFS);
  90d08e:	080846        	extui	a8, a8, 0, 7

	TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, cindex);

	while (tid->baw_head != tid->baw_tail &&
	       (!TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head))) {
		INCR(tid->seq_start, IEEE80211_SEQ_MAX);
  90d091:	292502        	s16i	a9, a2, 4
		INCR(tid->baw_head, ATH_TID_MAX_BUFS);
  90d094:	9823      	s32i.n	a8, a2, 12
	index  = ATH_BA_INDEX(tid->seq_start, seqno);
	cindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);

	TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, cindex);

	while (tid->baw_head != tid->baw_tail &&
  90d096:	8823      	l32i.n	a8, a2, 12
  90d098:	7c8110        	beq	a8, a12, 90d0ac <ath_tx_update_baw+0x5c>
	       (!TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head))) {
  90d09b:	085912        	srai	a9, a8, 5
  90d09e:	02990a        	addx4	a9, a9, a2
  90d0a1:	8995      	l32i.n	a9, a9, 20
  90d0a3:	008104        	ssl	a8
  90d0a6:	00ba1a        	sll	a10, a11
	index  = ATH_BA_INDEX(tid->seq_start, seqno);
	cindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);

	TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, cindex);

	while (tid->baw_head != tid->baw_tail &&
  90d0a9:	79a0d7        	bnone	a10, a9, 90d084 <ath_tx_update_baw+0x34>
  90d0ac:	d10f      	retw.n
	...

0090d0b0 <ath_dma_unmap>:
	skb = adf_nbuf_queue_first(&bf->bf_skbhead);
	adf_nbuf_map(sc->sc_dev, bf->bf_dmamap, skb, ADF_OS_DMA_TO_DEVICE);
}

static void ath_dma_unmap(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90d0b0:	6c1004        	entry	a1, 32
 * @return first buffer in queue
 */
static inline adf_nbuf_t 
adf_nbuf_queue_first(adf_nbuf_queue_t *head)
{
    return (__adf_nbuf_queue_first(head));
  90d0b3:	2a3c14        	addi	a10, a3, 20
  90d0b6:	5be706        	call8	906cd0 <__adf_nbuf_queue_first>
static inline void
adf_nbuf_unmap(adf_os_device_t      osdev, 
               adf_os_dma_map_t     bmap, 
               adf_os_dma_dir_t     dir)
{
    __adf_nbuf_unmap(osdev, bmap, dir);
  90d0b9:	2a2246        	l32i	a10, a2, 0x118
  90d0bc:	8b30      	l32i.n	a11, a3, 0
  90d0be:	2c0a00        	movi	a12, 0
  90d0c1:	5be671        	call8	906a88 <__adf_nbuf_unmap>
  90d0c4:	d10f      	retw.n
	...

0090d0c8 <ath_tgt_skb_free>:
}

static void ath_tgt_skb_free(struct ath_softc_tgt *sc,
			     adf_nbuf_queue_t *head,
			     HTC_ENDPOINT_ID endpt)
{
  90d0c8:	6c1004        	entry	a1, 32
	adf_nbuf_t tskb;

	while (adf_nbuf_queue_len(head) != 0) {
		tskb = adf_nbuf_queue_remove(head);
		ath_free_tx_skb(sc->tgt_htc_handle,endpt,tskb);
  90d0cb:	156915        	l32r	a5, 8e7520 <memset+0x6d8>
			     adf_nbuf_queue_t *head,
			     HTC_ENDPOINT_ID endpt)
{
	adf_nbuf_t tskb;

	while (adf_nbuf_queue_len(head) != 0) {
  90d0ce:	600012        	j	90d0e4 <ath_tgt_skb_free+0x1c>
 * @return The head buf in the buf queue.
 */
static inline adf_nbuf_t
adf_nbuf_queue_remove(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_remove(head);
  90d0d1:	da30      	mov.n	a10, a3
  90d0d3:	5be659        	call8	906a38 <__adf_nbuf_queue_remove>
  90d0d6:	dca0      	mov.n	a12, a10
		tskb = adf_nbuf_queue_remove(head);
		ath_free_tx_skb(sc->tgt_htc_handle,endpt,tskb);
  90d0d8:	285282        	l32i	a8, a5, 0x208
  90d0db:	2a2202        	l32i	a10, a2, 8
  90d0de:	044b02        	or	a11, a4, a4
  90d0e1:	0b8000        	callx8	a8
 * @return length of the queue
 */
static inline a_uint32_t
adf_nbuf_queue_len(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_len(head);
  90d0e4:	da30      	mov.n	a10, a3
  90d0e6:	5be6f8        	call8	906cc8 <__adf_nbuf_queue_len>
			     adf_nbuf_queue_t *head,
			     HTC_ENDPOINT_ID endpt)
{
	adf_nbuf_t tskb;

	while (adf_nbuf_queue_len(head) != 0) {
  90d0e9:	65afe4        	bnez	a10, 90d0d1 <ath_tgt_skb_free+0x9>
		tskb = adf_nbuf_queue_remove(head);
		ath_free_tx_skb(sc->tgt_htc_handle,endpt,tskb);
	}
}
  90d0ec:	d10f      	retw.n
	...

0090d0f0 <ath_filltxdesc>:
	skb = adf_nbuf_queue_first(&bf->bf_skbhead);
	adf_nbuf_unmap( sc->sc_dev, bf->bf_dmamap, ADF_OS_DMA_TO_DEVICE);
}

static void ath_filltxdesc(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90d0f0:	6c1004        	entry	a1, 32
	struct ath_tx_desc *ds0, *ds = bf->bf_desc;
  90d0f3:	863c      	l32i.n	a6, a3, 48
 * @param[out] sg   map info
 */
static inline void
adf_nbuf_dmamap_info(adf_os_dma_map_t bmap, adf_os_dmamap_info_t *sg)
{
    __adf_nbuf_dmamap_info(bmap, sg);
  90d0f5:	8a30      	l32i.n	a10, a3, 0
	struct ath_hal *ah = sc->sc_ah;
  90d0f7:	222d05        	addmi	a2, a2, 0x500
  90d0fa:	b43b      	addi.n	a11, a3, 4
	a_uint8_t i;

	ds0 = ds;
	adf_nbuf_dmamap_info(bf->bf_dmamap, &bf->bf_dmamap_info);

	for (i = 0; i < bf->bf_dmamap_info.nsegs; i++, ds++) {
  90d0fc:	c040      	movi.n	a4, 0
}

static void ath_filltxdesc(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_tx_desc *ds0, *ds = bf->bf_desc;
	struct ath_hal *ah = sc->sc_ah;
  90d0fe:	872b      	l32i.n	a7, a2, 44
	ds0 = ds;
	adf_nbuf_dmamap_info(bf->bf_dmamap, &bf->bf_dmamap_info);

	for (i = 0; i < bf->bf_dmamap_info.nsegs; i++, ds++) {

		ds->ds_data = bf->bf_dmamap_info.dma_segs[i].paddr;
  90d100:	d540      	mov.n	a5, a4
  90d102:	5be666        	call8	906a9c <__adf_nbuf_dmamap_info>
	adf_nbuf_unmap( sc->sc_dev, bf->bf_dmamap, ADF_OS_DMA_TO_DEVICE);
}

static void ath_filltxdesc(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_tx_desc *ds0, *ds = bf->bf_desc;
  90d105:	d260      	mov.n	a2, a6
	a_uint8_t i;

	ds0 = ds;
	adf_nbuf_dmamap_info(bf->bf_dmamap, &bf->bf_dmamap_info);

	for (i = 0; i < bf->bf_dmamap_info.nsegs; i++, ds++) {
  90d107:	600081        	j	90d18c <ath_filltxdesc+0x9c>
  90d10a:	000003        	xor	a0, a0, a0

		ds->ds_data = bf->bf_dmamap_info.dma_segs[i].paddr;
  90d10d:	480b2a        	excw
  90d110:	8008      	l32i.n	a0, a0, 32

		if (i == (bf->bf_dmamap_info.nsegs - 1)) {
  90d112:	b099      	addi.n	a9, a9, -1
	ds0 = ds;
	adf_nbuf_dmamap_info(bf->bf_dmamap, &bf->bf_dmamap_info);

	for (i = 0; i < bf->bf_dmamap_info.nsegs; i++, ds++) {

		ds->ds_data = bf->bf_dmamap_info.dma_segs[i].paddr;
  90d114:	2a2404        	s8i	a10, a2, 4
  90d117:	2a8009        	l8ui	a10, a8, 9
  90d11a:	2a2405        	s8i	a10, a2, 5
  90d11d:	2a800a        	l8ui	a10, a8, 10
  90d120:	2a2406        	s8i	a10, a2, 6
  90d123:	28800b        	l8ui	a8, a8, 11
  90d126:	282407        	s8i	a8, a2, 7

		if (i == (bf->bf_dmamap_info.nsegs - 1)) {
  90d129:	794910        	bne	a4, a9, 90d13d <ath_filltxdesc+0x4d>
			ds->ds_link = 0;
  90d12c:	252400        	s8i	a5, a2, 0
  90d12f:	252401        	s8i	a5, a2, 1
  90d132:	252402        	s8i	a5, a2, 2
  90d135:	252403        	s8i	a5, a2, 3
			bf->bf_lastds = ds;
  90d138:	923e      	s32i.n	a2, a3, 56
  90d13a:	600020        	j	90d15e <ath_filltxdesc+0x6e>
		} else
			ds->ds_link = ATH_BUF_GET_DESC_PHY_ADDR_WITH_IDX(bf, i+1);
  90d13d:	b148      	addi.n	a8, a4, 1
  90d13f:	0c8911        	slli	a9, a8, 4
  90d142:	a898      	add.n	a8, a9, a8
  90d144:	893d      	l32i.n	a9, a3, 52
  90d146:	09880b        	addx8	a8, a8, a9
  90d149:	088957        	extui	a9, a8, 24, 8
  90d14c:	292400        	s8i	a9, a2, 0
  90d14f:	080957        	extui	a9, a8, 16, 8
  90d152:	292401        	s8i	a9, a2, 1
  90d155:	088947        	extui	a9, a8, 8, 8
  90d158:	292402        	s8i	a9, a2, 2
  90d15b:	282403        	s8i	a8, a2, 3

		ah->ah_fillTxDesc(ds
				   , bf->bf_dmamap_info.dma_segs[i].len
				   , i == 0
				   , i == (bf->bf_dmamap_info.nsegs - 1)
  90d15e:	8d31      	l32i.n	a13, a3, 4
			ds->ds_link = 0;
			bf->bf_lastds = ds;
		} else
			ds->ds_link = ATH_BUF_GET_DESC_PHY_ADDR_WITH_IDX(bf, i+1);

		ah->ah_fillTxDesc(ds
  90d160:	c091      	movi.n	a9, 1
				   , bf->bf_dmamap_info.dma_segs[i].len
				   , i == 0
				   , i == (bf->bf_dmamap_info.nsegs - 1)
  90d162:	b0dd      	addi.n	a13, a13, -1
			ds->ds_link = 0;
			bf->bf_lastds = ds;
		} else
			ds->ds_link = ATH_BUF_GET_DESC_PHY_ADDR_WITH_IDX(bf, i+1);

		ah->ah_fillTxDesc(ds
  90d164:	0d4d0c        	sub	a13, a4, a13
  90d167:	034b0b        	addx8	a11, a4, a3
  90d16a:	c080      	movi.n	a8, 0
  90d16c:	dc80      	mov.n	a12, a8
  90d16e:	2f7218        	l32i	a15, a7, 96
  90d171:	0d9838        	moveqz	a8, a9, a13
  90d174:	8bb3      	l32i.n	a11, a11, 12
  90d176:	049c38        	moveqz	a12, a9, a4
  90d179:	dd80      	mov.n	a13, a8
  90d17b:	da20      	mov.n	a10, a2
  90d17d:	de60      	mov.n	a14, a6
  90d17f:	0bf000        	callx8	a15
	a_uint8_t i;

	ds0 = ds;
	adf_nbuf_dmamap_info(bf->bf_dmamap, &bf->bf_dmamap_info);

	for (i = 0; i < bf->bf_dmamap_info.nsegs; i++, ds++) {
  90d182:	b144      	addi.n	a4, a4, 1
  90d184:	280a88        	movi	a8, 136
  90d187:	040447        	extui	a4, a4, 0, 8
  90d18a:	a822      	add.n	a2, a2, a8
  90d18c:	8931      	l32i.n	a9, a3, 4
  90d18e:	794b02        	bgeu	a4, a9, 90d194 <ath_filltxdesc+0xa4>
  90d191:	63ff77        	j	90d10c <ath_filltxdesc+0x1c>
				   , bf->bf_dmamap_info.dma_segs[i].len
				   , i == 0
				   , i == (bf->bf_dmamap_info.nsegs - 1)
				   , ds0);
	}
}
  90d194:	d10f      	retw.n
	...

0090d198 <ath_tx_tgt_setds>:

static void ath_tx_tgt_setds(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90d198:	6c1006        	entry	a1, 48
	struct ath_tx_desc *ds = bf->bf_desc;
	struct ath_hal *ah = sc->sc_ah;

	switch (bf->bf_protmode) {
  90d19b:	293084        	l8ui	a9, a3, 132
}

static void ath_tx_tgt_setds(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_tx_desc *ds = bf->bf_desc;
	struct ath_hal *ah = sc->sc_ah;
  90d19e:	282d05        	addmi	a8, a2, 0x500
  90d1a1:	8d8b      	l32i.n	a13, a8, 44
	}
}

static void ath_tx_tgt_setds(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_tx_desc *ds = bf->bf_desc;
  90d1a3:	8a3c      	l32i.n	a10, a3, 48
  90d1a5:	283144        	l16ui	a8, a3, 136
	struct ath_hal *ah = sc->sc_ah;

	switch (bf->bf_protmode) {
  90d1a8:	689108        	beqi	a9, 1, 90d1b4 <ath_tx_tgt_setds+0x1c>
  90d1ab:	69920d        	bnei	a9, 2, 90d1bc <ath_tx_tgt_setds+0x24>
    	case IEEE80211_PROT_RTSCTS:
		bf->bf_flags |= HAL_TXDESC_RTSENA;
  90d1ae:	c094      	movi.n	a9, 4
  90d1b0:	600002        	j	90d1b6 <ath_tx_tgt_setds+0x1e>
  90d1b3:	00c098        	excw
		break;
    	case IEEE80211_PROT_CTSONLY:
		bf->bf_flags |= HAL_TXDESC_CTSENA;
  90d1b6:	098802        	or	a8, a8, a9
  90d1b9:	283544        	s16i	a8, a3, 136
		break;
    	default:
		break;
	}

	ah->ah_set11nTxDesc(ds
  90d1bc:	293144        	l16ui	a9, a3, 136
  90d1bf:	c180      	movi.n	a8, 16
  90d1c1:	089802        	or	a8, a9, a8
  90d1c4:	08084f        	extui	a8, a8, 0, 16
  90d1c7:	9810      	s32i.n	a8, a1, 0
  90d1c9:	2b3122        	l16ui	a11, a3, 68
  90d1cc:	88df      	l32i.n	a8, a13, 60
  90d1ce:	2c304a        	l8ui	a12, a3, 74
  90d1d1:	2e3049        	l8ui	a14, a3, 73
  90d1d4:	2f3085        	l8ui	a15, a3, 133
  90d1d7:	2d0a3c        	movi	a13, 60
  90d1da:	0b8000        	callx8	a8
			      , 60
			      , bf->bf_keyix
			      , bf->bf_keytype
			      , bf->bf_flags | HAL_TXDESC_INTREQ);

	ath_filltxdesc(sc, bf);
  90d1dd:	da20      	mov.n	a10, a2
  90d1df:	db30      	mov.n	a11, a3
  90d1e1:	5bffc3        	call8	90d0f0 <ath_filltxdesc>
  90d1e4:	d10f      	retw.n
	...

0090d1e8 <ath_tgt_tx_enqueue>:
	ath_tgt_tx_send_normal(sc, bf);
}

static void
ath_tgt_tx_enqueue(struct ath_txq *txq, struct ath_atx_tid  *tid)
{
  90d1e8:	6c1004        	entry	a1, 32
	if (tid->paused)
  90d1eb:	283034        	l8ui	a8, a3, 52
  90d1ee:	cd88      	bnez.n	a8, 90d20a <ath_tgt_tx_enqueue+0x22>
		return;

	if (tid->sched)
  90d1f0:	283035        	l8ui	a8, a3, 53
  90d1f3:	008832        	sext	a8, a8, 7
  90d1f6:	cd80      	bnez.n	a8, 90d20a <ath_tgt_tx_enqueue+0x22>
		return;

	tid->sched = AH_TRUE;
  90d1f8:	c091      	movi.n	a9, 1
  90d1fa:	293435        	s8i	a9, a3, 53
	asf_tailq_insert_tail(&txq->axq_tidq, tid, tid_qelem);
  90d1fd:	9839      	s32i.n	a8, a3, 36
  90d1ff:	8827      	l32i.n	a8, a2, 28
  90d201:	983a      	s32i.n	a8, a3, 40
  90d203:	9380      	s32i.n	a3, a8, 0
  90d205:	233c24        	addi	a3, a3, 36
  90d208:	9327      	s32i.n	a3, a2, 28
  90d20a:	d10f      	retw.n

0090d20c <ath_update_aggr_stats$isra$2>:
	ath_tx_set_retry(sc, bf);
	asf_tailq_insert_tail(bf_q, bf, bf_list);
}

static void
ath_update_aggr_stats(struct ath_softc_tgt *sc,
  90d20c:	6c1004        	entry	a1, 32
{

	u_int8_t status = ATH_DS_TX_STATUS(ds);
	u_int8_t txflags = ATH_DS_TX_FLAGS(ds);

	__statsn(sc, txaggr_longretries, ds->ds_txstat.ts_longretry);
  90d20f:	2a3071        	l8ui	a10, a3, 113
  90d212:	2b2268        	l32i	a11, a2, 0x1a0
ath_update_aggr_stats(struct ath_softc_tgt *sc,
		      struct ath_tx_desc *ds, int nframes,
		      int nbad)
{

	u_int8_t status = ATH_DS_TX_STATUS(ds);
  90d215:	283066        	l8ui	a8, a3, 102
	u_int8_t txflags = ATH_DS_TX_FLAGS(ds);

	__statsn(sc, txaggr_longretries, ds->ds_txstat.ts_longretry);
  90d218:	0aba08        	add	a10, a11, a10
		      struct ath_tx_desc *ds, int nframes,
		      int nbad)
{

	u_int8_t status = ATH_DS_TX_STATUS(ds);
	u_int8_t txflags = ATH_DS_TX_FLAGS(ds);
  90d21b:	293067        	l8ui	a9, a3, 103

	__statsn(sc, txaggr_longretries, ds->ds_txstat.ts_longretry);
  90d21e:	2a2668        	s32i	a10, a2, 0x1a0
	__statsn(sc, txaggr_shortretries, ds->ds_txstat.ts_shortretry);
  90d221:	233070        	l8ui	a3, a3, 112
  90d224:	2a226b        	l32i	a10, a2, 0x1ac
  90d227:	03a308        	add	a3, a10, a3
  90d22a:	23266b        	s32i	a3, a2, 0x1ac

	if (txflags & HAL_TX_DESC_CFG_ERR)
  90d22d:	7d9708        	bbci	a9, 29, 90d239 <ath_update_aggr_stats$isra$2+0x2d>
		__stats(sc, txaggr_desc_cfgerr);
  90d230:	232271        	l32i	a3, a2, 0x1c4
  90d233:	233c01        	addi	a3, a3, 1
  90d236:	232671        	s32i	a3, a2, 0x1c4

	if (txflags & HAL_TX_DATA_UNDERRUN)
  90d239:	7c9708        	bbci	a9, 28, 90d245 <ath_update_aggr_stats$isra$2+0x39>
		__stats(sc, txaggr_data_urun);
  90d23c:	232265        	l32i	a3, a2, 0x194
  90d23f:	233c01        	addi	a3, a3, 1
  90d242:	232665        	s32i	a3, a2, 0x194

	if (txflags & HAL_TX_DELIM_UNDERRUN)
  90d245:	7b9707        	bbci	a9, 27, 90d250 <ath_update_aggr_stats$isra$2+0x44>
		__stats(sc, txaggr_delim_urun);
  90d248:	232266        	l32i	a3, a2, 0x198
  90d24b:	b133      	addi.n	a3, a3, 1
  90d24d:	232666        	s32i	a3, a2, 0x198

	if (!status) {
  90d250:	cb88      	beqz.n	a8, 90d28c <ath_update_aggr_stats$isra$2+0x80>
		return;
	}

	if (status & HAL_TXERR_XRETRY)
  90d252:	7f8707        	bbci	a8, 31, 90d25d <ath_update_aggr_stats$isra$2+0x51>
		__stats(sc, txaggr_compxretry);
  90d255:	23226a        	l32i	a3, a2, 0x1a8
  90d258:	b133      	addi.n	a3, a3, 1
  90d25a:	23266a        	s32i	a3, a2, 0x1a8

	if (status & HAL_TXERR_FILT)
  90d25d:	7e8708        	bbci	a8, 30, 90d269 <ath_update_aggr_stats$isra$2+0x5d>
		__stats(sc, txaggr_filtered);
  90d260:	23226e        	l32i	a3, a2, 0x1b8
  90d263:	233c01        	addi	a3, a3, 1
  90d266:	23266e        	s32i	a3, a2, 0x1b8

	if (status & HAL_TXERR_FIFO)
  90d269:	7d8708        	bbci	a8, 29, 90d275 <ath_update_aggr_stats$isra$2+0x69>
		__stats(sc, txaggr_fifo);
  90d26c:	23226f        	l32i	a3, a2, 0x1bc
  90d26f:	233c01        	addi	a3, a3, 1
  90d272:	23266f        	s32i	a3, a2, 0x1bc

	if (status & HAL_TXERR_XTXOP)
  90d275:	7c8708        	bbci	a8, 28, 90d281 <ath_update_aggr_stats$isra$2+0x75>
		__stats(sc, txaggr_xtxop);
  90d278:	232270        	l32i	a3, a2, 0x1c0
  90d27b:	233c01        	addi	a3, a3, 1
  90d27e:	232670        	s32i	a3, a2, 0x1c0

	if (status & HAL_TXERR_TIMER_EXPIRED)
  90d281:	7b8707        	bbci	a8, 27, 90d28c <ath_update_aggr_stats$isra$2+0x80>
		__stats(sc, txaggr_timer_exp);
  90d284:	23226c        	l32i	a3, a2, 0x1b0
  90d287:	b133      	addi.n	a3, a3, 1
  90d289:	23266c        	s32i	a3, a2, 0x1b0
  90d28c:	d10f      	retw.n
	...

0090d290 <__adf_os_mem_set$constprop$13>:
}

/* set a memory buffer */
static inline void
__adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
  90d290:	6c1004        	entry	a1, 32
{
	A_MEMSET(buf, b, size);
  90d293:	186915        	l32r	a8, 8e76e8 <memset+0x8a0>
  90d296:	da20      	mov.n	a10, a2
  90d298:	8884      	l32i.n	a8, a8, 16
  90d29a:	c0b0      	movi.n	a11, 0
  90d29c:	dc30      	mov.n	a12, a3
  90d29e:	0b8000        	callx8	a8
  90d2a1:	d10f      	retw.n
	...

0090d2a4 <ath_buf_set_rate>:
		asf_tailq_insert_tail(&sc->sc_txbuf, bf, bf_list);
	}
}

static void ath_buf_set_rate(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90d2a4:	6c1016        	entry	a1, 176
    a_uint8_t rix, cix, rtsctsrate;
    a_int32_t prot_mode = AH_FALSE;

    rt = sc->sc_currates;
    rix = bf->bf_rcs[0].rix;
    flags = (bf->bf_flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA));
  90d2a7:	253144        	l16ui	a5, a3, 136
  90d2aa:	c07c      	movi.n	a7, 12
  90d2ac:	075801        	and	a8, a5, a7
    cix = rt->info[sc->sc_protrix].controlRate;
  90d2af:	272d03        	addmi	a7, a2, 0x300
  90d2b2:	27700c        	l8ui	a7, a7, 12
	}
}

static void ath_buf_set_rate(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
    struct ath_hal *ah = sc->sc_ah;
  90d2b5:	242d05        	addmi	a4, a2, 0x500
    HAL_11N_RATE_SERIES series[4];
    a_int32_t i, flags;
    a_uint8_t rix, cix, rtsctsrate;
    a_int32_t prot_mode = AH_FALSE;

    rt = sc->sc_currates;
  90d2b8:	262281        	l32i	a6, a2, 0x204
	}
}

static void ath_buf_set_rate(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
    struct ath_hal *ah = sc->sc_ah;
  90d2bb:	844b      	l32i.n	a4, a4, 44
    a_int32_t prot_mode = AH_FALSE;

    rt = sc->sc_currates;
    rix = bf->bf_rcs[0].rix;
    flags = (bf->bf_flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA));
    cix = rt->info[sc->sc_protrix].controlRate;
  90d2bd:	07770a        	addx4	a7, a7, a7
  90d2c0:	06770a        	addx4	a7, a7, a6
	}
}

static void ath_buf_set_rate(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
    struct ath_hal *ah = sc->sc_ah;
  90d2c3:	24161e        	s32i	a4, a1, 120
    a_uint8_t rix, cix, rtsctsrate;
    a_int32_t prot_mode = AH_FALSE;

    rt = sc->sc_currates;
    rix = bf->bf_rcs[0].rix;
    flags = (bf->bf_flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA));
  90d2c6:	28161c        	s32i	a8, a1, 112

static void ath_buf_set_rate(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
    struct ath_hal *ah = sc->sc_ah;
    const HAL_RATE_TABLE *rt;
    struct ath_tx_desc *ds = bf->bf_desc;
  90d2c9:	843c      	l32i.n	a4, a3, 48
    a_int32_t prot_mode = AH_FALSE;

    rt = sc->sc_currates;
    rix = bf->bf_rcs[0].rix;
    flags = (bf->bf_flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA));
    cix = rt->info[sc->sc_protrix].controlRate;
  90d2cb:	287037        	l8ui	a8, a7, 55

    if (bf->bf_protmode != IEEE80211_PROT_NONE &&
  90d2ce:	273084        	l8ui	a7, a3, 132

static void ath_buf_set_rate(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
    struct ath_hal *ah = sc->sc_ah;
    const HAL_RATE_TABLE *rt;
    struct ath_tx_desc *ds = bf->bf_desc;
  90d2d1:	24161f        	s32i	a4, a1, 124
    a_int32_t prot_mode = AH_FALSE;

    rt = sc->sc_currates;
    rix = bf->bf_rcs[0].rix;
    flags = (bf->bf_flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA));
    cix = rt->info[sc->sc_protrix].controlRate;
  90d2d4:	28161d        	s32i	a8, a1, 116
    a_int32_t i, flags;
    a_uint8_t rix, cix, rtsctsrate;
    a_int32_t prot_mode = AH_FALSE;

    rt = sc->sc_currates;
    rix = bf->bf_rcs[0].rix;
  90d2d7:	243050        	l8ui	a4, a3, 80
    flags = (bf->bf_flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA));
    cix = rt->info[sc->sc_protrix].controlRate;

    if (bf->bf_protmode != IEEE80211_PROT_NONE &&
  90d2da:	ca70      	beqz.n	a7, 90d2fe <ath_buf_set_rate+0x5a>
	(rt->info[rix].phy == IEEE80211_T_OFDM ||
  90d2dc:	04440a        	addx4	a4, a4, a4
  90d2df:	06440a        	addx4	a4, a4, a6
  90d2e2:	284029        	l8ui	a8, a4, 41
  90d2e5:	c071      	movi.n	a7, 1
  90d2e7:	298cfc        	addi	a9, a8, -4
  90d2ea:	c040      	movi.n	a4, 0
  90d2ec:	097438        	moveqz	a4, a7, a9
    rt = sc->sc_currates;
    rix = bf->bf_rcs[0].rix;
    flags = (bf->bf_flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA));
    cix = rt->info[sc->sc_protrix].controlRate;

    if (bf->bf_protmode != IEEE80211_PROT_NONE &&
  90d2ef:	cc46      	bnez.n	a4, 90d2f9 <ath_buf_set_rate+0x55>
	(rt->info[rix].phy == IEEE80211_T_OFDM ||
  90d2f1:	288cfe        	addi	a8, a8, -2
    rt = sc->sc_currates;
    rix = bf->bf_rcs[0].rix;
    flags = (bf->bf_flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA));
    cix = rt->info[sc->sc_protrix].controlRate;

    if (bf->bf_protmode != IEEE80211_PROT_NONE &&
  90d2f4:	087438        	moveqz	a4, a7, a8
  90d2f7:	c843      	beqz.n	a4, 90d2fe <ath_buf_set_rate+0x5a>
	(rt->info[rix].phy == IEEE80211_T_OFDM ||
	 rt->info[rix].phy == IEEE80211_T_HT) &&
	(bf->bf_flags & HAL_TXDESC_NOACK) == 0) {
	    cix = rt->info[sc->sc_protrix].controlRate;
	    prot_mode = AH_TRUE;
  90d2f9:	c071      	movi.n	a7, 1
    flags = (bf->bf_flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA));
    cix = rt->info[sc->sc_protrix].controlRate;

    if (bf->bf_protmode != IEEE80211_PROT_NONE &&
	(rt->info[rix].phy == IEEE80211_T_OFDM ||
	 rt->info[rix].phy == IEEE80211_T_HT) &&
  90d2fb:	7e574a        	bbci	a5, 30, 90d349 <ath_buf_set_rate+0xa5>
	(bf->bf_flags & HAL_TXDESC_NOACK) == 0) {
	    cix = rt->info[sc->sc_protrix].controlRate;
	    prot_mode = AH_TRUE;
    } else {
	    if (ath_hal_getcapability(ah, HAL_CAP_HT) && (!bf->bf_ismcast))
  90d2fe:	2a121e        	l32i	a10, a1, 120
  90d301:	c0b5      	movi.n	a11, 5
  90d303:	5bf693        	call8	90ad50 <ath_hal_getcapability>
  90d306:	c8af      	beqz.n	a10, 90d319 <ath_buf_set_rate+0x75>
  90d308:	253221        	l32i	a5, a3, 132
		    flags = HAL_TXDESC_RTSENA;
  90d30b:	28121c        	l32i	a8, a1, 112
	 rt->info[rix].phy == IEEE80211_T_HT) &&
	(bf->bf_flags & HAL_TXDESC_NOACK) == 0) {
	    cix = rt->info[sc->sc_protrix].controlRate;
	    prot_mode = AH_TRUE;
    } else {
	    if (ath_hal_getcapability(ah, HAL_CAP_HT) && (!bf->bf_ismcast))
  90d30e:	057540        	extui	a5, a5, 7, 1
		    flags = HAL_TXDESC_RTSENA;
  90d311:	c044      	movi.n	a4, 4
  90d313:	054838        	moveqz	a8, a4, a5
  90d316:	28161c        	s32i	a8, a1, 112
  90d319:	d530      	mov.n	a5, a3

	    for (i = 4; i--;) {
  90d31b:	c044      	movi.n	a4, 4
  90d31d:	600021        	j	90d342 <ath_buf_set_rate+0x9e>
  90d320:	255cf4        	addi	a5, a5, -12
		    if (bf->bf_rcs[i].tries) {
  90d323:	275081        	l8ui	a7, a5, 129
  90d326:	c978      	beqz.n	a7, 90d342 <ath_buf_set_rate+0x9e>
			    cix = rt->info[bf->bf_rcs[i].rix].controlRate;
  90d328:	044409        	addx2	a4, a4, a4
  90d32b:	03440a        	addx4	a4, a4, a3
  90d32e:	244050        	l8ui	a4, a4, 80
  90d331:	04440a        	addx4	a4, a4, a4
  90d334:	06440a        	addx4	a4, a4, a6
  90d337:	244037        	l8ui	a4, a4, 55
  90d33a:	24161d        	s32i	a4, a1, 116
  90d33d:	600006        	j	90d347 <ath_buf_set_rate+0xa3>
  90d340:	0000b0        	excw
	    prot_mode = AH_TRUE;
    } else {
	    if (ath_hal_getcapability(ah, HAL_CAP_HT) && (!bf->bf_ismcast))
		    flags = HAL_TXDESC_RTSENA;

	    for (i = 4; i--;) {
  90d343:	446940        	excw
  90d346:	d8c0      	mov.n	a8, a12
    const HAL_RATE_TABLE *rt;
    struct ath_tx_desc *ds = bf->bf_desc;
    HAL_11N_RATE_SERIES series[4];
    a_int32_t i, flags;
    a_uint8_t rix, cix, rtsctsrate;
    a_int32_t prot_mode = AH_FALSE;
  90d348:	70da10        	bge	a13, a0, 90d35c <ath_buf_set_rate+0xb8>
 * @param[in] size  buffer size
 */
static inline void
adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
{
    __adf_os_mem_set(buf, b, size);
  90d34b:	2b0a70        	movi	a11, 112
  90d34e:	5bffd0        	call8	90d290 <__adf_os_mem_set$constprop$13>
	if (bf != NULL) {
		asf_tailq_insert_tail(&sc->sc_txbuf, bf, bf_list);
	}
}

static void ath_buf_set_rate(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
  90d351:	283c30        	addi	a8, a3, 48
  90d354:	d530      	mov.n	a5, a3
  90d356:	241c10        	addi	a4, a1, 16
  90d359:	281620        	s32i	a8, a1, 128
    }

    adf_os_mem_set(series, 0, sizeof(HAL_11N_RATE_SERIES) * 4);

    for (i = 0; i < 4; i++) {
	    if (!bf->bf_rcs[i].tries)
  90d35c:	285051        	l8ui	a8, a5, 81
  90d35f:	6480f9        	beqz	a8, 90d45c <ath_buf_set_rate+0x1b8>
		    continue;

	    rix = bf->bf_rcs[i].rix;

	    series[i].Rate = rt->info[rix].rateCode |
  90d362:	2d5050        	l8ui	a13, a5, 80
		    (bf->bf_shpream ? rt->info[rix].shortPreamble : 0);
  90d365:	2c3221        	l32i	a12, a3, 132
	    if (!bf->bf_rcs[i].tries)
		    continue;

	    rix = bf->bf_rcs[i].rix;

	    series[i].Rate = rt->info[rix].rateCode |
  90d368:	0dda0a        	addx4	a10, a13, a13
  90d36b:	06aa0a        	addx4	a10, a10, a6
		    (bf->bf_shpream ? rt->info[rix].shortPreamble : 0);
  90d36e:	2e0a40        	movi	a14, 64
	    if (!bf->bf_rcs[i].tries)
		    continue;

	    rix = bf->bf_rcs[i].rix;

	    series[i].Rate = rt->info[rix].rateCode |
  90d371:	2ba034        	l8ui	a11, a10, 52
		    (bf->bf_shpream ? rt->info[rix].shortPreamble : 0);
  90d374:	290a00        	movi	a9, 0
	    if (!bf->bf_rcs[i].tries)
		    continue;

	    rix = bf->bf_rcs[i].rix;

	    series[i].Rate = rt->info[rix].rateCode |
  90d377:	2aac20        	addi	a10, a10, 32
		    (bf->bf_shpream ? rt->info[rix].shortPreamble : 0);
  90d37a:	7ec002        	bnone	a12, a14, 90d380 <ath_buf_set_rate+0xdc>
  90d37d:	29a015        	l8ui	a9, a10, 21
	    if (!bf->bf_rcs[i].tries)
		    continue;

	    rix = bf->bf_rcs[i].rix;

	    series[i].Rate = rt->info[rix].rateCode |
  90d380:	0b9902        	or	a9, a9, a11
	if (bf != NULL) {
		asf_tailq_insert_tail(&sc->sc_txbuf, bf, bf_list);
	}
}

static void ath_buf_set_rate(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
  90d383:	2a4cf4        	addi	a10, a4, -12
	    series[i].Rate = rt->info[rix].rateCode |
		    (bf->bf_shpream ? rt->info[rix].shortPreamble : 0);

	    series[i].Tries = bf->bf_rcs[i].tries;
#ifdef MAGPIE_MERLIN
	    series[i].RateFlags = ((bf->bf_rcs[i].flags & ATH_RC_RTSCTS_FLAG) ?
  90d386:	2e5053        	l8ui	a14, a5, 83
	    if (!bf->bf_rcs[i].tries)
		    continue;

	    rix = bf->bf_rcs[i].rix;

	    series[i].Rate = rt->info[rix].rateCode |
  90d389:	99a0      	s32i.n	a9, a10, 0
	if (bf != NULL) {
		asf_tailq_insert_tail(&sc->sc_txbuf, bf, bf_list);
	}
}

static void ath_buf_set_rate(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
  90d38b:	294cf0        	addi	a9, a4, -16
	    rix = bf->bf_rcs[i].rix;

	    series[i].Rate = rt->info[rix].rateCode |
		    (bf->bf_shpream ? rt->info[rix].shortPreamble : 0);

	    series[i].Tries = bf->bf_rcs[i].tries;
  90d38e:	9890      	s32i.n	a8, a9, 0
#ifdef MAGPIE_MERLIN
	    series[i].RateFlags = ((bf->bf_rcs[i].flags & ATH_RC_RTSCTS_FLAG) ?
				   HAL_RATESERIES_RTS_CTS : 0 ) |
		    ((bf->bf_rcs[i].flags & ATH_RC_CW40_FLAG) ?
		     HAL_RATESERIES_2040 : 0 ) |
  90d390:	c0a2      	movi.n	a10, 2
		    ((bf->bf_rcs[i].flags & ATH_RC_HT40_SGI_FLAG) ?
		     HAL_RATESERIES_HALFGI : 0 ) |
  90d392:	c094      	movi.n	a9, 4
	    series[i].Tries = bf->bf_rcs[i].tries;
#ifdef MAGPIE_MERLIN
	    series[i].RateFlags = ((bf->bf_rcs[i].flags & ATH_RC_RTSCTS_FLAG) ?
				   HAL_RATESERIES_RTS_CTS : 0 ) |
		    ((bf->bf_rcs[i].flags & ATH_RC_CW40_FLAG) ?
		     HAL_RATESERIES_2040 : 0 ) |
  90d394:	0aea01        	and	a10, a14, a10
		    ((bf->bf_rcs[i].flags & ATH_RC_HT40_SGI_FLAG) ?
		     HAL_RATESERIES_HALFGI : 0 ) |
  90d397:	09e901        	and	a9, a14, a9
		    (bf->bf_shpream ? rt->info[rix].shortPreamble : 0);

	    series[i].Tries = bf->bf_rcs[i].tries;
#ifdef MAGPIE_MERLIN
	    series[i].RateFlags = ((bf->bf_rcs[i].flags & ATH_RC_RTSCTS_FLAG) ?
				   HAL_RATESERIES_RTS_CTS : 0 ) |
  90d39a:	0e4840        	extui	a8, a14, 4, 1
  90d39d:	09ab02        	or	a11, a10, a9
		    ((bf->bf_rcs[i].flags & ATH_RC_CW40_FLAG) ?
		     HAL_RATESERIES_2040 : 0 ) |
		    ((bf->bf_rcs[i].flags & ATH_RC_HT40_SGI_FLAG) ?
		     HAL_RATESERIES_HALFGI : 0 ) |
		    ((bf->bf_rcs[i].flags & ATH_RC_TX_STBC_FLAG) ?
		     HAL_RATESERIES_STBC: 0);
  90d3a0:	c2f0      	movi.n	a15, 32
	    series[i].Tries = bf->bf_rcs[i].tries;
#ifdef MAGPIE_MERLIN
	    series[i].RateFlags = ((bf->bf_rcs[i].flags & ATH_RC_RTSCTS_FLAG) ?
				   HAL_RATESERIES_RTS_CTS : 0 ) |
		    ((bf->bf_rcs[i].flags & ATH_RC_CW40_FLAG) ?
		     HAL_RATESERIES_2040 : 0 ) |
  90d3a2:	08bb02        	or	a11, a11, a8
		    ((bf->bf_rcs[i].flags & ATH_RC_HT40_SGI_FLAG) ?
		     HAL_RATESERIES_HALFGI : 0 ) |
		    ((bf->bf_rcs[i].flags & ATH_RC_TX_STBC_FLAG) ?
		     HAL_RATESERIES_STBC: 0);
  90d3a5:	0fef01        	and	a15, a14, a15
  90d3a8:	c088      	movi.n	a8, 8
  90d3aa:	c0e0      	movi.n	a14, 0
  90d3ac:	0fe838        	moveqz	a8, a14, a15
	    series[i].RateFlags = ((bf->bf_rcs[i].flags & ATH_RC_RTSCTS_FLAG) ?
				   HAL_RATESERIES_RTS_CTS : 0 ) |
		    ((bf->bf_rcs[i].flags & ATH_RC_CW40_FLAG) ?
		     HAL_RATESERIES_2040 : 0 ) |
		    ((bf->bf_rcs[i].flags & ATH_RC_HT40_SGI_FLAG) ?
		     HAL_RATESERIES_HALFGI : 0 ) |
  90d3af:	08b802        	or	a8, a11, a8
	    series[i].Rate = rt->info[rix].rateCode |
		    (bf->bf_shpream ? rt->info[rix].shortPreamble : 0);

	    series[i].Tries = bf->bf_rcs[i].tries;
#ifdef MAGPIE_MERLIN
	    series[i].RateFlags = ((bf->bf_rcs[i].flags & ATH_RC_RTSCTS_FLAG) ?
  90d3b2:	9840      	s32i.n	a8, a4, 0

static a_uint32_t ath_pkt_duration(struct ath_softc_tgt *sc,
				   a_uint8_t rix, struct ath_tx_buf *bf,
				   a_int32_t width, a_int32_t half_gi)
{
	const HAL_RATE_TABLE *rt = sc->sc_currates;
  90d3b4:	2b2281        	l32i	a11, a2, 0x204
	a_uint32_t nbits, nsymbits, duration, nsymbols;
	a_uint8_t rc;
	a_int32_t streams;
	a_int32_t pktlen;

	pktlen = bf->bf_isaggr ? bf->bf_al : bf->bf_pktlen;
  90d3b7:	7ac705        	bbci	a12, 26, 90d3c0 <ath_buf_set_rate+0x11c>
  90d3ba:	2c3127        	l16ui	a12, a3, 78
  90d3bd:	600002        	j	90d3c3 <ath_buf_set_rate+0x11f>
  90d3c0:	2c3122        	l16ui	a12, a3, 68
	rc = rt->info[rix].rateCode;
  90d3c3:	0dd80a        	addx4	a8, a13, a13
  90d3c6:	0b880a        	addx4	a8, a8, a11
  90d3c9:	288034        	l8ui	a8, a8, 52

	if (!IS_HT_RATE(rc))
  90d3cc:	008e32        	sext	a14, a8, 7
  90d3cf:	66e011        	bltz	a14, 90d3e4 <ath_buf_set_rate+0x140>
		return ath_hal_computetxtime(sc->sc_ah, rt, pktlen, rix,
  90d3d2:	282d05        	addmi	a8, a2, 0x500
					     bf->bf_shpream);
  90d3d5:	2e3221        	l32i	a14, a3, 132

	pktlen = bf->bf_isaggr ? bf->bf_al : bf->bf_pktlen;
	rc = rt->info[rix].rateCode;

	if (!IS_HT_RATE(rc))
		return ath_hal_computetxtime(sc->sc_ah, rt, pktlen, rix,
  90d3d8:	8a8b      	l32i.n	a10, a8, 44
  90d3da:	0e6e40        	extui	a14, a14, 6, 1
  90d3dd:	5bf66b        	call8	90ad8c <ath_hal_computetxtime>
  90d3e0:	60004d        	j	90d431 <ath_buf_set_rate+0x18d>
  90d3e3:	00c0d1        	excw
		    ((bf->bf_rcs[i].flags & ATH_RC_CW40_FLAG) ?
		     HAL_RATESERIES_2040 : 0 ) |
		    ((bf->bf_rcs[i].flags & ATH_RC_HT40_SGI_FLAG) ?
		     HAL_RATESERIES_HALFGI : 0 );
#endif
	    series[i].PktDuration = ath_pkt_duration(sc, rix, bf,
  90d3e6:	c0b0      	movi.n	a11, 0
  90d3e8:	0adb39        	movnez	a11, a13, a10
	if (!IS_HT_RATE(rc))
		return ath_hal_computetxtime(sc->sc_ah, rt, pktlen, rix,
					     bf->bf_shpream);

	nbits = (pktlen << 3) + OFDM_PLCP_BITS;
	nsymbits = bits_per_symbol[HT_RC_2_MCS(rc)][width];
  90d3eb:	080a43        	extui	a10, a8, 0, 4
  90d3ee:	0bab09        	addx2	a11, a10, a11
  90d3f1:	1a6afd        	l32r	a10, 8e7fe8 <memset+0x11a0>
	nsymbols = (nbits + nsymbits - 1) / nsymbits;
  90d3f4:	281622        	s32i	a8, a1, 136
	if (!IS_HT_RATE(rc))
		return ath_hal_computetxtime(sc->sc_ah, rt, pktlen, rix,
					     bf->bf_shpream);

	nbits = (pktlen << 3) + OFDM_PLCP_BITS;
	nsymbits = bits_per_symbol[HT_RC_2_MCS(rc)][width];
  90d3f7:	0abb09        	addx2	a11, a11, a10
  90d3fa:	2bb100        	l16ui	a11, a11, 0
	nsymbols = (nbits + nsymbits - 1) / nsymbits;
  90d3fd:	291621        	s32i	a9, a1, 132

	if (!IS_HT_RATE(rc))
		return ath_hal_computetxtime(sc->sc_ah, rt, pktlen, rix,
					     bf->bf_shpream);

	nbits = (pktlen << 3) + OFDM_PLCP_BITS;
  90d400:	0bca0b        	addx8	a10, a12, a11
	nsymbits = bits_per_symbol[HT_RC_2_MCS(rc)][width];
	nsymbols = (nbits + nsymbits - 1) / nsymbits;
  90d403:	2aac15        	addi	a10, a10, 21
  90d406:	5b6591        	call8	8e6a4c <__udivsi3>

	if (!half_gi)
  90d409:	291221        	l32i	a9, a1, 132
  90d40c:	281222        	l32i	a8, a1, 136
  90d40f:	cc95      	bnez.n	a9, 90d418 <ath_buf_set_rate+0x174>
		duration = SYMBOL_TIME(nsymbols);
  90d411:	0eaa11        	slli	a10, a10, 2
  90d414:	600011        	j	90d429 <ath_buf_set_rate+0x185>
  90d417:	000aaa        	excw
	else
		duration = SYMBOL_TIME_HALFGI(nsymbols);
  90d41a:	0b0faa        	excw
  90d41d:	11196a        	l32r	a1, 8d39c8 <_bss_end+0x3c0ab8>
  90d420:	fe          	.byte 0xfe
  90d421:	b4aa      	addi.n	a10, a10, 4
  90d423:	09aa2a        	muluh	a10, a10, a9
  90d426:	0a2a14        	srli	a10, a10, 2

	streams = HT_RC_2_STREAMS(rc);
  90d429:	083843        	extui	a8, a8, 3, 4
	duration += L_STF + L_LTF + L_SIG + HT_SIG + HT_STF + HT_LTF(streams);
  90d42c:	b988      	addi.n	a8, a8, 9
  90d42e:	0a8a0a        	addx4	a10, a8, a10
#endif
	    series[i].PktDuration = ath_pkt_duration(sc, rix, bf,
				     (bf->bf_rcs[i].flags & ATH_RC_CW40_FLAG) != 0,
				     (bf->bf_rcs[i].flags & ATH_RC_HT40_SGI_FLAG));

	    series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
  90d431:	292d16        	addmi	a9, a2, 0x1600
	if (bf != NULL) {
		asf_tailq_insert_tail(&sc->sc_txbuf, bf, bf_list);
	}
}

static void ath_buf_set_rate(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
  90d434:	284cf8        	addi	a8, a4, -8
#endif
	    series[i].PktDuration = ath_pkt_duration(sc, rix, bf,
				     (bf->bf_rcs[i].flags & ATH_RC_CW40_FLAG) != 0,
				     (bf->bf_rcs[i].flags & ATH_RC_HT40_SGI_FLAG));

	    series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
  90d437:	299026        	l8ui	a9, a9, 38
		    ((bf->bf_rcs[i].flags & ATH_RC_CW40_FLAG) ?
		     HAL_RATESERIES_2040 : 0 ) |
		    ((bf->bf_rcs[i].flags & ATH_RC_HT40_SGI_FLAG) ?
		     HAL_RATESERIES_HALFGI : 0 );
#endif
	    series[i].PktDuration = ath_pkt_duration(sc, rix, bf,
  90d43a:	9a80      	s32i.n	a10, a8, 0
	if (bf != NULL) {
		asf_tailq_insert_tail(&sc->sc_txbuf, bf, bf_list);
	}
}

static void ath_buf_set_rate(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
  90d43c:	284cfc        	addi	a8, a4, -4
#endif
	    series[i].PktDuration = ath_pkt_duration(sc, rix, bf,
				     (bf->bf_rcs[i].flags & ATH_RC_CW40_FLAG) != 0,
				     (bf->bf_rcs[i].flags & ATH_RC_HT40_SGI_FLAG));

	    series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
  90d43f:	9980      	s32i.n	a9, a8, 0

	    if (prot_mode)
  90d441:	c878      	beqz.n	a7, 90d44d <ath_buf_set_rate+0x1a9>
		    series[i].RateFlags |= HAL_RATESERIES_RTS_CTS;
  90d443:	8940      	l32i.n	a9, a4, 0
  90d445:	c081      	movi.n	a8, 1
  90d447:	089802        	or	a8, a9, a8
  90d44a:	284600        	s32i	a8, a4, 0

	    if (bf->bf_rcs[i].flags & ATH_RC_DS_FLAG)
  90d44d:	285053        	l8ui	a8, a5, 83
  90d450:	7f8708        	bbci	a8, 31, 90d45c <ath_buf_set_rate+0x1b8>
		    series[i].RateFlags |= HAL_RATESERIES_RTS_CTS;
  90d453:	8940      	l32i.n	a9, a4, 0
  90d455:	c081      	movi.n	a8, 1
  90d457:	089802        	or	a8, a9, a8
  90d45a:	9840      	s32i.n	a8, a4, 0
	    }
    }

    adf_os_mem_set(series, 0, sizeof(HAL_11N_RATE_SERIES) * 4);

    for (i = 0; i < 4; i++) {
  90d45c:	281220        	l32i	a8, a1, 128
  90d45f:	bc55      	addi.n	a5, a5, 12
  90d461:	244c1c        	addi	a4, a4, 28
  90d464:	785102        	beq	a5, a8, 90d46a <ath_buf_set_rate+0x1c6>
  90d467:	63fef1        	j	90d35c <ath_buf_set_rate+0xb8>

	    if (bf->bf_rcs[i].flags & ATH_RC_DS_FLAG)
		    series[i].RateFlags |= HAL_RATESERIES_RTS_CTS;
    }

    rtsctsrate = rt->info[cix].rateCode |
  90d46a:	24121d        	l32i	a4, a1, 116
	    (bf->bf_shpream ? rt->info[cix].shortPreamble : 0);
  90d46d:	233221        	l32i	a3, a3, 132

	    if (bf->bf_rcs[i].flags & ATH_RC_DS_FLAG)
		    series[i].RateFlags |= HAL_RATESERIES_RTS_CTS;
    }

    rtsctsrate = rt->info[cix].rateCode |
  90d470:	04420a        	addx4	a2, a4, a4
  90d473:	06260a        	addx4	a6, a2, a6
  90d476:	2c6034        	l8ui	a12, a6, 52
  90d479:	c020      	movi.n	a2, 0
  90d47b:	266c20        	addi	a6, a6, 32
  90d47e:	793702        	bbci	a3, 25, 90d484 <ath_buf_set_rate+0x1e0>
  90d481:	226015        	l8ui	a2, a6, 21
	    (bf->bf_shpream ? rt->info[cix].shortPreamble : 0);

    ah->ah_set11nRateScenario(ds, 1,
  90d484:	28121e        	l32i	a8, a1, 120
  90d487:	2a121f        	l32i	a10, a1, 124
  90d48a:	238210        	l32i	a3, a8, 64
  90d48d:	2f121c        	l32i	a15, a1, 112
  90d490:	c0b1      	movi.n	a11, 1
  90d492:	0c2c02        	or	a12, a2, a12
  90d495:	dd10      	mov.n	a13, a1
  90d497:	c0e4      	movi.n	a14, 4
  90d499:	0b3000        	callx8	a3
  90d49c:	d10f      	retw.n
	...

0090d4a0 <ath_dma_map>:

	return duration;
}

static void ath_dma_map(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90d4a0:	6c1004        	entry	a1, 32
 * @return first buffer in queue
 */
static inline adf_nbuf_t 
adf_nbuf_queue_first(adf_nbuf_queue_t *head)
{
    return (__adf_nbuf_queue_first(head));
  90d4a3:	2a3c14        	addi	a10, a3, 20
  90d4a6:	5be60a        	call8	906cd0 <__adf_nbuf_queue_first>
  90d4a9:	dca0      	mov.n	a12, a10
adf_nbuf_map(adf_os_device_t        osdev, 
             adf_os_dma_map_t       bmap, 
             adf_nbuf_t             buf, 
             adf_os_dma_dir_t       dir)
{
    return __adf_nbuf_map(osdev, bmap, buf, dir);
  90d4ab:	8b30      	l32i.n	a11, a3, 0
  90d4ad:	2a2246        	l32i	a10, a2, 0x118
  90d4b0:	c0d0      	movi.n	a13, 0
  90d4b2:	5be572        	call8	906a7c <__adf_nbuf_map>
  90d4b5:	d10f      	retw.n
	...

0090d4b8 <ath_buf_toggle>:
}

static struct ath_tx_buf *ath_buf_toggle(struct ath_softc_tgt *sc,
				      struct ath_tx_buf *bf,
				      a_uint8_t retry)
{
  90d4b8:	6c1004        	entry	a1, 32
  90d4bb:	d520      	mov.n	a5, a2
	struct ath_tx_buf *tmp = NULL;
	adf_nbuf_t buf = NULL;

	adf_os_assert(sc->sc_txbuf_held != NULL);
  90d4bd:	2222dc        	l32i	a2, a2, 0x370
  90d4c0:	cd25      	bnez.n	a2, 90d4d9 <ath_buf_toggle+0x21>
  90d4c2:	126915        	l32r	a2, 8e7918 <memset+0xad0>
  90d4c5:	1a6afb        	l32r	a10, 8e80b4 <memset+0x126c>
  90d4c8:	222212        	l32i	a2, a2, 72
  90d4cb:	1b6aff        	l32r	a11, 8e80c8 <memset+0x1280>
  90d4ce:	0b2000        	callx8	a2
  90d4d1:	12697a        	l32r	a2, 8e7abc <memset+0xc74>
  90d4d4:	0c0200        	memw
  90d4d7:	8220      	l32i.n	a2, a2, 0

	tmp = sc->sc_txbuf_held;
  90d4d9:	2252dc        	l32i	a2, a5, 0x370

	if (retry) {
  90d4dc:	6440e0        	beqz	a4, 90d5c0 <ath_buf_toggle+0x108>
		ath_dma_unmap(sc, bf);
  90d4df:	033b02        	or	a11, a3, a3
  90d4e2:	055a02        	or	a10, a5, a5
  90d4e5:	5bfef2        	call8	90d0b0 <ath_dma_unmap>
		adf_nbuf_queue_init(&tmp->bf_skbhead);
  90d4e8:	262c14        	addi	a6, a2, 20
 * @param[in] head  buf queue head
 */
static inline void
adf_nbuf_queue_init(adf_nbuf_queue_t *head)
{
    __adf_nbuf_queue_init(head);
  90d4eb:	066a02        	or	a10, a6, a6
  90d4ee:	5be5f2        	call8	906cb8 <__adf_nbuf_queue_init>
		buf = adf_nbuf_queue_remove(&bf->bf_skbhead);
  90d4f1:	243c14        	addi	a4, a3, 20
 * @return The head buf in the buf queue.
 */
static inline adf_nbuf_t
adf_nbuf_queue_remove(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_remove(head);
  90d4f4:	044a02        	or	a10, a4, a4
  90d4f7:	5be550        	call8	906a38 <__adf_nbuf_queue_remove>
  90d4fa:	d7a0      	mov.n	a7, a10
		adf_os_assert(buf);
  90d4fc:	cda5      	bnez.n	a10, 90d515 <ath_buf_toggle+0x5d>
  90d4fe:	186915        	l32r	a8, 8e7954 <memset+0xb0c>
  90d501:	1a6afb        	l32r	a10, 8e80f0 <memset+0x12a8>
  90d504:	288212        	l32i	a8, a8, 72
  90d507:	1b6aff        	l32r	a11, 8e8104 <memset+0x12bc>
  90d50a:	0b8000        	callx8	a8
  90d50d:	18697a        	l32r	a8, 8e7af8 <memset+0xcb0>
  90d510:	0c0200        	memw
  90d513:	8880      	l32i.n	a8, a8, 0
 * @param[in] buf   buf
 */
static inline void
adf_nbuf_queue_add(adf_nbuf_queue_t *head, adf_nbuf_t buf)
{
    __adf_nbuf_queue_add(head, buf);
  90d515:	da60      	mov.n	a10, a6
  90d517:	db70      	mov.n	a11, a7
  90d519:	5be53f        	call8	906a18 <__adf_nbuf_queue_add>
 * @return length of the queue
 */
static inline a_uint32_t
adf_nbuf_queue_len(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_len(head);
  90d51c:	da40      	mov.n	a10, a4
  90d51e:	5be5ea        	call8	906cc8 <__adf_nbuf_queue_len>
		adf_nbuf_queue_add(&tmp->bf_skbhead, buf);

		adf_os_assert(adf_nbuf_queue_len(&bf->bf_skbhead) == 0);
  90d521:	c9a5      	beqz.n	a10, 90d53a <ath_buf_toggle+0x82>
  90d523:	146915        	l32r	a4, 8e7978 <memset+0xb30>
  90d526:	1a6afb        	l32r	a10, 8e8114 <memset+0x12cc>
  90d529:	244212        	l32i	a4, a4, 72
  90d52c:	1b6aff        	l32r	a11, 8e8128 <memset+0x12e0>
  90d52f:	0b4000        	callx8	a4
  90d532:	14697a        	l32r	a4, 8e7b1c <memset+0xcd4>
  90d535:	0c0200        	memw
  90d538:	8440      	l32i.n	a4, a4, 0

		tmp->bf_next = bf->bf_next;
  90d53a:	843b      	l32i.n	a4, a3, 44
		tmp->bf_endpt = bf->bf_endpt;
		tmp->bf_tidno = bf->bf_tidno;
		tmp->bf_skb = bf->bf_skb;
		tmp->bf_node = bf->bf_node;
		tmp->bf_isaggr = bf->bf_isaggr;
  90d53c:	262087        	l8ui	a6, a2, 135
		adf_os_assert(buf);
		adf_nbuf_queue_add(&tmp->bf_skbhead, buf);

		adf_os_assert(adf_nbuf_queue_len(&bf->bf_skbhead) == 0);

		tmp->bf_next = bf->bf_next;
  90d53f:	942b      	s32i.n	a4, a2, 44
		tmp->bf_endpt = bf->bf_endpt;
  90d541:	243223        	l32i	a4, a3, 140
		tmp->bf_tidno = bf->bf_tidno;
		tmp->bf_skb = bf->bf_skb;
		tmp->bf_node = bf->bf_node;
		tmp->bf_isaggr = bf->bf_isaggr;
		tmp->bf_flags = bf->bf_flags;
		tmp->bf_state = bf->bf_state;
  90d544:	2b3c3c        	addi	a11, a3, 60
		adf_nbuf_queue_add(&tmp->bf_skbhead, buf);

		adf_os_assert(adf_nbuf_queue_len(&bf->bf_skbhead) == 0);

		tmp->bf_next = bf->bf_next;
		tmp->bf_endpt = bf->bf_endpt;
  90d547:	242623        	s32i	a4, a2, 140
		tmp->bf_tidno = bf->bf_tidno;
  90d54a:	24304d        	l8ui	a4, a3, 77
		tmp->bf_skb = bf->bf_skb;
		tmp->bf_node = bf->bf_node;
		tmp->bf_isaggr = bf->bf_isaggr;
		tmp->bf_flags = bf->bf_flags;
		tmp->bf_state = bf->bf_state;
  90d54d:	c4cc      	movi.n	a12, 76

		adf_os_assert(adf_nbuf_queue_len(&bf->bf_skbhead) == 0);

		tmp->bf_next = bf->bf_next;
		tmp->bf_endpt = bf->bf_endpt;
		tmp->bf_tidno = bf->bf_tidno;
  90d54f:	24244d        	s8i	a4, a2, 77
		tmp->bf_skb = bf->bf_skb;
  90d552:	8438      	l32i.n	a4, a3, 32
		tmp->bf_node = bf->bf_node;
		tmp->bf_isaggr = bf->bf_isaggr;
		tmp->bf_flags = bf->bf_flags;
		tmp->bf_state = bf->bf_state;
  90d554:	2a2c3c        	addi	a10, a2, 60
		adf_os_assert(adf_nbuf_queue_len(&bf->bf_skbhead) == 0);

		tmp->bf_next = bf->bf_next;
		tmp->bf_endpt = bf->bf_endpt;
		tmp->bf_tidno = bf->bf_tidno;
		tmp->bf_skb = bf->bf_skb;
  90d557:	9428      	s32i.n	a4, a2, 32
		tmp->bf_node = bf->bf_node;
  90d559:	8434      	l32i.n	a4, a3, 16
  90d55b:	242604        	s32i	a4, a2, 16
		tmp->bf_isaggr = bf->bf_isaggr;
  90d55e:	273221        	l32i	a7, a3, 132
  90d561:	24fadf        	movi	a4, -33
  90d564:	075740        	extui	a7, a7, 5, 1
  90d567:	046601        	and	a6, a6, a4
  90d56a:	0b7711        	slli	a7, a7, 5
  90d56d:	076602        	or	a6, a6, a7
  90d570:	262487        	s8i	a6, a2, 135
		tmp->bf_flags = bf->bf_flags;
  90d573:	263144        	l16ui	a6, a3, 136
  90d576:	262544        	s16i	a6, a2, 136
		tmp->bf_state = bf->bf_state;
  90d579:	5b657a        	call8	8e6b64 <memcpy>
		tmp->bf_retries = bf->bf_retries;
  90d57c:	263086        	l8ui	a6, a3, 134
		tmp->bf_comp = bf->bf_comp;
		tmp->bf_nframes = bf->bf_nframes;
		tmp->bf_cookie = bf->bf_cookie;

		bf->bf_isaggr = 0;
		bf->bf_next = NULL;
  90d57f:	c080      	movi.n	a8, 0
		tmp->bf_skb = bf->bf_skb;
		tmp->bf_node = bf->bf_node;
		tmp->bf_isaggr = bf->bf_isaggr;
		tmp->bf_flags = bf->bf_flags;
		tmp->bf_state = bf->bf_state;
		tmp->bf_retries = bf->bf_retries;
  90d581:	262486        	s8i	a6, a2, 134
		tmp->bf_comp = bf->bf_comp;
  90d584:	863f      	l32i.n	a6, a3, 60
		bf->bf_comp = NULL;

		bf->bf_retries = 0;
		bf->bf_nframes = 0;

		ath_dma_map(sc, tmp);
  90d586:	da50      	mov.n	a10, a5
		tmp->bf_node = bf->bf_node;
		tmp->bf_isaggr = bf->bf_isaggr;
		tmp->bf_flags = bf->bf_flags;
		tmp->bf_state = bf->bf_state;
		tmp->bf_retries = bf->bf_retries;
		tmp->bf_comp = bf->bf_comp;
  90d588:	962f      	s32i.n	a6, a2, 60
		tmp->bf_nframes = bf->bf_nframes;
  90d58a:	26304c        	l8ui	a6, a3, 76
		bf->bf_comp = NULL;

		bf->bf_retries = 0;
		bf->bf_nframes = 0;

		ath_dma_map(sc, tmp);
  90d58d:	db20      	mov.n	a11, a2
		tmp->bf_isaggr = bf->bf_isaggr;
		tmp->bf_flags = bf->bf_flags;
		tmp->bf_state = bf->bf_state;
		tmp->bf_retries = bf->bf_retries;
		tmp->bf_comp = bf->bf_comp;
		tmp->bf_nframes = bf->bf_nframes;
  90d58f:	26244c        	s8i	a6, a2, 76
		tmp->bf_cookie = bf->bf_cookie;
  90d592:	263092        	l8ui	a6, a3, 146

		bf->bf_isaggr = 0;
		bf->bf_next = NULL;
  90d595:	983b      	s32i.n	a8, a3, 44
		tmp->bf_flags = bf->bf_flags;
		tmp->bf_state = bf->bf_state;
		tmp->bf_retries = bf->bf_retries;
		tmp->bf_comp = bf->bf_comp;
		tmp->bf_nframes = bf->bf_nframes;
		tmp->bf_cookie = bf->bf_cookie;
  90d597:	262492        	s8i	a6, a2, 146

		bf->bf_isaggr = 0;
  90d59a:	263087        	l8ui	a6, a3, 135
		bf->bf_next = NULL;
		bf->bf_skb = NULL;
  90d59d:	9838      	s32i.n	a8, a3, 32
		tmp->bf_retries = bf->bf_retries;
		tmp->bf_comp = bf->bf_comp;
		tmp->bf_nframes = bf->bf_nframes;
		tmp->bf_cookie = bf->bf_cookie;

		bf->bf_isaggr = 0;
  90d59f:	046401        	and	a4, a6, a4
  90d5a2:	243487        	s8i	a4, a3, 135
		bf->bf_next = NULL;
		bf->bf_skb = NULL;
		bf->bf_node = NULL;
  90d5a5:	9834      	s32i.n	a8, a3, 16
		bf->bf_flags = 0;
  90d5a7:	283544        	s16i	a8, a3, 136
		bf->bf_comp = NULL;
  90d5aa:	28360f        	s32i	a8, a3, 60

		bf->bf_retries = 0;
  90d5ad:	283486        	s8i	a8, a3, 134
		bf->bf_nframes = 0;
  90d5b0:	28344c        	s8i	a8, a3, 76

		bf->bf_isaggr = 0;
		bf->bf_next = NULL;
		bf->bf_skb = NULL;
		bf->bf_node = NULL;
		bf->bf_flags = 0;
  90d5b3:	088402        	or	a4, a8, a8
		bf->bf_comp = NULL;

		bf->bf_retries = 0;
		bf->bf_nframes = 0;

		ath_dma_map(sc, tmp);
  90d5b6:	5bffba        	call8	90d4a0 <ath_dma_map>
		ath_tx_tgt_setds(sc, tmp);
  90d5b9:	da50      	mov.n	a10, a5
  90d5bb:	db20      	mov.n	a11, a2
  90d5bd:	5bfef6        	call8	90d198 <ath_tx_tgt_setds>
	}

	sc->sc_txbuf_held = bf;
  90d5c0:	2356dc        	s32i	a3, a5, 0x370

	return tmp;
}
  90d5c3:	d10f      	retw.n
  90d5c5:	000000        	ill

0090d5c8 <ath_tx_freebuf>:
	bf->bf_txq_add(sc, bf);
}

static void
ath_tx_freebuf(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90d5c8:	6c1004        	entry	a1, 32
	a_int32_t i ;
	struct ath_tx_desc *bfd = NULL;
	struct ath_hal *ah = sc->sc_ah;
  90d5cb:	242d05        	addmi	a4, a2, 0x500
  90d5ce:	864b      	l32i.n	a6, a4, 44

	for (bfd = bf->bf_desc, i = 0; i < bf->bf_dmamap_info.nsegs; bfd++, i++) {
  90d5d0:	c050      	movi.n	a5, 0
  90d5d2:	843c      	l32i.n	a4, a3, 48
  90d5d4:	270a88        	movi	a7, 136
  90d5d7:	600023        	j	90d5fe <ath_tx_freebuf+0x36>
  90d5da:	000028        	mull	a0, a0, a0
		ah->ah_clr11nAggr(bfd);
  90d5dd:	6214da        	j	8eeabb <memset+0x7c73>
  90d5e0:	400b80        	excw
  90d5e3:	002862        	excw
		ah->ah_set11nBurstDuration(bfd, 0);
  90d5e6:	15044a        	l32r	a5, 8ce710 <_bss_end+0x3bb800>
  90d5e9:	022b0a        	addx4	a11, a2, a2
  90d5ec:	000b80        	excw
  90d5ef:	002862        	excw
		ah->ah_set11nVirtualMoreFrag(bfd, 0);
  90d5f2:	16da40        	l32r	a6, 903ef4 <memset+0x1d0ac>
  90d5f5:	c0b0      	movi.n	a11, 0
  90d5f7:	0b8000        	callx8	a8
{
	a_int32_t i ;
	struct ath_tx_desc *bfd = NULL;
	struct ath_hal *ah = sc->sc_ah;

	for (bfd = bf->bf_desc, i = 0; i < bf->bf_dmamap_info.nsegs; bfd++, i++) {
  90d5fa:	a744      	add.n	a4, a4, a7
  90d5fc:	b155      	addi.n	a5, a5, 1
  90d5fe:	283201        	l32i	a8, a3, 4
  90d601:	7853d7        	bltu	a5, a8, 90d5dc <ath_tx_freebuf+0x14>
		ah->ah_clr11nAggr(bfd);
		ah->ah_set11nBurstDuration(bfd, 0);
		ah->ah_set11nVirtualMoreFrag(bfd, 0);
	}

	ath_dma_unmap(sc, bf);
  90d604:	033b02        	or	a11, a3, a3
  90d607:	022a02        	or	a10, a2, a2
  90d60a:	5bfea9        	call8	90d0b0 <ath_dma_unmap>

	ath_tgt_skb_free(sc, &bf->bf_skbhead,bf->bf_endpt);
  90d60d:	2c3223        	l32i	a12, a3, 140
  90d610:	2b3c14        	addi	a11, a3, 20
  90d613:	022a02        	or	a10, a2, a2
  90d616:	5bfeac        	call8	90d0c8 <ath_tgt_skb_free>

	bf->bf_skb = NULL;
  90d619:	c040      	movi.n	a4, 0
  90d61b:	9438      	s32i.n	a4, a3, 32
	bf->bf_comp = NULL;
  90d61d:	943f      	s32i.n	a4, a3, 60
	bf->bf_node = NULL;
  90d61f:	9434      	s32i.n	a4, a3, 16
	bf->bf_next = NULL;
  90d621:	943b      	s32i.n	a4, a3, 44
	bf = ath_buf_toggle(sc, bf, 0);
  90d623:	db30      	mov.n	a11, a3
  90d625:	dc40      	mov.n	a12, a4
  90d627:	da20      	mov.n	a10, a2
  90d629:	5bffa3        	call8	90d4b8 <ath_buf_toggle>
	bf->bf_retries = 0;
	bf->bf_isretried = 0;
  90d62c:	26a087        	l8ui	a6, a10, 135
  90d62f:	c65f      	movi.n	a5, -17
  90d631:	056501        	and	a5, a6, a5
	bf->bf_skb = NULL;
	bf->bf_comp = NULL;
	bf->bf_node = NULL;
	bf->bf_next = NULL;
	bf = ath_buf_toggle(sc, bf, 0);
	bf->bf_retries = 0;
  90d634:	24a486        	s8i	a4, a10, 134
	bf->bf_isretried = 0;
  90d637:	25a487        	s8i	a5, a10, 135

	if (bf != NULL)
		asf_tailq_insert_tail(&sc->sc_txbuf, bf, bf_list);
  90d63a:	94a9      	s32i.n	a4, a10, 36
  90d63c:	2422f1        	l32i	a4, a2, 0x3c4
  90d63f:	23ac24        	addi	a3, a10, 36
  90d642:	94aa      	s32i.n	a4, a10, 40
  90d644:	9a40      	s32i.n	a10, a4, 0
  90d646:	2326f1        	s32i	a3, a2, 0x3c4
  90d649:	d10f      	retw.n
	...

0090d64c <ath_buf_comp>:
		ath_free_tx_skb(sc->tgt_htc_handle,endpt,tskb);
	}
}

static void ath_buf_comp(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90d64c:	6c1004        	entry	a1, 32
	ath_dma_unmap(sc, bf);
  90d64f:	022a02        	or	a10, a2, a2
  90d652:	033b02        	or	a11, a3, a3
  90d655:	5bfe96        	call8	90d0b0 <ath_dma_unmap>
	ath_tgt_skb_free(sc, &bf->bf_skbhead,bf->bf_endpt);
  90d658:	2c3223        	l32i	a12, a3, 140
  90d65b:	022a02        	or	a10, a2, a2
  90d65e:	2b3c14        	addi	a11, a3, 20
  90d661:	5bfe99        	call8	90d0c8 <ath_tgt_skb_free>
	bf->bf_skb = NULL;
  90d664:	c040      	movi.n	a4, 0
  90d666:	9438      	s32i.n	a4, a3, 32
	bf->bf_node = NULL;
  90d668:	9434      	s32i.n	a4, a3, 16
	bf = ath_buf_toggle(sc, bf, 0);
  90d66a:	da20      	mov.n	a10, a2
  90d66c:	033b02        	or	a11, a3, a3
  90d66f:	dc40      	mov.n	a12, a4
  90d671:	5bff91        	call8	90d4b8 <ath_buf_toggle>
	if (bf != NULL) {
  90d674:	74a10e        	beq	a10, a4, 90d686 <ath_buf_comp+0x3a>
		asf_tailq_insert_tail(&sc->sc_txbuf, bf, bf_list);
  90d677:	2322f1        	l32i	a3, a2, 0x3c4
  90d67a:	94a9      	s32i.n	a4, a10, 36
  90d67c:	93aa      	s32i.n	a3, a10, 40
  90d67e:	9a30      	s32i.n	a10, a3, 0
  90d680:	2aac24        	addi	a10, a10, 36
  90d683:	2a26f1        	s32i	a10, a2, 0x3c4
  90d686:	d10f      	retw.n

0090d688 <ath_bar_tx>:
	ath_buf_comp(sc, bf);
}

static void ath_bar_tx(struct ath_softc_tgt *sc,
		       ath_atx_tid_t *tid, struct ath_tx_buf *bf)
{
  90d688:	6c101a        	entry	a1, 208
  90d68b:	033702        	or	a7, a3, a3
	adf_nbuf_t skb;
	struct ieee80211_frame_bar *bar;
	u_int8_t min_rate;
	struct ath_tx_desc *ds, *ds0;
	struct ath_hal *ah = sc->sc_ah;
  90d68e:	232d05        	addmi	a3, a2, 0x500
  90d691:	23320b        	l32i	a3, a3, 44
  90d694:	2b0a70        	movi	a11, 112
  90d697:	231628        	s32i	a3, a1, 160
	int i = 0;
	adf_nbuf_queue_t skbhead;
	a_uint8_t *anbdata;
	a_uint32_t anblen;

	__stats(sc, tx_bars);
  90d69a:	232278        	l32i	a3, a2, 0x1e0
  90d69d:	2a1c20        	addi	a10, a1, 32
  90d6a0:	b133      	addi.n	a3, a3, 1
  90d6a2:	232678        	s32i	a3, a2, 0x1e0
  90d6a5:	5bfefa        	call8	90d290 <__adf_os_mem_set$constprop$13>

	adf_os_mem_set(&series, 0, sizeof(series));

	ath_aggr_pause_tid(sc, tid);

	skb = adf_nbuf_queue_remove(&bf->bf_skbhead);
  90d6a8:	254c14        	addi	a5, a4, 20
}

static inline void
ath_aggr_pause_tid(struct ath_softc_tgt *sc, ath_atx_tid_t *tid)
{
	tid->paused =1;
  90d6ab:	c031      	movi.n	a3, 1
  90d6ad:	237434        	s8i	a3, a7, 52
 * @return The head buf in the buf queue.
 */
static inline adf_nbuf_t
adf_nbuf_queue_remove(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_remove(head);
  90d6b0:	da50      	mov.n	a10, a5
  90d6b2:	5be4e1        	call8	906a38 <__adf_nbuf_queue_remove>
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  90d6b5:	261c20        	addi	a6, a1, 32
  90d6b8:	2c6c70        	addi	a12, a6, 112
  90d6bb:	2b6c74        	addi	a11, a6, 116
 * @return The head buf in the buf queue.
 */
static inline adf_nbuf_t
adf_nbuf_queue_remove(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_remove(head);
  90d6be:	0aa302        	or	a3, a10, a10
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  90d6c1:	5be577        	call8	906ca0 <__adf_nbuf_peek_header>
 * @return none
 */
static inline void
adf_nbuf_trim_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    __adf_nbuf_trim_tail(buf, size);
  90d6c4:	2b1224        	l32i	a11, a1, 144
  90d6c7:	da30      	mov.n	a10, a3
  90d6c9:	5be54a        	call8	906bf4 <__adf_nbuf_trim_tail>
	adf_nbuf_trim_tail(skb, anblen);
	bar = (struct ieee80211_frame_bar *) anbdata;

	min_rate =  0x0b;

	ath_dma_unmap(sc, bf);
  90d6cc:	da20      	mov.n	a10, a2
  90d6ce:	db40      	mov.n	a11, a4
	ath_aggr_pause_tid(sc, tid);

	skb = adf_nbuf_queue_remove(&bf->bf_skbhead);
	adf_nbuf_peek_header(skb, &anbdata, &anblen);
	adf_nbuf_trim_tail(skb, anblen);
	bar = (struct ieee80211_frame_bar *) anbdata;
  90d6d0:	261225        	l32i	a6, a1, 148

	min_rate =  0x0b;

	ath_dma_unmap(sc, bf);
  90d6d3:	5bfe77        	call8	90d0b0 <ath_dma_unmap>
 * @param[in] buf   buf
 */
static inline void
adf_nbuf_queue_add(adf_nbuf_queue_t *head, adf_nbuf_t buf)
{
    __adf_nbuf_queue_add(head, buf);
  90d6d6:	da50      	mov.n	a10, a5
  90d6d8:	033b02        	or	a11, a3, a3
	adf_nbuf_queue_add(&bf->bf_skbhead, skb);

	bar->i_fc[1] = IEEE80211_FC1_DIR_NODS;
  90d6db:	c050      	movi.n	a5, 0
  90d6dd:	5be4ce        	call8	906a18 <__adf_nbuf_queue_add>
  90d6e0:	256401        	s8i	a5, a6, 1
	bar->i_fc[0] = IEEE80211_FC0_VERSION_0 |
  90d6e3:	25fa84        	movi	a5, -124
  90d6e6:	256400        	s8i	a5, a6, 0
		IEEE80211_FC0_TYPE_CTL |
		IEEE80211_FC0_SUBTYPE_BAR;
	bar->i_ctl = tid->tidno << IEEE80211_BAR_CTL_TID_S |
  90d6e9:	8970      	l32i.n	a9, a7, 0
  90d6eb:	c054      	movi.n	a5, 4
  90d6ed:	049911        	slli	a9, a9, 12
  90d6f0:	059902        	or	a9, a9, a5
  90d6f3:	09094f        	extui	a9, a9, 0, 16
  90d6f6:	098a14        	srli	a10, a9, 8
  90d6f9:	2a6410        	s8i	a10, a6, 16
  90d6fc:	296411        	s8i	a9, a6, 17
		IEEE80211_BAR_CTL_COMBA;
	bar->i_seq = adf_os_cpu_to_le16(tid->seq_start << IEEE80211_SEQ_SEQ_SHIFT);
  90d6ff:	297102        	l16ui	a9, a7, 4

	bar->i_fc[1] = IEEE80211_FC1_DIR_NODS;
	bar->i_fc[0] = IEEE80211_FC0_VERSION_0 |
		IEEE80211_FC0_TYPE_CTL |
		IEEE80211_FC0_SUBTYPE_BAR;
	bar->i_ctl = tid->tidno << IEEE80211_BAR_CTL_TID_S |
  90d702:	c050      	movi.n	a5, 0
		IEEE80211_BAR_CTL_COMBA;
	bar->i_seq = adf_os_cpu_to_le16(tid->seq_start << IEEE80211_SEQ_SEQ_SHIFT);
  90d704:	0c9911        	slli	a9, a9, 4
  90d707:	09094f        	extui	a9, a9, 0, 16

#undef adf_os_cpu_to_le16

static a_uint16_t adf_os_cpu_to_le16(a_uint16_t x)
{
	return ((((x) & 0xff00) >> 8) |   (((x) & 0x00ff) << 8));
  90d70a:	089b11        	slli	a11, a9, 8
  90d70d:	098a14        	srli	a10, a9, 8
  90d710:	0aba02        	or	a10, a11, a10
	bar->i_fc[0] = IEEE80211_FC0_VERSION_0 |
		IEEE80211_FC0_TYPE_CTL |
		IEEE80211_FC0_SUBTYPE_BAR;
	bar->i_ctl = tid->tidno << IEEE80211_BAR_CTL_TID_S |
		IEEE80211_BAR_CTL_COMBA;
	bar->i_seq = adf_os_cpu_to_le16(tid->seq_start << IEEE80211_SEQ_SEQ_SHIFT);
  90d713:	0a0a4f        	extui	a10, a10, 0, 16
  90d716:	0a8b14        	srli	a11, a10, 8
  90d719:	2b6412        	s8i	a11, a6, 18
  90d71c:	2a6413        	s8i	a10, a6, 19

	bf->bf_seqno = tid->seq_start << IEEE80211_SEQ_SEQ_SHIFT;
  90d71f:	294523        	s16i	a9, a4, 70
 *         put, or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_put_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_put_tail(buf, size);
  90d722:	da30      	mov.n	a10, a3
  90d724:	c1b4      	movi.n	a11, 20
  90d726:	5be542        	call8	906c30 <__adf_nbuf_put_tail>

	adf_nbuf_put_tail(skb, sizeof(struct ieee80211_frame_bar));

	bf->bf_comp = ath_bar_tx_comp;
  90d729:	166b00        	l32r	a6, 8e832c <memset+0x14e4>
	bf->bf_tidno = tid->tidno;
	bf->bf_node = &tid->an->ni;
	ath_dma_map(sc, bf);
  90d72c:	da20      	mov.n	a10, a2

	bf->bf_seqno = tid->seq_start << IEEE80211_SEQ_SEQ_SHIFT;

	adf_nbuf_put_tail(skb, sizeof(struct ieee80211_frame_bar));

	bf->bf_comp = ath_bar_tx_comp;
  90d72e:	964f      	s32i.n	a6, a4, 60
	bf->bf_tidno = tid->tidno;
  90d730:	8670      	l32i.n	a6, a7, 0
	bf->bf_node = &tid->an->ni;
	ath_dma_map(sc, bf);
  90d732:	db40      	mov.n	a11, a4
	bf->bf_seqno = tid->seq_start << IEEE80211_SEQ_SEQ_SHIFT;

	adf_nbuf_put_tail(skb, sizeof(struct ieee80211_frame_bar));

	bf->bf_comp = ath_bar_tx_comp;
	bf->bf_tidno = tid->tidno;
  90d734:	26444d        	s8i	a6, a4, 77
	bf->bf_node = &tid->an->ni;
  90d737:	867e      	l32i.n	a6, a7, 56
  90d739:	9644      	s32i.n	a6, a4, 16
	ath_dma_map(sc, bf);
  90d73b:	5bff59        	call8	90d4a0 <ath_dma_map>
 * @param[out] sg   map info
 */
static inline void
adf_nbuf_dmamap_info(adf_os_dma_map_t bmap, adf_os_dmamap_info_t *sg)
{
    __adf_nbuf_dmamap_info(bmap, sg);
  90d73e:	8a40      	l32i.n	a10, a4, 0
  90d740:	b44b      	addi.n	a11, a4, 4
  90d742:	5be4d6        	call8	906a9c <__adf_nbuf_dmamap_info>
	adf_nbuf_dmamap_info(bf->bf_dmamap, &bf->bf_dmamap_info);

	ds = bf->bf_desc;
	ah->ah_setupTxDesc(ds
  90d745:	291228        	l32i	a9, a1, 160
 * @return The total length of this buf.
 */
static inline adf_os_size_t
adf_nbuf_len(adf_nbuf_t buf)
{
    return (__adf_nbuf_len(buf));
  90d748:	da30      	mov.n	a10, a3
  90d74a:	289217        	l32i	a8, a9, 92
	bf->bf_tidno = tid->tidno;
	bf->bf_node = &tid->an->ni;
	ath_dma_map(sc, bf);
	adf_nbuf_dmamap_info(bf->bf_dmamap, &bf->bf_dmamap_info);

	ds = bf->bf_desc;
  90d74d:	864c      	l32i.n	a6, a4, 48
  90d74f:	281629        	s32i	a8, a1, 164
  90d752:	5be54b        	call8	906c80 <__adf_nbuf_len>
	ah->ah_setupTxDesc(ds
  90d755:	234049        	l8ui	a3, a4, 73
  90d758:	c0fb      	movi.n	a15, 11
  90d75a:	9311      	s32i.n	a3, a1, 4
  90d75c:	281229        	l32i	a8, a1, 164
  90d75f:	c131      	movi.n	a3, 17
  90d761:	b4ab      	addi.n	a11, a10, 4
  90d763:	9312      	s32i.n	a3, a1, 8
  90d765:	da60      	mov.n	a10, a6
  90d767:	9f10      	s32i.n	a15, a1, 0
  90d769:	9513      	s32i.n	a5, a1, 12
  90d76b:	9514      	s32i.n	a5, a1, 16
  90d76d:	dc50      	mov.n	a12, a5
  90d76f:	055d02        	or	a13, a5, a5
  90d772:	2e0a3c        	movi	a14, 60
  90d775:	0b8000        	callx8	a8
			    , HAL_TXDESC_INTREQ
			    | HAL_TXDESC_CLRDMASK
			    , 0, 0);

	skbhead = bf->bf_skbhead;
	bf->bf_isaggr = 0;
  90d778:	284087        	l8ui	a8, a4, 135
  90d77b:	23fadf        	movi	a3, -33
  90d77e:	038301        	and	a3, a8, a3
  90d781:	234487        	s8i	a3, a4, 135
	bf->bf_next = NULL;
  90d784:	954b      	s32i.n	a5, a4, 44

	for (ds0 = ds, i=0; i < bf->bf_dmamap_info.nsegs; ds0++, i++) {
  90d786:	d360      	mov.n	a3, a6
  90d788:	260a88        	movi	a6, 136
  90d78b:	600011        	j	90d7a0 <ath_bar_tx+0x118>
  90d78e:	000000        	ill
		ah->ah_clr11nAggr(ds0);
  90d791:	291228        	l32i	a9, a1, 160
  90d794:	da30      	mov.n	a10, a3
  90d796:	289214        	l32i	a8, a9, 80

	skbhead = bf->bf_skbhead;
	bf->bf_isaggr = 0;
	bf->bf_next = NULL;

	for (ds0 = ds, i=0; i < bf->bf_dmamap_info.nsegs; ds0++, i++) {
  90d799:	a633      	add.n	a3, a3, a6
		ah->ah_clr11nAggr(ds0);
  90d79b:	0b8000        	callx8	a8

	skbhead = bf->bf_skbhead;
	bf->bf_isaggr = 0;
	bf->bf_next = NULL;

	for (ds0 = ds, i=0; i < bf->bf_dmamap_info.nsegs; ds0++, i++) {
  90d79e:	b155      	addi.n	a5, a5, 1
  90d7a0:	8841      	l32i.n	a8, a4, 4
  90d7a2:	7853eb        	bltu	a5, a8, 90d791 <ath_bar_tx+0x109>
		ah->ah_clr11nAggr(ds0);
	}

	ath_filltxdesc(sc, bf);
  90d7a5:	da20      	mov.n	a10, a2
  90d7a7:	db40      	mov.n	a11, a4
  90d7a9:	5bfe51        	call8	90d0f0 <ath_filltxdesc>

	for (i = 0 ; i < 4; i++) {
		series[i].Tries = ATH_TXMAXTRY;
		series[i].Rate = min_rate;
		series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
  90d7ac:	232d16        	addmi	a3, a2, 0x1600
  90d7af:	281c20        	addi	a8, a1, 32
  90d7b2:	263026        	l8ui	a6, a3, 38

	bf->bf_comp = NULL;
	ath_buf_comp(sc, bf);
}

static void ath_bar_tx(struct ath_softc_tgt *sc,
  90d7b5:	258c70        	addi	a5, a8, 112
	}

	ath_filltxdesc(sc, bf);

	for (i = 0 ; i < 4; i++) {
		series[i].Tries = ATH_TXMAXTRY;
  90d7b8:	c03b      	movi.n	a3, 11
  90d7ba:	9380      	s32i.n	a3, a8, 0
		series[i].Rate = min_rate;
  90d7bc:	9381      	s32i.n	a3, a8, 4
		series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
  90d7be:	9683      	s32i.n	a6, a8, 12
  90d7c0:	288c1c        	addi	a8, a8, 28
		ah->ah_clr11nAggr(ds0);
	}

	ath_filltxdesc(sc, bf);

	for (i = 0 ; i < 4; i++) {
  90d7c3:	7589f3        	bne	a8, a5, 90d7ba <ath_bar_tx+0x132>
		series[i].Tries = ATH_TXMAXTRY;
		series[i].Rate = min_rate;
		series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
	}

	ah->ah_set11nRateScenario(bf->bf_desc, 0, 0, series, 4, 4);
  90d7c6:	251228        	l32i	a5, a1, 160
  90d7c9:	8a4c      	l32i.n	a10, a4, 48
  90d7cb:	c0b0      	movi.n	a11, 0
  90d7cd:	c0e4      	movi.n	a14, 4
  90d7cf:	235210        	l32i	a3, a5, 64
  90d7d2:	dcb0      	mov.n	a12, a11
  90d7d4:	2d1c20        	addi	a13, a1, 32
  90d7d7:	0eef02        	or	a15, a14, a14
  90d7da:	0b3000        	callx8	a3
	ath_tgt_txq_add_ucast(sc, bf);
  90d7dd:	da20      	mov.n	a10, a2
  90d7df:	db40      	mov.n	a11, a4
  90d7e1:	5bfddc        	call8	90cf54 <ath_tgt_txq_add_ucast>
  90d7e4:	d10f      	retw.n
	...

0090d7e8 <ATH_SKB_2_WH>:
int ath_tgt_tx_add_to_aggr(struct ath_softc_tgt *sc,
			   struct ath_buf *bf,int datatype,
			   ath_atx_tid_t *tid, int is_burst);

struct ieee80211_frame *ATH_SKB_2_WH(adf_nbuf_t skb)
{
  90d7e8:	6c1006        	entry	a1, 48
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  90d7eb:	da20      	mov.n	a10, a2
  90d7ed:	b41b      	addi.n	a11, a1, 4
  90d7ef:	dc10      	mov.n	a12, a1
  90d7f1:	5be52b        	call8	906ca0 <__adf_nbuf_peek_header>
	a_uint32_t anblen;

	adf_nbuf_peek_header(skb, &anbdata, &anblen);

	return((struct ieee80211_frame *)anbdata);
}
  90d7f4:	8211      	l32i.n	a2, a1, 4
  90d7f6:	d10f      	retw.n

0090d7f8 <ath_tx_set_retry>:
		INCR(tid->baw_head, ATH_TID_MAX_BUFS);
	}
}

static void ath_tx_set_retry(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90d7f8:	6c1004        	entry	a1, 32
	struct ieee80211_frame *wh;

	__stats(sc, txaggr_retries);
  90d7fb:	282260        	l32i	a8, a2, 0x180

	bf->bf_isretried = 1;
	bf->bf_retries ++;
	wh = ATH_SKB_2_WH(bf->bf_skb);
  90d7fe:	8a38      	l32i.n	a10, a3, 32

static void ath_tx_set_retry(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ieee80211_frame *wh;

	__stats(sc, txaggr_retries);
  90d800:	b188      	addi.n	a8, a8, 1
  90d802:	282660        	s32i	a8, a2, 0x180

	bf->bf_isretried = 1;
  90d805:	283087        	l8ui	a8, a3, 135
  90d808:	c120      	movi.n	a2, 16
  90d80a:	028202        	or	a2, a8, a2
  90d80d:	223487        	s8i	a2, a3, 135
	bf->bf_retries ++;
  90d810:	223086        	l8ui	a2, a3, 134
  90d813:	222c01        	addi	a2, a2, 1
  90d816:	223486        	s8i	a2, a3, 134
	wh = ATH_SKB_2_WH(bf->bf_skb);
  90d819:	5bfff3        	call8	90d7e8 <ATH_SKB_2_WH>
	wh->i_fc[1] |= IEEE80211_FC1_RETRY;
  90d81c:	23a001        	l8ui	a3, a10, 1
  90d81f:	c028      	movi.n	a2, 8
  90d821:	023202        	or	a2, a3, a2
  90d824:	22a401        	s8i	a2, a10, 1
  90d827:	d10f      	retw.n
  90d829:	000000        	ill

0090d82c <owl_tgt_node_init>:
		ath_aggr_resume_tid(sc, tid);
	}
}

void owl_tgt_node_init(struct ath_node_target * an)
{
  90d82c:	6c1004        	entry	a1, 32
	struct ath_atx_tid *tid;
	int tidno;

	for (tidno = 0, tid = &an->tid[tidno]; tidno < WME_NUM_TID;tidno++, tid++) {
  90d82f:	232c24        	addi	a3, a2, 36
  90d832:	240a00        	movi	a4, 0
		tid->tidno = tidno;
		tid->an = an;

		if ( tid->flag & TID_CLEANUP_INPROGRES ) {
			tid->flag |= TID_REINITIALIZE;
  90d835:	250a04        	movi	a5, 4

	for (tidno = 0, tid = &an->tid[tidno]; tidno < WME_NUM_TID;tidno++, tid++) {
		tid->tidno = tidno;
		tid->an = an;

		if ( tid->flag & TID_CLEANUP_INPROGRES ) {
  90d838:	283036        	l8ui	a8, a3, 54
{
	struct ath_atx_tid *tid;
	int tidno;

	for (tidno = 0, tid = &an->tid[tidno]; tidno < WME_NUM_TID;tidno++, tid++) {
		tid->tidno = tidno;
  90d83b:	9430      	s32i.n	a4, a3, 0
		tid->an = an;
  90d83d:	923e      	s32i.n	a2, a3, 56

		if ( tid->flag & TID_CLEANUP_INPROGRES ) {
  90d83f:	7f871d        	bbci	a8, 31, 90d860 <owl_tgt_node_init+0x34>
			tid->flag |= TID_REINITIALIZE;
  90d842:	058802        	or	a8, a8, a5
  90d845:	283436        	s8i	a8, a3, 54
			adf_os_print("tid[%p]->incomp is not 0: %d\n",
  90d848:	186915        	l32r	a8, 8e7c9c <memset+0xe54>
  90d84b:	2c3037        	l8ui	a12, a3, 55
  90d84e:	288212        	l32i	a8, a8, 72
  90d851:	1a6b01        	l32r	a10, 8e8458 <memset+0x1610>
  90d854:	db30      	mov.n	a11, a3
  90d856:	00cc32        	sext	a12, a12, 7
  90d859:	0b8000        	callx8	a8
  90d85c:	600005        	j	90d865 <owl_tgt_node_init+0x39>
  90d85f:	00da30        	excw
				     tid, tid->incomp);
		} else {
			owl_tgt_tid_init(tid);
  90d862:	5bfda9        	call8	90cf08 <owl_tgt_tid_init>
void owl_tgt_node_init(struct ath_node_target * an)
{
	struct ath_atx_tid *tid;
	int tidno;

	for (tidno = 0, tid = &an->tid[tidno]; tidno < WME_NUM_TID;tidno++, tid++) {
  90d865:	b144      	addi.n	a4, a4, 1
  90d867:	233c3c        	addi	a3, a3, 60
  90d86a:	6948ca        	bnei	a4, 8, 90d838 <owl_tgt_node_init+0xc>
				     tid, tid->incomp);
		} else {
			owl_tgt_tid_init(tid);
		}
	}
}
  90d86d:	d10f      	retw.n
	...

0090d870 <ath_tx_status_clear>:

void ath_tx_status_clear(struct ath_softc_tgt *sc)
{
  90d870:	6c1004        	entry	a1, 32
	int i;

	for (i = 0; i < 2; i++) {
		sc->tx_status[i].cnt = 0;
  90d873:	222d16        	addmi	a2, a2, 0x1600
  90d876:	c080      	movi.n	a8, 0
  90d878:	282438        	s8i	a8, a2, 56
  90d87b:	28245d        	s8i	a8, a2, 93
  90d87e:	d10f      	retw.n

0090d880 <ath_tx_status_update>:

	return txs;
}

void ath_tx_status_update(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90d880:	6c1004        	entry	a1, 32
	struct ath_tx_desc *ds = bf->bf_lastds;
	WMI_TXSTATUS_EVENT *txs;

	if (sc->sc_tx_draining)
  90d883:	282249        	l32i	a8, a2, 0x124
  90d886:	146abc        	l32r	a4, 8e8378 <memset+0x1530>

	return txs;
}

void ath_tx_status_update(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90d889:	da20      	mov.n	a10, a2
	struct ath_tx_desc *ds = bf->bf_lastds;
	WMI_TXSTATUS_EVENT *txs;

	if (sc->sc_tx_draining)
  90d88b:	048401        	and	a4, a8, a4
	return txs;
}

void ath_tx_status_update(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_tx_desc *ds = bf->bf_lastds;
  90d88e:	2c320e        	l32i	a12, a3, 56
	WMI_TXSTATUS_EVENT *txs;

	if (sc->sc_tx_draining)
  90d891:	654074        	bnez	a4, 90d909 <ath_tx_status_update+0x89>
{
	WMI_TXSTATUS_EVENT *txs = NULL;
	int i;

	for (i = 0; i < 2; i++) {
		if (sc->tx_status[i].cnt < HTC_MAX_TX_STATUS) {
  90d894:	292d16        	addmi	a9, a2, 0x1600
  90d897:	2b9038        	l8ui	a11, a9, 56
  90d89a:	280a0b        	movi	a8, 11
  90d89d:	7b8b07        	bgeu	a8, a11, 90d8a8 <ath_tx_status_update+0x28>
  90d8a0:	24905d        	l8ui	a4, a9, 93
  90d8a3:	748362        	bltu	a8, a4, 90d909 <ath_tx_status_update+0x89>
static WMI_TXSTATUS_EVENT *ath_tx_status_get(struct ath_softc_tgt *sc)
{
	WMI_TXSTATUS_EVENT *txs = NULL;
	int i;

	for (i = 0; i < 2; i++) {
  90d8a6:	c041      	movi.n	a4, 1
		if (sc->tx_status[i].cnt < HTC_MAX_TX_STATUS) {
			txs = &sc->tx_status[i];
  90d8a8:	04480b        	addx8	a8, a4, a4
  90d8ab:	04840a        	addx4	a4, a8, a4
  90d8ae:	186b02        	l32r	a8, 8e84b8 <memset+0x1670>

	txs = ath_tx_status_get(sc);
	if (txs == NULL)
		return;

	txs->txstatus[txs->cnt].ts_flags = 0;
  90d8b1:	c0b0      	movi.n	a11, 0
	WMI_TXSTATUS_EVENT *txs = NULL;
	int i;

	for (i = 0; i < 2; i++) {
		if (sc->tx_status[i].cnt < HTC_MAX_TX_STATUS) {
			txs = &sc->tx_status[i];
  90d8b3:	a844      	add.n	a4, a4, a8
  90d8b5:	a4a4      	add.n	a4, a10, a4

	txs = ath_tx_status_get(sc);
	if (txs == NULL)
		return;

	txs->txstatus[txs->cnt].ts_flags = 0;
  90d8b7:	284008        	l8ui	a8, a4, 8
	WMI_TXSTATUS_EVENT *txs = NULL;
	int i;

	for (i = 0; i < 2; i++) {
		if (sc->tx_status[i].cnt < HTC_MAX_TX_STATUS) {
			txs = &sc->tx_status[i];
  90d8ba:	2d4c08        	addi	a13, a4, 8

	txs = ath_tx_status_get(sc);
	if (txs == NULL)
		return;

	txs->txstatus[txs->cnt].ts_flags = 0;
  90d8bd:	088909        	addx2	a9, a8, a8
  90d8c0:	a9d9      	add.n	a9, a13, a9
  90d8c2:	2b9403        	s8i	a11, a9, 3

	txs->txstatus[txs->cnt].cookie = bf->bf_cookie;
  90d8c5:	2b3092        	l8ui	a11, a3, 146
  90d8c8:	2b9401        	s8i	a11, a9, 1
	txs->txstatus[txs->cnt].ts_rate = SM(bf->bf_endpt, ATH9K_HTC_TXSTAT_EPID);
  90d8cb:	2b3223        	l32i	a11, a3, 140
  90d8ce:	0cbb11        	slli	a11, a11, 4
  90d8d1:	2b9402        	s8i	a11, a9, 2

	if (ds->ds_txstat.ts_status & HAL_TXERR_FILT)
  90d8d4:	2bc066        	l8ui	a11, a12, 102
  90d8d7:	7eb705        	bbci	a11, 30, 90d8e0 <ath_tx_status_update+0x60>
		txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_FILT;
  90d8da:	2b0a02        	movi	a11, 2
  90d8dd:	2b9403        	s8i	a11, a9, 3

	if (!(ds->ds_txstat.ts_status & HAL_TXERR_XRETRY) &&
  90d8e0:	2bc066        	l8ui	a11, a12, 102
  90d8e3:	c197      	movi.n	a9, 23
  90d8e5:	79b80f        	bany	a11, a9, 90d8f8 <ath_tx_status_update+0x78>
	    !(ds->ds_txstat.ts_status & HAL_TXERR_FIFO) &&
	    !(ds->ds_txstat.ts_status & HAL_TXERR_TIMER_EXPIRED) &&
	    !(ds->ds_txstat.ts_status & HAL_TXERR_FILT))
		txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_ACK;
  90d8e8:	088809        	addx2	a8, a8, a8
  90d8eb:	a8d8      	add.n	a8, a13, a8
  90d8ed:	2b8003        	l8ui	a11, a8, 3
  90d8f0:	c091      	movi.n	a9, 1
  90d8f2:	09b902        	or	a9, a11, a9
  90d8f5:	298403        	s8i	a9, a8, 3

	ath_tx_status_update_rate(sc, bf->bf_rcs, ds->ds_txstat.ts_rate, txs);
  90d8f8:	2cc068        	l8ui	a12, a12, 104
  90d8fb:	2b3c50        	addi	a11, a3, 80
  90d8fe:	5bfd0a        	call8	90cd28 <ath_tx_status_update_rate>

	txs->cnt++;
  90d901:	234008        	l8ui	a3, a4, 8
  90d904:	b133      	addi.n	a3, a3, 1
  90d906:	234408        	s8i	a3, a4, 8
  90d909:	d10f      	retw.n
	...

0090d90c <ath_tx_status_update_aggr>:
}

void ath_tx_status_update_aggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
			       struct ath_tx_desc *ds, struct ath_rc_series rcs[],
			       int txok)
{
  90d90c:	6c1004        	entry	a1, 32
	WMI_TXSTATUS_EVENT *txs;

	if (sc->sc_tx_draining)
  90d90f:	282249        	l32i	a8, a2, 0x124
  90d912:	176abc        	l32r	a7, 8e8404 <memset+0x15bc>
}

void ath_tx_status_update_aggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
			       struct ath_tx_desc *ds, struct ath_rc_series rcs[],
			       int txok)
{
  90d915:	da20      	mov.n	a10, a2
	WMI_TXSTATUS_EVENT *txs;

	if (sc->sc_tx_draining)
  90d917:	078701        	and	a7, a8, a7
}

void ath_tx_status_update_aggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
			       struct ath_tx_desc *ds, struct ath_rc_series rcs[],
			       int txok)
{
  90d91a:	db50      	mov.n	a11, a5
	WMI_TXSTATUS_EVENT *txs;

	if (sc->sc_tx_draining)
  90d91c:	657058        	bnez	a7, 90d978 <ath_tx_status_update_aggr+0x6c>
{
	WMI_TXSTATUS_EVENT *txs = NULL;
	int i;

	for (i = 0; i < 2; i++) {
		if (sc->tx_status[i].cnt < HTC_MAX_TX_STATUS) {
  90d91f:	292d16        	addmi	a9, a2, 0x1600
  90d922:	2c9038        	l8ui	a12, a9, 56
  90d925:	280a0b        	movi	a8, 11
  90d928:	7c8b08        	bgeu	a8, a12, 90d934 <ath_tx_status_update_aggr+0x28>
  90d92b:	27905d        	l8ui	a7, a9, 93
  90d92e:	778346        	bltu	a8, a7, 90d978 <ath_tx_status_update_aggr+0x6c>
static WMI_TXSTATUS_EVENT *ath_tx_status_get(struct ath_softc_tgt *sc)
{
	WMI_TXSTATUS_EVENT *txs = NULL;
	int i;

	for (i = 0; i < 2; i++) {
  90d931:	270a01        	movi	a7, 1
		if (sc->tx_status[i].cnt < HTC_MAX_TX_STATUS) {
			txs = &sc->tx_status[i];
  90d934:	07780b        	addx8	a8, a7, a7
  90d937:	07870a        	addx4	a7, a8, a7
  90d93a:	186b02        	l32r	a8, 8e8544 <memset+0x16fc>

	txs = ath_tx_status_get(sc);
	if (txs == NULL)
		return;

	txs->txstatus[txs->cnt].cookie = bf->bf_cookie;
  90d93d:	293092        	l8ui	a9, a3, 146
	WMI_TXSTATUS_EVENT *txs = NULL;
	int i;

	for (i = 0; i < 2; i++) {
		if (sc->tx_status[i].cnt < HTC_MAX_TX_STATUS) {
			txs = &sc->tx_status[i];
  90d940:	a877      	add.n	a7, a7, a8
  90d942:	a7a7      	add.n	a7, a10, a7

	txs = ath_tx_status_get(sc);
	if (txs == NULL)
		return;

	txs->txstatus[txs->cnt].cookie = bf->bf_cookie;
  90d944:	287008        	l8ui	a8, a7, 8
	WMI_TXSTATUS_EVENT *txs = NULL;
	int i;

	for (i = 0; i < 2; i++) {
		if (sc->tx_status[i].cnt < HTC_MAX_TX_STATUS) {
			txs = &sc->tx_status[i];
  90d947:	b87d      	addi.n	a13, a7, 8

	txs = ath_tx_status_get(sc);
	if (txs == NULL)
		return;

	txs->txstatus[txs->cnt].cookie = bf->bf_cookie;
  90d949:	088809        	addx2	a8, a8, a8
  90d94c:	a8d8      	add.n	a8, a13, a8
  90d94e:	298401        	s8i	a9, a8, 1
	txs->txstatus[txs->cnt].ts_rate = SM(bf->bf_endpt, ATH9K_HTC_TXSTAT_EPID);
  90d951:	233223        	l32i	a3, a3, 140
  90d954:	0c3311        	slli	a3, a3, 4
  90d957:	238402        	s8i	a3, a8, 2

	if (txok)
  90d95a:	c86a      	beqz.n	a6, 90d968 <ath_tx_status_update_aggr+0x5c>
		txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_ACK;
  90d95c:	298003        	l8ui	a9, a8, 3
  90d95f:	230a01        	movi	a3, 1
  90d962:	039302        	or	a3, a9, a3
  90d965:	238403        	s8i	a3, a8, 3

	if (rcs)
  90d968:	c8b4      	beqz.n	a11, 90d970 <ath_tx_status_update_aggr+0x64>
		ath_tx_status_update_rate(sc, rcs, ds->ds_txstat.ts_rate, txs);
  90d96a:	2c4068        	l8ui	a12, a4, 104
  90d96d:	5bfcee        	call8	90cd28 <ath_tx_status_update_rate>

	txs->cnt++;
  90d970:	237008        	l8ui	a3, a7, 8
  90d973:	b133      	addi.n	a3, a3, 1
  90d975:	237408        	s8i	a3, a7, 8
  90d978:	d10f      	retw.n
	...

0090d97c <ath_tx_retry_subframe>:
}

static void
ath_tx_retry_subframe(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
		      ath_tx_bufhead *bf_q, struct ath_tx_buf **bar)
{
  90d97c:	6c1006        	entry	a1, 48
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
	struct ath_tx_desc *ds = NULL;
	struct ath_hal *ah = sc->sc_ah;
	int i = 0;

	__stats(sc, txaggr_compretries);
  90d97f:	262263        	l32i	a6, a2, 0x18c
}

static void
ath_tx_retry_subframe(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
		      ath_tx_bufhead *bf_q, struct ath_tx_buf **bar)
{
  90d982:	d850      	mov.n	a8, a5
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
	struct ath_tx_desc *ds = NULL;
	struct ath_hal *ah = sc->sc_ah;
	int i = 0;

	__stats(sc, txaggr_compretries);
  90d984:	b166      	addi.n	a6, a6, 1
{

	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
	struct ath_tx_desc *ds = NULL;
	struct ath_hal *ah = sc->sc_ah;
  90d986:	252d05        	addmi	a5, a2, 0x500
static void
ath_tx_retry_subframe(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
		      ath_tx_bufhead *bf_q, struct ath_tx_buf **bar)
{

	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
  90d989:	8c34      	l32i.n	a12, a3, 16
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90d98b:	29304d        	l8ui	a9, a3, 77
	struct ath_tx_desc *ds = NULL;
	struct ath_hal *ah = sc->sc_ah;
  90d98e:	855b      	l32i.n	a5, a5, 44
	int i = 0;

	__stats(sc, txaggr_compretries);
  90d990:	262663        	s32i	a6, a2, 0x18c

	for(ds = bf->bf_desc, i = 0; i < bf->bf_dmamap_info.nsegs; ds++, i++) {
  90d993:	c070      	movi.n	a7, 0
  90d995:	863c      	l32i.n	a6, a3, 48
  90d997:	2d0a88        	movi	a13, 136
  90d99a:	600030        	j	90d9ce <ath_tx_retry_subframe+0x52>
		ah->ah_clr11nAggr(ds);
  90d99d:	2b5214        	l32i	a11, a5, 80
  90d9a0:	da60      	mov.n	a10, a6
  90d9a2:	9813      	s32i.n	a8, a1, 12
  90d9a4:	9911      	s32i.n	a9, a1, 4
  90d9a6:	9c10      	s32i.n	a12, a1, 0
  90d9a8:	9d12      	s32i.n	a13, a1, 8
  90d9aa:	0bb000        	callx8	a11
		ah->ah_set11nBurstDuration(ds, 0);
  90d9ad:	2e5215        	l32i	a14, a5, 84
  90d9b0:	066a02        	or	a10, a6, a6
  90d9b3:	c0b0      	movi.n	a11, 0
  90d9b5:	0be000        	callx8	a14
		ah->ah_set11nVirtualMoreFrag(ds, 0);
  90d9b8:	2e5216        	l32i	a14, a5, 88
  90d9bb:	da60      	mov.n	a10, a6
  90d9bd:	c0b0      	movi.n	a11, 0
  90d9bf:	0be000        	callx8	a14
	struct ath_hal *ah = sc->sc_ah;
	int i = 0;

	__stats(sc, txaggr_compretries);

	for(ds = bf->bf_desc, i = 0; i < bf->bf_dmamap_info.nsegs; ds++, i++) {
  90d9c2:	8d12      	l32i.n	a13, a1, 8
  90d9c4:	8c10      	l32i.n	a12, a1, 0
  90d9c6:	8911      	l32i.n	a9, a1, 4
  90d9c8:	8813      	l32i.n	a8, a1, 12
  90d9ca:	ad66      	add.n	a6, a6, a13
  90d9cc:	b177      	addi.n	a7, a7, 1
  90d9ce:	8b31      	l32i.n	a11, a3, 4
  90d9d0:	7b73c9        	bltu	a7, a11, 90d99d <ath_tx_retry_subframe+0x21>
		ah->ah_clr11nAggr(ds);
		ah->ah_set11nBurstDuration(ds, 0);
		ah->ah_set11nVirtualMoreFrag(ds, 0);
	}

	if (bf->bf_retries >= OWLMAX_RETRIES) {
  90d9d3:	253086        	l8ui	a5, a3, 134
  90d9d6:	c069      	movi.n	a6, 9
  90d9d8:	756b40        	bgeu	a6, a5, 90da1c <ath_tx_retry_subframe+0xa0>
		__stats(sc, txaggr_xretries);
  90d9db:	242274        	l32i	a4, a2, 0x1d0
		ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90d9de:	2b3123        	l16ui	a11, a3, 70
		ah->ah_set11nBurstDuration(ds, 0);
		ah->ah_set11nVirtualMoreFrag(ds, 0);
	}

	if (bf->bf_retries >= OWLMAX_RETRIES) {
		__stats(sc, txaggr_xretries);
  90d9e1:	b144      	addi.n	a4, a4, 1
  90d9e3:	242674        	s32i	a4, a2, 0x1d0
ath_tx_retry_subframe(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
		      ath_tx_bufhead *bf_q, struct ath_tx_buf **bar)
{

	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90d9e6:	0c9411        	slli	a4, a9, 4
  90d9e9:	09490c        	sub	a9, a4, a9
  90d9ec:	0c9a0a        	addx4	a10, a9, a12
		ah->ah_set11nVirtualMoreFrag(ds, 0);
	}

	if (bf->bf_retries >= OWLMAX_RETRIES) {
		__stats(sc, txaggr_xretries);
		ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90d9ef:	2aac24        	addi	a10, a10, 36
  90d9f2:	0b4b14        	srli	a11, a11, 4
  90d9f5:	9813      	s32i.n	a8, a1, 12
  90d9f7:	5bfd96        	call8	90d050 <ath_tx_update_baw>
		ath_tx_status_update_aggr(sc, bf, bf->bf_lastds, NULL, 0);
  90d9fa:	c0d0      	movi.n	a13, 0
  90d9fc:	8c3e      	l32i.n	a12, a3, 56
  90d9fe:	da20      	mov.n	a10, a2
  90da00:	db30      	mov.n	a11, a3
  90da02:	0dde02        	or	a14, a13, a13
  90da05:	5bffc1        	call8	90d90c <ath_tx_status_update_aggr>

		if (!*bar)
  90da08:	8813      	l32i.n	a8, a1, 12
  90da0a:	8480      	l32i.n	a4, a8, 0
  90da0c:	cc42      	bnez.n	a4, 90da12 <ath_tx_retry_subframe+0x96>
			*bar = bf;
  90da0e:	9380      	s32i.n	a3, a8, 0
  90da10:	d10f      	retw.n
		else
			ath_tx_freebuf(sc, bf);
  90da12:	da20      	mov.n	a10, a2
  90da14:	db30      	mov.n	a11, a3
  90da16:	5bfeec        	call8	90d5c8 <ath_tx_freebuf>
  90da19:	d10f      	retw.n
  90da1b:	00853b        	movgez	a5, a8, a0
		return;
	}

	if (!bf->bf_next) {
  90da1e:	cd54      	bnez.n	a5, 90da36 <ath_tx_retry_subframe+0xba>
		__stats(sc, txaggr_errlast);
  90da20:	252267        	l32i	a5, a2, 0x19c
		bf = ath_buf_toggle(sc, bf, 1);
  90da23:	db30      	mov.n	a11, a3
			ath_tx_freebuf(sc, bf);
		return;
	}

	if (!bf->bf_next) {
		__stats(sc, txaggr_errlast);
  90da25:	b155      	addi.n	a5, a5, 1
  90da27:	252667        	s32i	a5, a2, 0x19c
		bf = ath_buf_toggle(sc, bf, 1);
  90da2a:	da20      	mov.n	a10, a2
  90da2c:	c0c1      	movi.n	a12, 1
  90da2e:	5bfea2        	call8	90d4b8 <ath_buf_toggle>
  90da31:	d3a0      	mov.n	a3, a10
  90da33:	60000d        	j	90da44 <ath_tx_retry_subframe+0xc8>
	} else
		bf->bf_lastds = &(bf->bf_descarr[bf->bf_dmamap_info.nsegs - 1]);
  90da36:	b0b5      	addi.n	a5, a11, -1
  90da38:	0c5611        	slli	a6, a5, 4
  90da3b:	a565      	add.n	a5, a6, a5
  90da3d:	863d      	l32i.n	a6, a3, 52
  90da3f:	06550b        	addx8	a5, a5, a6
  90da42:	953e      	s32i.n	a5, a3, 56

	ath_tx_set_retry(sc, bf);
  90da44:	da20      	mov.n	a10, a2
  90da46:	db30      	mov.n	a11, a3
	asf_tailq_insert_tail(bf_q, bf, bf_list);
  90da48:	c020      	movi.n	a2, 0
		__stats(sc, txaggr_errlast);
		bf = ath_buf_toggle(sc, bf, 1);
	} else
		bf->bf_lastds = &(bf->bf_descarr[bf->bf_dmamap_info.nsegs - 1]);

	ath_tx_set_retry(sc, bf);
  90da4a:	5bff6b        	call8	90d7f8 <ath_tx_set_retry>
	asf_tailq_insert_tail(bf_q, bf, bf_list);
  90da4d:	9239      	s32i.n	a2, a3, 36
  90da4f:	8241      	l32i.n	a2, a4, 4
  90da51:	923a      	s32i.n	a2, a3, 40
  90da53:	9320      	s32i.n	a3, a2, 0
  90da55:	233c24        	addi	a3, a3, 36
  90da58:	9341      	s32i.n	a3, a4, 4
  90da5a:	d10f      	retw.n

0090da5c <ath_tx_comp_aggr_error>:
}

static void
ath_tx_comp_aggr_error(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
		       ath_atx_tid_t *tid)
{
  90da5c:	6c1020        	entry	a1, 0x100


	struct ath_tx_desc lastds;
	struct ath_tx_desc *ds = &lastds;
	struct ath_rc_series rcs[4];
	struct ath_tx_buf *bar = NULL;
  90da5f:	c060      	movi.n	a6, 0
  90da61:	261630        	s32i	a6, a1, 192
	struct ath_tx_buf *bf_next;
	int nframes = bf->bf_nframes;
	ath_tx_bufhead bf_q;
	struct ath_txq *txq;

	asf_tailq_init(&bf_q);
  90da64:	26162e        	s32i	a6, a1, 184
 * @param[in] size    buffer size
 */
static inline void
adf_os_mem_copy(void *dst, const void *src, adf_os_size_t size)
{
    __adf_os_mem_copy(dst, src, size);
  90da67:	8b3e      	l32i.n	a11, a3, 56
  90da69:	260ab8        	movi	a6, 184
  90da6c:	061608        	add	a6, a1, a6
  90da6f:	011a02        	or	a10, a1, a1
  90da72:	2c0a88        	movi	a12, 136
	struct ath_tx_desc lastds;
	struct ath_tx_desc *ds = &lastds;
	struct ath_rc_series rcs[4];
	struct ath_tx_buf *bar = NULL;
	struct ath_tx_buf *bf_next;
	int nframes = bf->bf_nframes;
  90da75:	25304c        	l8ui	a5, a3, 76
	ath_tx_bufhead bf_q;
	struct ath_txq *txq;

	asf_tailq_init(&bf_q);
  90da78:	26162f        	s32i	a6, a1, 188
	txq = bf->bf_txq;
  90da7b:	273220        	l32i	a7, a3, 128
  90da7e:	5bfd0a        	call8	90cea8 <__adf_os_mem_copy>
  90da81:	2a0a88        	movi	a10, 136
  90da84:	0a1a08        	add	a10, a1, a10
  90da87:	2b3c50        	addi	a11, a3, 80
  90da8a:	2c0a30        	movi	a12, 48
  90da8d:	5bfd06        	call8	90cea8 <__adf_os_mem_copy>
	adf_os_mem_copy(ds, bf->bf_lastds, sizeof (struct ath_tx_desc));
	adf_os_mem_copy(rcs, bf->bf_rcs, sizeof(rcs));

	while (bf) {
		bf_next = bf->bf_next;
		ath_tx_retry_subframe(sc, bf, &bf_q, &bar);
  90da90:	d860      	mov.n	a8, a6
  90da92:	2d0ac0        	movi	a13, 192

	adf_os_mem_copy(ds, bf->bf_lastds, sizeof (struct ath_tx_desc));
	adf_os_mem_copy(rcs, bf->bf_rcs, sizeof(rcs));

	while (bf) {
		bf_next = bf->bf_next;
  90da95:	863b      	l32i.n	a6, a3, 44
		ath_tx_retry_subframe(sc, bf, &bf_q, &bar);
  90da97:	db30      	mov.n	a11, a3
  90da99:	dc80      	mov.n	a12, a8
  90da9b:	da20      	mov.n	a10, a2
  90da9d:	a1dd      	add.n	a13, a13, a1
  90da9f:	281634        	s32i	a8, a1, 208
  90daa2:	5bffb6        	call8	90d97c <ath_tx_retry_subframe>
		bf = bf_next;
  90daa5:	d360      	mov.n	a3, a6
	txq = bf->bf_txq;

	adf_os_mem_copy(ds, bf->bf_lastds, sizeof (struct ath_tx_desc));
	adf_os_mem_copy(rcs, bf->bf_rcs, sizeof(rcs));

	while (bf) {
  90daa7:	281234        	l32i	a8, a1, 208
  90daaa:	656fe4        	bnez	a6, 90da92 <ath_tx_comp_aggr_error+0x36>
		bf_next = bf->bf_next;
		ath_tx_retry_subframe(sc, bf, &bf_q, &bar);
		bf = bf_next;
	}

	ath_update_aggr_stats(sc, ds, nframes, nframes);
  90daad:	022a02        	or	a10, a2, a2
  90dab0:	011b02        	or	a11, a1, a1
  90dab3:	5bfdd6        	call8	90d20c <ath_update_aggr_stats$isra$2>
	ath_rate_tx_complete(sc, tid->an, ds, rcs, nframes, nframes);
  90dab6:	8b4e      	l32i.n	a11, a4, 56
  90dab8:	2d0a88        	movi	a13, 136
  90dabb:	dc10      	mov.n	a12, a1
  90dabd:	da20      	mov.n	a10, a2
  90dabf:	ad1d      	add.n	a13, a1, a13
  90dac1:	de50      	mov.n	a14, a5
  90dac3:	df50      	mov.n	a15, a5
  90dac5:	5bfcd8        	call8	90ce28 <ath_rate_tx_complete>

	if (bar) {
  90dac8:	2c1230        	l32i	a12, a1, 192
  90dacb:	c8c5      	beqz.n	a12, 90dad4 <ath_tx_comp_aggr_error+0x78>
		ath_bar_tx(sc, tid, bar);
  90dacd:	da20      	mov.n	a10, a2
  90dacf:	db40      	mov.n	a11, a4
  90dad1:	5bfeed        	call8	90d688 <ath_bar_tx>
	}

	if (!asf_tailq_empty(&bf_q)) {
  90dad4:	23122e        	l32i	a3, a1, 184
  90dad7:	ca3d      	beqz.n	a3, 90db08 <ath_tx_comp_aggr_error+0xac>
		__stats(sc, txaggr_prepends);
  90dad9:	232264        	l32i	a3, a2, 0x190
  90dadc:	b133      	addi.n	a3, a3, 1
  90dade:	232664        	s32i	a3, a2, 0x190
		TAILQ_INSERTQ_HEAD(&tid->buf_q, &bf_q, bf_list);
  90dae1:	834b      	l32i.n	a3, a4, 44
  90dae3:	22122f        	l32i	a2, a1, 188
  90dae6:	c83b      	beqz.n	a3, 90daf5 <ath_tx_comp_aggr_error+0x99>
  90dae8:	9320      	s32i.n	a3, a2, 0
  90daea:	824b      	l32i.n	a2, a4, 44
  90daec:	23122f        	l32i	a3, a1, 188
  90daef:	932a      	s32i.n	a3, a2, 40
  90daf1:	600002        	j	90daf7 <ath_tx_comp_aggr_error+0x9b>
  90daf4:	00924c        	extui	a2, a0, 9, 13
  90daf7:	22122e        	l32i	a2, a1, 184
  90dafa:	234c2c        	addi	a3, a4, 44
  90dafd:	924b      	s32i.n	a2, a4, 44
  90daff:	932a      	s32i.n	a3, a2, 40
		ath_tgt_tx_enqueue(txq, tid);
  90db01:	da70      	mov.n	a10, a7
  90db03:	db40      	mov.n	a11, a4
  90db05:	5bfdb8        	call8	90d1e8 <ath_tgt_tx_enqueue>
  90db08:	d10f      	retw.n
	...

0090db0c <ath_tx_status_send>:

	txs->cnt++;
}

void ath_tx_status_send(struct ath_softc_tgt *sc)
{
  90db0c:	6c1004        	entry	a1, 32
	int i;

	if (sc->sc_tx_draining)
  90db0f:	242249        	l32i	a4, a2, 0x124
  90db12:	136abc        	l32r	a3, 8e8604 <memset+0x17bc>
  90db15:	034401        	and	a4, a4, a3
  90db18:	cf44      	bnez.n	a4, 90db50 <ath_tx_status_send+0x44>
		return;

	for (i = 0; i < 2; i++) {
		if (sc->tx_status[i].cnt) {
  90db1a:	232d16        	addmi	a3, a2, 0x1600
  90db1d:	283038        	l8ui	a8, a3, 56
  90db20:	c980      	beqz.n	a8, 90db34 <ath_tx_status_send+0x28>
			wmi_event(sc->tgt_wmi_handle, WMI_TXSTATUS_EVENTID,
  90db22:	1c6b04        	l32r	a12, 8e8734 <memset+0x18ec>
  90db25:	8a23      	l32i.n	a10, a2, 12
  90db27:	1b6b03        	l32r	a11, 8e8734 <memset+0x18ec>
  90db2a:	ac2c      	add.n	a12, a2, a12
  90db2c:	c2d5      	movi.n	a13, 37
  90db2e:	5be9fd        	call8	908324 <wmi_event>
				  &sc->tx_status[i], sizeof(WMI_TXSTATUS_EVENT));
			/* FIXME: Handle failures. */
			sc->tx_status[i].cnt = 0;
  90db31:	243438        	s8i	a4, a3, 56

	if (sc->sc_tx_draining)
		return;

	for (i = 0; i < 2; i++) {
		if (sc->tx_status[i].cnt) {
  90db34:	232d16        	addmi	a3, a2, 0x1600
  90db37:	24305d        	l8ui	a4, a3, 93
  90db3a:	c942      	beqz.n	a4, 90db50 <ath_tx_status_send+0x44>
			wmi_event(sc->tgt_wmi_handle, WMI_TXSTATUS_EVENTID,
  90db3c:	1c6b05        	l32r	a12, 8e8750 <memset+0x1908>
  90db3f:	8a23      	l32i.n	a10, a2, 12
  90db41:	1b6b03        	l32r	a11, 8e8750 <memset+0x1908>
  90db44:	ac2c      	add.n	a12, a2, a12
  90db46:	c2d5      	movi.n	a13, 37
				  &sc->tx_status[i], sizeof(WMI_TXSTATUS_EVENT));
			/* FIXME: Handle failures. */
			sc->tx_status[i].cnt = 0;
  90db48:	c020      	movi.n	a2, 0
	if (sc->sc_tx_draining)
		return;

	for (i = 0; i < 2; i++) {
		if (sc->tx_status[i].cnt) {
			wmi_event(sc->tgt_wmi_handle, WMI_TXSTATUS_EVENTID,
  90db4a:	5be9f6        	call8	908324 <wmi_event>
				  &sc->tx_status[i], sizeof(WMI_TXSTATUS_EVENT));
			/* FIXME: Handle failures. */
			sc->tx_status[i].cnt = 0;
  90db4d:	22345d        	s8i	a2, a3, 93
  90db50:	d10f      	retw.n
	...

0090db54 <ath_tgt_tid_drain>:
	return((struct ieee80211_frame *)anbdata);
}

void
ath_tgt_tid_drain(struct ath_softc_tgt *sc, struct ath_atx_tid *tid)
{
  90db54:	6c1004        	entry	a1, 32
	struct ath_tx_buf *bf;

	while (!asf_tailq_empty(&tid->buf_q)) {
  90db57:	600015        	j	90db70 <ath_tgt_tid_drain+0x1c>
		TAILQ_DEQ(&tid->buf_q, bf, bf_list);
  90db5a:	88b9      	l32i.n	a8, a11, 36
  90db5c:	89ba      	l32i.n	a9, a11, 40
  90db5e:	c883      	beqz.n	a8, 90db65 <ath_tgt_tid_drain+0x11>
  90db60:	998a      	s32i.n	a9, a8, 40
  90db62:	600001        	j	90db67 <ath_tgt_tid_drain+0x13>
  90db65:	993c      	s32i.n	a9, a3, 48
  90db67:	89ba      	l32i.n	a9, a11, 40
		ath_tx_freebuf(sc, bf);
  90db69:	da20      	mov.n	a10, a2
ath_tgt_tid_drain(struct ath_softc_tgt *sc, struct ath_atx_tid *tid)
{
	struct ath_tx_buf *bf;

	while (!asf_tailq_empty(&tid->buf_q)) {
		TAILQ_DEQ(&tid->buf_q, bf, bf_list);
  90db6b:	9890      	s32i.n	a8, a9, 0
		ath_tx_freebuf(sc, bf);
  90db6d:	5bfe96        	call8	90d5c8 <ath_tx_freebuf>
void
ath_tgt_tid_drain(struct ath_softc_tgt *sc, struct ath_atx_tid *tid)
{
	struct ath_tx_buf *bf;

	while (!asf_tailq_empty(&tid->buf_q)) {
  90db70:	8b3b      	l32i.n	a11, a3, 44
  90db72:	65bfe4        	bnez	a11, 90db5a <ath_tgt_tid_drain+0x6>
		TAILQ_DEQ(&tid->buf_q, bf, bf_list);
		ath_tx_freebuf(sc, bf);
	}

	tid->seq_next = tid->seq_start;
  90db75:	223102        	l16ui	a2, a3, 4
  90db78:	223503        	s16i	a2, a3, 6
	tid->baw_tail = tid->baw_head;
  90db7b:	8233      	l32i.n	a2, a3, 12
  90db7d:	9234      	s32i.n	a2, a3, 16
  90db7f:	d10f      	retw.n
  90db81:	000000        	ill

0090db84 <ath_tgt_tx_prepare>:
	return  bf;
}

struct ath_tx_buf* ath_tgt_tx_prepare(struct ath_softc_tgt *sc,
				   adf_nbuf_t skb, ath_data_hdr_t *dh)
{
  90db84:	6c1006        	entry	a1, 48
  90db87:	d520      	mov.n	a5, a2
	struct ath_tx_buf *bf;
	struct ieee80211_node_target *ni;
	struct ath_atx_tid *tid;

	ni = ath_tgt_find_node(sc, dh->ni_index);
  90db89:	224001        	l8ui	a2, a4, 1
							a_int32_t node_index)
{
	struct ath_node_target *an;
	struct ieee80211_node_target *ni;

	if (node_index > TARGET_NODE_MAX)
  90db8c:	c068      	movi.n	a6, 8
  90db8e:	726a02        	bge	a6, a2, 90db94 <ath_tgt_tx_prepare+0x10>
  90db91:	600263        	j	90ddf8 <ath_tgt_tx_prepare+0x274>
	  	return NULL;

	an = &sc->sc_sta[node_index];
  90db94:	0a2611        	slli	a6, a2, 6
  90db97:	a266      	add.n	a6, a6, a2
  90db99:	026609        	addx2	a6, a6, a2
  90db9c:	275a30        	movi	a7, 0x530
  90db9f:	07660a        	addx4	a6, a6, a7
  90dba2:	a656      	add.n	a6, a5, a6
  90dba4:	b866      	addi.n	a6, a6, 8
	ni = &an->ni;

	if (an->an_valid) {
  90dba6:	226d02        	addmi	a2, a6, 0x200
  90dba9:	222004        	l8ui	a2, a2, 4
  90dbac:	002232        	sext	a2, a2, 7
  90dbaf:	642247        	beqz	a2, 90ddfa <ath_tgt_tx_prepare+0x276>
		if (ni->ni_vap == NULL) {
  90dbb2:	8268      	l32i.n	a2, a6, 32
  90dbb4:	642242        	beqz	a2, 90ddfa <ath_tgt_tx_prepare+0x276>
	struct ieee80211_node_target *ni;
	struct ath_atx_tid *tid;

	ni = ath_tgt_find_node(sc, dh->ni_index);
	if (ni == NULL)
		return NULL;
  90dbb7:	c020      	movi.n	a2, 0
	struct ath_tx_buf *bf;
	struct ieee80211_node_target *ni;
	struct ath_atx_tid *tid;

	ni = ath_tgt_find_node(sc, dh->ni_index);
	if (ni == NULL)
  90dbb9:	726902        	bne	a6, a2, 90dbbf <ath_tgt_tx_prepare+0x3b>
  90dbbc:	60023a        	j	90ddfa <ath_tgt_tx_prepare+0x276>
		return NULL;

	tid = ATH_AN_2_TID(ATH_NODE_TARGET(ni), dh->tidno);
  90dbbf:	274003        	l8ui	a7, a4, 3
  90dbc2:	0c7811        	slli	a8, a7, 4
  90dbc5:	07870c        	sub	a7, a8, a7
  90dbc8:	06770a        	addx4	a7, a7, a6
	if (tid->flag & TID_REINITIALIZE) {
  90dbcb:	27705a        	l8ui	a7, a7, 90
  90dbce:	7d770e        	bbci	a7, 29, 90dbe0 <ath_tgt_tx_prepare+0x5c>
		adf_os_print("drop frame due to TID reinit\n");
  90dbd1:	136915        	l32r	a3, 8e8028 <memset+0x11e0>
  90dbd4:	1a6b06        	l32r	a10, 8e87ec <memset+0x19a4>
  90dbd7:	233212        	l32i	a3, a3, 72
  90dbda:	0b3000        	callx8	a3
		return NULL;
  90dbdd:	d10f      	retw.n
  90dbdf:	002252        	extui	a2, a0, 18, 3

static struct ath_tx_buf* ath_tx_buf_alloc(struct ath_softc_tgt *sc)
{
	struct ath_tx_buf *bf = NULL;

	bf = asf_tailq_first(&sc->sc_txbuf);
  90dbe2:	f0          	.byte 0xf0
	if (bf !=  NULL) {
  90dbe3:	cb22      	beqz.n	a2, 90dc19 <ath_tgt_tx_prepare+0x95>
 * @param[in] size  buffer size
 */
static inline void
adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
{
    __adf_os_mem_set(buf, b, size);
  90dbe5:	2a2c3c        	addi	a10, a2, 60
  90dbe8:	c4bc      	movi.n	a11, 76
  90dbea:	5bfda9        	call8	90d290 <__adf_os_mem_set$constprop$13>
		adf_os_mem_set(&bf->bf_state, 0, sizeof(struct ath_buf_state));
		asf_tailq_remove(&sc->sc_txbuf, bf, bf_list);
  90dbed:	8729      	l32i.n	a7, a2, 36
  90dbef:	882a      	l32i.n	a8, a2, 40
  90dbf1:	c874      	beqz.n	a7, 90dbf9 <ath_tgt_tx_prepare+0x75>
  90dbf3:	987a      	s32i.n	a8, a7, 40
  90dbf5:	600003        	j	90dbfc <ath_tgt_tx_prepare+0x78>
  90dbf8:	002856        	extui	a8, a0, 18, 7
  90dbfb:	f1          	.byte 0xf1
  90dbfc:	882a      	l32i.n	a8, a2, 40
		__stats(sc, tx_nobufs);
		return NULL;
	}

	bf->bf_tidno = dh->tidno;
	bf->bf_txq = TID_TO_ACTXQ(bf->bf_tidno);
  90dbfe:	c091      	movi.n	a9, 1
	struct ath_tx_buf *bf = NULL;

	bf = asf_tailq_first(&sc->sc_txbuf);
	if (bf !=  NULL) {
		adf_os_mem_set(&bf->bf_state, 0, sizeof(struct ath_buf_state));
		asf_tailq_remove(&sc->sc_txbuf, bf, bf_list);
  90dc00:	9780      	s32i.n	a7, a8, 0
	if (!bf) {
		__stats(sc, tx_nobufs);
		return NULL;
	}

	bf->bf_tidno = dh->tidno;
  90dc02:	284003        	l8ui	a8, a4, 3
	bf->bf_txq = TID_TO_ACTXQ(bf->bf_tidno);
  90dc05:	c070      	movi.n	a7, 0
  90dc07:	2a8cfd        	addi	a10, a8, -3
	if (!bf) {
		__stats(sc, tx_nobufs);
		return NULL;
	}

	bf->bf_tidno = dh->tidno;
  90dc0a:	28244d        	s8i	a8, a2, 77
	bf->bf_txq = TID_TO_ACTXQ(bf->bf_tidno);
  90dc0d:	0a9739        	movnez	a7, a9, a10
  90dc10:	c870      	beqz.n	a7, 90dc14 <ath_tgt_tx_prepare+0x90>
  90dc12:	ce84      	bnez.n	a8, 90dc3a <ath_tgt_tx_prepare+0xb6>
  90dc14:	c090      	movi.n	a9, 0
  90dc16:	600036        	j	90dc50 <ath_tgt_tx_prepare+0xcc>
	bf = asf_tailq_first(&sc->sc_txbuf);
	if (bf !=  NULL) {
		adf_os_mem_set(&bf->bf_state, 0, sizeof(struct ath_buf_state));
		asf_tailq_remove(&sc->sc_txbuf, bf, bf_list);
	} else {
		adf_os_assert(0);
  90dc19:	136915        	l32r	a3, 8e8070 <memset+0x1228>
  90dc1c:	1b6b07        	l32r	a11, 8e8838 <memset+0x19f0>
  90dc1f:	233212        	l32i	a3, a3, 72
  90dc22:	1a6afb        	l32r	a10, 8e8810 <memset+0x19c8>
  90dc25:	0b3000        	callx8	a3
  90dc28:	13697a        	l32r	a3, 8e8210 <memset+0x13c8>
  90dc2b:	0c0200        	memw
  90dc2e:	8330      	l32i.n	a3, a3, 0
		return NULL;
	}

	bf = ath_tx_buf_alloc(sc);
	if (!bf) {
		__stats(sc, tx_nobufs);
  90dc30:	235277        	l32i	a3, a5, 0x1dc
  90dc33:	b133      	addi.n	a3, a3, 1
  90dc35:	235677        	s32i	a3, a5, 0x1dc
		return NULL;
  90dc38:	d10f      	retw.n
	}

	bf->bf_tidno = dh->tidno;
	bf->bf_txq = TID_TO_ACTXQ(bf->bf_tidno);
  90dc3a:	b087      	addi.n	a7, a8, -1
  90dc3c:	070747        	extui	a7, a7, 0, 8
  90dc3f:	6e720d        	bltui	a7, 2, 90dc50 <ath_tgt_tx_prepare+0xcc>
  90dc42:	288cfc        	addi	a8, a8, -4
  90dc45:	080847        	extui	a8, a8, 0, 8
  90dc48:	c093      	movi.n	a9, 3
  90dc4a:	6f8202        	bgeui	a8, 2, 90dc50 <ath_tgt_tx_prepare+0xcc>
  90dc4d:	290a02        	movi	a9, 2
  90dc50:	05990a        	addx4	a9, a9, a5
  90dc53:	299d05        	addmi	a9, a9, 0x500
  90dc56:	8793      	l32i.n	a7, a9, 12
 * @param[in] buf   buf
 */
static inline void
adf_nbuf_queue_add(adf_nbuf_queue_t *head, adf_nbuf_t buf)
{
    __adf_nbuf_queue_add(head, buf);
  90dc58:	db30      	mov.n	a11, a3
  90dc5a:	272620        	s32i	a7, a2, 128
	bf->bf_keytype = dh->keytype;
  90dc5d:	274008        	l8ui	a7, a4, 8
  90dc60:	272485        	s8i	a7, a2, 133
	bf->bf_keyix = dh->keyix;
  90dc63:	274009        	l8ui	a7, a4, 9
  90dc66:	272449        	s8i	a7, a2, 73
	bf->bf_protmode = dh->flags & (IEEE80211_PROT_RTSCTS | IEEE80211_PROT_CTSONLY);
  90dc69:	274007        	l8ui	a7, a4, 7
	bf->bf_node = ni;
  90dc6c:	9624      	s32i.n	a6, a2, 16

	bf->bf_tidno = dh->tidno;
	bf->bf_txq = TID_TO_ACTXQ(bf->bf_tidno);
	bf->bf_keytype = dh->keytype;
	bf->bf_keyix = dh->keyix;
	bf->bf_protmode = dh->flags & (IEEE80211_PROT_RTSCTS | IEEE80211_PROT_CTSONLY);
  90dc6e:	070741        	extui	a7, a7, 0, 2
	bf->bf_node = ni;

	adf_nbuf_queue_add(&bf->bf_skbhead, skb);
  90dc71:	262c14        	addi	a6, a2, 20
  90dc74:	da60      	mov.n	a10, a6

	bf->bf_tidno = dh->tidno;
	bf->bf_txq = TID_TO_ACTXQ(bf->bf_tidno);
	bf->bf_keytype = dh->keytype;
	bf->bf_keyix = dh->keyix;
	bf->bf_protmode = dh->flags & (IEEE80211_PROT_RTSCTS | IEEE80211_PROT_CTSONLY);
  90dc76:	272484        	s8i	a7, a2, 132
  90dc79:	5be367        	call8	906a18 <__adf_nbuf_queue_add>
 * @return first buffer in queue
 */
static inline adf_nbuf_t 
adf_nbuf_queue_first(adf_nbuf_queue_t *head)
{
    return (__adf_nbuf_queue_first(head));
  90dc7c:	da60      	mov.n	a10, a6
  90dc7e:	5be414        	call8	906cd0 <__adf_nbuf_queue_first>
  90dc81:	d3a0      	mov.n	a3, a10
 * @return length of the queue
 */
static inline a_uint32_t
adf_nbuf_queue_len(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_len(head);
  90dc83:	da60      	mov.n	a10, a6
  90dc85:	5be410        	call8	906cc8 <__adf_nbuf_queue_len>
	bf->bf_node = ni;

	adf_nbuf_queue_add(&bf->bf_skbhead, skb);
	skb = adf_nbuf_queue_first(&(bf->bf_skbhead));

	if (adf_nbuf_queue_len(&(bf->bf_skbhead)) == 0) {
  90dc88:	ccac      	bnez.n	a10, 90dc98 <ath_tgt_tx_prepare+0x114>
		__stats(sc, tx_noskbs);
  90dc8a:	225276        	l32i	a2, a5, 0x1d8
  90dc8d:	b122      	addi.n	a2, a2, 1
  90dc8f:	225676        	s32i	a2, a5, 0x1d8
		return NULL;
  90dc92:	d2a0      	mov.n	a2, a10
  90dc94:	d10f      	retw.n
  90dc96:	0000cd        	excw
	}

	adf_os_assert(skb);
  90dc99:	361769        	excw
  90dc9c:	151a6a        	l32r	a5, 8d4644 <_bss_end+0x3c1734>
  90dc9f:	fb          	.byte 0xfb
  90dca0:	277212        	l32i	a7, a7, 72
  90dca3:	1b6b08        	l32r	a11, 8e88c4 <memset+0x1a7c>
  90dca6:	0b7000        	callx8	a7
  90dca9:	17697a        	l32r	a7, 8e8294 <memset+0x144c>
  90dcac:	0c0200        	memw
  90dcaf:	277200        	l32i	a7, a7, 0
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  90dcb2:	da30      	mov.n	a10, a3
  90dcb4:	b41b      	addi.n	a11, a1, 4

	bf->bf_skb = skb;
  90dcb6:	9328      	s32i.n	a3, a2, 32
  90dcb8:	dc10      	mov.n	a12, a1
  90dcba:	5be3f9        	call8	906ca0 <__adf_nbuf_peek_header>
				     ath_data_hdr_t *dh)

{
	struct ieee80211_frame *wh = ATH_SKB2_WH(bf->bf_skb);
	a_int32_t retval;
	a_uint32_t flags = adf_os_ntohl(dh->flags);
  90dcbd:	294004        	l8ui	a9, a4, 4
  90dcc0:	284005        	l8ui	a8, a4, 5
  90dcc3:	274006        	l8ui	a7, a4, 6
  90dcc6:	089910        	slli	a9, a9, 24
  90dcc9:	008811        	slli	a8, a8, 16
  90dccc:	098802        	or	a8, a8, a9
  90dccf:	244007        	l8ui	a4, a4, 7
  90dcd2:	087711        	slli	a7, a7, 8

static void ath_tgt_tx_seqno_normal(struct ath_tx_buf *bf)
{
	struct ieee80211_node_target *ni = bf->bf_node;
	struct ath_node_target *an = ATH_NODE_TARGET(ni);
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);
  90dcd5:	8a28      	l32i.n	a10, a2, 32
				     ath_data_hdr_t *dh)

{
	struct ieee80211_frame *wh = ATH_SKB2_WH(bf->bf_skb);
	a_int32_t retval;
	a_uint32_t flags = adf_os_ntohl(dh->flags);
  90dcd7:	087702        	or	a7, a7, a8
{
	a_uint8_t *anbdata;
	a_uint32_t anblen;

	adf_nbuf_peek_header(skb, &anbdata, &anblen);
	return((struct ieee80211_frame *)anbdata);
  90dcda:	8311      	l32i.n	a3, a1, 4
				     ath_data_hdr_t *dh)

{
	struct ieee80211_frame *wh = ATH_SKB2_WH(bf->bf_skb);
	a_int32_t retval;
	a_uint32_t flags = adf_os_ntohl(dh->flags);
  90dcdc:	074402        	or	a4, a4, a7
	return bf;
}

static void ath_tgt_tx_seqno_normal(struct ath_tx_buf *bf)
{
	struct ieee80211_node_target *ni = bf->bf_node;
  90dcdf:	272204        	l32i	a7, a2, 16
	struct ath_node_target *an = ATH_NODE_TARGET(ni);
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);
  90dce2:	5bfec1        	call8	90d7e8 <ATH_SKB_2_WH>
	struct ath_atx_tid *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90dce5:	28204d        	l8ui	a8, a2, 77

	u_int8_t fragno = (wh->i_seq[0] & 0xf);

	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);
  90dce8:	2b710c        	l16ui	a11, a7, 24
static void ath_tgt_tx_seqno_normal(struct ath_tx_buf *bf)
{
	struct ieee80211_node_target *ni = bf->bf_node;
	struct ath_node_target *an = ATH_NODE_TARGET(ni);
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);
	struct ath_atx_tid *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90dceb:	0c8911        	slli	a9, a8, 4
  90dcee:	08980c        	sub	a8, a9, a8
  90dcf1:	07880a        	addx4	a8, a8, a7

	u_int8_t fragno = (wh->i_seq[0] & 0xf);

	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);
  90dcf4:	b1bb      	addi.n	a11, a11, 1
  90dcf6:	0b0b4b        	extui	a11, a11, 0, 12
static void ath_tgt_tx_seqno_normal(struct ath_tx_buf *bf)
{
	struct ieee80211_node_target *ni = bf->bf_node;
	struct ath_node_target *an = ATH_NODE_TARGET(ni);
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);
	struct ath_atx_tid *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90dcf9:	288c24        	addi	a8, a8, 36

	u_int8_t fragno = (wh->i_seq[0] & 0xf);
  90dcfc:	29a016        	l8ui	a9, a10, 22

	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);
  90dcff:	2b750c        	s16i	a11, a7, 24

	bf->bf_seqno = (tid->seq_next << IEEE80211_SEQ_SEQ_SHIFT);
  90dd02:	278103        	l16ui	a7, a8, 6
	struct ieee80211_node_target *ni = bf->bf_node;
	struct ath_node_target *an = ATH_NODE_TARGET(ni);
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);
	struct ath_atx_tid *tid = ATH_AN_2_TID(an, bf->bf_tidno);

	u_int8_t fragno = (wh->i_seq[0] & 0xf);
  90dd05:	090943        	extui	a9, a9, 0, 4

	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);

	bf->bf_seqno = (tid->seq_next << IEEE80211_SEQ_SEQ_SHIFT);
  90dd08:	0c7711        	slli	a7, a7, 4
  90dd0b:	07074f        	extui	a7, a7, 0, 16
  90dd0e:	272523        	s16i	a7, a2, 70

#undef adf_os_cpu_to_le16

static a_uint16_t adf_os_cpu_to_le16(a_uint16_t x)
{
	return ((((x) & 0xff00) >> 8) |   (((x) & 0x00ff) << 8));
  90dd11:	087b11        	slli	a11, a7, 8
  90dd14:	078714        	srli	a7, a7, 8
  90dd17:	07b702        	or	a7, a11, a7

	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);

	bf->bf_seqno = (tid->seq_next << IEEE80211_SEQ_SEQ_SHIFT);

	*(u_int16_t *)wh->i_seq = adf_os_cpu_to_le16(bf->bf_seqno);
  90dd1a:	070b4f        	extui	a11, a7, 0, 16
  90dd1d:	27a50b        	s16i	a7, a10, 22
	wh->i_seq[0] |= fragno;
  90dd20:	0b8714        	srli	a7, a11, 8
  90dd23:	079702        	or	a7, a9, a7
  90dd26:	27a416        	s8i	a7, a10, 22

	if (!(wh->i_fc[1] & IEEE80211_FC1_MORE_FRAG))
  90dd29:	27a001        	l8ui	a7, a10, 1
  90dd2c:	7d7f08        	bbsi	a7, 29, 90dd38 <ath_tgt_tx_prepare+0x1b4>
		INCR(tid->seq_next, IEEE80211_SEQ_MAX);
  90dd2f:	278103        	l16ui	a7, a8, 6
  90dd32:	277c01        	addi	a7, a7, 1
  90dd35:	278503        	s16i	a7, a8, 6
  90dd38:	278103        	l16ui	a7, a8, 6
	a_uint32_t flags = adf_os_ntohl(dh->flags);

	ath_tgt_tx_seqno_normal(bf);

	bf->bf_txq_add  = ath_tgt_txq_add_ucast;
	bf->bf_hdrlen   = ieee80211_anyhdrsize(wh);
  90dd3b:	033a02        	or	a10, a3, a3

	*(u_int16_t *)wh->i_seq = adf_os_cpu_to_le16(bf->bf_seqno);
	wh->i_seq[0] |= fragno;

	if (!(wh->i_fc[1] & IEEE80211_FC1_MORE_FRAG))
		INCR(tid->seq_next, IEEE80211_SEQ_MAX);
  90dd3e:	07074b        	extui	a7, a7, 0, 12
  90dd41:	278503        	s16i	a7, a8, 6
	a_int32_t retval;
	a_uint32_t flags = adf_os_ntohl(dh->flags);

	ath_tgt_tx_seqno_normal(bf);

	bf->bf_txq_add  = ath_tgt_txq_add_ucast;
  90dd44:	176b09        	l32r	a7, 8e8968 <memset+0x1b20>
  90dd47:	272610        	s32i	a7, a2, 64
	bf->bf_hdrlen   = ieee80211_anyhdrsize(wh);
  90dd4a:	5bfc5c        	call8	90cebc <ieee80211_anyhdrsize>
  90dd4d:	d7a0      	mov.n	a7, a10
  90dd4f:	2a2448        	s8i	a10, a2, 72
 * @return first buffer in queue
 */
static inline adf_nbuf_t 
adf_nbuf_queue_first(adf_nbuf_queue_t *head)
{
    return (__adf_nbuf_queue_first(head));
  90dd52:	066a02        	or	a10, a6, a6
  90dd55:	5be3de        	call8	906cd0 <__adf_nbuf_queue_first>
 * @return The total length of this buf.
 */
static inline adf_os_size_t
adf_nbuf_len(adf_nbuf_t buf)
{
    return (__adf_nbuf_len(buf));
  90dd58:	5be3c9        	call8	906c80 <__adf_nbuf_len>
	a_int32_t pktlen;

	skb = adf_nbuf_queue_first(&bf->bf_skbhead);
	pktlen = adf_nbuf_len(skb);

	pktlen -= (hdrlen & 3);
  90dd5b:	070741        	extui	a7, a7, 0, 2
  90dd5e:	07aa0c        	sub	a10, a10, a7
	pktlen += IEEE80211_CRC_LEN;
  90dd61:	b4a7      	addi.n	a7, a10, 4

	ath_tgt_tx_seqno_normal(bf);

	bf->bf_txq_add  = ath_tgt_txq_add_ucast;
	bf->bf_hdrlen   = ieee80211_anyhdrsize(wh);
	bf->bf_pktlen   = ath_get_pktlen(bf, bf->bf_hdrlen);
  90dd63:	272522        	s16i	a7, a2, 68
	bf->bf_ismcast  = IEEE80211_IS_MULTICAST(wh->i_addr1);
  90dd66:	263004        	l8ui	a6, a3, 4
  90dd69:	232087        	l8ui	a3, a2, 135
  90dd6c:	096611        	slli	a6, a6, 7
  90dd6f:	030346        	extui	a3, a3, 0, 7
  90dd72:	063302        	or	a3, a3, a6
}

static a_int32_t ath_key_setup(struct ieee80211_node_target *ni,
			       struct ath_tx_buf *bf)
{
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);
  90dd75:	8a28      	l32i.n	a10, a2, 32
	ath_tgt_tx_seqno_normal(bf);

	bf->bf_txq_add  = ath_tgt_txq_add_ucast;
	bf->bf_hdrlen   = ieee80211_anyhdrsize(wh);
	bf->bf_pktlen   = ath_get_pktlen(bf, bf->bf_hdrlen);
	bf->bf_ismcast  = IEEE80211_IS_MULTICAST(wh->i_addr1);
  90dd77:	232487        	s8i	a3, a2, 135

	if ((retval = ath_key_setup(bf->bf_node, bf)) < 0)
  90dd7a:	262204        	l32i	a6, a2, 16
}

static a_int32_t ath_key_setup(struct ieee80211_node_target *ni,
			       struct ath_tx_buf *bf)
{
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);
  90dd7d:	5bfe9a        	call8	90d7e8 <ATH_SKB_2_WH>

	if (!(wh->i_fc[1] & IEEE80211_FC1_WEP)) {
  90dd80:	27a001        	l8ui	a7, a10, 1
  90dd83:	c430      	movi.n	a3, 64
  90dd85:	037301        	and	a3, a7, a3
  90dd88:	030747        	extui	a7, a3, 0, 8
  90dd8b:	cc79      	bnez.n	a7, 90dd98 <ath_tgt_tx_prepare+0x214>
		bf->bf_keytype = HAL_KEY_TYPE_CLEAR;
  90dd8d:	232485        	s8i	a3, a2, 133
		bf->bf_keyix = HAL_TXKEYIX_INVALID;
  90dd90:	c73f      	movi.n	a3, -1
  90dd92:	232449        	s8i	a3, a2, 73
  90dd95:	60002d        	j	90ddc6 <ath_tgt_tx_prepare+0x242>
		return 0;
	}

	switch (bf->bf_keytype) {
  90dd98:	2c2085        	l8ui	a12, a2, 133
  90dd9b:	68c209        	beqi	a12, 2, 90dda8 <ath_tgt_tx_prepare+0x224>
  90dd9e:	68c30e        	beqi	a12, 3, 90ddb0 <ath_tgt_tx_prepare+0x22c>
  90dda1:	69c113        	bnei	a12, 1, 90ddb8 <ath_tgt_tx_prepare+0x234>
  90dda4:	600008        	j	90ddb0 <ath_tgt_tx_prepare+0x22c>
  90dda7:	002321        	excw
	case HAL_KEY_TYPE_WEP:
		bf->bf_pktlen += IEEE80211_WEP_ICVLEN;
		break;
	case HAL_KEY_TYPE_AES:
		bf->bf_pktlen += IEEE80211_WEP_MICLEN;
  90ddaa:	22b833        	excw
  90ddad:	600004        	j	90ddb5 <ath_tgt_tx_prepare+0x231>
		break;
	case HAL_KEY_TYPE_TKIP:
		bf->bf_pktlen += IEEE80211_WEP_ICVLEN;
  90ddb0:	232122        	l16ui	a3, a2, 68
  90ddb3:	b433      	addi.n	a3, a3, 4
  90ddb5:	232522        	s16i	a3, a2, 68
		break;
	default:
		break;
	}

	if (bf->bf_keytype == HAL_KEY_TYPE_AES ||
  90ddb8:	23ccfe        	addi	a3, a12, -2
  90ddbb:	030347        	extui	a3, a3, 0, 8
  90ddbe:	6f3204        	bgeui	a3, 2, 90ddc6 <ath_tgt_tx_prepare+0x242>
	    bf->bf_keytype == HAL_KEY_TYPE_TKIP)
		ieee80211_tgt_crypto_encap(wh, ni, bf->bf_keytype);
  90ddc1:	db60      	mov.n	a11, a6
  90ddc3:	5804a2        	call8	90f04c <ieee80211_tgt_crypto_encap>
  90ddc6:	232087        	l8ui	a3, a2, 135
	bf->bf_ismcast  = IEEE80211_IS_MULTICAST(wh->i_addr1);

	if ((retval = ath_key_setup(bf->bf_node, bf)) < 0)
		return retval;

	if (flags & ATH_SHORT_PREAMBLE)
  90ddc9:	7f4707        	bbci	a4, 31, 90ddd4 <ath_tgt_tx_prepare+0x250>
		bf->bf_shpream = AH_TRUE;
  90ddcc:	c440      	movi.n	a4, 64
  90ddce:	043302        	or	a3, a3, a4
  90ddd1:	600005        	j	90ddda <ath_tgt_tx_prepare+0x256>
	else
		bf->bf_shpream = AH_FALSE;
  90ddd4:	24fabf        	movi	a4, -65
  90ddd7:	043301        	and	a3, a3, a4
  90ddda:	232487        	s8i	a3, a2, 135

	bf->bf_flags = HAL_TXDESC_CLRDMASK;
  90dddd:	c031      	movi.n	a3, 1
  90dddf:	232544        	s16i	a3, a2, 136
	bf->bf_atype = HAL_PKT_TYPE_NORMAL;
  90dde2:	c030      	movi.n	a3, 0
	adf_os_assert(skb);

	bf->bf_skb = skb;

	ath_tgt_txbuf_setup(sc, bf, dh);
	ath_dma_map(sc, bf);
  90dde4:	da50      	mov.n	a10, a5
  90dde6:	db20      	mov.n	a11, a2
		bf->bf_shpream = AH_TRUE;
	else
		bf->bf_shpream = AH_FALSE;

	bf->bf_flags = HAL_TXDESC_CLRDMASK;
	bf->bf_atype = HAL_PKT_TYPE_NORMAL;
  90dde8:	23244a        	s8i	a3, a2, 74
	adf_os_assert(skb);

	bf->bf_skb = skb;

	ath_tgt_txbuf_setup(sc, bf, dh);
	ath_dma_map(sc, bf);
  90ddeb:	5bfdad        	call8	90d4a0 <ath_dma_map>
	ath_tx_tgt_setds(sc, bf);
  90ddee:	da50      	mov.n	a10, a5
  90ddf0:	db20      	mov.n	a11, a2
  90ddf2:	5bfce9        	call8	90d198 <ath_tx_tgt_setds>

	return bf;
  90ddf5:	d10f      	retw.n
  90ddf7:	00c020        	excw
}
  90ddfa:	d10f      	retw.n

0090ddfc <ath_tgt_tx_send_normal>:
	return pktlen;
}

void
ath_tgt_tx_send_normal(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90ddfc:	6c1014        	entry	a1, 160
	struct ath_rc_series rcs[4];
	struct ath_rc_series mrcs[4];
	a_int32_t shortPreamble = 0;
	a_int32_t isProbe = 0;

	adf_os_mem_set(rcs, 0, sizeof(struct ath_rc_series)*4 );
  90ddff:	251c40        	addi	a5, a1, 64
  90de02:	da50      	mov.n	a10, a5
  90de04:	c3b0      	movi.n	a11, 48
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	struct ath_rc_series rcs[4];
	struct ath_rc_series mrcs[4];
	a_int32_t shortPreamble = 0;
	a_int32_t isProbe = 0;
  90de06:	c040      	movi.n	a4, 0
}

void
ath_tgt_tx_send_normal(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
  90de08:	8634      	l32i.n	a6, a3, 16
	struct ath_rc_series rcs[4];
	struct ath_rc_series mrcs[4];
	a_int32_t shortPreamble = 0;
	a_int32_t isProbe = 0;
  90de0a:	24161c        	s32i	a4, a1, 112
  90de0d:	5bfd20        	call8	90d290 <__adf_os_mem_set$constprop$13>
  90de10:	2a1c10        	addi	a10, a1, 16
  90de13:	c3b0      	movi.n	a11, 48
  90de15:	5bfd1e        	call8	90d290 <__adf_os_mem_set$constprop$13>

	adf_os_mem_set(rcs, 0, sizeof(struct ath_rc_series)*4 );
	adf_os_mem_set(mrcs, 0, sizeof(struct ath_rc_series)*4 );

	if (!bf->bf_ismcast) {
  90de18:	283221        	l32i	a8, a3, 132
  90de1b:	2d0a80        	movi	a13, 128
  90de1e:	08dd01        	and	a13, a13, a8
  90de21:	74d920        	bne	a13, a4, 90de45 <ath_tgt_tx_send_normal+0x49>
				  a_int32_t stepDnInc,
				  a_uint32_t rcflag,
				  struct ath_rc_series series[],
				  a_int32_t *isProbe)
{
	ath_rate_findrate(sc, an, 1, frameLen, 10, 4, 1,
  90de24:	c0c1      	movi.n	a12, 1

	adf_os_mem_set(rcs, 0, sizeof(struct ath_rc_series)*4 );
	adf_os_mem_set(mrcs, 0, sizeof(struct ath_rc_series)*4 );

	if (!bf->bf_ismcast) {
		ath_tgt_rate_findrate(sc, an, shortPreamble,
  90de26:	241c70        	addi	a4, a1, 112
				  a_int32_t stepDnInc,
				  a_uint32_t rcflag,
				  struct ath_rc_series series[],
				  a_int32_t *isProbe)
{
	ath_rate_findrate(sc, an, 1, frameLen, 10, 4, 1,
  90de29:	da20      	mov.n	a10, a2
  90de2b:	db60      	mov.n	a11, a6
  90de2d:	9c10      	s32i.n	a12, a1, 0
  90de2f:	9c11      	s32i.n	a12, a1, 4
  90de31:	9512      	s32i.n	a5, a1, 8
  90de33:	9413      	s32i.n	a4, a1, 12
  90de35:	c0ea      	movi.n	a14, 10
  90de37:	c0f4      	movi.n	a15, 4
  90de39:	5bfbf0        	call8	90cdfc <ath_rate_findrate>

	if (!bf->bf_ismcast) {
		ath_tgt_rate_findrate(sc, an, shortPreamble,
				      0, 0, 0, 0, 0,
				      rcs, &isProbe);
		ath_hal_memcpy(bf->bf_rcs, rcs, sizeof(rcs));
  90de3c:	2a3c50        	addi	a10, a3, 80
  90de3f:	db50      	mov.n	a11, a5
  90de41:	600023        	j	90de68 <ath_tgt_tx_send_normal+0x6c>
  90de44:	00c051        	extui	a0, a0, 28, 2
	} else {
		mrcs[1].tries = mrcs[2].tries = mrcs[3].tries = 0;
  90de47:	241435        	s8i	a4, a1, 53
  90de4a:	241429        	s8i	a4, a1, 41
  90de4d:	24141d        	s8i	a4, a1, 29
		mrcs[1].rix = mrcs[2].rix = mrcs[3].rix = 0;
  90de50:	241434        	s8i	a4, a1, 52
  90de53:	241428        	s8i	a4, a1, 40
  90de56:	24141c        	s8i	a4, a1, 28
		mrcs[0].rix   = 0;
  90de59:	241410        	s8i	a4, a1, 16
		mrcs[0].tries = 1;
  90de5c:	251411        	s8i	a5, a1, 17
		mrcs[0].flags = 0;
  90de5f:	241413        	s8i	a4, a1, 19
		ath_hal_memcpy(bf->bf_rcs, mrcs, sizeof(mrcs));
  90de62:	2a3c50        	addi	a10, a3, 80
  90de65:	2b1c10        	addi	a11, a1, 16
  90de68:	c3c0      	movi.n	a12, 48
  90de6a:	5be736        	call8	907b44 <ath_hal_memcpy>
	}

	ath_buf_set_rate(sc, bf);
  90de6d:	da20      	mov.n	a10, a2
  90de6f:	db30      	mov.n	a11, a3
  90de71:	5bfd0c        	call8	90d2a4 <ath_buf_set_rate>
	bf->bf_txq_add(sc, bf);
  90de74:	243210        	l32i	a4, a3, 64
  90de77:	da20      	mov.n	a10, a2
  90de79:	db30      	mov.n	a11, a3
  90de7b:	0b4000        	callx8	a4
  90de7e:	d10f      	retw.n

0090de80 <ath_tgt_send_mgt>:
}

void
ath_tgt_send_mgt(struct ath_softc_tgt *sc,adf_nbuf_t hdr_buf, adf_nbuf_t skb,
		 HTC_ENDPOINT_ID endpt)
{
  90de80:	6c1024        	entry	a1, 0x120
	struct ieee80211_node_target *ni;
	struct ieee80211vap_target *vap;
	struct ath_vap_target *avp;
	struct ath_hal *ah = sc->sc_ah;
  90de83:	262d05        	addmi	a6, a2, 0x500
  90de86:	866b      	l32i.n	a6, a6, 44
  90de88:	2b0aa4        	movi	a11, 164
  90de8b:	261635        	s32i	a6, a1, 212
  90de8e:	2c0aa0        	movi	a12, 160
	struct ath_rc_series rcs[4];
	HAL_11N_RATE_SERIES series[4];
	ath_mgt_hdr_t *mh;
	a_int8_t keyix;

	if (!hdr_buf) {
  90de91:	cd37      	bnez.n	a3, 90deac <ath_tgt_send_mgt+0x2c>
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  90de93:	231c20        	addi	a3, a1, 32
  90de96:	da40      	mov.n	a10, a4
  90de98:	0b3b08        	add	a11, a3, a11
  90de9b:	0c3c08        	add	a12, a3, a12
  90de9e:	5be380        	call8	906ca0 <__adf_nbuf_peek_header>
 *         or NULL if there is not sufficient data to pull.
 */
static inline a_uint8_t *
adf_nbuf_pull_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_pull_head(buf, size);
  90dea1:	da40      	mov.n	a10, a4
  90dea3:	c0b8      	movi.n	a11, 8
  90dea5:	5be2af        	call8	906964 <__adf_nbuf_pull_head>
  90dea8:	60000c        	j	90deb8 <ath_tgt_send_mgt+0x38>
  90deab:	00261c        	mul16u	a6, a2, a0
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  90deae:	20da30        	movi	a0, 0xfffffd30
  90deb1:	ab6b      	add.n	a11, a6, a11
  90deb3:	ac6c      	add.n	a12, a6, a12
  90deb5:	5be37a        	call8	906ca0 <__adf_nbuf_peek_header>
		adf_nbuf_pull_head(skb, sizeof(ath_mgt_hdr_t));
	} else {
		adf_nbuf_peek_header(hdr_buf, &data, &len);
	}

	adf_os_assert(len >= sizeof(ath_mgt_hdr_t));
  90deb8:	231230        	l32i	a3, a1, 192
  90debb:	6f3816        	bgeui	a3, 8, 90ded5 <ath_tgt_send_mgt+0x55>
  90debe:	136915        	l32r	a3, 8e8314 <memset+0x14cc>
  90dec1:	1a6afb        	l32r	a10, 8e8ab0 <memset+0x1c68>
  90dec4:	233212        	l32i	a3, a3, 72
  90dec7:	1b6b0a        	l32r	a11, 8e8af0 <memset+0x1ca8>
  90deca:	0b3000        	callx8	a3
  90decd:	13697a        	l32r	a3, 8e84b8 <memset+0x1670>
  90ded0:	0c0200        	memw
  90ded3:	8330      	l32i.n	a3, a3, 0
  90ded5:	281c20        	addi	a8, a1, 32
  90ded8:	2b0aa4        	movi	a11, 164
  90dedb:	2c0aa0        	movi	a12, 160
  90dede:	0b8b08        	add	a11, a8, a11
  90dee1:	0c8c08        	add	a12, a8, a12
  90dee4:	044a02        	or	a10, a4, a4

	mh = (ath_mgt_hdr_t *)data;
  90dee7:	231231        	l32i	a3, a1, 196
  90deea:	5be36d        	call8	906ca0 <__adf_nbuf_peek_header>
  90deed:	2c1c20        	addi	a12, a1, 32
  90def0:	2acc70        	addi	a10, a12, 112
  90def3:	2b0a30        	movi	a11, 48
	adf_nbuf_peek_header(skb, &data, &len);
	wh = (struct ieee80211_frame *)data;
  90def6:	261231        	l32i	a6, a1, 196
  90def9:	5bfce5        	call8	90d290 <__adf_os_mem_set$constprop$13>
  90defc:	2a1c20        	addi	a10, a1, 32
  90deff:	2b0a70        	movi	a11, 112
  90df02:	5bfce3        	call8	90d290 <__adf_os_mem_set$constprop$13>

	adf_os_mem_set(rcs, 0, sizeof(struct ath_rc_series)*4);
	adf_os_mem_set(series, 0, sizeof(HAL_11N_RATE_SERIES)*4);

	bf = asf_tailq_first(&sc->sc_txbuf);
  90df05:	2722f0        	l32i	a7, a2, 0x3c0
	if (!bf)
  90df08:	647375        	beqz	a7, 90e281 <ath_tgt_send_mgt+0x401>
		goto fail;

	asf_tailq_remove(&sc->sc_txbuf, bf, bf_list);
  90df0b:	8979      	l32i.n	a9, a7, 36
  90df0d:	8a7a      	l32i.n	a10, a7, 40
  90df0f:	c895      	beqz.n	a9, 90df18 <ath_tgt_send_mgt+0x98>
  90df11:	9a9a      	s32i.n	a10, a9, 40
  90df13:	600004        	j	90df1b <ath_tgt_send_mgt+0x9b>
  90df16:	00002a        	muluh	a0, a0, a0
  90df19:	26f18a        	l16ui	a6, a15, 0x114
  90df1c:	7a99a0        	bne	a9, a10, 90dec0 <ath_tgt_send_mgt+0x40>

	ni = ath_tgt_find_node(sc, mh->ni_index);
  90df1f:	293000        	l8ui	a9, a3, 0
							a_int32_t node_index)
{
	struct ath_node_target *an;
	struct ieee80211_node_target *ni;

	if (node_index > TARGET_NODE_MAX)
  90df22:	c0a8      	movi.n	a10, 8
  90df24:	79aa02        	bge	a10, a9, 90df2a <ath_tgt_send_mgt+0xaa>
  90df27:	600356        	j	90e281 <ath_tgt_send_mgt+0x401>
	  	return NULL;

	an = &sc->sc_sta[node_index];
  90df2a:	0a9e11        	slli	a14, a9, 6
  90df2d:	a9ee      	add.n	a14, a14, a9
  90df2f:	09ee09        	addx2	a14, a14, a9
  90df32:	2a5a30        	movi	a10, 0x530
  90df35:	0aee0a        	addx4	a14, a14, a10
  90df38:	ae2e      	add.n	a14, a2, a14
  90df3a:	b8ee      	addi.n	a14, a14, 8
	ni = &an->ni;

	if (an->an_valid) {
  90df3c:	29ed02        	addmi	a9, a14, 0x200
  90df3f:	299004        	l8ui	a9, a9, 4
  90df42:	64933b        	beqz	a9, 90e281 <ath_tgt_send_mgt+0x401>
		if (ni->ni_vap == NULL) {
  90df45:	29e208        	l32i	a9, a14, 32
  90df48:	649335        	beqz	a9, 90e281 <ath_tgt_send_mgt+0x401>

	ni = ath_tgt_find_node(sc, mh->ni_index);
	if (!ni)
		goto fail;

	bf->bf_endpt = endpt;
  90df4b:	257623        	s32i	a5, a7, 140
	bf->bf_cookie = mh->cookie;
  90df4e:	253006        	l8ui	a5, a3, 6
	bf->bf_protmode = mh->flags & (IEEE80211_PROT_RTSCTS | IEEE80211_PROT_CTSONLY);
	txq = &sc->sc_txq[1];
	iswep = wh->i_fc[1] & IEEE80211_FC1_WEP;
	ismcast = IEEE80211_IS_MULTICAST(wh->i_addr1);
	hdrlen = ieee80211_anyhdrsize(wh);
  90df51:	066a02        	or	a10, a6, a6
	ni = ath_tgt_find_node(sc, mh->ni_index);
	if (!ni)
		goto fail;

	bf->bf_endpt = endpt;
	bf->bf_cookie = mh->cookie;
  90df54:	257492        	s8i	a5, a7, 146
	bf->bf_protmode = mh->flags & (IEEE80211_PROT_RTSCTS | IEEE80211_PROT_CTSONLY);
  90df57:	253003        	l8ui	a5, a3, 3
  90df5a:	050541        	extui	a5, a5, 0, 2
  90df5d:	257484        	s8i	a5, a7, 132
	txq = &sc->sc_txq[1];
	iswep = wh->i_fc[1] & IEEE80211_FC1_WEP;
  90df60:	296001        	l8ui	a9, a6, 1
  90df63:	250a40        	movi	a5, 64
  90df66:	059901        	and	a9, a9, a5
  90df69:	29163a        	s32i	a9, a1, 232
	ismcast = IEEE80211_IS_MULTICAST(wh->i_addr1);
  90df6c:	256004        	l8ui	a5, a6, 4
	hdrlen = ieee80211_anyhdrsize(wh);
  90df6f:	2e163c        	s32i	a14, a1, 240
  90df72:	5bfbd2        	call8	90cebc <ieee80211_anyhdrsize>
	pktlen = len;
	keyix = HAL_TXKEYIX_INVALID;
	pktlen -= (hdrlen & 3);
  90df75:	0a0941        	extui	a9, a10, 0, 2
	bf->bf_cookie = mh->cookie;
	bf->bf_protmode = mh->flags & (IEEE80211_PROT_RTSCTS | IEEE80211_PROT_CTSONLY);
	txq = &sc->sc_txq[1];
	iswep = wh->i_fc[1] & IEEE80211_FC1_WEP;
	ismcast = IEEE80211_IS_MULTICAST(wh->i_addr1);
	hdrlen = ieee80211_anyhdrsize(wh);
  90df78:	2a163b        	s32i	a10, a1, 236
	pktlen = len;
	keyix = HAL_TXKEYIX_INVALID;
	pktlen -= (hdrlen & 3);
  90df7b:	2a1230        	l32i	a10, a1, 192
	txq = &sc->sc_txq[1];
	iswep = wh->i_fc[1] & IEEE80211_FC1_WEP;
	ismcast = IEEE80211_IS_MULTICAST(wh->i_addr1);
	hdrlen = ieee80211_anyhdrsize(wh);
	pktlen = len;
	keyix = HAL_TXKEYIX_INVALID;
  90df7e:	280aff        	movi	a8, 255
	pktlen -= (hdrlen & 3);
  90df81:	09a90c        	sub	a9, a10, a9
	pktlen += IEEE80211_CRC_LEN;
  90df84:	b499      	addi.n	a9, a9, 4
	txq = &sc->sc_txq[1];
	iswep = wh->i_fc[1] & IEEE80211_FC1_WEP;
	ismcast = IEEE80211_IS_MULTICAST(wh->i_addr1);
	hdrlen = ieee80211_anyhdrsize(wh);
	pktlen = len;
	keyix = HAL_TXKEYIX_INVALID;
  90df86:	281639        	s32i	a8, a1, 228
	pktlen -= (hdrlen & 3);
	pktlen += IEEE80211_CRC_LEN;

	if (iswep)
  90df89:	28123a        	l32i	a8, a1, 232
	ismcast = IEEE80211_IS_MULTICAST(wh->i_addr1);
	hdrlen = ieee80211_anyhdrsize(wh);
	pktlen = len;
	keyix = HAL_TXKEYIX_INVALID;
	pktlen -= (hdrlen & 3);
	pktlen += IEEE80211_CRC_LEN;
  90df8c:	291637        	s32i	a9, a1, 220
	bf->bf_endpt = endpt;
	bf->bf_cookie = mh->cookie;
	bf->bf_protmode = mh->flags & (IEEE80211_PROT_RTSCTS | IEEE80211_PROT_CTSONLY);
	txq = &sc->sc_txq[1];
	iswep = wh->i_fc[1] & IEEE80211_FC1_WEP;
	ismcast = IEEE80211_IS_MULTICAST(wh->i_addr1);
  90df8f:	050540        	extui	a5, a5, 0, 1
	pktlen = len;
	keyix = HAL_TXKEYIX_INVALID;
	pktlen -= (hdrlen & 3);
	pktlen += IEEE80211_CRC_LEN;

	if (iswep)
  90df92:	2e123c        	l32i	a14, a1, 240
  90df95:	c884      	beqz.n	a8, 90df9d <ath_tgt_send_mgt+0x11d>
		keyix = mh->keyix;
  90df97:	283005        	l8ui	a8, a3, 5
  90df9a:	281639        	s32i	a8, a1, 228
adf_nbuf_map(adf_os_device_t        osdev, 
             adf_os_dma_map_t       bmap, 
             adf_nbuf_t             buf, 
             adf_os_dma_dir_t       dir)
{
    return __adf_nbuf_map(osdev, bmap, buf, dir);
  90df9d:	8b70      	l32i.n	a11, a7, 0
  90df9f:	2a2246        	l32i	a10, a2, 0x118
  90dfa2:	dc40      	mov.n	a12, a4
  90dfa4:	c0d0      	movi.n	a13, 0
  90dfa6:	2e163c        	s32i	a14, a1, 240
  90dfa9:	5be2b4        	call8	906a7c <__adf_nbuf_map>
 * @param[in] buf   buf
 */
static inline void
adf_nbuf_queue_add(adf_nbuf_queue_t *head, adf_nbuf_t buf)
{
    __adf_nbuf_queue_add(head, buf);
  90dfac:	db40      	mov.n	a11, a4

	adf_nbuf_map(sc->sc_dev, bf->bf_dmamap, skb, ADF_OS_DMA_TO_DEVICE);

	bf->bf_skb = skb;
  90dfae:	9478      	s32i.n	a4, a7, 32
  90dfb0:	2a7c14        	addi	a10, a7, 20
  90dfb3:	5be299        	call8	906a18 <__adf_nbuf_queue_add>
	adf_nbuf_queue_add(&bf->bf_skbhead, skb);

	ds = bf->bf_desc;
  90dfb6:	847c      	l32i.n	a4, a7, 48
	rt = sc->sc_currates;
  90dfb8:	292281        	l32i	a9, a2, 0x204
	adf_nbuf_map(sc->sc_dev, bf->bf_dmamap, skb, ADF_OS_DMA_TO_DEVICE);

	bf->bf_skb = skb;
	adf_nbuf_queue_add(&bf->bf_skbhead, skb);

	ds = bf->bf_desc;
  90dfbb:	241638        	s32i	a4, a1, 224
	rt = sc->sc_currates;
	adf_os_assert(rt != NULL);
  90dfbe:	2e123c        	l32i	a14, a1, 240
  90dfc1:	cd9f      	bnez.n	a9, 90dfe4 <ath_tgt_send_mgt+0x164>
  90dfc3:	146915        	l32r	a4, 8e8418 <memset+0x15d0>
  90dfc6:	1a6afb        	l32r	a10, 8e8bb4 <memset+0x1d6c>
  90dfc9:	244212        	l32i	a4, a4, 72
  90dfcc:	1b6b0a        	l32r	a11, 8e8bf4 <memset+0x1dac>
  90dfcf:	29163f        	s32i	a9, a1, 252
  90dfd2:	0b4000        	callx8	a4
  90dfd5:	14697a        	l32r	a4, 8e85c0 <memset+0x1778>
  90dfd8:	2e123c        	l32i	a14, a1, 240
  90dfdb:	0c0200        	memw
  90dfde:	244200        	l32i	a4, a4, 0
  90dfe1:	29123f        	l32i	a9, a1, 252

	if (mh->flags == ATH_SHORT_PREAMBLE)
  90dfe4:	2a3003        	l8ui	a10, a3, 3
  90dfe7:	c040      	movi.n	a4, 0
  90dfe9:	b0aa      	addi.n	a10, a10, -1
  90dfeb:	c0b1      	movi.n	a11, 1
  90dfed:	d840      	mov.n	a8, a4
	else
		shortPreamble = AH_FALSE;

	flags = HAL_TXDESC_CLRDMASK;

	switch (wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) {
  90dfef:	2c6000        	l8ui	a12, a6, 0

	ds = bf->bf_desc;
	rt = sc->sc_currates;
	adf_os_assert(rt != NULL);

	if (mh->flags == ATH_SHORT_PREAMBLE)
  90dff2:	0ab838        	moveqz	a8, a11, a10
	else
		shortPreamble = AH_FALSE;

	flags = HAL_TXDESC_CLRDMASK;

	switch (wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) {
  90dff5:	c0ac      	movi.n	a10, 12
  90dff7:	0aca01        	and	a10, a12, a10
  90dffa:	74a91f        	bne	a10, a4, 90e01d <ath_tgt_send_mgt+0x19d>
	case IEEE80211_FC0_TYPE_MGT:
		subtype = wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK;
  90dffd:	c740      	movi.n	a4, -16
  90dfff:	04c401        	and	a4, a12, a4

		if (subtype == IEEE80211_FC0_SUBTYPE_PROBE_RESP)
			atype = HAL_PKT_TYPE_PROBE_RESP;
  90e002:	c0c4      	movi.n	a12, 4
  90e004:	2c1636        	s32i	a12, a1, 216

	switch (wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) {
	case IEEE80211_FC0_TYPE_MGT:
		subtype = wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK;

		if (subtype == IEEE80211_FC0_SUBTYPE_PROBE_RESP)
  90e007:	c5c0      	movi.n	a12, 80
  90e009:	7c4113        	beq	a4, a12, 90e020 <ath_tgt_send_mgt+0x1a0>
			atype = HAL_PKT_TYPE_PROBE_RESP;
		else if (subtype == IEEE80211_FC0_SUBTYPE_ATIM)
  90e00c:	2cfa70        	movi	a12, -144
  90e00f:	ac44      	add.n	a4, a4, a12
  90e011:	04ba38        	moveqz	a10, a11, a4
  90e014:	2a1636        	s32i	a10, a1, 216
  90e017:	600005        	j	90e020 <ath_tgt_send_mgt+0x1a0>
  90e01a:	000000        	ill
		else
			atype = HAL_PKT_TYPE_NORMAL;

		break;
	default:
		atype = HAL_PKT_TYPE_NORMAL;
  90e01d:	241636        	s32i	a4, a1, 216
		break;
	}

	avp = &sc->sc_vap[mh->vap_index];
  90e020:	243001        	l8ui	a4, a3, 1
  90e023:	1a6a17        	l32r	a10, 8e8880 <memset+0x1a38>
  90e026:	0c4b11        	slli	a11, a4, 4
  90e029:	a4bb      	add.n	a11, a11, a4
  90e02b:	0abb0a        	addx4	a11, a11, a10
  90e02e:	ab2b      	add.n	a11, a2, a11

	rcs[0].rix = ath_get_minrateidx(sc, avp);
  90e030:	2bbc08        	addi	a11, a11, 8
	rcs[0].tries = ATH_TXMAXTRY;
  90e033:	240a0b        	movi	a4, 11
		break;
	}

	avp = &sc->sc_vap[mh->vap_index];

	rcs[0].rix = ath_get_minrateidx(sc, avp);
  90e036:	da20      	mov.n	a10, a2
  90e038:	28163e        	s32i	a8, a1, 248
  90e03b:	29163f        	s32i	a9, a1, 252
  90e03e:	2e163c        	s32i	a14, a1, 240
  90e041:	5bed26        	call8	9094dc <ath_get_minrateidx>
	rcs[0].tries = ATH_TXMAXTRY;
  90e044:	241491        	s8i	a4, a1, 145
	rcs[0].flags = 0;
  90e047:	c040      	movi.n	a4, 0
  90e049:	241493        	s8i	a4, a1, 147
 * @param[in] size    buffer size
 */
static inline void
adf_os_mem_copy(void *dst, const void *src, adf_os_size_t size)
{
    __adf_os_mem_copy(dst, src, size);
  90e04c:	241c20        	addi	a4, a1, 32
  90e04f:	2b4c70        	addi	a11, a4, 112
		break;
	}

	avp = &sc->sc_vap[mh->vap_index];

	rcs[0].rix = ath_get_minrateidx(sc, avp);
  90e052:	2a1490        	s8i	a10, a1, 144
  90e055:	c3c0      	movi.n	a12, 48
  90e057:	2a7c50        	addi	a10, a7, 80
  90e05a:	5bfb93        	call8	90cea8 <__adf_os_mem_copy>
	rcs[0].flags = 0;

	adf_os_mem_copy(bf->bf_rcs, rcs, sizeof(rcs));
	rix = rcs[0].rix;
	try0 = rcs[0].tries;
	txrate = rt->info[rix].rateCode;
  90e05d:	2d1090        	l8ui	a13, a1, 144
  90e060:	29123f        	l32i	a9, a1, 252
  90e063:	0dd40a        	addx4	a4, a13, a13
  90e066:	09440a        	addx4	a4, a4, a9
  90e069:	2a4034        	l8ui	a10, a4, 52

	if (shortPreamble){
  90e06c:	28123e        	l32i	a8, a1, 248
	rcs[0].flags = 0;

	adf_os_mem_copy(bf->bf_rcs, rcs, sizeof(rcs));
	rix = rcs[0].rix;
	try0 = rcs[0].tries;
	txrate = rt->info[rix].rateCode;
  90e06f:	2a1634        	s32i	a10, a1, 208
	rcs[0].tries = ATH_TXMAXTRY;
	rcs[0].flags = 0;

	adf_os_mem_copy(bf->bf_rcs, rcs, sizeof(rcs));
	rix = rcs[0].rix;
	try0 = rcs[0].tries;
  90e072:	2b1091        	l8ui	a11, a1, 145
	txrate = rt->info[rix].rateCode;
  90e075:	244c20        	addi	a4, a4, 32

	if (shortPreamble){
  90e078:	2e123c        	l32i	a14, a1, 240
  90e07b:	c887      	beqz.n	a8, 90e086 <ath_tgt_send_mgt+0x206>
		txrate |= rt->info[rix].shortPreamble;
  90e07d:	244015        	l8ui	a4, a4, 21
  90e080:	04aa02        	or	a10, a10, a4
  90e083:	2a1634        	s32i	a10, a1, 208
	}

	vap = ni->ni_vap;
  90e086:	84e8      	l32i.n	a4, a14, 32
	bf->bf_node = ni;
  90e088:	9e74      	s32i.n	a14, a7, 16

	if (ismcast) {
  90e08a:	cd56      	bnez.n	a5, 90e0a4 <ath_tgt_send_mgt+0x224>
		flags |= HAL_TXDESC_NOACK;
		try0 = 1;
	} else if (pktlen > vap->iv_rtsthreshold) {
  90e08c:	244105        	l16ui	a4, a4, 10
  90e08f:	251237        	l32i	a5, a1, 220
  90e092:	754a16        	bge	a4, a5, 90e0ac <ath_tgt_send_mgt+0x22c>
		flags |= HAL_TXDESC_RTSENA;
		cix = rt->info[rix].controlRate;
  90e095:	0dd40a        	addx4	a4, a13, a13
  90e098:	09440a        	addx4	a4, a4, a9
  90e09b:	2c4037        	l8ui	a12, a4, 55

	if (ismcast) {
		flags |= HAL_TXDESC_NOACK;
		try0 = 1;
	} else if (pktlen > vap->iv_rtsthreshold) {
		flags |= HAL_TXDESC_RTSENA;
  90e09e:	c055      	movi.n	a5, 5
  90e0a0:	60000d        	j	90e0b1 <ath_tgt_send_mgt+0x231>
  90e0a3:	00c0b1        	excw

	vap = ni->ni_vap;
	bf->bf_node = ni;

	if (ismcast) {
		flags |= HAL_TXDESC_NOACK;
  90e0a6:	c053      	movi.n	a5, 3
  90e0a8:	600002        	j	90e0ae <ath_tgt_send_mgt+0x22e>
  90e0ab:	00c051        	extui	a0, a0, 28, 2
{
	struct ieee80211_node_target *ni;
	struct ieee80211vap_target *vap;
	struct ath_vap_target *avp;
	struct ath_hal *ah = sc->sc_ah;
	a_uint8_t rix, txrate, ctsrate, cix = 0xff, *data;
  90e0ae:	2c0aff        	movi	a12, 255
	} else if (pktlen > vap->iv_rtsthreshold) {
		flags |= HAL_TXDESC_RTSENA;
		cix = rt->info[rix].controlRate;
	}

	if ((bf->bf_protmode != IEEE80211_PROT_NONE) &&
  90e0b1:	247084        	l8ui	a4, a7, 132
  90e0b4:	ca44      	beqz.n	a4, 90e0dc <ath_tgt_send_mgt+0x25c>
	    rt->info[rix].phy == IEEE80211_T_OFDM &&
  90e0b6:	0dd40a        	addx4	a4, a13, a13
  90e0b9:	09440a        	addx4	a4, a4, a9
	} else if (pktlen > vap->iv_rtsthreshold) {
		flags |= HAL_TXDESC_RTSENA;
		cix = rt->info[rix].controlRate;
	}

	if ((bf->bf_protmode != IEEE80211_PROT_NONE) &&
  90e0bc:	244029        	l8ui	a4, a4, 41
  90e0bf:	694219        	bnei	a4, 2, 90e0dc <ath_tgt_send_mgt+0x25c>
	    rt->info[rix].phy == IEEE80211_T_OFDM &&
  90e0c2:	745816        	bany	a5, a4, 90e0dc <ath_tgt_send_mgt+0x25c>
	    (flags & HAL_TXDESC_NOACK) == 0) {
		cix = rt->info[sc->sc_protrix].controlRate;
  90e0c5:	242d03        	addmi	a4, a2, 0x300
  90e0c8:	24400c        	l8ui	a4, a4, 12
  90e0cb:	04440a        	addx4	a4, a4, a4
  90e0ce:	09440a        	addx4	a4, a4, a9
  90e0d1:	2c4037        	l8ui	a12, a4, 55
		sc->sc_tx_stats.ast_tx_protect++;
  90e0d4:	24225a        	l32i	a4, a2, 0x168
  90e0d7:	b144      	addi.n	a4, a4, 1
  90e0d9:	24265a        	s32i	a4, a2, 0x168
	}

	*(a_uint16_t *)&wh->i_seq[0] =  adf_os_cpu_to_le16(ni->ni_txseqmgmt <<
  90e0dc:	24e10c        	l16ui	a4, a14, 24
							   IEEE80211_SEQ_SEQ_SHIFT);
	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);

	ctsduration = 0;
	if (flags & (HAL_TXDESC_RTSENA|HAL_TXDESC_CTSENA)) {
  90e0df:	c0fc      	movi.n	a15, 12
	    (flags & HAL_TXDESC_NOACK) == 0) {
		cix = rt->info[sc->sc_protrix].controlRate;
		sc->sc_tx_stats.ast_tx_protect++;
	}

	*(a_uint16_t *)&wh->i_seq[0] =  adf_os_cpu_to_le16(ni->ni_txseqmgmt <<
  90e0e1:	0c4411        	slli	a4, a4, 4
  90e0e4:	04044f        	extui	a4, a4, 0, 16

#undef adf_os_cpu_to_le16

static a_uint16_t adf_os_cpu_to_le16(a_uint16_t x)
{
	return ((((x) & 0xff00) >> 8) |   (((x) & 0x00ff) << 8));
  90e0e7:	084a11        	slli	a10, a4, 8
  90e0ea:	048414        	srli	a4, a4, 8
  90e0ed:	04a402        	or	a4, a10, a4
	    (flags & HAL_TXDESC_NOACK) == 0) {
		cix = rt->info[sc->sc_protrix].controlRate;
		sc->sc_tx_stats.ast_tx_protect++;
	}

	*(a_uint16_t *)&wh->i_seq[0] =  adf_os_cpu_to_le16(ni->ni_txseqmgmt <<
  90e0f0:	24650b        	s16i	a4, a6, 22
							   IEEE80211_SEQ_SEQ_SHIFT);
	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);
  90e0f3:	24e10c        	l16ui	a4, a14, 24

	ctsduration = 0;
	if (flags & (HAL_TXDESC_RTSENA|HAL_TXDESC_CTSENA)) {
  90e0f6:	0f5f01        	and	a15, a5, a15
		sc->sc_tx_stats.ast_tx_protect++;
	}

	*(a_uint16_t *)&wh->i_seq[0] =  adf_os_cpu_to_le16(ni->ni_txseqmgmt <<
							   IEEE80211_SEQ_SEQ_SHIFT);
	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);
  90e0f9:	b144      	addi.n	a4, a4, 1
  90e0fb:	04044b        	extui	a4, a4, 0, 12
  90e0fe:	24e50c        	s16i	a4, a14, 24

	ctsduration = 0;
	if (flags & (HAL_TXDESC_RTSENA|HAL_TXDESC_CTSENA)) {
  90e101:	64f091        	beqz	a15, 90e196 <ath_tgt_send_mgt+0x316>
		adf_os_assert(cix != 0xff);
  90e104:	240aff        	movi	a4, 255
  90e107:	74c92e        	bne	a12, a4, 90e139 <ath_tgt_send_mgt+0x2b9>
  90e10a:	146915        	l32r	a4, 8e8560 <memset+0x1718>
  90e10d:	1a6afb        	l32r	a10, 8e8cfc <memset+0x1eb4>
  90e110:	244212        	l32i	a4, a4, 72
  90e113:	1b6b0a        	l32r	a11, 8e8d3c <memset+0x1ef4>
  90e116:	28163e        	s32i	a8, a1, 248
  90e119:	29163f        	s32i	a9, a1, 252
  90e11c:	2c163c        	s32i	a12, a1, 240
  90e11f:	2d163d        	s32i	a13, a1, 244
  90e122:	0b4000        	callx8	a4
  90e125:	14697a        	l32r	a4, 8e8710 <memset+0x18c8>
  90e128:	2d123d        	l32i	a13, a1, 244
  90e12b:	0c0200        	memw
  90e12e:	8440      	l32i.n	a4, a4, 0
  90e130:	2c123c        	l32i	a12, a1, 240
  90e133:	29123f        	l32i	a9, a1, 252
  90e136:	28123e        	l32i	a8, a1, 248
		ctsrate = rt->info[cix].rateCode;
  90e139:	0cca0a        	addx4	a10, a12, a12
  90e13c:	09aa0a        	addx4	a10, a10, a9
  90e13f:	24a034        	l8ui	a4, a10, 52
  90e142:	c0b4      	movi.n	a11, 4
		if (shortPreamble) {
  90e144:	c98c      	beqz.n	a8, 90e164 <ath_tgt_send_mgt+0x2e4>
			ctsrate |= rt->info[cix].shortPreamble;
  90e146:	2ea035        	l8ui	a14, a10, 53

	*(a_uint16_t *)&wh->i_seq[0] =  adf_os_cpu_to_le16(ni->ni_txseqmgmt <<
							   IEEE80211_SEQ_SEQ_SHIFT);
	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);

	ctsduration = 0;
  90e149:	c0f0      	movi.n	a15, 0
	if (flags & (HAL_TXDESC_RTSENA|HAL_TXDESC_CTSENA)) {
		adf_os_assert(cix != 0xff);
		ctsrate = rt->info[cix].rateCode;
		if (shortPreamble) {
			ctsrate |= rt->info[cix].shortPreamble;
  90e14b:	0e4402        	or	a4, a4, a14
			if (flags & HAL_TXDESC_RTSENA)      /* SIFS + CTS */
  90e14e:	7b5002        	bnone	a5, a11, 90e154 <ath_tgt_send_mgt+0x2d4>
				ctsduration += rt->info[cix].spAckDuration;
  90e151:	2fa11d        	l16ui	a15, a10, 58
			if ((flags & HAL_TXDESC_NOACK) == 0)    /* SIFS + ACK */
  90e154:	7e5f22        	bbsi	a5, 30, 90e17a <ath_tgt_send_mgt+0x2fa>
				ctsduration += rt->info[cix].spAckDuration;
  90e157:	0ccc0a        	addx4	a12, a12, a12
  90e15a:	09cc0a        	addx4	a12, a12, a9
  90e15d:	2ac11d        	l16ui	a10, a12, 58
  90e160:	600014        	j	90e178 <ath_tgt_send_mgt+0x2f8>
  90e163:	00df80        	excw
		} else {
			if (flags & HAL_TXDESC_RTSENA)      /* SIFS + CTS */
  90e166:	7b5002        	bnone	a5, a11, 90e16c <ath_tgt_send_mgt+0x2ec>
				ctsduration += rt->info[cix].lpAckDuration;
  90e169:	2fa11c        	l16ui	a15, a10, 56
			if ((flags & HAL_TXDESC_NOACK) == 0)    /* SIFS + ACK */
  90e16c:	7e5f0a        	bbsi	a5, 30, 90e17a <ath_tgt_send_mgt+0x2fa>
				ctsduration += rt->info[cix].lpAckDuration;
  90e16f:	0ccc0a        	addx4	a12, a12, a12
  90e172:	09cc0a        	addx4	a12, a12, a9
  90e175:	2ac11c        	l16ui	a10, a12, 56
  90e178:	aaff      	add.n	a15, a15, a10
		}
		ctsduration += ath_hal_computetxtime(ah,
  90e17a:	2a1235        	l32i	a10, a1, 212
  90e17d:	2c1237        	l32i	a12, a1, 220
  90e180:	099b02        	or	a11, a9, a9
  90e183:	088e02        	or	a14, a8, a8
  90e186:	2f163c        	s32i	a15, a1, 240
  90e189:	5bf300        	call8	90ad8c <ath_hal_computetxtime>
  90e18c:	2f123c        	l32i	a15, a1, 240
						     rt, pktlen, rix, shortPreamble);
		try0 = 1;
  90e18f:	c0b1      	movi.n	a11, 1
			if (flags & HAL_TXDESC_RTSENA)      /* SIFS + CTS */
				ctsduration += rt->info[cix].lpAckDuration;
			if ((flags & HAL_TXDESC_NOACK) == 0)    /* SIFS + ACK */
				ctsduration += rt->info[cix].lpAckDuration;
		}
		ctsduration += ath_hal_computetxtime(ah,
  90e191:	afaa      	add.n	a10, a10, a15
  90e193:	600003        	j	90e19a <ath_tgt_send_mgt+0x31a>

	*(a_uint16_t *)&wh->i_seq[0] =  adf_os_cpu_to_le16(ni->ni_txseqmgmt <<
							   IEEE80211_SEQ_SEQ_SHIFT);
	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);

	ctsduration = 0;
  90e196:	daf0      	mov.n	a10, a15
		}
		ctsduration += ath_hal_computetxtime(ah,
						     rt, pktlen, rix, shortPreamble);
		try0 = 1;
	} else
		ctsrate = 0;
  90e198:	d4f0      	mov.n	a4, a15

	flags |= HAL_TXDESC_INTREQ;

	ah->ah_setupTxDesc(ds
  90e19a:	281239        	l32i	a8, a1, 228
						     rt, pktlen, rix, shortPreamble);
		try0 = 1;
	} else
		ctsrate = 0;

	flags |= HAL_TXDESC_INTREQ;
  90e19d:	c190      	movi.n	a9, 16
  90e19f:	095502        	or	a5, a5, a9

	ah->ah_setupTxDesc(ds
  90e1a2:	008932        	sext	a9, a8, 7
  90e1a5:	281235        	l32i	a8, a1, 212
  90e1a8:	9b10      	s32i.n	a11, a1, 0
  90e1aa:	9512      	s32i.n	a5, a1, 8
  90e1ac:	9a14      	s32i.n	a10, a1, 16
  90e1ae:	9911      	s32i.n	a9, a1, 4
  90e1b0:	9413      	s32i.n	a4, a1, 12
  90e1b2:	298217        	l32i	a9, a8, 92
  90e1b5:	2a1238        	l32i	a10, a1, 224
  90e1b8:	2b1237        	l32i	a11, a1, 220
  90e1bb:	2c123b        	l32i	a12, a1, 236
  90e1be:	2d1236        	l32i	a13, a1, 216
  90e1c1:	2f1234        	l32i	a15, a1, 208
  90e1c4:	c3ec      	movi.n	a14, 60
  90e1c6:	0b9000        	callx8	a9
			    , keyix
			    , flags
			    , ctsrate
			    , ctsduration);

	bf->bf_flags = flags;
  90e1c9:	257544        	s16i	a5, a7, 136

	/*
	 * Set key type in tx desc while sending the encrypted challenge to AP
	 * in Auth frame 3 of Shared Authentication, owl needs this.
	 */
	if (iswep && (keyix != HAL_TXKEYIX_INVALID) &&
  90e1cc:	25123a        	l32i	a5, a1, 232
  90e1cf:	c95f      	beqz.n	a5, 90e1f2 <ath_tgt_send_mgt+0x372>
			(wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK) == IEEE80211_FC0_SUBTYPE_AUTH)
  90e1d1:	266000        	l8ui	a6, a6, 0
  90e1d4:	250af0        	movi	a5, 240

	/*
	 * Set key type in tx desc while sending the encrypted challenge to AP
	 * in Auth frame 3 of Shared Authentication, owl needs this.
	 */
	if (iswep && (keyix != HAL_TXKEYIX_INVALID) &&
  90e1d7:	056601        	and	a6, a6, a5
  90e1da:	250ab0        	movi	a5, 176
  90e1dd:	756911        	bne	a6, a5, 90e1f2 <ath_tgt_send_mgt+0x372>
			(wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK) == IEEE80211_FC0_SUBTYPE_AUTH)
		ah->ah_fillKeyTxDesc(ds, mh->keytype);
  90e1e0:	261235        	l32i	a6, a1, 212
  90e1e3:	2b3004        	l8ui	a11, a3, 4
  90e1e6:	2a1238        	l32i	a10, a1, 224
  90e1e9:	236219        	l32i	a3, a6, 100
  90e1ec:	00bb32        	sext	a11, a11, 7
  90e1ef:	0b3000        	callx8	a3

	ath_filltxdesc(sc, bf);
  90e1f2:	da20      	mov.n	a10, a2
  90e1f4:	db70      	mov.n	a11, a7
  90e1f6:	5bfbbe        	call8	90d0f0 <ath_filltxdesc>

	for (i=0; i<4; i++) {
		series[i].Tries = 2;
		series[i].Rate = txrate;
		series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
  90e1f9:	232d16        	addmi	a3, a2, 0x1600
  90e1fc:	2a3026        	l8ui	a10, a3, 38
  90e1ff:	231c20        	addi	a3, a1, 32
	sc->sc_tx_stats.ast_tx_shortretry += sr;
	sc->sc_tx_stats.ast_tx_longretry += lr;
}

void
ath_tgt_send_mgt(struct ath_softc_tgt *sc,adf_nbuf_t hdr_buf, adf_nbuf_t skb,
  90e202:	263c70        	addi	a6, a3, 112
		ah->ah_fillKeyTxDesc(ds, mh->keytype);

	ath_filltxdesc(sc, bf);

	for (i=0; i<4; i++) {
		series[i].Tries = 2;
  90e205:	c0b2      	movi.n	a11, 2
		series[i].Rate = txrate;
		series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
		series[i].RateFlags = 0;
  90e207:	c090      	movi.n	a9, 0

	ath_filltxdesc(sc, bf);

	for (i=0; i<4; i++) {
		series[i].Tries = 2;
		series[i].Rate = txrate;
  90e209:	281234        	l32i	a8, a1, 208
		ah->ah_fillKeyTxDesc(ds, mh->keytype);

	ath_filltxdesc(sc, bf);

	for (i=0; i<4; i++) {
		series[i].Tries = 2;
  90e20c:	9b30      	s32i.n	a11, a3, 0
		series[i].Rate = txrate;
  90e20e:	9831      	s32i.n	a8, a3, 4
		series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
  90e210:	9a33      	s32i.n	a10, a3, 12
		series[i].RateFlags = 0;
  90e212:	9934      	s32i.n	a9, a3, 16
  90e214:	233c1c        	addi	a3, a3, 28
  90e217:	c050      	movi.n	a5, 0
			(wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK) == IEEE80211_FC0_SUBTYPE_AUTH)
		ah->ah_fillKeyTxDesc(ds, mh->keytype);

	ath_filltxdesc(sc, bf);

	for (i=0; i<4; i++) {
  90e219:	7639ec        	bne	a3, a6, 90e209 <ath_tgt_send_mgt+0x389>
		series[i].Tries = 2;
		series[i].Rate = txrate;
		series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
		series[i].RateFlags = 0;
	}
	ah->ah_set11nRateScenario(ds, 0, ctsrate, series, 4, 0);
  90e21c:	261235        	l32i	a6, a1, 212
  90e21f:	2a1238        	l32i	a10, a1, 224
  90e222:	236210        	l32i	a3, a6, 64
  90e225:	db50      	mov.n	a11, a5
  90e227:	dc40      	mov.n	a12, a4
  90e229:	df50      	mov.n	a15, a5
  90e22b:	2d1c20        	addi	a13, a1, 32
  90e22e:	2e0a04        	movi	a14, 4
  90e231:	0b3000        	callx8	a3
static void
ath_tgt_txqaddbuf(struct ath_softc_tgt *sc,
		  struct ath_txq *txq, struct ath_tx_buf *bf,
		  struct ath_tx_desc *lastds)
{
	struct ath_hal *ah = sc->sc_ah;
  90e234:	232d05        	addmi	a3, a2, 0x500
  90e237:	843b      	l32i.n	a4, a3, 44

	ATH_TXQ_INSERT_TAIL(txq, bf, bf_list);
  90e239:	233aec        	movi	a3, 0x3ec
  90e23c:	a323      	add.n	a3, a2, a3
  90e23e:	9579      	s32i.n	a5, a7, 36
  90e240:	8533      	l32i.n	a5, a3, 12
		series[i].Rate = txrate;
		series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
		series[i].RateFlags = 0;
	}
	ah->ah_set11nRateScenario(ds, 0, ctsrate, series, 4, 0);
	ath_tgt_txqaddbuf(sc, txq, bf, bf->bf_lastds);
  90e242:	867e      	l32i.n	a6, a7, 56
		  struct ath_txq *txq, struct ath_tx_buf *bf,
		  struct ath_tx_desc *lastds)
{
	struct ath_hal *ah = sc->sc_ah;

	ATH_TXQ_INSERT_TAIL(txq, bf, bf_list);
  90e244:	957a      	s32i.n	a5, a7, 40
  90e246:	9750      	s32i.n	a7, a5, 0
  90e248:	257c24        	addi	a5, a7, 36
  90e24b:	9533      	s32i.n	a5, a3, 12
  90e24d:	8534      	l32i.n	a5, a3, 16
  90e24f:	9735      	s32i.n	a7, a3, 20
  90e251:	b155      	addi.n	a5, a5, 1
  90e253:	9534      	s32i.n	a5, a3, 16

	if (txq->axq_link == NULL) {
  90e255:	8531      	l32i.n	a5, a3, 4
  90e257:	cc5d      	bnez.n	a5, 90e268 <ath_tgt_send_mgt+0x3e8>
		ah->ah_setTxDP(ah, txq->axq_qnum, ATH_BUF_GET_DESC_PHY_ADDR(bf));
  90e259:	854a      	l32i.n	a5, a4, 40
  90e25b:	8b30      	l32i.n	a11, a3, 0
  90e25d:	8c7c      	l32i.n	a12, a7, 48
  90e25f:	da40      	mov.n	a10, a4
  90e261:	0b5000        	callx8	a5
  90e264:	600004        	j	90e26c <ath_tgt_send_mgt+0x3ec>
  90e267:	00837c        	excw
	} else {
		*txq->axq_link = ATH_BUF_GET_DESC_PHY_ADDR(bf);
  90e26a:	9350      	s32i.n	a3, a5, 0
	}

	txq->axq_link = &lastds->ds_link;
  90e26c:	233aec        	movi	a3, 0x3ec
  90e26f:	a322      	add.n	a2, a2, a3
	ah->ah_startTxDma(ah, txq->axq_qnum);
  90e271:	8b20      	l32i.n	a11, a2, 0
  90e273:	834c      	l32i.n	a3, a4, 48
		ah->ah_setTxDP(ah, txq->axq_qnum, ATH_BUF_GET_DESC_PHY_ADDR(bf));
	} else {
		*txq->axq_link = ATH_BUF_GET_DESC_PHY_ADDR(bf);
	}

	txq->axq_link = &lastds->ds_link;
  90e275:	9621      	s32i.n	a6, a2, 4
	ah->ah_startTxDma(ah, txq->axq_qnum);
  90e277:	da40      	mov.n	a10, a4
  90e279:	0b3000        	callx8	a3
  90e27c:	d10f      	retw.n
  90e27e:	000000        	ill
	ah->ah_set11nRateScenario(ds, 0, ctsrate, series, 4, 0);
	ath_tgt_txqaddbuf(sc, txq, bf, bf->bf_lastds);

	return;
fail:
	HTC_ReturnBuffers(sc->tgt_htc_handle, endpt, skb);
  90e281:	136915        	l32r	a3, 8e86d8 <memset+0x1890>
  90e284:	8a22      	l32i.n	a10, a2, 8
  90e286:	233282        	l32i	a3, a3, 0x208
  90e289:	db50      	mov.n	a11, a5
  90e28b:	dc40      	mov.n	a12, a4
  90e28d:	0b3000        	callx8	a3
  90e290:	d10f      	retw.n
	...

0090e294 <ath_tgt_handle_normal>:
	txq->axq_link = &lastds->ds_link;
	ah->ah_startTxDma(ah, txq->axq_qnum);
}

void ath_tgt_handle_normal(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90e294:	6c1004        	entry	a1, 32
	ath_atx_tid_t *tid;
	struct ath_node_target *an;

	an = (struct ath_node_target *)bf->bf_node;
  90e297:	253204        	l32i	a5, a3, 16
	adf_os_assert(an);
  90e29a:	655017        	bnez	a5, 90e2b5 <ath_tgt_handle_normal+0x21>
  90e29d:	146915        	l32r	a4, 8e86f4 <memset+0x18ac>
  90e2a0:	1a6afb        	l32r	a10, 8e8e8c <memset+0x2044>
  90e2a3:	244212        	l32i	a4, a4, 72
  90e2a6:	1b6b0b        	l32r	a11, 8e8ed4 <memset+0x208c>
  90e2a9:	0b4000        	callx8	a4
  90e2ac:	14697a        	l32r	a4, 8e8894 <memset+0x1a4c>
  90e2af:	0c0200        	memw
  90e2b2:	244200        	l32i	a4, a4, 0

	tid = &an->tid[bf->bf_tidno];
  90e2b5:	24304d        	l8ui	a4, a3, 77
  90e2b8:	0c4811        	slli	a8, a4, 4
  90e2bb:	04840c        	sub	a4, a8, a4
  90e2be:	05440a        	addx4	a4, a4, a5
  90e2c1:	244c24        	addi	a4, a4, 36
	adf_os_assert(tid);
  90e2c4:	cd45      	bnez.n	a4, 90e2dd <ath_tgt_handle_normal+0x49>
  90e2c6:	156915        	l32r	a5, 8e871c <memset+0x18d4>
  90e2c9:	1a6afb        	l32r	a10, 8e8eb8 <memset+0x2070>
  90e2cc:	255212        	l32i	a5, a5, 72
  90e2cf:	1b6b0b        	l32r	a11, 8e8efc <memset+0x20b4>
  90e2d2:	0b5000        	callx8	a5
  90e2d5:	15697a        	l32r	a5, 8e88c0 <memset+0x1a78>
  90e2d8:	0c0200        	memw
  90e2db:	8550      	l32i.n	a5, a5, 0

	bf->bf_comp = ath_tgt_tx_comp_normal;
  90e2dd:	156b0c        	l32r	a5, 8e8f10 <memset+0x20c8>
	INCR(tid->seq_start, IEEE80211_SEQ_MAX);
	ath_tgt_tx_send_normal(sc, bf);
  90e2e0:	da20      	mov.n	a10, a2
	adf_os_assert(an);

	tid = &an->tid[bf->bf_tidno];
	adf_os_assert(tid);

	bf->bf_comp = ath_tgt_tx_comp_normal;
  90e2e2:	953f      	s32i.n	a5, a3, 60
	INCR(tid->seq_start, IEEE80211_SEQ_MAX);
  90e2e4:	254102        	l16ui	a5, a4, 4
	ath_tgt_tx_send_normal(sc, bf);
  90e2e7:	db30      	mov.n	a11, a3

	tid = &an->tid[bf->bf_tidno];
	adf_os_assert(tid);

	bf->bf_comp = ath_tgt_tx_comp_normal;
	INCR(tid->seq_start, IEEE80211_SEQ_MAX);
  90e2e9:	b155      	addi.n	a5, a5, 1
  90e2eb:	05054b        	extui	a5, a5, 0, 12
  90e2ee:	254502        	s16i	a5, a4, 4
	ath_tgt_tx_send_normal(sc, bf);
  90e2f1:	5bfec2        	call8	90ddfc <ath_tgt_tx_send_normal>
  90e2f4:	d10f      	retw.n
	...

0090e2f8 <ath_tx_addto_baw>:

	return ATH_TGT_AGGR_DONE;
}

void ath_tx_addto_baw(ath_atx_tid_t *tid, struct ath_tx_buf *bf)
{
  90e2f8:	6c1004        	entry	a1, 32
	int index, cindex;

	if (bf->bf_isretried) {
  90e2fb:	283221        	l32i	a8, a3, 132
  90e2fe:	7b8f3e        	bbsi	a8, 27, 90e340 <ath_tx_addto_baw+0x48>
		return;
	}

	index  = ATH_BA_INDEX(tid->seq_start, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90e301:	293123        	l16ui	a9, a3, 70
  90e304:	232102        	l16ui	a3, a2, 4
  90e307:	094914        	srli	a9, a9, 4
  90e30a:	03990c        	sub	a9, a9, a3
	cindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);
  90e30d:	8a23      	l32i.n	a10, a2, 12

	if (bf->bf_isretried) {
		return;
	}

	index  = ATH_BA_INDEX(tid->seq_start, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90e30f:	09094b        	extui	a9, a9, 0, 12
	cindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);
  90e312:	a9ac      	add.n	a12, a10, a9
  90e314:	0c0846        	extui	a8, a12, 0, 7

	TX_BUF_BITMAP_SET(tid->tx_buf_bitmap, cindex);
  90e317:	085b12        	srai	a11, a8, 5
  90e31a:	b4bb      	addi.n	a11, a11, 4
  90e31c:	02bb0a        	addx4	a11, a11, a2
  90e31f:	c031      	movi.n	a3, 1
  90e321:	00c104        	ssl	a12
  90e324:	003c1a        	sll	a12, a3
  90e327:	83b1      	l32i.n	a3, a11, 4
  90e329:	0c3c02        	or	a12, a3, a12

	if (index >= ((tid->baw_tail - tid->baw_head) & (ATH_TID_MAX_BUFS - 1))) {
  90e32c:	8324      	l32i.n	a3, a2, 16
	}

	index  = ATH_BA_INDEX(tid->seq_start, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
	cindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);

	TX_BUF_BITMAP_SET(tid->tx_buf_bitmap, cindex);
  90e32e:	9cb1      	s32i.n	a12, a11, 4

	if (index >= ((tid->baw_tail - tid->baw_head) & (ATH_TID_MAX_BUFS - 1))) {
  90e330:	0a3a0c        	sub	a10, a3, a10
  90e333:	0a0a46        	extui	a10, a10, 0, 7
  90e336:	7a9206        	blt	a9, a10, 90e340 <ath_tx_addto_baw+0x48>
		tid->baw_tail = cindex;
		INCR(tid->baw_tail, ATH_TID_MAX_BUFS);
  90e339:	b188      	addi.n	a8, a8, 1
  90e33b:	080846        	extui	a8, a8, 0, 7
  90e33e:	9824      	s32i.n	a8, a2, 16
  90e340:	d10f      	retw.n
	...

0090e344 <ath_tgt_tx_form_aggr>:
	return aggr_limit;
}

int ath_tgt_tx_form_aggr(struct ath_softc_tgt *sc, ath_atx_tid_t *tid,
			 ath_tx_bufhead *bf_q)
{
  90e344:	6c100c        	entry	a1, 96
  90e347:	9219      	s32i.n	a2, a1, 36
	struct ath_tx_buf *bf_first ,*bf_prev = NULL;
	int nframes = 0, rl = 0;;
	struct ath_tx_desc *ds = NULL;
	struct ath_tx_buf *bf;
	struct ath_hal *ah = sc->sc_ah;
  90e349:	8519      	l32i.n	a5, a1, 36
	return aggr_limit;
}

int ath_tgt_tx_form_aggr(struct ath_softc_tgt *sc, ath_atx_tid_t *tid,
			 ath_tx_bufhead *bf_q)
{
  90e34b:	d230      	mov.n	a2, a3
	struct ath_tx_buf *bf_first ,*bf_prev = NULL;
	int nframes = 0, rl = 0;;
	struct ath_tx_desc *ds = NULL;
	struct ath_tx_buf *bf;
	struct ath_hal *ah = sc->sc_ah;
  90e34d:	235d05        	addmi	a3, a5, 0x500
  90e350:	833b      	l32i.n	a3, a3, 44
  90e352:	c186      	movi.n	a8, 22
  90e354:	931d      	s32i.n	a3, a1, 52
	u_int16_t aggr_limit =  (64*1024 -1), al = 0, bpad = 0, al_delta;
	u_int16_t h_baw = tid->baw_size/2, prev_al = 0, prev_frames = 0;
  90e356:	232104        	l16ui	a3, a2, 8
	return aggr_limit;
}

int ath_tgt_tx_form_aggr(struct ath_softc_tgt *sc, ath_atx_tid_t *tid,
			 ath_tx_bufhead *bf_q)
{
  90e359:	941b      	s32i.n	a4, a1, 44
	int nframes = 0, rl = 0;;
	struct ath_tx_desc *ds = NULL;
	struct ath_tx_buf *bf;
	struct ath_hal *ah = sc->sc_ah;
	u_int16_t aggr_limit =  (64*1024 -1), al = 0, bpad = 0, al_delta;
	u_int16_t h_baw = tid->baw_size/2, prev_al = 0, prev_frames = 0;
  90e35b:	031314        	srli	a3, a3, 1
  90e35e:	981c      	s32i.n	a8, a1, 48
  90e360:	c155      	movi.n	a5, 21

	bf_first = asf_tailq_first(&tid->buf_q);
  90e362:	842b      	l32i.n	a4, a2, 44
  90e364:	735301        	bltu	a5, a3, 90e369 <ath_tgt_tx_form_aggr+0x25>
  90e367:	931c      	s32i.n	a3, a1, 48
	struct ath_tx_buf *bf_first ,*bf_prev = NULL;
	int nframes = 0, rl = 0;;
	struct ath_tx_desc *ds = NULL;
	struct ath_tx_buf *bf;
	struct ath_hal *ah = sc->sc_ah;
	u_int16_t aggr_limit =  (64*1024 -1), al = 0, bpad = 0, al_delta;
  90e369:	196a07        	l32r	a9, 8e8b88 <memset+0x1d40>
  90e36c:	c070      	movi.n	a7, 0
  90e36e:	d670      	mov.n	a6, a7
  90e370:	991a      	s32i.n	a9, a1, 40

int ath_tgt_tx_form_aggr(struct ath_softc_tgt *sc, ath_atx_tid_t *tid,
			 ath_tx_bufhead *bf_q)
{
	struct ath_tx_buf *bf_first ,*bf_prev = NULL;
	int nframes = 0, rl = 0;;
  90e372:	dd70      	mov.n	a13, a7
  90e374:	d570      	mov.n	a5, a7
}

int ath_tgt_tx_form_aggr(struct ath_softc_tgt *sc, ath_atx_tid_t *tid,
			 ath_tx_bufhead *bf_q)
{
	struct ath_tx_buf *bf_first ,*bf_prev = NULL;
  90e376:	9718      	s32i.n	a7, a1, 32
	u_int16_t h_baw = tid->baw_size/2, prev_al = 0, prev_frames = 0;

	bf_first = asf_tailq_first(&tid->buf_q);

	do {
		bf = asf_tailq_first(&tid->buf_q);
  90e378:	832b      	l32i.n	a3, a2, 44
		adf_os_assert(bf);
  90e37a:	cd3a      	bnez.n	a3, 90e398 <ath_tgt_tx_form_aggr+0x54>
  90e37c:	186915        	l32r	a8, 8e87d0 <memset+0x1988>
  90e37f:	1a6afb        	l32r	a10, 8e8f6c <memset+0x2124>
  90e382:	2c8212        	l32i	a12, a8, 72
  90e385:	1b6b0d        	l32r	a11, 8e8fbc <memset+0x2174>
  90e388:	9d1e      	s32i.n	a13, a1, 56
  90e38a:	0bc000        	callx8	a12
  90e38d:	1a697a        	l32r	a10, 8e8978 <memset+0x1b30>
  90e390:	8d1e      	l32i.n	a13, a1, 56
  90e392:	0c0200        	memw
  90e395:	2aa200        	l32i	a10, a10, 0

		if (!BAW_WITHIN(tid->seq_start, tid->baw_size,
  90e398:	2b3123        	l16ui	a11, a3, 70
  90e39b:	2a2102        	l16ui	a10, a2, 4
  90e39e:	0b4b14        	srli	a11, a11, 4
  90e3a1:	0abb0c        	sub	a11, a11, a10
  90e3a4:	2a2104        	l16ui	a10, a2, 8
  90e3a7:	0b0b4b        	extui	a11, a11, 0, 12
  90e3aa:	7ab20a        	blt	a11, a10, 90e3b8 <ath_tgt_tx_form_aggr+0x74>
				SEQNO_FROM_BF_SEQNO(bf->bf_seqno))) {

			bf_first->bf_al= al;
  90e3ad:	264527        	s16i	a6, a4, 78
			bf_first->bf_nframes = nframes;
  90e3b0:	25444c        	s8i	a5, a4, 76
			return ATH_TGT_AGGR_BAW_CLOSED;
  90e3b3:	c021      	movi.n	a2, 1
  90e3b5:	d10f      	retw.n
  90e3b7:	0065d0        	excw
		}

		if (!rl) {
  90e3ba:	ad89      	add.n	a9, a8, a13
				 struct ath_tx_buf *bf)
{
	int i, prate;
	u_int32_t max4msframelen, frame_length;
	u_int16_t aggr_limit, legacy=0;
	const HAL_RATE_TABLE  *rt = sc->sc_currates;
  90e3bc:	19882e        	l32r	a9, 8f0474 <memset+0x962c>
  90e3bf:	299281        	l32i	a9, a9, 0x204
  90e3c2:	991a      	s32i.n	a9, a1, 40
	struct ieee80211_node_target *ieee_node = (struct ieee80211_node_target *)an;

	if (bf->bf_ismcast) {
  90e3c4:	2a3221        	l32i	a10, a3, 132
  90e3c7:	78a719        	bbci	a10, 24, 90e3e4 <ath_tgt_tx_form_aggr+0xa0>
		bf->bf_rcs[1].tries = bf->bf_rcs[2].tries = bf->bf_rcs[3].tries = 0;
		bf->bf_rcs[0].rix   = 0xb;
  90e3ca:	c0ab      	movi.n	a10, 11
  90e3cc:	2a3450        	s8i	a10, a3, 80
		bf->bf_rcs[0].tries = ATH_TXMAXTRY - 1;
  90e3cf:	c0aa      	movi.n	a10, 10
	u_int16_t aggr_limit, legacy=0;
	const HAL_RATE_TABLE  *rt = sc->sc_currates;
	struct ieee80211_node_target *ieee_node = (struct ieee80211_node_target *)an;

	if (bf->bf_ismcast) {
		bf->bf_rcs[1].tries = bf->bf_rcs[2].tries = bf->bf_rcs[3].tries = 0;
  90e3d1:	2d3475        	s8i	a13, a3, 117
  90e3d4:	2d3469        	s8i	a13, a3, 105
  90e3d7:	2d345d        	s8i	a13, a3, 93
		bf->bf_rcs[0].rix   = 0xb;
		bf->bf_rcs[0].tries = ATH_TXMAXTRY - 1;
  90e3da:	2a3451        	s8i	a10, a3, 81
		bf->bf_rcs[0].flags = 0;
  90e3dd:	2d3453        	s8i	a13, a3, 83
  90e3e0:	60001f        	j	90e403 <ath_tgt_tx_form_aggr+0xbf>
  90e3e3:	002a3c        	excw
	} else {
		ath_tgt_rate_findrate(sc, an, AH_TRUE, 0, ATH_TXMAXTRY-1, 4, 1,
				      ATH_RC_PROBE_ALLOWED, bf->bf_rcs, &prate);
  90e3e6:	509a12        	call0	934c30 <_etext+0x25b17>
				  a_int32_t stepDnInc,
				  a_uint32_t rcflag,
				  struct ath_rc_series series[],
				  a_int32_t *isProbe)
{
	ath_rate_findrate(sc, an, 1, frameLen, 10, 4, 1,
  90e3e9:	2a1c10        	addi	a10, a1, 16
  90e3ec:	c0c1      	movi.n	a12, 1
  90e3ee:	9a13      	s32i.n	a10, a1, 12
  90e3f0:	8a19      	l32i.n	a10, a1, 36
  90e3f2:	db80      	mov.n	a11, a8
  90e3f4:	9c10      	s32i.n	a12, a1, 0
  90e3f6:	9c11      	s32i.n	a12, a1, 4
  90e3f8:	c0ea      	movi.n	a14, 10
  90e3fa:	c0f4      	movi.n	a15, 4
  90e3fc:	981e      	s32i.n	a8, a1, 56
  90e3fe:	5bfa7f        	call8	90cdfc <ath_rate_findrate>
  90e401:	881e      	l32i.n	a8, a1, 56
}

int ath_tgt_tx_form_aggr(struct ath_softc_tgt *sc, ath_atx_tid_t *tid,
			 ath_tx_bufhead *bf_q)
{
	struct ath_tx_buf *bf_first ,*bf_prev = NULL;
  90e403:	1b6a07        	l32r	a11, 8e8c20 <memset+0x1dd8>
  90e406:	033a02        	or	a10, a3, a3
  90e409:	2c0a00        	movi	a12, 0
	}

	max4msframelen = IEEE80211_AMPDU_LIMIT_MAX;

	for (i = 0; i < 4; i++) {
		if (bf->bf_rcs[i].tries) {
  90e40c:	2da051        	l8ui	a13, a10, 81
  90e40f:	c9d5      	beqz.n	a13, 90e428 <ath_tgt_tx_form_aggr+0xe4>
			frame_length = bf->bf_rcs[i].max4msframelen;

			if (rt->info[bf->bf_rcs[i].rix].phy != IEEE80211_T_HT) {
  90e411:	2da050        	l8ui	a13, a10, 80
  90e414:	891a      	l32i.n	a9, a1, 40
  90e416:	0ddd0a        	addx4	a13, a13, a13
  90e419:	09dd0a        	addx4	a13, a13, a9
  90e41c:	2dd029        	l8ui	a13, a13, 41

	max4msframelen = IEEE80211_AMPDU_LIMIT_MAX;

	for (i = 0; i < 4; i++) {
		if (bf->bf_rcs[i].tries) {
			frame_length = bf->bf_rcs[i].max4msframelen;
  90e41f:	2ea215        	l32i	a14, a10, 84

			if (rt->info[bf->bf_rcs[i].rix].phy != IEEE80211_T_HT) {
  90e422:	69d40f        	bnei	a13, 4, 90e435 <ath_tgt_tx_form_aggr+0xf1>
				legacy = 1;
				break;
			}

			max4msframelen = ATH_MIN(max4msframelen, frame_length);
  90e425:	0ebb36        	minu	a11, a11, a14
				      ATH_RC_PROBE_ALLOWED, bf->bf_rcs, &prate);
	}

	max4msframelen = IEEE80211_AMPDU_LIMIT_MAX;

	for (i = 0; i < 4; i++) {
  90e428:	b1cc      	addi.n	a12, a12, 1
  90e42a:	bcaa      	addi.n	a10, a10, 12
  90e42c:	69c4dc        	bnei	a12, 4, 90e40c <ath_tgt_tx_form_aggr+0xc8>
				 struct ath_node_target *an,
				 struct ath_tx_buf *bf)
{
	int i, prate;
	u_int32_t max4msframelen, frame_length;
	u_int16_t aggr_limit, legacy=0;
  90e42f:	c0c0      	movi.n	a12, 0
  90e431:	600002        	j	90e437 <ath_tgt_tx_form_aggr+0xf3>
  90e434:	00c0c1        	excw

			max4msframelen = ATH_MIN(max4msframelen, frame_length);
		}
	}

	if (prate || legacy)
  90e437:	8d14      	l32i.n	a13, a1, 16
		return 0;
  90e439:	c0a0      	movi.n	a10, 0

			max4msframelen = ATH_MIN(max4msframelen, frame_length);
		}
	}

	if (prate || legacy)
  90e43b:	7ad925        	bne	a13, a10, 90e464 <ath_tgt_tx_form_aggr+0x120>
		return 0;
  90e43e:	dad0      	mov.n	a10, a13

			max4msframelen = ATH_MIN(max4msframelen, frame_length);
		}
	}

	if (prate || legacy)
  90e440:	cec0      	bnez.n	a12, 90e464 <ath_tgt_tx_form_aggr+0x120>
		return 0;

	if (sc->sc_ic.ic_enable_coex)
  90e442:	8919      	l32i.n	a9, a1, 36
  90e444:	2a9d16        	addmi	a10, a9, 0x1600
  90e447:	2ca025        	l8ui	a12, a10, 37
  90e44a:	8aa8      	l32i.n	a10, a10, 32
  90e44c:	64c005        	beqz	a12, 90e455 <ath_tgt_tx_form_aggr+0x111>
		aggr_limit = ATH_MIN((max4msframelen*3)/8, sc->sc_ic.ic_ampdu_limit);
  90e44f:	0bbb09        	addx2	a11, a11, a11
  90e452:	0b3b14        	srli	a11, a11, 3
	else
		aggr_limit = ATH_MIN(max4msframelen, sc->sc_ic.ic_ampdu_limit);
  90e455:	0aba36        	minu	a10, a11, a10

	if (ieee_node->ni_maxampdu)
  90e458:	28810a        	l16ui	a8, a8, 20
		return 0;

	if (sc->sc_ic.ic_enable_coex)
		aggr_limit = ATH_MIN((max4msframelen*3)/8, sc->sc_ic.ic_ampdu_limit);
	else
		aggr_limit = ATH_MIN(max4msframelen, sc->sc_ic.ic_ampdu_limit);
  90e45b:	0a0a4f        	extui	a10, a10, 0, 16

	if (ieee_node->ni_maxampdu)
		aggr_limit = ATH_MIN(aggr_limit, ieee_node->ni_maxampdu);
  90e45e:	08ab36        	minu	a11, a10, a8
  90e461:	08ba39        	movnez	a10, a11, a8
			bf_first->bf_nframes = nframes;
			return ATH_TGT_AGGR_BAW_CLOSED;
		}

		if (!rl) {
			aggr_limit = ath_lookup_rate(sc, tid->an, bf);
  90e464:	0a0a4f        	extui	a10, a10, 0, 16
  90e467:	9a1a      	s32i.n	a10, a1, 40
			rl = 1;
		}

		al_delta = ATH_AGGR_DELIM_SZ + bf->bf_pktlen;
  90e469:	2c3122        	l16ui	a12, a3, 68
  90e46c:	b4cc      	addi.n	a12, a12, 4
  90e46e:	0c0c4f        	extui	a12, a12, 0, 16

		if (nframes && (aggr_limit < (al + bpad + al_delta + prev_al))) {
  90e471:	c85b      	beqz.n	a5, 90e480 <ath_tgt_tx_form_aggr+0x13c>
  90e473:	a76a      	add.n	a10, a6, a7
  90e475:	881a      	l32i.n	a8, a1, 40
  90e477:	acaa      	add.n	a10, a10, a12
  90e479:	7a8a03        	bge	a8, a10, 90e480 <ath_tgt_tx_form_aggr+0x13c>
  90e47c:	600005        	j	90e485 <ath_tgt_tx_form_aggr+0x141>
  90e47f:	00891c        	mul16u	a9, a8, a0
		}

#ifdef PROJECT_K2
		if ((nframes + prev_frames) >= ATH_MIN((h_baw), 17)) {
#else
		if ((nframes + prev_frames) >= ATH_MIN((h_baw), 22)) {
  90e482:	79520a        	blt	a5, a9, 90e490 <ath_tgt_tx_form_aggr+0x14c>
#endif
			bf_first->bf_al= al;
  90e485:	264527        	s16i	a6, a4, 78
			bf_first->bf_nframes = nframes;
  90e488:	25444c        	s8i	a5, a4, 76
			return ATH_TGT_AGGR_LIMITED;
  90e48b:	c022      	movi.n	a2, 2
  90e48d:	d10f      	retw.n
  90e48f:	00da20        	excw
		}

		ath_tx_addto_baw(tid, bf);
  90e492:	db30      	mov.n	a11, a3
  90e494:	9c1f      	s32i.n	a12, a1, 60
  90e496:	5bff98        	call8	90e2f8 <ath_tx_addto_baw>
		asf_tailq_remove(&tid->buf_q, bf, bf_list);
  90e499:	8a39      	l32i.n	a10, a3, 36
  90e49b:	8b3a      	l32i.n	a11, a3, 40
  90e49d:	8c1f      	l32i.n	a12, a1, 60
  90e49f:	c8a3      	beqz.n	a10, 90e4a6 <ath_tgt_tx_form_aggr+0x162>
  90e4a1:	9baa      	s32i.n	a11, a10, 40
  90e4a3:	600001        	j	90e4a8 <ath_tgt_tx_form_aggr+0x164>
  90e4a6:	9b2c      	s32i.n	a11, a2, 48
  90e4a8:	8b3a      	l32i.n	a11, a3, 40
		asf_tailq_insert_tail(bf_q, bf, bf_list);
  90e4aa:	881b      	l32i.n	a8, a1, 44
			bf_first->bf_nframes = nframes;
			return ATH_TGT_AGGR_LIMITED;
		}

		ath_tx_addto_baw(tid, bf);
		asf_tailq_remove(&tid->buf_q, bf, bf_list);
  90e4ac:	9ab0      	s32i.n	a10, a11, 0
		asf_tailq_insert_tail(bf_q, bf, bf_list);
  90e4ae:	c0a0      	movi.n	a10, 0
  90e4b0:	9a39      	s32i.n	a10, a3, 36
  90e4b2:	8a81      	l32i.n	a10, a8, 4
		nframes ++;
  90e4b4:	b155      	addi.n	a5, a5, 1
			return ATH_TGT_AGGR_LIMITED;
		}

		ath_tx_addto_baw(tid, bf);
		asf_tailq_remove(&tid->buf_q, bf, bf_list);
		asf_tailq_insert_tail(bf_q, bf, bf_list);
  90e4b6:	9a3a      	s32i.n	a10, a3, 40
  90e4b8:	93a0      	s32i.n	a3, a10, 0
  90e4ba:	2a3c24        	addi	a10, a3, 36
  90e4bd:	9a81      	s32i.n	a10, a8, 4
		nframes ++;

		adf_os_assert(bf);

		adf_os_assert(bf->bf_comp == ath_tgt_tx_comp_aggr);
  90e4bf:	8b3f      	l32i.n	a11, a3, 60
  90e4c1:	1a6b0e        	l32r	a10, 8e90fc <memset+0x22b4>
  90e4c4:	7ab11a        	beq	a11, a10, 90e4e2 <ath_tgt_tx_form_aggr+0x19e>
  90e4c7:	1a6915        	l32r	a10, 8e891c <memset+0x1ad4>
  90e4ca:	1b6b0d        	l32r	a11, 8e9100 <memset+0x22b8>
  90e4cd:	2da212        	l32i	a13, a10, 72
  90e4d0:	1a6afb        	l32r	a10, 8e90bc <memset+0x2274>
  90e4d3:	9c1f      	s32i.n	a12, a1, 60
  90e4d5:	0bd000        	callx8	a13
  90e4d8:	1a697a        	l32r	a10, 8e8ac0 <memset+0x1c78>
  90e4db:	8c1f      	l32i.n	a12, a1, 60
  90e4dd:	0c0200        	memw
  90e4e0:	8aa0      	l32i.n	a10, a10, 0

		al += bpad + al_delta;
  90e4e2:	a766      	add.n	a6, a6, a7
		bf->bf_ndelim = ATH_AGGR_GET_NDELIM(bf->bf_pktlen);
  90e4e4:	273122        	l16ui	a7, a3, 68

		adf_os_assert(bf);

		adf_os_assert(bf->bf_comp == ath_tgt_tx_comp_aggr);

		al += bpad + al_delta;
  90e4e7:	ac66      	add.n	a6, a6, a12
		bf->bf_ndelim = ATH_AGGR_GET_NDELIM(bf->bf_pktlen);
  90e4e9:	2b0afb        	movi	a11, 251

		adf_os_assert(bf);

		adf_os_assert(bf->bf_comp == ath_tgt_tx_comp_aggr);

		al += bpad + al_delta;
  90e4ec:	06064f        	extui	a6, a6, 0, 16
		bf->bf_ndelim = ATH_AGGR_GET_NDELIM(bf->bf_pktlen);
  90e4ef:	c0a0      	movi.n	a10, 0
  90e4f1:	77b208        	blt	a11, a7, 90e4fd <ath_tgt_tx_form_aggr+0x1b9>
  90e4f4:	2a0afc        	movi	a10, 252
  90e4f7:	07aa0c        	sub	a10, a10, a7
  90e4fa:	0a2a47        	extui	a10, a10, 2, 8

		switch (bf->bf_keytype) {
  90e4fd:	2b3085        	l8ui	a11, a3, 133
		adf_os_assert(bf);

		adf_os_assert(bf->bf_comp == ath_tgt_tx_comp_aggr);

		al += bpad + al_delta;
		bf->bf_ndelim = ATH_AGGR_GET_NDELIM(bf->bf_pktlen);
  90e500:	2a344b        	s8i	a10, a3, 75

		switch (bf->bf_keytype) {
  90e503:	68b212        	beqi	a11, 2, 90e519 <ath_tgt_tx_form_aggr+0x1d5>
  90e506:	6fb306        	bgeui	a11, 3, 90e510 <ath_tgt_tx_form_aggr+0x1cc>
  90e509:	69b11f        	bnei	a11, 1, 90e52c <ath_tgt_tx_form_aggr+0x1e8>
  90e50c:	600010        	j	90e520 <ath_tgt_tx_form_aggr+0x1dc>
  90e50f:	0068b3        	excw
  90e512:	0c69b4        	excw
  90e515:	156000        	l32r	a5, 8e6518 <_xtos_set_exception_handler+0x1d0>
  90e518:	0dbaaa        	excw
		case HAL_KEY_TYPE_AES:
			bf->bf_ndelim += ATH_AGGR_ENCRYPTDELIM;
  90e51b:	60000a        	j	90e529 <ath_tgt_tx_form_aggr+0x1e5>
  90e51e:	00002a        	muluh	a0, a0, a0
			break;
		case HAL_KEY_TYPE_WEP:
		case HAL_KEY_TYPE_TKIP:
			bf->bf_ndelim += 64;
  90e521:	ac40      	add.n	a0, a4, a12
  90e523:	600002        	j	90e529 <ath_tgt_tx_form_aggr+0x1e5>
  90e526:	00bcaa        	excw
			break;
		case HAL_KEY_TYPE_WAPI:
			bf->bf_ndelim += 12;
  90e529:	2a344b        	s8i	a10, a3, 75
			break;
		default:
			break;
		}

		bpad = PADBYTES(al_delta) + (bf->bf_ndelim << 2);
  90e52c:	0c0c06        	neg	a12, a12
  90e52f:	27304b        	l8ui	a7, a3, 75

		if (bf_prev) {
  90e532:	8918      	l32i.n	a9, a1, 32
			break;
		default:
			break;
		}

		bpad = PADBYTES(al_delta) + (bf->bf_ndelim << 2);
  90e534:	0c0c41        	extui	a12, a12, 0, 2
  90e537:	0c770a        	addx4	a7, a7, a12

		if (bf_prev) {
  90e53a:	c99a      	beqz.n	a9, 90e558 <ath_tgt_tx_form_aggr+0x214>
			bf_prev->bf_next = bf;
			bf_prev->bf_lastds->ds_link = ATH_BUF_GET_DESC_PHY_ADDR(bf);
  90e53c:	2b3030        	l8ui	a11, a3, 48
  90e53f:	8a9e      	l32i.n	a10, a9, 56
		}

		bpad = PADBYTES(al_delta) + (bf->bf_ndelim << 2);

		if (bf_prev) {
			bf_prev->bf_next = bf;
  90e541:	939b      	s32i.n	a3, a9, 44
			bf_prev->bf_lastds->ds_link = ATH_BUF_GET_DESC_PHY_ADDR(bf);
  90e543:	2ba400        	s8i	a11, a10, 0
  90e546:	2b3031        	l8ui	a11, a3, 49
  90e549:	2ba401        	s8i	a11, a10, 1
  90e54c:	2b3032        	l8ui	a11, a3, 50
  90e54f:	2ba402        	s8i	a11, a10, 2
  90e552:	2b3033        	l8ui	a11, a3, 51
  90e555:	2ba403        	s8i	a11, a10, 3
		}
		bf_prev = bf;

		for(ds = bf->bf_desc; ds <= bf->bf_lastds; ds++)
  90e558:	8c3c      	l32i.n	a12, a3, 48
  90e55a:	2d0a88        	movi	a13, 136
  90e55d:	600016        	j	90e577 <ath_tgt_tx_form_aggr+0x233>
			ah->ah_set11nAggrMiddle(ds, bf->bf_ndelim);
  90e560:	881d      	l32i.n	a8, a1, 52
  90e562:	2b304b        	l8ui	a11, a3, 75
  90e565:	2e8212        	l32i	a14, a8, 72
  90e568:	dac0      	mov.n	a10, a12
  90e56a:	9c1f      	s32i.n	a12, a1, 60
  90e56c:	9d1e      	s32i.n	a13, a1, 56
  90e56e:	0be000        	callx8	a14
			bf_prev->bf_next = bf;
			bf_prev->bf_lastds->ds_link = ATH_BUF_GET_DESC_PHY_ADDR(bf);
		}
		bf_prev = bf;

		for(ds = bf->bf_desc; ds <= bf->bf_lastds; ds++)
  90e571:	8c1f      	l32i.n	a12, a1, 60
  90e573:	8d1e      	l32i.n	a13, a1, 56
  90e575:	adcc      	add.n	a12, a12, a13
  90e577:	8a3e      	l32i.n	a10, a3, 56
  90e579:	7cabe3        	bgeu	a10, a12, 90e560 <ath_tgt_tx_form_aggr+0x21c>
			ah->ah_set11nAggrMiddle(ds, bf->bf_ndelim);

	} while (!asf_tailq_empty(&tid->buf_q));
  90e57c:	882b      	l32i.n	a8, a2, 44
  90e57e:	9318      	s32i.n	a3, a1, 32
  90e580:	c0d1      	movi.n	a13, 1
  90e582:	658df2        	bnez	a8, 90e378 <ath_tgt_tx_form_aggr+0x34>

	bf_first->bf_al= al;
  90e585:	264527        	s16i	a6, a4, 78
	bf_first->bf_nframes = nframes;
  90e588:	25444c        	s8i	a5, a4, 76

	return ATH_TGT_AGGR_DONE;
  90e58b:	d280      	mov.n	a2, a8
}
  90e58d:	d10f      	retw.n
	...

0090e590 <ath_tgt_txq_schedule>:
	asf_tailq_insert_tail(&txq->axq_tidq, tid, tid_qelem);
}

static void
ath_tgt_txq_schedule(struct ath_softc_tgt *sc, struct ath_txq *txq)
{
  90e590:	6c1008        	entry	a1, 64
	u_int8_t bdone;

	bdone = AH_FALSE;

	do {
		TAILQ_DEQ(&txq->axq_tidq, tid, tid_qelem);
  90e593:	8536      	l32i.n	a5, a3, 24
  90e595:	6451ff        	beqz	a5, 90e798 <ath_tgt_txq_schedule+0x208>
  90e598:	8459      	l32i.n	a4, a5, 36
  90e59a:	865a      	l32i.n	a6, a5, 40
  90e59c:	c844      	beqz.n	a4, 90e5a4 <ath_tgt_txq_schedule+0x14>
  90e59e:	964a      	s32i.n	a6, a4, 40
  90e5a0:	600002        	j	90e5a6 <ath_tgt_txq_schedule+0x16>
  90e5a3:	009637        	maxu	a6, a9, a0
  90e5a6:	865a      	l32i.n	a6, a5, 40
  90e5a8:	9460      	s32i.n	a4, a6, 0
		if (tid == NULL)
			return;

		tid->sched = AH_FALSE;

		if (tid->paused)
  90e5aa:	275034        	l8ui	a7, a5, 52
		TAILQ_DEQ(&txq->axq_tidq, tid, tid_qelem);

		if (tid == NULL)
			return;

		tid->sched = AH_FALSE;
  90e5ad:	c040      	movi.n	a4, 0
  90e5af:	245435        	s8i	a4, a5, 53

		if (tid->paused)
  90e5b2:	007732        	sext	a7, a7, 7
  90e5b5:	c040      	movi.n	a4, 0
  90e5b7:	747102        	beq	a7, a4, 90e5bd <ath_tgt_txq_schedule+0x2d>
  90e5ba:	6001d3        	j	90e791 <ath_tgt_txq_schedule+0x201>
			continue;

		if (!(tid->flag & TID_AGGR_ENABLED))
  90e5bd:	285036        	l8ui	a8, a5, 54
  90e5c0:	c042      	movi.n	a4, 2
  90e5c2:	048801        	and	a8, a8, a4
  90e5c5:	c061      	movi.n	a6, 1
  90e5c7:	8450      	l32i.n	a4, a5, 0
  90e5c9:	65804f        	bnez	a8, 90e61c <ath_tgt_txq_schedule+0x8c>

static void
ath_tgt_tx_sched_normal(struct ath_softc_tgt *sc, ath_atx_tid_t *tid)
{
	struct ath_tx_buf *bf;
	struct ath_txq *txq =TID_TO_ACTXQ(tid->tidno);;
  90e5cc:	274cfd        	addi	a7, a4, -3
  90e5cf:	d980      	mov.n	a9, a8
  90e5d1:	076939        	movnez	a9, a6, a7
  90e5d4:	c996      	beqz.n	a9, 90e5ee <ath_tgt_txq_schedule+0x5e>
  90e5d6:	046839        	movnez	a8, a6, a4
  90e5d9:	c981      	beqz.n	a8, 90e5ee <ath_tgt_txq_schedule+0x5e>
  90e5db:	b047      	addi.n	a7, a4, -1
  90e5dd:	6e720f        	bltui	a7, 2, 90e5f0 <ath_tgt_txq_schedule+0x60>
  90e5e0:	244cfc        	addi	a4, a4, -4
  90e5e3:	c063      	movi.n	a6, 3
  90e5e5:	6f4207        	bgeui	a4, 2, 90e5f0 <ath_tgt_txq_schedule+0x60>
  90e5e8:	c062      	movi.n	a6, 2
  90e5ea:	600002        	j	90e5f0 <ath_tgt_txq_schedule+0x60>
  90e5ed:	00c060        	excw
  90e5f0:	02660a        	addx4	a6, a6, a2
  90e5f3:	266d05        	addmi	a6, a6, 0x500
  90e5f6:	8763      	l32i.n	a7, a6, 12

	do {
		if (asf_tailq_empty(&tid->buf_q))
  90e5f8:	8b5b      	l32i.n	a11, a5, 44
  90e5fa:	64b186        	beqz	a11, 90e784 <ath_tgt_txq_schedule+0x1f4>
			break;

		bf = asf_tailq_first(&tid->buf_q);
		asf_tailq_remove(&tid->buf_q, bf, bf_list);
  90e5fd:	84b9      	l32i.n	a4, a11, 36
  90e5ff:	86ba      	l32i.n	a6, a11, 40
  90e601:	c844      	beqz.n	a4, 90e609 <ath_tgt_txq_schedule+0x79>
  90e603:	964a      	s32i.n	a6, a4, 40
  90e605:	600002        	j	90e60b <ath_tgt_txq_schedule+0x7b>
  90e608:	00965c        	extui	a6, a0, 25, 13
  90e60b:	86ba      	l32i.n	a6, a11, 40
		ath_tgt_tx_send_normal(sc, bf);
  90e60d:	da20      	mov.n	a10, a2
	do {
		if (asf_tailq_empty(&tid->buf_q))
			break;

		bf = asf_tailq_first(&tid->buf_q);
		asf_tailq_remove(&tid->buf_q, bf, bf_list);
  90e60f:	9460      	s32i.n	a4, a6, 0
		ath_tgt_tx_send_normal(sc, bf);
  90e611:	5bfdfa        	call8	90ddfc <ath_tgt_tx_send_normal>

	} while (txq->axq_depth < ATH_AGGR_MIN_QDEPTH);
  90e614:	8474      	l32i.n	a4, a7, 16
  90e616:	644fde        	beqz	a4, 90e5f8 <ath_tgt_txq_schedule+0x68>
  90e619:	600167        	j	90e784 <ath_tgt_txq_schedule+0x1f4>
ath_tgt_tx_sched_aggr(struct ath_softc_tgt *sc, ath_atx_tid_t *tid)
{
	struct ath_tx_buf  *bf, *bf_last;
	ATH_AGGR_STATUS status;
	ath_tx_bufhead bf_q;
	struct ath_txq *txq = TID_TO_ACTXQ(tid->tidno);
  90e61c:	284cfd        	addi	a8, a4, -3
  90e61f:	d970      	mov.n	a9, a7
  90e621:	086939        	movnez	a9, a6, a8
  90e624:	090847        	extui	a8, a9, 0, 8
  90e627:	c98b      	beqz.n	a8, 90e646 <ath_tgt_txq_schedule+0xb6>
  90e629:	046739        	movnez	a7, a6, a4
  90e62c:	070747        	extui	a7, a7, 0, 8
  90e62f:	c973      	beqz.n	a7, 90e646 <ath_tgt_txq_schedule+0xb6>
  90e631:	b047      	addi.n	a7, a4, -1
  90e633:	6e7211        	bltui	a7, 2, 90e648 <ath_tgt_txq_schedule+0xb8>
  90e636:	244cfc        	addi	a4, a4, -4
  90e639:	c063      	movi.n	a6, 3
  90e63b:	6f4209        	bgeui	a4, 2, 90e648 <ath_tgt_txq_schedule+0xb8>
  90e63e:	c062      	movi.n	a6, 2
  90e640:	600004        	j	90e648 <ath_tgt_txq_schedule+0xb8>
  90e643:	000000        	ill
  90e646:	c060      	movi.n	a6, 0
  90e648:	02660a        	addx4	a6, a6, a2
  90e64b:	266d05        	addmi	a6, a6, 0x500
  90e64e:	8663      	l32i.n	a6, a6, 12
	struct ath_tx_desc *ds = NULL;
	struct ath_hal *ah = sc->sc_ah;
  90e650:	242d05        	addmi	a4, a2, 0x500
ath_tgt_tx_sched_aggr(struct ath_softc_tgt *sc, ath_atx_tid_t *tid)
{
	struct ath_tx_buf  *bf, *bf_last;
	ATH_AGGR_STATUS status;
	ath_tx_bufhead bf_q;
	struct ath_txq *txq = TID_TO_ACTXQ(tid->tidno);
  90e653:	9615      	s32i.n	a6, a1, 20
	struct ath_tx_desc *ds = NULL;
	struct ath_hal *ah = sc->sc_ah;
  90e655:	864b      	l32i.n	a6, a4, 44
	int i;


	if (asf_tailq_empty(&tid->buf_q))
  90e657:	845b      	l32i.n	a4, a5, 44
  90e659:	644127        	beqz	a4, 90e784 <ath_tgt_txq_schedule+0x1f4>

	do {
		if (asf_tailq_empty(&tid->buf_q))
			break;

		asf_tailq_init(&bf_q);
  90e65c:	c040      	movi.n	a4, 0

	if (asf_tailq_empty(&tid->buf_q))
		return;

	do {
		if (asf_tailq_empty(&tid->buf_q))
  90e65e:	875b      	l32i.n	a7, a5, 44
  90e660:	647120        	beqz	a7, 90e784 <ath_tgt_txq_schedule+0x1f4>
			break;

		asf_tailq_init(&bf_q);

		status = ath_tgt_tx_form_aggr(sc, tid, &bf_q);
  90e663:	da20      	mov.n	a10, a2
  90e665:	db50      	mov.n	a11, a5
  90e667:	dc10      	mov.n	a12, a1

	do {
		if (asf_tailq_empty(&tid->buf_q))
			break;

		asf_tailq_init(&bf_q);
  90e669:	9410      	s32i.n	a4, a1, 0
  90e66b:	9111      	s32i.n	a1, a1, 4

		status = ath_tgt_tx_form_aggr(sc, tid, &bf_q);
  90e66d:	5bff35        	call8	90e344 <ath_tgt_tx_form_aggr>

		if (asf_tailq_empty(&bf_q))
  90e670:	8710      	l32i.n	a7, a1, 0
		if (asf_tailq_empty(&tid->buf_q))
			break;

		asf_tailq_init(&bf_q);

		status = ath_tgt_tx_form_aggr(sc, tid, &bf_q);
  90e672:	9a14      	s32i.n	a10, a1, 16

		if (asf_tailq_empty(&bf_q))
  90e674:	64710c        	beqz	a7, 90e784 <ath_tgt_txq_schedule+0x1f4>
			break;

		bf = asf_tailq_first(&bf_q);
		bf_last = asf_tailq_last(&bf_q, ath_tx_bufhead_s);
  90e677:	8a11      	l32i.n	a10, a1, 4
  90e679:	8aa1      	l32i.n	a10, a10, 4
  90e67b:	8da0      	l32i.n	a13, a10, 0

		if (bf->bf_nframes == 1) {
  90e67d:	2a704c        	l8ui	a10, a7, 76
  90e680:	69a166        	bnei	a10, 1, 90e6ea <ath_tgt_txq_schedule+0x15a>

			if(bf->bf_retries == 0)
  90e683:	2a7086        	l8ui	a10, a7, 134
  90e686:	cca6      	bnez.n	a10, 90e690 <ath_tgt_txq_schedule+0x100>
				__stats(sc, txaggr_single);
  90e688:	2a2261        	l32i	a10, a2, 0x184
  90e68b:	b1aa      	addi.n	a10, a10, 1
  90e68d:	2a2661        	s32i	a10, a2, 0x184
			bf->bf_isaggr = 0;
  90e690:	2b7087        	l8ui	a11, a7, 135
  90e693:	2afadf        	movi	a10, -33
  90e696:	0aba01        	and	a10, a11, a10
  90e699:	2a7487        	s8i	a10, a7, 135
			bf->bf_lastds = &(bf->bf_descarr[bf->bf_dmamap_info.nsegs -1]);
  90e69c:	8a71      	l32i.n	a10, a7, 4
			bf->bf_lastds->ds_link = 0;
  90e69e:	c080      	movi.n	a8, 0
		if (bf->bf_nframes == 1) {

			if(bf->bf_retries == 0)
				__stats(sc, txaggr_single);
			bf->bf_isaggr = 0;
			bf->bf_lastds = &(bf->bf_descarr[bf->bf_dmamap_info.nsegs -1]);
  90e6a0:	b0aa      	addi.n	a10, a10, -1
  90e6a2:	0cab11        	slli	a11, a10, 4
  90e6a5:	aaba      	add.n	a10, a11, a10
  90e6a7:	8b7d      	l32i.n	a11, a7, 52
			bf->bf_lastds->ds_link = 0;
			bf->bf_next = NULL;

			for(ds = bf->bf_desc; ds <= bf->bf_lastds; ds++)
  90e6a9:	2c0a88        	movi	a12, 136
		if (bf->bf_nframes == 1) {

			if(bf->bf_retries == 0)
				__stats(sc, txaggr_single);
			bf->bf_isaggr = 0;
			bf->bf_lastds = &(bf->bf_descarr[bf->bf_dmamap_info.nsegs -1]);
  90e6ac:	0baa0b        	addx8	a10, a10, a11
  90e6af:	9a7e      	s32i.n	a10, a7, 56
			bf->bf_lastds->ds_link = 0;
  90e6b1:	24a400        	s8i	a4, a10, 0
  90e6b4:	28a401        	s8i	a8, a10, 1
  90e6b7:	28a402        	s8i	a8, a10, 2
  90e6ba:	28a403        	s8i	a8, a10, 3
			bf->bf_next = NULL;
  90e6bd:	947b      	s32i.n	a4, a7, 44

			for(ds = bf->bf_desc; ds <= bf->bf_lastds; ds++)
  90e6bf:	8b7c      	l32i.n	a11, a7, 48
  90e6c1:	600013        	j	90e6d8 <ath_tgt_txq_schedule+0x148>
				ah->ah_clr11nAggr(ds);
  90e6c4:	2d6214        	l32i	a13, a6, 80
  90e6c7:	dab0      	mov.n	a10, a11
  90e6c9:	2b1607        	s32i	a11, a1, 28
  90e6cc:	2c1606        	s32i	a12, a1, 24
  90e6cf:	0bd000        	callx8	a13
			bf->bf_isaggr = 0;
			bf->bf_lastds = &(bf->bf_descarr[bf->bf_dmamap_info.nsegs -1]);
			bf->bf_lastds->ds_link = 0;
			bf->bf_next = NULL;

			for(ds = bf->bf_desc; ds <= bf->bf_lastds; ds++)
  90e6d2:	8b17      	l32i.n	a11, a1, 28
  90e6d4:	8c16      	l32i.n	a12, a1, 24
  90e6d6:	acbb      	add.n	a11, a11, a12
  90e6d8:	8a7e      	l32i.n	a10, a7, 56
  90e6da:	7babe6        	bgeu	a10, a11, 90e6c4 <ath_tgt_txq_schedule+0x134>
				ah->ah_clr11nAggr(ds);

			ath_buf_set_rate(sc, bf);
  90e6dd:	da20      	mov.n	a10, a2
  90e6df:	db70      	mov.n	a11, a7
  90e6e1:	5bfaf0        	call8	90d2a4 <ath_buf_set_rate>
  90e6e4:	600084        	j	90e76c <ath_tgt_txq_schedule+0x1dc>
  90e6e7:	000000        	ill

			continue;
		}

		bf_last->bf_next = NULL;
		bf_last->bf_lastds->ds_link = 0;
  90e6ea:	8ade      	l32i.n	a10, a13, 56
			bf->bf_txq_add(sc, bf);

			continue;
		}

		bf_last->bf_next = NULL;
  90e6ec:	94db      	s32i.n	a4, a13, 44
		bf_last->bf_lastds->ds_link = 0;
  90e6ee:	24a400        	s8i	a4, a10, 0
  90e6f1:	24a401        	s8i	a4, a10, 1
  90e6f4:	24a402        	s8i	a4, a10, 2
  90e6f7:	24a403        	s8i	a4, a10, 3
		bf_last->bf_ndelim = 0;
  90e6fa:	24d44b        	s8i	a4, a13, 75

		bf->bf_isaggr  = 1;
  90e6fd:	2b7087        	l8ui	a11, a7, 135
  90e700:	c2a0      	movi.n	a10, 32
  90e702:	0aba02        	or	a10, a11, a10
  90e705:	2a7487        	s8i	a10, a7, 135
		ath_buf_set_rate(sc, bf);
  90e708:	db70      	mov.n	a11, a7
  90e70a:	da20      	mov.n	a10, a2
  90e70c:	2d1606        	s32i	a13, a1, 24
  90e70f:	5bfae5        	call8	90d2a4 <ath_buf_set_rate>
		ah->ah_set11nAggrFirst(bf->bf_desc, bf->bf_al,
  90e712:	8a7c      	l32i.n	a10, a7, 48
  90e714:	2b7127        	l16ui	a11, a7, 78
  90e717:	2e6211        	l32i	a14, a6, 68
  90e71a:	2c704b        	l8ui	a12, a7, 75
  90e71d:	0be000        	callx8	a14
					  bf->bf_ndelim);
		bf->bf_lastds = bf_last->bf_lastds;
  90e720:	8d16      	l32i.n	a13, a1, 24

		for (i = 0; i < bf_last->bf_dmamap_info.nsegs; i++)
  90e722:	c0b0      	movi.n	a11, 0

		bf->bf_isaggr  = 1;
		ath_buf_set_rate(sc, bf);
		ah->ah_set11nAggrFirst(bf->bf_desc, bf->bf_al,
					  bf->bf_ndelim);
		bf->bf_lastds = bf_last->bf_lastds;
  90e724:	8ade      	l32i.n	a10, a13, 56
  90e726:	9a7e      	s32i.n	a10, a7, 56
  90e728:	60001b        	j	90e747 <ath_tgt_txq_schedule+0x1b7>
  90e72b:	00008a        	excw

		for (i = 0; i < bf_last->bf_dmamap_info.nsegs; i++)
			ah->ah_set11nAggrLast(&bf_last->bf_descarr[i]);
  90e72e:	dd0c      	excw
	tid->sched = AH_TRUE;
	asf_tailq_insert_tail(&txq->axq_tidq, tid, tid_qelem);
}

static void
ath_tgt_txq_schedule(struct ath_softc_tgt *sc, struct ath_txq *txq)
  90e730:	be11      	addi.n	a1, a1, 14
  90e732:	abee      	add.n	a14, a14, a11
		ah->ah_set11nAggrFirst(bf->bf_desc, bf->bf_al,
					  bf->bf_ndelim);
		bf->bf_lastds = bf_last->bf_lastds;

		for (i = 0; i < bf_last->bf_dmamap_info.nsegs; i++)
			ah->ah_set11nAggrLast(&bf_last->bf_descarr[i]);
  90e734:	2c6213        	l32i	a12, a6, 76
  90e737:	0aea0b        	addx8	a10, a14, a10
  90e73a:	9b17      	s32i.n	a11, a1, 28
  90e73c:	9d16      	s32i.n	a13, a1, 24
  90e73e:	0bc000        	callx8	a12
		ath_buf_set_rate(sc, bf);
		ah->ah_set11nAggrFirst(bf->bf_desc, bf->bf_al,
					  bf->bf_ndelim);
		bf->bf_lastds = bf_last->bf_lastds;

		for (i = 0; i < bf_last->bf_dmamap_info.nsegs; i++)
  90e741:	8b17      	l32i.n	a11, a1, 28
  90e743:	8d16      	l32i.n	a13, a1, 24
  90e745:	b1bb      	addi.n	a11, a11, 1
  90e747:	8ad1      	l32i.n	a10, a13, 4
  90e749:	7ab3e0        	bltu	a11, a10, 90e72d <ath_tgt_txq_schedule+0x19d>
			ah->ah_set11nAggrLast(&bf_last->bf_descarr[i]);

		if (status == ATH_AGGR_8K_LIMITED) {
  90e74c:	8914      	l32i.n	a9, a1, 16
  90e74e:	69941a        	bnei	a9, 4, 90e76c <ath_tgt_txq_schedule+0x1dc>
			adf_os_assert(0);
  90e751:	146915        	l32r	a4, 8e8ba8 <memset+0x1d60>
  90e754:	1a6afb        	l32r	a10, 8e9340 <memset+0x24f8>
  90e757:	244212        	l32i	a4, a4, 72
  90e75a:	1b6b0f        	l32r	a11, 8e9398 <memset+0x2550>
  90e75d:	0b4000        	callx8	a4
  90e760:	14697a        	l32r	a4, 8e8d48 <memset+0x1f00>
  90e763:	0c0200        	memw
  90e766:	8440      	l32i.n	a4, a4, 0
  90e768:	600018        	j	90e784 <ath_tgt_txq_schedule+0x1f4>
  90e76b:	002c72        	excw
			break;
		}

		bf->bf_txq_add(sc, bf);
  90e76e:	10da20        	l32r	a0, 904ff0 <memset+0x1e1a8>
  90e771:	db70      	mov.n	a11, a7
  90e773:	0bc000        	callx8	a12
	} while (txq->axq_depth < ATH_AGGR_MIN_QDEPTH &&
		 status != ATH_TGT_AGGR_BAW_CLOSED);
  90e776:	8915      	l32i.n	a9, a1, 20
  90e778:	8894      	l32i.n	a8, a9, 16
  90e77a:	cc86      	bnez.n	a8, 90e784 <ath_tgt_txq_schedule+0x1f4>
			adf_os_assert(0);
			break;
		}

		bf->bf_txq_add(sc, bf);
	} while (txq->axq_depth < ATH_AGGR_MIN_QDEPTH &&
  90e77c:	8814      	l32i.n	a8, a1, 16
  90e77e:	688102        	beqi	a8, 1, 90e784 <ath_tgt_txq_schedule+0x1f4>
  90e781:	63fed9        	j	90e65e <ath_tgt_txq_schedule+0xce>
		else
			ath_tgt_tx_sched_aggr(sc,tid);

		bdone = AH_TRUE;

		if (!asf_tailq_empty(&tid->buf_q)) {
  90e784:	865b      	l32i.n	a6, a5, 44
		if (!(tid->flag & TID_AGGR_ENABLED))
			ath_tgt_tx_sched_normal(sc,tid);
		else
			ath_tgt_tx_sched_aggr(sc,tid);

		bdone = AH_TRUE;
  90e786:	c041      	movi.n	a4, 1

		if (!asf_tailq_empty(&tid->buf_q)) {
  90e788:	c865      	beqz.n	a6, 90e791 <ath_tgt_txq_schedule+0x201>
			ath_tgt_tx_enqueue(txq, tid);
  90e78a:	da30      	mov.n	a10, a3
  90e78c:	db50      	mov.n	a11, a5
  90e78e:	5bfa96        	call8	90d1e8 <ath_tgt_tx_enqueue>
		}

	} while (!asf_tailq_empty(&txq->axq_tidq) && !bdone);
  90e791:	8636      	l32i.n	a6, a3, 24
  90e793:	c861      	beqz.n	a6, 90e798 <ath_tgt_txq_schedule+0x208>
  90e795:	644dfa        	beqz	a4, 90e593 <ath_tgt_txq_schedule+0x3>
  90e798:	d10f      	retw.n
	...

0090e79c <ath_aggr_resume_tid>:
	return ((((x) & 0xff00) >> 8) |   (((x) & 0x00ff) << 8));
}

static inline void
ath_aggr_resume_tid(struct ath_softc_tgt *sc, ath_atx_tid_t *tid)
{
  90e79c:	6c1004        	entry	a1, 32
	struct ath_txq *txq;

	txq = TID_TO_ACTXQ(tid->tidno);
  90e79f:	8930      	l32i.n	a9, a3, 0
  90e7a1:	c081      	movi.n	a8, 1
  90e7a3:	249cfd        	addi	a4, a9, -3
  90e7a6:	c0b0      	movi.n	a11, 0
  90e7a8:	048b39        	movnez	a11, a8, a4
  90e7ab:	c9b3      	beqz.n	a11, 90e7c2 <ath_aggr_resume_tid+0x26>
  90e7ad:	c991      	beqz.n	a9, 90e7c2 <ath_aggr_resume_tid+0x26>
  90e7af:	b094      	addi.n	a4, a9, -1
  90e7b1:	6e420f        	bltui	a4, 2, 90e7c4 <ath_aggr_resume_tid+0x28>
  90e7b4:	299cfc        	addi	a9, a9, -4
  90e7b7:	c083      	movi.n	a8, 3
  90e7b9:	6f9207        	bgeui	a9, 2, 90e7c4 <ath_aggr_resume_tid+0x28>
  90e7bc:	c082      	movi.n	a8, 2
  90e7be:	600002        	j	90e7c4 <ath_aggr_resume_tid+0x28>
  90e7c1:	00c080        	excw
  90e7c4:	02880a        	addx4	a8, a8, a2
  90e7c7:	288d05        	addmi	a8, a8, 0x500
  90e7ca:	8483      	l32i.n	a4, a8, 12
	tid->paused = 0;
  90e7cc:	c080      	movi.n	a8, 0
  90e7ce:	283434        	s8i	a8, a3, 52

	if (asf_tailq_empty(&tid->buf_q))
  90e7d1:	883b      	l32i.n	a8, a3, 44
  90e7d3:	c88d      	beqz.n	a8, 90e7e4 <ath_aggr_resume_tid+0x48>
		return;

	ath_tgt_tx_enqueue(txq, tid);
  90e7d5:	da40      	mov.n	a10, a4
  90e7d7:	033b02        	or	a11, a3, a3
  90e7da:	5bfa83        	call8	90d1e8 <ath_tgt_tx_enqueue>
	ath_tgt_txq_schedule(sc, txq);
  90e7dd:	da20      	mov.n	a10, a2
  90e7df:	db40      	mov.n	a11, a4
  90e7e1:	5bff6b        	call8	90e590 <ath_tgt_txq_schedule>
  90e7e4:	d10f      	retw.n
	...

0090e7e8 <owl_tgt_tid_cleanup>:
	}
}

static void owl_tgt_tid_cleanup(struct ath_softc_tgt *sc,
				struct ath_atx_tid *tid)
{
  90e7e8:	6c1004        	entry	a1, 32
	tid->incomp--;
  90e7eb:	283037        	l8ui	a8, a3, 55
	}
}

static void owl_tgt_tid_cleanup(struct ath_softc_tgt *sc,
				struct ath_atx_tid *tid)
{
  90e7ee:	da20      	mov.n	a10, a2
	tid->incomp--;
  90e7f0:	b088      	addi.n	a8, a8, -1
  90e7f2:	080847        	extui	a8, a8, 0, 8
  90e7f5:	283437        	s8i	a8, a3, 55
	if (tid->incomp) {
  90e7f8:	cf85      	bnez.n	a8, 90e831 <owl_tgt_tid_cleanup+0x49>
		return;
	}

	tid->flag &= ~TID_CLEANUP_INPROGRES;
  90e7fa:	283036        	l8ui	a8, a3, 54
  90e7fd:	29fafe        	movi	a9, -2
  90e800:	098901        	and	a9, a8, a9
  90e803:	293436        	s8i	a9, a3, 54

	if (tid->flag & TID_REINITIALIZE) {
  90e806:	7d8722        	bbci	a8, 29, 90e82c <owl_tgt_tid_cleanup+0x44>
		adf_os_print("TID REINIT DONE for tid %p\n", tid);
  90e809:	186915        	l32r	a8, 8e8c60 <memset+0x1e18>
  90e80c:	1a6b10        	l32r	a10, 8e944c <memset+0x2604>
  90e80f:	288212        	l32i	a8, a8, 72
  90e812:	033b02        	or	a11, a3, a3
  90e815:	0b8000        	callx8	a8
		tid->flag  &= ~TID_REINITIALIZE;
  90e818:	293036        	l8ui	a9, a3, 54
  90e81b:	c78b      	movi.n	a8, -5
  90e81d:	089801        	and	a8, a9, a8
  90e820:	283436        	s8i	a8, a3, 54
		owl_tgt_tid_init(tid);
  90e823:	da30      	mov.n	a10, a3
  90e825:	5bf9b8        	call8	90cf08 <owl_tgt_tid_init>
  90e828:	d10f      	retw.n
  90e82a:	0000db        	excw
	} else {
		ath_aggr_resume_tid(sc, tid);
  90e82d:	305bff        	excw
  90e830:	dbd1      	excw
  90e832:	0f006c        	excw

0090e834 <ath_tgt_tx_comp_normal>:
	tid->baw_tail = tid->baw_head;
}

static void ath_tgt_tx_comp_normal(struct ath_softc_tgt *sc,
				   struct ath_tx_buf *bf)
{
  90e834:	6c1004        	entry	a1, 32
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90e837:	28304d        	l8ui	a8, a3, 77
  90e83a:	8934      	l32i.n	a9, a3, 16
  90e83c:	0c8b11        	slli	a11, a8, 4
  90e83f:	08bb0c        	sub	a11, a11, a8
  90e842:	09bb0a        	addx4	a11, a11, a9
  90e845:	2bbc24        	addi	a11, a11, 36

	if (tid->flag & TID_CLEANUP_INPROGRES) {
  90e848:	28b036        	l8ui	a8, a11, 54
  90e84b:	7f8705        	bbci	a8, 31, 90e854 <ath_tgt_tx_comp_normal+0x20>
		owl_tgt_tid_cleanup(sc, tid);
  90e84e:	022a02        	or	a10, a2, a2
  90e851:	5bffe5        	call8	90e7e8 <owl_tgt_tid_cleanup>
	}

	if (bf->bf_node) {
  90e854:	8834      	l32i.n	a8, a3, 16
  90e856:	c98f      	beqz.n	a8, 90e879 <ath_tgt_tx_comp_normal+0x45>
}

static void
ath_tx_uc_comp(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	ath_tx_status_update(sc, bf);
  90e858:	da20      	mov.n	a10, a2
  90e85a:	033b02        	or	a11, a3, a3
  90e85d:	5bfc08        	call8	90d880 <ath_tx_status_update>
	ath_update_stats(sc, bf);
  90e860:	da20      	mov.n	a10, a2
  90e862:	033b02        	or	a11, a3, a3
  90e865:	5bf9de        	call8	90cfe0 <ath_update_stats>
	ath_rate_tx_complete(sc, ATH_NODE_TARGET(bf->bf_node),
  90e868:	8b34      	l32i.n	a11, a3, 16
  90e86a:	8c3e      	l32i.n	a12, a3, 56
  90e86c:	da20      	mov.n	a10, a2
  90e86e:	2d3c50        	addi	a13, a3, 80
  90e871:	c0e1      	movi.n	a14, 1
  90e873:	2f0a00        	movi	a15, 0
  90e876:	5bf96c        	call8	90ce28 <ath_rate_tx_complete>

	if (bf->bf_node) {
		ath_tx_uc_comp(sc, bf);
	}

	ath_tx_freebuf(sc, bf);
  90e879:	da20      	mov.n	a10, a2
  90e87b:	db30      	mov.n	a11, a3
  90e87d:	5bfb52        	call8	90d5c8 <ath_tx_freebuf>
  90e880:	d10f      	retw.n
	...

0090e884 <ath_tgt_tx_comp_aggr>:
		INCR(tid->baw_tail, ATH_TID_MAX_BUFS);
	}
}

void ath_tgt_tx_comp_aggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90e884:	6c1032        	entry	a1, 0x190
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90e887:	25304d        	l8ui	a5, a3, 77
	}
}

void ath_tgt_tx_comp_aggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
  90e88a:	8434      	l32i.n	a4, a3, 16
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90e88c:	0c5811        	slli	a8, a5, 4
  90e88f:	05880c        	sub	a8, a8, a5
  90e892:	04880a        	addx4	a8, a8, a4
  90e895:	258c24        	addi	a5, a8, 36
	struct ath_rc_series rcs[4];
	u_int16_t seq_st;
	u_int32_t *ba;
	int ba_index;
	int nbad = 0;
	int nframes = bf->bf_nframes;
  90e898:	26304c        	l8ui	a6, a3, 76
	ath_tx_bufhead bf_q;
	int tx_ok = 1;
	struct ath_tx_buf *bar = NULL;
	struct ath_txq *txq;

	txq = bf->bf_txq;
  90e89b:	283220        	l32i	a8, a3, 128

	if (tid->flag & TID_CLEANUP_INPROGRES) {
  90e89e:	295036        	l8ui	a9, a5, 54
	struct ath_rc_series rcs[4];
	u_int16_t seq_st;
	u_int32_t *ba;
	int ba_index;
	int nbad = 0;
	int nframes = bf->bf_nframes;
  90e8a1:	261654        	s32i	a6, a1, 0x150
	struct ath_tx_buf *bf_next;
	ath_tx_bufhead bf_q;
	int tx_ok = 1;
	struct ath_tx_buf *bar = NULL;
  90e8a4:	c060      	movi.n	a6, 0
  90e8a6:	261652        	s32i	a6, a1, 0x148
	struct ath_txq *txq;

	txq = bf->bf_txq;
  90e8a9:	281655        	s32i	a8, a1, 0x154

	if (tid->flag & TID_CLEANUP_INPROGRES) {
  90e8ac:	090640        	extui	a6, a9, 0, 1
  90e8af:	6460b1        	beqz	a6, 90e964 <ath_tgt_tx_comp_aggr+0xe0>
  90e8b2:	8b3e      	l32i.n	a11, a3, 56
  90e8b4:	da10      	mov.n	a10, a1
  90e8b6:	2c0a88        	movi	a12, 136
  90e8b9:	5bf97b        	call8	90cea8 <__adf_os_mem_copy>
  90e8bc:	2a1a10        	movi	a10, 0x110
  90e8bf:	a1aa      	add.n	a10, a10, a1
  90e8c1:	2b3c50        	addi	a11, a3, 80
  90e8c4:	c3c0      	movi.n	a12, 48
  90e8c6:	5bf978        	call8	90cea8 <__adf_os_mem_copy>

	while (bf) {
		ba_index = ATH_BA_INDEX(seq_st, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
		bf_next  = bf->bf_next;

		ath_tx_status_update_aggr(sc, bf, ds, rcs, 0);
  90e8c9:	281a10        	movi	a8, 0x110

	seq_st = ATH_DS_BA_SEQ(ds);
	ba     = ATH_DS_BA_BITMAP(ds);
	tx_ok  = (ATH_DS_TX_STATUS(ds) == HAL_OK);

	if (!bf->bf_isaggr) {
  90e8cc:	263221        	l32i	a6, a3, 132

	while (bf) {
		ba_index = ATH_BA_INDEX(seq_st, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
		bf_next  = bf->bf_next;

		ath_tx_status_update_aggr(sc, bf, ds, rcs, 0);
  90e8cf:	a188      	add.n	a8, a8, a1
  90e8d1:	d780      	mov.n	a7, a8

	seq_st = ATH_DS_BA_SEQ(ds);
	ba     = ATH_DS_BA_BITMAP(ds);
	tx_ok  = (ATH_DS_TX_STATUS(ds) == HAL_OK);

	if (!bf->bf_isaggr) {
  90e8d3:	7a6f2f        	bbsi	a6, 26, 90e906 <ath_tgt_tx_comp_aggr+0x82>
		ath_update_stats(sc, bf);
  90e8d6:	db30      	mov.n	a11, a3
  90e8d8:	da20      	mov.n	a10, a2
  90e8da:	5bf9c1        	call8	90cfe0 <ath_update_stats>

		__stats(sc, tx_compunaggr);
  90e8dd:	24225e        	l32i	a4, a2, 0x178

		ath_tx_status_update(sc, bf);
  90e8e0:	db30      	mov.n	a11, a3
	tx_ok  = (ATH_DS_TX_STATUS(ds) == HAL_OK);

	if (!bf->bf_isaggr) {
		ath_update_stats(sc, bf);

		__stats(sc, tx_compunaggr);
  90e8e2:	b144      	addi.n	a4, a4, 1

		ath_tx_status_update(sc, bf);
  90e8e4:	022a02        	or	a10, a2, a2
	tx_ok  = (ATH_DS_TX_STATUS(ds) == HAL_OK);

	if (!bf->bf_isaggr) {
		ath_update_stats(sc, bf);

		__stats(sc, tx_compunaggr);
  90e8e7:	24265e        	s32i	a4, a2, 0x178

		ath_tx_status_update(sc, bf);
  90e8ea:	5bfbe5        	call8	90d880 <ath_tx_status_update>

		ath_tx_freebuf(sc, bf);
  90e8ed:	db30      	mov.n	a11, a3
  90e8ef:	da20      	mov.n	a10, a2
  90e8f1:	5bfb35        	call8	90d5c8 <ath_tx_freebuf>

		if (tid->flag & TID_CLEANUP_INPROGRES) {
  90e8f4:	235036        	l8ui	a3, a5, 54
  90e8f7:	7f3f02        	bbsi	a3, 31, 90e8fd <ath_tgt_tx_comp_aggr+0x79>
  90e8fa:	6002fa        	j	90ebf8 <ath_tgt_tx_comp_aggr+0x374>
			owl_tgt_tid_cleanup(sc, tid);
  90e8fd:	da20      	mov.n	a10, a2
  90e8ff:	db50      	mov.n	a11, a5
  90e901:	5bffb9        	call8	90e7e8 <owl_tgt_tid_cleanup>
  90e904:	d10f      	retw.n

	while (bf) {
		ba_index = ATH_BA_INDEX(seq_st, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
		bf_next  = bf->bf_next;

		ath_tx_status_update_aggr(sc, bf, ds, rcs, 0);
  90e906:	db30      	mov.n	a11, a3
  90e908:	da20      	mov.n	a10, a2
  90e90a:	dc10      	mov.n	a12, a1
  90e90c:	dd70      	mov.n	a13, a7
  90e90e:	c0e0      	movi.n	a14, 0
		return;
	}

	while (bf) {
		ba_index = ATH_BA_INDEX(seq_st, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
		bf_next  = bf->bf_next;
  90e910:	26320b        	l32i	a6, a3, 44

		ath_tx_status_update_aggr(sc, bf, ds, rcs, 0);
  90e913:	5bfbfe        	call8	90d90c <ath_tx_status_update_aggr>

		ath_tx_freebuf(sc, bf);
  90e916:	db30      	mov.n	a11, a3
  90e918:	da20      	mov.n	a10, a2
  90e91a:	5bfb2b        	call8	90d5c8 <ath_tx_freebuf>

		tid->incomp--;
  90e91d:	235037        	l8ui	a3, a5, 55
  90e920:	b033      	addi.n	a3, a3, -1
  90e922:	030347        	extui	a3, a3, 0, 8
  90e925:	235437        	s8i	a3, a5, 55
		if (!tid->incomp) {
  90e928:	cd35      	bnez.n	a3, 90e941 <ath_tgt_tx_comp_aggr+0xbd>
			tid->flag  &= ~TID_CLEANUP_INPROGRES;
  90e92a:	265036        	l8ui	a6, a5, 54
  90e92d:	c73e      	movi.n	a3, -2
  90e92f:	036301        	and	a3, a6, a3
  90e932:	235436        	s8i	a3, a5, 54
			ath_aggr_resume_tid(sc, tid);
  90e935:	da20      	mov.n	a10, a2
  90e937:	db50      	mov.n	a11, a5
  90e939:	5bff98        	call8	90e79c <ath_aggr_resume_tid>
  90e93c:	600006        	j	90e946 <ath_tgt_tx_comp_aggr+0xc2>
  90e93f:	0000d3        	excw
			break;
		}

		bf = bf_next;
  90e942:	60656f        	j	914eb5 <_etext+0x5d9c>
		}

		return;
	}

	while (bf) {
  90e945:	bfda      	addi.n	a10, a13, 15
		}

		bf = bf_next;
	}

	ath_update_aggr_stats(sc, ds, nframes, nbad);
  90e947:	20db10        	l32ai	a0, a13, 64
  90e94a:	5bfa30        	call8	90d20c <ath_update_aggr_stats$isra$2>
	ath_rate_tx_complete(sc, an, ds, rcs, nframes, nbad);
  90e94d:	2d1a10        	movi	a13, 0x110
  90e950:	2e1254        	l32i	a14, a1, 0x150
  90e953:	da20      	mov.n	a10, a2
  90e955:	db40      	mov.n	a11, a4
  90e957:	dc10      	mov.n	a12, a1
  90e959:	ad1d      	add.n	a13, a1, a13
  90e95b:	c0f0      	movi.n	a15, 0
  90e95d:	5bf932        	call8	90ce28 <ath_rate_tx_complete>
  90e960:	d10f      	retw.n
  90e962:	00002c        	excw
void ath_tgt_tx_comp_aggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
	struct ath_tx_desc lastds;
	struct ath_tx_desc *ds = &lastds;
  90e965:	0a882b        	mulsh	a8, a8, a10
  90e968:	320e0c        	excw
  90e96b:	1a085b        	l32r	a10, 8d0ad8 <_bss_end+0x3bdbc8>
  90e96e:	f9          	.byte 0xf9
  90e96f:	4e2d3c        	excw
		ath_tx_comp_cleanup(sc, bf);
		return;
	}

	adf_os_mem_copy(ds, bf->bf_lastds, sizeof (struct ath_tx_desc));
	adf_os_mem_copy(rcs, bf->bf_rcs, sizeof(rcs));
  90e972:	502a1a        	call0	9191dc <_etext+0xa0c3>
  90e975:	10aa1a        	l32r	a0, 8f91e0 <memset+0x12398>
  90e978:	0ddb02        	or	a11, a13, a13
  90e97b:	2c0a30        	movi	a12, 48
  90e97e:	2d1658        	s32i	a13, a1, 0x160
  90e981:	5bf949        	call8	90cea8 <__adf_os_mem_copy>

	if (ds->ds_txstat.ts_flags == HAL_TX_SW_FILTERED) {
  90e984:	2a10ef        	l8ui	a10, a1, 239
  90e987:	2d1258        	l32i	a13, a1, 0x160
  90e98a:	69ae1a        	bnei	a10, 128, 90e9a8 <ath_tgt_tx_comp_aggr+0x124>
		adf_os_assert(0);
  90e98d:	126915        	l32r	a2, 8e8de4 <memset+0x1f9c>
  90e990:	1a6afb        	l32r	a10, 8e957c <memset+0x2734>
  90e993:	222212        	l32i	a2, a2, 72
  90e996:	1b6b11        	l32r	a11, 8e95dc <memset+0x2794>
  90e999:	0b2000        	callx8	a2
  90e99c:	12697a        	l32r	a2, 8e8f84 <memset+0x213c>
  90e99f:	0c0200        	memw
  90e9a2:	8220      	l32i.n	a2, a2, 0
  90e9a4:	d10f      	retw.n
  90e9a6:	000027        	excw
		return;
	}

	if (!bf->bf_isaggr) {
  90e9a9:	3221c2        	excw
  90e9ac:	b007      	addi.n	a7, a0, -1
  90e9ae:	b701      	addi.n	a1, a0, 7
  90e9b0:	657104        	bnez	a7, 90eab8 <ath_tgt_tx_comp_aggr+0x234>
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
	struct ath_tx_desc *ds  = bf->bf_lastds;

	ath_update_stats(sc, bf);
  90e9b3:	da20      	mov.n	a10, a2
  90e9b5:	db30      	mov.n	a11, a3
static void
ath_tx_comp_unaggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
	struct ath_tx_desc *ds  = bf->bf_lastds;
  90e9b7:	853e      	l32i.n	a5, a3, 56
}

static void
ath_tx_comp_unaggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
  90e9b9:	8434      	l32i.n	a4, a3, 16
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90e9bb:	26304d        	l8ui	a6, a3, 77
	struct ath_tx_desc *ds  = bf->bf_lastds;

	ath_update_stats(sc, bf);
  90e9be:	2d1658        	s32i	a13, a1, 0x160
  90e9c1:	5bf987        	call8	90cfe0 <ath_update_stats>
	ath_rate_tx_complete(sc, an, ds, bf->bf_rcs, 1, 0);
  90e9c4:	2d1258        	l32i	a13, a1, 0x160
  90e9c7:	dc50      	mov.n	a12, a5
  90e9c9:	da20      	mov.n	a10, a2
  90e9cb:	db40      	mov.n	a11, a4
  90e9cd:	c0e1      	movi.n	a14, 1
  90e9cf:	df70      	mov.n	a15, a7
  90e9d1:	5bf915        	call8	90ce28 <ath_rate_tx_complete>

	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
  90e9d4:	255066        	l8ui	a5, a5, 102
  90e9d7:	7f5f02        	bbsi	a5, 31, 90e9dd <ath_tgt_tx_comp_aggr+0x159>
  90e9da:	6000ab        	j	90ea89 <ath_tgt_tx_comp_aggr+0x205>

static inline void
ath_tx_retry_unaggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90e9dd:	24304d        	l8ui	a4, a3, 77
	struct ath_txq *txq;

	txq = bf->bf_txq;

	if (bf->bf_retries >= OWLMAX_RETRIES) {
  90e9e0:	c079      	movi.n	a7, 9

static inline void
ath_tx_retry_unaggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90e9e2:	0c4511        	slli	a5, a4, 4
  90e9e5:	04540c        	sub	a4, a5, a4
  90e9e8:	8534      	l32i.n	a5, a3, 16
	struct ath_txq *txq;

	txq = bf->bf_txq;
  90e9ea:	263220        	l32i	a6, a3, 128

static inline void
ath_tx_retry_unaggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90e9ed:	05440a        	addx4	a4, a4, a5
	struct ath_txq *txq;

	txq = bf->bf_txq;

	if (bf->bf_retries >= OWLMAX_RETRIES) {
  90e9f0:	253086        	l8ui	a5, a3, 134

static inline void
ath_tx_retry_unaggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90e9f3:	244c24        	addi	a4, a4, 36
	struct ath_txq *txq;

	txq = bf->bf_txq;

	if (bf->bf_retries >= OWLMAX_RETRIES) {
  90e9f6:	757b27        	bgeu	a7, a5, 90ea21 <ath_tgt_tx_comp_aggr+0x19d>
		__stats(sc, txunaggr_xretry);
  90e9f9:	252273        	l32i	a5, a2, 0x1cc
		ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90e9fc:	2b3123        	l16ui	a11, a3, 70
	struct ath_txq *txq;

	txq = bf->bf_txq;

	if (bf->bf_retries >= OWLMAX_RETRIES) {
		__stats(sc, txunaggr_xretry);
  90e9ff:	b155      	addi.n	a5, a5, 1
		ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90ea01:	044a02        	or	a10, a4, a4
	struct ath_txq *txq;

	txq = bf->bf_txq;

	if (bf->bf_retries >= OWLMAX_RETRIES) {
		__stats(sc, txunaggr_xretry);
  90ea04:	252673        	s32i	a5, a2, 0x1cc
		ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90ea07:	0b4b14        	srli	a11, a11, 4
  90ea0a:	5bf991        	call8	90d050 <ath_tx_update_baw>
		ath_tx_status_update(sc, bf);
  90ea0d:	da20      	mov.n	a10, a2
  90ea0f:	db30      	mov.n	a11, a3
  90ea11:	5bfb9b        	call8	90d880 <ath_tx_status_update>
		ath_bar_tx(sc, tid, bf);
  90ea14:	da20      	mov.n	a10, a2
  90ea16:	db40      	mov.n	a11, a4
  90ea18:	dc30      	mov.n	a12, a3
  90ea1a:	5bfb1b        	call8	90d688 <ath_bar_tx>
  90ea1d:	d10f      	retw.n
  90ea1f:	000025        	excw
		return;
	}

	__stats(sc, txunaggr_compretries);
  90ea22:	226db1        	addmi	a2, a6, 0xffffb100
  90ea25:	552526        	call4	957ec0 <_etext+0x48da7>
  90ea28:	6d853e        	excw
	if (!bf->bf_lastds->ds_link) {
  90ea2b:	295000        	l8ui	a9, a5, 0
  90ea2e:	285001        	l8ui	a8, a5, 1
  90ea31:	275002        	l8ui	a7, a5, 2
  90ea34:	089910        	slli	a9, a9, 24
  90ea37:	008811        	slli	a8, a8, 16
  90ea3a:	098802        	or	a8, a8, a9
  90ea3d:	087711        	slli	a7, a7, 8
  90ea40:	255003        	l8ui	a5, a5, 3
  90ea43:	087702        	or	a7, a7, a8
  90ea46:	075502        	or	a5, a5, a7
  90ea49:	cd54      	bnez.n	a5, 90ea61 <ath_tgt_tx_comp_aggr+0x1dd>
		__stats(sc, txunaggr_errlast);
  90ea4b:	252272        	l32i	a5, a2, 0x1c8
		bf = ath_buf_toggle(sc, bf, 1);
  90ea4e:	db30      	mov.n	a11, a3
		return;
	}

	__stats(sc, txunaggr_compretries);
	if (!bf->bf_lastds->ds_link) {
		__stats(sc, txunaggr_errlast);
  90ea50:	b155      	addi.n	a5, a5, 1
  90ea52:	252672        	s32i	a5, a2, 0x1c8
		bf = ath_buf_toggle(sc, bf, 1);
  90ea55:	022a02        	or	a10, a2, a2
  90ea58:	2c0a01        	movi	a12, 1
  90ea5b:	5bfa97        	call8	90d4b8 <ath_buf_toggle>
  90ea5e:	0aa302        	or	a3, a10, a10
	}

	ath_tx_set_retry(sc, bf);
  90ea61:	da20      	mov.n	a10, a2
  90ea63:	db30      	mov.n	a11, a3
  90ea65:	5bfb64        	call8	90d7f8 <ath_tx_set_retry>
	asf_tailq_insert_head(&tid->buf_q, bf, bf_list);
  90ea68:	824b      	l32i.n	a2, a4, 44
  90ea6a:	253c24        	addi	a5, a3, 36
  90ea6d:	9239      	s32i.n	a2, a3, 36
  90ea6f:	c823      	beqz.n	a2, 90ea76 <ath_tgt_tx_comp_aggr+0x1f2>
  90ea71:	952a      	s32i.n	a5, a2, 40
  90ea73:	600001        	j	90ea78 <ath_tgt_tx_comp_aggr+0x1f4>
  90ea76:	954c      	s32i.n	a5, a4, 48
  90ea78:	934b      	s32i.n	a3, a4, 44
  90ea7a:	224c2c        	addi	a2, a4, 44
  90ea7d:	923a      	s32i.n	a2, a3, 40
	ath_tgt_tx_enqueue(txq, tid);
  90ea7f:	da60      	mov.n	a10, a6
  90ea81:	db40      	mov.n	a11, a4
  90ea83:	60016e        	j	90ebf5 <ath_tgt_tx_comp_aggr+0x371>
  90ea86:	000000        	ill

	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
		ath_tx_retry_unaggr(sc, bf);
		return;
	}
	__stats(sc, tx_compunaggr);
  90ea89:	25225e        	l32i	a5, a2, 0x178

	ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90ea8c:	2b3123        	l16ui	a11, a3, 70

	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
		ath_tx_retry_unaggr(sc, bf);
		return;
	}
	__stats(sc, tx_compunaggr);
  90ea8f:	b155      	addi.n	a5, a5, 1
  90ea91:	25265e        	s32i	a5, a2, 0x178

static void
ath_tx_comp_unaggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90ea94:	0c6511        	slli	a5, a6, 4
  90ea97:	06560c        	sub	a6, a5, a6
  90ea9a:	046a0a        	addx4	a10, a6, a4
		ath_tx_retry_unaggr(sc, bf);
		return;
	}
	__stats(sc, tx_compunaggr);

	ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90ea9d:	2aac24        	addi	a10, a10, 36
  90eaa0:	0b4b14        	srli	a11, a11, 4
  90eaa3:	5bf96b        	call8	90d050 <ath_tx_update_baw>
	ath_tx_status_update(sc, bf);
  90eaa6:	da20      	mov.n	a10, a2
  90eaa8:	db30      	mov.n	a11, a3
  90eaaa:	5bfb75        	call8	90d880 <ath_tx_status_update>
	ath_tx_freebuf(sc, bf);
  90eaad:	da20      	mov.n	a10, a2
  90eaaf:	db30      	mov.n	a11, a3
  90eab1:	5bfac5        	call8	90d5c8 <ath_tx_freebuf>
  90eab4:	d10f      	retw.n
  90eab6:	000027        	excw
	if (!bf->bf_isaggr) {
		ath_tx_comp_unaggr(sc, bf);
		return;
	}

	__stats(sc, tx_compaggr);
  90eab9:	225f26        	s32ri	a2, a5, 152

	asf_tailq_init(&bf_q);
  90eabc:	1650b1        	l32r	a6, 8e2d80 <athos_indirection_table_install+0x180c>
	if (!bf->bf_isaggr) {
		ath_tx_comp_unaggr(sc, bf);
		return;
	}

	__stats(sc, tx_compaggr);
  90eabf:	77261a        	bbci	a2, 7, 90eadd <ath_tgt_tx_comp_aggr+0x259>

	asf_tailq_init(&bf_q);
  90eac2:	402726        	excw
	if (!bf->bf_isaggr) {
		ath_tx_comp_unaggr(sc, bf);
		return;
	}

	__stats(sc, tx_compaggr);
  90eac5:	5fa617        	call12	8f8324 <memset+0x114dc>

	asf_tailq_init(&bf_q);
  90eac8:	271651        	s32i	a7, a1, 0x144

	seq_st =  ATH_DS_BA_SEQ(ds);
  90eacb:	281176        	l16ui	a8, a1, 236
	ba     =  ATH_DS_BA_BITMAP(ds);
	tx_ok  =  (ATH_DS_TX_STATUS(ds) == HAL_OK);
  90eace:	2710ee        	l8ui	a7, a1, 238

	__stats(sc, tx_compaggr);

	asf_tailq_init(&bf_q);

	seq_st =  ATH_DS_BA_SEQ(ds);
  90ead1:	281656        	s32i	a8, a1, 0x158
	ba     =  ATH_DS_BA_BITMAP(ds);
	tx_ok  =  (ATH_DS_TX_STATUS(ds) == HAL_OK);

	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
  90ead4:	070f40        	extui	a15, a7, 0, 1
  90ead7:	c8f1      	beqz.n	a15, 90eadc <ath_tgt_tx_comp_aggr+0x258>
  90ead9:	60001f        	j	90eafc <ath_tgt_tx_comp_aggr+0x278>

	asf_tailq_init(&bf_q);

	seq_st =  ATH_DS_BA_SEQ(ds);
	ba     =  ATH_DS_BA_BITMAP(ds);
	tx_ok  =  (ATH_DS_TX_STATUS(ds) == HAL_OK);
  90eadc:	c091      	movi.n	a9, 1
  90eade:	07f939        	movnez	a9, a15, a7
	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
		ath_tx_comp_aggr_error(sc, bf, tid);
		return;
	}

	if (tx_ok && !ATH_DS_TX_BA(ds)) {
  90eae1:	ca95      	beqz.n	a9, 90eb0a <ath_tgt_tx_comp_aggr+0x286>
  90eae3:	d6f0      	mov.n	a6, a15
  90eae5:	7faf23        	bbsi	a10, 31, 90eb0c <ath_tgt_tx_comp_aggr+0x288>
		__stats(sc, txaggr_babug);
  90eae8:	242269        	l32i	a4, a2, 0x1a4
		adf_os_print("BA Bug?\n");
  90eaeb:	1a6b12        	l32r	a10, 8e9734 <memset+0x28ec>
		ath_tx_comp_aggr_error(sc, bf, tid);
		return;
	}

	if (tx_ok && !ATH_DS_TX_BA(ds)) {
		__stats(sc, txaggr_babug);
  90eaee:	b144      	addi.n	a4, a4, 1
  90eaf0:	242669        	s32i	a4, a2, 0x1a4
		adf_os_print("BA Bug?\n");
  90eaf3:	146915        	l32r	a4, 8e8f48 <memset+0x2100>
  90eaf6:	244212        	l32i	a4, a4, 72
  90eaf9:	0b4000        	callx8	a4
		ath_tx_comp_aggr_error(sc, bf, tid);
  90eafc:	da20      	mov.n	a10, a2
  90eafe:	db30      	mov.n	a11, a3
  90eb00:	dc50      	mov.n	a12, a5
  90eb02:	5bfbd6        	call8	90da5c <ath_tx_comp_aggr_error>
  90eb05:	d10f      	retw.n
  90eb07:	000000        	ill
	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
		ath_tx_comp_aggr_error(sc, bf, tid);
		return;
	}

	if (tx_ok && !ATH_DS_TX_BA(ds)) {
  90eb0a:	d690      	mov.n	a6, a9

	while (bf) {
		ba_index = ATH_BA_INDEX(seq_st, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
		bf_next  = bf->bf_next;

		if (tx_ok && ATH_BA_ISSET(ba, ba_index)) {
  90eb0c:	270afc        	movi	a7, 252
		ath_tx_comp_aggr_error(sc, bf, tid);
		return;
	}

	while (bf) {
		ba_index = ATH_BA_INDEX(seq_st, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90eb0f:	2b3123        	l16ui	a11, a3, 70
  90eb12:	281256        	l32i	a8, a1, 0x158
  90eb15:	0b4b14        	srli	a11, a11, 4
  90eb18:	08ba0c        	sub	a10, a11, a8
		bf_next  = bf->bf_next;
  90eb1b:	883b      	l32i.n	a8, a3, 44
		ath_tx_comp_aggr_error(sc, bf, tid);
		return;
	}

	while (bf) {
		ba_index = ATH_BA_INDEX(seq_st, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90eb1d:	0a0c4b        	extui	a12, a10, 0, 12
		bf_next  = bf->bf_next;
  90eb20:	281657        	s32i	a8, a1, 0x15c

		if (tx_ok && ATH_BA_ISSET(ba, ba_index)) {
  90eb23:	c38f      	movi.n	a8, 63
  90eb25:	7c824c        	blt	a8, a12, 90eb75 <ath_tgt_tx_comp_aggr+0x2f1>
  90eb28:	649049        	beqz	a9, 90eb75 <ath_tgt_tx_comp_aggr+0x2f1>
  90eb2b:	0c5c12        	srai	a12, a12, 5
  90eb2e:	01cc0a        	addx4	a12, a12, a1
  90eb31:	a7cc      	add.n	a12, a12, a7
  90eb33:	c0e1      	movi.n	a14, 1
  90eb35:	8cc0      	l32i.n	a12, a12, 0
  90eb37:	00a104        	ssl	a10
  90eb3a:	00ea1a        	sll	a10, a14
  90eb3d:	7ca034        	bnone	a10, a12, 90eb75 <ath_tgt_tx_comp_aggr+0x2f1>
			__stats(sc, txaggr_compgood);
  90eb40:	2a2262        	l32i	a10, a2, 0x188
  90eb43:	aeaa      	add.n	a10, a10, a14
  90eb45:	2a2662        	s32i	a10, a2, 0x188
			ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90eb48:	055a02        	or	a10, a5, a5
  90eb4b:	291659        	s32i	a9, a1, 0x164
  90eb4e:	2e1658        	s32i	a14, a1, 0x160
  90eb51:	5bf93f        	call8	90d050 <ath_tx_update_baw>
			ath_tx_status_update_aggr(sc, bf, ds, rcs, 1);
  90eb54:	2e1258        	l32i	a14, a1, 0x160
  90eb57:	2c0a88        	movi	a12, 136
  90eb5a:	2d1a10        	movi	a13, 0x110
  90eb5d:	da20      	mov.n	a10, a2
  90eb5f:	db30      	mov.n	a11, a3
  90eb61:	a1cc      	add.n	a12, a12, a1
  90eb63:	0d1d08        	add	a13, a1, a13
  90eb66:	5bfb69        	call8	90d90c <ath_tx_status_update_aggr>
			ath_tx_freebuf(sc, bf);
  90eb69:	da20      	mov.n	a10, a2
  90eb6b:	db30      	mov.n	a11, a3
  90eb6d:	5bfa96        	call8	90d5c8 <ath_tx_freebuf>
  90eb70:	600019        	j	90eb8d <ath_tgt_tx_comp_aggr+0x309>
  90eb73:	00002c        	excw
		} else {
			ath_tx_retry_subframe(sc, bf, &bf_q, &bar);
  90eb76:	1a402d        	l32r	a10, 8dec2c <_bss_end+0x3cbd1c>
  90eb79:	1a48da        	l32r	a10, 8e0ee4 <_bss_end+0x3cdfd4>
  90eb7c:	20db30        	l32ai	a0, a13, 192
  90eb7f:	ac1c      	add.n	a12, a1, a12
  90eb81:	0d1d08        	add	a13, a1, a13
  90eb84:	291659        	s32i	a9, a1, 0x164
			nbad ++;
  90eb87:	266c01        	addi	a6, a6, 1
			__stats(sc, txaggr_compgood);
			ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
			ath_tx_status_update_aggr(sc, bf, ds, rcs, 1);
			ath_tx_freebuf(sc, bf);
		} else {
			ath_tx_retry_subframe(sc, bf, &bf_q, &bar);
  90eb8a:	5bfb7c        	call8	90d97c <ath_tx_retry_subframe>
  90eb8d:	231257        	l32i	a3, a1, 0x15c
			nbad ++;
  90eb90:	291259        	l32i	a9, a1, 0x164
		adf_os_print("BA Bug?\n");
		ath_tx_comp_aggr_error(sc, bf, tid);
		return;
	}

	while (bf) {
  90eb93:	653f78        	bnez	a3, 90eb0f <ath_tgt_tx_comp_aggr+0x28b>
			nbad ++;
		}
		bf = bf_next;
	}

	ath_update_aggr_stats(sc, ds, nframes, nbad);
  90eb96:	2b0a88        	movi	a11, 136
  90eb99:	da20      	mov.n	a10, a2
  90eb9b:	a1bb      	add.n	a11, a11, a1
  90eb9d:	5bf99b        	call8	90d20c <ath_update_aggr_stats$isra$2>
	ath_rate_tx_complete(sc, an, ds, rcs, nframes, nbad);
  90eba0:	2c0a88        	movi	a12, 136
  90eba3:	2d1a10        	movi	a13, 0x110
  90eba6:	2e1254        	l32i	a14, a1, 0x150
  90eba9:	a1cc      	add.n	a12, a12, a1
  90ebab:	da20      	mov.n	a10, a2
  90ebad:	db40      	mov.n	a11, a4
  90ebaf:	0d1d08        	add	a13, a1, a13
  90ebb2:	066f02        	or	a15, a6, a6
  90ebb5:	5bf89c        	call8	90ce28 <ath_rate_tx_complete>

	if (bar) {
  90ebb8:	2c1252        	l32i	a12, a1, 0x148
  90ebbb:	c8c5      	beqz.n	a12, 90ebc4 <ath_tgt_tx_comp_aggr+0x340>
		ath_bar_tx(sc, tid, bar);
  90ebbd:	da20      	mov.n	a10, a2
  90ebbf:	db50      	mov.n	a11, a5
  90ebc1:	5bfab1        	call8	90d688 <ath_bar_tx>
	}

	if (!asf_tailq_empty(&bf_q)) {
  90ebc4:	231250        	l32i	a3, a1, 0x140
  90ebc7:	ca3d      	beqz.n	a3, 90ebf8 <ath_tgt_tx_comp_aggr+0x374>
		__stats(sc, txaggr_prepends);
  90ebc9:	232264        	l32i	a3, a2, 0x190
  90ebcc:	b133      	addi.n	a3, a3, 1
  90ebce:	232664        	s32i	a3, a2, 0x190
		TAILQ_INSERTQ_HEAD(&tid->buf_q, &bf_q, bf_list);
  90ebd1:	835b      	l32i.n	a3, a5, 44
  90ebd3:	221251        	l32i	a2, a1, 0x144
  90ebd6:	c83a      	beqz.n	a3, 90ebe4 <ath_tgt_tx_comp_aggr+0x360>
  90ebd8:	9320      	s32i.n	a3, a2, 0
  90ebda:	825b      	l32i.n	a2, a5, 44
  90ebdc:	231251        	l32i	a3, a1, 0x144
  90ebdf:	932a      	s32i.n	a3, a2, 40
  90ebe1:	600001        	j	90ebe6 <ath_tgt_tx_comp_aggr+0x362>
  90ebe4:	925c      	s32i.n	a2, a5, 48
  90ebe6:	221250        	l32i	a2, a1, 0x140
  90ebe9:	235c2c        	addi	a3, a5, 44
  90ebec:	925b      	s32i.n	a2, a5, 44
		ath_tgt_tx_enqueue(txq, tid);
  90ebee:	2a1255        	l32i	a10, a1, 0x154
		ath_bar_tx(sc, tid, bar);
	}

	if (!asf_tailq_empty(&bf_q)) {
		__stats(sc, txaggr_prepends);
		TAILQ_INSERTQ_HEAD(&tid->buf_q, &bf_q, bf_list);
  90ebf1:	932a      	s32i.n	a3, a2, 40
		ath_tgt_tx_enqueue(txq, tid);
  90ebf3:	db50      	mov.n	a11, a5
  90ebf5:	5bf97c        	call8	90d1e8 <ath_tgt_tx_enqueue>
  90ebf8:	d10f      	retw.n
	...

0090ebfc <owltgt_tx_processq>:
	ath_tx_status_send(sc);
}

void owltgt_tx_processq(struct ath_softc_tgt *sc, struct ath_txq *txq,
			owl_txq_state_t txqstate)
{
  90ebfc:	6c1006        	entry	a1, 48
	struct ath_tx_buf *bf;
	struct ath_tx_desc *ds;
	struct ath_hal *ah = sc->sc_ah;
  90ebff:	252d05        	addmi	a5, a2, 0x500
  90ec02:	865b      	l32i.n	a6, a5, 44
		bf = asf_tailq_first(&txq->axq_q);

		ds = bf->bf_lastds;
		status = ah->ah_procTxDesc(ah, ds);

		if (status == HAL_EINPROGRESS) {
  90ec04:	c07f      	movi.n	a7, 15
	struct ath_tx_desc *ds;
	struct ath_hal *ah = sc->sc_ah;
	HAL_STATUS status;

	for (;;) {
		if (asf_tailq_empty(&txq->axq_q)) {
  90ec06:	8532      	l32i.n	a5, a3, 8
  90ec08:	cc54      	bnez.n	a5, 90ec10 <owltgt_tx_processq+0x14>
			txq->axq_link = NULL;
  90ec0a:	9531      	s32i.n	a5, a3, 4
			txq->axq_linkbuf = NULL;
  90ec0c:	9535      	s32i.n	a5, a3, 20
			break;
  90ec0e:	d10f      	retw.n
		}

		bf = asf_tailq_first(&txq->axq_q);

		ds = bf->bf_lastds;
  90ec10:	885e      	l32i.n	a8, a5, 56
		status = ah->ah_procTxDesc(ah, ds);
  90ec12:	29621a        	l32i	a9, a6, 104
  90ec15:	db80      	mov.n	a11, a8
  90ec17:	9810      	s32i.n	a8, a1, 0
  90ec19:	da60      	mov.n	a10, a6
  90ec1b:	0b9000        	callx8	a9

		if (status == HAL_EINPROGRESS) {
  90ec1e:	8810      	l32i.n	a8, a1, 0
  90ec20:	77a91e        	bne	a10, a7, 90ec42 <owltgt_tx_processq+0x46>
			if (txqstate == OWL_TXQ_ACTIVE)
  90ec23:	64406d        	beqz	a4, 90ec94 <owltgt_tx_processq+0x98>
				break;
			else if (txqstate == OWL_TXQ_STOPPED) {
  90ec26:	694112        	bnei	a4, 1, 90ec3c <owltgt_tx_processq+0x40>
				__stats(sc, tx_stopfiltered);
  90ec29:	292275        	l32i	a9, a2, 0x1d4
  90ec2c:	b199      	addi.n	a9, a9, 1
  90ec2e:	292675        	s32i	a9, a2, 0x1d4
				ds->ds_txstat.ts_flags  = 0;
  90ec31:	c090      	movi.n	a9, 0
  90ec33:	298467        	s8i	a9, a8, 103
				ds->ds_txstat.ts_status = HAL_OK;
  90ec36:	298466        	s8i	a9, a8, 102
  90ec39:	600005        	j	90ec42 <owltgt_tx_processq+0x46>
			} else {
				ds->ds_txstat.ts_flags  = HAL_TX_SW_FILTERED;
  90ec3c:	29fa80        	movi	a9, -128
  90ec3f:	298467        	s8i	a9, a8, 103
			}
		}

		ATH_TXQ_REMOVE_HEAD(txq, bf, bf_list);
  90ec42:	8859      	l32i.n	a8, a5, 36
  90ec44:	895a      	l32i.n	a9, a5, 40
  90ec46:	c883      	beqz.n	a8, 90ec4d <owltgt_tx_processq+0x51>
  90ec48:	998a      	s32i.n	a9, a8, 40
  90ec4a:	600001        	j	90ec4f <owltgt_tx_processq+0x53>
  90ec4d:	9933      	s32i.n	a9, a3, 12
  90ec4f:	895a      	l32i.n	a9, a5, 40
  90ec51:	9890      	s32i.n	a8, a9, 0
  90ec53:	8834      	l32i.n	a8, a3, 16
  90ec55:	b088      	addi.n	a8, a8, -1
  90ec57:	9834      	s32i.n	a8, a3, 16
		if ((asf_tailq_empty(&txq->axq_q))) {
  90ec59:	8832      	l32i.n	a8, a3, 8
  90ec5b:	cc8a      	bnez.n	a8, 90ec69 <owltgt_tx_processq+0x6d>
			__stats(sc, tx_qnull);
  90ec5d:	29225c        	l32i	a9, a2, 0x170
  90ec60:	b199      	addi.n	a9, a9, 1
  90ec62:	29265c        	s32i	a9, a2, 0x170
			txq->axq_link = NULL;
  90ec65:	9831      	s32i.n	a8, a3, 4
			txq->axq_linkbuf = NULL;
  90ec67:	9835      	s32i.n	a8, a3, 20
		}

		if (bf->bf_comp) {
  90ec69:	885f      	l32i.n	a8, a5, 60
			bf->bf_comp(sc, bf);
  90ec6b:	da20      	mov.n	a10, a2
  90ec6d:	db50      	mov.n	a11, a5
			__stats(sc, tx_qnull);
			txq->axq_link = NULL;
			txq->axq_linkbuf = NULL;
		}

		if (bf->bf_comp) {
  90ec6f:	c886      	beqz.n	a8, 90ec79 <owltgt_tx_processq+0x7d>
			bf->bf_comp(sc, bf);
  90ec71:	0b8000        	callx8	a8
  90ec74:	60000c        	j	90ec84 <owltgt_tx_processq+0x88>
  90ec77:	00005b        	extui	a0, a0, 16, 12
		} else {
			ath_tx_status_update(sc, bf);
  90ec7a:	fb          	.byte 0xfb
  90ec7b:	01022a        	muluh	a2, a0, a1
			ath_buf_comp(sc, bf);
  90ec7e:	02db50        	extui	a11, a2, 29, 1
  90ec81:	5bfa72        	call8	90d64c <ath_buf_comp>
		}

		if (txqstate == OWL_TXQ_ACTIVE) {
  90ec84:	654f7e        	bnez	a4, 90ec06 <owltgt_tx_processq+0xa>
			ath_tgt_txq_schedule(sc, txq);
  90ec87:	022a02        	or	a10, a2, a2
  90ec8a:	033b02        	or	a11, a3, a3
  90ec8d:	5bfe40        	call8	90e590 <ath_tgt_txq_schedule>
  90ec90:	63ff72        	j	90ec06 <owltgt_tx_processq+0xa>
  90ec93:	00d10f        	subx8	a1, a13, a0
	...

0090ec98 <owl_tgt_tx_tasklet>:
	owltgt_tx_processq(sc, txq, OWL_TXQ_ACTIVE);
	ah->ah_setInterrupts(ah, sc->sc_imask);
}

void owl_tgt_tx_tasklet(TQUEUE_ARG data)
{
  90ec98:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)data;
	a_int32_t i;
	struct ath_txq *txq;

	ath_tx_status_clear(sc);
  90ec9b:	da20      	mov.n	a10, a2
  90ec9d:	5bfaf4        	call8	90d870 <ath_tx_status_clear>

	for (i = 0; i < (HAL_NUM_TX_QUEUES - 6); i++) {
  90eca0:	c030      	movi.n	a3, 0
		txq = ATH_TXQ(sc, i);

		if (ATH_TXQ_SETUP(sc, i)) {
			if (txq == sc->sc_cabq)
  90eca2:	262d05        	addmi	a6, a2, 0x500
	ath_tx_status_clear(sc);

	for (i = 0; i < (HAL_NUM_TX_QUEUES - 6); i++) {
		txq = ATH_TXQ(sc, i);

		if (ATH_TXQ_SETUP(sc, i)) {
  90eca5:	242d03        	addmi	a4, a2, 0x300
  90eca8:	2440c8        	l8ui	a4, a4, 200
  90ecab:	003004        	ssr	a3
  90ecae:	04041b        	sra	a4, a4
  90ecb1:	7f4745        	bbci	a4, 31, 90ecfa <owl_tgt_tx_tasklet+0x62>
	struct ath_txq *txq;

	ath_tx_status_clear(sc);

	for (i = 0; i < (HAL_NUM_TX_QUEUES - 6); i++) {
		txq = ATH_TXQ(sc, i);
  90ecb4:	253c1e        	addi	a5, a3, 30
  90ecb7:	0b5511        	slli	a5, a5, 5
  90ecba:	a525      	add.n	a5, a2, a5

		if (ATH_TXQ_SETUP(sc, i)) {
			if (txq == sc->sc_cabq)
  90ecbc:	846c      	l32i.n	a4, a6, 48
	struct ath_txq *txq;

	ath_tx_status_clear(sc);

	for (i = 0; i < (HAL_NUM_TX_QUEUES - 6); i++) {
		txq = ATH_TXQ(sc, i);
  90ecbe:	bc55      	addi.n	a5, a5, 12

		if (ATH_TXQ_SETUP(sc, i)) {
			if (txq == sc->sc_cabq)
  90ecc0:	74592d        	bne	a5, a4, 90ecf1 <owl_tgt_tx_tasklet+0x59>
	}
}

static void owltgt_tx_process_cabq(struct ath_softc_tgt *sc, struct ath_txq *txq)
{
	struct ath_hal *ah = sc->sc_ah;
  90ecc3:	846b      	l32i.n	a4, a6, 44
	ah->ah_setInterrupts(ah, sc->sc_imask & ~HAL_INT_SWBA);
  90ecc5:	196a22        	l32r	a9, 8e9550 <memset+0x2708>
  90ecc8:	2b22c4        	l32i	a11, a2, 0x310
  90eccb:	284228        	l32i	a8, a4, 160
  90ecce:	09bb01        	and	a11, a11, a9
  90ecd1:	da40      	mov.n	a10, a4
  90ecd3:	0b8000        	callx8	a8
	owltgt_tx_processq(sc, txq, OWL_TXQ_ACTIVE);
  90ecd6:	da20      	mov.n	a10, a2
  90ecd8:	db50      	mov.n	a11, a5
  90ecda:	2c0a00        	movi	a12, 0
  90ecdd:	5bffc7        	call8	90ebfc <owltgt_tx_processq>
	ah->ah_setInterrupts(ah, sc->sc_imask);
  90ece0:	2b22c4        	l32i	a11, a2, 0x310
  90ece3:	254228        	l32i	a5, a4, 160
  90ece6:	044a02        	or	a10, a4, a4
  90ece9:	0b5000        	callx8	a5
  90ecec:	60000a        	j	90ecfa <owl_tgt_tx_tasklet+0x62>
  90ecef:	0000da        	excw

		if (ATH_TXQ_SETUP(sc, i)) {
			if (txq == sc->sc_cabq)
				owltgt_tx_process_cabq(sc, txq);
			else
				owltgt_tx_processq(sc, txq, OWL_TXQ_ACTIVE);
  90ecf2:	20db50        	l32ai	a0, a13, 0x140
  90ecf5:	c0c0      	movi.n	a12, 0
  90ecf7:	5bffc1        	call8	90ebfc <owltgt_tx_processq>
	a_int32_t i;
	struct ath_txq *txq;

	ath_tx_status_clear(sc);

	for (i = 0; i < (HAL_NUM_TX_QUEUES - 6); i++) {
  90ecfa:	b133      	addi.n	a3, a3, 1
  90ecfc:	6934a5        	bnei	a3, 4, 90eca5 <owl_tgt_tx_tasklet+0xd>
			else
				owltgt_tx_processq(sc, txq, OWL_TXQ_ACTIVE);
		}
	}

	ath_tx_status_send(sc);
  90ecff:	da20      	mov.n	a10, a2
  90ed01:	5bfb82        	call8	90db0c <ath_tx_status_send>
  90ed04:	d10f      	retw.n
	...

0090ed08 <ath_tgt_handle_aggr>:
	} while (!asf_tailq_empty(&txq->axq_tidq) && !bdone);
}

void
ath_tgt_handle_aggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90ed08:	6c1004        	entry	a1, 32
	ath_atx_tid_t *tid;
	struct ath_node_target *an;
	struct ath_txq *txq = bf->bf_txq;
	a_bool_t queue_frame, within_baw;

	an = (struct ath_node_target *)bf->bf_node;
  90ed0b:	8634      	l32i.n	a6, a3, 16
void
ath_tgt_handle_aggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	ath_atx_tid_t *tid;
	struct ath_node_target *an;
	struct ath_txq *txq = bf->bf_txq;
  90ed0d:	253220        	l32i	a5, a3, 128
	a_bool_t queue_frame, within_baw;

	an = (struct ath_node_target *)bf->bf_node;
	adf_os_assert(an);
  90ed10:	cd65      	bnez.n	a6, 90ed29 <ath_tgt_handle_aggr+0x21>
  90ed12:	146915        	l32r	a4, 8e9168 <memset+0x2320>
  90ed15:	1a6afb        	l32r	a10, 8e9904 <memset+0x2abc>
  90ed18:	244212        	l32i	a4, a4, 72
  90ed1b:	1b6b13        	l32r	a11, 8e9968 <memset+0x2b20>
  90ed1e:	0b4000        	callx8	a4
  90ed21:	14697a        	l32r	a4, 8e930c <memset+0x24c4>
  90ed24:	0c0200        	memw
  90ed27:	8440      	l32i.n	a4, a4, 0

	tid = &an->tid[bf->bf_tidno];
  90ed29:	24304d        	l8ui	a4, a3, 77
  90ed2c:	0c4811        	slli	a8, a4, 4
  90ed2f:	04840c        	sub	a4, a8, a4
  90ed32:	06440a        	addx4	a4, a4, a6
  90ed35:	244c24        	addi	a4, a4, 36
	adf_os_assert(tid);
  90ed38:	cd45      	bnez.n	a4, 90ed51 <ath_tgt_handle_aggr+0x49>
  90ed3a:	166915        	l32r	a6, 8e9190 <memset+0x2348>
  90ed3d:	1a6afb        	l32r	a10, 8e992c <memset+0x2ae4>
  90ed40:	266212        	l32i	a6, a6, 72
  90ed43:	1b6b13        	l32r	a11, 8e9990 <memset+0x2b48>
  90ed46:	0b6000        	callx8	a6
  90ed49:	16697a        	l32r	a6, 8e9334 <memset+0x24ec>
  90ed4c:	0c0200        	memw
  90ed4f:	8660      	l32i.n	a6, a6, 0

	bf->bf_comp = ath_tgt_tx_comp_aggr;
  90ed51:	166b0e        	l32r	a6, 8e998c <memset+0x2b44>
	within_baw = BAW_WITHIN(tid->seq_start, tid->baw_size,
				SEQNO_FROM_BF_SEQNO(bf->bf_seqno));

	queue_frame = ( (txq->axq_depth >= ATH_AGGR_MIN_QDEPTH) ||
			(!asf_tailq_empty(&tid->buf_q)) ||
			(tid->paused) || (!within_baw) );
  90ed54:	8a54      	l32i.n	a10, a5, 16
	adf_os_assert(an);

	tid = &an->tid[bf->bf_tidno];
	adf_os_assert(tid);

	bf->bf_comp = ath_tgt_tx_comp_aggr;
  90ed56:	963f      	s32i.n	a6, a3, 60

	within_baw = BAW_WITHIN(tid->seq_start, tid->baw_size,
  90ed58:	283123        	l16ui	a8, a3, 70
  90ed5b:	294102        	l16ui	a9, a4, 4
  90ed5e:	264104        	l16ui	a6, a4, 8
				SEQNO_FROM_BF_SEQNO(bf->bf_seqno));

	queue_frame = ( (txq->axq_depth >= ATH_AGGR_MIN_QDEPTH) ||
			(!asf_tailq_empty(&tid->buf_q)) ||
			(tid->paused) || (!within_baw) );
  90ed61:	cda3      	bnez.n	a10, 90ed78 <ath_tgt_handle_aggr+0x70>
	bf->bf_comp = ath_tgt_tx_comp_aggr;

	within_baw = BAW_WITHIN(tid->seq_start, tid->baw_size,
				SEQNO_FROM_BF_SEQNO(bf->bf_seqno));

	queue_frame = ( (txq->axq_depth >= ATH_AGGR_MIN_QDEPTH) ||
  90ed63:	8a4b      	l32i.n	a10, a4, 44
  90ed65:	ccaf      	bnez.n	a10, 90ed78 <ath_tgt_handle_aggr+0x70>
			(!asf_tailq_empty(&tid->buf_q)) ||
  90ed67:	2a4034        	l8ui	a10, a4, 52
  90ed6a:	ccaa      	bnez.n	a10, 90ed78 <ath_tgt_handle_aggr+0x70>
	tid = &an->tid[bf->bf_tidno];
	adf_os_assert(tid);

	bf->bf_comp = ath_tgt_tx_comp_aggr;

	within_baw = BAW_WITHIN(tid->seq_start, tid->baw_size,
  90ed6c:	084814        	srli	a8, a8, 4
  90ed6f:	09880c        	sub	a8, a8, a9
  90ed72:	08084b        	extui	a8, a8, 0, 12
				SEQNO_FROM_BF_SEQNO(bf->bf_seqno));

	queue_frame = ( (txq->axq_depth >= ATH_AGGR_MIN_QDEPTH) ||
			(!asf_tailq_empty(&tid->buf_q)) ||
			(tid->paused) || (!within_baw) );
  90ed75:	768219        	blt	a8, a6, 90ed92 <ath_tgt_handle_aggr+0x8a>

	if (queue_frame) {
		asf_tailq_insert_tail(&tid->buf_q, bf, bf_list);
  90ed78:	c020      	movi.n	a2, 0
  90ed7a:	9239      	s32i.n	a2, a3, 36
  90ed7c:	824c      	l32i.n	a2, a4, 48
		ath_tgt_tx_enqueue(txq, tid);
  90ed7e:	da50      	mov.n	a10, a5
	queue_frame = ( (txq->axq_depth >= ATH_AGGR_MIN_QDEPTH) ||
			(!asf_tailq_empty(&tid->buf_q)) ||
			(tid->paused) || (!within_baw) );

	if (queue_frame) {
		asf_tailq_insert_tail(&tid->buf_q, bf, bf_list);
  90ed80:	923a      	s32i.n	a2, a3, 40
  90ed82:	9320      	s32i.n	a3, a2, 0
  90ed84:	233c24        	addi	a3, a3, 36
  90ed87:	934c      	s32i.n	a3, a4, 48
		ath_tgt_tx_enqueue(txq, tid);
  90ed89:	db40      	mov.n	a11, a4
  90ed8b:	5bf917        	call8	90d1e8 <ath_tgt_tx_enqueue>
  90ed8e:	d10f      	retw.n
  90ed90:	0000da        	excw
	} else {
		ath_tx_addto_baw(tid, bf);
  90ed93:	40db30        	excw
  90ed96:	5bfd58        	call8	90e2f8 <ath_tx_addto_baw>
		__stats(sc, txaggr_nframes);
  90ed99:	24225d        	l32i	a4, a2, 0x174
		ath_tgt_tx_send_normal(sc, bf);
  90ed9c:	da20      	mov.n	a10, a2
	if (queue_frame) {
		asf_tailq_insert_tail(&tid->buf_q, bf, bf_list);
		ath_tgt_tx_enqueue(txq, tid);
	} else {
		ath_tx_addto_baw(tid, bf);
		__stats(sc, txaggr_nframes);
  90ed9e:	b144      	addi.n	a4, a4, 1
  90eda0:	24265d        	s32i	a4, a2, 0x174
		ath_tgt_tx_send_normal(sc, bf);
  90eda3:	db30      	mov.n	a11, a3
  90eda5:	5bfc15        	call8	90ddfc <ath_tgt_tx_send_normal>
  90eda8:	d10f      	retw.n
	...

0090edac <ath_tgt_tx_cleanup>:
	wh->i_fc[1] |= IEEE80211_FC1_RETRY;
}

void ath_tgt_tx_cleanup(struct ath_softc_tgt *sc, struct ath_node_target *an,
			ath_atx_tid_t *tid, a_uint8_t discard_all)
{
  90edac:	6c1004        	entry	a1, 32
  90edaf:	050547        	extui	a5, a5, 0, 8
	struct ath_tx_buf *bf_next;
	struct ath_txq *txq;

	txq = TID_TO_ACTXQ(tid->tidno);

	bf = asf_tailq_first(&tid->buf_q);
  90edb2:	834b      	l32i.n	a3, a4, 44

	while (bf) {
		if (discard_all || bf->bf_isretried) {
			bf_next = asf_tailq_next(bf, bf_list);
			TAILQ_DEQ(&tid->buf_q, bf, bf_list);
			if (bf->bf_isretried)
  90edb4:	c160      	movi.n	a6, 16

	txq = TID_TO_ACTXQ(tid->tidno);

	bf = asf_tailq_first(&tid->buf_q);

	while (bf) {
  90edb6:	600042        	j	90edfc <ath_tgt_tx_cleanup+0x50>
		if (discard_all || bf->bf_isretried) {
  90edb9:	cc54      	bnez.n	a5, 90edc1 <ath_tgt_tx_cleanup+0x15>
  90edbb:	273221        	l32i	a7, a3, 132
  90edbe:	776033        	bnone	a6, a7, 90edf5 <ath_tgt_tx_cleanup+0x49>
			bf_next = asf_tailq_next(bf, bf_list);
  90edc1:	8739      	l32i.n	a7, a3, 36
			TAILQ_DEQ(&tid->buf_q, bf, bf_list);
  90edc3:	834b      	l32i.n	a3, a4, 44
  90edc5:	c83f      	beqz.n	a3, 90edd8 <ath_tgt_tx_cleanup+0x2c>
  90edc7:	8839      	l32i.n	a8, a3, 36
  90edc9:	893a      	l32i.n	a9, a3, 40
  90edcb:	c883      	beqz.n	a8, 90edd2 <ath_tgt_tx_cleanup+0x26>
  90edcd:	998a      	s32i.n	a9, a8, 40
  90edcf:	600001        	j	90edd4 <ath_tgt_tx_cleanup+0x28>
  90edd2:	994c      	s32i.n	a9, a4, 48
  90edd4:	893a      	l32i.n	a9, a3, 40
  90edd6:	9890      	s32i.n	a8, a9, 0
			if (bf->bf_isretried)
  90edd8:	283221        	l32i	a8, a3, 132
  90eddb:	78600a        	bnone	a6, a8, 90ede9 <ath_tgt_tx_cleanup+0x3d>
				ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90edde:	2b3123        	l16ui	a11, a3, 70
  90ede1:	da40      	mov.n	a10, a4
  90ede3:	0b4b14        	srli	a11, a11, 4
  90ede6:	5bf89a        	call8	90d050 <ath_tx_update_baw>
			ath_tx_freebuf(sc, bf);
  90ede9:	db30      	mov.n	a11, a3
  90edeb:	da20      	mov.n	a10, a2
  90eded:	5bf9f6        	call8	90d5c8 <ath_tx_freebuf>
			bf = bf_next;
  90edf0:	d370      	mov.n	a3, a7
			continue;
  90edf2:	600006        	j	90edfc <ath_tgt_tx_cleanup+0x50>
		}
		bf->bf_comp = ath_tgt_tx_comp_normal;
  90edf5:	176b0c        	l32r	a7, 8e9a28 <memset+0x2be0>
  90edf8:	973f      	s32i.n	a7, a3, 60
		bf = asf_tailq_next(bf, bf_list);
  90edfa:	8339      	l32i.n	a3, a3, 36

	txq = TID_TO_ACTXQ(tid->tidno);

	bf = asf_tailq_first(&tid->buf_q);

	while (bf) {
  90edfc:	653fb9        	bnez	a3, 90edb9 <ath_tgt_tx_cleanup+0xd>
}

static inline void
ath_aggr_pause_tid(struct ath_softc_tgt *sc, ath_atx_tid_t *tid)
{
	tid->paused =1;
  90edff:	c031      	movi.n	a3, 1
  90ee01:	234434        	s8i	a3, a4, 52
		bf = asf_tailq_next(bf, bf_list);
	}

	ath_aggr_pause_tid(sc, tid);

	while (tid->baw_head != tid->baw_tail) {
  90ee04:	8944      	l32i.n	a9, a4, 16
		if (TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head)) {
  90ee06:	c051      	movi.n	a5, 1
			tid->incomp++;
			tid->flag |= TID_CLEANUP_INPROGRES;
			TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, tid->baw_head);
  90ee08:	c7af      	movi.n	a10, -1
  90ee0a:	60003d        	j	90ee4b <ath_tgt_tx_cleanup+0x9f>
	}

	ath_aggr_pause_tid(sc, tid);

	while (tid->baw_head != tid->baw_tail) {
		if (TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head)) {
  90ee0d:	035612        	srai	a6, a3, 5
  90ee10:	b466      	addi.n	a6, a6, 4
  90ee12:	04660a        	addx4	a6, a6, a4
  90ee15:	8761      	l32i.n	a7, a6, 4
  90ee17:	003104        	ssl	a3
  90ee1a:	00581a        	sll	a8, a5
  90ee1d:	778018        	bnone	a8, a7, 90ee39 <ath_tgt_tx_cleanup+0x8d>
			tid->incomp++;
  90ee20:	2b4037        	l8ui	a11, a4, 55
			tid->flag |= TID_CLEANUP_INPROGRES;
			TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, tid->baw_head);
  90ee23:	08a803        	xor	a8, a10, a8

	ath_aggr_pause_tid(sc, tid);

	while (tid->baw_head != tid->baw_tail) {
		if (TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head)) {
			tid->incomp++;
  90ee26:	b1bb      	addi.n	a11, a11, 1
  90ee28:	2b4437        	s8i	a11, a4, 55
			tid->flag |= TID_CLEANUP_INPROGRES;
  90ee2b:	2b4036        	l8ui	a11, a4, 54
			TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, tid->baw_head);
  90ee2e:	078701        	and	a7, a8, a7
	ath_aggr_pause_tid(sc, tid);

	while (tid->baw_head != tid->baw_tail) {
		if (TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head)) {
			tid->incomp++;
			tid->flag |= TID_CLEANUP_INPROGRES;
  90ee31:	05bb02        	or	a11, a11, a5
  90ee34:	2b4436        	s8i	a11, a4, 54
			TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, tid->baw_head);
  90ee37:	9761      	s32i.n	a7, a6, 4
		}
		INCR(tid->baw_head, ATH_TID_MAX_BUFS);
  90ee39:	b133      	addi.n	a3, a3, 1
  90ee3b:	030346        	extui	a3, a3, 0, 7
  90ee3e:	9343      	s32i.n	a3, a4, 12
		INCR(tid->seq_start, IEEE80211_SEQ_MAX);
  90ee40:	234102        	l16ui	a3, a4, 4
  90ee43:	b133      	addi.n	a3, a3, 1
  90ee45:	03034b        	extui	a3, a3, 0, 12
  90ee48:	234502        	s16i	a3, a4, 4
		bf = asf_tailq_next(bf, bf_list);
	}

	ath_aggr_pause_tid(sc, tid);

	while (tid->baw_head != tid->baw_tail) {
  90ee4b:	8343      	l32i.n	a3, a4, 12
  90ee4d:	7939bc        	bne	a3, a9, 90ee0d <ath_tgt_tx_cleanup+0x61>
		}
		INCR(tid->baw_head, ATH_TID_MAX_BUFS);
		INCR(tid->seq_start, IEEE80211_SEQ_MAX);
	}

	if (!(tid->flag & TID_CLEANUP_INPROGRES)) {
  90ee50:	234036        	l8ui	a3, a4, 54
  90ee53:	7f3f06        	bbsi	a3, 31, 90ee5d <ath_tgt_tx_cleanup+0xb1>
		ath_aggr_resume_tid(sc, tid);
  90ee56:	da20      	mov.n	a10, a2
  90ee58:	db40      	mov.n	a11, a4
  90ee5a:	5bfe50        	call8	90e79c <ath_aggr_resume_tid>
  90ee5d:	d10f      	retw.n
	...

0090ee60 <ath_bar_tx_comp>:
	ath_tx_set_retry(sc, bf);
	ath_tgt_txq_add_ucast(sc, bf);
}

static void ath_bar_tx_comp(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90ee60:	6c1006        	entry	a1, 48
	struct ath_node_target *an;
	ath_atx_tid_t *tid;
	struct ath_txq *txq;

	an = (struct ath_node_target *)bf->bf_node;
	tid = &an->tid[bf->bf_tidno];
  90ee63:	25304d        	l8ui	a5, a3, 77
	ath_tgt_txq_add_ucast(sc, bf);
}

static void ath_bar_tx_comp(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_tx_desc *ds = bf->bf_lastds;
  90ee66:	883e      	l32i.n	a8, a3, 56
	struct ath_node_target *an;
	ath_atx_tid_t *tid;
	struct ath_txq *txq;

	an = (struct ath_node_target *)bf->bf_node;
	tid = &an->tid[bf->bf_tidno];
  90ee68:	0c5911        	slli	a9, a5, 4
	struct ath_tx_desc *ds = bf->bf_lastds;
	struct ath_node_target *an;
	ath_atx_tid_t *tid;
	struct ath_txq *txq;

	an = (struct ath_node_target *)bf->bf_node;
  90ee6b:	8434      	l32i.n	a4, a3, 16
	tid = &an->tid[bf->bf_tidno];
	txq = TID_TO_ACTXQ(tid->tidno);

	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
  90ee6d:	268066        	l8ui	a6, a8, 102
	struct ath_node_target *an;
	ath_atx_tid_t *tid;
	struct ath_txq *txq;

	an = (struct ath_node_target *)bf->bf_node;
	tid = &an->tid[bf->bf_tidno];
  90ee70:	05990c        	sub	a9, a9, a5
  90ee73:	04990a        	addx4	a9, a9, a4
	txq = TID_TO_ACTXQ(tid->tidno);

	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
  90ee76:	060640        	extui	a6, a6, 0, 1
	struct ath_node_target *an;
	ath_atx_tid_t *tid;
	struct ath_txq *txq;

	an = (struct ath_node_target *)bf->bf_node;
	tid = &an->tid[bf->bf_tidno];
  90ee79:	259c24        	addi	a5, a9, 36
  90ee7c:	299c20        	addi	a9, a9, 32
	txq = TID_TO_ACTXQ(tid->tidno);

	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
  90ee7f:	6460bf        	beqz	a6, 90ef42 <ath_bar_tx_comp+0xe2>
static void ath_bar_retry(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);

	if (bf->bf_retries >= OWLMAX_BAR_RETRIES) {
  90ee82:	263086        	l8ui	a6, a3, 134
  90ee85:	c0a9      	movi.n	a10, 9
  90ee87:	76ab5a        	bgeu	a10, a6, 90eee5 <ath_bar_tx_comp+0x85>
		ath_tgt_delba_send(sc, bf->bf_node, tid->tidno, 1,
  90ee8a:	269007        	l8ui	a6, a9, 7
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, tidno);
	struct wmi_data_delba wmi_delba;

	tid->flag &= ~TID_AGGR_ENABLED;

	ath_tgt_tx_cleanup(sc, an, tid, 1);
  90ee8d:	db40      	mov.n	a11, a4
			       struct ieee80211_node_target *ni,
			       a_uint8_t tidno, a_uint8_t initiator,
			       a_uint16_t reasoncode)
{
	struct ath_node_target *an = ATH_NODE_TARGET(ni);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, tidno);
  90ee8f:	0c6811        	slli	a8, a6, 4
  90ee92:	06860c        	sub	a6, a8, a6
  90ee95:	04660a        	addx4	a6, a6, a4
  90ee98:	2c6c24        	addi	a12, a6, 36
	struct wmi_data_delba wmi_delba;

	tid->flag &= ~TID_AGGR_ENABLED;
  90ee9b:	29c036        	l8ui	a9, a12, 54
  90ee9e:	c78d      	movi.n	a8, -3
  90eea0:	089801        	and	a8, a9, a8
  90eea3:	28c436        	s8i	a8, a12, 54

	ath_tgt_tx_cleanup(sc, an, tid, 1);
  90eea6:	da20      	mov.n	a10, a2
  90eea8:	c0d1      	movi.n	a13, 1
  90eeaa:	5bffc0        	call8	90edac <ath_tgt_tx_cleanup>

	wmi_delba.ni_nodeindex = ni->ni_nodeindex;
  90eead:	24400c        	l8ui	a4, a4, 12
	wmi_delba.tidno = tid->tidno;
	wmi_delba.initiator = 1;
	wmi_delba.reasoncode = IEEE80211_REASON_UNSPECIFIED;

	__stats(sc, txbar_xretry);
	wmi_event(sc->tgt_wmi_handle,
  90eeb0:	1b6b14        	l32r	a11, 8e9b00 <memset+0x2cb8>

	tid->flag &= ~TID_AGGR_ENABLED;

	ath_tgt_tx_cleanup(sc, an, tid, 1);

	wmi_delba.ni_nodeindex = ni->ni_nodeindex;
  90eeb3:	241400        	s8i	a4, a1, 0
	wmi_delba.tidno = tid->tidno;
  90eeb6:	8469      	l32i.n	a4, a6, 36
	wmi_delba.initiator = 1;
	wmi_delba.reasoncode = IEEE80211_REASON_UNSPECIFIED;

	__stats(sc, txbar_xretry);
	wmi_event(sc->tgt_wmi_handle,
  90eeb8:	8a23      	l32i.n	a10, a2, 12
	tid->flag &= ~TID_AGGR_ENABLED;

	ath_tgt_tx_cleanup(sc, an, tid, 1);

	wmi_delba.ni_nodeindex = ni->ni_nodeindex;
	wmi_delba.tidno = tid->tidno;
  90eeba:	241401        	s8i	a4, a1, 1
	wmi_delba.initiator = 1;
  90eebd:	c041      	movi.n	a4, 1
  90eebf:	241402        	s8i	a4, a1, 2
	wmi_delba.reasoncode = IEEE80211_REASON_UNSPECIFIED;
  90eec2:	241403        	s8i	a4, a1, 3

	__stats(sc, txbar_xretry);
  90eec5:	242279        	l32i	a4, a2, 0x1e4
	wmi_event(sc->tgt_wmi_handle,
  90eec8:	dc10      	mov.n	a12, a1
	wmi_delba.ni_nodeindex = ni->ni_nodeindex;
	wmi_delba.tidno = tid->tidno;
	wmi_delba.initiator = 1;
	wmi_delba.reasoncode = IEEE80211_REASON_UNSPECIFIED;

	__stats(sc, txbar_xretry);
  90eeca:	b144      	addi.n	a4, a4, 1
  90eecc:	242679        	s32i	a4, a2, 0x1e4
	wmi_event(sc->tgt_wmi_handle,
  90eecf:	c0d4      	movi.n	a13, 4
  90eed1:	5be514        	call8	908324 <wmi_event>
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);

	if (bf->bf_retries >= OWLMAX_BAR_RETRIES) {
		ath_tgt_delba_send(sc, bf->bf_node, tid->tidno, 1,
				   IEEE80211_REASON_UNSPECIFIED);
		ath_tgt_tid_drain(sc, tid);
  90eed4:	da20      	mov.n	a10, a2
  90eed6:	db50      	mov.n	a11, a5

		bf->bf_comp = NULL;
  90eed8:	c040      	movi.n	a4, 0
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);

	if (bf->bf_retries >= OWLMAX_BAR_RETRIES) {
		ath_tgt_delba_send(sc, bf->bf_node, tid->tidno, 1,
				   IEEE80211_REASON_UNSPECIFIED);
		ath_tgt_tid_drain(sc, tid);
  90eeda:	5bfb1e        	call8	90db54 <ath_tgt_tid_drain>
			       struct ieee80211_node_target *ni,
			       a_uint8_t tidno, a_uint8_t initiator,
			       a_uint16_t reasoncode)
{
	struct ath_node_target *an = ATH_NODE_TARGET(ni);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, tidno);
  90eedd:	266c20        	addi	a6, a6, 32
	if (bf->bf_retries >= OWLMAX_BAR_RETRIES) {
		ath_tgt_delba_send(sc, bf->bf_node, tid->tidno, 1,
				   IEEE80211_REASON_UNSPECIFIED);
		ath_tgt_tid_drain(sc, tid);

		bf->bf_comp = NULL;
  90eee0:	943f      	s32i.n	a4, a3, 60
  90eee2:	600065        	j	90ef4b <ath_bar_tx_comp+0xeb>
		ath_buf_comp(sc, bf);
		return;
	}

	__stats(sc, txbar_compretries);
  90eee5:	24227a        	l32i	a4, a2, 0x1e8
  90eee8:	b144      	addi.n	a4, a4, 1
  90eeea:	24267a        	s32i	a4, a2, 0x1e8

	if (!bf->bf_lastds->ds_link) {
  90eeed:	268000        	l8ui	a6, a8, 0
  90eef0:	258001        	l8ui	a5, a8, 1
  90eef3:	248002        	l8ui	a4, a8, 2
  90eef6:	086610        	slli	a6, a6, 24
  90eef9:	005511        	slli	a5, a5, 16
  90eefc:	065502        	or	a5, a5, a6
  90eeff:	084411        	slli	a4, a4, 8
  90ef02:	054402        	or	a4, a4, a5
  90ef05:	258003        	l8ui	a5, a8, 3
  90ef08:	045402        	or	a4, a5, a4
  90ef0b:	cd43      	bnez.n	a4, 90ef22 <ath_bar_tx_comp+0xc2>
		__stats(sc, txbar_errlast);
  90ef0d:	24227b        	l32i	a4, a2, 0x1ec
		bf = ath_buf_toggle(sc, bf, 1);
  90ef10:	db30      	mov.n	a11, a3
	}

	__stats(sc, txbar_compretries);

	if (!bf->bf_lastds->ds_link) {
		__stats(sc, txbar_errlast);
  90ef12:	b144      	addi.n	a4, a4, 1
  90ef14:	24267b        	s32i	a4, a2, 0x1ec
		bf = ath_buf_toggle(sc, bf, 1);
  90ef17:	022a02        	or	a10, a2, a2
  90ef1a:	2c0a01        	movi	a12, 1
  90ef1d:	5bf966        	call8	90d4b8 <ath_buf_toggle>
  90ef20:	d3a0      	mov.n	a3, a10
	}

	bf->bf_lastds->ds_link = 0;
  90ef22:	843e      	l32i.n	a4, a3, 56
  90ef24:	c080      	movi.n	a8, 0

	ath_tx_set_retry(sc, bf);
  90ef26:	da20      	mov.n	a10, a2
  90ef28:	db30      	mov.n	a11, a3
	if (!bf->bf_lastds->ds_link) {
		__stats(sc, txbar_errlast);
		bf = ath_buf_toggle(sc, bf, 1);
	}

	bf->bf_lastds->ds_link = 0;
  90ef2a:	284400        	s8i	a8, a4, 0
  90ef2d:	284401        	s8i	a8, a4, 1
  90ef30:	284402        	s8i	a8, a4, 2
  90ef33:	284403        	s8i	a8, a4, 3

	ath_tx_set_retry(sc, bf);
  90ef36:	5bfa30        	call8	90d7f8 <ath_tx_set_retry>
	ath_tgt_txq_add_ucast(sc, bf);
  90ef39:	da20      	mov.n	a10, a2
  90ef3b:	db30      	mov.n	a11, a3
  90ef3d:	5bf805        	call8	90cf54 <ath_tgt_txq_add_ucast>
  90ef40:	d10f      	retw.n
	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
		ath_bar_retry(sc, bf);
		return;
	}

	ath_aggr_resume_tid(sc, tid);
  90ef42:	da20      	mov.n	a10, a2
  90ef44:	db50      	mov.n	a11, a5
  90ef46:	5bfe15        	call8	90e79c <ath_aggr_resume_tid>

	bf->bf_comp = NULL;
  90ef49:	963f      	s32i.n	a6, a3, 60
	ath_buf_comp(sc, bf);
  90ef4b:	da20      	mov.n	a10, a2
  90ef4d:	db30      	mov.n	a11, a3
  90ef4f:	5bf9bf        	call8	90d64c <ath_buf_comp>
  90ef52:	d10f      	retw.n

0090ef54 <ath_pci_suspend>:
	adf_os_free_intr(sc->sc_dev);
}

static void
ath_pci_suspend(adf_drv_handle_t hdl, adf_os_pm_t pm)
{
  90ef54:	6c1004        	entry	a1, 32
  90ef57:	d10f      	retw.n
  90ef59:	000000        	ill

0090ef5c <ath_pci_resume>:
}

static void
ath_pci_resume(adf_drv_handle_t hdl)
{
  90ef5c:	6c1004        	entry	a1, 32
  90ef5f:	d10f      	retw.n
  90ef61:	000000        	ill

0090ef64 <ath_pci_remove>:
	return NULL;
}

static void
ath_pci_remove(adf_drv_handle_t hdl)
{
  90ef64:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = hdl;

	ath_detach((struct ath_softc_tgt *)hdl);
  90ef67:	da20      	mov.n	a10, a2
  90ef69:	5beaed        	call8	909b20 <ath_detach>
}

static inline void
adf_os_free_intr(adf_os_device_t osdev)
{
    __adf_os_free_intr(osdev);
  90ef6c:	2a2246        	l32i	a10, a2, 0x118
  90ef6f:	5bef71        	call8	90ad34 <__adf_os_free_intr>
  90ef72:	d10f      	retw.n

0090ef74 <init_ath_pci>:

static adf_drv_info_t ath_drv_info = adf_os_pci_set_drv_info(ath_pci_tgt,&ath_pci_id_table[0], ath_pci_probe, ath_pci_remove, ath_pci_suspend, ath_pci_resume);

a_int32_t
init_ath_pci(void)
{
  90ef74:	6c1004        	entry	a1, 32
 * @return status of operation
 */
static inline a_status_t 
adf_net_register_drv(adf_drv_info_t *drv)
{
    return(__adf_net_register_drv(drv));
  90ef77:	1a6b15        	l32r	a10, 8e9bcc <memset+0x2d84>
  90ef7a:	580063        	call8	90f108 <__adf_net_register_drv>
	return adf_net_register_drv( &ath_drv_info );
}
  90ef7d:	d2a0      	mov.n	a2, a10
  90ef7f:	d10f      	retw.n
  90ef81:	000000        	ill

0090ef84 <ath_pci_probe>:
a_int32_t init_ath_pci(void);

static adf_drv_handle_t
ath_pci_probe(adf_os_resource_t *res,a_int32_t count, adf_os_attach_data_t *data,
	      adf_os_device_t osdev)
{
  90ef84:	6c1004        	entry	a1, 32
}

static inline int 
__adf_os_pci_config_write8(adf_os_device_t osdev, int offset, a_uint8_t val)
{
    wlan_pci_config_write(offset, val, 1);
  90ef87:	c2b0      	movi.n	a11, 32
  90ef89:	c0c1      	movi.n	a12, 1
  90ef8b:	c0ac      	movi.n	a10, 12
  90ef8d:	5beaf5        	call8	909b64 <wlan_pci_config_write>
  90ef90:	2b0aa8        	movi	a11, 168
  90ef93:	2c0a01        	movi	a12, 1
  90ef96:	2a0a0d        	movi	a10, 13
  90ef99:	5beaf2        	call8	909b64 <wlan_pci_config_write>
#include "Magpie_api.h"

static inline void *	__adf_os_mem_alloc(adf_os_size_t size)
{
//    return (malloc(size,M_DEVBUF,M_DONTWAIT | M_ZERO));
    return A_ALLOCRAM(size);
  90ef9c:	166915        	l32r	a6, 8e93f0 <memset+0x25a8>
  90ef9f:	136b16        	l32r	a3, 8e9bf8 <memset+0x2db0>
  90efa2:	226252        	l32i	a2, a6, 0x148
  90efa5:	c0a0      	movi.n	a10, 0
  90efa7:	db30      	mov.n	a11, a3
  90efa9:	0b2000        	callx8	a2
  90efac:	d2a0      	mov.n	a2, a10
	adf_os_pci_config_write8(osdev, ATH_PCI_CACHE_LINE_SIZE, csz);
	adf_os_pci_config_write8(osdev, ATH_PCI_LATENCY_TIMER, 0xa8);

	sc = adf_os_mem_alloc(sizeof(struct ath_pci_softc));

	if (sc == NULL) {
  90efae:	ccaa      	bnez.n	a10, 90efbc <ath_pci_probe+0x38>
		adf_os_print("ath_pci: no memory for device state\n");
  90efb0:	236212        	l32i	a3, a6, 72
  90efb3:	1a6b17        	l32r	a10, 8e9c10 <memset+0x2dc8>
  90efb6:	0b3000        	callx8	a3
  90efb9:	d10f      	retw.n
  90efbb:	008864        	excw

/* set a memory buffer */
static inline void
__adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
{
	A_MEMSET(buf, b, size);
  90efbe:	dc30      	mov.n	a12, a3
  90efc0:	c0b0      	movi.n	a11, 0
  90efc2:	0b8000        	callx8	a8

	/*
	 * Mark the device as detached to avoid processing
	 * interrupts until setup is complete.
	 */
	sc->aps_sc.sc_invalid = 1;
  90efc5:	232d01        	addmi	a3, a2, 0x100
  90efc8:	293024        	l8ui	a9, a3, 36
  90efcb:	28fa80        	movi	a8, -128
  90efce:	089802        	or	a8, a9, a8
  90efd1:	283424        	s8i	a8, a3, 36

	adf_os_print("ath_pci_probe %x\n",id->device);
  90efd4:	2b4201        	l32i	a11, a4, 4
  90efd7:	266212        	l32i	a6, a6, 72
  90efda:	1a6b18        	l32r	a10, 8e9c3c <memset+0x2df4>
  90efdd:	0b6000        	callx8	a6

	if (ath_tgt_attach(id->device, &sc->aps_sc, osdev) != 0)
  90efe0:	8a41      	l32i.n	a10, a4, 4
  90efe2:	db20      	mov.n	a11, a2
  90efe4:	dc50      	mov.n	a12, a5
  90efe6:	5be9b8        	call8	9096c8 <ath_tgt_attach>
  90efe9:	cda1      	bnez.n	a10, 90effe <ath_pci_probe+0x7a>
		goto bad3;

	/* ready to process interrupts */
	sc->aps_sc.sc_invalid = 0;
  90efeb:	243024        	l8ui	a4, a3, 36
#include <adf_os_irq_pvt.h>

static inline int
adf_os_setup_intr(adf_os_device_t  osdev, adf_os_drv_intr fn)
{
    return __adf_os_setup_intr(osdev, fn);
  90efee:	1b6a21        	l32r	a11, 8e9874 <memset+0x2a2c>
  90eff1:	040446        	extui	a4, a4, 0, 7
  90eff4:	243424        	s8i	a4, a3, 36
  90eff7:	da50      	mov.n	a10, a5
  90eff9:	5bef4b        	call8	90ad28 <__adf_os_setup_intr>
  90effc:	d10f      	retw.n
	adf_os_setup_intr(osdev, ath_intr);
	return (adf_drv_handle_t)sc;
bad3:
bad2:
	return NULL;
  90effe:	c020      	movi.n	a2, 0
}
  90f000:	d10f      	retw.n
	...

0090f004 <exit_ath_pci>:
	return adf_net_register_drv( &ath_drv_info );
}

void
exit_ath_pci(void)
{
  90f004:	6c1004        	entry	a1, 32
 * @see adf_net_register_drv()
 */
static inline void
adf_net_unregister_drv(a_uint8_t *drv_name)
{
    __adf_net_unregister_drv(drv_name);
  90f007:	1a6b19        	l32r	a10, 8e9c6c <memset+0x2e24>
  90f00a:	580042        	call8	90f114 <__adf_net_unregister_drv>
  90f00d:	d10f      	retw.n
	...

0090f010 <ar5416AttachRateTables>:

#endif //#ifdef MAGPIE_MERLIN // MAGPIE_MERLIN 

void
ar5416AttachRateTables(struct atheros_softc *sc)
{
  90f010:	6c1004        	entry	a1, 32
    sc->hwRateTable[WIRELESS_MODE_11NG]  = &ar5416_11ngRateTable;
  90f013:	186b1a        	l32r	a8, 8e9c7c <memset+0x2e34>
  90f016:	9822      	s32i.n	a8, a2, 8
#ifdef ATH_SUPPORT_A_MODE
    sc->hwRateTable[WIRELESS_MODE_11NA]  = &ar5416_11naRateTable;
  90f018:	186b1b        	l32r	a8, 8e9c84 <memset+0x2e3c>
  90f01b:	9821      	s32i.n	a8, a2, 4
  90f01d:	d10f      	retw.n
	...

0090f020 <io32_rmw>:
	iowrite8(addr, val);
}

static inline void io32_rmw(volatile uint32_t addr,
			    const uint32_t set, const uint32_t clr)
{
  90f020:	6c1006        	entry	a1, 48
  90f023:	0c0200        	memw
  90f026:	9210      	s32i.n	a2, a1, 0
	uint32_t val;

	val = ioread32(addr);
  90f028:	0c0200        	memw
  90f02b:	8810      	l32i.n	a8, a1, 0
	val &= ~clr;
  90f02d:	c79f      	movi.n	a9, -1
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90f02f:	0c0200        	memw
  90f032:	8880      	l32i.n	a8, a8, 0
			    const uint32_t set, const uint32_t clr)
{
	uint32_t val;

	val = ioread32(addr);
	val &= ~clr;
  90f034:	049403        	xor	a4, a9, a4
  90f037:	084801        	and	a8, a4, a8
	val |= set;
	iowrite32(addr, val);
  90f03a:	0c0200        	memw
  90f03d:	8a10      	l32i.n	a10, a1, 0
{
	uint32_t val;

	val = ioread32(addr);
	val &= ~clr;
	val |= set;
  90f03f:	038302        	or	a3, a8, a3
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90f042:	0c0200        	memw
  90f045:	93a0      	s32i.n	a3, a10, 0
  90f047:	d10f      	retw.n
  90f049:	000000        	ill

0090f04c <ieee80211_tgt_crypto_encap>:

a_status_t
ieee80211_tgt_crypto_encap(struct ieee80211_frame *wh,
			   struct ieee80211_node_target *ni,
			   a_uint8_t keytype)
{
  90f04c:	6c1004        	entry	a1, 32
	a_uint16_t tmp;
	a_uint16_t offset = IEEE80211_WLAN_HDR_LEN;
	a_uint8_t b1, b2;
	struct ieee80211_qosframe_addr4 *wh_mesh;

	if (IEEE80211_QOS_HAS_SEQ(wh))
  90f04f:	2a2000        	l8ui	a10, a2, 0
  90f052:	280a8c        	movi	a8, 140
  90f055:	08aa01        	and	a10, a10, a8
#define CRYPTO_KEY_TYPE_WAPI         4
#define IEEE80211_WLAN_HDR_LEN      24

	a_uint8_t *iv = NULL;
	a_uint16_t tmp;
	a_uint16_t offset = IEEE80211_WLAN_HDR_LEN;
  90f058:	290a88        	movi	a9, 136
  90f05b:	09aa0c        	sub	a10, a10, a9
  90f05e:	c188      	movi.n	a8, 24
  90f060:	c19c      	movi.n	a9, 28
  90f062:	0a9838        	moveqz	a8, a9, a10
	if (IEEE80211_QOS_HAS_SEQ(wh))
		offset += 4;  // pad for 4 byte alignment

	/* set the offset to 32 if the mesh control field is present */
	wh_mesh = (struct ieee80211_qosframe_addr4 *)wh;
	if (wh_mesh->i_qos[1] & 0x01)
  90f065:	2a201f        	l8ui	a10, a2, 31
		offset = 32;
  90f068:	c290      	movi.n	a9, 32
	if (IEEE80211_QOS_HAS_SEQ(wh))
		offset += 4;  // pad for 4 byte alignment

	/* set the offset to 32 if the mesh control field is present */
	wh_mesh = (struct ieee80211_qosframe_addr4 *)wh;
	if (wh_mesh->i_qos[1] & 0x01)
  90f06a:	0a0a40        	extui	a10, a10, 0, 1
		offset = 32;
  90f06d:	0a9839        	movnez	a8, a9, a10

a_status_t
ieee80211_tgt_crypto_encap(struct ieee80211_frame *wh,
			   struct ieee80211_node_target *ni,
			   a_uint8_t keytype)
{
  90f070:	040447        	extui	a4, a4, 0, 8
	wh_mesh = (struct ieee80211_qosframe_addr4 *)wh;
	if (wh_mesh->i_qos[1] & 0x01)
		offset = 32;

	iv = (a_uint8_t *) wh;
	iv = iv + offset;
  90f073:	a822      	add.n	a2, a2, a8

	switch (keytype) {
  90f075:	684208        	beqi	a4, 2, 90f081 <ieee80211_tgt_crypto_encap+0x35>
  90f078:	684302        	beqi	a4, 3, 90f07e <ieee80211_tgt_crypto_encap+0x32>
  90f07b:	600082        	j	90f101 <ieee80211_tgt_crypto_encap+0xb5>
  90f07e:	600031        	j	90f0b3 <ieee80211_tgt_crypto_encap+0x67>
	case CRYPTO_KEY_TYPE_AES:
		ni->ni_iv16++;
  90f081:	28310d        	l16ui	a8, a3, 26
  90f084:	b188      	addi.n	a8, a8, 1
  90f086:	08084f        	extui	a8, a8, 0, 16
  90f089:	28350d        	s16i	a8, a3, 26
		if (ni->ni_iv16 == 0)
  90f08c:	cc84      	bnez.n	a8, 90f094 <ieee80211_tgt_crypto_encap+0x48>
		{
			ni->ni_iv32++;
  90f08e:	8437      	l32i.n	a4, a3, 28
  90f090:	b144      	addi.n	a4, a4, 1
  90f092:	9437      	s32i.n	a4, a3, 28
		}

		*iv++ = (a_uint8_t) ni->ni_iv16;
  90f094:	282400        	s8i	a8, a2, 0
		*iv++ = (a_uint8_t) (ni->ni_iv16 >> 8);
  90f097:	24310d        	l16ui	a4, a3, 26
		*iv++ = 0x00;
		*iv++ |= 0x20;
  90f09a:	282003        	l8ui	a8, a2, 3
		{
			ni->ni_iv32++;
		}

		*iv++ = (a_uint8_t) ni->ni_iv16;
		*iv++ = (a_uint8_t) (ni->ni_iv16 >> 8);
  90f09d:	048414        	srli	a4, a4, 8
  90f0a0:	242401        	s8i	a4, a2, 1
		*iv++ = 0x00;
  90f0a3:	c040      	movi.n	a4, 0
  90f0a5:	242402        	s8i	a4, a2, 2
		*iv++ |= 0x20;
  90f0a8:	c240      	movi.n	a4, 32
  90f0aa:	048402        	or	a4, a8, a4
  90f0ad:	242403        	s8i	a4, a2, 3
  90f0b0:	600036        	j	90f0ea <ieee80211_tgt_crypto_encap+0x9e>
		tmp = (a_uint16_t) (ni->ni_iv32 >> 16);
		*iv++ = (a_uint8_t) tmp;
		*iv = (a_uint8_t) (tmp >> 8);
		break;
	case CRYPTO_KEY_TYPE_TKIP:
		ni->ni_iv16++;
  90f0b3:	28310d        	l16ui	a8, a3, 26
  90f0b6:	b188      	addi.n	a8, a8, 1
  90f0b8:	08084f        	extui	a8, a8, 0, 16
  90f0bb:	28350d        	s16i	a8, a3, 26
		if (ni->ni_iv16 == 0)
  90f0be:	cc86      	bnez.n	a8, 90f0c8 <ieee80211_tgt_crypto_encap+0x7c>
		{
			ni->ni_iv32++;
  90f0c0:	243207        	l32i	a4, a3, 28
  90f0c3:	b144      	addi.n	a4, a4, 1
  90f0c5:	243607        	s32i	a4, a3, 28
		}

		b1 = (a_uint8_t) (ni->ni_iv16 >> 8);
  90f0c8:	088814        	srli	a8, a8, 8
		b2 = (b1 | 0x20) & 0x7f;
  90f0cb:	c54f      	movi.n	a4, 95
		if (ni->ni_iv16 == 0)
		{
			ni->ni_iv32++;
		}

		b1 = (a_uint8_t) (ni->ni_iv16 >> 8);
  90f0cd:	282400        	s8i	a8, a2, 0
		b2 = (b1 | 0x20) & 0x7f;
  90f0d0:	c290      	movi.n	a9, 32
  90f0d2:	048801        	and	a8, a8, a4
  90f0d5:	098802        	or	a8, a8, a9
  90f0d8:	282401        	s8i	a8, a2, 1

		*iv++ = b1;
		*iv++ = b2;

		*iv++ = (a_uint8_t) ni->ni_iv16;
  90f0db:	24310d        	l16ui	a4, a3, 26
  90f0de:	242402        	s8i	a4, a2, 2
		*iv++ |= 0x20;
  90f0e1:	242003        	l8ui	a4, a2, 3
  90f0e4:	094902        	or	a9, a4, a9
  90f0e7:	292403        	s8i	a9, a2, 3

		tmp = (a_uint16_t) ni->ni_iv32;
  90f0ea:	8837      	l32i.n	a8, a3, 28
		*iv++ = (a_uint8_t) tmp;
  90f0ec:	282404        	s8i	a8, a2, 4
		*iv++ = (a_uint8_t) (tmp >> 8);
  90f0ef:	088847        	extui	a8, a8, 8, 8
  90f0f2:	282405        	s8i	a8, a2, 5

		tmp = (a_uint16_t) (ni->ni_iv32 >> 16);
  90f0f5:	23310e        	l16ui	a3, a3, 28
		*iv++ = (a_uint8_t) tmp;
  90f0f8:	232406        	s8i	a3, a2, 6
		*iv = (a_uint8_t) (tmp >> 8);
  90f0fb:	038314        	srli	a3, a3, 8
  90f0fe:	232407        	s8i	a3, a2, 7

#undef CRYPTO_KEY_TYPE_TKIP
#undef CRYPTO_KEY_TYPE_AES
#undef CRYPTO_KEY_TYPE_WAPI
#undef IEEE80211_WLAN_HDR_LEN
}
  90f101:	c021      	movi.n	a2, 1
  90f103:	d10f      	retw.n
  90f105:	000000        	ill

0090f108 <__adf_net_register_drv>:
 * 
 * @return a_status_t
 */
a_status_t
__adf_net_register_drv(adf_drv_info_t *drv)
{
  90f108:	6c1004        	entry	a1, 32
    wlan_pci_register_drv(drv);    
  90f10b:	da20      	mov.n	a10, a2
  90f10d:	5bea92        	call8	909b58 <wlan_pci_register_drv>
    return A_STATUS_OK;
}
  90f110:	c020      	movi.n	a2, 0
  90f112:	d10f      	retw.n

0090f114 <__adf_net_unregister_drv>:
 * @brief unregister the driver from the shim
 * @param[in] name
 */
void
__adf_net_unregister_drv(a_uint8_t *name)
{
  90f114:	6c1004        	entry	a1, 32
  90f117:	d10f      	retw.n
