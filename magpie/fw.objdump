
../ath9k-htc-firmware-blob/magpie/fw.elf:     Dateiformat elf32-xtensa-be
../ath9k-htc-firmware-blob/magpie/fw.elf
Architektur: xtensa, Flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
Startadresse 0x00906000

Xtensa header:

Machine     = Base
Insn tables = true
Literal tables = true

Programm-Header:
    LOAD off    0x00501000 vaddr 0x00501000 paddr 0x00501000 align 2**29
         filesz 0x00001b14 memsz 0x00001b14 flags r--
    LOAD off    0x00510d00 vaddr 0x00510d00 paddr 0x00510d00 align 2**29
         filesz 0x00001f68 memsz 0x00002210 flags rw-
    LOAD off    0x00906000 vaddr 0x00906000 paddr 0x00906000 align 2**29
         filesz 0x00009231 memsz 0x00009231 flags r-x

Sektionen:
Idx Name          Größe     VMA       LMA       Datei-Off Ausr.
  0 .lit4         00019000  004e8000  004e8000  00000000  2**0
                  ALLOC
  1 .rodata       000012e4  00501000  00501000  00501000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .literals     00000830  005022e4  005022e4  005022e4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .dport0.bss   00000000  00510d00  00510d00  0090f231  2**0
                  CONTENTS
  4 .data         00001f68  00510d00  00510d00  00510d00  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          000002a8  00512c68  00512c68  00512c68  2**2
                  ALLOC
  6 .boot         00000270  00906000  00906000  00906000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .text         00008fc1  00906270  00906270  00906270  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .debug_aranges 00000348  00000000  00000000  0090f231  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   000601d6  00000000  00000000  0090f579  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00006513  00000000  00000000  0096f74f  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00012f82  00000000  00000000  00975c62  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00001fd0  00000000  00000000  00988be4  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    0000925b  00000000  00000000  0098abb4  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    0000d279  00000000  00000000  00993e0f  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .xt.prop      00005064  00000000  00000000  009a1088  2**0
                  CONTENTS, READONLY
 16 .debug_ranges 00000f28  00000000  00000000  009a60ec  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      0000006d  00000000  00000000  009a7014  2**0
                  CONTENTS, READONLY
 18 .xtensa.info  00000038  00000000  00000000  009a7081  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
004e8000 l    d  .lit4	00000000 .lit4
00501000 l    d  .rodata	00000000 .rodata
005022e4 l    d  .literals	00000000 .literals
00510d00 l    d  .dport0.bss	00000000 .dport0.bss
00510d00 l    d  .data	00000000 .data
00512c68 l    d  .bss	00000000 .bss
00906000 l    d  .boot	00000000 .boot
00906270 l    d  .text	00000000 .text
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .xt.prop	00000000 .xt.prop
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .xtensa.info	00000000 .xtensa.info
00000000 l    df *ABS*	00000000 magpie.c
00501000 l     O .rodata	0000000d __FUNCTION__$3916
00000000 l    df *ABS*	00000000 adf_nbuf.c
005010d7 l     O .rodata	00000010 __FUNCTION__$4939
005010bb l     O .rodata	0000001c __FUNCTION__$4944
0050109f l     O .rodata	0000001c __FUNCTION__$4949
0050108d l     O .rodata	00000012 __FUNCTION__$4955
00501068 l     O .rodata	00000010 __FUNCTION__$4984
00501055 l     O .rodata	00000013 __FUNCTION__$4989
00501041 l     O .rodata	00000014 __FUNCTION__$5002
00501026 l     O .rodata	0000001b __FUNCTION__$5059
0050100d l     O .rodata	00000019 __FUNCTION__$5072
00501078 l     O .rodata	00000015 __FUNCTION__$4979
00000000 l    df *ABS*	00000000 dbg_api.c
00906dc0 l     F .text	00000011 db_incorect_format
00906dd4 l     F .text	00000028 zf_debug_init
00906dfc l     F .text	0000006a db_ascii_to_hex
00906e68 l     F .text	00000038 db_hex_to_ascii
00906ea0 l     F .text	00000035 db_help_cmd
00906ed8 l     F .text	00000013 db_cmd_starthtc
00906eec l     F .text	0000005c db_cmd_memcmp
00906f48 l     F .text	0000009c db_cmd_memdump
00906fe4 l     F .text	000000bc db_str_cmd
009070a0 l     F .text	00000088 db_ldr_cmd
00907128 l     F .text	000000d9 db_intr_cmd
00907204 l     F .text	00000146 db_wdt_cmd
0090734c l     F .text	00000036 db_usb_cmd
00907384 l     F .text	00000024 db_info_cmd
009073a8 l     F .text	00000243 zf_debug_task
00907628 l     F .text	0000006c db_clock_cmd
00000000 l    df *ABS*	00000000 usb_api_main_patch.c
00510d02 l     O .data	00000002 cmd_is_new$5398
00512c94 l     O .bss	00000004 evntbuf$5396
00512c90 l     O .bss	00000004 regaddr$5397
00512c8c l     O .bss	00000002 buf_len$5395
00510d00 l     O .data	00000002 cmd_is_new$5417
00512c88 l     O .bss	00000004 buf$5415
00512c84 l     O .bss	00000002 cmd_len$5414
005011b4 l     O .rodata	00000012 __func__$5418
00512c80 l     O .bss	00000004 regaddr$5413
00000000 l    df *ABS*	00000000 if_ath.c
00907afc l     F .text	00000014 __adf_os_mem_alloc
00907b10 l     F .text	00000013 __adf_os_mem_copy
00907b24 l     F .text	00000013 __adf_os_mem_set
00907b38 l     F .text	00000005 tgt_HTCRecv_uapsdhandler
0050124e l     O .rodata	00000019 __FUNCTION__$7819
00907b40 l     F .text	0000001c dispatch_magpie_sys_cmds
00907b5c l     F .text	00000005 htc_setup_comp
00907fb8 l     F .text	0000010c tgt_HTCSendCompleteHandler
00907ee8 l     F .text	00000074 tgt_ServiceConnect
00907b64 l     F .text	0000002e tgt_reg_service
00907b94 l     F .text	00000010 tgt_HTCRecv_mgmthandler
00907ba4 l     F .text	00000098 ath_descdma_cleanup
00907c3c l     F .text	00000014 __adf_os_init_bh$isra$5
00907c50 l     F .text	00000010 __adf_os_sched_bh$isra$6
00907c60 l     F .text	000000b7 ath_tgt_rx_tasklet
00907d18 l     F .text	00000198 ath_rxdesc_init
00512c9c l     O .bss	00000001 reset_pll$7632
00907eb0 l     F .text	00000036 ath_pll_reset_ones$isra$12
0050120d l     O .rodata	00000013 __FUNCTION__$7859
00907f5c l     F .text	0000005c ath_reg_read_filter
009080c4 l     F .text	0000004c ath_desc_free
005011ec l     O .rodata	00000012 __FUNCTION__$7419
00908110 l     F .text	000000b4 ath_descdma_setup$isra$22$constprop$28
00501234 l     O .rodata	0000001a __FUNCTION__$7382
009081c4 l     F .text	000000a6 tgt_HTCRecvMessageHandler
0090826c l     F .text	0000003b tgt_HTCRecv_cabhandler
00510e08 l     O .data	00000004 ath_numrxbufs
0050129d l     O .rodata	0000001a __FUNCTION__$7250
00908960 l     F .text	00000012 ath_fatal_tasklet
00908974 l     F .text	00000012 ath_bmiss_tasklet
005012b7 l     O .rodata	0000000c __FUNCTION__$7192
009089e4 l     F .text	0000006a ath_hal_reg_rmw_tgt
00908a50 l     F .text	00000088 ath_rc_mask_tgt
00908ad8 l     F .text	00000023 ath_rx_stats_tgt
00908afc l     F .text	00000042 ath_tx_stats_tgt
00908b40 l     F .text	00000032 ath_int_stats_tgt
00908b74 l     F .text	0000006f ath_node_update_tgt
00908be4 l     F .text	0000002a ath_detach_tgt
00501289 l     O .rodata	00000014 __FUNCTION__$7556
00908c10 l     F .text	000000ab ath_enable_aggr_tgt
00908cbc l     F .text	0000002c ath_ic_update_tgt
00908ce8 l     F .text	0000005a handle_rc_rate_update_cmd
00908d44 l     F .text	00000052 handle_rc_state_change_cmd
00908d98 l     F .text	0000004a ath_hal_reg_write_tgt
00908de4 l     F .text	00000042 ath_hal_reg_read_tgt
00501276 l     O .rodata	00000013 __FUNCTION__$7577
00908e28 l     F .text	0000007a ath_vap_create_tgt
00908ea4 l     F .text	00000052 ath_vap_delete_tgt
00908ef8 l     F .text	00000030 ath_node_cleanup_tgt
00908f28 l     F .text	000000af ath_node_create_tgt
00501267 l     O .rodata	0000000f __FUNCTION__$7171
00908fd8 l     F .text	00000080 ath_setcurmode_tgt
00909058 l     F .text	00000050 ath_flushrecv_tgt
009090a8 l     F .text	0000003a ath_stoprecv_tgt
009090e4 l     F .text	00000086 ath_startrecv_tgt
0090916c l     F .text	000000c6 ath_draintxq_tgt
00909234 l     F .text	0000002e ath_tx_draintxq_tgt
00909264 l     F .text	00000023 ath_aborttx_dma_tgt
00909288 l     F .text	00000026 ath_stop_tx_dma_tgt
009092b0 l     F .text	00000040 ath_aborttxq_tgt
009092f0 l     F .text	0000004e ath_init_tgt
00909340 l     F .text	00000054 ath_enable_intr_tgt
00909394 l     F .text	00000026 ath_disable_intr_tgt
009093bc l     F .text	0000001e ath_get_tgt_version
009093dc l     F .text	00000013 handle_echo_command
00501220 l     O .rodata	00000014 __FUNCTION__$7310
00909408 l     F .text	000001d4 tgt_HTCRecv_beaconhandler
00510d04 l     O .data	00000100 Magpie_Sys_DispatchEntries
00510e04 l     O .data	00000004 ath_numrxdescs
005011fe l     O .rodata	0000000f __FUNCTION__$7443
00000000 l    df *ABS*	00000000 htc.c
005012c3 l     O .rodata	00000018 __FUNCTION__$4106
00000000 l    df *ABS*	00000000 wmi_svc.c
0090a374 l     F .text	0000000b WMIServiceConnect
0090a380 l     F .text	00000007 _WMI_GetPendingEventsCount
0090a388 l     F .text	00000007 _WMI_GetControlEp
0090a390 l     F .text	00000014 _WMI_RegisterDispatchTable
0090a3a4 l     F .text	00000005 _WMI_Shutdown
005012db l     O .rodata	00000016 __FUNCTION__$3905
0090a3ac l     F .text	0000009b WMIRecvMessageHandler
0090a448 l     F .text	00000024 _WMI_SendCompleteHandler
0090a46c l     F .text	00000030 _WMI_AllocEvent
0090a49c l     F .text	00000036 _WMI_SendEvent
0090a4d4 l     F .text	0000006f _WMI_Init
00000000 l    df *ABS*	00000000 ar5416_hw.c
005012f4 l     O .rodata	000000d4 ar5416hal_10
00000000 l    df *ABS*	00000000 ratectrl_11n_ln.c
0090c0ac l     F .text	000000bc rcRateSetseries
0090c168 l     F .text	00000058 rcIsValidPhyRate
0090c1c0 l     F .text	00000401 rcSibUpdate_ht$constprop$6
0090c5c4 l     F .text	0000002a ath_rate_newassoc_11n
005013c8 l     O .rodata	00000028 nRetry2PerLookup$7260
0090c5f0 l     F .text	0000020e rcUpdate_ht$constprop$5
0090c800 l     F .text	00000062 rcRateGetIndex$constprop$9
00000000 l    df *ABS*	00000000 if_owl.c
0090cdfc l     F .text	00000013 __adf_os_mem_copy
0090ce10 l     F .text	0000004d ieee80211_anyhdrsize
0090ce60 l     F .text	0000004c owl_tgt_tid_init
00501455 l     O .rodata	00000016 __FUNCTION__$7250
0090ceac l     F .text	0000008a ath_tgt_txq_add_ucast
0090cf38 l     F .text	0000005f ath_tx_update_baw
0090cf98 l     F .text	00000060 ath_update_stats$isra$1
0090cff8 l     F .text	00000024 ath_tgt_tx_enqueue$isra$3
0090d01c l     F .text	00000076 ath_update_aggr_stats$isra$5
0090d094 l     F .text	00000014 ath_dma_unmap$isra$6
0090d0a8 l     F .text	00000026 ath_tgt_skb_free$isra$7
0090d0d0 l     F .text	0000009e ath_filltxdesc$isra$9
0090d170 l     F .text	0000004e ath_tx_tgt_setds
0090d1c0 l     F .text	00000013 __adf_os_mem_set$constprop$19
005014b4 l     O .rodata	00000040 bits_per_symbol
0090d1d4 l     F .text	00000212 ath_buf_set_rate
0090d3e8 l     F .text	00000016 ath_dma_map$isra$8
005014a5 l     O .rodata	0000000f __FUNCTION__$7058
0090d400 l     F .text	00000111 ath_buf_toggle
0090d514 l     F .text	0000003c ath_buf_comp
0090d550 l     F .text	00000083 ath_tx_freebuf
0090ef6c l     F .text	00000107 ath_bar_tx_comp
0090d5d4 l     F .text	0000016a ath_bar_tx
0090d940 l     F .text	00000010 ATH_SKB2_WH
0090d950 l     F .text	0000002f ath_tx_set_retry$isra$12
0090d980 l     F .text	000000e7 ath_tx_retry_subframe$isra$14
0090da68 l     F .text	000000b7 ath_tx_comp_aggr_error
0050146b l     O .rodata	00000011 __FUNCTION__$7214
0050147c l     O .rodata	00000013 __FUNCTION__$7223
00501444 l     O .rodata	00000011 __FUNCTION__$7331
0050142e l     O .rodata	00000016 __FUNCTION__$7352
0090ea50 l     F .text	0000005a ath_tgt_tx_comp_normal
0050141a l     O .rodata	00000014 __FUNCTION__$7375
00501405 l     O .rodata	00000015 __FUNCTION__$7441
0050148f l     O .rodata	00000016 __FUNCTION__$7404
0090e69c l     F .text	00000214 ath_tgt_txq_schedule
0090e9bc l     F .text	00000046 ath_aggr_resume_tid
0090ea04 l     F .text	0000004b owl_tgt_tid_cleanup
005013f0 l     O .rodata	00000015 __FUNCTION__$7478
00000000 l    df *ABS*	00000000 app_start.c
0090f140 l     F .text	00000029 io32_rmw
00000000 l    df *ABS*	00000000 init.c
00906270 l     F .text	00000029 io32_rmw
00512c70 l     O .bss	00000004 loop_high
00512c74 l     O .bss	00000004 loop_low
00000000 l    df *ABS*	00000000 ah_osdep.c
00000000 l    df *ABS*	00000000 wlan_pci.c
00000000 l    df *ABS*	00000000 usb_api_magpie_patch.c
0090a57c l     F .text	00000029 io32_rmw
0090a5a8 l     F .text	00000068 _fw_restore_dma_fifo
0090a610 l     F .text	00000377 _fw_reset_dma_fifo
00000000 l    df *ABS*	00000000 if_ath_pci.c
0090f074 l     F .text	00000005 ath_pci_suspend
0090f07c l     F .text	00000005 ath_pci_resume
0090f084 l     F .text	00000010 ath_pci_remove
00511bc0 l     O .data	00000020 ath_drv_info
0090f0a4 l     F .text	0000007e ath_pci_probe
00511be0 l     O .data	00000160 ath_pci_id_table
00000000 l    df *ABS*	00000000 buf_pool_static.c
00000000 l    df *ABS*	00000000 cmnos_clock_patch.c
00512cbc l     O .bss	00000004 last_tick$3816
00000000 l    df *ABS*	00000000 HIF_usb_patch.c
00000000 l    df *ABS*	00000000 adf_os_dma.c
00000000 l    df *ABS*	00000000 adf_os_irq_pvt.c
00000000 l    df *ABS*	00000000 ah.c
00000000 l    df *ABS*	00000000 ar5416_phy.c
00000000 l    df *ABS*	00000000 adf_net.c
00000000 l    df *ABS*	00000000 ar5416Phy.c
00000000 l    df *ABS*	00000000 ieee80211_output.c
00500abc g       *ABS*	00000000 u16TxRxCounter
00906728 g     F .text	00000035 init_mem
00511388 g     O .data	000002bc ar5416_11g_table
008e37e8 g       *ABS*	00000000 HIFusb_DescTraceDump
0090cd7c g     F .text	00000036 ath_rate_tx_complete
004e8000 g       *ABS*	00000000 _rom_literal_start
0090654c g     F .text	00000054 zfGenWrongEpidEvent
00906a90 g     F .text	0000002b __adf_nbuf_dmamap_info
00512cf4 g     O .bss	000000a0 cmd_str
00510e0c g     O .data	00000002 bEepromExist
009079f4 g     F .text	00000079 bGet_descriptor_patch
0090db20 g     F .text	0000002d ath_tgt_tid_drain
00906bc8 g     F .text	00000011 __adf_nbuf_last
00500ad0 g       *ABS*	00000000 u8UsbInterfaceValue
00906984 g     F .text	00000020 __adf_nbuf_copy
00512cc0 g     O .bss	00000004 _assfail_ori
00906a70 g     F .text	00000009 __adf_nbuf_map
005022e4 g       *ABS*	00000000 _bss_table_end
0090f220 g     F .text	0000000c __adf_net_register_drv
00512ca0 g     O .bss	00000004 g_wlan_intr
00906a54 g     F .text	0000001c __adf_nbuf_dmamap_create
0090ad48 g     F .text	0000004f ath_hal_get_curmode
00511d40 g     O .data	0000073c ar5416_11naRateTable
0090a088 g     F .text	00000098 HTCControlSvcProcessMsg
0051247c g     O .data	000007ec ar5416_11ngRateTable
00512d94 g     O .bss	00000002 gvLen
00909a60 g     F .text	0000000f wlan_pci_module_init
00500000 g       *ABS*	00000000 _indir_tbl
0090ac8c g     F .text	00000010 ath_hal_attach_tgt
00906d9c g     F .text	00000023 buf_pool_module_install
00501000 g       *ABS*	00000000 _lit4_end
00906c80 g     F .text	00000007 __adf_nbuf_is_cloned
00907824 g     F .text	000000ff usb_reg_out_patch
00906abc g     F .text	00000005 __adf_nbuf_set_rx_cksum
0090bde4 g     F .text	000000bc ar5416AbortTxDma
00512d98 g     O .bss	00000004 cmd_buf_ptr
0090f231 g       *ABS*	00000000 _text_end
0090eaac g     F .text	00000408 ath_tgt_tx_comp_aggr
0090abac g     F .text	00000013 _HIFusb_isr_handler_patch
0090cd1c g     F .text	0000002e ath_rate_attach
0090bd00 g     F .text	00000044 ar5416Set11nBurstDuration_20
00907968 g     F .text	00000022 vUsbFIFO_EPxCfg_FS_patch
00906acc g     F .text	0000009a __adf_nbuf_create_frm_frag
00907700 g     F .text	00000022 cold_reboot
00501000 g       *ABS*	00000000 _lit4_start
009076ac g     F .text	0000000f cmnos_dbg_module_install
00502b14 g       *ABS*	00000000 _dram0_literal_end
0090a120 g     F .text	0000003c AdjustCreditThreshold
00502b14 g       *ABS*	00000000 _dram0_literal_start
0090ad98 g     F .text	00000029 ath_hal_wait
0090f231 g       .text	00000000 _etext
0090bd44 g     F .text	0000006f ar5416Set11nVirtualMoreFrag_20
008e4f60 g       *ABS*	00000000 vbuf_module_install
00512c68 g     O .bss	00000004 idle_cnt
0090d740 g     F .text	00000043 owl_tgt_node_init
00907724 g     F .text	000000ff usb_status_in_patch
00909a70 g     F .text	0000000a wlan_pci_register_drv
0090692c g     F .text	0000002a __adf_nbuf_push_head
009076bc g     F .text	00000022 _fw_usbfifo_recv_command
0090f130 g     F .text	0000000f ar5416AttachRateTables
00909c14 g     F .text	000000bf _HTC_Init
009068cc g     F .text	0000001e __adf_nbuf_realloc_headroom
0090bb30 g     F .text	00000089 ar5416Set11nAggrFirst_20
00906a88 g     F .text	00000005 __adf_nbuf_dmamap_destroy
0090de68 g     F .text	0000043b ath_tgt_send_mgt
0090c078 g     F .text	00000033 ar5416GetRateTable
00906ca0 g     F .text	0000000d __adf_nbuf_queue_init
008e6b64 g       *ABS*	00000000 memcpy
00907694 g     F .text	00000016 dbg_timer_func
0090cdb4 g     F .text	00000012 ath_rate_newassoc
005022e4 g       *ABS*	00000000 _rodata_end
00906ac4 g     F .text	00000007 __adf_nbuf_get_vlan_info
0090cae4 g     F .text	00000196 rcUpdate_11n
0090acd4 g     F .text	00000073 ath_hal_computetxtime
00500ad8 g       *ABS*	00000000 u8UsbDeviceDescriptor
0090cc7c g     F .text	0000009e ath_tx_status_update_rate
00906cb8 g     F .text	00000007 __adf_nbuf_queue_first
00512cc4 g     O .bss	00000004 htc_handle
0090d940 g     F .text	00000010 ATH_SKB_2_WH
0090f16c g     F .text	000000b3 ieee80211_tgt_crypto_encap
008e6a4c g       *ABS*	00000000 __udivsi3
00909d64 g     F .text	00000057 _HTC_Ready
00907a70 g     F .text	00000010 ath_hal_getuptime
00906c04 g     F .text	0000003b __adf_nbuf_trim_tail
00512c68 g       *ABS*	00000000 _bss_start
00510d00 g       *ABS*	00000000 _dram0_data_end
00511900 g     O .data	000002bc ar5416_11a_table
00909e24 g     F .text	00000066 ReturnBuffers
0090dde0 g     F .text	00000088 ath_tgt_tx_send_normal
00500ad2 g       *ABS*	00000000 u8UsbInterfaceAlternateSetting
00512c68 g       *ABS*	00000000 __XT_EXCEPTION_DESCS__
0090e360 g     F .text	000000c6 ath_tgt_handle_aggr
005010e8 g     O .rodata	000000cc command_table
00906270 g       *ABS*	00000000 _text_start
009076e0 g     F .text	00000020 _fw_usbfifo_init
0090e8b0 g     F .text	0000009a owltgt_tx_processq
009068ec g     F .text	0000001e __adf_nbuf_realloc_tailroom
0090e2a4 g     F .text	00000070 ath_tgt_handle_normal
0090b190 g     F .text	00000015 ar5416StartTxDma
0090bfa8 g     F .text	00000055 ar5416SetRxFilter
00907adc g     F .text	00000005 ath_hal_free
0090a15c g     F .text	0000014e _HTC_SendMsg
0090c000 g     F .text	00000077 ar5416Attach
00906c78 g     F .text	00000005 __adf_nbuf_cat
0090b17c g     F .text	00000014 ar5416SetTxDP
0090cdc8 g     F .text	00000012 ath_rate_node_update
008e1548 g       *ABS*	00000000 generic_hif_module_install
00906c4c g     F .text	00000019 __adf_nbuf_tailroom
00906c70 g     F .text	00000007 __adf_nbuf_clone
008e4934 g       *ABS*	00000000 mUsbFIFOConfig
0090ab28 g     F .text	0000000a cmnos_clock_init_patch
008e36e4 g       *ABS*	00000000 _HIFusb_isr_handler
00906cf8 g     F .text	00000057 _buf_pool_static_create_pool
00512d9c g     O .bss	00000028 raw_cmd
00906cb0 g     F .text	00000007 __adf_nbuf_queue_len
00501000 g       *ABS*	00000000 _dport0_literal_start
0090f124 g     F .text	0000000b exit_ath_pci
00512f10 g       *ABS*	00000000 _bss_end
00906cf0 g     F .text	00000005 _buf_pool_static_shutdown
0090b118 g     F .text	00000061 ar5416UpdateTxTrigLevel
00512cb4 g     O .bss	00000002 bJumptoFlash
00512cc8 g     O .bss	0000002c g_poolCtx
009069ec g     F .text	00000020 __adf_nbuf_get_priv
00512cb0 g     O .bss	00000004 gpio_func
0090a00c g     F .text	0000007b HTCProcessConfigPipeMsg
00906d50 g     F .text	00000024 _buf_pool_static_alloc_buf
0090bdb4 g     F .text	0000000a ar5416Detach
0090ae9c g     F .text	0000000f ar5416EnableReceive
00500aa4 g       *ABS*	00000000 usbFifoConf
00500ab8 g       *ABS*	00000000 pu8DescriptorEX
0090ab34 g     F .text	0000000a cmnos_refclk_speed_get_patch
0090b7c4 g     F .text	00000108 ar5416Set11nTxDesc_20
00510d00 g       *ABS*	00000000 _dram0_data_start
0090f094 g     F .text	0000000d init_ath_pci
00511644 g     O .data	000002bc ar5416_11b_table
008e3a9c g       *ABS*	00000000 bGet_descriptor
0090b1a8 g     F .text	0000002e ar5416NumTxPending
009095dc g     F .text	0000045c ath_tgt_attach
00909bb8 g     F .text	00000013 _HTC_GetReservedHeadroom
00906834 g     F .text	0000003c Magpie_init
00512c68 g       *ABS*	00000000 __XT_EXCEPTION_DESCS_END__
00906470 g     F .text	0000005e zfGenExceptionEvent
00906b68 g     F .text	00000060 __adf_nbuf_split_to_frag
0090a544 g     F .text	00000037 WMI_service_module_install
00906d74 g     F .text	00000010 _buf_pool_static_alloc_buf_align
00501000 g       *ABS*	00000000 _dport0_rodata_start
00510d00 g       *ABS*	00000000 _dport0_data_start
008e6958 g       *ABS*	00000000 xthal_get_ccount
0090690c g     F .text	0000001e __adf_nbuf_expand
0090addc g     F .text	00000085 ar5416SetInterrupts
009062e4 g     F .text	00000066 change_magpie_clk
0090ae8c g     F .text	0000000d ar5416SetRxDP
0090d784 g     F .text	00000010 ath_tx_status_clear
00512ca4 g     O .bss	00000004 g_wlan_drv_handle
00909bcc g     F .text	0000002e HTCSendDoneHandler
0090a988 g     F .text	00000072 _fw_usb_suspend_reboot
008e497c g       *ABS*	00000000 mUsbEPMxPtSzLow
0090ae64 g     F .text	00000026 ar5416GetTsf64
00512cb8 g     O .bss	00000004 ref_clk
00909dbc g     F .text	00000066 HTCCheckAndSendCreditReport
00500a98 g       *ABS*	00000000 ControlCmd
00510d00 g       *ABS*	00000000 _data_start
00500ace g       *ABS*	00000000 u8UsbConfigValue
00907ab8 g     F .text	00000022 ath_hal_malloc
0090bdc0 g     F .text	00000021 ar5416StopDmaReceive
00909cd4 g     F .text	00000005 _HTC_PauseRecv
0090f22c g     F .text	00000005 __adf_net_unregister_drv
0090ac44 g     F .text	0000002e __adf_os_dmamem_alloc
008e48f8 g       *ABS*	00000000 mUsbEPMap
00906958 g     F .text	0000002b __adf_nbuf_pull_head
0090ac74 g     F .text	0000000c __adf_os_setup_intr
00512c7c g     O .bss	00000004 m_origUsbfifoRecvCmd
0090ab5c g     F .text	0000002b cmnos_tick_patch
00906a0c g     F .text	0000001e __adf_nbuf_queue_add
00908988 g     F .text	0000005b wmi_cmd_rsp
009069a4 g     F .text	00000020 __adf_nbuf_unshare
00512ec0 g     O .bss	00000012 UsbDeviceDescriptorPatch
00906d84 g     F .text	00000018 _buf_pool_static_free_buf
00906cc8 g     F .text	00000010 __adf_nbuf_is_queue_empty
0090adc4 g     F .text	00000017 ar5416IsInterruptPending
00907ae4 g     F .text	00000015 ath_hal_memcpy
008e6348 g       *ABS*	00000000 _xtos_set_exception_handler
00906000 g     F .boot	00000270 app_start
0090b1d8 g     F .text	000001e6 ar5416SetupTxDesc_20
0050095c g       *ABS*	00000000 cticks
008e5010 g       *ABS*	00000000 vdesc_module_install
0090d794 g     F .text	000000c3 ath_tx_status_update
00512c68 g       *ABS*	00000000 _data_end
0090f231 g       *ABS*	00000000 _iram0_text_end
0090e428 g     F .text	00000273 ath_tgt_tx_form_aggr
005022d3 g       *ABS*	00000000 __XT_EXCEPTION_TABLE__
0090e314 g     F .text	0000004a ath_tx_addto_baw
00906a2c g     F .text	00000026 __adf_nbuf_queue_remove
00909a38 g     F .text	00000028 ath_detach
00906760 g     F .text	0000005d wlan_task
005022e4 g       *ABS*	00000000 _literals_start
00512dc4 g     O .bss	000000f0 cmd_buffer
00906cd8 g     F .text	00000018 _buf_pool_static_init
00512c6c g     O .bss	00000001 htc_complete_setup
00906c68 g     F .text	00000008 __adf_nbuf_len
0090bea0 g     F .text	0000003d ar5416StopTxDma
00909b88 g     F .text	00000016 wlan_pci_isr
008e6e48 g       *ABS*	00000000 memset
00502b14 g       *ABS*	00000000 _literals_end
00909ba0 g     F .text	00000005 _HTC_Shutdown
0090ac9c g     F .text	00000037 ath_hal_getcapability
009069c4 g     F .text	00000027 __adf_nbuf_frag_info
00501000 g       *ABS*	00000000 _dport0_rodata_end
0090ab40 g     F .text	0000001c cmnos_delay_us_patch
00500ac4 g       *ABS*	00000000 eUsbCxFinishAction
00512c98 g     O .bss	00000004 init_htc_handle
00909d28 g     F .text	00000016 HTCFreeMsgBuffer
0090bbbc g     F .text	00000083 ar5416Set11nAggrMiddle_20
00906c88 g     F .text	00000015 __adf_nbuf_peek_header
009065d4 g     F .text	00000153 HTCMsgRecvHandler_patch
00906444 g     F .text	0000002a reset_EP4_FIFO
008e6998 g       *ABS*	00000000 __divsi3
008e6560 g       *ABS*	00000000 strcmp
0090af3c g     F .text	000001dc ar5416ProcRxDescFast_20
00501000 g       *ABS*	00000000 _dram0_rodata_start
0090a9fc g     F .text	000000da zfTurnOffPower_patch
00501000 g       *ABS*	00000000 _rom_literal_end
009082a8 g     F .text	0000005b wmi_event
00512c78 g     O .bss	00000004 delay
00909aac g     F .text	0000003c wlan_pci_config_read
00908304 g     F .text	0000065a ath_intr
00909e8c g     F .text	00000010 _HTC_ReturnBuffers
008e1574 g       *ABS*	00000000 athos_indirection_table_install
008e6980 g       *ABS*	00000000 xthal_get_intenable
0090e94c g     F .text	00000070 owl_tgt_tx_tasklet
008e4954 g       *ABS*	00000000 mUsbEPMxPtSzHigh
00907aa8 g     F .text	00000010 ath_hal_delay
00500ac0 g       *ABS*	00000000 u8ConfigDescriptorEX
00906870 g     F .text	0000003e __adf_nbuf_alloc
0090abc0 g     F .text	00000083 _HIFusb_start_patch
00906cc0 g     F .text	00000007 __adf_nbuf_queue_next
009075ec g     F .text	0000003c db_ascii_to_int
0090a2ac g     F .text	000000be HTCMsgRecvHandler
0090d858 g     F .text	000000a0 ath_tx_status_update_aggr
009068b0 g     F .text	0000001c __adf_nbuf_free
00512eb4 g     O .bss	00000004 cmd_not_found
008e4914 g       *ABS*	00000000 mUsbFIFOMap
009067c0 g     F .text	00000005 htc_setup_comp
005022d4 g       *ABS*	00000000 _bss_table_start
005110cc g     O .data	000002bc ar5416_11ng_table
00906a7c g     F .text	00000009 __adf_nbuf_unmap
00906c40 g     F .text	0000000a __adf_nbuf_headroom
0090eeb4 g     F .text	000000b6 ath_tgt_tx_cleanup
008e3e64 g       *ABS*	00000000 bStandardCommand
008e3b54 g       *ABS*	00000000 bSet_configuration
00909ae8 g     F .text	000000a0 wlan_pci_probe
009064d0 g     F .text	0000007c AR6002_fatal_exception_handler_patch
00909ce4 g     F .text	00000041 htc_module_install
00510d00 g       *ABS*	00000000 _dport0_data_end
0090ab88 g     F .text	0000000d cmnos_milliseconds_patch
00512cac g     O .bss	00000004 gpio
00501000 g       *ABS*	00000000 _rodata_start
009093f0 g     F .text	00000018 ath_get_minrateidx
00512f10 g       .bss	00000000 _end
008e34a0 g       *ABS*	00000000 _HIFusb_start
0090ab98 g     F .text	00000011 _HIFusb_get_max_msg_len_patch
0090aad8 g     F .text	0000004f zfResetUSBFIFO_patch
0090d8f8 g     F .text	00000046 ath_tx_status_send
00512eb8 g     O .bss	00000004 cmd_buf_full
0090f231 g       *ABS*	00000000 _iram0_text_start
0090bc40 g     F .text	0000007d ar5416Set11nAggrLast_20
00909ee8 g     F .text	00000043 HTCControlSvcProcessSendComplete
00909d40 g     F .text	00000021 HTCAllocMsgBuffer
00511bbc g     O .data	00000004 g_pci_init_func
00909ba8 g     F .text	0000000d _HTC_RegisterService
00907a80 g     F .text	00000026 _ath_hal_attach_tgt
00909f2c g     F .text	000000e0 HTCProcessConnectMsg
0090bcc0 g     F .text	0000003e ar5416Clr11nAggr_20
0090c864 g     F .text	0000027e rcRateFind_11n
00906bdc g     F .text	00000026 __adf_nbuf_put_tail
0090cd4c g     F .text	0000002f ath_rate_findrate
00512ca8 g     O .bss	00000004 g_wlan_drv
0090634c g     F .text	000000f6 exception_reset
0090b3c0 g     F .text	00000136 ar5416FillTxDesc_20
00909bfc g     F .text	00000017 HTC_AssembleBuffers
00510e10 g     O .data	000002bc ar5416_11na_table
00512f10 g       *ABS*	00000000 _fw_image_end
00909cdc g     F .text	00000005 _HTC_ResumeRecv
0090db50 g     F .text	0000028e ath_tgt_tx_prepare
00906270 g       .text	00000000 _stext
0090798c g     F .text	00000023 bSet_configuration_patch
0090ac80 g     F .text	0000000c __adf_os_free_intr
0090b4f8 g     F .text	00000021 ar5416FillKeyTxDesc_20
009067c8 g     F .text	0000006b _wmi_cmd_rsp
00512ebc g     O .bss	00000004 pressed_time
00909a7c g     F .text	00000030 wlan_pci_config_write
0090629c g     F .text	00000046 fatal_exception_func
00909e9c g     F .text	0000004a _HTC_ReturnBuffersList
0090aec4 g     F .text	00000077 ar5416SetupRxDesc_20
009065a0 g     F .text	00000032 HTCControlSvcProcessMsg_patch
008e49a0 g       *ABS*	00000000 mUsbEPinHighBandSet
0090cddc g     F .text	0000001e ath_rate_newstate
00510d00 g       *ABS*	00000000 _dport0_bss_start
00501000 g       *ABS*	00000000 _dram0_rodata_end
0090b51c g     F .text	000002a8 ar5416ProcTxDesc_20
0090a36c g     F .text	00000005 RedistributeCredit
00907924 g     F .text	00000042 vUSBFIFO_EP6Cfg_FS_patch
00510d00 g       *ABS*	00000000 _dport0_bss_end
009079b0 g     F .text	00000044 bStandardCommand_patch
00512ed2 g     O .bss	0000003c ConfigDescriptorPatch
0090bee0 g     F .text	000000c7 ar5416GetPendingInterrupts
00501000 g       *ABS*	00000000 _dport0_literal_end
0090b8cc g     F .text	00000264 ar5416Set11nRateScenario_20
0090aeac g     F .text	00000017 ar5416StopPcuReceive



Disassembly of section .boot:

00906000 <app_start>:

extern BOOLEAN bJumptoFlash;
extern BOOLEAN bEepromExist;

void __section(boot) __noreturn __visible app_start(void)
{
  906000:	6c1004        	entry	a1, 32
#if defined(PROJECT_MAGPIE)
	T_EEP_RET retEEP;
#endif

	/* Zero BSS segment & dynamic memory section. */
	init_mem();
  906003:	5801c9        	call8	906728 <init_mem>

#if defined(PROJECT_MAGPIE)
	fatal_exception_func();
  906006:	5800a5        	call8	90629c <fatal_exception_func>
#endif

	if( IS_FLASHBOOT() ) {
  906009:	1268bb        	l32r	a2, 8e02f8 <_bss_end+0x3cd3e8>
  90600c:	1568bc        	l32r	a5, 8e02fc <_bss_end+0x3cd3ec>
  90600f:	0c0200        	memw
  906012:	232200        	l32i	a3, a2, 0
  906015:	1468bd        	l32r	a4, 8e030c <_bss_end+0x3cd3fc>
  906018:	03035f        	extui	a3, a3, 16, 16
  90601b:	1268bf        	l32r	a2, 8e0318 <_bss_end+0x3cd408>
  90601e:	753937        	bne	a3, a5, 906059 <app_start+0x59>
		athos_indirection_table_install();
  906021:	5b6d54        	call8	8e1574 <athos_indirection_table_install>
		DBG_MODULE_INSTALL();
  906024:	da40      	mov.n	a10, a4
  906026:	5805a1        	call8	9076ac <cmnos_dbg_module_install>
		A_CLOCK_INIT(SYSTEM_CLK);
  906029:	1a68be        	l32r	a10, 8e0324 <_bss_end+0x3cd414>
  90602c:	232238        	l32i	a3, a2, 224
  90602f:	0b3000        	callx8	a3
		A_UART_INIT();
  906032:	2a2213        	l32i	a10, a2, 76
  906035:	0ba000        	callx8	a10
		A_PRINTF_INIT();
  906038:	232211        	l32i	a3, a2, 68
  90603b:	0b3000        	callx8	a3
		A_DBG_INIT();
  90603e:	23226e        	l32i	a3, a2, 0x1b8
  906041:	0b3000        	callx8	a3
		A_EEP_INIT();
  906044:	23225f        	l32i	a3, a2, 0x17c
  906047:	0b3000        	callx8	a3
		A_TASKLET_INIT();
  90604a:	232269        	l32i	a3, a2, 0x1a4
  90604d:	0b3000        	callx8	a3
		_indir_tbl.cmnos.timer._timer_init();
  906050:	232241        	l32i	a3, a2, 0x104
  906053:	600005        	j	90605c <app_start+0x5c>
  906056:	000000        	ill
		u8UsbInterfaceAlternateSetting = u8UsbConfigValue = u8UsbInterfaceValue = 0;
#endif
	}
#ifdef ROM_VER_1_1
	else
		A_EEP_INIT(); /*Required for 1_1*/
  906059:	23225f        	l32i	a3, a2, 0x17c
  90605c:	0b3000        	callx8	a3
#endif

#if defined(PROJECT_MAGPIE)
	retEEP = A_EEP_IS_EXIST();
  90605f:	2a2262        	l32i	a10, a2, 0x188
	bJumptoFlash = FALSE;
  906062:	250a00        	movi	a5, 0
	else
		A_EEP_INIT(); /*Required for 1_1*/
#endif

#if defined(PROJECT_MAGPIE)
	retEEP = A_EEP_IS_EXIST();
  906065:	0ba000        	callx8	a10
	bJumptoFlash = FALSE;
  906068:	1368c0        	l32r	a3, 8e0368 <_bss_end+0x3cd458>
  90606b:	253500        	s16i	a5, a3, 0
  90606e:	1368c1        	l32r	a3, 8e0374 <_bss_end+0x3cd464>
	if ( RET_SUCCESS == retEEP ) {
  906071:	cca0      	bnez.n	a10, 906075 <app_start+0x75>
		bEepromExist = TRUE;
  906073:	c051      	movi.n	a5, 1
	} else {
		bEepromExist = FALSE;
	}
#endif

	hostif = A_IS_HOST_PRESENT();
  906075:	8a2e      	l32i.n	a10, a2, 56
	retEEP = A_EEP_IS_EXIST();
	bJumptoFlash = FALSE;
	if ( RET_SUCCESS == retEEP ) {
		bEepromExist = TRUE;
	} else {
		bEepromExist = FALSE;
  906077:	253500        	s16i	a5, a3, 0
	}
#endif

	hostif = A_IS_HOST_PRESENT();
  90607a:	0ba000        	callx8	a10
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90607d:	1368c2        	l32r	a3, 8e0388 <_bss_end+0x3cd478>
  906080:	d5a0      	mov.n	a5, a10
  906082:	0c0200        	memw
  906085:	263200        	l32i	a6, a3, 0
#elif defined(PROJECT_K2)
	rst_status = ioread32(MAGPIE_REG_RST_STATUS_ADDR);
#endif /* #if defined(PROJECT_MAGPIE) */


	A_PRINTF(" A_WDT_INIT()\n\r");
  906088:	1a68c3        	l32r	a10, 8e0394 <_bss_end+0x3cd484>
  90608b:	232212        	l32i	a3, a2, 72
  90608e:	0b3000        	callx8	a3
		_indir_tbl.cmnos.usb._usb_fw_task = _fw_usb_fw_task;
		_indir_tbl.cmnos.usb._usb_reset_fifo = _fw_usb_reset_fifo;
#endif
	}

	if( rst_status == WDT_MAGIC_PATTERN ) {
  906091:	1768c4        	l32r	a7, 8e03a4 <_bss_end+0x3cd494>
  906094:	232212        	l32i	a3, a2, 72
  906097:	77691a        	bne	a6, a7, 9060b5 <app_start+0xb5>
		A_PRINTF(" ==>WDT reset<==\n");
  90609a:	1a68c5        	l32r	a10, 8e03b0 <_bss_end+0x3cd4a0>
  90609d:	0b3000        	callx8	a3
#if defined(PROJECT_MAGPIE)
		reset_EP4_FIFO();
  9060a0:	5800e8        	call8	906444 <reset_EP4_FIFO>
#endif
		*((volatile uint32_t*)WATCH_DOG_RESET_COUNTER_ADDR)+=1;
  9060a3:	1668c6        	l32r	a6, 8e03bc <_bss_end+0x3cd4ac>
  9060a6:	0c0200        	memw
  9060a9:	8360      	l32i.n	a3, a6, 0
  9060ab:	b133      	addi.n	a3, a3, 1
  9060ad:	0c0200        	memw
  9060b0:	9360      	s32i.n	a3, a6, 0
  9060b2:	60000e        	j	9060c4 <app_start+0xc4>
	} else if (rst_status == SUS_MAGIC_PATTERN) {
  9060b5:	1768c7        	l32r	a7, 8e03d4 <_bss_end+0x3cd4c4>
		A_PRINTF(" ==>warm start<==\n");
  9060b8:	1a68c8        	l32r	a10, 8e03d8 <_bss_end+0x3cd4c8>
		A_PRINTF(" ==>WDT reset<==\n");
#if defined(PROJECT_MAGPIE)
		reset_EP4_FIFO();
#endif
		*((volatile uint32_t*)WATCH_DOG_RESET_COUNTER_ADDR)+=1;
	} else if (rst_status == SUS_MAGIC_PATTERN) {
  9060bb:	776102        	beq	a6, a7, 9060c1 <app_start+0xc1>
		A_PRINTF(" ==>warm start<==\n");
	} else
		A_PRINTF(" ==>cold start<==\n");
  9060be:	1a68c9        	l32r	a10, 8e03e4 <_bss_end+0x3cd4d4>
  9060c1:	0b3000        	callx8	a3

#if defined(PROJECT_MAGPIE)
	*((volatile uint32_t*)WATCH_DOG_MAGIC_PATTERN_ADDR)=WDT_MAGIC_PATTERN;
  9060c4:	1668c4        	l32r	a6, 8e03d4 <_bss_end+0x3cd4c4>
  9060c7:	1368c2        	l32r	a3, 8e03d0 <_bss_end+0x3cd4c0>
#endif /* #if defined(PROJECT_MAGPIE) */

	/* intr enable would left for firmware */
	/* athos_interrupt_init(); */

	DBG_MODULE_INSTALL();
  9060ca:	da40      	mov.n	a10, a4
		A_PRINTF(" ==>warm start<==\n");
	} else
		A_PRINTF(" ==>cold start<==\n");

#if defined(PROJECT_MAGPIE)
	*((volatile uint32_t*)WATCH_DOG_MAGIC_PATTERN_ADDR)=WDT_MAGIC_PATTERN;
  9060cc:	0c0200        	memw
  9060cf:	9630      	s32i.n	a6, a3, 0
#endif /* #if defined(PROJECT_MAGPIE) */

	/* intr enable would left for firmware */
	/* athos_interrupt_init(); */

	DBG_MODULE_INSTALL();
  9060d1:	580576        	call8	9076ac <cmnos_dbg_module_install>
	SFLASH_MODULE_INSTALL();
	A_SFLASH_INIT();
#endif
#endif

	HIF_MODULE_INSTALL();
  9060d4:	1a68ca        	l32r	a10, 8e03fc <_bss_end+0x3cd4ec>
  9060d7:	5b6d1c        	call8	8e1548 <generic_hif_module_install>
	HTC_MODULE_INSTALL();
  9060da:	1a68cb        	l32r	a10, 8e0408 <_bss_end+0x3cd4f8>
  9060dd:	580f01        	call8	909ce4 <htc_module_install>
	WMI_SERVICE_MODULE_INSTALL();
  9060e0:	1a68cc        	l32r	a10, 8e0410 <_bss_end+0x3cd500>
  9060e3:	581118        	call8	90a544 <WMI_service_module_install>
	BUF_POOL_MODULE_INSTALL();
  9060e6:	1a68cd        	l32r	a10, 8e041c <_bss_end+0x3cd50c>
  9060e9:	58032c        	call8	906d9c <buf_pool_module_install>
	VBUF_MODULE_INSTALL();
  9060ec:	1a68ce        	l32r	a10, 8e0424 <_bss_end+0x3cd514>
  9060ef:	5b7b9c        	call8	8e4f60 <vbuf_module_install>
	VDESC_MODULE_INSTALL();
  9060f2:	1a68cf        	l32r	a10, 8e0430 <_bss_end+0x3cd520>
  9060f5:	5b7bc6        	call8	8e5010 <vdesc_module_install>

	//init each module, should be put together..
	A_PRINTF("ALLOCRAM start 0x%x size %d\n", ALLOCRAM_START, ALLOCRAM_SIZE);
  9060f8:	1468d0        	l32r	a4, 8e0438 <_bss_end+0x3cd528>
  9060fb:	1668d1        	l32r	a6, 8e0440 <_bss_end+0x3cd530>
  9060fe:	282212        	l32i	a8, a2, 72
  906101:	b443      	addi.n	a3, a4, 4
  906103:	04670c        	sub	a7, a6, a4
  906106:	1a68d2        	l32r	a10, 8e0450 <_bss_end+0x3cd540>
  906109:	dc70      	mov.n	a12, a7
  90610b:	db30      	mov.n	a11, a3
  90610d:	0b8000        	callx8	a8
	A_ALLOCRAM_INIT(ALLOCRAM_START, ALLOCRAM_SIZE);
  906110:	c78c      	movi.n	a8, -4
  906112:	78410b        	beq	a4, a8, 906121 <app_start+0x121>
  906115:	da30      	mov.n	a10, a3
  906117:	1b68ba        	l32r	a11, 8e0400 <_bss_end+0x3cd4f0>
  90611a:	764906        	bne	a4, a6, 906124 <app_start+0x124>
  90611d:	600005        	j	906126 <app_start+0x126>
  906120:	001a68        	excw
  906123:	b9db      	addi.n	a11, a13, 9
  906125:	702322        	bltu	a2, a0, 90614b <app_start+0x14b>
  906128:	510b30        	call0	948dec <_iram0_text_end+0x39bbb>
  90612b:	006550        	extui	a5, a0, 22, 1

	if( hostif == HIF_USB ) {
  90612e:	c513      	movi.n	a1, 83
		_indir_tbl.hif._get_max_msg_len = _HIFusb_get_max_msg_len_patch;
  906130:	68d323        	beqi	a13, 3, 906157 <app_start+0x157>
  906133:	267913        	l16si	a6, a7, 38
		_indir_tbl.cmnos.usb._usb_reg_out = usb_reg_out_patch;
  906136:	68d423        	beqi	a13, 4, 90615d <app_start+0x15d>
  906139:	263313        	excw
		_indir_tbl.hif._isr_handler = _HIFusb_isr_handler_patch;
  90613c:	68d523        	beqi	a13, 5, 906163 <app_start+0x163>
  90613f:	267b13        	l32ai	a6, a7, 76
		_indir_tbl.cmnos.usb._usb_set_configuration = bSet_configuration_patch;
  906142:	68d623        	beqi	a13, 6, 906169 <app_start+0x169>
  906145:	262613        	s32i	a6, a2, 76
		_indir_tbl.cmnos.usb._usb_status_in = usb_status_in_patch;
  906148:	68d723        	beqi	a13, 7, 90616f <app_start+0x16f>
  90614b:	263413        	s8i	a6, a3, 19
		_indir_tbl.cmnos.usb._usb_get_descriptor = bGet_descriptor_patch;
  90614e:	68d823        	beqi	a13, 8, 906175 <app_start+0x175>
  906151:	263013        	l8ui	a6, a3, 19
		_indir_tbl.cmnos.usb._usb_standard_cmd = bStandardCommand_patch;
  906154:	68d923        	beqi	a13, 10, 90617b <app_start+0x17b>
  906157:	262713        	excw
		_indir_tbl.usbfifo_api._init = _fw_usbfifo_init;
  90615a:	68da23        	beqi	a13, 12, 906181 <app_start+0x181>
  90615d:	269613        	s32i	a6, a9, 76

#if defined(PROJECT_MAGPIE)
		_indir_tbl.cmnos.usb._usb_power_off = zfTurnOffPower_patch;
  906160:	68db23        	beqi	a13, 16, 906187 <app_start+0x187>
  906163:	262913        	l16si	a6, a2, 38
		_indir_tbl.cmnos.usb._usb_reset_fifo = zfResetUSBFIFO_patch;
  906166:	68dc23        	beqi	a13, 32, 90618d <app_start+0x18d>
  906169:	262a13        	movi	a6, 0x213
		_indir_tbl.hif._start = _HIFusb_start_patch;
  90616c:	68dd23        	beqi	a13, 64, 906193 <app_start+0x193>
  90616f:	267413        	s8i	a6, a7, 19
		_indir_tbl.htc._HTC_MsgRecvHandler = HTCMsgRecvHandler_patch;
  906172:	68de23        	beqi	a13, 128, 906199 <app_start+0x199>
  906175:	268613        	s32i	a6, a8, 76
		_indir_tbl.htc._HTC_ControlSvcProcessMsg = HTCControlSvcProcessMsg_patch;
  906178:	68df23        	beqi	a13, 0x100, 90619f <app_start+0x19f>
  90617b:	268813        	excw

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  90617e:	68e023        	beqi	a14, -1, 9061a5 <app_start+0x1a5>
  906181:	300079        	excw
#endif

		if (!(ioread8_usb(ZM_MAIN_CTRL_OFFSET) & BIT6))
  906184:	3f0258        	excw
			vUSBFIFO_EP6Cfg_FS_patch();
  906187:	05e713        	srai	a7, a5, 30
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90618a:	68e124        	beqi	a14, 1, 9061b2 <app_start+0x1b2>

#ifdef FUSION_USB_ENABLE_TX_STREAM
		// For K2, enable tx stream mode
		A_PRINTF("Enable Tx Stream mode: 0x%x\r\n",
  90618d:	22120c        	l32i	a2, a1, 48
  906190:	02008b        	excw
  906193:	301a68        	excw
  906196:	e2          	.byte 0xe2
  906197:	0b4000        	callx8	a4
			ioread32_usb(ZM_SOC_USB_MODE_CTRL_OFFSET));

		/* Patch for K2 USB STREAM mode */
		/* disable down stream DMA mode */
		io32_rmw_usb(ZM_SOC_USB_MODE_CTRL_OFFSET, BIT6, BIT0);
  90619a:	da30      	mov.n	a10, a3
  90619c:	2c0a01        	movi	a12, 1
  90619f:	c4b0      	movi.n	a11, 64
  9061a1:	5823e7        	call8	90f140 <io32_rmw>
#if SYSTEM_MODULE_HP_EP5
		io32_set_usb(ZM_SOC_USB_MODE_CTRL_OFFSET, BIT8);
  9061a4:	da30      	mov.n	a10, a3
  9061a6:	c0c0      	movi.n	a12, 0
  9061a8:	2b1a00        	movi	a11, 0x100
  9061ab:	5823e5        	call8	90f140 <io32_rmw>
#endif

#if SYSTEM_MODULE_HP_EP6
		io32_set_usb(ZM_SOC_USB_MODE_CTRL_OFFSET, BIT9);
  9061ae:	da30      	mov.n	a10, a3
  9061b0:	2c0a00        	movi	a12, 0
  9061b3:	2b2a00        	movi	a11, 0x200
  9061b6:	5823e2        	call8	90f140 <io32_rmw>
#endif
		/* enable down stream DMA mode */
		io32_set_usb(ZM_SOC_USB_MODE_CTRL_OFFSET, BIT0);
  9061b9:	da30      	mov.n	a10, a3
  9061bb:	c0c0      	movi.n	a12, 0
  9061bd:	c0b1      	movi.n	a11, 1
  9061bf:	5823e0        	call8	90f140 <io32_rmw>
#endif

#ifdef FUSION_USB_ENABLE_RX_STREAM
		/* Patch for K2 USB STREAM mode */
		/* disable upstream DMA mode and enable upstream stream mode */
		io32_clr_usb(ZM_SOC_USB_MODE_CTRL_OFFSET, BIT1 | BIT3);
  9061c2:	da30      	mov.n	a10, a3
  9061c4:	c0ca      	movi.n	a12, 10
  9061c6:	2b0a00        	movi	a11, 0
  9061c9:	5823dd        	call8	90f140 <io32_rmw>

		/* K2, Set maximum IN transfer to 8K */
		io32_rmw_usb(ZM_SOC_USB_MODE_CTRL_OFFSET, 0x20, 0x30);
  9061cc:	da30      	mov.n	a10, a3
  9061ce:	c3c0      	movi.n	a12, 48
  9061d0:	2b0a20        	movi	a11, 32
  9061d3:	5823db        	call8	90f140 <io32_rmw>

		/* enable upstream DMA mode */
		io32_set_usb(ZM_SOC_USB_MODE_CTRL_OFFSET, BIT1);
  9061d6:	da30      	mov.n	a10, a3
  9061d8:	2c0a00        	movi	a12, 0
  9061db:	c0b2      	movi.n	a11, 2
  9061dd:	5823d8        	call8	90f140 <io32_rmw>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  9061e0:	1368e3        	l32r	a3, 8e056c <_bss_end+0x3cd65c>
  9061e3:	240aa0        	movi	a4, 160
  9061e6:	0c0200        	memw
  9061e9:	9430      	s32i.n	a4, a3, 0
  9061eb:	1368e4        	l32r	a3, 8e057c <_bss_end+0x3cd66c>
  9061ee:	c049      	movi.n	a4, 9
  9061f0:	0c0200        	memw
  9061f3:	9430      	s32i.n	a4, a3, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  9061f5:	1368e5        	l32r	a3, 8e058c <_bss_end+0x3cd67c>
	}
#if defined(PROJECT_MAGPIE) && !defined(ROM_VER_1_1)
	else if (hostif == HIF_PCI )
		hif_pci_patch_install(&_indir_tbl.hif);
#endif
	A_PRINTF("USB mode: 0x%x\r\n", ioread32_usb(0x100));
  9061f8:	1a68e6        	l32r	a10, 8e0590 <_bss_end+0x3cd680>
  9061fb:	0c0200        	memw
  9061fe:	8b30      	l32i.n	a11, a3, 0
  906200:	232212        	l32i	a3, a2, 72
  906203:	0b3000        	callx8	a3

	// patch the clock function
	if(1) {
		_indir_tbl.cmnos.clock._clock_init = cmnos_clock_init_patch;
  906206:	1368e7        	l32r	a3, 8e05a4 <_bss_end+0x3cd694>
		_indir_tbl.cmnos.clock._delay_us = cmnos_delay_us_patch;
		_indir_tbl.cmnos.clock._clock_tick = cmnos_tick_patch;
		_indir_tbl.cmnos.clock._milliseconds = cmnos_milliseconds_patch;

		//default clock, setup initial variable, SYSTEM_FREQ=40
		A_CLOCK_INIT(SYSTEM_FREQ);
  906209:	c2a8      	movi.n	a10, 40
#endif
	A_PRINTF("USB mode: 0x%x\r\n", ioread32_usb(0x100));

	// patch the clock function
	if(1) {
		_indir_tbl.cmnos.clock._clock_init = cmnos_clock_init_patch;
  90620b:	232638        	s32i	a3, a2, 224
		_indir_tbl.cmnos.clock._refclk_speed_get = cmnos_refclk_speed_get_patch;
  90620e:	1368e8        	l32r	a3, 8e05b0 <_bss_end+0x3cd6a0>
  906211:	23263d        	s32i	a3, a2, 244
		_indir_tbl.cmnos.clock._delay_us = cmnos_delay_us_patch;
  906214:	1368e9        	l32r	a3, 8e05b8 <_bss_end+0x3cd6a8>
  906217:	23263b        	s32i	a3, a2, 236
		_indir_tbl.cmnos.clock._clock_tick = cmnos_tick_patch;
  90621a:	1368ea        	l32r	a3, 8e05c4 <_bss_end+0x3cd6b4>
  90621d:	232640        	s32i	a3, a2, 0x100
		_indir_tbl.cmnos.clock._milliseconds = cmnos_milliseconds_patch;
  906220:	1368eb        	l32r	a3, 8e05cc <_bss_end+0x3cd6bc>
  906223:	23263e        	s32i	a3, a2, 248

		//default clock, setup initial variable, SYSTEM_FREQ=40
		A_CLOCK_INIT(SYSTEM_FREQ);
  906226:	581240        	call8	90ab28 <cmnos_clock_init_patch>
	}

	Magpie_init();
  906229:	580182        	call8	906834 <Magpie_init>

#if MAGPIE_ENABLE_WLAN == 1
	io32_clr(MAGPIE_REG_RST_RESET_ADDR, BIT10 | BIT8 | BIT7 | BIT6);
  90622c:	1a68ec        	l32r	a10, 8e05dc <_bss_end+0x3cd6cc>
  90622f:	2c5ac0        	movi	a12, 0x5c0
  906232:	2b0a00        	movi	a11, 0
  906235:	5823c2        	call8	90f140 <io32_rmw>
#if defined(PROJECT_MAGPIE)
	io32_set(MAGPIE_REG_AHB_ARB_ADDR, BIT1);
  906238:	1a68ed        	l32r	a10, 8e05ec <_bss_end+0x3cd6dc>
  90623b:	2c0a00        	movi	a12, 0
  90623e:	2b0a02        	movi	a11, 2
  906241:	5823bf        	call8	90f140 <io32_rmw>
#endif

	wlan_pci_module_init();
  906244:	580e06        	call8	909a60 <wlan_pci_module_init>
	wlan_pci_probe();
  906247:	580e28        	call8	909ae8 <wlan_pci_probe>
#endif


	A_PRINTF("Tgt running\n\r");
  90624a:	1a68ee        	l32r	a10, 8e0604 <_bss_end+0x3cd6f4>
  90624d:	232212        	l32i	a3, a2, 72
  906250:	0b3000        	callx8	a3

#if defined(PROJECT_MAGPIE)
	if(1) {
		A_PRINTF("======= Apply MISC Assert patch\n\r");
  906253:	1a68ef        	l32r	a10, 8e0610 <_bss_end+0x3cd700>
  906256:	232212        	l32i	a3, a2, 72
  906259:	0b3000        	callx8	a3
		_assfail_ori =  _indir_tbl.cmnos.misc._assfail;
  90625c:	842a      	l32i.n	a4, a2, 40
  90625e:	1368f0        	l32r	a3, 8e0620 <_bss_end+0x3cd710>
  906261:	243600        	s32i	a4, a3, 0
		_indir_tbl.cmnos.misc._assfail = exception_reset;
  906264:	1368f1        	l32r	a3, 8e0628 <_bss_end+0x3cd718>
  906267:	23260a        	s32i	a3, a2, 40
	}

	change_magpie_clk();
  90626a:	58001e        	call8	9062e4 <change_magpie_clk>
#endif
	wlan_task(); //never return
  90626d:	58013c        	call8	906760 <wlan_task>

Disassembly of section .text:

00906270 <io32_rmw>:
	iowrite8(addr, val);
}

static inline void io32_rmw(volatile uint32_t addr,
			    const uint32_t set, const uint32_t clr)
{
  906270:	6c1006        	entry	a1, 48
  906273:	0c0200        	memw
  906276:	9210      	s32i.n	a2, a1, 0
	uint32_t val;

	val = ioread32(addr);
  906278:	0c0200        	memw
  90627b:	8810      	l32i.n	a8, a1, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90627d:	0c0200        	memw
  906280:	8980      	l32i.n	a9, a8, 0
			    const uint32_t set, const uint32_t clr)
{
	uint32_t val;

	val = ioread32(addr);
	val &= ~clr;
  906282:	c78f      	movi.n	a8, -1
  906284:	048403        	xor	a4, a8, a4
  906287:	094401        	and	a4, a4, a9
	val |= set;
	iowrite32(addr, val);
  90628a:	0c0200        	memw
  90628d:	8810      	l32i.n	a8, a1, 0
{
	uint32_t val;

	val = ioread32(addr);
	val &= ~clr;
	val |= set;
  90628f:	034402        	or	a4, a4, a3
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  906292:	0c0200        	memw
  906295:	9480      	s32i.n	a4, a8, 0
  906297:	d10f      	retw.n
  906299:	000000        	ill

0090629c <fatal_exception_func>:

static void idle_task();

#if defined(PROJECT_MAGPIE)
void fatal_exception_func()
{
  90629c:	6c1004        	entry	a1, 32
	// patch for execption
	(void)_xtos_set_exception_handler(EXCCAUSE_UNALIGNED, AR6002_fatal_exception_handler_patch);
  90629f:	1268f2        	l32r	a2, 8e0668 <_bss_end+0x3cd758>
  9062a2:	c0a9      	movi.n	a10, 9
  9062a4:	022b02        	or	a11, a2, a2
  9062a7:	5b8028        	call8	8e6348 <_xtos_set_exception_handler>
	(void)_xtos_set_exception_handler(EXCCAUSE_LOAD_STORE_ERROR, AR6002_fatal_exception_handler_patch);
  9062aa:	db20      	mov.n	a11, a2
  9062ac:	2a0a03        	movi	a10, 3
  9062af:	5b8026        	call8	8e6348 <_xtos_set_exception_handler>
	(void)_xtos_set_exception_handler(EXCCAUSE_ILLEGAL, AR6002_fatal_exception_handler_patch);
  9062b2:	db20      	mov.n	a11, a2
  9062b4:	2a0a00        	movi	a10, 0
  9062b7:	5b8024        	call8	8e6348 <_xtos_set_exception_handler>
	(void)_xtos_set_exception_handler(EXCCAUSE_INSTR_ERROR, AR6002_fatal_exception_handler_patch);
  9062ba:	db20      	mov.n	a11, a2
  9062bc:	2a0a02        	movi	a10, 2
  9062bf:	5b8022        	call8	8e6348 <_xtos_set_exception_handler>
	(void)_xtos_set_exception_handler(EXCCAUSE_PRIVILEGED, AR6002_fatal_exception_handler_patch);
  9062c2:	db20      	mov.n	a11, a2
  9062c4:	2a0a08        	movi	a10, 8
  9062c7:	5b8020        	call8	8e6348 <_xtos_set_exception_handler>
	(void)_xtos_set_exception_handler(EXCCAUSE_INSTR_DATA_ERROR, AR6002_fatal_exception_handler_patch);
  9062ca:	db20      	mov.n	a11, a2
  9062cc:	2a0a0c        	movi	a10, 12
  9062cf:	5b801e        	call8	8e6348 <_xtos_set_exception_handler>
	(void)_xtos_set_exception_handler(EXCCAUSE_LOAD_STORE_DATA_ERROR, AR6002_fatal_exception_handler_patch);
  9062d2:	db20      	mov.n	a11, a2
  9062d4:	c0ad      	movi.n	a10, 13
  9062d6:	5b801c        	call8	8e6348 <_xtos_set_exception_handler>
	(void)_xtos_set_exception_handler(EXCCAUSE_DIVIDE_BY_ZERO, AR6002_fatal_exception_handler_patch);
  9062d9:	db20      	mov.n	a11, a2
  9062db:	c0a6      	movi.n	a10, 6
  9062dd:	5b801a        	call8	8e6348 <_xtos_set_exception_handler>
  9062e0:	d10f      	retw.n
	...

009062e4 <change_magpie_clk>:
#endif

#if defined(PROJECT_MAGPIE)
void
change_magpie_clk(void)
{
  9062e4:	6c1004        	entry	a1, 32
  9062e7:	1368f3        	l32r	a3, 8e06b4 <_bss_end+0x3cd7a4>
  9062ea:	c121      	movi.n	a2, 17
  9062ec:	0c0200        	memw
  9062ef:	9230      	s32i.n	a2, a3, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  9062f1:	0c0200        	memw
  9062f4:	8230      	l32i.n	a2, a3, 0
	iowrite32(0x00056004, BIT4 | BIT0);

	/* Wait for the update bit (BIT0) to get cleared */
	while (ioread32(0x00056004) & BIT0)
  9062f6:	020240        	extui	a2, a2, 0, 1
  9062f9:	652ff4        	bnez	a2, 9062f1 <change_magpie_clk+0xd>
		;

	/* Put the PLL into reset */
	io32_set(0x00050010, BIT1);
  9062fc:	1468ec        	l32r	a4, 8e06ac <_bss_end+0x3cd79c>
  9062ff:	dc20      	mov.n	a12, a2
  906301:	da40      	mov.n	a10, a4
  906303:	c0b2      	movi.n	a11, 2
  906305:	5bffda        	call8	906270 <io32_rmw>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  906308:	1868f4        	l32r	a8, 8e06d8 <_bss_end+0x3cd7c8>
  90630b:	293a25        	movi	a9, 0x325
	 */
	/* Setting PLL to 400MHz */
	iowrite32(0x00056000, 0x325);

	/* Pull CPU PLL out of Reset */
	io32_clr(0x00050010, BIT1);
  90630e:	db20      	mov.n	a11, a2
  906310:	da40      	mov.n	a10, a4
  906312:	0c0200        	memw
  906315:	9980      	s32i.n	a9, a8, 0
  906317:	2c0a02        	movi	a12, 2
  90631a:	5bffd5        	call8	906270 <io32_rmw>

	A_DELAY_USECS(60); // wait for stable
  90631d:	1268bf        	l32r	a2, 8e061c <_bss_end+0x3cd70c>
  906320:	2a0a3c        	movi	a10, 60
  906323:	24223b        	l32i	a4, a2, 236
  906326:	0b4000        	callx8	a4
  906329:	1468f5        	l32r	a4, 8e0700 <_bss_end+0x3cd7f0>
  90632c:	0c0200        	memw
  90632f:	9430      	s32i.n	a4, a3, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  906331:	1468f3        	l32r	a4, 8e0700 <_bss_end+0x3cd7f0>
  906334:	0c0200        	memw
  906337:	8340      	l32i.n	a3, a4, 0
	/*
	 * AHB clk = ( CPU clk / 2 )
	 */
	iowrite32(0x00056004, 0x00001 | BIT16 | BIT8); /* set plldiv to 2 */

	while (ioread32(0x00056004) & BIT0)
  906339:	7f3ff7        	bbsi	a3, 31, 906334 <change_magpie_clk+0x50>
		;

	/* UART Setting */
	A_UART_HWINIT((100*1000*1000), 115200);
  90633c:	22221a        	l32i	a2, a2, 104
  90633f:	1b68f6        	l32r	a11, 8e0718 <_bss_end+0x3cd808>
  906342:	1a68f7        	l32r	a10, 8e0720 <_bss_end+0x3cd810>
  906345:	0b2000        	callx8	a2
  906348:	d10f      	retw.n
	...

0090634c <exception_reset>:

}

void exception_reset(struct register_dump_s *dump)
{
  90634c:	6c1004        	entry	a1, 32
	A_PRINTF("exception_reset \n");
  90634f:	1368bf        	l32r	a3, 8e064c <_bss_end+0x3cd73c>
  906352:	1a68f8        	l32r	a10, 8e0734 <_bss_end+0x3cd824>
  906355:	243212        	l32i	a4, a3, 72
  906358:	0b4000        	callx8	a4

	/* phase I dump info */
	A_PRINTF("exception reset-phase 1\n");
  90635b:	1a68f9        	l32r	a10, 8e0740 <_bss_end+0x3cd830>
  90635e:	243212        	l32i	a4, a3, 72
  906361:	0b4000        	callx8	a4
	if(_assfail_ori)
  906364:	1468f0        	l32r	a4, 8e0724 <_bss_end+0x3cd814>
  906367:	8440      	l32i.n	a4, a4, 0
  906369:	c844      	beqz.n	a4, 906371 <exception_reset+0x25>
		_assfail_ori(dump);
  90636b:	022a02        	or	a10, a2, a2
  90636e:	0b4000        	callx8	a4

	/* phase II reset */
	A_PRINTF("exception reset-phase 2\n");
  906371:	223212        	l32i	a2, a3, 72
  906374:	1a68fa        	l32r	a10, 8e075c <_bss_end+0x3cd84c>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  906377:	c040      	movi.n	a4, 0
  906379:	0b2000        	callx8	a2
  90637c:	1568c2        	l32r	a5, 8e0684 <_bss_end+0x3cd774>
  90637f:	1268c4        	l32r	a2, 8e0690 <_bss_end+0x3cd780>
	iowrite32(WATCH_DOG_MAGIC_PATTERN_ADDR, WDT_MAGIC_PATTERN);

	io32_set(MAGPIE_REG_RST_RESET_ADDR, BIT10 | BIT8 | BIT7 | BIT6);
  906382:	c0c0      	movi.n	a12, 0
  906384:	0c0200        	memw
  906387:	9250      	s32i.n	a2, a5, 0
  906389:	1268ec        	l32r	a2, 8e073c <_bss_end+0x3cd82c>
  90638c:	2b5ac0        	movi	a11, 0x5c0
  90638f:	da20      	mov.n	a10, a2
  906391:	5bffb7        	call8	906270 <io32_rmw>

	io32_set(MAGPIE_REG_AHB_ARB_ADDR, BIT1);
  906394:	1a68ed        	l32r	a10, 8e0748 <_bss_end+0x3cd838>
  906397:	2c0a00        	movi	a12, 0
  90639a:	2b0a02        	movi	a11, 2
  90639d:	5bffb4        	call8	906270 <io32_rmw>
  9063a0:	1668fb        	l32r	a6, 8e078c <_bss_end+0x3cd87c>

	iowrite32_usb(ZM_SOC_USB_DMA_RESET_OFFSET, 0x0);
	io32_set(0x50010, BIT4);
  9063a3:	dc40      	mov.n	a12, a4
  9063a5:	0c0200        	memw
  9063a8:	9460      	s32i.n	a4, a6, 0
  9063aa:	c1b0      	movi.n	a11, 16
  9063ac:	da20      	mov.n	a10, a2
  9063ae:	5bffb0        	call8	906270 <io32_rmw>
	A_DELAY_USECS(5);
  9063b1:	28323b        	l32i	a8, a3, 236
  9063b4:	c0a5      	movi.n	a10, 5
  9063b6:	0b8000        	callx8	a8
	io32_clr(0x50010, BIT4);
  9063b9:	c1c0      	movi.n	a12, 16
  9063bb:	044b02        	or	a11, a4, a4
  9063be:	022a02        	or	a10, a2, a2
  9063c1:	5bffab        	call8	906270 <io32_rmw>
	A_DELAY_USECS(5);
  9063c4:	22323b        	l32i	a2, a3, 236
  9063c7:	c0a5      	movi.n	a10, 5
  9063c9:	0b2000        	callx8	a2
  9063cc:	c021      	movi.n	a2, 1
  9063ce:	0c0200        	memw
  9063d1:	226600        	s32i	a2, a6, 0
  9063d4:	1668f3        	l32r	a6, 8e07a0 <_bss_end+0x3cd890>
  9063d7:	280a11        	movi	a8, 17
  9063da:	0c0200        	memw
  9063dd:	286600        	s32i	a8, a6, 0
	iowrite32_usb(ZM_SOC_USB_DMA_RESET_OFFSET, BIT0);

	// set clock to bypass mode - 40Mhz from XTAL
	iowrite32(MAGPIE_REG_CPU_PLL_BYPASS_ADDR, BIT0 | BIT4);
	A_DELAY_USECS(100); // wait for stable
  9063e0:	26323b        	l32i	a6, a3, 236
  9063e3:	2a0a64        	movi	a10, 100
  9063e6:	0b6000        	callx8	a6
  9063e9:	1868fc        	l32r	a8, 8e07dc <_bss_end+0x3cd8cc>
  9063ec:	1668f4        	l32r	a6, 8e07bc <_bss_end+0x3cd8ac>
	iowrite32(MAGPIE_REG_CPU_PLL_ADDR, BIT16);

	A_UART_HWINIT((40*1000*1000), 115200);
  9063ef:	1b68f6        	l32r	a11, 8e07c8 <_bss_end+0x3cd8b8>
  9063f2:	0c0200        	memw
  9063f5:	9860      	s32i.n	a8, a6, 0
  9063f7:	1a68be        	l32r	a10, 8e06f0 <_bss_end+0x3cd7e0>
  9063fa:	26321a        	l32i	a6, a3, 104
  9063fd:	0b6000        	callx8	a6

	A_PRINTF("do TX/RX swap\n");
  906400:	1a68fd        	l32r	a10, 8e07f4 <_bss_end+0x3cd8e4>
  906403:	263212        	l32i	a6, a3, 72
  906406:	0b6000        	callx8	a6

	MAGPIE_REG_USB_RX0_SWAP_DATA = 0x1;
  906409:	1668fe        	l32r	a6, 8e0804 <_bss_end+0x3cd8f4>
	MAGPIE_REG_USB_TX0_SWAP_DATA = 0x1;
	MAGPIE_REG_USB_RX1_SWAP_DATA = 0x1;
	MAGPIE_REG_USB_RX2_SWAP_DATA = 0x1;

        A_PRINTF("Cold reboot initiated.");
  90640c:	1a6902        	l32r	a10, 8e0814 <_bss_end+0x3cd904>

	A_UART_HWINIT((40*1000*1000), 115200);

	A_PRINTF("do TX/RX swap\n");

	MAGPIE_REG_USB_RX0_SWAP_DATA = 0x1;
  90640f:	0c0200        	memw
  906412:	9260      	s32i.n	a2, a6, 0
	MAGPIE_REG_USB_TX0_SWAP_DATA = 0x1;
  906414:	1668ff        	l32r	a6, 8e0810 <_bss_end+0x3cd900>
  906417:	0c0200        	memw
  90641a:	226600        	s32i	a2, a6, 0
	MAGPIE_REG_USB_RX1_SWAP_DATA = 0x1;
  90641d:	166900        	l32r	a6, 8e0820 <_bss_end+0x3cd910>
  906420:	0c0200        	memw
  906423:	226600        	s32i	a2, a6, 0
	MAGPIE_REG_USB_RX2_SWAP_DATA = 0x1;
  906426:	166901        	l32r	a6, 8e082c <_bss_end+0x3cd91c>
  906429:	0c0200        	memw
  90642c:	226600        	s32i	a2, a6, 0

        A_PRINTF("Cold reboot initiated.");
  90642f:	223212        	l32i	a2, a3, 72
  906432:	0b2000        	callx8	a2
#if defined(PROJECT_MAGPIE)
	iowrite32(WATCH_DOG_MAGIC_PATTERN_ADDR, 0);
#elif defined(PROJECT_K2)
	iowrite32(MAGPIE_REG_RST_STATUS_ADDR, 0);
#endif /* #if defined(PROJECT_MAGPIE) */
	A_USB_JUMP_BOOT();
  906435:	22322c        	l32i	a2, a3, 176
  906438:	0c0200        	memw
  90643b:	9450      	s32i.n	a4, a5, 0
  90643d:	0b2000        	callx8	a2
  906440:	d10f      	retw.n
	...

00906444 <reset_EP4_FIFO>:
}

void reset_EP4_FIFO(void)
{
  906444:	6c1004        	entry	a1, 32
  906447:	196903        	l32r	a9, 8e0854 <_bss_end+0x3cd944>
{
	uint8_t val;

	val = ioread8(addr);
	val &= ~clr;
	val |= set;
  90644a:	c1a0      	movi.n	a10, 16

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  90644c:	289000        	l8ui	a8, a9, 0
  90644f:	080847        	extui	a8, a8, 0, 8
{
	uint8_t val;

	val = ioread8(addr);
	val &= ~clr;
	val |= set;
  906452:	0a8802        	or	a8, a8, a10
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  906455:	0c0200        	memw
  906458:	289400        	s8i	a8, a9, 0

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  90645b:	289000        	l8ui	a8, a9, 0
			    const uint8_t set, const uint8_t clr)
{
	uint8_t val;

	val = ioread8(addr);
	val &= ~clr;
  90645e:	c6af      	movi.n	a10, -17

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  906460:	080847        	extui	a8, a8, 0, 8
			    const uint8_t set, const uint8_t clr)
{
	uint8_t val;

	val = ioread8(addr);
	val &= ~clr;
  906463:	0a8801        	and	a8, a8, a10
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  906466:	0c0200        	memw
  906469:	289400        	s8i	a8, a9, 0
  90646c:	d10f      	retw.n
	...

00906470 <zfGenExceptionEvent>:
	for(i = 0; i < 100; i++) {}
	io8_clr_usb(ZM_EP4_BYTE_COUNT_HIGH_OFFSET, BIT4);
}

LOCAL void zfGenExceptionEvent(uint32_t exccause, uint32_t pc, uint32_t badvaddr)
{
  906470:	6c1004        	entry	a1, 32
	uint32_t pattern = 0x33221199;

	A_PRINTF("<Exception>Tgt Drv send an event 44332211 to Host Drv\n");
  906473:	1868bf        	l32r	a8, 8e0770 <_bss_end+0x3cd860>
  906476:	1a6904        	l32r	a10, 8e0888 <_bss_end+0x3cd978>
  906479:	288212        	l32i	a8, a8, 72
  90647c:	0b8000        	callx8	a8

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  90647f:	196905        	l32r	a9, 8e0894 <_bss_end+0x3cd984>
	mUSB_STATUS_IN_INT_DISABLE();
  906482:	2a0ac0        	movi	a10, 192
  906485:	289000        	l8ui	a8, a9, 0
  906488:	080847        	extui	a8, a8, 0, 8
  90648b:	0a8802        	or	a8, a8, a10
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  90648e:	0c0200        	memw
  906491:	289400        	s8i	a8, a9, 0
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  906494:	1868e5        	l32r	a8, 8e0828 <_bss_end+0x3cd918>
  906497:	c09f      	movi.n	a9, 15
  906499:	0c0200        	memw
  90649c:	9980      	s32i.n	a9, a8, 0
  90649e:	186906        	l32r	a8, 8e08b8 <_bss_end+0x3cd9a8>
  9064a1:	196907        	l32r	a9, 8e08c0 <_bss_end+0x3cd9b0>
	iowrite32_usb(ZM_EP3_DATA_OFFSET, pattern);
	iowrite32_usb(ZM_EP3_DATA_OFFSET, exccause);
	iowrite32_usb(ZM_EP3_DATA_OFFSET, pc);
	iowrite32_usb(ZM_EP3_DATA_OFFSET, badvaddr);
    
	mUSB_EP3_XFER_DONE();
  9064a4:	c0a8      	movi.n	a10, 8
  9064a6:	0c0200        	memw
  9064a9:	9980      	s32i.n	a9, a8, 0
  9064ab:	0c0200        	memw
  9064ae:	9280      	s32i.n	a2, a8, 0
  9064b0:	0c0200        	memw
  9064b3:	9380      	s32i.n	a3, a8, 0

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  9064b5:	196908        	l32r	a9, 8e08d8 <_bss_end+0x3cd9c8>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  9064b8:	0c0200        	memw
  9064bb:	9480      	s32i.n	a4, a8, 0

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  9064bd:	289000        	l8ui	a8, a9, 0
  9064c0:	080847        	extui	a8, a8, 0, 8
  9064c3:	0a8802        	or	a8, a8, a10
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  9064c6:	0c0200        	memw
  9064c9:	289400        	s8i	a8, a9, 0
  9064cc:	d10f      	retw.n
	...

009064d0 <AR6002_fatal_exception_handler_patch>:
	mUSB_EP3_XFER_DONE();
}

void
AR6002_fatal_exception_handler_patch(CPU_exception_frame_t *exc_frame)
{
  9064d0:	6c1016        	entry	a1, 176
	struct register_dump_s dump;
	uint32_t  exc_cause, exc_vaddr;
	asm volatile("rsr %0,%1" : "=r" (exc_cause) : "n" (EXCCAUSE));
  9064d3:	03e830        	rsr.exccause	a3
	asm volatile("rsr %0,%1" : "=r" (exc_vaddr) : "n" (EXCVADDR));
  9064d6:	04ee30        	rsr.excvaddr	a4

	dump.exc_frame              = *exc_frame; /* structure copy */
  9064d9:	2c0a80        	movi	a12, 128
  9064dc:	022b02        	or	a11, a2, a2
  9064df:	2a1c10        	addi	a10, a1, 16
  9064e2:	5b81a0        	call8	8e6b64 <memcpy>
	dump.badvaddr               = exc_vaddr;
	dump.exc_frame.xt_exccause  = exc_cause;
	dump.pc                     = exc_frame->xt_pc;
  9064e5:	8b20      	l32i.n	a11, a2, 0
	uint32_t  exc_cause, exc_vaddr;
	asm volatile("rsr %0,%1" : "=r" (exc_cause) : "n" (EXCCAUSE));
	asm volatile("rsr %0,%1" : "=r" (exc_vaddr) : "n" (EXCVADDR));

	dump.exc_frame              = *exc_frame; /* structure copy */
	dump.badvaddr               = exc_vaddr;
  9064e7:	dc40      	mov.n	a12, a4
	dump.exc_frame.xt_exccause  = exc_cause;
  9064e9:	da30      	mov.n	a10, a3
	dump.pc                     = exc_frame->xt_pc;
	dump.assline                = 0;
  9064eb:	c020      	movi.n	a2, 0
	asm volatile("rsr %0,%1" : "=r" (exc_cause) : "n" (EXCCAUSE));
	asm volatile("rsr %0,%1" : "=r" (exc_vaddr) : "n" (EXCVADDR));

	dump.exc_frame              = *exc_frame; /* structure copy */
	dump.badvaddr               = exc_vaddr;
	dump.exc_frame.xt_exccause  = exc_cause;
  9064ed:	931c      	s32i.n	a3, a1, 48
	dump.pc                     = exc_frame->xt_pc;
  9064ef:	9b12      	s32i.n	a11, a1, 8
	dump.assline                = 0;
  9064f1:	9211      	s32i.n	a2, a1, 4
	uint32_t  exc_cause, exc_vaddr;
	asm volatile("rsr %0,%1" : "=r" (exc_cause) : "n" (EXCCAUSE));
	asm volatile("rsr %0,%1" : "=r" (exc_vaddr) : "n" (EXCVADDR));

	dump.exc_frame              = *exc_frame; /* structure copy */
	dump.badvaddr               = exc_vaddr;
  9064f3:	9413      	s32i.n	a4, a1, 12
	dump.exc_frame.xt_exccause  = exc_cause;
	dump.pc                     = exc_frame->xt_pc;
	dump.assline                = 0;

	zfGenExceptionEvent(dump.exc_frame.xt_exccause, dump.pc, dump.badvaddr);
  9064f5:	5bffde        	call8	906470 <zfGenExceptionEvent>

#if SYSTEM_MODULE_PRINT
	A_PRINTF("\nFatal exception (%d): \tpc=0x%x \n\r\tbadvaddr=0x%x \n\r\tdump area=0x%x\n",
  9064f8:	1268bf        	l32r	a2, 8e07f4 <_bss_end+0x3cd8e4>
  9064fb:	8d13      	l32i.n	a13, a1, 12
  9064fd:	232212        	l32i	a3, a2, 72
  906500:	8c12      	l32i.n	a12, a1, 8
  906502:	8b1c      	l32i.n	a11, a1, 48
  906504:	1a6909        	l32r	a10, 8e0928 <_bss_end+0x3cda18>
  906507:	de10      	mov.n	a14, a1
  906509:	0b3000        	callx8	a3
		 dump.exc_frame.xt_exccause, dump.pc, dump.badvaddr, &dump);
	PRINT_FAILURE_STATE();
  90650c:	0bb130        	rsr.epc1	a11
  90650f:	0cb230        	rsr.epc2	a12
  906512:	0db330        	rsr.epc3	a13
  906515:	0eb430        	rsr.epc4	a14
  906518:	1a690a        	l32r	a10, 8e0940 <_bss_end+0x3cda30>
  90651b:	232212        	l32i	a3, a2, 72
  90651e:	0b3000        	callx8	a3
  906521:	1368bb        	l32r	a3, 8e0810 <_bss_end+0x3cd900>
  906524:	1a690b        	l32r	a10, 8e0950 <_bss_end+0x3cda40>
  906527:	0c0200        	memw
  90652a:	8b30      	l32i.n	a11, a3, 0
  90652c:	1368c6        	l32r	a3, 8e0844 <_bss_end+0x3cd934>
  90652f:	0c0200        	memw
  906532:	8c30      	l32i.n	a12, a3, 0
  906534:	1368c2        	l32r	a3, 8e083c <_bss_end+0x3cd92c>
  906537:	0c0200        	memw
  90653a:	8d30      	l32i.n	a13, a3, 0
  90653c:	232212        	l32i	a3, a2, 72
  90653f:	0b3000        	callx8	a3
#else
	A_PUTS("Fatal exception\n\r");
#endif
	A_ASSFAIL(&dump);
  906542:	822a      	l32i.n	a2, a2, 40
  906544:	da10      	mov.n	a10, a1
  906546:	0b2000        	callx8	a2
  906549:	63fffc        	j	906549 <AR6002_fatal_exception_handler_patch+0x79>

0090654c <zfGenWrongEpidEvent>:
    
	mUSB_EP3_XFER_DONE();
}

LOCAL void zfGenWrongEpidEvent(uint32_t epid)
{
  90654c:	6c1004        	entry	a1, 32
	uint32_t pattern   = 0x33221299;

	A_PRINTF("<WrongEPID>Tgt Drv send an event 44332212 to Host Drv\n");
  90654f:	1868bf        	l32r	a8, 8e084c <_bss_end+0x3cd93c>
  906552:	1a690c        	l32r	a10, 8e0984 <_bss_end+0x3cda74>
  906555:	288212        	l32i	a8, a8, 72
  906558:	0b8000        	callx8	a8

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  90655b:	196905        	l32r	a9, 8e0970 <_bss_end+0x3cda60>
	mUSB_STATUS_IN_INT_DISABLE();
  90655e:	2a0ac0        	movi	a10, 192
  906561:	289000        	l8ui	a8, a9, 0
  906564:	080847        	extui	a8, a8, 0, 8
  906567:	0a8802        	or	a8, a8, a10
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  90656a:	0c0200        	memw
  90656d:	289400        	s8i	a8, a9, 0
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  906570:	1868e5        	l32r	a8, 8e0904 <_bss_end+0x3cd9f4>
  906573:	c09f      	movi.n	a9, 15
  906575:	0c0200        	memw
  906578:	9980      	s32i.n	a9, a8, 0
  90657a:	186906        	l32r	a8, 8e0994 <_bss_end+0x3cda84>
  90657d:	19690d        	l32r	a9, 8e09b4 <_bss_end+0x3cdaa4>
	iowrite32_usb(ZM_CBUS_FIFO_SIZE_OFFSET, 0x0f);

	iowrite32_usb(ZM_EP3_DATA_OFFSET, pattern);
	iowrite32_usb(ZM_EP3_DATA_OFFSET, epid);

	mUSB_EP3_XFER_DONE();
  906580:	c0a8      	movi.n	a10, 8
  906582:	0c0200        	memw
  906585:	9980      	s32i.n	a9, a8, 0

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  906587:	196908        	l32r	a9, 8e09a8 <_bss_end+0x3cda98>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90658a:	0c0200        	memw
  90658d:	9280      	s32i.n	a2, a8, 0

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  90658f:	289000        	l8ui	a8, a9, 0
  906592:	080847        	extui	a8, a8, 0, 8
  906595:	0a8802        	or	a8, a8, a10
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  906598:	0c0200        	memw
  90659b:	289400        	s8i	a8, a9, 0
  90659e:	d10f      	retw.n

009065a0 <HTCControlSvcProcessMsg_patch>:
}

void 
HTCControlSvcProcessMsg_patch(HTC_ENDPOINT_ID EndpointID, adf_nbuf_t hdr_buf,
			      adf_nbuf_t pBuffers, void *arg)
{
  9065a0:	6c1006        	entry	a1, 48
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  9065a3:	da40      	mov.n	a10, a4
  9065a5:	dc10      	mov.n	a12, a1
  9065a7:	b41b      	addi.n	a11, a1, 4
  9065a9:	5801b7        	call8	906c88 <__adf_nbuf_peek_header>
	/* we assume buffers are aligned such that we can access the message
	 * parameters directly*/
	adf_nbuf_peek_header(pBuffers, &anbdata, &anblen);
	pMsg = (HTC_UNKNOWN_MSG *)anbdata;

	if (pMsg->MessageID == HTC_MSG_SETUP_COMPLETE_ID) {
  9065ac:	8a11      	l32i.n	a10, a1, 4
  9065ae:	28a000        	l8ui	a8, a10, 0
  9065b1:	088911        	slli	a9, a8, 8
  9065b4:	28a001        	l8ui	a8, a10, 1
  9065b7:	098802        	or	a8, a8, a9
  9065ba:	698407        	bnei	a8, 4, 9065c5 <HTCControlSvcProcessMsg_patch+0x25>
		htc_complete_setup = 1;
  9065bd:	18690e        	l32r	a8, 8e09f8 <_bss_end+0x3cdae8>
  9065c0:	c091      	movi.n	a9, 1
  9065c2:	298400        	s8i	a9, a8, 0
	}

	HTCControlSvcProcessMsg(EndpointID, hdr_buf, pBuffers, arg);
  9065c5:	dd50      	mov.n	a13, a5
  9065c7:	dc40      	mov.n	a12, a4
  9065c9:	db30      	mov.n	a11, a3
  9065cb:	da20      	mov.n	a10, a2
  9065cd:	580eae        	call8	90a088 <HTCControlSvcProcessMsg>
  9065d0:	d10f      	retw.n
	...

009065d4 <HTCMsgRecvHandler_patch>:
}

/* Patch callback for check the endpoint ID is correct or not */
void 
HTCMsgRecvHandler_patch(adf_nbuf_t hdr_buf, adf_nbuf_t buffer, void *context)
{
  9065d4:	6c100a        	entry	a1, 80
	a_uint8_t *anbdata;
	a_uint32_t anblen;
	adf_nbuf_t tmp_nbuf;
	HTC_FRAME_HDR *pHTCHdr;
                
	if (hdr_buf == ADF_NBUF_NULL) {
  9065d7:	022502        	or	a5, a2, a2
  9065da:	023538        	moveqz	a5, a3, a2
  9065dd:	2b1c24        	addi	a11, a1, 36
  9065e0:	2c1c20        	addi	a12, a1, 32
  9065e3:	055a02        	or	a10, a5, a5
  9065e6:	5801a8        	call8	906c88 <__adf_nbuf_peek_header>
	} else {
		tmp_nbuf = hdr_buf;
	}
                
	adf_nbuf_peek_header(tmp_nbuf, &anbdata, &anblen);        
	pHTCHdr = (HTC_FRAME_HDR *)anbdata; 
  9065e9:	8619      	l32i.n	a6, a1, 36
  
	eid = pHTCHdr->EndpointID;
  9065eb:	2b6000        	l8ui	a11, a6, 0
    
	if ((eid != 0) && (htc_complete_setup == 0)) {
  9065ee:	64b12a        	beqz	a11, 90671c <HTCMsgRecvHandler_patch+0x148>
  9065f1:	18690e        	l32r	a8, 8e0a2c <_bss_end+0x3cdb1c>
  9065f4:	288000        	l8ui	a8, a8, 0
  9065f7:	658095        	bnez	a8, 906690 <HTCMsgRecvHandler_patch+0xbc>
		A_PRINTF("\nHTC Hdr EndpointID = %d, anblen = %d\n", pHTCHdr->EndpointID, anblen);
  9065fa:	1268bf        	l32r	a2, 8e08f8 <_bss_end+0x3cd9e8>
  9065fd:	8c18      	l32i.n	a12, a1, 32
  9065ff:	232212        	l32i	a3, a2, 72
  906602:	1a690f        	l32r	a10, 8e0a40 <_bss_end+0x3cdb30>
  906605:	0b3000        	callx8	a3
		A_PRINTF("HTC Hder : %2x-%2x-%2x-%2x-%2x-%2x-%2x-%2x-%2x-%2x-%2x-%2x\n",
                         *anbdata, *(anbdata+1), *(anbdata+2), *(anbdata+3), 
  906608:	8819      	l32i.n	a8, a1, 36
  
	eid = pHTCHdr->EndpointID;
    
	if ((eid != 0) && (htc_complete_setup == 0)) {
		A_PRINTF("\nHTC Hdr EndpointID = %d, anblen = %d\n", pHTCHdr->EndpointID, anblen);
		A_PRINTF("HTC Hder : %2x-%2x-%2x-%2x-%2x-%2x-%2x-%2x-%2x-%2x-%2x-%2x\n",
  90660a:	1a6910        	l32r	a10, 8e0a4c <_bss_end+0x3cdb3c>
  90660d:	23800b        	l8ui	a3, a8, 11
  906610:	2b8000        	l8ui	a11, a8, 0
  906613:	2f8004        	l8ui	a15, a8, 4
  906616:	2e8003        	l8ui	a14, a8, 3
  906619:	2d8002        	l8ui	a13, a8, 2
  90661c:	2c8001        	l8ui	a12, a8, 1
  90661f:	9316      	s32i.n	a3, a1, 24
  906621:	23800a        	l8ui	a3, a8, 10
  906624:	9315      	s32i.n	a3, a1, 20
  906626:	238009        	l8ui	a3, a8, 9
  906629:	9314      	s32i.n	a3, a1, 16
  90662b:	238008        	l8ui	a3, a8, 8
  90662e:	9313      	s32i.n	a3, a1, 12
  906630:	238007        	l8ui	a3, a8, 7
  906633:	9312      	s32i.n	a3, a1, 8
  906635:	238006        	l8ui	a3, a8, 6
  906638:	9311      	s32i.n	a3, a1, 4
  90663a:	238005        	l8ui	a3, a8, 5
  90663d:	9310      	s32i.n	a3, a1, 0
  90663f:	232212        	l32i	a3, a2, 72
  906642:	0b3000        	callx8	a3
                         *anbdata, *(anbdata+1), *(anbdata+2), *(anbdata+3), 
                         *(anbdata+4), *(anbdata+5), *(anbdata+6), *(anbdata+7),
                         *(anbdata+8), *(anbdata+9), *(anbdata+10), *(anbdata+11)); 
		A_PRINTF("init_htc_handle = 0x%8x\n", init_htc_handle);
  906645:	146911        	l32r	a4, 8e0a8c <_bss_end+0x3cdb7c>
  906648:	232212        	l32i	a3, a2, 72
  90664b:	2b4200        	l32i	a11, a4, 0
  90664e:	1a6912        	l32r	a10, 8e0a98 <_bss_end+0x3cdb88>
  906651:	0b3000        	callx8	a3
            
		if (pHTCHdr->EndpointID == 1) {
  906654:	236000        	l8ui	a3, a6, 0
  906657:	693112        	bnei	a3, 1, 90666d <HTCMsgRecvHandler_patch+0x99>
			A_PRINTF("Return WMI Command buffer\n");
  90665a:	262212        	l32i	a6, a2, 72
  90665d:	1a6913        	l32r	a10, 8e0aac <_bss_end+0x3cdb9c>
  906660:	0b6000        	callx8	a6
			HTC_ReturnBuffers(init_htc_handle, 1, tmp_nbuf);
  906663:	dc50      	mov.n	a12, a5
  906665:	222282        	l32i	a2, a2, 0x208
  906668:	db30      	mov.n	a11, a3
  90666a:	60001b        	j	906689 <HTCMsgRecvHandler_patch+0xb5>
		} else if ((pHTCHdr->EndpointID == 5) || (pHTCHdr->EndpointID == 6)) {
  90666d:	233cfb        	addi	a3, a3, -5
  906670:	030347        	extui	a3, a3, 0, 8
  906673:	6e3202        	bltui	a3, 2, 906679 <HTCMsgRecvHandler_patch+0xa5>
  906676:	6000ab        	j	906725 <HTCMsgRecvHandler_patch+0x151>
			A_PRINTF("Return Data buffer\n");
  906679:	232212        	l32i	a3, a2, 72
  90667c:	1a6914        	l32r	a10, 8e0acc <_bss_end+0x3cdbbc>
  90667f:	0b3000        	callx8	a3
			HTC_ReturnBuffers(init_htc_handle, 6, tmp_nbuf);
  906682:	222282        	l32i	a2, a2, 0x208
  906685:	dc50      	mov.n	a12, a5
  906687:	c0b6      	movi.n	a11, 6
  906689:	8a40      	l32i.n	a10, a4, 0
  90668b:	0b2000        	callx8	a2
  90668e:	d10f      	retw.n
		} else {
		}
	} else {
		if ((pHTCHdr->EndpointID < 0) || (pHTCHdr->EndpointID >= ENDPOINT_MAX)) {
  906690:	c185      	movi.n	a8, 21
  906692:	7b8302        	bltu	a8, a11, 906698 <HTCMsgRecvHandler_patch+0xc4>
  906695:	600083        	j	90671c <HTCMsgRecvHandler_patch+0x148>
			A_PRINTF("HTC Hdr EndpointID = %d, anblen = %d\n", pHTCHdr->EndpointID, anblen);
  906698:	1268bf        	l32r	a2, 8e0994 <_bss_end+0x3cda84>
  90669b:	8c18      	l32i.n	a12, a1, 32
  90669d:	232212        	l32i	a3, a2, 72
  9066a0:	1a6915        	l32r	a10, 8e0af4 <_bss_end+0x3cdbe4>
  9066a3:	0b3000        	callx8	a3
			A_PRINTF("HTC Hder : %2x-%2x-%2x-%2x-%2x-%2x-%2x-%2x\n", 
                                 *anbdata, *(anbdata+1), *(anbdata+2), *(anbdata+3), 
  9066a6:	8819      	l32i.n	a8, a1, 36
		} else {
		}
	} else {
		if ((pHTCHdr->EndpointID < 0) || (pHTCHdr->EndpointID >= ENDPOINT_MAX)) {
			A_PRINTF("HTC Hdr EndpointID = %d, anblen = %d\n", pHTCHdr->EndpointID, anblen);
			A_PRINTF("HTC Hder : %2x-%2x-%2x-%2x-%2x-%2x-%2x-%2x\n", 
  9066a8:	1a6916        	l32r	a10, 8e0b00 <_bss_end+0x3cdbf0>
  9066ab:	238007        	l8ui	a3, a8, 7
  9066ae:	2f8004        	l8ui	a15, a8, 4
  9066b1:	2e8003        	l8ui	a14, a8, 3
  9066b4:	2d8002        	l8ui	a13, a8, 2
  9066b7:	2c8001        	l8ui	a12, a8, 1
  9066ba:	2b8000        	l8ui	a11, a8, 0
  9066bd:	9312      	s32i.n	a3, a1, 8
  9066bf:	238006        	l8ui	a3, a8, 6
  9066c2:	231601        	s32i	a3, a1, 4
  9066c5:	238005        	l8ui	a3, a8, 5
  9066c8:	231600        	s32i	a3, a1, 0
  9066cb:	232212        	l32i	a3, a2, 72
  9066ce:	0b3000        	callx8	a3
                                 *anbdata, *(anbdata+1), *(anbdata+2), *(anbdata+3), 
                                 *(anbdata+4), *(anbdata+5), *(anbdata+6), *(anbdata+7));

			if (anblen > 64) {
  9066d1:	8818      	l32i.n	a8, a1, 32
  9066d3:	c490      	movi.n	a9, 64
  9066d5:	136911        	l32r	a3, 8e0b1c <_bss_end+0x3cdc0c>
  9066d8:	242212        	l32i	a4, a2, 72
  9066db:	789b1a        	bgeu	a9, a8, 9066f9 <HTCMsgRecvHandler_patch+0x125>
				A_PRINTF("EP1-Tx-Data with Wrong Htc Header Endpoint ID, WAR free this buffer\n");
  9066de:	1a6917        	l32r	a10, 8e0b3c <_bss_end+0x3cdc2c>
  9066e1:	0b4000        	callx8	a4
				HTC_ReturnBuffers(init_htc_handle, 6, tmp_nbuf);
  9066e4:	8a30      	l32i.n	a10, a3, 0
  9066e6:	242282        	l32i	a4, a2, 0x208
  9066e9:	dc50      	mov.n	a12, a5
  9066eb:	c0b6      	movi.n	a11, 6
  9066ed:	0b4000        	callx8	a4
				A_PRINTF("EP1-Tx-Data > Free this buffer successfully\n");
  9066f0:	1a6918        	l32r	a10, 8e0b50 <_bss_end+0x3cdc40>
  9066f3:	222212        	l32i	a2, a2, 72
  9066f6:	60001d        	j	906717 <HTCMsgRecvHandler_patch+0x143>
			} else {
				A_PRINTF("EP4-WMI-Cmd with Wrong Htc Header Endpoint ID, WAR free this buffer\n");
  9066f9:	1a6919        	l32r	a10, 8e0b60 <_bss_end+0x3cdc50>
  9066fc:	0b4000        	callx8	a4
				zfGenWrongEpidEvent((a_uint32_t)pHTCHdr->EndpointID);
  9066ff:	2a6000        	l8ui	a10, a6, 0
  906702:	5bff92        	call8	90654c <zfGenWrongEpidEvent>
				HTC_ReturnBuffers(init_htc_handle, 1, tmp_nbuf);
  906705:	8a30      	l32i.n	a10, a3, 0
  906707:	242282        	l32i	a4, a2, 0x208
  90670a:	dc50      	mov.n	a12, a5
  90670c:	c0b1      	movi.n	a11, 1
  90670e:	0b4000        	callx8	a4
				A_PRINTF("EP4-WMI-Cmd > Free this buffer successfully\n");
  906711:	1a691a        	l32r	a10, 8e0b7c <_bss_end+0x3cdc6c>
  906714:	222212        	l32i	a2, a2, 72
  906717:	0b2000        	callx8	a2
  90671a:	d10f      	retw.n
			}
		} else
			HTCMsgRecvHandler( hdr_buf, buffer, context);
  90671c:	dc40      	mov.n	a12, a4
  90671e:	db30      	mov.n	a11, a3
  906720:	da20      	mov.n	a10, a2
  906722:	580ee2        	call8	90a2ac <HTCMsgRecvHandler>
  906725:	d10f      	retw.n
	...

00906728 <init_mem>:
	}
}
#endif

void init_mem()
{
  906728:	6c1004        	entry	a1, 32
	int i = 0;
	uint32_t *temp = (uint32_t *)ALLOCRAM_START;

	/* clear bss segment */
	for(temp = (uint32_t *)&START_BSS; temp < (uint32_t *)&END_BSS; temp++)
  90672b:	18691b        	l32r	a8, 8e0b98 <_bss_end+0x3cdc88>
  90672e:	19691c        	l32r	a9, 8e0ba0 <_bss_end+0x3cdc90>
		*temp = 0;
  906731:	c0a0      	movi.n	a10, 0
{
	int i = 0;
	uint32_t *temp = (uint32_t *)ALLOCRAM_START;

	/* clear bss segment */
	for(temp = (uint32_t *)&START_BSS; temp < (uint32_t *)&END_BSS; temp++)
  906733:	600003        	j	90673a <init_mem+0x12>
		*temp = 0;
  906736:	9a80      	s32i.n	a10, a8, 0
{
	int i = 0;
	uint32_t *temp = (uint32_t *)ALLOCRAM_START;

	/* clear bss segment */
	for(temp = (uint32_t *)&START_BSS; temp < (uint32_t *)&END_BSS; temp++)
  906738:	b488      	addi.n	a8, a8, 4
  90673a:	7983f8        	bltu	a8, a9, 906736 <init_mem+0xe>
		*temp = 0;

	/* clear heap segment */
	for(i = 0; i < ((ALLOCRAM_SIZE - 4)/4); i++)
  90673d:	1a68d0        	l32r	a10, 8e0a80 <_bss_end+0x3cdb70>
  906740:	19691d        	l32r	a9, 8e0bb4 <_bss_end+0x3cdca4>
  906743:	0a990c        	sub	a9, a9, a10
  906746:	092914        	srli	a9, a9, 2
  906749:	0e9911        	slli	a9, a9, 2
  90674c:	a989      	add.n	a9, a8, a9
		temp[i] = 0;
  90674e:	c0a0      	movi.n	a10, 0
  906750:	600004        	j	906758 <init_mem+0x30>
  906753:	009a80        	excw
  906756:	b488      	addi.n	a8, a8, 4
	/* clear bss segment */
	for(temp = (uint32_t *)&START_BSS; temp < (uint32_t *)&END_BSS; temp++)
		*temp = 0;

	/* clear heap segment */
	for(i = 0; i < ((ALLOCRAM_SIZE - 4)/4); i++)
  906758:	7989f8        	bne	a8, a9, 906754 <init_mem+0x2c>
		temp[i] = 0;
}
  90675b:	d10f      	retw.n
  90675d:	000000        	ill

00906760 <wlan_task>:
	}
	return;
}

void __noreturn wlan_task(void)
{
  906760:	6c1004        	entry	a1, 32
	loop_low=loop_high=0;
  906763:	14691e        	l32r	a4, 8e0bdc <_bss_end+0x3cdccc>
  906766:	13691f        	l32r	a3, 8e0be4 <_bss_end+0x3cdcd4>
  906769:	c020      	movi.n	a2, 0
  90676b:	9240      	s32i.n	a2, a4, 0
  90676d:	9230      	s32i.n	a2, a3, 0

	while(1) {
		/* update wdt timer */
		A_WDT_TASK();
  90676f:	1268bf        	l32r	a2, 8e0a6c <_bss_end+0x3cdb5c>
  906772:	28225c        	l32i	a8, a2, 0x170
  906775:	0b8000        	callx8	a8

		/* UPDATE cticks - to be moved to idle_tsk, put here will be easier to read  */
		A_CLOCK_TICK();
  906778:	282240        	l32i	a8, a2, 0x100
  90677b:	0b8000        	callx8	a8

		HIF_isr_handler(NULL);
  90677e:	28227b        	l32i	a8, a2, 0x1ec
  906781:	c0a0      	movi.n	a10, 0
  906783:	0b8000        	callx8	a8

#if MAGPIE_ENABLE_WLAN == 1
		wlan_pci_isr();
  906786:	580d00        	call8	909b88 <wlan_pci_isr>
#endif

		A_TASKLET_RUN();
  906789:	28226d        	l32i	a8, a2, 0x1b4
  90678c:	0b8000        	callx8	a8
		A_TIMER_RUN();
  90678f:	282245        	l32i	a8, a2, 0x114
  906792:	0b8000        	callx8	a8

		/* Very low priority tasks */
		if ((loop_low & 0x1fff) == 0x7)
  906795:	283200        	l32i	a8, a3, 0
  906798:	08084c        	extui	a8, a8, 0, 13
  90679b:	698705        	bnei	a8, 7, 9067a4 <wlan_task+0x44>
			A_DBG_TASK();
  90679e:	28226f        	l32i	a8, a2, 0x1bc
  9067a1:	0b8000        	callx8	a8
		temp[i] = 0;
}

static void idle_task()
{
	if (loop_low == 0xffffffff) {
  9067a4:	8830      	l32i.n	a8, a3, 0
  9067a6:	69800c        	bnei	a8, -1, 9067b6 <wlan_task+0x56>
		loop_low = 0;
  9067a9:	c080      	movi.n	a8, 0
  9067ab:	9830      	s32i.n	a8, a3, 0
		loop_high++;
  9067ad:	8840      	l32i.n	a8, a4, 0
  9067af:	b188      	addi.n	a8, a8, 1
  9067b1:	9840      	s32i.n	a8, a4, 0
  9067b3:	63ffbb        	j	906772 <wlan_task+0x12>
	} else {
		loop_low++;
  9067b6:	b188      	addi.n	a8, a8, 1
  9067b8:	9830      	s32i.n	a8, a3, 0
  9067ba:	63ffb4        	j	906772 <wlan_task+0x12>
  9067bd:	000000        	ill

009067c0 <htc_setup_comp>:
#define MAGPIE 1

#if MAGPIE==1

void htc_setup_comp(void)
{
  9067c0:	6c1004        	entry	a1, 32
  9067c3:	d10f      	retw.n
  9067c5:	000000        	ill

009067c8 <_wmi_cmd_rsp>:
	}
}

void _wmi_cmd_rsp(void *pContext, WMI_COMMAND_ID cmd_id, A_UINT16 SeqNo,
		  A_UINT8 *buffer, int Length)
{
  9067c8:	6c1006        	entry	a1, 48
	adf_nbuf_t netbuf = ADF_NBUF_NULL;
	A_UINT8 *pData;

	netbuf = WMI_AllocEvent(pContext, WMI_EVT_CLASS_CMD_REPLY, sizeof(WMI_CMD_HDR) + Length);
  9067cb:	1768bf        	l32r	a7, 8e0ac8 <_bss_end+0x3cdbb8>
  9067ce:	b46c      	addi.n	a12, a6, 4
  9067d0:	28728d        	l32i	a8, a7, 0x234
  9067d3:	2b0a01        	movi	a11, 1
  9067d6:	022a02        	or	a10, a2, a2
  9067d9:	0b8000        	callx8	a8
	}
}

void _wmi_cmd_rsp(void *pContext, WMI_COMMAND_ID cmd_id, A_UINT16 SeqNo,
		  A_UINT8 *buffer, int Length)
{
  9067dc:	04044f        	extui	a4, a4, 0, 16
	adf_nbuf_t netbuf = ADF_NBUF_NULL;
	A_UINT8 *pData;

	netbuf = WMI_AllocEvent(pContext, WMI_EVT_CLASS_CMD_REPLY, sizeof(WMI_CMD_HDR) + Length);
  9067df:	d8a0      	mov.n	a8, a10
    
	if (netbuf == ADF_NBUF_NULL) {
  9067e1:	cea5      	bnez.n	a10, 90680a <_wmi_cmd_rsp+0x42>
		adf_os_print("%s: buffer allocation for event_id %x failed!\n", __FUNCTION__, cmd_id);
  9067e3:	126920        	l32r	a2, 8e0c64 <_bss_end+0x3cdd54>
  9067e6:	247212        	l32i	a4, a7, 72
  9067e9:	1a6921        	l32r	a10, 8e0c70 <_bss_end+0x3cdd60>
  9067ec:	033c02        	or	a12, a3, a3
  9067ef:	022b02        	or	a11, a2, a2
  9067f2:	0b4000        	callx8	a4
		adf_os_assert(0);
  9067f5:	1a6922        	l32r	a10, 8e0c80 <_bss_end+0x3cdd70>
  9067f8:	237212        	l32i	a3, a7, 72
  9067fb:	db20      	mov.n	a11, a2
  9067fd:	0b3000        	callx8	a3
  906800:	126923        	l32r	a2, 8e0c8c <_bss_end+0x3cdd7c>
  906803:	0c0200        	memw
  906806:	8220      	l32i.n	a2, a2, 0
  906808:	d10f      	retw.n
		return;
	}

	if (Length != 0 && buffer != NULL) {
  90680a:	c962      	beqz.n	a6, 906820 <_wmi_cmd_rsp+0x58>
  90680c:	c950      	beqz.n	a5, 906820 <_wmi_cmd_rsp+0x58>
 *         put, or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_put_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_put_tail(buf, size);
  90680e:	db60      	mov.n	a11, a6
  906810:	9a10      	s32i.n	a10, a1, 0
  906812:	5800f2        	call8	906bdc <__adf_nbuf_put_tail>
}

/* move a memory buffer */
static inline void 		__adf_os_mem_copy(void *dst, const void *src, adf_os_size_t size)
{
    A_MEMCPY(dst,src,size);    
  906815:	8975      	l32i.n	a9, a7, 20
  906817:	dc60      	mov.n	a12, a6
  906819:	db50      	mov.n	a11, a5
  90681b:	0b9000        	callx8	a9
  90681e:	8810      	l32i.n	a8, a1, 0
		pData = (A_UINT8 *)adf_nbuf_put_tail(netbuf, Length);
		adf_os_mem_copy(pData, buffer, Length);
	}

	WMI_SendEvent(pContext, netbuf, cmd_id, SeqNo, Length);
  906820:	25728e        	l32i	a5, a7, 0x238
  906823:	de60      	mov.n	a14, a6
  906825:	dd40      	mov.n	a13, a4
  906827:	030c4f        	extui	a12, a3, 0, 16
  90682a:	db80      	mov.n	a11, a8
  90682c:	da20      	mov.n	a10, a2
  90682e:	0b5000        	callx8	a5
  906831:	d10f      	retw.n
	...

00906834 <Magpie_init>:
}


void Magpie_init(void)
{
  906834:	6c1004        	entry	a1, 32
	A_PRINTF("[+++Magpie_init]\n\r");
  906837:	1268bf        	l32r	a2, 8e0b34 <_bss_end+0x3cdc24>
  90683a:	1a6924        	l32r	a10, 8e0ccc <_bss_end+0x3cddbc>
  90683d:	232212        	l32i	a3, a2, 72
  906840:	0b3000        	callx8	a3
 
	A_PRINTF("[+++VBUF_init(%d)]\n\r", MAX_BUF_NUM);
  906843:	136925        	l32r	a3, 8e0cd8 <_bss_end+0x3cddc8>
  906846:	282212        	l32i	a8, a2, 72
  906849:	2b0a64        	movi	a11, 100
  90684c:	da30      	mov.n	a10, a3
  90684e:	0b8000        	callx8	a8
	VBUF_init(MAX_BUF_NUM);
  906851:	2822a0        	l32i	a8, a2, 0x280
  906854:	2a0a64        	movi	a10, 100
  906857:	0b8000        	callx8	a8
    
	A_PRINTF("[+++VBUF_init(%d)]\n\r", MAX_DESC_NUM);
  90685a:	282212        	l32i	a8, a2, 72
  90685d:	2b0a64        	movi	a11, 100
  906860:	da30      	mov.n	a10, a3
  906862:	0b8000        	callx8	a8
	VDESC_init(MAX_DESC_NUM);
  906865:	2222a5        	l32i	a2, a2, 0x294
  906868:	2a0a64        	movi	a10, 100
  90686b:	0b2000        	callx8	a2
  90686e:	d10f      	retw.n

00906870 <__adf_nbuf_alloc>:
 * @return newly allocated nbuf
 */
__adf_nbuf_t 
__adf_nbuf_alloc(adf_os_size_t size, a_uint32_t reserve, 
                 a_uint32_t align)
{
  906870:	6c1004        	entry	a1, 32
    VBUF *buf = NULL;
    VDESC *desc;
    
    buf = VBUF_alloc_vbuf();
  906873:	1568bf        	l32r	a5, 8e0b70 <_bss_end+0x3cdc60>
 * @return newly allocated nbuf
 */
__adf_nbuf_t 
__adf_nbuf_alloc(adf_os_size_t size, a_uint32_t reserve, 
                 a_uint32_t align)
{
  906876:	d620      	mov.n	a6, a2
    VBUF *buf = NULL;
    VDESC *desc;
    
    buf = VBUF_alloc_vbuf();
  906878:	2a52a1        	l32i	a10, a5, 0x284
  90687b:	0ba000        	callx8	a10
  90687e:	d2a0      	mov.n	a2, a10
    if ( buf != NULL ) {
  906880:	64a028        	beqz	a10, 9068ac <__adf_nbuf_alloc+0x3c>
        desc = VDESC_alloc_vdesc();
  906883:	2a52a6        	l32i	a10, a5, 0x298
  906886:	0ba000        	callx8	a10
        desc->buf_addr = (A_UINT8 *)A_ALLOCRAM(size);
  906889:	255252        	l32i	a5, a5, 0x148
    VBUF *buf = NULL;
    VDESC *desc;
    
    buf = VBUF_alloc_vbuf();
    if ( buf != NULL ) {
        desc = VDESC_alloc_vdesc();
  90688c:	d4a0      	mov.n	a4, a10
        desc->buf_addr = (A_UINT8 *)A_ALLOCRAM(size);
  90688e:	db60      	mov.n	a11, a6
  906890:	c0a0      	movi.n	a10, 0
  906892:	0b5000        	callx8	a5
        desc->buf_size = size;
        desc->next_desc = NULL;
  906895:	c080      	movi.n	a8, 0
    VDESC *desc;
    
    buf = VBUF_alloc_vbuf();
    if ( buf != NULL ) {
        desc = VDESC_alloc_vdesc();
        desc->buf_addr = (A_UINT8 *)A_ALLOCRAM(size);
  906897:	9a41      	s32i.n	a10, a4, 4
        desc->buf_size = size;
  906899:	264504        	s16i	a6, a4, 8
        desc->next_desc = NULL;
  90689c:	9840      	s32i.n	a8, a4, 0
        desc->data_offset = reserve;
  90689e:	234505        	s16i	a3, a4, 10
        desc->data_size = 0;
  9068a1:	284506        	s16i	a8, a4, 12
        desc->control = 0;    
  9068a4:	284507        	s16i	a8, a4, 14
        
        buf->desc_list = desc;
  9068a7:	9420      	s32i.n	a4, a2, 0
        buf->buf_length = 0;    
  9068a9:	282504        	s16i	a8, a2, 8
    }
    
    return buf;
}   
  9068ac:	d10f      	retw.n
	...

009068b0 <__adf_nbuf_free>:
 * @param hdl
 * @param adf_nbuf
 * 
 */
void __adf_nbuf_free(__adf_nbuf_t  buf)
{
  9068b0:	6c1004        	entry	a1, 32
    adf_os_assert(0);
  9068b3:	1868bf        	l32r	a8, 8e0bb0 <_bss_end+0x3cdca0>
  9068b6:	1b6926        	l32r	a11, 8e0d50 <_bss_end+0x3cde40>
  9068b9:	288212        	l32i	a8, a8, 72
  9068bc:	1a6927        	l32r	a10, 8e0d58 <_bss_end+0x3cde48>
  9068bf:	0b8000        	callx8	a8
  9068c2:	186923        	l32r	a8, 8e0d50 <_bss_end+0x3cde40>
  9068c5:	0c0200        	memw
  9068c8:	8880      	l32i.n	a8, a8, 0
  9068ca:	d10f      	retw.n

009068cc <__adf_nbuf_realloc_headroom>:
 * 
 * @return new nbuf
 */
__adf_nbuf_t 
__adf_nbuf_realloc_headroom(__adf_nbuf_t buf, a_uint32_t headroom)
{
  9068cc:	6c1004        	entry	a1, 32
    adf_os_assert(0);
  9068cf:	1868bf        	l32r	a8, 8e0bcc <_bss_end+0x3cdcbc>
  9068d2:	1b6928        	l32r	a11, 8e0d74 <_bss_end+0x3cde64>
  9068d5:	288212        	l32i	a8, a8, 72
  9068d8:	1a6927        	l32r	a10, 8e0d74 <_bss_end+0x3cde64>
    return NULL;
}
  9068db:	c020      	movi.n	a2, 0
 * @return new nbuf
 */
__adf_nbuf_t 
__adf_nbuf_realloc_headroom(__adf_nbuf_t buf, a_uint32_t headroom)
{
    adf_os_assert(0);
  9068dd:	0b8000        	callx8	a8
  9068e0:	186923        	l32r	a8, 8e0d6c <_bss_end+0x3cde5c>
  9068e3:	0c0200        	memw
  9068e6:	8880      	l32i.n	a8, a8, 0
    return NULL;
}
  9068e8:	d10f      	retw.n
	...

009068ec <__adf_nbuf_realloc_tailroom>:
 * 
 * @return struct mbuf * (buffer with the new tailroom)
 */
__adf_nbuf_t 
__adf_nbuf_realloc_tailroom(__adf_nbuf_t  buf, a_uint32_t tailroom)
{
  9068ec:	6c1004        	entry	a1, 32
    adf_os_assert(0);
  9068ef:	1868bf        	l32r	a8, 8e0bec <_bss_end+0x3cdcdc>
  9068f2:	1b6929        	l32r	a11, 8e0d98 <_bss_end+0x3cde88>
  9068f5:	288212        	l32i	a8, a8, 72
  9068f8:	1a6927        	l32r	a10, 8e0d94 <_bss_end+0x3cde84>
    return NULL;
}
  9068fb:	c020      	movi.n	a2, 0
 * @return struct mbuf * (buffer with the new tailroom)
 */
__adf_nbuf_t 
__adf_nbuf_realloc_tailroom(__adf_nbuf_t  buf, a_uint32_t tailroom)
{
    adf_os_assert(0);
  9068fd:	0b8000        	callx8	a8
  906900:	186923        	l32r	a8, 8e0d8c <_bss_end+0x3cde7c>
  906903:	0c0200        	memw
  906906:	8880      	l32i.n	a8, a8, 0
    return NULL;
}
  906908:	d10f      	retw.n
	...

0090690c <__adf_nbuf_expand>:
 * 
 * @return struct mbuf* (NULL if something goofed up)
 */
__adf_nbuf_t 
__adf_nbuf_expand(__adf_nbuf_t buf, a_uint32_t headroom, a_uint32_t tailroom)
{
  90690c:	6c1004        	entry	a1, 32
    adf_os_assert(0);
  90690f:	1868bf        	l32r	a8, 8e0c0c <_bss_end+0x3cdcfc>
  906912:	1b692a        	l32r	a11, 8e0dbc <_bss_end+0x3cdeac>
  906915:	288212        	l32i	a8, a8, 72
  906918:	1a6927        	l32r	a10, 8e0db4 <_bss_end+0x3cdea4>
    return NULL;
}
  90691b:	c020      	movi.n	a2, 0
 * @return struct mbuf* (NULL if something goofed up)
 */
__adf_nbuf_t 
__adf_nbuf_expand(__adf_nbuf_t buf, a_uint32_t headroom, a_uint32_t tailroom)
{
    adf_os_assert(0);
  90691d:	0b8000        	callx8	a8
  906920:	186923        	l32r	a8, 8e0dac <_bss_end+0x3cde9c>
  906923:	0c0200        	memw
  906926:	8880      	l32i.n	a8, a8, 0
    return NULL;
}
  906928:	d10f      	retw.n
	...

0090692c <__adf_nbuf_push_head>:
 * @return new data pointer ,NULL if the len is more than the
 *         space available in the head frag.
 */
a_uint8_t *       
__adf_nbuf_push_head(__adf_nbuf_t buf, adf_os_size_t len)
{
  90692c:	6c1004        	entry	a1, 32
    a_uint8_t *ptr = NULL; 
    VDESC *desc = buf->desc_list;
  90692f:	8920      	l32i.n	a9, a2, 0
    
    desc->data_offset -= len;
  906931:	03034f        	extui	a3, a3, 0, 16
    desc->data_size += len;
  906934:	2a9106        	l16ui	a10, a9, 12
__adf_nbuf_push_head(__adf_nbuf_t buf, adf_os_size_t len)
{
    a_uint8_t *ptr = NULL; 
    VDESC *desc = buf->desc_list;
    
    desc->data_offset -= len;
  906937:	289105        	l16ui	a8, a9, 10
    desc->data_size += len;
  90693a:	aa3a      	add.n	a10, a3, a10
  90693c:	2a9506        	s16i	a10, a9, 12
__adf_nbuf_push_head(__adf_nbuf_t buf, adf_os_size_t len)
{
    a_uint8_t *ptr = NULL; 
    VDESC *desc = buf->desc_list;
    
    desc->data_offset -= len;
  90693f:	03880c        	sub	a8, a8, a3
    desc->data_size += len;
    buf->buf_length += len;
  906942:	2a2104        	l16ui	a10, a2, 8
__adf_nbuf_push_head(__adf_nbuf_t buf, adf_os_size_t len)
{
    a_uint8_t *ptr = NULL; 
    VDESC *desc = buf->desc_list;
    
    desc->data_offset -= len;
  906945:	08084f        	extui	a8, a8, 0, 16
  906948:	289505        	s16i	a8, a9, 10
    desc->data_size += len;
    buf->buf_length += len;
  90694b:	aa33      	add.n	a3, a3, a10
  90694d:	232504        	s16i	a3, a2, 8
    ptr = desc->buf_addr + desc->data_offset;
  906950:	8291      	l32i.n	a2, a9, 4
    return(ptr);
}
  906952:	a822      	add.n	a2, a2, a8
  906954:	d10f      	retw.n
	...

00906958 <__adf_nbuf_pull_head>:
 * 
 * @return new data pointer
 */
a_uint8_t * 
__adf_nbuf_pull_head(__adf_nbuf_t buf, adf_os_size_t len)
{
  906958:	6c1004        	entry	a1, 32
    a_uint8_t *ptr = NULL;
    VDESC *desc = buf->desc_list;
  90695b:	8920      	l32i.n	a9, a2, 0
    
    desc->data_offset += len;
  90695d:	030a4f        	extui	a10, a3, 0, 16
    desc->data_size -= len;
  906960:	239106        	l16ui	a3, a9, 12
__adf_nbuf_pull_head(__adf_nbuf_t buf, adf_os_size_t len)
{
    a_uint8_t *ptr = NULL;
    VDESC *desc = buf->desc_list;
    
    desc->data_offset += len;
  906963:	289105        	l16ui	a8, a9, 10
    desc->data_size -= len;
  906966:	0a330c        	sub	a3, a3, a10
  906969:	239506        	s16i	a3, a9, 12
__adf_nbuf_pull_head(__adf_nbuf_t buf, adf_os_size_t len)
{
    a_uint8_t *ptr = NULL;
    VDESC *desc = buf->desc_list;
    
    desc->data_offset += len;
  90696c:	a8a8      	add.n	a8, a10, a8
    desc->data_size -= len;
    buf->buf_length -= len;
  90696e:	232104        	l16ui	a3, a2, 8
__adf_nbuf_pull_head(__adf_nbuf_t buf, adf_os_size_t len)
{
    a_uint8_t *ptr = NULL;
    VDESC *desc = buf->desc_list;
    
    desc->data_offset += len;
  906971:	08084f        	extui	a8, a8, 0, 16
  906974:	289505        	s16i	a8, a9, 10
    desc->data_size -= len;
    buf->buf_length -= len;
  906977:	0a330c        	sub	a3, a3, a10
  90697a:	232504        	s16i	a3, a2, 8
    ptr = desc->buf_addr + desc->data_offset;
  90697d:	8291      	l32i.n	a2, a9, 4
    
    return ptr;
}
  90697f:	a822      	add.n	a2, a2, a8
  906981:	d10f      	retw.n
	...

00906984 <__adf_nbuf_copy>:
 * 
 * @return struct mbuf * (newly allocated buffer)
 */
__adf_nbuf_t 
__adf_nbuf_copy(__adf_nbuf_t src)
{
  906984:	6c1004        	entry	a1, 32
    __adf_nbuf_t buf = NULL; 

    adf_os_assert(src != NULL);
  906987:	cd25      	bnez.n	a2, 9069a0 <__adf_nbuf_copy+0x1c>
  906989:	1868bf        	l32r	a8, 8e0c88 <_bss_end+0x3cdd78>
  90698c:	1b692b        	l32r	a11, 8e0e38 <_bss_end+0x3cdf28>
  90698f:	288212        	l32i	a8, a8, 72
  906992:	1a6927        	l32r	a10, 8e0e30 <_bss_end+0x3cdf20>
  906995:	0b8000        	callx8	a8
  906998:	186923        	l32r	a8, 8e0e24 <_bss_end+0x3cdf14>
  90699b:	0c0200        	memw
  90699e:	8880      	l32i.n	a8, a8, 0
    
    return buf;
}
  9069a0:	c020      	movi.n	a2, 0
  9069a2:	d10f      	retw.n

009069a4 <__adf_nbuf_unshare>:
 * 
 * @return new nbuf
 */
__adf_nbuf_t 
__adf_nbuf_unshare(__adf_nbuf_t  src)
{
  9069a4:	6c1004        	entry	a1, 32
    __adf_nbuf_t buf = NULL;

    adf_os_assert(src != NULL);
  9069a7:	cd25      	bnez.n	a2, 9069c0 <__adf_nbuf_unshare+0x1c>
  9069a9:	1868bf        	l32r	a8, 8e0ca8 <_bss_end+0x3cdd98>
  9069ac:	1b692c        	l32r	a11, 8e0e5c <_bss_end+0x3cdf4c>
  9069af:	288212        	l32i	a8, a8, 72
  9069b2:	1a6927        	l32r	a10, 8e0e50 <_bss_end+0x3cdf40>
  9069b5:	0b8000        	callx8	a8
  9069b8:	186923        	l32r	a8, 8e0e44 <_bss_end+0x3cdf34>
  9069bb:	0c0200        	memw
  9069be:	8880      	l32i.n	a8, a8, 0

    return buf;
}
  9069c0:	c020      	movi.n	a2, 0
  9069c2:	d10f      	retw.n

009069c4 <__adf_nbuf_frag_info>:
 * @param[out] sg (scatter/gather list of all the frags)
 * 
 */
void  
__adf_nbuf_frag_info(__adf_nbuf_t buf, adf_os_sglist_t	*sg)
{
  9069c4:	6c1004        	entry	a1, 32
    VDESC *desc = buf->desc_list;
  9069c7:	8820      	l32i.n	a8, a2, 0
  9069c9:	b439      	addi.n	a9, a3, 4
    int count = 0;
  9069cb:	c0a0      	movi.n	a10, 0
    
    while( desc != NULL ) {
  9069cd:	600013        	j	9069e4 <__adf_nbuf_frag_info+0x20>
        sg->sg_segs[count].vaddr = desc->buf_addr + desc->data_offset;
  9069d0:	2c8105        	l16ui	a12, a8, 10
  9069d3:	8b81      	l32i.n	a11, a8, 4
        sg->sg_segs[count].len   = desc->data_size;
        
        count++;        
  9069d5:	b1aa      	addi.n	a10, a10, 1
{
    VDESC *desc = buf->desc_list;
    int count = 0;
    
    while( desc != NULL ) {
        sg->sg_segs[count].vaddr = desc->buf_addr + desc->data_offset;
  9069d7:	acbb      	add.n	a11, a11, a12
  9069d9:	9b90      	s32i.n	a11, a9, 0
        sg->sg_segs[count].len   = desc->data_size;
  9069db:	2b8106        	l16ui	a11, a8, 12
        
        count++;        
        desc = desc->next_desc;
  9069de:	8880      	l32i.n	a8, a8, 0
    VDESC *desc = buf->desc_list;
    int count = 0;
    
    while( desc != NULL ) {
        sg->sg_segs[count].vaddr = desc->buf_addr + desc->data_offset;
        sg->sg_segs[count].len   = desc->data_size;
  9069e0:	9b91      	s32i.n	a11, a9, 4
  9069e2:	b899      	addi.n	a9, a9, 8
__adf_nbuf_frag_info(__adf_nbuf_t buf, adf_os_sglist_t	*sg)
{
    VDESC *desc = buf->desc_list;
    int count = 0;
    
    while( desc != NULL ) {
  9069e4:	658fe8        	bnez	a8, 9069d0 <__adf_nbuf_frag_info+0xc>
        
        count++;        
        desc = desc->next_desc;
    }
    
    sg->nsegs = count;
  9069e7:	9a30      	s32i.n	a10, a3, 0
  9069e9:	d10f      	retw.n
	...

009069ec <__adf_nbuf_get_priv>:
 * 
 * @return uint8_t* ( pointer to the data )
 */
a_uint8_t *
__adf_nbuf_get_priv(__adf_nbuf_t buf)
{
  9069ec:	6c1004        	entry	a1, 32
    adf_os_assert(buf != NULL);
  9069ef:	cd25      	bnez.n	a2, 906a08 <__adf_nbuf_get_priv+0x1c>
  9069f1:	1868bf        	l32r	a8, 8e0cf0 <_bss_end+0x3cdde0>
  9069f4:	1b692d        	l32r	a11, 8e0ea8 <_bss_end+0x3cdf98>
  9069f7:	288212        	l32i	a8, a8, 72
  9069fa:	1a6927        	l32r	a10, 8e0e98 <_bss_end+0x3cdf88>
  9069fd:	0b8000        	callx8	a8
  906a00:	186923        	l32r	a8, 8e0e8c <_bss_end+0x3cdf7c>
  906a03:	0c0200        	memw
  906a06:	8880      	l32i.n	a8, a8, 0

    return buf->ctx;
}
  906a08:	bc22      	addi.n	a2, a2, 12
  906a0a:	d10f      	retw.n

00906a0c <__adf_nbuf_queue_add>:
 * 
 */
void 
__adf_nbuf_queue_add(__adf_nbuf_qhead_t  *qhead, 
                     __adf_nbuf_t  buf)
{
  906a0c:	6c1004        	entry	a1, 32
    qhead->qlen++;
  906a0f:	8822      	l32i.n	a8, a2, 8
  906a11:	b188      	addi.n	a8, a8, 1
  906a13:	9822      	s32i.n	a8, a2, 8

    buf->next_buf = NULL;
  906a15:	c080      	movi.n	a8, 0
  906a17:	9831      	s32i.n	a8, a3, 4

    if (qhead->head == NULL) {
  906a19:	8820      	l32i.n	a8, a2, 0
  906a1b:	cc83      	bnez.n	a8, 906a22 <__adf_nbuf_queue_add+0x16>
        qhead->head = buf;
  906a1d:	9320      	s32i.n	a3, a2, 0
  906a1f:	600003        	j	906a26 <__adf_nbuf_queue_add+0x1a>
    }
    else {
        qhead->tail->next_buf = buf;
  906a22:	8821      	l32i.n	a8, a2, 4
  906a24:	9381      	s32i.n	a3, a8, 4
    }
    qhead->tail = buf;
  906a26:	9321      	s32i.n	a3, a2, 4
  906a28:	d10f      	retw.n
	...

00906a2c <__adf_nbuf_queue_remove>:
 * 
 * @return the nbuf
 */
__adf_nbuf_t   
__adf_nbuf_queue_remove(__adf_nbuf_qhead_t *qhead)
{
  906a2c:	6c1004        	entry	a1, 32
  906a2f:	d820      	mov.n	a8, a2
    __adf_nbuf_t  b0 = NULL;

    if (qhead->head) {
  906a31:	8220      	l32i.n	a2, a2, 0
  906a33:	c929      	beqz.n	a2, 906a50 <__adf_nbuf_queue_remove+0x24>
        qhead->qlen--;
  906a35:	8982      	l32i.n	a9, a8, 8
        b0 = qhead->head;
        if ( qhead->head == qhead->tail ) {
  906a37:	8a81      	l32i.n	a10, a8, 4
__adf_nbuf_queue_remove(__adf_nbuf_qhead_t *qhead)
{
    __adf_nbuf_t  b0 = NULL;

    if (qhead->head) {
        qhead->qlen--;
  906a39:	b099      	addi.n	a9, a9, -1
  906a3b:	9982      	s32i.n	a9, a8, 8
  906a3d:	c090      	movi.n	a9, 0
        b0 = qhead->head;
        if ( qhead->head == qhead->tail ) {
  906a3f:	7a2907        	bne	a2, a10, 906a4a <__adf_nbuf_queue_remove+0x1e>
            qhead->head = NULL;
  906a42:	9980      	s32i.n	a9, a8, 0
            qhead->tail = NULL;
  906a44:	9981      	s32i.n	a9, a8, 4
  906a46:	600004        	j	906a4e <__adf_nbuf_queue_remove+0x22>
  906a49:	008a21        	excw
        } else {
            qhead->head = qhead->head->next_buf;
  906a4c:	9a80      	s32i.n	a10, a8, 0
        }
    
        b0->next_buf = NULL;
  906a4e:	9921      	s32i.n	a9, a2, 4
    }
	return b0;
}
  906a50:	d10f      	retw.n
	...

00906a54 <__adf_nbuf_dmamap_create>:
 * 
 * @return a_status_t
 */
a_status_t 
__adf_nbuf_dmamap_create(__adf_os_device_t osdev, __adf_os_dma_map_t *dmap)
{
  906a54:	6c1004        	entry	a1, 32
    a_status_t retval = A_STATUS_OK;
    
    (*dmap) = A_ALLOCRAM(sizeof(struct __adf_dma_map));
  906a57:	1268bf        	l32r	a2, 8e0d54 <_bss_end+0x3cde44>
  906a5a:	c0bc      	movi.n	a11, 12
  906a5c:	222252        	l32i	a2, a2, 0x148
  906a5f:	c0a0      	movi.n	a10, 0
  906a61:	0b2000        	callx8	a2
  906a64:	9a30      	s32i.n	a10, a3, 0
    if(*dmap == NULL)
        return A_STATUS_ENOMEM;
  906a66:	c023      	movi.n	a2, 3
__adf_nbuf_dmamap_create(__adf_os_device_t osdev, __adf_os_dma_map_t *dmap)
{
    a_status_t retval = A_STATUS_OK;
    
    (*dmap) = A_ALLOCRAM(sizeof(struct __adf_dma_map));
    if(*dmap == NULL)
  906a68:	c8a2      	beqz.n	a10, 906a6e <__adf_nbuf_dmamap_create+0x1a>
        return A_STATUS_ENOMEM;
            
    (*dmap)->buf = NULL;
  906a6a:	c020      	movi.n	a2, 0
  906a6c:	92a0      	s32i.n	a2, a10, 0
    return retval;
}
  906a6e:	d10f      	retw.n

00906a70 <__adf_nbuf_map>:


a_status_t 
__adf_nbuf_map(__adf_os_device_t osdev, __adf_os_dma_map_t bmap, 
                          __adf_nbuf_t buf, adf_os_dma_dir_t dir)
{   
  906a70:	6c1004        	entry	a1, 32
    bmap->buf = buf;
  906a73:	9430      	s32i.n	a4, a3, 0
    
    return A_STATUS_OK;
}
  906a75:	c020      	movi.n	a2, 0
  906a77:	d10f      	retw.n
  906a79:	000000        	ill

00906a7c <__adf_nbuf_unmap>:

void 
__adf_nbuf_unmap(__adf_os_device_t osdev, __adf_os_dma_map_t bmap, 
                            adf_os_dma_dir_t dir)
{
  906a7c:	6c1004        	entry	a1, 32
    bmap->buf = NULL;
  906a7f:	c080      	movi.n	a8, 0
  906a81:	9830      	s32i.n	a8, a3, 0
  906a83:	d10f      	retw.n
  906a85:	000000        	ill

00906a88 <__adf_nbuf_dmamap_destroy>:
  906a88:	6c1004        	entry	a1, 32
  906a8b:	d10f      	retw.n
  906a8d:	000000        	ill

00906a90 <__adf_nbuf_dmamap_info>:
 * @param[in]  bmap
 * @param[out] sg (map_info ptr)
 */
void 
__adf_nbuf_dmamap_info(__adf_os_dma_map_t bmap, adf_os_dmamap_info_t *sg)
{
  906a90:	6c1004        	entry	a1, 32
    VDESC *desc = bmap->buf->desc_list;
  906a93:	8820      	l32i.n	a8, a2, 0
  906a95:	b439      	addi.n	a9, a3, 4
  906a97:	8880      	l32i.n	a8, a8, 0
    int count = 0;
  906a99:	c0a0      	movi.n	a10, 0
    
    while( desc != NULL ) {
  906a9b:	600015        	j	906ab4 <__adf_nbuf_dmamap_info+0x24>
  906a9e:	00002c        	excw
        sg->dma_segs[count].paddr = (adf_os_dma_addr_t)(desc->buf_addr + desc->data_offset);
  906aa1:	8105      	l32i.n	a1, a0, 20
  906aa3:	8b81      	l32i.n	a11, a8, 4
        sg->dma_segs[count].len   = desc->data_size;
        
        count++;        
  906aa5:	b1aa      	addi.n	a10, a10, 1
{
    VDESC *desc = bmap->buf->desc_list;
    int count = 0;
    
    while( desc != NULL ) {
        sg->dma_segs[count].paddr = (adf_os_dma_addr_t)(desc->buf_addr + desc->data_offset);
  906aa7:	acbb      	add.n	a11, a11, a12
  906aa9:	9b90      	s32i.n	a11, a9, 0
        sg->dma_segs[count].len   = desc->data_size;
  906aab:	2b8106        	l16ui	a11, a8, 12
        
        count++;        
        desc = desc->next_desc;
  906aae:	8880      	l32i.n	a8, a8, 0
    VDESC *desc = bmap->buf->desc_list;
    int count = 0;
    
    while( desc != NULL ) {
        sg->dma_segs[count].paddr = (adf_os_dma_addr_t)(desc->buf_addr + desc->data_offset);
        sg->dma_segs[count].len   = desc->data_size;
  906ab0:	9b91      	s32i.n	a11, a9, 4
  906ab2:	b899      	addi.n	a9, a9, 8
__adf_nbuf_dmamap_info(__adf_os_dma_map_t bmap, adf_os_dmamap_info_t *sg)
{
    VDESC *desc = bmap->buf->desc_list;
    int count = 0;
    
    while( desc != NULL ) {
  906ab4:	658fe8        	bnez	a8, 906aa0 <__adf_nbuf_dmamap_info+0x10>
        
        count++;        
        desc = desc->next_desc;
    }
    
    sg->nsegs = count;    
  906ab7:	9a30      	s32i.n	a10, a3, 0
  906ab9:	d10f      	retw.n
	...

00906abc <__adf_nbuf_set_rx_cksum>:
  906abc:	6c1004        	entry	a1, 32
  906abf:	d10f      	retw.n
  906ac1:	000000        	ill

00906ac4 <__adf_nbuf_get_vlan_info>:
}

a_status_t      
__adf_nbuf_get_vlan_info(adf_net_handle_t hdl, __adf_nbuf_t buf, 
                         adf_net_vlanhdr_t *vlan)
{
  906ac4:	6c1004        	entry	a1, 32
    return A_STATUS_OK;
}
  906ac7:	c020      	movi.n	a2, 0
  906ac9:	d10f      	retw.n
	...

00906acc <__adf_nbuf_create_frm_frag>:

__adf_nbuf_t
__adf_nbuf_create_frm_frag(__adf_nbuf_queue_t *qhead)
{
  906acc:	6c1006        	entry	a1, 48
    VBUF *buf_tmp, *buf_head = NULL;
    VDESC *vdesc_prev = NULL, *vdesc_tmp = NULL;
    a_uint32_t cnt = 0, len = __adf_nbuf_queue_len(qhead);
    a_uint16_t total_len = 0;

    buf_head = VBUF_alloc_vbuf();
  906acf:	1468bf        	l32r	a4, 8e0dcc <_bss_end+0x3cdebc>
    return A_STATUS_OK;
}

__adf_nbuf_t
__adf_nbuf_create_frm_frag(__adf_nbuf_queue_t *qhead)
{
  906ad2:	d520      	mov.n	a5, a2
    VBUF *buf_tmp, *buf_head = NULL;
    VDESC *vdesc_prev = NULL, *vdesc_tmp = NULL;
    a_uint32_t cnt = 0, len = __adf_nbuf_queue_len(qhead);
    a_uint16_t total_len = 0;

    buf_head = VBUF_alloc_vbuf();
  906ad4:	2a42a1        	l32i	a10, a4, 0x284
 * 
 */
a_uint32_t  
__adf_nbuf_queue_len(__adf_nbuf_qhead_t *qhead)
{
    return qhead->qlen;
  906ad7:	8222      	l32i.n	a2, a2, 8
  906ad9:	9210      	s32i.n	a2, a1, 0
    VBUF *buf_tmp, *buf_head = NULL;
    VDESC *vdesc_prev = NULL, *vdesc_tmp = NULL;
    a_uint32_t cnt = 0, len = __adf_nbuf_queue_len(qhead);
    a_uint16_t total_len = 0;

    buf_head = VBUF_alloc_vbuf();
  906adb:	0ba000        	callx8	a10
  906ade:	d2a0      	mov.n	a2, a10
 * @return (NULL if the Q is empty)
 */
__adf_nbuf_t   
__adf_nbuf_queue_first(__adf_nbuf_queue_t *qhead)
{
    return qhead->head;
  906ae0:	8350      	l32i.n	a3, a5, 0
    a_uint16_t total_len = 0;

    buf_head = VBUF_alloc_vbuf();
    buf_tmp = __adf_nbuf_queue_first(qhead);

    __adf_os_assert(buf_head);
  906ae2:	cda2      	bnez.n	a10, 906af8 <__adf_nbuf_create_frm_frag+0x2c>
  906ae4:	274212        	l32i	a7, a4, 72
  906ae7:	1b692e        	l32r	a11, 8e0fa0 <_bss_end+0x3ce090>
  906aea:	1a6927        	l32r	a10, 8e0f88 <_bss_end+0x3ce078>
  906aed:	0b7000        	callx8	a7
  906af0:	176923        	l32r	a7, 8e0f7c <_bss_end+0x3ce06c>
  906af3:	0c0200        	memw
  906af6:	8770      	l32i.n	a7, a7, 0
    __adf_os_assert(buf_tmp);
  906af8:	cd32      	bnez.n	a3, 906b0e <__adf_nbuf_create_frm_frag+0x42>
  906afa:	274212        	l32i	a7, a4, 72
  906afd:	1b692e        	l32r	a11, 8e0fb8 <_bss_end+0x3ce0a8>
  906b00:	1a6927        	l32r	a10, 8e0f9c <_bss_end+0x3ce08c>
  906b03:	0b7000        	callx8	a7
  906b06:	176923        	l32r	a7, 8e0f94 <_bss_end+0x3ce084>
  906b09:	0c0200        	memw
  906b0c:	8770      	l32i.n	a7, a7, 0

    buf_head->desc_list = buf_tmp->desc_list;
  906b0e:	8330      	l32i.n	a3, a3, 0
  906b10:	9320      	s32i.n	a3, a2, 0
__adf_nbuf_create_frm_frag(__adf_nbuf_queue_t *qhead)
{
    VBUF *buf_tmp, *buf_head = NULL;
    VDESC *vdesc_prev = NULL, *vdesc_tmp = NULL;
    a_uint32_t cnt = 0, len = __adf_nbuf_queue_len(qhead);
    a_uint16_t total_len = 0;
  906b12:	c030      	movi.n	a3, 0
__adf_nbuf_t
__adf_nbuf_create_frm_frag(__adf_nbuf_queue_t *qhead)
{
    VBUF *buf_tmp, *buf_head = NULL;
    VDESC *vdesc_prev = NULL, *vdesc_tmp = NULL;
    a_uint32_t cnt = 0, len = __adf_nbuf_queue_len(qhead);
  906b14:	d630      	mov.n	a6, a3

__adf_nbuf_t
__adf_nbuf_create_frm_frag(__adf_nbuf_queue_t *qhead)
{
    VBUF *buf_tmp, *buf_head = NULL;
    VDESC *vdesc_prev = NULL, *vdesc_tmp = NULL;
  906b16:	d730      	mov.n	a7, a3
    __adf_os_assert(buf_head);
    __adf_os_assert(buf_tmp);

    buf_head->desc_list = buf_tmp->desc_list;

    while ((buf_tmp = __adf_nbuf_queue_remove(qhead)) != NULL) {
  906b18:	600024        	j	906b40 <__adf_nbuf_create_frm_frag+0x74>
  906b1b:	000028        	mull	a0, a0, a0
        cnt++;

        //adf_os_print("merge buf: %x\n", buf_tmp->desc_list->buf_addr + buf_tmp->desc_list->data_offset);

        total_len += buf_tmp->buf_length;
  906b1e:	a104      	add.n	a4, a0, a1
    __adf_os_assert(buf_tmp);

    buf_head->desc_list = buf_tmp->desc_list;

    while ((buf_tmp = __adf_nbuf_queue_remove(qhead)) != NULL) {
        cnt++;
  906b20:	b166      	addi.n	a6, a6, 1

        //adf_os_print("merge buf: %x\n", buf_tmp->desc_list->buf_addr + buf_tmp->desc_list->data_offset);

        total_len += buf_tmp->buf_length;
  906b22:	a833      	add.n	a3, a3, a8
  906b24:	03034f        	extui	a3, a3, 0, 16
  906b27:	88a0      	l32i.n	a8, a10, 0

        if (vdesc_prev) {
  906b29:	c871      	beqz.n	a7, 906b2e <__adf_nbuf_create_frm_frag+0x62>
            /* link "the last VDESC of previous VBUF" to "the 1st VDESC of this VBUF" */
            vdesc_prev->next_desc = buf_tmp->desc_list;
  906b2b:	287600        	s32i	a8, a7, 0
  906b2e:	d780      	mov.n	a7, a8
        }

        /* traverse VDESC list in this VBUF to find out the last VDESC */
        vdesc_tmp = buf_tmp->desc_list;
        while (vdesc_tmp->next_desc) {
  906b30:	8880      	l32i.n	a8, a8, 0
  906b32:	658ff8        	bnez	a8, 906b2e <__adf_nbuf_create_frm_frag+0x62>
            vdesc_tmp = vdesc_tmp->next_desc;
        }
        vdesc_prev = vdesc_tmp;

        /* return VBUF to the pool */
        buf_tmp->desc_list = NULL;
  906b35:	98a0      	s32i.n	a8, a10, 0
        buf_tmp->buf_length = 0;
  906b37:	28a504        	s16i	a8, a10, 8
        VBUF_free_vbuf(buf_tmp);
  906b3a:	2842a3        	l32i	a8, a4, 0x28c
  906b3d:	0b8000        	callx8	a8
    __adf_os_assert(buf_head);
    __adf_os_assert(buf_tmp);

    buf_head->desc_list = buf_tmp->desc_list;

    while ((buf_tmp = __adf_nbuf_queue_remove(qhead)) != NULL) {
  906b40:	da50      	mov.n	a10, a5
  906b42:	5bffba        	call8	906a2c <__adf_nbuf_queue_remove>
  906b45:	65afd4        	bnez	a10, 906b1d <__adf_nbuf_create_frm_frag+0x51>
        buf_tmp->desc_list = NULL;
        buf_tmp->buf_length = 0;
        VBUF_free_vbuf(buf_tmp);
    }

    if (cnt != len) {
  906b48:	8510      	l32i.n	a5, a1, 0
  906b4a:	756113        	beq	a6, a5, 906b61 <__adf_nbuf_create_frm_frag+0x95>
        //adf_os_print("cnt: %x, len: %x, __adf_nbuf_queue_len: %x\n", cnt, len, 
        //             __adf_nbuf_queue_len(qhead));
        adf_os_assert(0);
  906b4d:	244212        	l32i	a4, a4, 72
  906b50:	1b692e        	l32r	a11, 8e1008 <_bss_end+0x3ce0f8>
  906b53:	1a6927        	l32r	a10, 8e0ff0 <_bss_end+0x3ce0e0>
  906b56:	0b4000        	callx8	a4
  906b59:	146923        	l32r	a4, 8e0fe8 <_bss_end+0x3ce0d8>
  906b5c:	0c0200        	memw
  906b5f:	8440      	l32i.n	a4, a4, 0
    }
    //__adf_os_assert(cnt == len);

    buf_head->buf_length = total_len;
  906b61:	232504        	s16i	a3, a2, 8

    return buf_head;
}
  906b64:	d10f      	retw.n
	...

00906b68 <__adf_nbuf_split_to_frag>:

void
__adf_nbuf_split_to_frag(__adf_nbuf_t buf, __adf_nbuf_qhead_t *qhead)
{
  906b68:	6c1004        	entry	a1, 32
 * @param qhead
 */
void 
__adf_nbuf_queue_init(__adf_nbuf_qhead_t *qhead)
{
    qhead->qlen = 0;
  906b6b:	c040      	movi.n	a4, 0
  906b6d:	9432      	s32i.n	a4, a3, 8
    qhead->head = NULL;
  906b6f:	9430      	s32i.n	a4, a3, 0
    qhead->tail = NULL;
  906b71:	9431      	s32i.n	a4, a3, 4
  906b73:	1668bf        	l32r	a6, 8e0e70 <_bss_end+0x3cdf60>
{
    VBUF *buf_tmp;
    VDESC *desc_tmp = NULL;

    __adf_nbuf_queue_init(qhead);
    desc_tmp = buf->desc_list;
  906b76:	8420      	l32i.n	a4, a2, 0

    while (desc_tmp /*&& desc_tmp->buf_addr*/) {
  906b78:	60003a        	j	906bb6 <__adf_nbuf_split_to_frag+0x4e>
  906b7b:	00002a        	muluh	a0, a0, a0
        buf_tmp = VBUF_alloc_vbuf();
  906b7e:	62a10b        	j	8f0c8d <memset+0x9e45>
  906b81:	a000      	add.n	a0, a0, a0
  906b83:	d5a0      	mov.n	a5, a10

        __adf_os_assert(buf_tmp);
  906b85:	65a014        	bnez	a10, 906b9d <__adf_nbuf_split_to_frag+0x35>
  906b88:	276212        	l32i	a7, a6, 72
  906b8b:	1b692f        	l32r	a11, 8e1048 <_bss_end+0x3ce138>
  906b8e:	1a6927        	l32r	a10, 8e102c <_bss_end+0x3ce11c>
  906b91:	0b7000        	callx8	a7
  906b94:	176923        	l32r	a7, 8e1020 <_bss_end+0x3ce110>
  906b97:	0c0200        	memw
  906b9a:	277200        	l32i	a7, a7, 0

        //desc_tmp->data_size = 0;
        buf_tmp->desc_list = desc_tmp;
        //buf_tmp->buf_length = desc_tmp->buf_size;
        buf_tmp->buf_length = desc_tmp->data_size;
  906b9d:	274106        	l16ui	a7, a4, 12
        buf_tmp = VBUF_alloc_vbuf();

        __adf_os_assert(buf_tmp);

        //desc_tmp->data_size = 0;
        buf_tmp->desc_list = desc_tmp;
  906ba0:	9450      	s32i.n	a4, a5, 0
        //buf_tmp->buf_length = desc_tmp->buf_size;
        buf_tmp->buf_length = desc_tmp->data_size;
  906ba2:	275504        	s16i	a7, a5, 8
        buf_tmp->next_buf = NULL;
  906ba5:	c070      	movi.n	a7, 0
  906ba7:	9751      	s32i.n	a7, a5, 4

        //adf_os_print("split - buf: %x\n", buf_tmp->desc_list->buf_addr + buf_tmp->desc_list->data_offset);

        __adf_nbuf_queue_add(qhead, buf_tmp);
  906ba9:	db50      	mov.n	a11, a5
  906bab:	da30      	mov.n	a10, a3
  906bad:	5bff97        	call8	906a0c <__adf_nbuf_queue_add>

        desc_tmp = desc_tmp->next_desc;

        buf_tmp->desc_list->next_desc = NULL;
  906bb0:	8550      	l32i.n	a5, a5, 0

        //adf_os_print("split - buf: %x\n", buf_tmp->desc_list->buf_addr + buf_tmp->desc_list->data_offset);

        __adf_nbuf_queue_add(qhead, buf_tmp);

        desc_tmp = desc_tmp->next_desc;
  906bb2:	8440      	l32i.n	a4, a4, 0

        buf_tmp->desc_list->next_desc = NULL;
  906bb4:	9750      	s32i.n	a7, a5, 0
    VDESC *desc_tmp = NULL;

    __adf_nbuf_queue_init(qhead);
    desc_tmp = buf->desc_list;

    while (desc_tmp /*&& desc_tmp->buf_addr*/) {
  906bb6:	654fc3        	bnez	a4, 906b7d <__adf_nbuf_split_to_frag+0x15>
        buf_tmp->desc_list->next_desc = NULL;
    }

    buf->desc_list = NULL;
    buf->buf_length = 0;
    VBUF_free_vbuf(buf);
  906bb9:	2362a3        	l32i	a3, a6, 0x28c
        desc_tmp = desc_tmp->next_desc;

        buf_tmp->desc_list->next_desc = NULL;
    }

    buf->desc_list = NULL;
  906bbc:	9420      	s32i.n	a4, a2, 0
    buf->buf_length = 0;
  906bbe:	242504        	s16i	a4, a2, 8
    VBUF_free_vbuf(buf);
  906bc1:	da20      	mov.n	a10, a2
  906bc3:	0b3000        	callx8	a3
  906bc6:	d10f      	retw.n

00906bc8 <__adf_nbuf_last>:
 * 
 * @return struct mbuf*
 */
VDESC * 
__adf_nbuf_last(VBUF *buf)
{
  906bc8:	6c1004        	entry	a1, 32
    VDESC *desc = buf->desc_list;
  906bcb:	8220      	l32i.n	a2, a2, 0
    
    //for(; desc->next_desc != NULL; desc = desc->next_desc)
    //    ;
    while(desc->next_desc != NULL)
  906bcd:	600001        	j	906bd2 <__adf_nbuf_last+0xa>
  906bd0:	d280      	mov.n	a2, a8
  906bd2:	8820      	l32i.n	a8, a2, 0
  906bd4:	658ff8        	bnez	a8, 906bd0 <__adf_nbuf_last+0x8>
    {
        desc = desc->next_desc;
    }
    
    return desc;
}
  906bd7:	d10f      	retw.n
  906bd9:	000000        	ill

00906bdc <__adf_nbuf_put_tail>:
 * @return previous tail (data+len),NULL if the len is more than
 *         space available
 */
a_uint8_t *
__adf_nbuf_put_tail(__adf_nbuf_t buf, adf_os_size_t len)
{
  906bdc:	6c1004        	entry	a1, 32
    a_uint8_t *tail = NULL;
    VDESC *last_desc = __adf_nbuf_last(buf);
  906bdf:	da20      	mov.n	a10, a2
  906be1:	5bfff9        	call8	906bc8 <__adf_nbuf_last>
    
    tail = last_desc->buf_addr + last_desc->data_offset + last_desc->data_size;
  906be4:	28a106        	l16ui	a8, a10, 12
  906be7:	29a105        	l16ui	a9, a10, 10
    last_desc->data_size += len;
  906bea:	03034f        	extui	a3, a3, 0, 16
__adf_nbuf_put_tail(__adf_nbuf_t buf, adf_os_size_t len)
{
    a_uint8_t *tail = NULL;
    VDESC *last_desc = __adf_nbuf_last(buf);
    
    tail = last_desc->buf_addr + last_desc->data_offset + last_desc->data_size;
  906bed:	a899      	add.n	a9, a9, a8
    last_desc->data_size += len;
  906bef:	a388      	add.n	a8, a8, a3
  906bf1:	28a506        	s16i	a8, a10, 12
    buf->buf_length += len;
  906bf4:	282104        	l16ui	a8, a2, 8
__adf_nbuf_put_tail(__adf_nbuf_t buf, adf_os_size_t len)
{
    a_uint8_t *tail = NULL;
    VDESC *last_desc = __adf_nbuf_last(buf);
    
    tail = last_desc->buf_addr + last_desc->data_offset + last_desc->data_size;
  906bf7:	8ba1      	l32i.n	a11, a10, 4
    last_desc->data_size += len;
    buf->buf_length += len;
  906bf9:	a833      	add.n	a3, a3, a8
  906bfb:	232504        	s16i	a3, a2, 8
    
    return tail;
}
  906bfe:	a9b2      	add.n	a2, a11, a9
  906c00:	d10f      	retw.n
	...

00906c04 <__adf_nbuf_trim_tail>:
 * @param len (how much to strip down)
 * 
 */
void 
__adf_nbuf_trim_tail(__adf_nbuf_t buf, adf_os_size_t len)
{
  906c04:	6c1004        	entry	a1, 32
    VDESC *last_desc = __adf_nbuf_last(buf);
  906c07:	022a02        	or	a10, a2, a2
  906c0a:	5bffef        	call8	906bc8 <__adf_nbuf_last>
  906c0d:	d4a0      	mov.n	a4, a10
    
    adf_os_assert(buf != NULL);
  906c0f:	cd25      	bnez.n	a2, 906c28 <__adf_nbuf_trim_tail+0x24>
  906c11:	1868bf        	l32r	a8, 8e0f10 <_bss_end+0x3ce000>
  906c14:	1b6930        	l32r	a11, 8e10d4 <_bss_end+0x3ce1c4>
  906c17:	288212        	l32i	a8, a8, 72
  906c1a:	1a6927        	l32r	a10, 8e10b8 <_bss_end+0x3ce1a8>
  906c1d:	0b8000        	callx8	a8
  906c20:	186923        	l32r	a8, 8e10ac <_bss_end+0x3ce19c>
  906c23:	0c0200        	memw
  906c26:	8880      	l32i.n	a8, a8, 0
    last_desc->data_size -= len;
  906c28:	284106        	l16ui	a8, a4, 12
  906c2b:	03034f        	extui	a3, a3, 0, 16
  906c2e:	03880c        	sub	a8, a8, a3
  906c31:	284506        	s16i	a8, a4, 12
    buf->buf_length -= len;
  906c34:	282104        	l16ui	a8, a2, 8
  906c37:	03830c        	sub	a3, a8, a3
  906c3a:	232504        	s16i	a3, a2, 8
  906c3d:	d10f      	retw.n
	...

00906c40 <__adf_nbuf_headroom>:
 * 
 * @return num of bytes available
 */
a_uint32_t
__adf_nbuf_headroom(__adf_nbuf_t  buf)
{
  906c40:	6c1004        	entry	a1, 32
    return buf->desc_list->data_offset;
  906c43:	8820      	l32i.n	a8, a2, 0
}
  906c45:	228105        	l16ui	a2, a8, 10
  906c48:	d10f      	retw.n
	...

00906c4c <__adf_nbuf_tailroom>:
 * @return num of bytes
 */

a_uint32_t 
__adf_nbuf_tailroom(__adf_nbuf_t  buf)
{
  906c4c:	6c1004        	entry	a1, 32
    VDESC *last_desc = __adf_nbuf_last(buf);
  906c4f:	da20      	mov.n	a10, a2
  906c51:	5bffdd        	call8	906bc8 <__adf_nbuf_last>
    
    return last_desc->buf_size - last_desc->data_offset - last_desc->data_size;
  906c54:	22a105        	l16ui	a2, a10, 10
  906c57:	28a104        	l16ui	a8, a10, 8
  906c5a:	02880c        	sub	a8, a8, a2
  906c5d:	22a106        	l16ui	a2, a10, 12
}
  906c60:	02820c        	sub	a2, a8, a2
  906c63:	d10f      	retw.n
  906c65:	000000        	ill

00906c68 <__adf_nbuf_len>:
 * 
 * @return total length of packet (sum of all frag lengths)
 */ 
a_uint32_t
__adf_nbuf_len(__adf_nbuf_t  buf)
{
  906c68:	6c1004        	entry	a1, 32
    return buf->buf_length; 
}
  906c6b:	222104        	l16ui	a2, a2, 8
  906c6e:	d10f      	retw.n

00906c70 <__adf_nbuf_clone>:
 * 
 * @return Read-only copy of the nbuf (including clusters)
 */
__adf_nbuf_t 
__adf_nbuf_clone(__adf_nbuf_t  src)
{
  906c70:	6c1004        	entry	a1, 32
    __adf_nbuf_t buf = NULL;
    
    return buf;
}
  906c73:	c020      	movi.n	a2, 0
  906c75:	d10f      	retw.n
	...

00906c78 <__adf_nbuf_cat>:

void
__adf_nbuf_cat(__adf_nbuf_t dst, __adf_nbuf_t src)
{
  906c78:	6c1004        	entry	a1, 32
  906c7b:	d10f      	retw.n
  906c7d:	000000        	ill

00906c80 <__adf_nbuf_is_cloned>:
 * 
 * @return a_bool_t
 */
a_bool_t
__adf_nbuf_is_cloned(__adf_nbuf_t  buf)
{
  906c80:	6c1004        	entry	a1, 32
    return A_FALSE;
}
  906c83:	c020      	movi.n	a2, 0
  906c85:	d10f      	retw.n
	...

00906c88 <__adf_nbuf_peek_header>:
 * @brief This will return the header's addr & m_len
 */
void
__adf_nbuf_peek_header(__adf_nbuf_t buf, a_uint8_t   **addr, 
                       a_uint32_t	*len)
{
  906c88:	6c1004        	entry	a1, 32
    VDESC *desc = buf->desc_list;
  906c8b:	8820      	l32i.n	a8, a2, 0
    
    *addr = desc->buf_addr + desc->data_offset;
  906c8d:	2a8105        	l16ui	a10, a8, 10
  906c90:	8981      	l32i.n	a9, a8, 4
    *len = desc->data_size; 
  906c92:	288106        	l16ui	a8, a8, 12
__adf_nbuf_peek_header(__adf_nbuf_t buf, a_uint8_t   **addr, 
                       a_uint32_t	*len)
{
    VDESC *desc = buf->desc_list;
    
    *addr = desc->buf_addr + desc->data_offset;
  906c95:	aa99      	add.n	a9, a9, a10
  906c97:	9930      	s32i.n	a9, a3, 0
    *len = desc->data_size; 
  906c99:	9840      	s32i.n	a8, a4, 0
  906c9b:	d10f      	retw.n
  906c9d:	000000        	ill

00906ca0 <__adf_nbuf_queue_init>:
 * @brief init the queue
 * @param qhead
 */
void 
__adf_nbuf_queue_init(__adf_nbuf_qhead_t *qhead)
{
  906ca0:	6c1004        	entry	a1, 32
    qhead->qlen = 0;
  906ca3:	c080      	movi.n	a8, 0
  906ca5:	9822      	s32i.n	a8, a2, 8
    qhead->head = NULL;
  906ca7:	9820      	s32i.n	a8, a2, 0
    qhead->tail = NULL;
  906ca9:	9821      	s32i.n	a8, a2, 4
  906cab:	d10f      	retw.n
  906cad:	000000        	ill

00906cb0 <__adf_nbuf_queue_len>:
 * @return length
 * 
 */
a_uint32_t  
__adf_nbuf_queue_len(__adf_nbuf_qhead_t *qhead)
{
  906cb0:	6c1004        	entry	a1, 32
    return qhead->qlen;
}
  906cb3:	8222      	l32i.n	a2, a2, 8
  906cb5:	d10f      	retw.n
	...

00906cb8 <__adf_nbuf_queue_first>:
 * 
 * @return (NULL if the Q is empty)
 */
__adf_nbuf_t   
__adf_nbuf_queue_first(__adf_nbuf_queue_t *qhead)
{
  906cb8:	6c1004        	entry	a1, 32
    return qhead->head;
}
  906cbb:	8220      	l32i.n	a2, a2, 0
  906cbd:	d10f      	retw.n
	...

00906cc0 <__adf_nbuf_queue_next>:
 * 
 * @return (NULL if no packets are there)
 */
__adf_nbuf_t   
__adf_nbuf_queue_next(__adf_nbuf_t  buf)
{
  906cc0:	6c1004        	entry	a1, 32
    return buf->next_buf;
}
  906cc3:	8221      	l32i.n	a2, a2, 4
  906cc5:	d10f      	retw.n
	...

00906cc8 <__adf_nbuf_is_queue_empty>:
 * 
 * @return a_bool_t
 */
a_bool_t  
__adf_nbuf_is_queue_empty(__adf_nbuf_qhead_t *qhead)
{
  906cc8:	6c1004        	entry	a1, 32
    return ((qhead->qlen == 0));
  906ccb:	8222      	l32i.n	a2, a2, 8
  906ccd:	c091      	movi.n	a9, 1
  906ccf:	c080      	movi.n	a8, 0
  906cd1:	029838        	moveqz	a8, a9, a2
  906cd4:	d280      	mov.n	a2, a8
}
  906cd6:	d10f      	retw.n

00906cd8 <_buf_pool_static_init>:
    pAPIs->_free_buf = _buf_pool_static_free_buf;
    pAPIs->_shutdown = _buf_pool_static_shutdown;
}
 
LOCAL pool_handle_t _buf_pool_static_init(adf_os_handle_t handle)
{
  906cd8:	6c1004        	entry	a1, 32
  906cdb:	c080      	movi.n	a8, 0
#if 1
    int i;
    
    for(i=0; i < POOL_ID_MAX; i++) {
        g_poolCtx.bufQ[i] = NULL;
  906cdd:	126931        	l32r	a2, 8e11a4 <_bss_end+0x3ce294>
  906ce0:	db80      	mov.n	a11, a8
LOCAL pool_handle_t _buf_pool_static_init(adf_os_handle_t handle)
{
#if 1
    int i;
    
    for(i=0; i < POOL_ID_MAX; i++) {
  906ce2:	290a0a        	movi	a9, 10
  906ce5:	6d9805        	loop	a9, 906cee <_buf_pool_static_init+0x16>
        g_poolCtx.bufQ[i] = NULL;
  906ce8:	a28a      	add.n	a10, a8, a2
  906cea:	9ba0      	s32i.n	a11, a10, 0
  906cec:	b488      	addi.n	a8, a8, 4
    ctx = (BUF_POOL_STATIC_CONTEXT *)adf_os_mem_alloc(sizeof(BUF_POOL_STATIC_CONTEXT));
    ctx->NetHandle = handle;
    
    return ctx; 
#endif    
}      
  906cee:	d10f      	retw.n

00906cf0 <_buf_pool_static_shutdown>:
    
LOCAL void _buf_pool_static_shutdown(pool_handle_t handle) 
{
  906cf0:	6c1004        	entry	a1, 32
  906cf3:	d10f      	retw.n
  906cf5:	000000        	ill

00906cf8 <_buf_pool_static_create_pool>:
    // SHALL NOT BE USED in FW
}

LOCAL void _buf_pool_static_create_pool(pool_handle_t handle, BUF_POOL_ID poolId, int nItems, int nSize)
{
  906cf8:	6c1006        	entry	a1, 48
        desc->data_size = 0;
        
        buf->buf_length = 0;        
        buf->desc_list = desc;
        
        if ( g_poolCtx.bufQ[poolId] == NULL ) {
  906cfb:	126931        	l32r	a2, 8e11c0 <_bss_end+0x3ce2b0>
  906cfe:	0e3311        	slli	a3, a3, 2
{
    // SHALL NOT BE USED in FW
}

LOCAL void _buf_pool_static_create_pool(pool_handle_t handle, BUF_POOL_ID poolId, int nItems, int nSize)
{
  906d01:	d940      	mov.n	a9, a4
    VDESC *desc;
    
    //BUF_POOL_STATIC_CONTEXT *ctx = (BUF_POOL_STATIC_CONTEXT *)handle;
    
    for ( i = 0; i < nItems; i++) {
        buf = VBUF_alloc_vbuf();
  906d03:	1668bf        	l32r	a6, 8e1000 <_bss_end+0x3ce0f0>
    VBUF *buf;
    VDESC *desc;
    
    //BUF_POOL_STATIC_CONTEXT *ctx = (BUF_POOL_STATIC_CONTEXT *)handle;
    
    for ( i = 0; i < nItems; i++) {
  906d06:	c040      	movi.n	a4, 0
        desc->data_size = 0;
        
        buf->buf_length = 0;        
        buf->desc_list = desc;
        
        if ( g_poolCtx.bufQ[poolId] == NULL ) {
  906d08:	a323      	add.n	a3, a2, a3
    VBUF *buf;
    VDESC *desc;
    
    //BUF_POOL_STATIC_CONTEXT *ctx = (BUF_POOL_STATIC_CONTEXT *)handle;
    
    for ( i = 0; i < nItems; i++) {
  906d0a:	60003c        	j	906d4a <_buf_pool_static_create_pool+0x52>
        buf = VBUF_alloc_vbuf();
  906d0d:	2a62a1        	l32i	a10, a6, 0x284
  906d10:	9910      	s32i.n	a9, a1, 0
  906d12:	0ba000        	callx8	a10
  906d15:	d2a0      	mov.n	a2, a10
        desc = VDESC_alloc_vdesc();
  906d17:	2a62a6        	l32i	a10, a6, 0x298
  906d1a:	0ba000        	callx8	a10
#include "Magpie_api.h"

static inline void *	__adf_os_mem_alloc(adf_os_size_t size)
{
//    return (malloc(size,M_DEVBUF,M_DONTWAIT | M_ZERO));
    return A_ALLOCRAM(size);
  906d1d:	286252        	l32i	a8, a6, 0x148
  906d20:	d7a0      	mov.n	a7, a10
  906d22:	db50      	mov.n	a11, a5
  906d24:	c0a0      	movi.n	a10, 0
  906d26:	0b8000        	callx8	a8

        desc->buf_addr = (A_UINT8 *)adf_os_mem_alloc(nSize);
        desc->buf_size = nSize;
        desc->data_offset = 0;
  906d29:	c080      	movi.n	a8, 0
    
    for ( i = 0; i < nItems; i++) {
        buf = VBUF_alloc_vbuf();
        desc = VDESC_alloc_vdesc();

        desc->buf_addr = (A_UINT8 *)adf_os_mem_alloc(nSize);
  906d2b:	9a71      	s32i.n	a10, a7, 4
        desc->buf_size = nSize;
  906d2d:	257504        	s16i	a5, a7, 8
        desc->data_offset = 0;
  906d30:	287505        	s16i	a8, a7, 10
        desc->data_size = 0;
  906d33:	287506        	s16i	a8, a7, 12
        
        buf->buf_length = 0;        
        buf->desc_list = desc;
  906d36:	9720      	s32i.n	a7, a2, 0
        
        if ( g_poolCtx.bufQ[poolId] == NULL ) {
  906d38:	8730      	l32i.n	a7, a3, 0
        desc->buf_addr = (A_UINT8 *)adf_os_mem_alloc(nSize);
        desc->buf_size = nSize;
        desc->data_offset = 0;
        desc->data_size = 0;
        
        buf->buf_length = 0;        
  906d3a:	282504        	s16i	a8, a2, 8
        buf->desc_list = desc;
        
        if ( g_poolCtx.bufQ[poolId] == NULL ) {
  906d3d:	8910      	l32i.n	a9, a1, 0
  906d3f:	cc71      	bnez.n	a7, 906d44 <_buf_pool_static_create_pool+0x4c>
  906d41:	600001        	j	906d46 <_buf_pool_static_create_pool+0x4e>
            g_poolCtx.bufQ[poolId] = buf;
        } else {
            buf->next_buf = g_poolCtx.bufQ[poolId];
  906d44:	9721      	s32i.n	a7, a2, 4
            g_poolCtx.bufQ[poolId] = buf;
  906d46:	9230      	s32i.n	a2, a3, 0
    VBUF *buf;
    VDESC *desc;
    
    //BUF_POOL_STATIC_CONTEXT *ctx = (BUF_POOL_STATIC_CONTEXT *)handle;
    
    for ( i = 0; i < nItems; i++) {
  906d48:	b144      	addi.n	a4, a4, 1
  906d4a:	7942bf        	blt	a4, a9, 906d0d <_buf_pool_static_create_pool+0x15>
        } else {
            buf->next_buf = g_poolCtx.bufQ[poolId];
            g_poolCtx.bufQ[poolId] = buf;
        }
    }
}
  906d4d:	d10f      	retw.n
	...

00906d50 <_buf_pool_static_alloc_buf>:
            
LOCAL adf_nbuf_t  _buf_pool_static_alloc_buf(pool_handle_t handle, BUF_POOL_ID poolId, int reserve)
{
  906d50:	6c1004        	entry	a1, 32
    VBUF *buf;
    
    buf = g_poolCtx.bufQ[poolId];
  906d53:	126931        	l32r	a2, 8e1218 <_bss_end+0x3ce308>
  906d56:	0e3311        	slli	a3, a3, 2
  906d59:	a323      	add.n	a3, a2, a3
  906d5b:	8230      	l32i.n	a2, a3, 0
    if ( buf != NULL ) {
  906d5d:	c921      	beqz.n	a2, 906d72 <_buf_pool_static_alloc_buf+0x22>
        g_poolCtx.bufQ[poolId] = buf->next_buf;
  906d5f:	8821      	l32i.n	a8, a2, 4
  906d61:	9830      	s32i.n	a8, a3, 0
        
        buf->next_buf = NULL;
  906d63:	c030      	movi.n	a3, 0
        buf->desc_list->data_offset = reserve;
  906d65:	8820      	l32i.n	a8, a2, 0
    
    buf = g_poolCtx.bufQ[poolId];
    if ( buf != NULL ) {
        g_poolCtx.bufQ[poolId] = buf->next_buf;
        
        buf->next_buf = NULL;
  906d67:	9321      	s32i.n	a3, a2, 4
        buf->desc_list->data_offset = reserve;
  906d69:	248505        	s16i	a4, a8, 10
        buf->desc_list->data_size = 0;
  906d6c:	238506        	s16i	a3, a8, 12
        buf->buf_length = 0;
  906d6f:	232504        	s16i	a3, a2, 8
    }
    
    return buf;
}
  906d72:	d10f      	retw.n

00906d74 <_buf_pool_static_alloc_buf_align>:

LOCAL adf_nbuf_t  _buf_pool_static_alloc_buf_align(pool_handle_t handle, BUF_POOL_ID poolId, int reserve, int align)
{
  906d74:	6c1004        	entry	a1, 32
    return _buf_pool_static_alloc_buf(handle, poolId, reserve);
  906d77:	dc40      	mov.n	a12, a4
  906d79:	db30      	mov.n	a11, a3
  906d7b:	da20      	mov.n	a10, a2
  906d7d:	5bfff4        	call8	906d50 <_buf_pool_static_alloc_buf>
}
  906d80:	d2a0      	mov.n	a2, a10
  906d82:	d10f      	retw.n

00906d84 <_buf_pool_static_free_buf>:
    
LOCAL void _buf_pool_static_free_buf(pool_handle_t handle, BUF_POOL_ID poolId, adf_nbuf_t buf)
{
  906d84:	6c1004        	entry	a1, 32
    if ( g_poolCtx.bufQ[poolId] == NULL ) {
  906d87:	186931        	l32r	a8, 8e124c <_bss_end+0x3ce33c>
  906d8a:	0e3311        	slli	a3, a3, 2
  906d8d:	a383      	add.n	a3, a8, a3
  906d8f:	8830      	l32i.n	a8, a3, 0
  906d91:	cc81      	bnez.n	a8, 906d96 <_buf_pool_static_free_buf+0x12>
  906d93:	600001        	j	906d98 <_buf_pool_static_free_buf+0x14>
        g_poolCtx.bufQ[poolId] = buf;
    } else {
        buf->next_buf = g_poolCtx.bufQ[poolId];
  906d96:	9841      	s32i.n	a8, a4, 4
        g_poolCtx.bufQ[poolId] = buf;
  906d98:	9430      	s32i.n	a4, a3, 0
  906d9a:	d10f      	retw.n

00906d9c <buf_pool_module_install>:
LOCAL void _buf_pool_static_shutdown(pool_handle_t handle);      

BUF_POOL_STATIC_CONTEXT g_poolCtx;

void buf_pool_module_install(struct buf_pool_api *pAPIs)
{   
  906d9c:	6c1004        	entry	a1, 32
    pAPIs->_init = _buf_pool_static_init;
  906d9f:	186932        	l32r	a8, 8e1268 <_bss_end+0x3ce358>
  906da2:	9820      	s32i.n	a8, a2, 0
    pAPIs->_create_pool = _buf_pool_static_create_pool;
  906da4:	186933        	l32r	a8, 8e1270 <_bss_end+0x3ce360>
  906da7:	9822      	s32i.n	a8, a2, 8
    pAPIs->_alloc_buf = _buf_pool_static_alloc_buf;
  906da9:	186934        	l32r	a8, 8e127c <_bss_end+0x3ce36c>
  906dac:	9823      	s32i.n	a8, a2, 12
    pAPIs->_alloc_buf_align = _buf_pool_static_alloc_buf_align;
  906dae:	186935        	l32r	a8, 8e1284 <_bss_end+0x3ce374>
  906db1:	9824      	s32i.n	a8, a2, 16
    pAPIs->_free_buf = _buf_pool_static_free_buf;
  906db3:	186936        	l32r	a8, 8e128c <_bss_end+0x3ce37c>
  906db6:	9825      	s32i.n	a8, a2, 20
    pAPIs->_shutdown = _buf_pool_static_shutdown;
  906db8:	186937        	l32r	a8, 8e1294 <_bss_end+0x3ce384>
  906dbb:	9821      	s32i.n	a8, a2, 4
  906dbd:	d10f      	retw.n
	...

00906dc0 <db_incorect_format>:
int cmd_not_found;
uint16_t gvLen;
int pressed_time;

static void db_incorect_format(void)
{
  906dc0:	6c1004        	entry	a1, 32
	A_PRINTF("Error! Incorrect format.\n\r");
  906dc3:	1868bf        	l32r	a8, 8e10c0 <_bss_end+0x3ce1b0>
  906dc6:	1a6938        	l32r	a10, 8e12a8 <_bss_end+0x3ce398>
  906dc9:	288212        	l32i	a8, a8, 72
  906dcc:	0b8000        	callx8	a8
  906dcf:	d10f      	retw.n
  906dd1:	000000        	ill

00906dd4 <zf_debug_init>:
	} while (mem1 < mem2);
	A_PRINTF("\n\r");
}

static void zf_debug_init(void)
{
  906dd4:	6c1006        	entry	a1, 48
	uint8_t ch;

	/* Purge Rx FIFO */
	while ((zm_get_char(&ch)) != 0)
  906dd7:	1268bf        	l32r	a2, 8e10d4 <_bss_end+0x3ce1c4>
  906dda:	282215        	l32i	a8, a2, 84
  906ddd:	da10      	mov.n	a10, a1
  906ddf:	0b8000        	callx8	a8
  906de2:	65aff4        	bnez	a10, 906dda <zf_debug_init+0x6>
	{
	}

	cmd_buf_ptr = 0;
  906de5:	186939        	l32r	a8, 8e12cc <_bss_end+0x3ce3bc>
  906de8:	9a80      	s32i.n	a10, a8, 0
	cmd_buf_full = FALSE;
  906dea:	18693a        	l32r	a8, 8e12d4 <_bss_end+0x3ce3c4>
  906ded:	9a80      	s32i.n	a10, a8, 0
	gvLen = 0;
  906def:	18693b        	l32r	a8, 8e12dc <_bss_end+0x3ce3cc>
  906df2:	2a8500        	s16i	a10, a8, 0
	pressed_time = 0;
  906df5:	18693c        	l32r	a8, 8e12e8 <_bss_end+0x3ce3d8>
  906df8:	9a80      	s32i.n	a10, a8, 0
  906dfa:	d10f      	retw.n

00906dfc <db_ascii_to_hex>:
	}
	return (int)A_STRLEN(cmd_str);
}

static int db_ascii_to_hex(char *num_str, unsigned long *hex_num)
{
  906dfc:	6c1004        	entry	a1, 32
	int i = 0;

	*hex_num = 0;
  906dff:	c080      	movi.n	a8, 0
  906e01:	9830      	s32i.n	a8, a3, 0
	while (num_str[i])
	{
		if ((num_str[i] >= '0') && (num_str[i] <= '9'))
  906e03:	c099      	movi.n	a9, 9
static int db_ascii_to_hex(char *num_str, unsigned long *hex_num)
{
	int i = 0;

	*hex_num = 0;
	while (num_str[i])
  906e05:	60004f        	j	906e58 <db_ascii_to_hex+0x5c>
	{
		if ((num_str[i] >= '0') && (num_str[i] <= '9'))
  906e08:	2a8cd0        	addi	a10, a8, -48
  906e0b:	0a0a47        	extui	a10, a10, 0, 8
  906e0e:	7a930f        	bltu	a9, a10, 906e21 <db_ascii_to_hex+0x25>
		{
			*hex_num <<= 4;
  906e11:	8830      	l32i.n	a8, a3, 0
  906e13:	0c8811        	slli	a8, a8, 4
  906e16:	9830      	s32i.n	a8, a3, 0
			*hex_num += (num_str[i] - '0');
  906e18:	2a2000        	l8ui	a10, a2, 0
  906e1b:	288cd0        	addi	a8, a8, -48
  906e1e:	600030        	j	906e52 <db_ascii_to_hex+0x56>
		}
		else if ((num_str[i] >= 'A') && (num_str[i] <= 'F'))
  906e21:	2a8cbf        	addi	a10, a8, -65
  906e24:	0a0a47        	extui	a10, a10, 0, 8
  906e27:	6fa611        	bgeui	a10, 6, 906e3c <db_ascii_to_hex+0x40>
		{
			*hex_num <<= 4;
  906e2a:	8830      	l32i.n	a8, a3, 0
  906e2c:	0c8811        	slli	a8, a8, 4
  906e2f:	9830      	s32i.n	a8, a3, 0
			*hex_num += (num_str[i] - 'A' + 10);
  906e31:	2a2000        	l8ui	a10, a2, 0
  906e34:	288cc9        	addi	a8, a8, -55
  906e37:	600017        	j	906e52 <db_ascii_to_hex+0x56>
  906e3a:	000028        	mull	a0, a0, a0
		}
		else if ((num_str[i] >= 'a') && (num_str[i] <= 'f'))
  906e3d:	8c9f      	l32i.n	a12, a9, 60
  906e3f:	080847        	extui	a8, a8, 0, 8
  906e42:	6f861c        	bgeui	a8, 6, 906e62 <db_ascii_to_hex+0x66>
		{
			*hex_num <<= 4;
  906e45:	8830      	l32i.n	a8, a3, 0
  906e47:	0c8811        	slli	a8, a8, 4
  906e4a:	9830      	s32i.n	a8, a3, 0
			*hex_num += (num_str[i] - 'a' + 10);
  906e4c:	2a2000        	l8ui	a10, a2, 0
  906e4f:	288ca9        	addi	a8, a8, -87
  906e52:	a8a8      	add.n	a8, a10, a8
  906e54:	9830      	s32i.n	a8, a3, 0
  906e56:	b122      	addi.n	a2, a2, 1
static int db_ascii_to_hex(char *num_str, unsigned long *hex_num)
{
	int i = 0;

	*hex_num = 0;
	while (num_str[i])
  906e58:	282000        	l8ui	a8, a2, 0
  906e5b:	658fa9        	bnez	a8, 906e08 <db_ascii_to_hex+0xc>
		{
			return -1;
		}
		i++;
	}
	return 0;
  906e5e:	d280      	mov.n	a2, a8
  906e60:	d10f      	retw.n
			*hex_num <<= 4;
			*hex_num += (num_str[i] - 'a' + 10);
		}
		else
		{
			return -1;
  906e62:	c72f      	movi.n	a2, -1
		}
		i++;
	}
	return 0;
}
  906e64:	d10f      	retw.n
	...

00906e68 <db_hex_to_ascii>:
	}
	return 0;
}

static int db_hex_to_ascii(unsigned long hex_num, char *num_str)
{
  906e68:	6c1004        	entry	a1, 32
  906e6b:	d930      	mov.n	a9, a3
  906e6d:	c1bc      	movi.n	a11, 28
	unsigned long four_bits;

	for (i=7; i>=0; i--)
	{
		four_bits = (hex_num >> i*4) & 0xf;
		if (four_bits < 10)
  906e6f:	2c0a09        	movi	a12, 9
static int db_hex_to_ascii(unsigned long hex_num, char *num_str)
{
	int i;
	unsigned long four_bits;

	for (i=7; i>=0; i--)
  906e72:	2a0a08        	movi	a10, 8
  906e75:	6da81e        	loop	a10, 906e97 <db_hex_to_ascii+0x2f>
	{
		four_bits = (hex_num >> i*4) & 0xf;
  906e78:	00b004        	ssr	a11
  906e7b:	020819        	srl	a8, a2
  906e7e:	080843        	extui	a8, a8, 0, 4
		if (four_bits < 10)
  906e81:	78c307        	bltu	a12, a8, 906e8c <db_hex_to_ascii+0x24>
		{
			num_str[7-i] = four_bits + '0';
  906e84:	288c30        	addi	a8, a8, 48
  906e87:	600004        	j	906e8f <db_hex_to_ascii+0x27>
  906e8a:	000028        	mull	a0, a0, a0
		}
		else
		{
			num_str[7-i] = four_bits - 10 + 'A';
  906e8d:	8c37      	l32i.n	a12, a3, 28
  906e8f:	289400        	s8i	a8, a9, 0
  906e92:	2bbcfc        	addi	a11, a11, -4
  906e95:	b199      	addi.n	a9, a9, 1
		}
	}
	num_str[8] = 0;
  906e97:	c080      	movi.n	a8, 0
  906e99:	283408        	s8i	a8, a3, 8
	return 0;
}
  906e9c:	c020      	movi.n	a2, 0
  906e9e:	d10f      	retw.n

00906ea0 <db_help_cmd>:

int db_help_cmd(char *cmd, char *param1, char *param2, char *param3)
{
  906ea0:	6c1004        	entry	a1, 32
	int i;

	i = 0;

	A_PRINTF("%s %s\n", ATH_DEBUGGER_VERSION_STR, ATH_COMMAND_LIST_STR);
  906ea3:	1468bf        	l32r	a4, 8e11a0 <_bss_end+0x3ce290>
  906ea6:	1c693d        	l32r	a12, 8e139c <_bss_end+0x3ce48c>
  906ea9:	224212        	l32i	a2, a4, 72
  906eac:	1b693e        	l32r	a11, 8e13a4 <_bss_end+0x3ce494>
  906eaf:	1a693f        	l32r	a10, 8e13ac <_bss_end+0x3ce49c>
  906eb2:	0b2000        	callx8	a2
  906eb5:	136940        	l32r	a3, 8e13b8 <_bss_end+0x3ce4a8>

int db_help_cmd(char *cmd, char *param1, char *param2, char *param3)
{
	int i;

	i = 0;
  906eb8:	c020      	movi.n	a2, 0

	A_PRINTF("%s %s\n", ATH_DEBUGGER_VERSION_STR, ATH_COMMAND_LIST_STR);

	while (command_table[i].cmd_func)
  906eba:	600010        	j	906ece <db_help_cmd+0x2e>
	{
		A_PRINTF("%s\t%s\n\r", command_table[i].cmd_str,
  906ebd:	8c31      	l32i.n	a12, a3, 4
  906ebf:	8b30      	l32i.n	a11, a3, 0
  906ec1:	284212        	l32i	a8, a4, 72
  906ec4:	1a6941        	l32r	a10, 8e13c8 <_bss_end+0x3ce4b8>
				       command_table[i].help_str);
		i++;
  906ec7:	b122      	addi.n	a2, a2, 1

	A_PRINTF("%s %s\n", ATH_DEBUGGER_VERSION_STR, ATH_COMMAND_LIST_STR);

	while (command_table[i].cmd_func)
	{
		A_PRINTF("%s\t%s\n\r", command_table[i].cmd_str,
  906ec9:	0b8000        	callx8	a8
  906ecc:	bc33      	addi.n	a3, a3, 12

	i = 0;

	A_PRINTF("%s %s\n", ATH_DEBUGGER_VERSION_STR, ATH_COMMAND_LIST_STR);

	while (command_table[i].cmd_func)
  906ece:	8832      	l32i.n	a8, a3, 8
  906ed0:	658fe9        	bnez	a8, 906ebd <db_help_cmd+0x1d>
		A_PRINTF("%s\t%s\n\r", command_table[i].cmd_str,
				       command_table[i].help_str);
		i++;
	}
	return i;
}
  906ed3:	d10f      	retw.n
  906ed5:	000000        	ill

00906ed8 <db_cmd_starthtc>:
#endif
	return 1;
}

static int db_cmd_starthtc(char *cmd, char *param1, char *param2, char *param3)
{
  906ed8:	6c1004        	entry	a1, 32
    extern htc_handle_t htc_handle;
    HTC_Ready(htc_handle);
  906edb:	186942        	l32r	a8, 8e13e4 <_bss_end+0x3ce4d4>
  906ede:	1268bf        	l32r	a2, 8e11dc <_bss_end+0x3ce2cc>
  906ee1:	8a80      	l32i.n	a10, a8, 0
  906ee3:	222281        	l32i	a2, a2, 0x204
  906ee6:	0b2000        	callx8	a2
}
  906ee9:	d10f      	retw.n
	...

00906eec <db_cmd_memcmp>:
#endif
#endif /* #if defined(PROJECT_K2) */

/* Memory Comparison */
static int db_cmd_memcmp(char *cmd, char *param1, char *param2, char *param3)
{
  906eec:	6c1006        	entry	a1, 48
	unsigned long       addr1, addr2, len;
	A_UINT8             *buf1, *buf2;

	if (db_ascii_to_hex(param1, &addr1) != -1 &&
  906eef:	2b1c08        	addi	a11, a1, 8
  906ef2:	033a02        	or	a10, a3, a3
  906ef5:	5bffc1        	call8	906dfc <db_ascii_to_hex>
  906ef8:	68a045        	beqi	a10, -1, 906f41 <db_cmd_memcmp+0x55>
	    db_ascii_to_hex(param2, &addr2) != -1 &&
  906efb:	2b1c04        	addi	a11, a1, 4
  906efe:	044a02        	or	a10, a4, a4
  906f01:	5bffbe        	call8	906dfc <db_ascii_to_hex>
static int db_cmd_memcmp(char *cmd, char *param1, char *param2, char *param3)
{
	unsigned long       addr1, addr2, len;
	A_UINT8             *buf1, *buf2;

	if (db_ascii_to_hex(param1, &addr1) != -1 &&
  906f04:	68a039        	beqi	a10, -1, 906f41 <db_cmd_memcmp+0x55>
	    db_ascii_to_hex(param2, &addr2) != -1 &&
	    db_ascii_to_hex(param3, &len) != -1 &&
  906f07:	011b02        	or	a11, a1, a1
  906f0a:	055a02        	or	a10, a5, a5
  906f0d:	5bffbb        	call8	906dfc <db_ascii_to_hex>
{
	unsigned long       addr1, addr2, len;
	A_UINT8             *buf1, *buf2;

	if (db_ascii_to_hex(param1, &addr1) != -1 &&
	    db_ascii_to_hex(param2, &addr2) != -1 &&
  906f10:	68a02d        	beqi	a10, -1, 906f41 <db_cmd_memcmp+0x55>
	    db_ascii_to_hex(param3, &len) != -1 &&
	    addr1 != addr2 && addr1%4 == 0 && addr2%4 == 0 && len%4 == 0)
  906f13:	8a12      	l32i.n	a10, a1, 8
  906f15:	8b11      	l32i.n	a11, a1, 4
	unsigned long       addr1, addr2, len;
	A_UINT8             *buf1, *buf2;

	if (db_ascii_to_hex(param1, &addr1) != -1 &&
	    db_ascii_to_hex(param2, &addr2) != -1 &&
	    db_ascii_to_hex(param3, &len) != -1 &&
  906f17:	7ba126        	beq	a10, a11, 906f41 <db_cmd_memcmp+0x55>
	    addr1 != addr2 && addr1%4 == 0 && addr2%4 == 0 && len%4 == 0)
  906f1a:	0ba202        	or	a2, a10, a11
  906f1d:	020241        	extui	a2, a2, 0, 2
  906f20:	cd2d      	bnez.n	a2, 906f41 <db_cmd_memcmp+0x55>
  906f22:	8c10      	l32i.n	a12, a1, 0
  906f24:	0c0241        	extui	a2, a12, 0, 2
  906f27:	cd26      	bnez.n	a2, 906f41 <db_cmd_memcmp+0x55>
	{
		buf1 = (A_UINT8 *)addr1;
		buf2 = (A_UINT8 *)addr2;        ;

		A_PRINTF("memcmp(buf1, buf2, len) = %d\n\r", A_MEMCMP(buf1, buf2, len));
  906f29:	1868bf        	l32r	a8, 8e1228 <_bss_end+0x3ce318>
  906f2c:	238212        	l32i	a3, a8, 72
  906f2f:	8887      	l32i.n	a8, a8, 28
  906f31:	0b8000        	callx8	a8
  906f34:	dba0      	mov.n	a11, a10
  906f36:	1a6943        	l32r	a10, 8e1444 <_bss_end+0x3ce534>
  906f39:	0b3000        	callx8	a3
		return 0;
  906f3c:	d10f      	retw.n
  906f3e:	000000        	ill
	}

	db_incorect_format();
  906f41:	5bff9f        	call8	906dc0 <db_incorect_format>
	return -1;
  906f44:	c72f      	movi.n	a2, -1
}
  906f46:	d10f      	retw.n

00906f48 <db_cmd_memdump>:

/* Memory Dump */
static int db_cmd_memdump(char *cmd, char *param1, char *param2, char *param3)
{
  906f48:	6c1006        	entry	a1, 48
	unsigned long       addr1, addr2;

	if (db_ascii_to_hex(param1, &addr1) != -1 && db_ascii_to_hex(param2, &addr2) != -1 && addr1 < addr2 && addr1%4 == 0)
  906f4b:	2b1c04        	addi	a11, a1, 4
  906f4e:	033a02        	or	a10, a3, a3
  906f51:	5bffaa        	call8	906dfc <db_ascii_to_hex>
  906f54:	69a002        	bnei	a10, -1, 906f5a <db_cmd_memdump+0x12>
  906f57:	600082        	j	906fdd <db_cmd_memdump+0x95>
  906f5a:	db10      	mov.n	a11, a1
  906f5c:	da40      	mov.n	a10, a4
  906f5e:	5bffa7        	call8	906dfc <db_ascii_to_hex>
  906f61:	68a078        	beqi	a10, -1, 906fdd <db_cmd_memdump+0x95>
  906f64:	8211      	l32i.n	a2, a1, 4
  906f66:	261200        	l32i	a6, a1, 0
  906f69:	762b70        	bgeu	a2, a6, 906fdd <db_cmd_memdump+0x95>
  906f6c:	020341        	extui	a3, a2, 0, 2
  906f6f:	65306a        	bnez	a3, 906fdd <db_cmd_memdump+0x95>
  906f72:	1468bf        	l32r	a4, 8e1270 <_bss_end+0x3ce360>
{
	unsigned int i = 0;
	const char *tmp;

	do {
		if (i == 0) {
  906f75:	cc3b      	bnez.n	a3, 906f84 <db_cmd_memdump+0x3c>
			A_PRINTF("\n\r%06x: ", mem1);
  906f77:	254212        	l32i	a5, a4, 72
  906f7a:	1a6944        	l32r	a10, 8e148c <_bss_end+0x3ce57c>
  906f7d:	db20      	mov.n	a11, a2
  906f7f:	0b5000        	callx8	a5
  906f82:	d520      	mov.n	a5, a2
			tmp = mem1;
		}

		A_PRINTF("%04x ", *(uint16_t *)mem1);
  906f84:	2b2100        	l16ui	a11, a2, 0
  906f87:	274212        	l32i	a7, a4, 72
  906f8a:	1a6945        	l32r	a10, 8e14a0 <_bss_end+0x3ce590>

		mem1 += 2;
		i++;
  906f8d:	b133      	addi.n	a3, a3, 1
		if (i == 0) {
			A_PRINTF("\n\r%06x: ", mem1);
			tmp = mem1;
		}

		A_PRINTF("%04x ", *(uint16_t *)mem1);
  906f8f:	0b7000        	callx8	a7

		mem1 += 2;
  906f92:	222c02        	addi	a2, a2, 2
		i++;

		if (i == 8) {
  906f95:	693833        	bnei	a3, 8, 906fcc <db_cmd_memdump+0x84>
			A_PRINTF(" ");
  906f98:	234212        	l32i	a3, a4, 72
  906f9b:	1a6946        	l32r	a10, 8e14b4 <_bss_end+0x3ce5a4>
			do {
				if (*tmp > 0x20 && *tmp < 0x7e)
  906f9e:	270a5c        	movi	a7, 92

		mem1 += 2;
		i++;

		if (i == 8) {
			A_PRINTF(" ");
  906fa1:	0b3000        	callx8	a3
			do {
				if (*tmp > 0x20 && *tmp < 0x7e)
  906fa4:	2b5000        	l8ui	a11, a5, 0
  906fa7:	23bcdf        	addi	a3, a11, -33
  906faa:	030347        	extui	a3, a3, 0, 8
  906fad:	73730b        	bltu	a7, a3, 906fbc <db_cmd_memdump+0x74>
					A_PRINTF("%c", *tmp);
  906fb0:	234212        	l32i	a3, a4, 72
  906fb3:	1a6947        	l32r	a10, 8e14d0 <_bss_end+0x3ce5c0>
  906fb6:	0b3000        	callx8	a3
  906fb9:	600008        	j	906fc5 <db_cmd_memdump+0x7d>
				else
					A_PRINTF(".");
  906fbc:	234212        	l32i	a3, a4, 72
  906fbf:	1a6948        	l32r	a10, 8e14e0 <_bss_end+0x3ce5d0>
  906fc2:	0b3000        	callx8	a3
				tmp++;
  906fc5:	b155      	addi.n	a5, a5, 1
			} while (tmp < mem1);
  906fc7:	7253d9        	bltu	a5, a2, 906fa4 <db_cmd_memdump+0x5c>
			i = 0;
  906fca:	c030      	movi.n	a3, 0
		}
	} while (mem1 < mem2);
  906fcc:	7623a5        	bltu	a2, a6, 906f75 <db_cmd_memdump+0x2d>
	A_PRINTF("\n\r");
  906fcf:	224212        	l32i	a2, a4, 72
  906fd2:	1a6949        	l32r	a10, 8e14f8 <_bss_end+0x3ce5e8>
  906fd5:	0b2000        	callx8	a2
	unsigned long       addr1, addr2;

	if (db_ascii_to_hex(param1, &addr1) != -1 && db_ascii_to_hex(param2, &addr2) != -1 && addr1 < addr2 && addr1%4 == 0)
	{
		db_print_dump((const char *)addr1, (const char *)addr2);
		return 0;
  906fd8:	c020      	movi.n	a2, 0
  906fda:	d10f      	retw.n
  906fdc:	005bff        	excw
	}

	db_incorect_format();
  906fdf:	78c72f        	bbci	a12, 24, 907012 <db_str_cmd+0x2e>
	return -1;
}
  906fe2:	d10f      	retw.n

00906fe4 <db_str_cmd>:
	db_incorect_format();
	return -1;
}

static int db_str_cmd(char *cmd, char *param1, char *param2, char *param3)
{
  906fe4:	6c100a        	entry	a1, 80
	unsigned long val;
	unsigned long addr;
	char val_str[20];
	char addr_str[20];

	if ((A_STRLEN(param2) > 0) &&
  906fe7:	1568bf        	l32r	a5, 8e12e4 <_bss_end+0x3ce3d4>
  906fea:	da40      	mov.n	a10, a4
  906fec:	285266        	l32i	a8, a5, 0x198
  906fef:	0b8000        	callx8	a8
  906ff2:	6ba102        	bgei	a10, 1, 906ff8 <db_str_cmd+0x14>
  906ff5:	6000a0        	j	907099 <db_str_cmd+0xb5>
	    (db_ascii_to_hex(param1, &addr) != -1) &&
  906ff8:	2b1c28        	addi	a11, a1, 40
  906ffb:	da30      	mov.n	a10, a3
  906ffd:	5bff7f        	call8	906dfc <db_ascii_to_hex>
	unsigned long val;
	unsigned long addr;
	char val_str[20];
	char addr_str[20];

	if ((A_STRLEN(param2) > 0) &&
  907000:	69a002        	bnei	a10, -1, 907006 <db_str_cmd+0x22>
  907003:	600092        	j	907099 <db_str_cmd+0xb5>
	    (db_ascii_to_hex(param1, &addr) != -1) &&
	    (db_ascii_to_hex(param2, &val) != -1))
  907006:	2b1c2c        	addi	a11, a1, 44
  907009:	da40      	mov.n	a10, a4
  90700b:	5bff7c        	call8	906dfc <db_ascii_to_hex>
	unsigned long addr;
	char val_str[20];
	char addr_str[20];

	if ((A_STRLEN(param2) > 0) &&
	    (db_ascii_to_hex(param1, &addr) != -1) &&
  90700e:	69a002        	bnei	a10, -1, 907014 <db_str_cmd+0x30>
  907011:	600084        	j	907099 <db_str_cmd+0xb5>
	    (db_ascii_to_hex(param2, &val) != -1))
	{
		if (strcmp(cmd, "STR") == 0)
  907014:	1b694a        	l32r	a11, 8e153c <_bss_end+0x3ce62c>
  907017:	da20      	mov.n	a10, a2
  907019:	5b7d51        	call8	8e6560 <strcmp>
  90701c:	cda1      	bnez.n	a10, 907031 <db_str_cmd+0x4d>
		{
			addr &= 0xfffffffc;
  90701e:	821a      	l32i.n	a2, a1, 40
  907020:	c78c      	movi.n	a8, -4
  907022:	028801        	and	a8, a8, a2
			iowrite32(addr, val);
  907025:	821b      	l32i.n	a2, a1, 44
	    (db_ascii_to_hex(param1, &addr) != -1) &&
	    (db_ascii_to_hex(param2, &val) != -1))
	{
		if (strcmp(cmd, "STR") == 0)
		{
			addr &= 0xfffffffc;
  907027:	981a      	s32i.n	a8, a1, 40
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  907029:	0c0200        	memw
  90702c:	9280      	s32i.n	a2, a8, 0
  90702e:	600044        	j	907076 <db_str_cmd+0x92>
			iowrite32(addr, val);
		}

		else if (strcmp(cmd, "STRH") == 0)
  907031:	1b694b        	l32r	a11, 8e1560 <generic_hif_module_install+0x18>
  907034:	da20      	mov.n	a10, a2
  907036:	5b7d4a        	call8	8e6560 <strcmp>
  907039:	cda3      	bnez.n	a10, 907050 <db_str_cmd+0x6c>
		{
			addr &= 0xfffffffe;
  90703b:	821a      	l32i.n	a2, a1, 40
  90703d:	c78e      	movi.n	a8, -2
  90703f:	028801        	and	a8, a8, a2
			//*(volatile unsigned short *)(addr & 0xfffffffe) = (unsigned short)val;
			iowrite16(addr, val);
  907042:	221117        	l16ui	a2, a1, 46
			iowrite32(addr, val);
		}

		else if (strcmp(cmd, "STRH") == 0)
		{
			addr &= 0xfffffffe;
  907045:	981a      	s32i.n	a8, a1, 40
	*(volatile uint8_t *) addr = b;
}

static inline void iowrite16(volatile uint32_t addr, const uint16_t b)
{
	*(volatile uint16_t *) addr = b;
  907047:	0c0200        	memw
  90704a:	228500        	s16i	a2, a8, 0
  90704d:	600025        	j	907076 <db_str_cmd+0x92>
			//*(volatile unsigned short *)(addr & 0xfffffffe) = (unsigned short)val;
			iowrite16(addr, val);
		}
		else if (strcmp(cmd, "STRB") == 0)
  907050:	1b694c        	l32r	a11, 8e1580 <athos_indirection_table_install+0xc>
  907053:	da20      	mov.n	a10, a2
  907055:	5b7d42        	call8	8e6560 <strcmp>
  907058:	cdaa      	bnez.n	a10, 907076 <db_str_cmd+0x92>
		{
			if( addr & 0x00f00000 )
  90705a:	891a      	l32i.n	a9, a1, 40
  90705c:	12694d        	l32r	a2, 8e1590 <athos_indirection_table_install+0x1c>
  90705f:	881b      	l32i.n	a8, a1, 44
  907061:	729003        	bnone	a9, a2, 907068 <db_str_cmd+0x84>
  907064:	600005        	j	90706d <db_str_cmd+0x89>
  907067:	00c023        	excw
				iowrite8(addr, val);
			else
				iowrite8(addr^3, val);
  90706a:	029903        	xor	a9, a9, a2
  90706d:	080847        	extui	a8, a8, 0, 8
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  907070:	0c0200        	memw
  907073:	289400        	s8i	a8, a9, 0
			//*(volatile unsigned char *)addr = (unsigned char)val;
		}

		db_hex_to_ascii(val, val_str);
  907076:	8a1b      	l32i.n	a10, a1, 44
  907078:	2b1c14        	addi	a11, a1, 20
  90707b:	5bff7b        	call8	906e68 <db_hex_to_ascii>
		db_hex_to_ascii(addr, addr_str);
  90707e:	8a1a      	l32i.n	a10, a1, 40
  907080:	db10      	mov.n	a11, a1
  907082:	5bff79        	call8	906e68 <db_hex_to_ascii>

		A_PRINTF("%s : %s\n\r", addr_str, val_str);
  907085:	1a694e        	l32r	a10, 8e15c0 <athos_indirection_table_install+0x4c>
  907088:	225212        	l32i	a2, a5, 72
  90708b:	2c1c14        	addi	a12, a1, 20
  90708e:	011b02        	or	a11, a1, a1
  907091:	0b2000        	callx8	a2
		return 0;
  907094:	c020      	movi.n	a2, 0
  907096:	d10f      	retw.n
  907098:	005bff        	excw
	}

	db_incorect_format();
  90709b:	49c72f        	excw
	return -1;
}
  90709e:	d10f      	retw.n

009070a0 <db_ldr_cmd>:
	}
	return i;
}

static int db_ldr_cmd(char *cmd, char *param1, char *param2, char *param3)
{
  9070a0:	6c100a        	entry	a1, 80
	unsigned long val;
	unsigned long addr;
	char val_str[20];
	char addr_str[20];

	if (db_ascii_to_hex(param1, &addr) != -1)
  9070a3:	033a02        	or	a10, a3, a3
  9070a6:	2b1c28        	addi	a11, a1, 40
  9070a9:	5bff54        	call8	906dfc <db_ascii_to_hex>
  9070ac:	d3a0      	mov.n	a3, a10
  9070ae:	68a06f        	beqi	a10, -1, 907121 <db_ldr_cmd+0x81>
	{
		if( addr == 0 )
  9070b1:	831a      	l32i.n	a3, a1, 40
  9070b3:	1568bf        	l32r	a5, 8e13b0 <_bss_end+0x3ce4a0>
  9070b6:	cc3f      	bnez.n	a3, 9070c9 <db_ldr_cmd+0x29>
		{
			A_PRINTF("Error! bad address 0x%08x.\n\r",
  9070b8:	225212        	l32i	a2, a5, 72
  9070bb:	1a694f        	l32r	a10, 8e15f8 <athos_indirection_table_install+0x84>
  9070be:	033b02        	or	a11, a3, a3
  9070c1:	0b2000        	callx8	a2
				 (unsigned long)addr);
			return -1;
  9070c4:	c73f      	movi.n	a3, -1
  9070c6:	60005a        	j	907124 <db_ldr_cmd+0x84>
		}
		if (strcmp(cmd, "LDR") == 0)
  9070c9:	1b6950        	l32r	a11, 8e160c <athos_indirection_table_install+0x98>
  9070cc:	da20      	mov.n	a10, a2
  9070ce:	5b7d24        	call8	8e6560 <strcmp>
  9070d1:	cda0      	bnez.n	a10, 9070e5 <db_ldr_cmd+0x45>
		{
			addr &= 0xfffffffc;
  9070d3:	c72c      	movi.n	a2, -4
  9070d5:	023301        	and	a3, a3, a2
  9070d8:	931a      	s32i.n	a3, a1, 40
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  9070da:	0c0200        	memw
  9070dd:	8430      	l32i.n	a4, a3, 0
  9070df:	60001a        	j	9070fd <db_ldr_cmd+0x5d>
  9070e2:	000000        	ill
			//val = *(unsigned long *)addr;

			val = ioread32(addr);
		}
		else if (strcmp(cmd, "LDRH") == 0)
  9070e5:	1b6951        	l32r	a11, 8e162c <athos_indirection_table_install+0xb8>
  9070e8:	022a02        	or	a10, a2, a2
  9070eb:	5b7d1d        	call8	8e6560 <strcmp>
  9070ee:	ccab      	bnez.n	a10, 9070fd <db_ldr_cmd+0x5d>
		{
			addr &= 0xfffffffe;
  9070f0:	c72e      	movi.n	a2, -2
  9070f2:	023301        	and	a3, a3, a2
	return *(const volatile uint8_t *) addr;
}

static inline uint16_t ioread16(const volatile uint32_t addr)
{
	return *(const volatile uint16_t *) addr;
  9070f5:	243100        	l16ui	a4, a3, 0
  9070f8:	931a      	s32i.n	a3, a1, 40
  9070fa:	04044f        	extui	a4, a4, 0, 16
		}
		else if (strcmp(cmd, "LDRB") == 0)
		{
		}

		db_hex_to_ascii(val, val_str);
  9070fd:	2b1c14        	addi	a11, a1, 20
  907100:	da40      	mov.n	a10, a4
  907102:	5bff59        	call8	906e68 <db_hex_to_ascii>
		db_hex_to_ascii(addr, addr_str);
  907105:	8a1a      	l32i.n	a10, a1, 40
  907107:	db10      	mov.n	a11, a1
  907109:	5bff57        	call8	906e68 <db_hex_to_ascii>

		A_PRINTF("%s : %s\n\r", addr_str, val_str);
  90710c:	1a694e        	l32r	a10, 8e1644 <athos_indirection_table_install+0xd0>
  90710f:	225212        	l32i	a2, a5, 72
  907112:	2c1c14        	addi	a12, a1, 20
  907115:	db10      	mov.n	a11, a1
  907117:	0b2000        	callx8	a2
		return 0;
  90711a:	c030      	movi.n	a3, 0
  90711c:	600004        	j	907124 <db_ldr_cmd+0x84>
  90711f:	00005b        	extui	a0, a0, 16, 12
	}

	db_incorect_format();
  907122:	ff          	.byte 0xff
  907123:	27d230        	l32i	a7, a13, 192
	return -1;
}
  907126:	d10f      	retw.n

00907128 <db_intr_cmd>:
}

uint32_t delay = 0;

static int db_intr_cmd(char *cmd, char *param1, char *param2, char *param3)
{
  907128:	6c1006        	entry	a1, 48
#if SYSTEM_MODULE_INTR
	uint32_t pending_intrs;

	if(strcmp(param1, "read") == 0 )
  90712b:	1b6952        	l32r	a11, 8e1674 <athos_indirection_table_install+0x100>
  90712e:	033a02        	or	a10, a3, a3
  907131:	5b7d0b        	call8	8e6560 <strcmp>
  907134:	65a028        	bnez	a10, 907160 <db_intr_cmd+0x38>
	{
		{
			/* Update snapshot of pending interrupts */

			pending_intrs = A_INTR_GET_INTRPENDING();
  907137:	1268bf        	l32r	a2, 8e1434 <_bss_end+0x3ce524>
  90713a:	2a224f        	l32i	a10, a2, 0x13c
  90713d:	0ba000        	callx8	a10
  907140:	0aa302        	or	a3, a10, a10

			A_PRINTF("intr mask [0x%08x]\n\r", xthal_get_intenable());
  907143:	242212        	l32i	a4, a2, 72
  907146:	5b7e0e        	call8	8e6980 <xthal_get_intenable>
  907149:	dba0      	mov.n	a11, a10
  90714b:	1a6953        	l32r	a10, 8e1698 <athos_indirection_table_install+0x124>
  90714e:	0b4000        	callx8	a4
			A_PRINTF("intr on [0x%08x]\n\r", pending_intrs);
  907151:	1a6954        	l32r	a10, 8e16a4 <athos_indirection_table_install+0x130>
  907154:	222212        	l32i	a2, a2, 72
  907157:	db30      	mov.n	a11, a3
  907159:	0b2000        	callx8	a2
  90715c:	60009d        	j	9071fd <db_intr_cmd+0xd5>
  90715f:	001b69        	excw
		}
	}
	else if (strcmp(param1, "timer") == 0 )
  907162:	55da30        	call4	97da24 <_etext+0x6e7f3>
  907165:	5b7cfe        	call8	8e6560 <strcmp>
  907168:	65a07c        	bnez	a10, 9071e8 <db_intr_cmd+0xc0>
	{
		uint32_t data = 0;

		if (strcmp(param2, "on") == 0 )
  90716b:	1b6956        	l32r	a11, 8e16c4 <athos_indirection_table_install+0x150>
			A_PRINTF("intr on [0x%08x]\n\r", pending_intrs);
		}
	}
	else if (strcmp(param1, "timer") == 0 )
	{
		uint32_t data = 0;
  90716e:	9a10      	s32i.n	a10, a1, 0

		if (strcmp(param2, "on") == 0 )
  907170:	da40      	mov.n	a10, a4
  907172:	5b7cfb        	call8	8e6560 <strcmp>
  907175:	65a013        	bnez	a10, 90718c <db_intr_cmd+0x64>
		{
			/* TODO: this part is probably dead. */
			pending_intrs = A_INTR_GET_INTRENABLE()|CMNOS_IMASK_XTTIMER;
  907178:	1468bf        	l32r	a4, 8e1474 <_bss_end+0x3ce564>
  90717b:	220a02        	movi	a2, 2
  90717e:	2a424d        	l32i	a10, a4, 0x134
  907181:	0ba000        	callx8	a10
  907184:	02a202        	or	a2, a10, a2
  907187:	600019        	j	9071a4 <db_intr_cmd+0x7c>
  90718a:	00001b        	sra	a0, a0
			A_INTR_SET_INTRENABLE(pending_intrs);
			A_PRINTF("- intr [0x%08x]\n\r", pending_intrs);
		}
		else if ( strcmp(param2, "off") == 0 )
  90718d:	6958da        	bnei	a5, 8, 90716b <db_intr_cmd+0x43>
  907190:	405b7c        	excw
  907193:	f3          	.byte 0xf3
  907194:	cea1      	bnez.n	a10, 9071b9 <db_intr_cmd+0x91>
		{
			pending_intrs = A_INTR_GET_INTRENABLE()&(~CMNOS_IMASK_XTTIMER);
  907196:	1468bf        	l32r	a4, 8e1494 <_bss_end+0x3ce584>
  907199:	c72d      	movi.n	a2, -3
  90719b:	2a424d        	l32i	a10, a4, 0x134
  90719e:	0ba000        	callx8	a10
  9071a1:	02a201        	and	a2, a10, a2
			A_INTR_SET_INTRENABLE(pending_intrs);
  9071a4:	23424e        	l32i	a3, a4, 0x138
  9071a7:	da20      	mov.n	a10, a2
  9071a9:	0b3000        	callx8	a3
			A_PRINTF("- intr [0x%08x]\n\r", pending_intrs);
  9071ac:	db20      	mov.n	a11, a2
  9071ae:	234212        	l32i	a3, a4, 72
  9071b1:	1a6957        	l32r	a10, 8e1710 <athos_indirection_table_install+0x19c>
  9071b4:	600029        	j	9071e1 <db_intr_cmd+0xb9>
  9071b7:	0000db        	excw
            
		}
		else if( db_ascii_to_hex(param2, &data)==0 )
  9071ba:	10da40        	l32r	a0, 8fdabc <memset+0x16c74>
  9071bd:	5bff0f        	call8	906dfc <db_ascii_to_hex>
  9071c0:	cfa9      	bnez.n	a10, 9071fd <db_intr_cmd+0xd5>
		{
			if( data>=0 && data <=10 )
  9071c2:	8410      	l32i.n	a4, a1, 0
  9071c4:	c03a      	movi.n	a3, 10
  9071c6:	126959        	l32r	a2, 8e172c <athos_indirection_table_install+0x1b8>
  9071c9:	743305        	bltu	a3, a4, 9071d2 <db_intr_cmd+0xaa>
				delay = data;
  9071cc:	9420      	s32i.n	a4, a2, 0
  9071ce:	600004        	j	9071d6 <db_intr_cmd+0xae>
  9071d1:	00c033        	excw
			else
				delay = 3;
  9071d4:	9320      	s32i.n	a3, a2, 0
            
			A_PRINTF("==>set cb to %d seconds \n\r", delay);
  9071d6:	1368bf        	l32r	a3, 8e14d4 <_bss_end+0x3ce5c4>
  9071d9:	8b20      	l32i.n	a11, a2, 0
  9071db:	233212        	l32i	a3, a3, 72
  9071de:	1a695a        	l32r	a10, 8e1748 <athos_indirection_table_install+0x1d4>
  9071e1:	0b3000        	callx8	a3
  9071e4:	600015        	j	9071fd <db_intr_cmd+0xd5>
  9071e7:	001268        	excw
		}

	}
	else
	{
		A_PRINTF("\tintr read - read the interrenable status\n\r");
  9071ea:	bf1a      	addi.n	a10, a1, 15
  9071ec:	695b23        	bnei	a5, 16, 907213 <db_wdt_cmd+0xf>
  9071ef:	22120b        	l32i	a2, a1, 44
  9071f2:	30001a        	excw
		A_PRINTF("\tintr timer on/off/tick - timer attach on/off/ticks\n\r");
  9071f5:	695c22        	bnei	a5, 32, 90721b <db_wdt_cmd+0x17>
  9071f8:	22120b        	l32i	a2, a1, 44
  9071fb:	2000c0        	l8ui	a0, a0, 192

	}

#endif //#if SYSTEM_MODULE_INTR
	return 0;
}
  9071fe:	20d10f        	l16ui	a0, a13, 30
  907201:	000000        	ill

00907204 <db_wdt_cmd>:
    extern htc_handle_t htc_handle;
    HTC_Ready(htc_handle);
}

static int db_wdt_cmd(char *cmd, char *param1, char *param2, char *param3)
{
  907204:	6c1006        	entry	a1, 48
        if ( strcmp(param1, "rst") == 0 )
  907207:	1b695d        	l32r	a11, 8e177c <athos_indirection_table_install+0x208>
  90720a:	033a02        	or	a10, a3, a3
  90720d:	5b7cd4        	call8	8e6560 <strcmp>
  907210:	cda0      	bnez.n	a10, 907224 <db_wdt_cmd+0x20>
        {
		A_PRINTF(" reseting...\n\n\r");
  907212:	1368bf        	l32r	a3, 8e1510 <_bss_end+0x3ce600>
  907215:	1a695e        	l32r	a10, 8e1790 <athos_indirection_table_install+0x21c>
  907218:	223212        	l32i	a2, a3, 72
  90721b:	0b2000        	callx8	a2
		A_WDT_RESET();
  90721e:	22325d        	l32i	a2, a3, 0x174
  907221:	600024        	j	907249 <db_wdt_cmd+0x45>
        }
        else if( strcmp(param1, "on") == 0 )
  907224:	1b6956        	l32r	a11, 8e177c <athos_indirection_table_install+0x208>
  907227:	da30      	mov.n	a10, a3
  907229:	5b7ccd        	call8	8e6560 <strcmp>
  90722c:	cca9      	bnez.n	a10, 907239 <db_wdt_cmd+0x35>
        {
		A_WDT_ENABLE();
  90722e:	1268bf        	l32r	a2, 8e152c <_bss_end+0x3ce61c>
  907231:	222259        	l32i	a2, a2, 0x164
  907234:	600011        	j	907249 <db_wdt_cmd+0x45>
  907237:	00001b        	sra	a0, a0
        }
        else if (strcmp(param1, "off") == 0 )
  90723a:	6958da        	bnei	a5, 8, 907218 <db_wdt_cmd+0x14>
  90723d:	305b7c        	excw
  907240:	c8cc      	beqz.n	a12, 907250 <db_wdt_cmd+0x4c>
  907242:	ab12      	add.n	a2, a1, a11
        {
		A_WDT_DISABLE();
  907244:	68bf22        	beqi	a11, 0x100, 90726a <db_wdt_cmd+0x66>
  907247:	225a0b        	movi	a2, 0x50b
  90724a:	2000d1        	l8ui	a0, a0, 209
  90724d:	0f0000        	callx12	a0
        }
        else if ( strcmp(param1, "boot") == 0 )
  907250:	1b695f        	l32r	a11, 8e17cc <athos_indirection_table_install+0x258>
  907253:	da30      	mov.n	a10, a3
  907255:	5b7cc2        	call8	8e6560 <strcmp>
  907258:	cea4      	bnez.n	a10, 907280 <db_wdt_cmd+0x7c>
        {
		A_PRINTF("Last BOOT is ");
  90725a:	1368bf        	l32r	a3, 8e1558 <generic_hif_module_install+0x10>
  90725d:	1a6960        	l32r	a10, 8e17e0 <athos_indirection_table_install+0x26c>
  907260:	223212        	l32i	a2, a3, 72
  907263:	0b2000        	callx8	a2
		if (ENUM_WDT_BOOT == A_WDT_LASTBOOT() )
  907266:	2a325e        	l32i	a10, a3, 0x178
  907269:	0ba000        	callx8	a10
  90726c:	233212        	l32i	a3, a3, 72
  90726f:	69a105        	bnei	a10, 1, 907278 <db_wdt_cmd+0x74>
			A_PRINTF("wdt");
  907272:	1a6961        	l32r	a10, 8e17f8 <athos_indirection_table_install+0x284>
  907275:	600002        	j	90727b <db_wdt_cmd+0x77>
		else
			A_PRINTF("normal boot");
  907278:	1a6962        	l32r	a10, 8e1800 <athos_indirection_table_install+0x28c>
  90727b:	0b3000        	callx8	a3
  90727e:	d10f      	retw.n
        }
        else if (strcmp(param1, "loop") == 0 )
  907280:	1b6963        	l32r	a11, 8e180c <athos_indirection_table_install+0x298>
  907283:	da30      	mov.n	a10, a3
  907285:	5b7cb6        	call8	8e6560 <strcmp>
  907288:	ceac      	bnez.n	a10, 9072b8 <db_wdt_cmd+0xb4>
        {
		T_WDT_CMD wdt_cmd;
		uint32_t time_offset;
		A_PRINTF(" doing the wdt reseting...");
  90728a:	1368bf        	l32r	a3, 8e1588 <athos_indirection_table_install+0x14>
  90728d:	1a6964        	l32r	a10, 8e1820 <athos_indirection_table_install+0x2ac>
  907290:	223212        	l32i	a2, a3, 72
  907293:	0b2000        	callx8	a2

		if( db_ascii_to_hex(param2, &time_offset)!=0 )
  907296:	b81b      	addi.n	a11, a1, 8
  907298:	da40      	mov.n	a10, a4
  90729a:	5bfed8        	call8	906dfc <db_ascii_to_hex>
		{
			if( time_offset < 0 || time_offset >0xffffffff )
				time_offset = 0xffffff;
		}
		A_PRINTF(" (wdt tick: 0x%08x...\n\n\r", time_offset);
  90729d:	8b12      	l32i.n	a11, a1, 8
  90729f:	223212        	l32i	a2, a3, 72
  9072a2:	1a6965        	l32r	a10, 8e1838 <athos_indirection_table_install+0x2c4>
  9072a5:	0b2000        	callx8	a2
		wdt_cmd.cmd = WDT_TIMEOUT;
		wdt_cmd.timeout = time_offset;

		A_WDT_SET(wdt_cmd);
  9072a8:	2b1202        	l32i	a11, a1, 8
  9072ab:	22325b        	l32i	a2, a3, 0x16c
  9072ae:	2a0a01        	movi	a10, 1
  9072b1:	0b2000        	callx8	a2
  9072b4:	63fffc        	j	9072b4 <db_wdt_cmd+0xb0>
  9072b7:	001b69        	excw
		while(1) ;
        }
        else if (strcmp(param1, "noloop") == 0 )
  9072ba:	66da30        	bltz	a13, 906cee <_buf_pool_static_init+0x16>
  9072bd:	5b7ca8        	call8	8e6560 <strcmp>
  9072c0:	cea9      	bnez.n	a10, 9072ed <db_wdt_cmd+0xe9>
        {
		T_WDT_CMD wdt_cmd;
		uint32_t time_offset;
		A_PRINTF(" doing the wdt reseting...");
  9072c2:	1368bf        	l32r	a3, 8e15c0 <athos_indirection_table_install+0x4c>
  9072c5:	1a6964        	l32r	a10, 8e1858 <athos_indirection_table_install+0x2e4>
  9072c8:	223212        	l32i	a2, a3, 72
  9072cb:	0b2000        	callx8	a2

		if( db_ascii_to_hex(param3, &time_offset)!=0 )
  9072ce:	b81b      	addi.n	a11, a1, 8
  9072d0:	da50      	mov.n	a10, a5
  9072d2:	5bfeca        	call8	906dfc <db_ascii_to_hex>
		{
			if( time_offset < 0 || time_offset >0xffffffff )
				time_offset = 0xffffff;
		}
		A_PRINTF(" (wdt tick: 0x%08x...\n\n\r", time_offset);
  9072d5:	8b12      	l32i.n	a11, a1, 8
  9072d7:	223212        	l32i	a2, a3, 72
  9072da:	1a6965        	l32r	a10, 8e1870 <athos_indirection_table_install+0x2fc>
  9072dd:	0b2000        	callx8	a2

		wdt_cmd.cmd = WDT_TIMEOUT;
		wdt_cmd.timeout = time_offset;

		A_WDT_SET(wdt_cmd);
  9072e0:	8b12      	l32i.n	a11, a1, 8
  9072e2:	22325b        	l32i	a2, a3, 0x16c
  9072e5:	c0a1      	movi.n	a10, 1
  9072e7:	0b2000        	callx8	a2
  9072ea:	d10f      	retw.n
  9072ec:	001b69        	excw
        }
        else if( strcmp(param1, "event") == 0 )
  9072ef:	67da30        	bgez	a13, 906d23 <_buf_pool_static_create_pool+0x2b>
  9072f2:	5b7c9b        	call8	8e6560 <strcmp>
  9072f5:	65a04f        	bnez	a10, 907348 <db_wdt_cmd+0x144>

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  9072f8:	186905        	l32r	a8, 8e170c <athos_indirection_table_install+0x198>
        {
		uint32_t event= 0x00123400;

		/* disable ep3 intr */
		iowrite8_usb(0x17, ioread8_usb(0x17)|0xc0);
  9072fb:	220ac0        	movi	a2, 192
  9072fe:	238000        	l8ui	a3, a8, 0
  907301:	196908        	l32r	a9, 8e1724 <athos_indirection_table_install+0x1b0>
  907304:	030347        	extui	a3, a3, 0, 8
  907307:	023302        	or	a3, a3, a2
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90730a:	1268e5        	l32r	a2, 8e16a0 <athos_indirection_table_install+0x12c>
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  90730d:	0c0200        	memw
  907310:	238400        	s8i	a3, a8, 0
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  907313:	c03f      	movi.n	a3, 15
  907315:	0c0200        	memw
  907318:	9320      	s32i.n	a3, a2, 0
  90731a:	136968        	l32r	a3, 8e18bc <athos_indirection_table_install+0x348>
  90731d:	126906        	l32r	a2, 8e1738 <athos_indirection_table_install+0x1c4>
  907320:	0c0200        	memw
  907323:	9320      	s32i.n	a3, a2, 0

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  907325:	239000        	l8ui	a3, a9, 0

		/* ZM_EP3_DATA_REG = event; */
		iowrite32_usb(0xF8, event);

		/* tx done */
		iowrite8_usb(0xAE, ioread8_usb(0xAE) | 0x08);
  907328:	c028      	movi.n	a2, 8
  90732a:	030347        	extui	a3, a3, 0, 8
  90732d:	023302        	or	a3, a3, a2
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  907330:	0c0200        	memw
  907333:	239400        	s8i	a3, a9, 0

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  907336:	238000        	l8ui	a3, a8, 0
  907339:	22fabf        	movi	a2, -65
  90733c:	030347        	extui	a3, a3, 0, 8
  90733f:	023301        	and	a3, a3, a2
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  907342:	0c0200        	memw
  907345:	238400        	s8i	a3, a8, 0

		/* enable ep3 intr */
		iowrite8_usb(0x17, ioread8_usb(0x17) & 0xbf);
        }
}
  907348:	d10f      	retw.n
	...

0090734c <db_usb_cmd>:
#endif //#if SYSTEM_MODULE_INTR
	return 0;
}

static int db_usb_cmd(char *cmd, char *param1, char *param2, char *param3)
{
  90734c:	6c1004        	entry	a1, 32
	A_PRINTF("THIS IS USB COMMAND\n\r");
  90734f:	1268bf        	l32r	a2, 8e164c <athos_indirection_table_install+0xd8>
  907352:	1a6969        	l32r	a10, 8e18f8 <athos_indirection_table_install+0x384>
  907355:	282212        	l32i	a8, a2, 72
  907358:	0b8000        	callx8	a8

	if( strcmp(param1, "que") == 0 )
  90735b:	1b696a        	l32r	a11, 8e1904 <athos_indirection_table_install+0x390>
  90735e:	033a02        	or	a10, a3, a3
  907361:	5b7c7f        	call8	8e6560 <strcmp>
  907364:	cca4      	bnez.n	a10, 90736c <db_usb_cmd+0x20>
	{
		HIFusb_DescTraceDump();
  907366:	5b7120        	call8	8e37e8 <HIFusb_DescTraceDump>
  907369:	600011        	j	90737e <db_usb_cmd+0x32>
	}
	else
	{
		A_PRINTF("\tusb que - dump descriptor queue\n\r");
  90736c:	282212        	l32i	a8, a2, 72
  90736f:	1a696b        	l32r	a10, 8e191c <athos_indirection_table_install+0x3a8>
  907372:	0b8000        	callx8	a8
		A_PRINTF("\tusb fw on/off - enable/disable write fw download to ram\n\r");
  907375:	1a696c        	l32r	a10, 8e1928 <athos_indirection_table_install+0x3b4>
  907378:	222212        	l32i	a2, a2, 72
  90737b:	0b2000        	callx8	a2

	}
	return 0;
}
  90737e:	c020      	movi.n	a2, 0
  907380:	d10f      	retw.n
	...

00907384 <db_info_cmd>:
		clk_change(clk, ratio, baud);
	}
}

static int db_info_cmd(char *cmd, char *param1, char *param2, char *param3)
{
  907384:	6c1004        	entry	a1, 32
#if 1

	if(strcmp(param1, "ram") == 0 )
  907387:	1b696d        	l32r	a11, 8e193c <athos_indirection_table_install+0x3c8>
  90738a:	033a02        	or	a10, a3, a3
  90738d:	5b7c74        	call8	8e6560 <strcmp>
  907390:	65a00d        	bnez	a10, 9073a1 <db_info_cmd+0x1d>
	{
		A_ALLOCRAM_DEBUG();
  907393:	1868bf        	l32r	a8, 8e1690 <athos_indirection_table_install+0x11c>
  907396:	288253        	l32i	a8, a8, 0x14c
  907399:	0b8000        	callx8	a8
  90739c:	600004        	j	9073a4 <db_info_cmd+0x20>
  90739f:	00005b        	extui	a0, a0, 16, 12
	* is dead too */
	else if(strcmp(param1, "cpu") == 0)
		zfPrintCpuUtilization();
#endif
	else   // defalut dump
		HIFusb_DescTraceDump();
  9073a2:	7111c0        	beq	a1, a1, 907366 <db_usb_cmd+0x1a>
		A_PRINTF("read 0x%08x (0x%08x) use %d clocks\n\r", data3, data, ccount2-ccount1);

	}
#endif
	return 1;
}
  9073a5:	21d10f        	l16ui	a1, a13, 30

009073a8 <zf_debug_task>:
	gvLen = 0;
	pressed_time = 0;
}

static void zf_debug_task(void)
{
  9073a8:	6c1008        	entry	a1, 64
	int i;
	uint8_t ch;

	if ((zm_get_char(&ch)) == 0)
  9073ab:	1268bf        	l32r	a2, 8e16a8 <athos_indirection_table_install+0x134>
  9073ae:	da10      	mov.n	a10, a1
  9073b0:	232215        	l32i	a3, a2, 84
  9073b3:	0b3000        	callx8	a3
  9073b6:	64a22f        	beqz	a10, 9075e9 <zf_debug_task+0x241>
	{
		return;
	}

	if (db_get_cmd_line(ch, raw_cmd, &gvLen) == 0)
  9073b9:	2b1000        	l8ui	a11, a1, 0

static uint16_t db_get_cmd_line(uint8_t ch, char *cmd_line, uint16_t *i)
{
	int cmd_buf_loc;

	switch (ch)
  9073bc:	69b802        	bnei	a11, 8, 9073c2 <zf_debug_task+0x1a>
  9073bf:	6000fe        	j	9074c1 <zf_debug_task+0x119>
  9073c2:	c038      	movi.n	a3, 8
  9073c4:	7b3305        	bltu	a3, a11, 9073cd <zf_debug_task+0x25>
  9073c7:	64b21e        	beqz	a11, 9075e9 <zf_debug_task+0x241>
  9073ca:	600112        	j	9074e0 <zf_debug_task+0x138>
  9073cd:	c03d      	movi.n	a3, 13
  9073cf:	73b17d        	beq	a11, a3, 907450 <zf_debug_task+0xa8>
  9073d2:	c53c      	movi.n	a3, 92
  9073d4:	73b102        	beq	a11, a3, 9073da <zf_debug_task+0x32>
  9073d7:	600105        	j	9074e0 <zf_debug_task+0x138>
	{
	case '\\' : /* Last command */
		pressed_time++;
  9073da:	14693c        	l32r	a4, 8e18cc <athos_indirection_table_install+0x358>
  9073dd:	234200        	l32i	a3, a4, 0
  9073e0:	233c01        	addi	a3, a3, 1
		if (pressed_time >= COMMAND_BUFFER_SIZE)
  9073e3:	6b3601        	bgei	a3, 6, 9073e8 <zf_debug_task+0x40>
	int cmd_buf_loc;

	switch (ch)
	{
	case '\\' : /* Last command */
		pressed_time++;
  9073e6:	9340      	s32i.n	a3, a4, 0
		if (pressed_time >= COMMAND_BUFFER_SIZE)
		{
			pressed_time--;
		}
		cmd_buf_loc = cmd_buf_ptr - pressed_time;
  9073e8:	136939        	l32r	a3, 8e18cc <athos_indirection_table_install+0x358>
  9073eb:	8440      	l32i.n	a4, a4, 0
  9073ed:	8330      	l32i.n	a3, a3, 0
  9073ef:	04340c        	sub	a4, a3, a4
		if (cmd_buf_loc < 0)
  9073f2:	67400f        	bgez	a4, 907405 <zf_debug_task+0x5d>
		{
			if (cmd_buf_full == TRUE)
  9073f5:	13693a        	l32r	a3, 8e18e0 <athos_indirection_table_install+0x36c>
  9073f8:	8530      	l32i.n	a5, a3, 0
			{
				cmd_buf_loc += COMMAND_BUFFER_SIZE;
  9073fa:	b643      	addi.n	a3, a4, 6
  9073fc:	b054      	addi.n	a4, a5, -1
  9073fe:	c050      	movi.n	a5, 0
  907400:	043538        	moveqz	a5, a3, a4
  907403:	d450      	mov.n	a4, a5
			{
				cmd_buf_loc = 0;
			}
		}

		if (A_STRLEN(cmd_buffer[cmd_buf_loc]) != 0)
  907405:	0e4311        	slli	a3, a4, 2
  907408:	043308        	add	a3, a3, a4
  90740b:	14696e        	l32r	a4, 8e19c4 <athos_indirection_table_install+0x450>
  90740e:	0d3311        	slli	a3, a3, 3
  907411:	043308        	add	a3, a3, a4
  907414:	242266        	l32i	a4, a2, 0x198
  907417:	033a02        	or	a10, a3, a3
  90741a:	0b4000        	callx8	a4
  90741d:	64a1c8        	beqz	a10, 9075e9 <zf_debug_task+0x241>
		{
			A_STRCPY(cmd_line, cmd_buffer[cmd_buf_loc]);
  907420:	14696f        	l32r	a4, 8e19dc <athos_indirection_table_install+0x468>
  907423:	252264        	l32i	a5, a2, 0x190
  907426:	db30      	mov.n	a11, a3
  907428:	da40      	mov.n	a10, a4
  90742a:	0b5000        	callx8	a5
			*i = A_STRLEN(cmd_buffer[cmd_buf_loc]);
  90742d:	252266        	l32i	a5, a2, 0x198
  907430:	da30      	mov.n	a10, a3
  907432:	0b5000        	callx8	a5
  907435:	13693b        	l32r	a3, 8e1924 <athos_indirection_table_install+0x3b0>
  907438:	2a3500        	s16i	a10, a3, 0
			A_PRINTF("\r>");
  90743b:	232212        	l32i	a3, a2, 72
  90743e:	1a6970        	l32r	a10, 8e1a00 <athos_indirection_table_install+0x48c>
  907441:	0b3000        	callx8	a3
			A_PRINTF("%s", cmd_line);
  907444:	db40      	mov.n	a11, a4
  907446:	222212        	l32i	a2, a2, 72
  907449:	1a6971        	l32r	a10, 8e1a10 <athos_indirection_table_install+0x49c>
  90744c:	6000cd        	j	90751d <zf_debug_task+0x175>
  90744f:	001369        	excw
		}
		break;
	case 13 : /* Return */
		pressed_time = 0;
  907452:	3cc050        	excw
  907455:	253600        	s32i	a5, a3, 0
		cmd_line[*i] = 0;
  907458:	13693b        	l32r	a3, 8e1944 <athos_indirection_table_install+0x3d0>
		A_PRINTF("\n\r");
  90745b:	1a6949        	l32r	a10, 8e1980 <athos_indirection_table_install+0x40c>
			A_PRINTF("%s", cmd_line);
		}
		break;
	case 13 : /* Return */
		pressed_time = 0;
		cmd_line[*i] = 0;
  90745e:	243100        	l16ui	a4, a3, 0
  907461:	13696f        	l32r	a3, 8e1a20 <athos_indirection_table_install+0x4ac>
  907464:	043408        	add	a4, a3, a4
  907467:	254400        	s8i	a5, a4, 0
		A_PRINTF("\n\r");
  90746a:	242212        	l32i	a4, a2, 72
  90746d:	0b4000        	callx8	a4
		if (*i != 0)
  907470:	15693b        	l32r	a5, 8e195c <athos_indirection_table_install+0x3e8>
  907473:	166939        	l32r	a6, 8e1958 <athos_indirection_table_install+0x3e4>
  907476:	245100        	l16ui	a4, a5, 0
  907479:	cb41      	beqz.n	a4, 9074ae <zf_debug_task+0x106>
		{
			//Filter duplicated string in command history
			if (strcmp(cmd_buffer[(cmd_buf_ptr==0)?(COMMAND_BUFFER_SIZE-1):(cmd_buf_ptr-1)], cmd_line) != 0)
  90747b:	8560      	l32i.n	a5, a6, 0
  90747d:	c045      	movi.n	a4, 5
  90747f:	b05a      	addi.n	a10, a5, -1
  907481:	05a439        	movnez	a4, a10, a5
  907484:	0e4a11        	slli	a10, a4, 2
  907487:	a4aa      	add.n	a10, a10, a4
  907489:	14696e        	l32r	a4, 8e1a44 <athos_indirection_table_install+0x4d0>
  90748c:	0daa11        	slli	a10, a10, 3
  90748f:	db30      	mov.n	a11, a3
  907491:	aa4a      	add.n	a10, a4, a10
  907493:	5b7c33        	call8	8e6560 <strcmp>
  907496:	c9a4      	beqz.n	a10, 9074ae <zf_debug_task+0x106>
			{
				A_STRCPY(cmd_buffer[cmd_buf_ptr++], cmd_line);
  907498:	0e5a11        	slli	a10, a5, 2
  90749b:	a5aa      	add.n	a10, a10, a5
  90749d:	b158      	addi.n	a8, a5, 1
  90749f:	0daa11        	slli	a10, a10, 3
  9074a2:	272264        	l32i	a7, a2, 0x190
  9074a5:	9860      	s32i.n	a8, a6, 0
  9074a7:	db30      	mov.n	a11, a3
  9074a9:	aa4a      	add.n	a10, a4, a10
  9074ab:	0b7000        	callx8	a7
			}
		}
		if (cmd_buf_ptr >= COMMAND_BUFFER_SIZE)
  9074ae:	8460      	l32i.n	a4, a6, 0
  9074b0:	6a466e        	blti	a4, 6, 907522 <zf_debug_task+0x17a>
		{
			cmd_buf_ptr = 0;
  9074b3:	c040      	movi.n	a4, 0
  9074b5:	9460      	s32i.n	a4, a6, 0
			cmd_buf_full = TRUE;
  9074b7:	14693a        	l32r	a4, 8e19a0 <athos_indirection_table_install+0x42c>
  9074ba:	c051      	movi.n	a5, 1
  9074bc:	9540      	s32i.n	a5, a4, 0
  9074be:	600060        	j	907522 <zf_debug_task+0x17a>
		}
		return 1;
	case '\b' : /* Backspace */
		pressed_time = 0;
  9074c1:	13693c        	l32r	a3, 8e19b4 <athos_indirection_table_install+0x440>
  9074c4:	c040      	movi.n	a4, 0
  9074c6:	9430      	s32i.n	a4, a3, 0
		if (*i > 0)
  9074c8:	14693b        	l32r	a4, 8e19b4 <athos_indirection_table_install+0x440>
  9074cb:	234100        	l16ui	a3, a4, 0
  9074ce:	643117        	beqz	a3, 9075e9 <zf_debug_task+0x241>
		{
			*i = *i-1;
  9074d1:	b033      	addi.n	a3, a3, -1
  9074d3:	234500        	s16i	a3, a4, 0
			A_PRINTF("\b \b");
  9074d6:	222212        	l32i	a2, a2, 72
  9074d9:	1a6972        	l32r	a10, 8e1aa4 <athos_indirection_table_install+0x530>
  9074dc:	600106        	j	9075e6 <zf_debug_task+0x23e>
  9074df:	0023bc        	excw
		}
		break;
	case 0 : //None
		break;
	default :
		if ((ch >= ' ') && (ch <= '~'))
  9074e2:	e0          	.byte 0xe0
  9074e3:	030347        	extui	a3, a3, 0, 8
  9074e6:	c54e      	movi.n	a4, 94
  9074e8:	734329        	bltu	a4, a3, 907515 <zf_debug_task+0x16d>
		{
			pressed_time = 0;
  9074eb:	13693c        	l32r	a3, 8e19dc <athos_indirection_table_install+0x468>
			if (*i < DB_MAX_COMMAND_LENGTH-2)
  9074ee:	15693b        	l32r	a5, 8e19dc <athos_indirection_table_install+0x468>
	case 0 : //None
		break;
	default :
		if ((ch >= ' ') && (ch <= '~'))
		{
			pressed_time = 0;
  9074f1:	c040      	movi.n	a4, 0
  9074f3:	9430      	s32i.n	a4, a3, 0
			if (*i < DB_MAX_COMMAND_LENGTH-2)
  9074f5:	235100        	l16ui	a3, a5, 0
  9074f8:	c245      	movi.n	a4, 37
  9074fa:	734b02        	bgeu	a4, a3, 907500 <zf_debug_task+0x158>
  9074fd:	6000e8        	j	9075e9 <zf_debug_task+0x241>
				{
					//if ((buf <= 'z') && (buf >= 'a'))
					//{
					//    buf -= 'a' - 'A';
					//}
					cmd_line[*i] = ch;
  907500:	14696f        	l32r	a4, 8e1abc <athos_indirection_table_install+0x548>
					*i = *i + 1;
					A_PRINTF("%c", ch);
  907503:	222212        	l32i	a2, a2, 72
				{
					//if ((buf <= 'z') && (buf >= 'a'))
					//{
					//    buf -= 'a' - 'A';
					//}
					cmd_line[*i] = ch;
  907506:	a344      	add.n	a4, a4, a3
					*i = *i + 1;
  907508:	b133      	addi.n	a3, a3, 1
				{
					//if ((buf <= 'z') && (buf >= 'a'))
					//{
					//    buf -= 'a' - 'A';
					//}
					cmd_line[*i] = ch;
  90750a:	2b4400        	s8i	a11, a4, 0
					*i = *i + 1;
  90750d:	235500        	s16i	a3, a5, 0
  907510:	600006        	j	90751a <zf_debug_task+0x172>
  907513:	000022        	excw
			}
		}
		else
		{
			ch = 7; /* Beep */
			A_PRINTF("%c", ch);
  907516:	2212c0        	l32i	a2, a1, 0x300
  907519:	b71a      	addi.n	a10, a1, 7
  90751b:	69470b        	bnei	a4, 7, 90752a <zf_debug_task+0x182>
  90751e:	2000d1        	l8ui	a0, a0, 209
  907521:	0fc090        	l32e	a15, a12, -64
		cmd_line[*i] = 0;
		A_PRINTF("\n\r");
		if (*i != 0)
		{
			//Filter duplicated string in command history
			if (strcmp(cmd_buffer[(cmd_buf_ptr==0)?(COMMAND_BUFFER_SIZE-1):(cmd_buf_ptr-1)], cmd_line) != 0)
  907524:	d890      	mov.n	a8, a9
  907526:	df90      	mov.n	a15, a9
		j = 0;
		while(raw_str[i] && (raw_str[i] != ' '))
		{
			if (k == 0)
			{
				if ((raw_str[i] <= 'z') && (raw_str[i] >= 'a'))
  907528:	c179      	movi.n	a7, 25
  90752a:	63ffff        	j	90752d <zf_debug_task+0x185>


	for (k=0; k<4; k++)
	{
		/* Remove preceeding spaces */
		while (raw_str[i++] == ' '){}
  90752d:	a83d      	add.n	a13, a3, a8
  90752f:	24d000        	l8ui	a4, a13, 0
  907532:	b18b      	addi.n	a11, a8, 1
  907534:	d8b0      	mov.n	a8, a11
  907536:	684cf3        	beqi	a4, 32, 90752d <zf_debug_task+0x185>
  907539:	1e6973        	l32r	a14, 8e1b08 <athos_indirection_table_install+0x594>
  90753c:	c061      	movi.n	a6, 1
  90753e:	d4e0      	mov.n	a4, a14
  907540:	600027        	j	90756b <zf_debug_task+0x1c3>
  907543:	00cdf6        	excw
		j = 0;
		while(raw_str[i] && (raw_str[i] != ' '))
		{
			if (k == 0)
			{
				if ((raw_str[i] <= 'z') && (raw_str[i] >= 'a'))
  907546:	25ac9f        	addi	a5, a10, -97
  907549:	050547        	extui	a5, a5, 0, 8
  90754c:	757305        	bltu	a7, a5, 907555 <zf_debug_task+0x1ad>
				{
					raw_str[i] -= 'a' - 'A';
  90754f:	2aace0        	addi	a10, a10, -32
  907552:	2ad400        	s8i	a10, a13, 0
				}
				cmd_str[k*DB_MAX_COMMAND_LENGTH + j++] = raw_str[i++];
  907555:	25d000        	l8ui	a5, a13, 0
  907558:	25e400        	s8i	a5, a14, 0
  90755b:	600004        	j	907563 <zf_debug_task+0x1bb>
			}
			else
			{
				cmd_str[k*DB_MAX_COMMAND_LENGTH + j++] = raw_str[i++];
  90755e:	a9e5      	add.n	a5, a14, a9
  907560:	2a5400        	s8i	a10, a5, 0
  907563:	b1dd      	addi.n	a13, a13, 1
  907565:	b1bb      	addi.n	a11, a11, 1
  907567:	b166      	addi.n	a6, a6, 1
  907569:	b1ee      	addi.n	a14, a14, 1
  90756b:	b06c      	addi.n	a12, a6, -1
		while (raw_str[i++] == ' '){}
		i--;

		/* Copy command string */
		j = 0;
		while(raw_str[i] && (raw_str[i] != ' '))
  90756d:	2ad000        	l8ui	a10, a13, 0
  907570:	9c14      	s32i.n	a12, a1, 16
  907572:	2cfadf        	movi	a12, -33
  907575:	0ca501        	and	a5, a10, a12
  907578:	b0b8      	addi.n	a8, a11, -1
  90757a:	655fc6        	bnez	a5, 907544 <zf_debug_task+0x19c>
			else
			{
				cmd_str[k*DB_MAX_COMMAND_LENGTH + j++] = raw_str[i++];
			}
		}
		cmd_str[k*DB_MAX_COMMAND_LENGTH + j] = 0;
  90757d:	8614      	l32i.n	a6, a1, 16
	int i = 0;
	int j;
	int k;


	for (k=0; k<4; k++)
  90757f:	b1ff      	addi.n	a15, a15, 1
			else
			{
				cmd_str[k*DB_MAX_COMMAND_LENGTH + j++] = raw_str[i++];
			}
		}
		cmd_str[k*DB_MAX_COMMAND_LENGTH + j] = 0;
  907581:	a64c      	add.n	a12, a4, a6
  907583:	09cc08        	add	a12, a12, a9
  907586:	25c400        	s8i	a5, a12, 0
  907589:	299c28        	addi	a9, a9, 40
	int i = 0;
	int j;
	int k;


	for (k=0; k<4; k++)
  90758c:	69f49d        	bnei	a15, 4, 90752d <zf_debug_task+0x185>
				cmd_str[k*DB_MAX_COMMAND_LENGTH + j++] = raw_str[i++];
			}
		}
		cmd_str[k*DB_MAX_COMMAND_LENGTH + j] = 0;
	}
	return (int)A_STRLEN(cmd_str);
  90758f:	232266        	l32i	a3, a2, 0x198
  907592:	044a02        	or	a10, a4, a4
  907595:	0b3000        	callx8	a3
	if (db_get_cmd_line(ch, raw_cmd, &gvLen) == 0)
	{
		return;
	}

	if (db_formalize_command(raw_cmd, cmd_str))
  907598:	64a044        	beqz	a10, 9075e0 <zf_debug_task+0x238>
	{
		gvLen = 0;
  90759b:	1c693b        	l32r	a12, 8e1a88 <athos_indirection_table_install+0x514>
		i = 0;

		cmd_not_found = TRUE;
  90759e:	c031      	movi.n	a3, 1
		return;
	}

	if (db_formalize_command(raw_cmd, cmd_str))
	{
		gvLen = 0;
  9075a0:	25c500        	s16i	a5, a12, 0
		i = 0;

		cmd_not_found = TRUE;
  9075a3:	156974        	l32r	a5, 8e1b74 <athos_indirection_table_install+0x600>
  9075a6:	9350      	s32i.n	a3, a5, 0
  9075a8:	136940        	l32r	a3, 8e1aa8 <athos_indirection_table_install+0x534>
  9075ab:	60001d        	j	9075cc <zf_debug_task+0x224>
		while(command_table[i].cmd_func)
		{
			if (!strcmp(command_table[i].cmd_str, cmd_str))
  9075ae:	8a30      	l32i.n	a10, a3, 0
  9075b0:	db40      	mov.n	a11, a4
  9075b2:	5b7beb        	call8	8e6560 <strcmp>
  9075b5:	bc33      	addi.n	a3, a3, 12
  9075b7:	cda1      	bnez.n	a10, 9075cc <zf_debug_task+0x224>
			{
				cmd_not_found = FALSE;
				command_table[i].cmd_func(cmd_str,
  9075b9:	1d6975        	l32r	a13, 8e1b90 <athos_indirection_table_install+0x61c>
  9075bc:	1c6976        	l32r	a12, 8e1b94 <athos_indirection_table_install+0x620>
  9075bf:	1b6977        	l32r	a11, 8e1b9c <athos_indirection_table_install+0x628>
		cmd_not_found = TRUE;
		while(command_table[i].cmd_func)
		{
			if (!strcmp(command_table[i].cmd_str, cmd_str))
			{
				cmd_not_found = FALSE;
  9075c2:	9a50      	s32i.n	a10, a5, 0
				command_table[i].cmd_func(cmd_str,
  9075c4:	da40      	mov.n	a10, a4
  9075c6:	0b6000        	callx8	a6
  9075c9:	600004        	j	9075d1 <zf_debug_task+0x229>
	{
		gvLen = 0;
		i = 0;

		cmd_not_found = TRUE;
		while(command_table[i].cmd_func)
  9075cc:	8632      	l32i.n	a6, a3, 8
  9075ce:	656fdc        	bnez	a6, 9075ae <zf_debug_task+0x206>
							  cmd_str+DB_MAX_COMMAND_LENGTH*3);
				break;
			}
			i++;
		}
		if (cmd_not_found)
  9075d1:	235200        	l32i	a3, a5, 0
  9075d4:	643008        	beqz	a3, 9075e0 <zf_debug_task+0x238>
		{
			A_PRINTF("Error, HELP for command list.\n\r");
  9075d7:	232212        	l32i	a3, a2, 72
  9075da:	1a6978        	l32r	a10, 8e1bbc <athos_indirection_table_install+0x648>
  9075dd:	0b3000        	callx8	a3
		}

	}

	A_PRINTF(">");
  9075e0:	222212        	l32i	a2, a2, 72
  9075e3:	1a6979        	l32r	a10, 8e1bc8 <athos_indirection_table_install+0x654>
  9075e6:	0b2000        	callx8	a2
  9075e9:	d10f      	retw.n
	...

009075ec <db_ascii_to_int>:
	}
	return 0;
}

int db_ascii_to_int(char *num_str, unsigned long *int_num)
{
  9075ec:	6c1004        	entry	a1, 32
	int i = 0;

	*int_num = 0;
  9075ef:	c080      	movi.n	a8, 0
  9075f1:	9830      	s32i.n	a8, a3, 0
	while (num_str[i])
	{
		if ((num_str[i] >= '0') && (num_str[i] <= '9'))
  9075f3:	c0a9      	movi.n	a10, 9
int db_ascii_to_int(char *num_str, unsigned long *int_num)
{
	int i = 0;

	*int_num = 0;
	while (num_str[i])
  9075f5:	600020        	j	907619 <db_ascii_to_int+0x2d>
	{
		if ((num_str[i] >= '0') && (num_str[i] <= '9'))
  9075f8:	288cd0        	addi	a8, a8, -48
  9075fb:	080847        	extui	a8, a8, 0, 8
  9075fe:	78a322        	bltu	a10, a8, 907624 <db_ascii_to_int+0x38>
		{
			*int_num *= 10;
  907601:	8930      	l32i.n	a9, a3, 0
  907603:	0e9811        	slli	a8, a9, 2
  907606:	a988      	add.n	a8, a8, a9
  907608:	0f8811        	slli	a8, a8, 1
  90760b:	9830      	s32i.n	a8, a3, 0
			*int_num += (num_str[i] - '0');
  90760d:	292000        	l8ui	a9, a2, 0
  907610:	288cd0        	addi	a8, a8, -48
  907613:	a898      	add.n	a8, a9, a8
  907615:	9830      	s32i.n	a8, a3, 0
  907617:	b122      	addi.n	a2, a2, 1
int db_ascii_to_int(char *num_str, unsigned long *int_num)
{
	int i = 0;

	*int_num = 0;
	while (num_str[i])
  907619:	282000        	l8ui	a8, a2, 0
  90761c:	658fd8        	bnez	a8, 9075f8 <db_ascii_to_int+0xc>
		{
			return -1;
		}
		i++;
	}
	return 0;
  90761f:	d280      	mov.n	a2, a8
  907621:	d10f      	retw.n
  907623:	00c72f        	excw
}
  907626:	d10f      	retw.n

00907628 <db_clock_cmd>:
	A_UART_HWINIT((clk*1000*1000)/ratio, baud);

}

static int db_clock_cmd(char *cmd, char *param1, char *param2, char *param3)
{
  907628:	6c1006        	entry	a1, 48
	uint32_t ratio = 1;
	uint32_t baud = 19200;
	uint32_t clk = 0;
  90762b:	c040      	movi.n	a4, 0
    
	if( db_ascii_to_int(param1, &clk) != -1 )
  90762d:	011b02        	or	a11, a1, a1
  907630:	da30      	mov.n	a10, a3

static int db_clock_cmd(char *cmd, char *param1, char *param2, char *param3)
{
	uint32_t ratio = 1;
	uint32_t baud = 19200;
	uint32_t clk = 0;
  907632:	241600        	s32i	a4, a1, 0
    
	if( db_ascii_to_int(param1, &clk) != -1 )
  907635:	5bffed        	call8	9075ec <db_ascii_to_int>
  907638:	68a056        	beqi	a10, -1, 907692 <db_clock_cmd+0x6a>
	{
		A_PRINTF("changing clock to %d\n", clk);
  90763b:	1268bf        	l32r	a2, 8e1938 <athos_indirection_table_install+0x3c4>
  90763e:	8b10      	l32i.n	a11, a1, 0
  907640:	282212        	l32i	a8, a2, 72
  907643:	1a697a        	l32r	a10, 8e1c2c <athos_indirection_table_install+0x6b8>
  907646:	0b8000        	callx8	a8
		clk_change(clk, ratio, baud);
  907649:	8910      	l32i.n	a9, a1, 0

static void clk_change(uint32_t clk, uint32_t ratio, uint32_t baud)
{
	uint32_t clk_sel = 0;

	switch(clk){
  90764b:	c2ac      	movi.n	a10, 44
		break;
        case 88:
		clk_sel = 1;
		break;
        case 44:
		clk_sel = 2;
  90764d:	c082      	movi.n	a8, 2

static void clk_change(uint32_t clk, uint32_t ratio, uint32_t baud)
{
	uint32_t clk_sel = 0;

	switch(clk){
  90764f:	7a9122        	beq	a9, a10, 907675 <db_clock_cmd+0x4d>
  907652:	79a30e        	bltu	a10, a9, 907664 <db_clock_cmd+0x3c>
  907655:	c1a6      	movi.n	a10, 22
        case 22:
		clk_sel = 0;
  907657:	d840      	mov.n	a8, a4

static void clk_change(uint32_t clk, uint32_t ratio, uint32_t baud)
{
	uint32_t clk_sel = 0;

	switch(clk){
  907659:	7a9118        	beq	a9, a10, 907675 <db_clock_cmd+0x4d>
  90765c:	c248      	movi.n	a4, 40
		break;
        case 117:
		clk_sel = 4;
		break;
        case 40:
		clk_sel = 6;            
  90765e:	c086      	movi.n	a8, 6
  907660:	60000c        	j	907670 <db_clock_cmd+0x48>
  907663:	00c548        	extui	a5, a0, 12, 9
	switch(clk){
        case 22:
		clk_sel = 0;
		break;
        case 88:
		clk_sel = 1;
  907666:	c081      	movi.n	a8, 1

static void clk_change(uint32_t clk, uint32_t ratio, uint32_t baud)
{
	uint32_t clk_sel = 0;

	switch(clk){
  907668:	749109        	beq	a9, a4, 907675 <db_clock_cmd+0x4d>
  90766b:	240a75        	movi	a4, 117
		break;
        case 44:
		clk_sel = 2;
		break;
        case 117:
		clk_sel = 4;
  90766e:	c084      	movi.n	a8, 4

static void clk_change(uint32_t clk, uint32_t ratio, uint32_t baud)
{
	uint32_t clk_sel = 0;

	switch(clk){
  907670:	749101        	beq	a9, a4, 907675 <db_clock_cmd+0x4d>
		break;
        case 40:
		clk_sel = 6;            
		break;
        default:
		clk_sel = 6;
  907673:	c086      	movi.n	a8, 6
		break;
	}

	iowrite32(0x50040, (0x300|clk_sel|(ratio>>1)<<12));
  907675:	243a00        	movi	a4, 0x300
	A_UART_HWINIT((clk*1000*1000)/ratio, baud);
  907678:	1a697d        	l32r	a10, 8e1c6c <athos_indirection_table_install+0x6f8>
        default:
		clk_sel = 6;
		break;
	}

	iowrite32(0x50040, (0x300|clk_sel|(ratio>>1)<<12));
  90767b:	048802        	or	a8, a8, a4
  90767e:	14697b        	l32r	a4, 8e1c6c <athos_indirection_table_install+0x6f8>
	A_UART_HWINIT((clk*1000*1000)/ratio, baud);
  907681:	22221a        	l32i	a2, a2, 104
  907684:	1b697c        	l32r	a11, 8e1c74 <athos_indirection_table_install+0x700>
  907687:	0a9a28        	mull	a10, a9, a10
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90768a:	0c0200        	memw
  90768d:	9840      	s32i.n	a8, a4, 0
  90768f:	0b2000        	callx8	a2
	if( db_ascii_to_int(param1, &clk) != -1 )
	{
		A_PRINTF("changing clock to %d\n", clk);
		clk_change(clk, ratio, baud);
	}
}
  907692:	d10f      	retw.n

00907694 <dbg_timer_func>:
	db_incorect_format();
	return -1;
}

LOCAL void dbg_timer_func(A_HANDLE alarm, void *data)
{
  907694:	6c1004        	entry	a1, 32
	A_PRINTF("this is a timer alarm function 0x%08x\n\r", xthal_get_ccount());
  907697:	1268bf        	l32r	a2, 8e1994 <athos_indirection_table_install+0x420>
  90769a:	222212        	l32i	a2, a2, 72
  90769d:	5b7cae        	call8	8e6958 <xthal_get_ccount>
  9076a0:	dba0      	mov.n	a11, a10
  9076a2:	1a697e        	l32r	a10, 8e1c9c <athos_indirection_table_install+0x728>
  9076a5:	0b2000        	callx8	a2
  9076a8:	d10f      	retw.n
	...

009076ac <cmnos_dbg_module_install>:

	db_incorect_format();
	return -1;
}
void cmnos_dbg_module_install(struct dbg_api *apis)
{
  9076ac:	6c1004        	entry	a1, 32
	apis->_dbg_init = zf_debug_init;
  9076af:	18697f        	l32r	a8, 8e1cac <athos_indirection_table_install+0x738>
  9076b2:	9820      	s32i.n	a8, a2, 0
	apis->_dbg_task = zf_debug_task;
  9076b4:	186980        	l32r	a8, 8e1cb4 <athos_indirection_table_install+0x740>
  9076b7:	9821      	s32i.n	a8, a2, 4
  9076b9:	d10f      	retw.n
	...

009076bc <_fw_usbfifo_recv_command>:

typedef void (* USBFIFO_recv_command)(VBUF *cmd);
USBFIFO_recv_command m_origUsbfifoRecvCmd = NULL;

void _fw_usbfifo_recv_command(VBUF *buf)
{
  9076bc:	6c1004        	entry	a1, 32
	uint8_t *cmd_data;
	uint32_t tmp;

	cmd_data = (uint8_t *)(buf->desc_list->buf_addr +
  9076bf:	8920      	l32i.n	a9, a2, 0

typedef void (* USBFIFO_recv_command)(VBUF *cmd);
USBFIFO_recv_command m_origUsbfifoRecvCmd = NULL;

void _fw_usbfifo_recv_command(VBUF *buf)
{
  9076c1:	da20      	mov.n	a10, a2
	uint8_t *cmd_data;
	uint32_t tmp;

	cmd_data = (uint8_t *)(buf->desc_list->buf_addr +
				buf->desc_list->data_offset);
  9076c3:	2b9105        	l16ui	a11, a9, 10
	tmp = *((uint32_t *)cmd_data);
  9076c6:	8891      	l32i.n	a8, a9, 4
  9076c8:	ab88      	add.n	a8, a8, a11
	if (tmp == 0xFFFFFFFF)
  9076ca:	8880      	l32i.n	a8, a8, 0
  9076cc:	698004        	bnei	a8, -1, 9076d4 <_fw_usbfifo_recv_command+0x18>
		_fw_usb_suspend_reboot();
  9076cf:	580cae        	call8	90a988 <_fw_usb_suspend_reboot>
  9076d2:	d10f      	retw.n
	else
		m_origUsbfifoRecvCmd(buf);
  9076d4:	186981        	l32r	a8, 8e1cd8 <athos_indirection_table_install+0x764>
  9076d7:	8880      	l32i.n	a8, a8, 0
  9076d9:	0b8000        	callx8	a8
  9076dc:	d10f      	retw.n
	...

009076e0 <_fw_usbfifo_init>:
}

void _fw_usbfifo_init(USB_FIFO_CONFIG *pConfig)
{
  9076e0:	6c1004        	entry	a1, 32
	m_origUsbfifoRecvCmd = pConfig->recv_command;
  9076e3:	8921      	l32i.n	a9, a2, 4
  9076e5:	186981        	l32r	a8, 8e1cec <athos_indirection_table_install+0x778>
  9076e8:	9980      	s32i.n	a9, a8, 0

	usbFifoConf.get_command_buf = pConfig->get_command_buf;
  9076ea:	8920      	l32i.n	a9, a2, 0
  9076ec:	186982        	l32r	a8, 8e1cf4 <athos_indirection_table_install+0x780>
  9076ef:	9980      	s32i.n	a9, a8, 0
	usbFifoConf.recv_command    = _fw_usbfifo_recv_command;
  9076f1:	196983        	l32r	a9, 8e1d00 <athos_indirection_table_install+0x78c>
  9076f4:	9981      	s32i.n	a9, a8, 4
	usbFifoConf.get_event_buf   = pConfig->get_event_buf;
  9076f6:	8922      	l32i.n	a9, a2, 8
	usbFifoConf.send_event_done = pConfig->send_event_done;
  9076f8:	8223      	l32i.n	a2, a2, 12
{
	m_origUsbfifoRecvCmd = pConfig->recv_command;

	usbFifoConf.get_command_buf = pConfig->get_command_buf;
	usbFifoConf.recv_command    = _fw_usbfifo_recv_command;
	usbFifoConf.get_event_buf   = pConfig->get_event_buf;
  9076fa:	9982      	s32i.n	a9, a8, 8
	usbFifoConf.send_event_done = pConfig->send_event_done;
  9076fc:	9283      	s32i.n	a2, a8, 12
  9076fe:	d10f      	retw.n

00907700 <cold_reboot>:
}

void cold_reboot(void)
{
  907700:	6c1004        	entry	a1, 32
	A_PRINTF("Cold reboot initiated.");
  907703:	1268bf        	l32r	a2, 8e1a00 <athos_indirection_table_install+0x48c>
  907706:	1a6984        	l32r	a10, 8e1d18 <athos_indirection_table_install+0x7a4>
  907709:	282212        	l32i	a8, a2, 72
  90770c:	0b8000        	callx8	a8
  90770f:	1868c2        	l32r	a8, 8e1a18 <athos_indirection_table_install+0x4a4>
  907712:	c090      	movi.n	a9, 0
#if defined(PROJECT_MAGPIE)
	iowrite32(WATCH_DOG_MAGIC_PATTERN_ADDR, 0);
#elif defined(PROJECT_K2)
	iowrite32(MAGPIE_REG_RST_STATUS_ADDR, 0);
#endif /* #if defined(PROJECT_MAGPIE) */
	A_USB_JUMP_BOOT();
  907714:	22222c        	l32i	a2, a2, 176
  907717:	0c0200        	memw
  90771a:	298600        	s32i	a9, a8, 0
  90771d:	0b2000        	callx8	a2
  907720:	d10f      	retw.n
	...

00907724 <usb_status_in_patch>:

/*
 * support more than 64 bytes command on ep3
 */
void usb_status_in_patch(void)
{
  907724:	6c1004        	entry	a1, 32
	static VBUF *evntbuf = NULL;
	static volatile uint32_t *regaddr;
	static BOOLEAN cmd_is_new = TRUE;
	BOOLEAN cmd_end = FALSE;

	if (cmd_is_new) {
  907727:	126985        	l32r	a2, 8e1d3c <athos_indirection_table_install+0x7c8>
  90772a:	282100        	l16ui	a8, a2, 0
  90772d:	648048        	beqz	a8, 907779 <usb_status_in_patch+0x55>
		evntbuf = usbFifoConf.get_event_buf();
  907730:	186982        	l32r	a8, 8e1d38 <athos_indirection_table_install+0x7c4>
  907733:	8a82      	l32i.n	a10, a8, 8
  907735:	0ba000        	callx8	a10
  907738:	186986        	l32r	a8, 8e1d50 <athos_indirection_table_install+0x7dc>
  90773b:	9a80      	s32i.n	a10, a8, 0
		if (evntbuf != NULL) {
  90773d:	c9af      	beqz.n	a10, 907760 <usb_status_in_patch+0x3c>
			regaddr = (uint32_t *)VBUF_GET_DATA_ADDR(evntbuf);
  90773f:	89a0      	l32i.n	a9, a10, 0
  907741:	2b9105        	l16ui	a11, a9, 10
  907744:	8891      	l32i.n	a8, a9, 4
  907746:	196987        	l32r	a9, 8e1d64 <athos_indirection_table_install+0x7f0>
  907749:	ab88      	add.n	a8, a8, a11
  90774b:	9890      	s32i.n	a8, a9, 0
			buf_len = evntbuf->buf_length;
  90774d:	186988        	l32r	a8, 8e1d70 <athos_indirection_table_install+0x7fc>
  907750:	29a104        	l16ui	a9, a10, 8
  907753:	298500        	s16i	a9, a8, 0
		} else {
			mUSB_STATUS_IN_INT_DISABLE();
			return;
		}

		cmd_is_new = FALSE;
  907756:	c080      	movi.n	a8, 0
  907758:	282500        	s16i	a8, a2, 0
  90775b:	60001a        	j	907779 <usb_status_in_patch+0x55>
  90775e:	000018        	src	a0, a0, a0

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  907761:	690529        	bnei	a0, 5, 90778e <usb_status_in_patch+0x6a>
		evntbuf = usbFifoConf.get_event_buf();
		if (evntbuf != NULL) {
			regaddr = (uint32_t *)VBUF_GET_DATA_ADDR(evntbuf);
			buf_len = evntbuf->buf_length;
		} else {
			mUSB_STATUS_IN_INT_DISABLE();
  907764:	0ac022        	excw
  907767:	8000      	l32i.n	a0, a0, 0
  907769:	020247        	extui	a2, a2, 0, 8
  90776c:	092202        	or	a2, a2, a9
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  90776f:	0c0200        	memw
  907772:	228400        	s8i	a2, a8, 0
  907775:	d10f      	retw.n
  907777:	00001a        	sll	a0, a0
		}

		cmd_is_new = FALSE;
	}

	if (buf_len > USB_EP3_MAX_PKT_SIZE) {
  90777a:	6988c4        	bnei	a8, 8, 907742 <usb_status_in_patch+0x1e>
  90777d:	9028      	s32i.n	a0, a2, 32
  90777f:	a100      	add.n	a0, a0, a1
	}
	/* TODO: 64 bytes...
	 * controller supposed will take care of zero-length? */
	else {
		reg_buf_len = buf_len;
		cmd_end = TRUE;
  907781:	c0c1      	movi.n	a12, 1
		}

		cmd_is_new = FALSE;
	}

	if (buf_len > USB_EP3_MAX_PKT_SIZE) {
  907783:	789b09        	bgeu	a9, a8, 907790 <usb_status_in_patch+0x6c>
		reg_buf_len = USB_EP3_MAX_PKT_SIZE;
		buf_len -= USB_EP3_MAX_PKT_SIZE;
  907786:	288cc0        	addi	a8, a8, -64
  907789:	28a500        	s16i	a8, a10, 0
	uint16_t reg_buf_len;
	static uint16_t buf_len;
	static VBUF *evntbuf = NULL;
	static volatile uint32_t *regaddr;
	static BOOLEAN cmd_is_new = TRUE;
	BOOLEAN cmd_end = FALSE;
  90778c:	c0c0      	movi.n	a12, 0

		cmd_is_new = FALSE;
	}

	if (buf_len > USB_EP3_MAX_PKT_SIZE) {
		reg_buf_len = USB_EP3_MAX_PKT_SIZE;
  90778e:	d890      	mov.n	a8, a9
  907790:	1b6987        	l32r	a11, 8e1dac <athos_indirection_table_install+0x838>
  907793:	082914        	srli	a9, a8, 2
  907796:	8ab0      	l32i.n	a10, a11, 0
  907798:	0e9911        	slli	a9, a9, 2
  90779b:	a9a9      	add.n	a9, a10, a9
		reg_buf_len = buf_len;
		cmd_end = TRUE;
	}

	/* INT use EP3 */
	for (count = 0; count < (reg_buf_len / 4); count++)
  90779d:	c0d0      	movi.n	a13, 0
  90779f:	1e6906        	l32r	a14, 8e1bb8 <athos_indirection_table_install+0x644>
  9077a2:	c0f1      	movi.n	a15, 1
  9077a4:	60000e        	j	9077b6 <usb_status_in_patch+0x92>
  9077a7:	000c02        	or	a12, a0, a0
	{
		iowrite32_usb(ZM_EP3_DATA_OFFSET, *regaddr);
  9077aa:	008da0        	excw
		regaddr++;
  9077ad:	b4aa      	addi.n	a10, a10, 4
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  9077af:	0c0200        	memw
  9077b2:	9de0      	s32i.n	a13, a14, 0
  9077b4:	ddf0      	mov.n	a13, a15
		reg_buf_len = buf_len;
		cmd_end = TRUE;
	}

	/* INT use EP3 */
	for (count = 0; count < (reg_buf_len / 4); count++)
  9077b6:	7a99ee        	bne	a9, a10, 9077a8 <usb_status_in_patch+0x84>
  9077b9:	c8d0      	beqz.n	a13, 9077bd <usb_status_in_patch+0x99>
  9077bb:	99b0      	s32i.n	a9, a11, 0
	{
		iowrite32_usb(ZM_EP3_DATA_OFFSET, *regaddr);
		regaddr++;
	}

	remainder = reg_buf_len % 4;
  9077bd:	080841        	extui	a8, a8, 0, 2

	if (remainder) {
  9077c0:	cb81      	beqz.n	a8, 9077f5 <usb_status_in_patch+0xd1>
  9077c2:	1968e5        	l32r	a9, 8e1b58 <athos_indirection_table_install+0x5e4>
		switch(remainder) {
  9077c5:	688207        	beqi	a8, 2, 9077d0 <usb_status_in_patch+0xac>
  9077c8:	698309        	bnei	a8, 3, 9077d5 <usb_status_in_patch+0xb1>
  9077cb:	c087      	movi.n	a8, 7
  9077cd:	600006        	j	9077d7 <usb_status_in_patch+0xb3>
  9077d0:	c083      	movi.n	a8, 3
  9077d2:	600001        	j	9077d7 <usb_status_in_patch+0xb3>
  9077d5:	c081      	movi.n	a8, 1
  9077d7:	0c0200        	memw
  9077da:	9890      	s32i.n	a8, a9, 0
		case 1:
			iowrite32_usb(ZM_CBUS_FIFO_SIZE_OFFSET, 0x1);
			break;
		}

		iowrite32_usb(ZM_EP3_DATA_OFFSET, *regaddr);
  9077dc:	88b0      	l32i.n	a8, a11, 0
  9077de:	0c0200        	memw
  9077e1:	8980      	l32i.n	a9, a8, 0
  9077e3:	186906        	l32r	a8, 8e1bfc <athos_indirection_table_install+0x688>
  9077e6:	0c0200        	memw
  9077e9:	9980      	s32i.n	a9, a8, 0
  9077eb:	1868e5        	l32r	a8, 8e1b80 <athos_indirection_table_install+0x60c>
  9077ee:	c09f      	movi.n	a9, 15
  9077f0:	0c0200        	memw
  9077f3:	9980      	s32i.n	a9, a8, 0

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  9077f5:	196908        	l32r	a9, 8e1c18 <athos_indirection_table_install+0x6a4>

		/* Restore CBus FIFO size to word size */
		iowrite32_usb(ZM_CBUS_FIFO_SIZE_OFFSET, 0xF);
	}

	mUSB_EP3_XFER_DONE();
  9077f8:	c0a8      	movi.n	a10, 8
  9077fa:	289000        	l8ui	a8, a9, 0
  9077fd:	080847        	extui	a8, a8, 0, 8
  907800:	0a8802        	or	a8, a8, a10
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  907803:	0c0200        	memw
  907806:	289400        	s8i	a8, a9, 0

	if (evntbuf != NULL && cmd_end) {
  907809:	186986        	l32r	a8, 8e1e24 <athos_indirection_table_install+0x8b0>
  90780c:	8a80      	l32i.n	a10, a8, 0
  90780e:	c8af      	beqz.n	a10, 907821 <usb_status_in_patch+0xfd>
  907810:	64c00d        	beqz	a12, 907821 <usb_status_in_patch+0xfd>
		usbFifoConf.send_event_done(evntbuf);
  907813:	186982        	l32r	a8, 8e1e1c <athos_indirection_table_install+0x8a8>
  907816:	288203        	l32i	a8, a8, 12
  907819:	0b8000        	callx8	a8
		cmd_is_new = TRUE;
  90781c:	c081      	movi.n	a8, 1
  90781e:	282500        	s16i	a8, a2, 0
  907821:	d10f      	retw.n
	...

00907824 <usb_reg_out_patch>:

/*
 * support more than 64 bytes command on ep4 
 */
void usb_reg_out_patch(void)
{
  907824:	6c1004        	entry	a1, 32

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  907827:	126989        	l32r	a2, 8e1e4c <athos_indirection_table_install+0x8d8>
	static BOOLEAN cmd_is_new = TRUE;

	/* get the size of this transcation */
	usbfifolen = ioread8_usb(ZM_EP4_BYTE_COUNT_LOW_OFFSET);

	if (usbfifolen > USB_EP4_MAX_PKT_SIZE) {
  90782a:	240a40        	movi	a4, 64
  90782d:	222000        	l8ui	a2, a2, 0
  907830:	020247        	extui	a2, a2, 0, 8
	static VBUF *buf;
	BOOLEAN cmd_is_last = FALSE;
	static BOOLEAN cmd_is_new = TRUE;

	/* get the size of this transcation */
	usbfifolen = ioread8_usb(ZM_EP4_BYTE_COUNT_LOW_OFFSET);
  907833:	02034f        	extui	a3, a2, 0, 16

	if (usbfifolen > USB_EP4_MAX_PKT_SIZE) {
  907836:	734b11        	bgeu	a4, a3, 90784b <usb_reg_out_patch+0x27>
		A_PRINTF("EP4 FIFO Bug? Buffer is too big: %x\n", usbfifolen);
  907839:	1468bf        	l32r	a4, 8e1b38 <athos_indirection_table_install+0x5c4>
  90783c:	1a698a        	l32r	a10, 8e1e64 <athos_indirection_table_install+0x8f0>
  90783f:	244212        	l32i	a4, a4, 72
  907842:	022b02        	or	a11, a2, a2
  907845:	0b4000        	callx8	a4
		cold_reboot();
  907848:	5bffad        	call8	907700 <cold_reboot>
	}

	/* check is command is new */
	if(cmd_is_new) {
  90784b:	14698b        	l32r	a4, 8e1e78 <athos_indirection_table_install+0x904>
  90784e:	15698c        	l32r	a5, 8e1e80 <athos_indirection_table_install+0x90c>
  907851:	284100        	l16ui	a8, a4, 0
  907854:	ca8d      	beqz.n	a8, 907885 <usb_reg_out_patch+0x61>

		buf = usbFifoConf.get_command_buf();
  907856:	186982        	l32r	a8, 8e1e60 <athos_indirection_table_install+0x8ec>
  907859:	8a80      	l32i.n	a10, a8, 0
  90785b:	0ba000        	callx8	a10
		cmd_len = 0;
  90785e:	19698d        	l32r	a9, 8e1e94 <athos_indirection_table_install+0x920>
  907861:	c080      	movi.n	a8, 0
	}

	/* check is command is new */
	if(cmd_is_new) {

		buf = usbFifoConf.get_command_buf();
  907863:	9a50      	s32i.n	a10, a5, 0
		cmd_len = 0;
  907865:	289500        	s16i	a8, a9, 0

		if(!buf) {
  907868:	ccad      	bnez.n	a10, 907879 <usb_reg_out_patch+0x55>
			A_PRINTF("%s: Filed to get new buffer.\n", __func__);
  90786a:	1268bf        	l32r	a2, 8e1b68 <athos_indirection_table_install+0x5f4>
  90786d:	1b698e        	l32r	a11, 8e1ea8 <athos_indirection_table_install+0x934>
  907870:	222212        	l32i	a2, a2, 72
  907873:	1a698f        	l32r	a10, 8e1eb0 <athos_indirection_table_install+0x93c>
  907876:	600031        	j	9078ab <usb_reg_out_patch+0x87>
			goto err;
		}

		/* copy free, assignment buffer of the address */
		regaddr = (uint32_t *)buf->desc_list->buf_addr;
  907879:	89a0      	l32i.n	a9, a10, 0

		cmd_is_new = FALSE;
  90787b:	284500        	s16i	a8, a4, 0
			A_PRINTF("%s: Filed to get new buffer.\n", __func__);
			goto err;
		}

		/* copy free, assignment buffer of the address */
		regaddr = (uint32_t *)buf->desc_list->buf_addr;
  90787e:	8a91      	l32i.n	a10, a9, 4
  907880:	196990        	l32r	a9, 8e1ec0 <athos_indirection_table_install+0x94c>
  907883:	9a90      	s32i.n	a10, a9, 0

		cmd_is_new = FALSE;
	}

	/* just in case, suppose should not happen */
	if(!buf)
  907885:	8a50      	l32i.n	a10, a5, 0
  907887:	caa3      	beqz.n	a10, 9078ae <usb_reg_out_patch+0x8a>
	 */
	if(usbfifolen < USB_EP4_MAX_PKT_SIZE)
		cmd_is_last = TRUE;

	/* accumulate the size */
	cmd_len += usbfifolen;
  907889:	19698d        	l32r	a9, 8e1ec0 <athos_indirection_table_install+0x94c>
  90788c:	289100        	l16ui	a8, a9, 0
  90788f:	a838      	add.n	a8, a3, a8
  907891:	08084f        	extui	a8, a8, 0, 16
  907894:	289500        	s16i	a8, a9, 0

	if (cmd_len > buf->desc_list->buf_size) {
  907897:	89a0      	l32i.n	a9, a10, 0
  907899:	259104        	l16ui	a5, a9, 8
  90789c:	785b18        	bgeu	a5, a8, 9078b8 <usb_reg_out_patch+0x94>
		A_PRINTF("%s: Data length on EP4 FIFO is bigger as "
  90789f:	1268bf        	l32r	a2, 8e1b9c <athos_indirection_table_install+0x628>
  9078a2:	1b698e        	l32r	a11, 8e1edc <athos_indirection_table_install+0x968>
  9078a5:	222212        	l32i	a2, a2, 72
  9078a8:	1a6991        	l32r	a10, 8e1eec <athos_indirection_table_install+0x978>
  9078ab:	0b2000        	callx8	a2
		usbfifolen = (usbfifolen >> 2) + 1;
	else
		usbfifolen = usbfifolen >> 2;

	/* retrieve the data from fifo */
	for(ii = 0; ii < usbfifolen; ii++) {
  9078ae:	c020      	movi.n	a2, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  9078b0:	146992        	l32r	a4, 8e1ef8 <athos_indirection_table_install+0x984>
  9078b3:	600067        	j	90791e <usb_reg_out_patch+0xfa>
  9078b6:	000003        	xor	a0, a0, a0
		goto err;
	}

	/* round it to alignment */
	if(usbfifolen % 4)
		usbfifolen = (usbfifolen >> 2) + 1;
  9078b9:	2b141c        	s8i	a11, a1, 28
  9078bc:	699002        	bnei	a9, -1, 9078c2 <usb_reg_out_patch+0x9e>
			 "allocated buffer data! Drop it!\n", __func__);
		goto err;
	}

	/* round it to alignment */
	if(usbfifolen % 4)
  9078bf:	0241b1        	excw
		usbfifolen = (usbfifolen >> 2) + 1;
  9078c2:	b502      	addi.n	a2, a0, 5
  9078c4:	b538      	addi.n	a8, a3, 5
  9078c6:	8bc0      	l32i.n	a11, a12, 0
  9078c8:	0e5211        	slli	a2, a5, 2
  9078cb:	a2b2      	add.n	a2, a11, a2
	else
		usbfifolen = usbfifolen >> 2;

	/* retrieve the data from fifo */
	for(ii = 0; ii < usbfifolen; ii++) {
  9078cd:	c0d0      	movi.n	a13, 0
  9078cf:	156992        	l32r	a5, 8e1f18 <athos_indirection_table_install+0x9a4>
  9078d2:	c0e1      	movi.n	a14, 1
  9078d4:	60000e        	j	9078e6 <usb_reg_out_patch+0xc2>
  9078d7:	000c02        	or	a12, a0, a0
  9078da:	008d50        	extui	a13, a0, 24, 1
		/* read fifo data out */
		ep4_data = ioread32_usb(ZM_EP4_DATA_OFFSET);
		*regaddr = ep4_data;
  9078dd:	0c0200        	memw
  9078e0:	9db0      	s32i.n	a13, a11, 0
		regaddr++;
  9078e2:	b4bb      	addi.n	a11, a11, 4
  9078e4:	dde0      	mov.n	a13, a14
		usbfifolen = (usbfifolen >> 2) + 1;
	else
		usbfifolen = usbfifolen >> 2;

	/* retrieve the data from fifo */
	for(ii = 0; ii < usbfifolen; ii++) {
  9078e6:	7b29ee        	bne	a2, a11, 9078d8 <usb_reg_out_patch+0xb4>
  9078e9:	c8d0      	beqz.n	a13, 9078ed <usb_reg_out_patch+0xc9>
  9078eb:	92c0      	s32i.n	a2, a12, 0
		*regaddr = ep4_data;
		regaddr++;
	}

	/* if this is the last command, callback to HTC */
	if (cmd_is_last) {
  9078ed:	c32f      	movi.n	a2, 63
  9078ef:	73232e        	bltu	a2, a3, 907921 <usb_reg_out_patch+0xfd>
		buf->desc_list->next_desc = NULL;
  9078f2:	c020      	movi.n	a2, 0
  9078f4:	9290      	s32i.n	a2, a9, 0
		buf->desc_list->data_offset = 0;
  9078f6:	229505        	s16i	a2, a9, 10
		buf->desc_list->data_size = cmd_len;
		buf->desc_list->control = 0;
  9078f9:	229507        	s16i	a2, a9, 14

	/* if this is the last command, callback to HTC */
	if (cmd_is_last) {
		buf->desc_list->next_desc = NULL;
		buf->desc_list->data_offset = 0;
		buf->desc_list->data_size = cmd_len;
  9078fc:	289506        	s16i	a8, a9, 12
		buf->desc_list->control = 0;
		buf->next_buf = NULL;
  9078ff:	92a1      	s32i.n	a2, a10, 4
		buf->buf_length = cmd_len;

		usbFifoConf.recv_command(buf);
  907901:	126982        	l32r	a2, 8e1f0c <athos_indirection_table_install+0x998>
		buf->desc_list->next_desc = NULL;
		buf->desc_list->data_offset = 0;
		buf->desc_list->data_size = cmd_len;
		buf->desc_list->control = 0;
		buf->next_buf = NULL;
		buf->buf_length = cmd_len;
  907904:	28a504        	s16i	a8, a10, 8

		usbFifoConf.recv_command(buf);
  907907:	8221      	l32i.n	a2, a2, 4
  907909:	0b2000        	callx8	a2

		cmd_is_new = TRUE;
  90790c:	c021      	movi.n	a2, 1
  90790e:	224500        	s16i	a2, a4, 0
  907911:	d10f      	retw.n
  907913:	00b122        	excw
  907916:	0c0200        	memw
  907919:	8540      	l32i.n	a5, a4, 0
	goto done;
err:
	/* we might get no command buffer here?
	 * but if we return here, the ep4 fifo will be lock out,
	 * so that we still read them out but just drop it? */
	for(ii = 0; ii < usbfifolen; ii++)
  90791b:	02024f        	extui	a2, a2, 0, 16
  90791e:	7323f2        	bltu	a2, a3, 907914 <usb_reg_out_patch+0xf0>
  907921:	d10f      	retw.n
	...

00907924 <vUSBFIFO_EP6Cfg_FS_patch>:
#define FS_C1_I0_A0_EP6_MAP		\
	 (FS_C1_I0_A0_EP6_FIFO_START | (FS_C1_I0_A0_EP6_FIFO_START << 4) | \
	  (MASK_F0 >> (4*FS_C1_I0_A0_EP6_DIRECTION)))

void vUSBFIFO_EP6Cfg_FS_patch(void)
{
  907924:	6c1004        	entry	a1, 32
#if (FS_C1_I0_A0_EP_NUMBER >= 6)
	int i;

	/* EP0X06 */
	mUsbEPMap(EP6, FS_C1_I0_A0_EP6_MAP);
  907927:	2b0a6f        	movi	a11, 111
  90792a:	2a0a06        	movi	a10, 6
  90792d:	5b73f2        	call8	8e48f8 <mUsbEPMap>
	mUsbFIFOMap(FS_C1_I0_A0_EP6_FIFO_START, FS_C1_I0_A0_EP6_FIFO_MAP);
  907930:	2b0a06        	movi	a11, 6
  907933:	0bba02        	or	a10, a11, a11
  907936:	5b73f7        	call8	8e4914 <mUsbFIFOMap>
	mUsbFIFOConfig(FS_C1_I0_A0_EP6_FIFO_START, FS_C1_I0_A0_EP6_FIFO_CONFIG);
  907939:	2b0a86        	movi	a11, 134
  90793c:	c0a6      	movi.n	a10, 6
  90793e:	5b73fd        	call8	8e4934 <mUsbFIFOConfig>

	for(i = FS_C1_I0_A0_EP6_FIFO_START + 1 ;
            i < FS_C1_I0_A0_EP6_FIFO_START + FS_C1_I0_A0_EP6_FIFO_NO ; i ++)
	{
		mUsbFIFOConfig(i, (FS_C1_I0_A0_EP6_FIFO_CONFIG & (~BIT7)) );
  907941:	c0b6      	movi.n	a11, 6
  907943:	c0a7      	movi.n	a10, 7
  907945:	5b73fb        	call8	8e4934 <mUsbFIFOConfig>
	}

	mUsbEPMxPtSzHigh(EP6, FS_C1_I0_A0_EP6_DIRECTION,
  907948:	c4c0      	movi.n	a12, 64
  90794a:	c0b1      	movi.n	a11, 1
  90794c:	c0a6      	movi.n	a10, 6
  90794e:	5b7401        	call8	8e4954 <mUsbEPMxPtSzHigh>
			 (FS_C1_I0_A0_EP6_MAX_PACKET & 0x7ff));
	mUsbEPMxPtSzLow(EP6, FS_C1_I0_A0_EP6_DIRECTION,
  907951:	c4c0      	movi.n	a12, 64
  907953:	c0b1      	movi.n	a11, 1
  907955:	c0a6      	movi.n	a10, 6
  907957:	5b7409        	call8	8e497c <mUsbEPMxPtSzLow>
			(FS_C1_I0_A0_EP6_MAX_PACKET & 0x7ff));
	mUsbEPinHighBandSet(EP6, FS_C1_I0_A0_EP6_DIRECTION,
  90795a:	c4c0      	movi.n	a12, 64
  90795c:	c0b1      	movi.n	a11, 1
  90795e:	2a0a06        	movi	a10, 6
  907961:	5b740f        	call8	8e49a0 <mUsbEPinHighBandSet>
  907964:	d10f      	retw.n
	...

00907968 <vUsbFIFO_EPxCfg_FS_patch>:
			    FS_C1_I0_A0_EP6_MAX_PACKET);
#endif
}

void vUsbFIFO_EPxCfg_FS_patch(void)
{
  907968:	6c1004        	entry	a1, 32
	switch (u8UsbConfigValue)
  90796b:	186993        	l32r	a8, 8e1fb8 <athos_indirection_table_install+0xa44>
  90796e:	288100        	l16ui	a8, a8, 0
  907971:	698113        	bnei	a8, 1, 907988 <vUsbFIFO_EPxCfg_FS_patch+0x20>
	{
#if (FS_CONFIGURATION_NUMBER >= 1)
		/* Configuration 0X01 */
        case 0X01:
		switch (u8UsbInterfaceValue)
  907974:	186994        	l32r	a8, 8e1fc4 <athos_indirection_table_install+0xa50>
  907977:	288100        	l16ui	a8, a8, 0
  90797a:	cc8a      	bnez.n	a8, 907988 <vUsbFIFO_EPxCfg_FS_patch+0x20>
		{
#if (FS_C1_INTERFACE_NUMBER >= 1)
			/* Interface 0 */
                case 0:
			switch (u8UsbInterfaceAlternateSetting)
  90797c:	186995        	l32r	a8, 8e1fd0 <athos_indirection_table_install+0xa5c>
  90797f:	288100        	l16ui	a8, a8, 0
  907982:	658002        	bnez	a8, 907988 <vUsbFIFO_EPxCfg_FS_patch+0x20>
                        case 0:

				/* snapped.... */

				/* patch up this ep6_fs config */
				vUSBFIFO_EP6Cfg_FS_patch();
  907985:	5bffe7        	call8	907924 <vUSBFIFO_EP6Cfg_FS_patch>
  907988:	d10f      	retw.n
	...

0090798c <bSet_configuration_patch>:
	}
	/* mCHECK_STACK(); */
}

BOOLEAN bSet_configuration_patch(void)
{
  90798c:	6c1004        	entry	a1, 32
	/* do some defaul configuration */
	bSet_configuration();
  90798f:	5b7071        	call8	8e3b54 <bSet_configuration>

	/* overwrite defaul FIFO configuration for FullSpeed USB */
	if ((mLOW_BYTE(mDEV_REQ_VALUE()) != 0) && !mUsbHighSpeedST())
  907992:	126996        	l32r	a2, 8e1fec <athos_indirection_table_install+0xa78>
  907995:	222007        	l8ui	a2, a2, 7
  907998:	c82a      	beqz.n	a2, 9079a6 <bSet_configuration_patch+0x1a>

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  90799a:	1268e0        	l32r	a2, 8e1d1c <athos_indirection_table_install+0x7a8>
  90799d:	222000        	l8ui	a2, a2, 0
  9079a0:	792f02        	bbsi	a2, 25, 9079a6 <bSet_configuration_patch+0x1a>
			vUsbFIFO_EPxCfg_FS_patch();
  9079a3:	5bfff1        	call8	907968 <vUsbFIFO_EPxCfg_FS_patch>

	eUsbCxFinishAction = ACT_DONE;
  9079a6:	186997        	l32r	a8, 8e2004 <athos_indirection_table_install+0xa90>
  9079a9:	c021      	movi.n	a2, 1
  9079ab:	9280      	s32i.n	a2, a8, 0
	return TRUE;
}
  9079ad:	d10f      	retw.n
	...

009079b0 <bStandardCommand_patch>:

extern BOOLEAN bStandardCommand(void);

BOOLEAN bStandardCommand_patch(void)
{
  9079b0:	6c1004        	entry	a1, 32
	if (mDEV_REQ_REQ() == USB_SET_CONFIGURATION) {
  9079b3:	186996        	l32r	a8, 8e200c <athos_indirection_table_install+0xa98>
  9079b6:	298102        	l16ui	a9, a8, 4
  9079b9:	280a09        	movi	a8, 9
  9079bc:	78992d        	bne	a9, a8, 9079ed <bStandardCommand_patch+0x3d>
		A_USB_SET_CONFIG();
  9079bf:	1868bf        	l32r	a8, 8e1cbc <athos_indirection_table_install+0x748>
  9079c2:	2a8226        	l32i	a10, a8, 152
  9079c5:	0ba000        	callx8	a10

#if ENABLE_SWAP_DATA_MODE
		/* SWAP FUNCTION should be enabled while DMA engine
		 * is not working, the best place to enable it
		 * is before we trigger the DMA */
		MAGPIE_REG_USB_RX0_SWAP_DATA = 0x1;
  9079c8:	1868fe        	l32r	a8, 8e1dc0 <athos_indirection_table_install+0x84c>
  9079cb:	c0a1      	movi.n	a10, 1
  9079cd:	0c0200        	memw
  9079d0:	9a80      	s32i.n	a10, a8, 0
		MAGPIE_REG_USB_TX0_SWAP_DATA = 0x1;
  9079d2:	1868ff        	l32r	a8, 8e1dd0 <athos_indirection_table_install+0x85c>
  9079d5:	0c0200        	memw
  9079d8:	9a80      	s32i.n	a10, a8, 0

#if SYSTEM_MODULE_HP_EP5
		MAGPIE_REG_USB_RX1_SWAP_DATA = 0x1;
  9079da:	186900        	l32r	a8, 8e1ddc <athos_indirection_table_install+0x868>
  9079dd:	0c0200        	memw
  9079e0:	9a80      	s32i.n	a10, a8, 0
#endif

#if SYSTEM_MODULE_HP_EP6
		MAGPIE_REG_USB_RX2_SWAP_DATA = 0x1;
  9079e2:	186901        	l32r	a8, 8e1de8 <athos_indirection_table_install+0x874>
  9079e5:	0c0200        	memw
  9079e8:	9a80      	s32i.n	a10, a8, 0
#endif

#endif /* ENABLE_SWAP_DATA_MODE */
		return TRUE;
  9079ea:	600002        	j	9079f0 <bStandardCommand_patch+0x40>
	} else
		return bStandardCommand();
  9079ed:	5b711d        	call8	8e3e64 <bStandardCommand>
}
  9079f0:	d2a0      	mov.n	a2, a10
  9079f2:	d10f      	retw.n

009079f4 <bGet_descriptor_patch>:
#define EP3_INT_INTERVAL		19
#define EP4_TRANSFER_TYPE_OFFSET	21
#define EP4_INT_INTERVAL		22

BOOLEAN bGet_descriptor_patch(void)
{
  9079f4:	6c1004        	entry	a1, 32
	if (mDEV_REQ_VALUE_HIGH() == 1)
  9079f7:	126996        	l32r	a2, 8e2050 <athos_indirection_table_install+0xadc>
  9079fa:	282103        	l16ui	a8, a2, 6
  9079fd:	088814        	srli	a8, a8, 8
  907a00:	698120        	bnei	a8, 1, 907a24 <bGet_descriptor_patch+0x30>
	{
		uint8_t *p = (uint8_t *)u8UsbDeviceDescriptor;
  907a03:	146998        	l32r	a4, 8e2064 <athos_indirection_table_install+0xaf0>

		/* Copy Usb Device Descriptor */
		ath_hal_memcpy(UsbDeviceDescriptorPatch, p,
  907a06:	136999        	l32r	a3, 8e206c <athos_indirection_table_install+0xaf8>
  907a09:	8b40      	l32i.n	a11, a4, 0
  907a0b:	da30      	mov.n	a10, a3
  907a0d:	c1c2      	movi.n	a12, 18
  907a0f:	580035        	call8	907ae4 <ath_hal_memcpy>
				sizeof(UsbDeviceDescriptorPatch));

		/* Change bcdDevice. we need it to detect if FW
		 * was uploaded. */
		UsbDeviceDescriptorPatch[BCD_DEVICE_OFFSET] =
  907a12:	c78f      	movi.n	a8, -1
  907a14:	283506        	s16i	a8, a3, 12
			BCD_DEVICE_FW_SIGNATURE;

		pu8DescriptorEX = UsbDeviceDescriptorPatch;
  907a17:	18699a        	l32r	a8, 8e2080 <athos_indirection_table_install+0xb0c>
  907a1a:	9380      	s32i.n	a3, a8, 0
		u16TxRxCounter = mTABLE_LEN(u8UsbDeviceDescriptor[0]);
  907a1c:	8340      	l32i.n	a3, a4, 0
  907a1e:	283001        	l8ui	a8, a3, 1
  907a21:	600024        	j	907a49 <bGet_descriptor_patch+0x55>
			u16TxRxCounter = mDEV_REQ_LENGTH();

		A_USB_EP0_TX_DATA();

		return TRUE;
	} else if (mDEV_REQ_VALUE_HIGH() == 2) {
  907a24:	69823e        	bnei	a8, 2, 907a66 <bGet_descriptor_patch+0x72>
		uint8_t *p = (uint8_t *)u8ConfigDescriptorEX;

		/* Copy ConfigDescriptor */
		ath_hal_memcpy(ConfigDescriptorPatch, p,
  907a27:	14699c        	l32r	a4, 8e2098 <athos_indirection_table_install+0xb24>
  907a2a:	13699d        	l32r	a3, 8e20a0 <athos_indirection_table_install+0xb2c>
  907a2d:	2b4200        	l32i	a11, a4, 0
  907a30:	2c0a3c        	movi	a12, 60
  907a33:	033a02        	or	a10, a3, a3
  907a36:	58002b        	call8	907ae4 <ath_hal_memcpy>
				sizeof(ConfigDescriptorPatch));

		 /* place holder for EPx patches */

		if (mDEV_REQ_VALUE_LOW() == 0) {
  907a39:	242007        	l8ui	a4, a2, 7
			/* configuration no: 0 */
			pu8DescriptorEX = ConfigDescriptorPatch;
			u16TxRxCounter = ConfigDescriptorPatch[1];
		} else
			return FALSE;
  907a3c:	c0a0      	movi.n	a10, 0
		ath_hal_memcpy(ConfigDescriptorPatch, p,
				sizeof(ConfigDescriptorPatch));

		 /* place holder for EPx patches */

		if (mDEV_REQ_VALUE_LOW() == 0) {
  907a3e:	7a4927        	bne	a4, a10, 907a69 <bGet_descriptor_patch+0x75>
			/* configuration no: 0 */
			pu8DescriptorEX = ConfigDescriptorPatch;
  907a41:	14699a        	l32r	a4, 8e20ac <athos_indirection_table_install+0xb38>
			u16TxRxCounter = ConfigDescriptorPatch[1];
  907a44:	283101        	l16ui	a8, a3, 2

		 /* place holder for EPx patches */

		if (mDEV_REQ_VALUE_LOW() == 0) {
			/* configuration no: 0 */
			pu8DescriptorEX = ConfigDescriptorPatch;
  907a47:	9340      	s32i.n	a3, a4, 0
			u16TxRxCounter = ConfigDescriptorPatch[1];
  907a49:	13699b        	l32r	a3, 8e20b8 <athos_indirection_table_install+0xb44>
		} else
			return FALSE;

		if (u16TxRxCounter > mDEV_REQ_LENGTH())
  907a4c:	222105        	l16ui	a2, a2, 10
		 /* place holder for EPx patches */

		if (mDEV_REQ_VALUE_LOW() == 0) {
			/* configuration no: 0 */
			pu8DescriptorEX = ConfigDescriptorPatch;
			u16TxRxCounter = ConfigDescriptorPatch[1];
  907a4f:	283500        	s16i	a8, a3, 0
		} else
			return FALSE;

		if (u16TxRxCounter > mDEV_REQ_LENGTH())
  907a52:	782b02        	bgeu	a2, a8, 907a58 <bGet_descriptor_patch+0x64>
			u16TxRxCounter = mDEV_REQ_LENGTH();
  907a55:	223500        	s16i	a2, a3, 0

		A_USB_EP0_TX_DATA();
  907a58:	1268bf        	l32r	a2, 8e1d54 <athos_indirection_table_install+0x7e0>
  907a5b:	222235        	l32i	a2, a2, 212
  907a5e:	0b2000        	callx8	a2
		return TRUE;
  907a61:	c0a1      	movi.n	a10, 1
  907a63:	600002        	j	907a69 <bGet_descriptor_patch+0x75>
	} else
		return bGet_descriptor();
  907a66:	5b700d        	call8	8e3a9c <bGet_descriptor>
}
  907a69:	d2a0      	mov.n	a2, a10
  907a6b:	d10f      	retw.n
  907a6d:	000000        	ill

00907a70 <ath_hal_getuptime>:
#include<ah_internal.h>
#include "ah_osdep.h"

a_uint32_t __ahdecl
ath_hal_getuptime(struct ath_hal *ah)
{
  907a70:	6c1004        	entry	a1, 32
	return MSEC_TO_TICK(msecs);
}
static inline unsigned long
__adf_os_getuptime(void)
{
    return MSEC_TO_TICK(A_MILLISECONDS());;      
  907a73:	1868bf        	l32r	a8, 8e1d70 <athos_indirection_table_install+0x7fc>
  907a76:	2a823e        	l32i	a10, a8, 248
  907a79:	0ba000        	callx8	a10
	return adf_os_getuptime();
}
  907a7c:	d2a0      	mov.n	a2, a10
  907a7e:	d10f      	retw.n

00907a80 <_ath_hal_attach_tgt>:

struct ath_hal *
_ath_hal_attach_tgt(a_uint32_t devid, HAL_SOFTC sc,
		    adf_os_device_t dev, a_uint32_t flags, void* s)
{
  907a80:	6c1006        	entry	a1, 48
	HAL_STATUS status;
	struct ath_hal *ah = ath_hal_attach_tgt(devid, sc, dev, flags, &status);
  907a83:	de10      	mov.n	a14, a1
  907a85:	dd50      	mov.n	a13, a5
  907a87:	dc40      	mov.n	a12, a4
  907a89:	db30      	mov.n	a11, a3
  907a8b:	da20      	mov.n	a10, a2
  907a8d:	580c7f        	call8	90ac8c <ath_hal_attach_tgt>
	adf_os_print(" ath_hal = %p \n",ah);
  907a90:	1868bf        	l32r	a8, 8e1d8c <athos_indirection_table_install+0x818>
  907a93:	dba0      	mov.n	a11, a10
struct ath_hal *
_ath_hal_attach_tgt(a_uint32_t devid, HAL_SOFTC sc,
		    adf_os_device_t dev, a_uint32_t flags, void* s)
{
	HAL_STATUS status;
	struct ath_hal *ah = ath_hal_attach_tgt(devid, sc, dev, flags, &status);
  907a95:	d2a0      	mov.n	a2, a10
	adf_os_print(" ath_hal = %p \n",ah);
  907a97:	288212        	l32i	a8, a8, 72
  907a9a:	1a699e        	l32r	a10, 8e2114 <athos_indirection_table_install+0xba0>
  907a9d:	0b8000        	callx8	a8
	*(HAL_STATUS *)s = status;
  907aa0:	8810      	l32i.n	a8, a1, 0
  907aa2:	9860      	s32i.n	a8, a6, 0
	return ah;
}
  907aa4:	d10f      	retw.n
	...

00907aa8 <ath_hal_delay>:
/*
 * Delay n microseconds.
 */
void __ahdecl
ath_hal_delay(a_int32_t n)
{
  907aa8:	6c1004        	entry	a1, 32
}

static inline void
__adf_os_udelay(int usecs)
{
    A_DELAY_USECS(usecs);
  907aab:	1868bf        	l32r	a8, 8e1da8 <athos_indirection_table_install+0x834>
  907aae:	da20      	mov.n	a10, a2
  907ab0:	28823b        	l32i	a8, a8, 236
  907ab3:	0b8000        	callx8	a8
  907ab6:	d10f      	retw.n

00907ab8 <ath_hal_malloc>:
/*
 * Allocate/free memory.
 */
void * __ahdecl
ath_hal_malloc(adf_os_size_t size)
{
  907ab8:	6c1004        	entry	a1, 32
  907abb:	1468bf        	l32r	a4, 8e1db8 <athos_indirection_table_install+0x844>
  907abe:	d320      	mov.n	a3, a2
  907ac0:	224252        	l32i	a2, a4, 0x148
  907ac3:	db30      	mov.n	a11, a3
  907ac5:	c0a0      	movi.n	a10, 0
  907ac7:	0b2000        	callx8	a2
  907aca:	d2a0      	mov.n	a2, a10
	void *p;

	p = adf_os_mem_alloc(size);
	if (p)
  907acc:	c8a8      	beqz.n	a10, 907ad8 <ath_hal_malloc+0x20>
}
/* zero a memory buffer */
static inline void
__adf_os_mem_zero(void *buf, adf_os_size_t size)
{
    A_MEMZERO(buf,size);
  907ace:	8444      	l32i.n	a4, a4, 16
  907ad0:	dc30      	mov.n	a12, a3
  907ad2:	2b0a00        	movi	a11, 0
  907ad5:	0b4000        	callx8	a4
		adf_os_mem_zero(p, size);

	return p;
}
  907ad8:	d10f      	retw.n
	...

00907adc <ath_hal_free>:

void __ahdecl
ath_hal_free(void* p)
{
  907adc:	6c1004        	entry	a1, 32
  907adf:	d10f      	retw.n
  907ae1:	000000        	ill

00907ae4 <ath_hal_memcpy>:
	adf_os_mem_free(p);
}

void * __ahdecl
ath_hal_memcpy(void *dst, const void *src, adf_os_size_t n)
{
  907ae4:	6c1004        	entry	a1, 32
}

/* move a memory buffer */
static inline void 		__adf_os_mem_copy(void *dst, const void *src, adf_os_size_t size)
{
    A_MEMCPY(dst,src,size);    
  907ae7:	1868bf        	l32r	a8, 8e1de4 <athos_indirection_table_install+0x870>
  907aea:	dc40      	mov.n	a12, a4
  907aec:	8885      	l32i.n	a8, a8, 20
  907aee:	db30      	mov.n	a11, a3
  907af0:	da20      	mov.n	a10, a2
  907af2:	0b8000        	callx8	a8
	adf_os_mem_copy(dst, src, n);
	return 0;
}
  907af5:	c020      	movi.n	a2, 0
  907af7:	d10f      	retw.n
  907af9:	000000        	ill

00907afc <__adf_os_mem_alloc>:

#include "cmnos_api.h"
#include "Magpie_api.h"

static inline void *	__adf_os_mem_alloc(adf_os_size_t size)
{
  907afc:	6c1004        	entry	a1, 32
//    return (malloc(size,M_DEVBUF,M_DONTWAIT | M_ZERO));
    return A_ALLOCRAM(size);
  907aff:	1868bf        	l32r	a8, 8e1dfc <athos_indirection_table_install+0x888>
  907b02:	db20      	mov.n	a11, a2
  907b04:	288252        	l32i	a8, a8, 0x148
  907b07:	c0a0      	movi.n	a10, 0
  907b09:	0b8000        	callx8	a8
}
  907b0c:	d2a0      	mov.n	a2, a10
  907b0e:	d10f      	retw.n

00907b10 <__adf_os_mem_copy>:
    //free(buf,M_DEVBUF);
}

/* move a memory buffer */
static inline void 		__adf_os_mem_copy(void *dst, const void *src, adf_os_size_t size)
{
  907b10:	6c1004        	entry	a1, 32
    A_MEMCPY(dst,src,size);    
  907b13:	1868bf        	l32r	a8, 8e1e10 <athos_indirection_table_install+0x89c>
  907b16:	dc40      	mov.n	a12, a4
  907b18:	8885      	l32i.n	a8, a8, 20
  907b1a:	db30      	mov.n	a11, a3
  907b1c:	da20      	mov.n	a10, a2
  907b1e:	0b8000        	callx8	a8
  907b21:	d10f      	retw.n
	...

00907b24 <__adf_os_mem_set>:
}

/* set a memory buffer */
static inline void
__adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
{
  907b24:	6c1004        	entry	a1, 32
	A_MEMSET(buf, b, size);
  907b27:	1868bf        	l32r	a8, 8e1e24 <athos_indirection_table_install+0x8b0>
  907b2a:	dc40      	mov.n	a12, a4
  907b2c:	8884      	l32i.n	a8, a8, 16
  907b2e:	db30      	mov.n	a11, a3
  907b30:	da20      	mov.n	a10, a2
  907b32:	0b8000        	callx8	a8
  907b35:	d10f      	retw.n
	...

00907b38 <tgt_HTCRecv_uapsdhandler>:
	ath_tgt_send_beacon(sc, hdr_buf, buf, EndPt);
}

static void tgt_HTCRecv_uapsdhandler(HTC_ENDPOINT_ID EndPt, adf_nbuf_t hdr_buf,
				     adf_nbuf_t buf, void *ServiceCtx)
{
  907b38:	6c1004        	entry	a1, 32
  907b3b:	d10f      	retw.n
  907b3d:	000000        	ill

00907b40 <dispatch_magpie_sys_cmds>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void dispatch_magpie_sys_cmds(void *pContext, A_UINT16 Command,
				     A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
  907b40:	6c1004        	entry	a1, 32
	adf_os_assert(0);
  907b43:	1868bf        	l32r	a8, 8e1e40 <athos_indirection_table_install+0x8cc>
  907b46:	1b699f        	l32r	a11, 8e21c4 <athos_indirection_table_install+0xc50>
  907b49:	288212        	l32i	a8, a8, 72
  907b4c:	1a69a0        	l32r	a10, 8e21cc <athos_indirection_table_install+0xc58>
  907b4f:	0b8000        	callx8	a8
  907b52:	186923        	l32r	a8, 8e1fe0 <athos_indirection_table_install+0xa6c>
  907b55:	0c0200        	memw
  907b58:	8880      	l32i.n	a8, a8, 0
  907b5a:	d10f      	retw.n

00907b5c <htc_setup_comp>:
/*****************/
/* Init / Deinit */
/*****************/

static void htc_setup_comp(void)
{
  907b5c:	6c1004        	entry	a1, 32
  907b5f:	d10f      	retw.n
  907b61:	000000        	ill

00907b64 <tgt_reg_service>:
	return HTC_SERVICE_SUCCESS;
}

static void tgt_reg_service(struct ath_softc_tgt *sc, HTC_SERVICE *svc,
			    int svcId, HTC_SERVICE_ProcessRecvMsg recvMsg)
{
  907b64:	6c1004        	entry	a1, 32
	svc->ProcessRecvMsg = recvMsg;
	svc->ProcessSendBufferComplete = tgt_HTCSendCompleteHandler;
  907b67:	1869a1        	l32r	a8, 8e21ec <athos_indirection_table_install+0xc78>
	svc->ProcessConnect = tgt_ServiceConnect;
	svc->MaxSvcMsgSize = 1600;
	svc->TrailerSpcCheckLimit = 0;
	svc->ServiceID = svcId;
	svc->ServiceCtx = sc;
	HTC_RegisterService(sc->tgt_htc_handle, svc);
  907b6a:	8a22      	l32i.n	a10, a2, 8

static void tgt_reg_service(struct ath_softc_tgt *sc, HTC_SERVICE *svc,
			    int svcId, HTC_SERVICE_ProcessRecvMsg recvMsg)
{
	svc->ProcessRecvMsg = recvMsg;
	svc->ProcessSendBufferComplete = tgt_HTCSendCompleteHandler;
  907b6c:	9832      	s32i.n	a8, a3, 8
	svc->ProcessConnect = tgt_ServiceConnect;
  907b6e:	1869a2        	l32r	a8, 8e21f8 <athos_indirection_table_install+0xc84>
	return HTC_SERVICE_SUCCESS;
}

static void tgt_reg_service(struct ath_softc_tgt *sc, HTC_SERVICE *svc,
			    int svcId, HTC_SERVICE_ProcessRecvMsg recvMsg)
{
  907b71:	db30      	mov.n	a11, a3
	svc->ProcessRecvMsg = recvMsg;
	svc->ProcessSendBufferComplete = tgt_HTCSendCompleteHandler;
	svc->ProcessConnect = tgt_ServiceConnect;
  907b73:	9833      	s32i.n	a8, a3, 12
	svc->MaxSvcMsgSize = 1600;
  907b75:	286a40        	movi	a8, 0x640
  907b78:	28350a        	s16i	a8, a3, 20
	svc->TrailerSpcCheckLimit = 0;
  907b7b:	c080      	movi.n	a8, 0
  907b7d:	28350b        	s16i	a8, a3, 22
	svc->ServiceID = svcId;
	svc->ServiceCtx = sc;
	HTC_RegisterService(sc->tgt_htc_handle, svc);
  907b80:	1868bf        	l32r	a8, 8e1e7c <athos_indirection_table_install+0x908>
}

static void tgt_reg_service(struct ath_softc_tgt *sc, HTC_SERVICE *svc,
			    int svcId, HTC_SERVICE_ProcessRecvMsg recvMsg)
{
	svc->ProcessRecvMsg = recvMsg;
  907b83:	9531      	s32i.n	a5, a3, 4
	svc->ProcessConnect = tgt_ServiceConnect;
	svc->MaxSvcMsgSize = 1600;
	svc->TrailerSpcCheckLimit = 0;
	svc->ServiceID = svcId;
	svc->ServiceCtx = sc;
	HTC_RegisterService(sc->tgt_htc_handle, svc);
  907b85:	288280        	l32i	a8, a8, 0x200
	svc->ProcessRecvMsg = recvMsg;
	svc->ProcessSendBufferComplete = tgt_HTCSendCompleteHandler;
	svc->ProcessConnect = tgt_ServiceConnect;
	svc->MaxSvcMsgSize = 1600;
	svc->TrailerSpcCheckLimit = 0;
	svc->ServiceID = svcId;
  907b88:	243508        	s16i	a4, a3, 16
	svc->ServiceCtx = sc;
  907b8b:	9236      	s32i.n	a2, a3, 24
	HTC_RegisterService(sc->tgt_htc_handle, svc);
  907b8d:	0b8000        	callx8	a8
  907b90:	d10f      	retw.n
	...

00907b94 <tgt_HTCRecv_mgmthandler>:
{
}

static void tgt_HTCRecv_mgmthandler(HTC_ENDPOINT_ID EndPt, adf_nbuf_t hdr_buf,
				    adf_nbuf_t buf, void *ServiceCtx)
{
  907b94:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)ServiceCtx;

	ath_tgt_send_mgt(sc,hdr_buf,buf,EndPt);
  907b97:	dd20      	mov.n	a13, a2
  907b99:	dc40      	mov.n	a12, a4
  907b9b:	db30      	mov.n	a11, a3
  907b9d:	da50      	mov.n	a10, a5
  907b9f:	5818b2        	call8	90de68 <ath_tgt_send_mgt>
  907ba2:	d10f      	retw.n

00907ba4 <ath_descdma_cleanup>:
}

static void ath_descdma_cleanup(struct ath_softc_tgt *sc,
				struct ath_descdma *dd,
				ath_bufhead *head, a_int32_t dir)
{
  907ba4:	6c1006        	entry	a1, 48
	struct ath_buf *bf;
	struct ieee80211_node_target *ni;

	asf_tailq_foreach(bf, head, bf_list) {
  907ba7:	8740      	l32i.n	a7, a4, 0
  907ba9:	60007d        	j	907c2a <ath_descdma_cleanup+0x86>
		if (adf_nbuf_queue_len(&bf->bf_skbhead) != 0) {
  907bac:	267c14        	addi	a6, a7, 20
 * @return length of the queue
 */
static inline a_uint32_t
adf_nbuf_queue_len(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_len(head);
  907baf:	da60      	mov.n	a10, a6
  907bb1:	5bfc3f        	call8	906cb0 <__adf_nbuf_queue_len>
  907bb4:	d9a0      	mov.n	a9, a10
  907bb6:	cbac      	beqz.n	a10, 907bf6 <ath_descdma_cleanup+0x52>
static inline void
adf_nbuf_unmap(adf_os_device_t      osdev, 
               adf_os_dma_map_t     bmap, 
               adf_os_dma_dir_t     dir)
{
    __adf_nbuf_unmap(osdev, bmap, dir);
  907bb8:	2b7200        	l32i	a11, a7, 0
  907bbb:	2a2246        	l32i	a10, a2, 0x118
  907bbe:	055c02        	or	a12, a5, a5
  907bc1:	5bfbae        	call8	906a7c <__adf_nbuf_unmap>
  907bc4:	600021        	j	907be9 <ath_descdma_cleanup+0x45>
  907bc7:	000018        	src	a0, a0, a0
			adf_nbuf_unmap(sc->sc_dev, bf->bf_dmamap, dir);
			while(adf_nbuf_queue_len(&bf->bf_skbhead) != 0) {
				ath_free_rx_skb(sc,
  907bca:	68bf8d        	beqi	a11, 0x100, 907b5b <dispatch_magpie_sys_cmds+0x1b>
  907bcd:	202982        	l16si	a0, a2, 0x104
  907bd0:	9eda      	s32i.n	a14, a13, 40
 * @return The head buf in the buf queue.
 */
static inline adf_nbuf_t
adf_nbuf_queue_remove(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_remove(head);
  907bd2:	609911        	j	9114e7 <_etext+0x22b6>
  907bd5:	9d10      	s32i.n	a13, a1, 0
  907bd7:	5bfb95        	call8	906a2c <__adf_nbuf_queue_remove>
  907bda:	8d10      	l32i.n	a13, a1, 0
  907bdc:	8911      	l32i.n	a9, a1, 4
  907bde:	0aac02        	or	a12, a10, a10
  907be1:	2b0a03        	movi	a11, 3
  907be4:	dad0      	mov.n	a10, a13
  907be6:	0b9000        	callx8	a9
 * @return length of the queue
 */
static inline a_uint32_t
adf_nbuf_queue_len(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_len(head);
  907be9:	da60      	mov.n	a10, a6
  907beb:	5bfc31        	call8	906cb0 <__adf_nbuf_queue_len>
	struct ieee80211_node_target *ni;

	asf_tailq_foreach(bf, head, bf_list) {
		if (adf_nbuf_queue_len(&bf->bf_skbhead) != 0) {
			adf_nbuf_unmap(sc->sc_dev, bf->bf_dmamap, dir);
			while(adf_nbuf_queue_len(&bf->bf_skbhead) != 0) {
  907bee:	65afd7        	bnez	a10, 907bc9 <ath_descdma_cleanup+0x25>
				ath_free_rx_skb(sc,
					adf_nbuf_queue_remove(&bf->bf_skbhead));
			}
			bf->bf_skb = NULL;
  907bf1:	9a78      	s32i.n	a10, a7, 32
  907bf3:	600025        	j	907c1c <ath_descdma_cleanup+0x78>
		} else if (bf->bf_skb != NULL) {
  907bf6:	8678      	l32i.n	a6, a7, 32
  907bf8:	ca60      	beqz.n	a6, 907c1c <ath_descdma_cleanup+0x78>
static inline void
adf_nbuf_unmap(adf_os_device_t      osdev, 
               adf_os_dma_map_t     bmap, 
               adf_os_dma_dir_t     dir)
{
    __adf_nbuf_unmap(osdev, bmap, dir);
  907bfa:	2b7200        	l32i	a11, a7, 0
  907bfd:	2a2246        	l32i	a10, a2, 0x118
  907c00:	055c02        	or	a12, a5, a5
  907c03:	291601        	s32i	a9, a1, 4
  907c06:	5bfb9d        	call8	906a7c <__adf_nbuf_unmap>
			adf_nbuf_unmap(sc->sc_dev,bf->bf_dmamap, dir);
			ath_free_rx_skb(sc, bf->bf_skb);
  907c09:	1868bf        	l32r	a8, 8e1f08 <athos_indirection_table_install+0x994>
  907c0c:	8c78      	l32i.n	a12, a7, 32
  907c0e:	8a20      	l32i.n	a10, a2, 0
  907c10:	26829e        	l32i	a6, a8, 0x278
  907c13:	c0b3      	movi.n	a11, 3
  907c15:	0b6000        	callx8	a6
			bf->bf_skb = NULL;
  907c18:	8911      	l32i.n	a9, a1, 4
  907c1a:	9978      	s32i.n	a9, a7, 32
 * @param[in] dmap
 */
static inline void
adf_nbuf_dmamap_destroy(adf_os_device_t osdev, adf_os_dma_map_t dmap)
{
    __adf_nbuf_dmamap_destroy(osdev, dmap);
  907c1c:	8b70      	l32i.n	a11, a7, 0
  907c1e:	2a2246        	l32i	a10, a2, 0x118
		}

		adf_nbuf_dmamap_destroy(sc->sc_dev, bf->bf_dmamap);

		ni = bf->bf_node;
		bf->bf_node = NULL;
  907c21:	c060      	movi.n	a6, 0
  907c23:	5bfb99        	call8	906a88 <__adf_nbuf_dmamap_destroy>
  907c26:	9674      	s32i.n	a6, a7, 16
				ath_bufhead *head, a_int32_t dir)
{
	struct ath_buf *bf;
	struct ieee80211_node_target *ni;

	asf_tailq_foreach(bf, head, bf_list) {
  907c28:	8779      	l32i.n	a7, a7, 36
  907c2a:	657f7e        	bnez	a7, 907bac <ath_descdma_cleanup+0x8>
	}

	adf_os_dmamem_free(sc->sc_dev, dd->dd_desc_len,
			   1, dd->dd_desc, dd->dd_desc_dmamap);

	asf_tailq_init(head);
  907c2d:	9740      	s32i.n	a7, a4, 0
  907c2f:	9441      	s32i.n	a4, a4, 4
 * @param[in] size  buffer size
 */
static inline void
adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
{
    __adf_os_mem_set(buf, b, size);
  907c31:	c1c8      	movi.n	a12, 24
  907c33:	db70      	mov.n	a11, a7
  907c35:	da30      	mov.n	a10, a3
  907c37:	5bffbb        	call8	907b24 <__adf_os_mem_set>
  907c3a:	d10f      	retw.n

00907c3c <__adf_os_init_bh$isra$5>:
									  void 				*arg)
{
	__adf_os_init_defer(work, func, arg);
}

static inline void	__adf_os_init_bh(adf_os_handle_t  hdl,
  907c3c:	6c1004        	entry	a1, 32
									 __adf_os_bh_t		*bh,
									 adf_os_defer_fn_t	func,
									 void				*arg)
{
	//__adf_os_init_defer(bh, func, arg);
	A_TASKLET_INIT_TASK(func, arg, bh);
  907c3f:	1868bf        	l32r	a8, 8e1f3c <athos_indirection_table_install+0x9c8>
  907c42:	dc20      	mov.n	a12, a2
  907c44:	28826a        	l32i	a8, a8, 0x1a8
  907c47:	db40      	mov.n	a11, a4
  907c49:	da30      	mov.n	a10, a3
  907c4b:	0b8000        	callx8	a8
  907c4e:	d10f      	retw.n

00907c50 <__adf_os_sched_bh$isra$6>:
                                         __adf_os_work_t  * work)
{
    //taskqueue_drain(taskqueue_thread, &work->tsk);
}

static inline void __adf_os_sched_bh(adf_os_handle_t  hdl, 
  907c50:	6c1004        	entry	a1, 32
                                       __adf_os_bh_t  * bh)
{
    A_TASKLET_SCHEDULE(bh);
  907c53:	1868bf        	l32r	a8, 8e1f50 <athos_indirection_table_install+0x9dc>
  907c56:	da20      	mov.n	a10, a2
  907c58:	28826c        	l32i	a8, a8, 0x1b0
  907c5b:	0b8000        	callx8	a8
  907c5e:	d10f      	retw.n

00907c60 <ath_tgt_rx_tasklet>:

	return 0;
}

static void ath_tgt_rx_tasklet(TQUEUE_ARG data)
{
  907c60:	6c1006        	entry	a1, 48
	struct ath_softc_tgt *sc  = (struct ath_softc_tgt *)data;
	struct ath_rx_buf *bf = NULL;
	struct ath_hal *ah = sc->sc_ah;
  907c63:	252d05        	addmi	a5, a2, 0x500
  907c66:	835b      	l32i.n	a3, a5, 44
			continue;
		}

		asf_tailq_remove(&sc->sc_rxbuf, bf, bf_list);

		bf->bf_skb = NULL;
  907c68:	c040      	movi.n	a4, 0

static void ath_tgt_rx_tasklet(TQUEUE_ARG data)
{
	struct ath_softc_tgt *sc  = (struct ath_softc_tgt *)data;
	struct ath_rx_buf *bf = NULL;
	struct ath_hal *ah = sc->sc_ah;
  907c6a:	231600        	s32i	a3, a1, 0
	struct rx_frame_header *rxhdr;
	struct ath_rx_status *rxstats;
	adf_nbuf_t skb = ADF_NBUF_NULL;

	do {
		bf = asf_tailq_first(&sc->sc_rxbuf);
  907c6d:	2322d5        	l32i	a3, a2, 0x354
		if (bf == NULL) {
  907c70:	64308c        	beqz	a3, 907d00 <ath_tgt_rx_tasklet+0xa0>
			break;
		}

		if (!(bf->bf_status & ATH_BUFSTATUS_DONE)) {
  907c73:	863f      	l32i.n	a6, a3, 60
  907c75:	7f6f02        	bbsi	a6, 31, 907c7b <ath_tgt_rx_tasklet+0x1b>
  907c78:	600084        	j	907d00 <ath_tgt_rx_tasklet+0xa0>
			break;
		}

		skb = bf->bf_skb;
  907c7b:	8d38      	l32i.n	a13, a3, 32
		if (skb == NULL) {
  907c7d:	64dfef        	beqz	a13, 907c70 <ath_tgt_rx_tasklet+0x10>
			continue;
		}

		asf_tailq_remove(&sc->sc_rxbuf, bf, bf_list);
  907c80:	8639      	l32i.n	a6, a3, 36
  907c82:	873a      	l32i.n	a7, a3, 40
  907c84:	c864      	beqz.n	a6, 907c8c <ath_tgt_rx_tasklet+0x2c>
  907c86:	976a      	s32i.n	a7, a6, 40
  907c88:	600003        	j	907c8f <ath_tgt_rx_tasklet+0x2f>
  907c8b:	002726        	excw
  907c8e:	d687      	excw
  907c90:	3adad0        	excw
  907c93:	9670      	s32i.n	a6, a7, 0

		bf->bf_skb = NULL;
  907c95:	9438      	s32i.n	a4, a3, 32
 *         or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_push_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_push_head(buf, size);
  907c97:	2b0a28        	movi	a11, 40
  907c9a:	2d1601        	s32i	a13, a1, 4
  907c9d:	5bfb23        	call8	90692c <__adf_nbuf_push_head>
 * @param[in] size    buffer size
 */
static inline void
adf_os_mem_copy(void *dst, const void *src, adf_os_size_t size)
{
    __adf_os_mem_copy(dst, src, size);
  907ca0:	c2c8      	movi.n	a12, 40
  907ca2:	2b3c40        	addi	a11, a3, 64
  907ca5:	d7a0      	mov.n	a7, a10
  907ca7:	5bff9a        	call8	907b10 <__adf_os_mem_copy>
  907caa:	8a5b      	l32i.n	a10, a5, 44
						     sizeof(struct rx_frame_header));
		rxstats = (struct ath_rx_status *)(&rxhdr->rx_stats[0]);
		adf_os_mem_copy(rxstats, &(bf->bf_rx_status),
				sizeof(struct ath_rx_status));

		rxstats->rs_tstamp = ath_extend_tsf(sc, (u_int32_t)rxstats->rs_tstamp);
  907cac:	8671      	l32i.n	a6, a7, 4
	struct ath_hal *ah = sc->sc_ah;
	u_int64_t tsf;
	u_int32_t tsf_low;
	a_int64_t tsf_delta;  /* signed int64 */

	tsf = ah->ah_getTsf64(ah);
  907cae:	28a21e        	l32i	a8, a10, 120
  907cb1:	0b8000        	callx8	a8
	tsf_low = tsf & 0xffffffffUL;

	tsf_delta = (a_int32_t)((rstamp - tsf_low) & 0xffffffffUL);
  907cb4:	0b680c        	sub	a8, a6, a11

	return (tsf + (u_int64_t)tsf_delta);
  907cb7:	ab8b      	add.n	a11, a8, a11
  907cb9:	08fc13        	srai	a12, a8, 31
  907cbc:	c061      	movi.n	a6, 1
  907cbe:	8d11      	l32i.n	a13, a1, 4
  907cc0:	78b301        	bltu	a11, a8, 907cc5 <ath_tgt_rx_tasklet+0x65>
  907cc3:	d640      	mov.n	a6, a4
  907cc5:	aaca      	add.n	a10, a12, a10
  907cc7:	aa66      	add.n	a6, a6, a10
						     sizeof(struct rx_frame_header));
		rxstats = (struct ath_rx_status *)(&rxhdr->rx_stats[0]);
		adf_os_mem_copy(rxstats, &(bf->bf_rx_status),
				sizeof(struct ath_rx_status));

		rxstats->rs_tstamp = ath_extend_tsf(sc, (u_int32_t)rxstats->rs_tstamp);
  907cc9:	9670      	s32i.n	a6, a7, 0

		HTC_SendMsg(sc->tgt_htc_handle, RX_ENDPOINT_ID, skb);
  907ccb:	1668bf        	l32r	a6, 8e1fc8 <athos_indirection_table_install+0xa54>
  907cce:	8a22      	l32i.n	a10, a2, 8
  907cd0:	266284        	l32i	a6, a6, 0x210
						     sizeof(struct rx_frame_header));
		rxstats = (struct ath_rx_status *)(&rxhdr->rx_stats[0]);
		adf_os_mem_copy(rxstats, &(bf->bf_rx_status),
				sizeof(struct ath_rx_status));

		rxstats->rs_tstamp = ath_extend_tsf(sc, (u_int32_t)rxstats->rs_tstamp);
  907cd3:	9b71      	s32i.n	a11, a7, 4

		HTC_SendMsg(sc->tgt_htc_handle, RX_ENDPOINT_ID, skb);
  907cd5:	dcd0      	mov.n	a12, a13
  907cd7:	c0b3      	movi.n	a11, 3
  907cd9:	0b6000        	callx8	a6
		sc->sc_rx_stats.ast_rx_send++;
  907cdc:	26227d        	l32i	a6, a2, 0x1f4

		bf->bf_status &= ~ATH_BUFSTATUS_DONE;
  907cdf:	c77e      	movi.n	a7, -2
				sizeof(struct ath_rx_status));

		rxstats->rs_tstamp = ath_extend_tsf(sc, (u_int32_t)rxstats->rs_tstamp);

		HTC_SendMsg(sc->tgt_htc_handle, RX_ENDPOINT_ID, skb);
		sc->sc_rx_stats.ast_rx_send++;
  907ce1:	b166      	addi.n	a6, a6, 1
  907ce3:	26267d        	s32i	a6, a2, 0x1f4

		bf->bf_status &= ~ATH_BUFSTATUS_DONE;
  907ce6:	863f      	l32i.n	a6, a3, 60
		asf_tailq_insert_tail(&sc->sc_rxbuf, bf, bf_list);
  907ce8:	9439      	s32i.n	a4, a3, 36
		rxstats->rs_tstamp = ath_extend_tsf(sc, (u_int32_t)rxstats->rs_tstamp);

		HTC_SendMsg(sc->tgt_htc_handle, RX_ENDPOINT_ID, skb);
		sc->sc_rx_stats.ast_rx_send++;

		bf->bf_status &= ~ATH_BUFSTATUS_DONE;
  907cea:	076601        	and	a6, a6, a7
  907ced:	963f      	s32i.n	a6, a3, 60
		asf_tailq_insert_tail(&sc->sc_rxbuf, bf, bf_list);
  907cef:	2622d6        	l32i	a6, a2, 0x358
  907cf2:	963a      	s32i.n	a6, a3, 40
  907cf4:	9360      	s32i.n	a3, a6, 0
  907cf6:	233c24        	addi	a3, a3, 36
  907cf9:	2326d6        	s32i	a3, a2, 0x358
  907cfc:	63ff6d        	j	907c6d <ath_tgt_rx_tasklet+0xd>
  907cff:	002322        	excw

	} while(1);

	sc->sc_imask |= HAL_INT_RX;
  907d02:	c4c0      	movi.n	a12, 64
  907d04:	b103      	addi.n	a3, a0, 1
  907d06:	bb02      	addi.n	a2, a0, 11
	ah->ah_setInterrupts(ah, sc->sc_imask);
  907d08:	8310      	l32i.n	a3, a1, 0
		bf->bf_status &= ~ATH_BUFSTATUS_DONE;
		asf_tailq_insert_tail(&sc->sc_rxbuf, bf, bf_list);

	} while(1);

	sc->sc_imask |= HAL_INT_RX;
  907d0a:	2b26c4        	s32i	a11, a2, 0x310
	ah->ah_setInterrupts(ah, sc->sc_imask);
  907d0d:	223228        	l32i	a2, a3, 160
  907d10:	da30      	mov.n	a10, a3
  907d12:	0b2000        	callx8	a2
  907d15:	d10f      	retw.n
	...

00907d18 <ath_rxdesc_init>:
				       RX_HEADER_SPACE, align);
	return skb;
}

static a_int32_t ath_rxdesc_init(struct ath_softc_tgt *sc, struct ath_rx_desc *ds)
{
  907d18:	6c1006        	entry	a1, 48
	struct ath_hal *ah = sc->sc_ah;
  907d1b:	242d05        	addmi	a4, a2, 0x500
  907d1e:	854b      	l32i.n	a5, a4, 44
	struct ath_rx_desc *ds_held;
	a_uint8_t *anbdata;
	a_uint32_t anblen;

	if (!sc->sc_rxdesc_held) {
  907d20:	2422db        	l32i	a4, a2, 0x36c
		sc->sc_rxdesc_held = ds;
  907d23:	2326db        	s32i	a3, a2, 0x36c
	struct ath_hal *ah = sc->sc_ah;
	struct ath_rx_desc *ds_held;
	a_uint8_t *anbdata;
	a_uint32_t anblen;

	if (!sc->sc_rxdesc_held) {
  907d26:	cc43      	bnez.n	a4, 907d2d <ath_rxdesc_init+0x15>
  907d28:	600180        	j	907eac <ath_rxdesc_init+0x194>
  907d2b:	000028        	mull	a0, a0, a0

	ds_held = sc->sc_rxdesc_held;
	sc->sc_rxdesc_held = ds;
	ds = ds_held;

	if (ds->ds_nbuf == ADF_NBUF_NULL) {
  907d2e:	403423        	excw
  907d31:	403508        	excw
  907d34:	8810      	l32i.n	a8, a1, 0
  907d36:	003311        	slli	a3, a3, 16
  907d39:	083802        	or	a8, a3, a8
  907d3c:	234036        	l8ui	a3, a4, 54
  907d3f:	264037        	l8ui	a6, a4, 55
  907d42:	083311        	slli	a3, a3, 8
  907d45:	083302        	or	a3, a3, a8
  907d48:	036302        	or	a3, a6, a3
  907d4b:	6530b9        	bnez	a3, 907e08 <ath_rxdesc_init+0xf0>
static adf_nbuf_t ath_alloc_skb_align(struct ath_softc_tgt *sc,
				      a_uint32_t size, a_uint32_t align)
{
	adf_nbuf_t skb;

	skb = BUF_Pool_alloc_buf_align(sc->pool_handle, POOL_ID_WLAN_RX_BUF,
  907d4e:	1368bf        	l32r	a3, 8e204c <athos_indirection_table_install+0xad8>
  907d51:	2d2196        	l16ui	a13, a2, 0x12c
  907d54:	23329d        	l32i	a3, a3, 0x274
  907d57:	8a20      	l32i.n	a10, a2, 0
  907d59:	c3c0      	movi.n	a12, 48
  907d5b:	c0b3      	movi.n	a11, 3
  907d5d:	0b3000        	callx8	a3
	ds_held = sc->sc_rxdesc_held;
	sc->sc_rxdesc_held = ds;
	ds = ds_held;

	if (ds->ds_nbuf == ADF_NBUF_NULL) {
		ds->ds_nbuf = ath_alloc_skb_align(sc, sc->sc_rxbufsize, sc->sc_cachelsz);
  907d60:	0a8357        	extui	a3, a10, 24, 8
  907d63:	234434        	s8i	a3, a4, 52
  907d66:	0a0357        	extui	a3, a10, 16, 8
  907d69:	234435        	s8i	a3, a4, 53
  907d6c:	0a8347        	extui	a3, a10, 8, 8
  907d6f:	234436        	s8i	a3, a4, 54
  907d72:	2a4437        	s8i	a10, a4, 55
		if (ds->ds_nbuf == ADF_NBUF_NULL) {
  907d75:	cda0      	bnez.n	a10, 907d89 <ath_rxdesc_init+0x71>
			sc->sc_rxdesc_held = ds;
			sc->sc_rx_stats.ast_rx_nobuf++;
  907d77:	23227c        	l32i	a3, a2, 0x1f0
	ds = ds_held;

	if (ds->ds_nbuf == ADF_NBUF_NULL) {
		ds->ds_nbuf = ath_alloc_skb_align(sc, sc->sc_rxbufsize, sc->sc_cachelsz);
		if (ds->ds_nbuf == ADF_NBUF_NULL) {
			sc->sc_rxdesc_held = ds;
  907d7a:	2426db        	s32i	a4, a2, 0x36c
			sc->sc_rx_stats.ast_rx_nobuf++;
  907d7d:	b133      	addi.n	a3, a3, 1
  907d7f:	23267c        	s32i	a3, a2, 0x1f0
			return ENOMEM;
  907d82:	c72f      	movi.n	a2, -1
  907d84:	d10f      	retw.n
  907d86:	000000        	ill
		}
		adf_nbuf_map(sc->sc_dev, ds->ds_dmap, ds->ds_nbuf, ADF_OS_DMA_FROM_DEVICE);
  907d89:	234038        	l8ui	a3, a4, 56
  907d8c:	2b4039        	l8ui	a11, a4, 57
  907d8f:	083310        	slli	a3, a3, 24
  907d92:	00bb11        	slli	a11, a11, 16
  907d95:	03bb02        	or	a11, a11, a3
  907d98:	23403a        	l8ui	a3, a4, 58
adf_nbuf_map(adf_os_device_t        osdev, 
             adf_os_dma_map_t       bmap, 
             adf_nbuf_t             buf, 
             adf_os_dma_dir_t       dir)
{
    return __adf_nbuf_map(osdev, bmap, buf, dir);
  907d9b:	dca0      	mov.n	a12, a10
  907d9d:	083311        	slli	a3, a3, 8
  907da0:	0b3302        	or	a3, a3, a11
  907da3:	2b403b        	l8ui	a11, a4, 59
  907da6:	2a2246        	l32i	a10, a2, 0x118
  907da9:	03bb02        	or	a11, a11, a3
  907dac:	c0d1      	movi.n	a13, 1
  907dae:	5bfb30        	call8	906a70 <__adf_nbuf_map>
		adf_nbuf_dmamap_info(ds->ds_dmap, &ds->ds_dmap_info);
  907db1:	2a4039        	l8ui	a10, a4, 57
  907db4:	234038        	l8ui	a3, a4, 56
  907db7:	00aa11        	slli	a10, a10, 16
  907dba:	083310        	slli	a3, a3, 24
  907dbd:	03aa02        	or	a10, a10, a3
  907dc0:	23403a        	l8ui	a3, a4, 58
 * @param[out] sg   map info
 */
static inline void
adf_nbuf_dmamap_info(adf_os_dma_map_t bmap, adf_os_dmamap_info_t *sg)
{
    __adf_nbuf_dmamap_info(bmap, sg);
  907dc3:	2b4c3c        	addi	a11, a4, 60
  907dc6:	083311        	slli	a3, a3, 8
  907dc9:	0a3302        	or	a3, a3, a10
  907dcc:	2a403b        	l8ui	a10, a4, 59
  907dcf:	03aa02        	or	a10, a10, a3
  907dd2:	5bfb2f        	call8	906a90 <__adf_nbuf_dmamap_info>
		ds->ds_data = ds->ds_dmap_info.dma_segs[0].paddr;
  907dd5:	234040        	l8ui	a3, a4, 64
  907dd8:	083810        	slli	a8, a3, 24
  907ddb:	234041        	l8ui	a3, a4, 65
  907dde:	003311        	slli	a3, a3, 16
  907de1:	083302        	or	a3, a3, a8
  907de4:	284042        	l8ui	a8, a4, 66
  907de7:	088811        	slli	a8, a8, 8
  907dea:	038302        	or	a3, a8, a3
  907ded:	284043        	l8ui	a8, a4, 67
  907df0:	038802        	or	a8, a8, a3
  907df3:	088357        	extui	a3, a8, 24, 8
  907df6:	234404        	s8i	a3, a4, 4
  907df9:	080357        	extui	a3, a8, 16, 8
  907dfc:	234405        	s8i	a3, a4, 5
  907dff:	088347        	extui	a3, a8, 8, 8
  907e02:	234406        	s8i	a3, a4, 6
  907e05:	284407        	s8i	a8, a4, 7
	}

	ds->ds_link = 0;
	adf_nbuf_peek_header(ds->ds_nbuf, &anbdata, &anblen);
  907e08:	284034        	l8ui	a8, a4, 52
  907e0b:	2a4035        	l8ui	a10, a4, 53
  907e0e:	088810        	slli	a8, a8, 24
  907e11:	00aa11        	slli	a10, a10, 16
  907e14:	08aa02        	or	a10, a10, a8
  907e17:	284036        	l8ui	a8, a4, 54
		adf_nbuf_map(sc->sc_dev, ds->ds_dmap, ds->ds_nbuf, ADF_OS_DMA_FROM_DEVICE);
		adf_nbuf_dmamap_info(ds->ds_dmap, &ds->ds_dmap_info);
		ds->ds_data = ds->ds_dmap_info.dma_segs[0].paddr;
	}

	ds->ds_link = 0;
  907e1a:	c030      	movi.n	a3, 0
	adf_nbuf_peek_header(ds->ds_nbuf, &anbdata, &anblen);
  907e1c:	088811        	slli	a8, a8, 8
  907e1f:	0a8802        	or	a8, a8, a10
  907e22:	2a4037        	l8ui	a10, a4, 55
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  907e25:	dc10      	mov.n	a12, a1
  907e27:	2b1c04        	addi	a11, a1, 4
  907e2a:	08aa02        	or	a10, a10, a8
		adf_nbuf_map(sc->sc_dev, ds->ds_dmap, ds->ds_nbuf, ADF_OS_DMA_FROM_DEVICE);
		adf_nbuf_dmamap_info(ds->ds_dmap, &ds->ds_dmap_info);
		ds->ds_data = ds->ds_dmap_info.dma_segs[0].paddr;
	}

	ds->ds_link = 0;
  907e2d:	234400        	s8i	a3, a4, 0
  907e30:	234401        	s8i	a3, a4, 1
  907e33:	234402        	s8i	a3, a4, 2
  907e36:	234403        	s8i	a3, a4, 3
  907e39:	5bfb93        	call8	906c88 <__adf_nbuf_peek_header>
	adf_nbuf_peek_header(ds->ds_nbuf, &anbdata, &anblen);

	ah->ah_setupRxDesc(ds, adf_nbuf_tailroom(ds->ds_nbuf), 0);
  907e3c:	284034        	l8ui	a8, a4, 52
  907e3f:	2a4035        	l8ui	a10, a4, 53
  907e42:	088810        	slli	a8, a8, 24
  907e45:	00aa11        	slli	a10, a10, 16
  907e48:	08aa02        	or	a10, a10, a8
  907e4b:	284036        	l8ui	a8, a4, 54
  907e4e:	265220        	l32i	a6, a5, 128
  907e51:	088811        	slli	a8, a8, 8
  907e54:	0a8802        	or	a8, a8, a10
  907e57:	2a4037        	l8ui	a10, a4, 55
 * @return amount of tail room 
 */
static inline a_uint32_t
adf_nbuf_tailroom(adf_nbuf_t buf)
{
    return (__adf_nbuf_tailroom(buf));
  907e5a:	08aa02        	or	a10, a10, a8
  907e5d:	5bfb7b        	call8	906c4c <__adf_nbuf_tailroom>
  907e60:	dba0      	mov.n	a11, a10
  907e62:	dc30      	mov.n	a12, a3
  907e64:	da40      	mov.n	a10, a4
  907e66:	0b6000        	callx8	a6
  907e69:	2b4048        	l8ui	a11, a4, 72
  907e6c:	294049        	l8ui	a9, a4, 73
  907e6f:	28404a        	l8ui	a8, a4, 74

	if (sc->sc_rxlink == NULL) {
  907e72:	2322ef        	l32i	a3, a2, 0x3bc
		ah->ah_setRxDP(ah, ds->ds_daddr);
  907e75:	08bb10        	slli	a11, a11, 24
  907e78:	009911        	slli	a9, a9, 16
  907e7b:	2a404b        	l8ui	a10, a4, 75
  907e7e:	0b9902        	or	a9, a9, a11
  907e81:	088811        	slli	a8, a8, 8
	ds->ds_link = 0;
	adf_nbuf_peek_header(ds->ds_nbuf, &anbdata, &anblen);

	ah->ah_setupRxDesc(ds, adf_nbuf_tailroom(ds->ds_nbuf), 0);

	if (sc->sc_rxlink == NULL) {
  907e84:	cd31      	bnez.n	a3, 907e99 <ath_rxdesc_init+0x181>
		ah->ah_setRxDP(ah, ds->ds_daddr);
  907e86:	098b02        	or	a11, a8, a9
  907e89:	23521f        	l32i	a3, a5, 124
  907e8c:	0bab02        	or	a11, a10, a11
  907e8f:	da50      	mov.n	a10, a5
  907e91:	0b3000        	callx8	a3
  907e94:	600009        	j	907ea1 <ath_rxdesc_init+0x189>
  907e97:	000009        	addx2	a0, a0, a0
	}
	else {
		*sc->sc_rxlink = ds->ds_daddr;
  907e9a:	8802      	l32i.n	a8, a0, 8
  907e9c:	08a802        	or	a8, a10, a8
  907e9f:	9830      	s32i.n	a8, a3, 0
	}
	sc->sc_rxlink = &ds->ds_link;
  907ea1:	2426ef        	s32i	a4, a2, 0x3bc
	ah->ah_enableReceive(ah);
  907ea4:	225225        	l32i	a2, a5, 148
  907ea7:	da50      	mov.n	a10, a5
  907ea9:	0b2000        	callx8	a2

	return 0;
  907eac:	c020      	movi.n	a2, 0
}
  907eae:	d10f      	retw.n

00907eb0 <ath_pll_reset_ones$isra$12>:
	}

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &val[0], datalen);
}

static void ath_pll_reset_ones(struct ath_hal *ah)
  907eb0:	6c1004        	entry	a1, 32
{
	static uint8_t reset_pll = 0;

	if(reset_pll == 0) {
  907eb3:	1a69a3        	l32r	a10, 8e2540 <athos_indirection_table_install+0xfcc>
  907eb6:	28a000        	l8ui	a8, a10, 0
  907eb9:	ce87      	bnez.n	a8, 907ee4 <ath_pll_reset_ones$isra$12+0x34>
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  907ebb:	1869a4        	l32r	a8, 8e254c <athos_indirection_table_install+0xfd8>
			 ioread32_mac(0x786c) & (~0x6000000));

		iowrite32(MAGPIE_REG_RST_PWDN_CTRL_ADDR, 0x20);

#elif defined(PROJECT_MAGPIE) && !defined (FPGA)
		iowrite32_mac(0x7890,
  907ebe:	1b69a5        	l32r	a11, 8e2554 <athos_indirection_table_install+0xfe0>
  907ec1:	0c0200        	memw
  907ec4:	8980      	l32i.n	a9, a8, 0
  907ec6:	0b9902        	or	a9, a9, a11
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  907ec9:	0c0200        	memw
  907ecc:	9980      	s32i.n	a9, a8, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  907ece:	0c0200        	memw
  907ed1:	8980      	l32i.n	a9, a8, 0
			 ioread32_mac(0x7890) | 0x1800000);
		iowrite32_mac(0x7890,
  907ed3:	1b69a6        	l32r	a11, 8e256c <athos_indirection_table_install+0xff8>
  907ed6:	0b9901        	and	a9, a9, a11
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  907ed9:	0c0200        	memw
  907edc:	9980      	s32i.n	a9, a8, 0
			 ioread32_mac(0x7890) & (~0x1800000));
#endif
		reset_pll = 1;
  907ede:	280a01        	movi	a8, 1
  907ee1:	28a400        	s8i	a8, a10, 0
  907ee4:	d10f      	retw.n
	...

00907ee8 <tgt_ServiceConnect>:
				  HTC_ENDPOINT_ID eid,
				  A_UINT8 *pDataIn,
				  a_int32_t LengthIn,
				  A_UINT8 *pDataOut,
				  a_int32_t *pLengthOut)
{
  907ee8:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)pService->ServiceCtx;

	switch(pService->ServiceID) {
  907eeb:	292108        	l16ui	a9, a2, 16
				  A_UINT8 *pDataIn,
				  a_int32_t LengthIn,
				  A_UINT8 *pDataOut,
				  a_int32_t *pLengthOut)
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)pService->ServiceCtx;
  907eee:	8826      	l32i.n	a8, a2, 24

	switch(pService->ServiceID) {
  907ef0:	299dff        	addmi	a9, a9, 0xffffff00
  907ef3:	09094f        	extui	a9, a9, 0, 16
  907ef6:	c028      	movi.n	a2, 8
  907ef8:	792345        	bltu	a2, a9, 907f41 <tgt_ServiceConnect+0x59>
  907efb:	1a69a7        	l32r	a10, 8e2598 <athos_indirection_table_install+0x1024>
  907efe:	0e9911        	slli	a9, a9, 2
  907f01:	a9a9      	add.n	a9, a10, a9
  907f03:	8290      	l32i.n	a2, a9, 0
  907f05:	0a2000        	jx	a2
  907f08:	000000        	ill
	case WMI_CONTROL_SVC:
		sc->wmi_command_ep= eid;
  907f0b:	23863c        	s32i	a3, a8, 240
		break;
  907f0e:	600046        	j	907f58 <tgt_ServiceConnect+0x70>
	case WMI_BEACON_SVC:
		sc->beacon_ep= eid;
  907f11:	23863d        	s32i	a3, a8, 244
		break;
  907f14:	600040        	j	907f58 <tgt_ServiceConnect+0x70>
	case WMI_CAB_SVC:
		sc->cab_ep= eid;
  907f17:	23863e        	s32i	a3, a8, 248
		break;
  907f1a:	60003a        	j	907f58 <tgt_ServiceConnect+0x70>
	case WMI_UAPSD_SVC:
		sc->uapsd_ep= eid;
  907f1d:	23863f        	s32i	a3, a8, 252
		break;
  907f20:	600034        	j	907f58 <tgt_ServiceConnect+0x70>
	case WMI_MGMT_SVC:
		sc->mgmt_ep= eid;
  907f23:	238640        	s32i	a3, a8, 0x100
		break;
  907f26:	60002e        	j	907f58 <tgt_ServiceConnect+0x70>
	case WMI_DATA_VO_SVC:
		sc->data_VO_ep = eid;
  907f29:	238641        	s32i	a3, a8, 0x104
		break;
  907f2c:	600028        	j	907f58 <tgt_ServiceConnect+0x70>
	case WMI_DATA_VI_SVC:
		sc->data_VI_ep = eid;
  907f2f:	238642        	s32i	a3, a8, 0x108
		break;
  907f32:	600022        	j	907f58 <tgt_ServiceConnect+0x70>
	case WMI_DATA_BE_SVC:
		sc->data_BE_ep = eid;
  907f35:	238643        	s32i	a3, a8, 0x10c
		break;
  907f38:	60001c        	j	907f58 <tgt_ServiceConnect+0x70>
	case WMI_DATA_BK_SVC:
		sc->data_BK_ep = eid;
  907f3b:	238644        	s32i	a3, a8, 0x110
		break;
  907f3e:	600016        	j	907f58 <tgt_ServiceConnect+0x70>
	default:
		adf_os_assert(0);
  907f41:	1268bf        	l32r	a2, 8e2240 <athos_indirection_table_install+0xccc>
  907f44:	1b69a8        	l32r	a11, 8e25e4 <athos_indirection_table_install+0x1070>
  907f47:	222212        	l32i	a2, a2, 72
  907f4a:	1a69a0        	l32r	a10, 8e25cc <athos_indirection_table_install+0x1058>
  907f4d:	0b2000        	callx8	a2
  907f50:	126923        	l32r	a2, 8e23dc <athos_indirection_table_install+0xe68>
  907f53:	0c0200        	memw
  907f56:	8220      	l32i.n	a2, a2, 0
	}

	return HTC_SERVICE_SUCCESS;
}
  907f58:	c020      	movi.n	a2, 0
  907f5a:	d10f      	retw.n

00907f5c <ath_reg_read_filter>:

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static a_int32_t ath_reg_read_filter(struct ath_hal *ah, a_int32_t addr)
{
  907f5c:	6c1004        	entry	a1, 32
	if ((addr & 0xffffe000) == 0x2000) {
  907f5f:	1869a9        	l32r	a8, 8e2604 <athos_indirection_table_install+0x1090>
  907f62:	1969aa        	l32r	a9, 8e260c <athos_indirection_table_install+0x1098>
  907f65:	083801        	and	a8, a3, a8
  907f68:	798935        	bne	a8, a9, 907fa1 <ath_reg_read_filter+0x45>
		/* SEEPROM registers */
		ioread32_mac(addr);
  907f6b:	1869ab        	l32r	a8, 8e2618 <athos_indirection_table_install+0x10a4>
		if (!ath_hal_wait(ah, 0x407c, 0x00030000, 0))
  907f6e:	1c69ac        	l32r	a12, 8e2620 <athos_indirection_table_install+0x10ac>

static a_int32_t ath_reg_read_filter(struct ath_hal *ah, a_int32_t addr)
{
	if ((addr & 0xffffe000) == 0x2000) {
		/* SEEPROM registers */
		ioread32_mac(addr);
  907f71:	a838      	add.n	a8, a3, a8
		if (!ath_hal_wait(ah, 0x407c, 0x00030000, 0))
  907f73:	1b69ad        	l32r	a11, 8e2628 <athos_indirection_table_install+0x10b4>
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  907f76:	0c0200        	memw
  907f79:	8880      	l32i.n	a8, a8, 0
  907f7b:	2d0a00        	movi	a13, 0
  907f7e:	022a02        	or	a10, a2, a2
  907f81:	580b85        	call8	90ad98 <ath_hal_wait>
  907f84:	ccac      	bnez.n	a10, 907f94 <ath_reg_read_filter+0x38>
			adf_os_print("SEEPROM Read fail: 0x%08x\n", addr);
  907f86:	1268bf        	l32r	a2, 8e2284 <athos_indirection_table_install+0xd10>
  907f89:	1a69ae        	l32r	a10, 8e2644 <athos_indirection_table_install+0x10d0>
  907f8c:	222212        	l32i	a2, a2, 72
  907f8f:	db30      	mov.n	a11, a3
  907f91:	0b2000        	callx8	a2
  907f94:	1269af        	l32r	a2, 8e2650 <athos_indirection_table_install+0x10dc>
  907f97:	0c0200        	memw
  907f9a:	8220      	l32i.n	a2, a2, 0

		return ioread32_mac(0x407c) & 0x0000ffff;
  907f9c:	02024f        	extui	a2, a2, 0, 16
  907f9f:	d10f      	retw.n
	} else if (addr > 0xffff)
  907fa1:	1269b0        	l32r	a2, 8e2664 <athos_indirection_table_install+0x10f0>
  907fa4:	732a04        	bge	a2, a3, 907fac <ath_reg_read_filter+0x50>
  907fa7:	600006        	j	907fb1 <ath_reg_read_filter+0x55>
  907faa:	000012        	srai	a0, a0, 0
		/* SoC registers */
		return ioread32(addr);
	else
		/* MAC registers */
		return ioread32_mac(addr);
  907fad:	69aba2        	bnei	a10, 16, 907f53 <tgt_ServiceConnect+0x6b>
  907fb0:	330c02        	excw
  907fb3:	008230        	excw
}
  907fb6:	d10f      	retw.n

00907fb8 <tgt_HTCSendCompleteHandler>:
		asf_tailq_insert_tail(&sc->sc_rxdesc, ds_tmp, ds_list);
	}
}

static void tgt_HTCSendCompleteHandler(HTC_ENDPOINT_ID Endpt, adf_nbuf_t buf, void *ServiceCtx)
{
  907fb8:	6c1006        	entry	a1, 48
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)ServiceCtx;

	if (Endpt == RX_ENDPOINT_ID) {
  907fbb:	682302        	beqi	a2, 3, 907fc1 <tgt_HTCSendCompleteHandler+0x9>
  907fbe:	600100        	j	9080c2 <tgt_HTCSendCompleteHandler+0x10a>
		sc->sc_rx_stats.ast_rx_done++;
  907fc1:	22427e        	l32i	a2, a4, 0x1f8
}

static inline void
adf_nbuf_split_to_frag(adf_nbuf_t buf, adf_nbuf_queue_t *qhead)
{
    return __adf_nbuf_split_to_frag(buf, qhead);
  907fc4:	da30      	mov.n	a10, a3
  907fc6:	b122      	addi.n	a2, a2, 1
  907fc8:	22467e        	s32i	a2, a4, 0x1f8
  907fcb:	db10      	mov.n	a11, a1
  907fcd:	5bfae6        	call8	906b68 <__adf_nbuf_split_to_frag>
	struct ath_rx_desc *ds;
	adf_nbuf_t buf_tmp;
	adf_nbuf_queue_t nbuf_head;

	adf_nbuf_split_to_frag(buf, &nbuf_head);
	ds = asf_tailq_first(&sc->sc_rxdesc_idle);
  907fd0:	2242d7        	l32i	a2, a4, 0x35c

		if (buf_tmp == NULL) {
			break;
		}

		BUF_Pool_free_buf(sc->pool_handle, POOL_ID_WLAN_RX_BUF, buf_tmp);
  907fd3:	1368bf        	l32r	a3, 8e22d0 <athos_indirection_table_install+0xd5c>
  907fd6:	6000e5        	j	9080bf <tgt_HTCSendCompleteHandler+0x107>
 * @return The head buf in the buf queue.
 */
static inline adf_nbuf_t
adf_nbuf_queue_remove(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_remove(head);
  907fd9:	da10      	mov.n	a10, a1
  907fdb:	5bfa94        	call8	906a2c <__adf_nbuf_queue_remove>

	while (ds) {
		struct ath_rx_desc *ds_tmp;
		buf_tmp = adf_nbuf_queue_remove(&nbuf_head);

		if (buf_tmp == NULL) {
  907fde:	64a0e0        	beqz	a10, 9080c2 <tgt_HTCSendCompleteHandler+0x10a>
			break;
		}

		BUF_Pool_free_buf(sc->pool_handle, POOL_ID_WLAN_RX_BUF, buf_tmp);
  907fe1:	dca0      	mov.n	a12, a10
  907fe3:	25329e        	l32i	a5, a3, 0x278
  907fe6:	8a40      	l32i.n	a10, a4, 0
  907fe8:	c0b3      	movi.n	a11, 3
  907fea:	0b5000        	callx8	a5

		ds_tmp = ds;
		ds = asf_tailq_next(ds, ds_list);
  907fed:	28204c        	l8ui	a8, a2, 76
  907ff0:	25204d        	l8ui	a5, a2, 77
  907ff3:	088810        	slli	a8, a8, 24
  907ff6:	005511        	slli	a5, a5, 16
  907ff9:	085802        	or	a8, a5, a8
  907ffc:	25204e        	l8ui	a5, a2, 78

		ath_rxdesc_init(sc, ds_tmp);
  907fff:	022b02        	or	a11, a2, a2
		}

		BUF_Pool_free_buf(sc->pool_handle, POOL_ID_WLAN_RX_BUF, buf_tmp);

		ds_tmp = ds;
		ds = asf_tailq_next(ds, ds_list);
  908002:	085511        	slli	a5, a5, 8
  908005:	085502        	or	a5, a5, a8
  908008:	28204f        	l8ui	a8, a2, 79

		ath_rxdesc_init(sc, ds_tmp);
  90800b:	044a02        	or	a10, a4, a4
		}

		BUF_Pool_free_buf(sc->pool_handle, POOL_ID_WLAN_RX_BUF, buf_tmp);

		ds_tmp = ds;
		ds = asf_tailq_next(ds, ds_list);
  90800e:	058502        	or	a5, a8, a5

		ath_rxdesc_init(sc, ds_tmp);
  908011:	5bff41        	call8	907d18 <ath_rxdesc_init>

		asf_tailq_remove(&sc->sc_rxdesc_idle, ds_tmp, ds_list);
  908014:	28204c        	l8ui	a8, a2, 76
  908017:	2c2050        	l8ui	a12, a2, 80
  90801a:	088a10        	slli	a10, a8, 24
  90801d:	28204d        	l8ui	a8, a2, 77
  908020:	292052        	l8ui	a9, a2, 82
  908023:	008811        	slli	a8, a8, 16
  908026:	0a8802        	or	a8, a8, a10
  908029:	2a204e        	l8ui	a10, a2, 78
  90802c:	08cc10        	slli	a12, a12, 24
  90802f:	08aa11        	slli	a10, a10, 8
  908032:	08a802        	or	a8, a10, a8
  908035:	2a204f        	l8ui	a10, a2, 79
  908038:	2b2053        	l8ui	a11, a2, 83
  90803b:	08aa02        	or	a10, a10, a8
  90803e:	282051        	l8ui	a8, a2, 81
  908041:	089911        	slli	a9, a9, 8
  908044:	008811        	slli	a8, a8, 16
  908047:	0c8802        	or	a8, a8, a12
  90804a:	089802        	or	a8, a9, a8
  90804d:	08b802        	or	a8, a11, a8
  908050:	c9a8      	beqz.n	a10, 90806c <tgt_HTCSendCompleteHandler+0xb4>
  908052:	088957        	extui	a9, a8, 24, 8
  908055:	29a450        	s8i	a9, a10, 80
  908058:	080957        	extui	a9, a8, 16, 8
  90805b:	29a451        	s8i	a9, a10, 81
  90805e:	088947        	extui	a9, a8, 8, 8
  908061:	29a452        	s8i	a9, a10, 82
  908064:	28a453        	s8i	a8, a10, 83
  908067:	600004        	j	90806f <tgt_HTCSendCompleteHandler+0xb7>
  90806a:	000028        	mull	a0, a0, a0
  90806d:	46d829        	excw
  908070:	205028        	l8ui	a0, a5, 40
  908073:	205108        	l16ui	a0, a5, 16
  908076:	9910      	s32i.n	a9, a1, 0
  908078:	008811        	slli	a8, a8, 16
  90807b:	098902        	or	a9, a8, a9
  90807e:	282052        	l8ui	a8, a2, 82
  908081:	088811        	slli	a8, a8, 8
  908084:	098802        	or	a8, a8, a9
  908087:	292053        	l8ui	a9, a2, 83
  90808a:	089802        	or	a8, a9, a8
  90808d:	9a80      	s32i.n	a10, a8, 0
		asf_tailq_insert_tail(&sc->sc_rxdesc, ds_tmp, ds_list);
  90808f:	c080      	movi.n	a8, 0
  908091:	28244c        	s8i	a8, a2, 76
  908094:	28244d        	s8i	a8, a2, 77
  908097:	28244e        	s8i	a8, a2, 78
  90809a:	28244f        	s8i	a8, a2, 79
  90809d:	2842da        	l32i	a8, a4, 0x368
  9080a0:	088957        	extui	a9, a8, 24, 8
  9080a3:	292450        	s8i	a9, a2, 80
  9080a6:	080957        	extui	a9, a8, 16, 8
  9080a9:	292451        	s8i	a9, a2, 81
  9080ac:	088947        	extui	a9, a8, 8, 8
  9080af:	292452        	s8i	a9, a2, 82
  9080b2:	282453        	s8i	a8, a2, 83
  9080b5:	9280      	s32i.n	a2, a8, 0
  9080b7:	222c4c        	addi	a2, a2, 76
  9080ba:	2246da        	s32i	a2, a4, 0x368
		}

		BUF_Pool_free_buf(sc->pool_handle, POOL_ID_WLAN_RX_BUF, buf_tmp);

		ds_tmp = ds;
		ds = asf_tailq_next(ds, ds_list);
  9080bd:	d250      	mov.n	a2, a5
	adf_nbuf_queue_t nbuf_head;

	adf_nbuf_split_to_frag(buf, &nbuf_head);
	ds = asf_tailq_first(&sc->sc_rxdesc_idle);

	while (ds) {
  9080bf:	652f16        	bnez	a2, 907fd9 <tgt_HTCSendCompleteHandler+0x21>
  9080c2:	d10f      	retw.n

009080c4 <ath_desc_free>:

#undef DS2PHYS
}

static void ath_desc_free(struct ath_softc_tgt *sc)
{
  9080c4:	6c1004        	entry	a1, 32
	asf_tailq_insert_tail(&sc->sc_txbuf, sc->sc_txbuf_held, bf_list);
  9080c7:	2822dc        	l32i	a8, a2, 0x370
  9080ca:	2922f1        	l32i	a9, a2, 0x3c4
  9080cd:	c0d0      	movi.n	a13, 0
  9080cf:	9d89      	s32i.n	a13, a8, 36
  9080d1:	998a      	s32i.n	a9, a8, 40
  9080d3:	9890      	s32i.n	a8, a9, 0
  9080d5:	2822dc        	l32i	a8, a2, 0x370

	sc->sc_txbuf_held = NULL;
  9080d8:	2d26dc        	s32i	a13, a2, 0x370
#undef DS2PHYS
}

static void ath_desc_free(struct ath_softc_tgt *sc)
{
	asf_tailq_insert_tail(&sc->sc_txbuf, sc->sc_txbuf_held, bf_list);
  9080db:	288c24        	addi	a8, a8, 36
  9080de:	2826f1        	s32i	a8, a2, 0x3c4

	sc->sc_txbuf_held = NULL;

	if (sc->sc_txdma.dd_desc_len != 0)
  9080e1:	2822e7        	l32i	a8, a2, 0x39c
  9080e4:	7d8110        	beq	a8, a13, 9080f8 <ath_desc_free+0x34>
		ath_descdma_cleanup(sc, &sc->sc_txdma, (ath_bufhead *)&sc->sc_txbuf,
  9080e7:	2c3ac0        	movi	a12, 0x3c0
  9080ea:	2b3a8c        	movi	a11, 0x38c
  9080ed:	ac2c      	add.n	a12, a2, a12
  9080ef:	0b2b08        	add	a11, a2, a11
  9080f2:	022a02        	or	a10, a2, a2
  9080f5:	5bfeab        	call8	907ba4 <ath_descdma_cleanup>
				    ADF_OS_DMA_TO_DEVICE);
	if (sc->sc_rxdma.dd_desc_len != 0)
  9080f8:	2822e1        	l32i	a8, a2, 0x384
  9080fb:	c88f      	beqz.n	a8, 90810e <ath_desc_free+0x4a>
		ath_descdma_cleanup(sc, &sc->sc_rxdma, (ath_bufhead *)&sc->sc_rxbuf,
  9080fd:	2c3a54        	movi	a12, 0x354
  908100:	2b3a74        	movi	a11, 0x374
  908103:	c0d1      	movi.n	a13, 1
  908105:	ac2c      	add.n	a12, a2, a12
  908107:	ab2b      	add.n	a11, a2, a11
  908109:	da20      	mov.n	a10, a2
  90810b:	5bfea6        	call8	907ba4 <ath_descdma_cleanup>
  90810e:	d10f      	retw.n

00908110 <ath_descdma_setup$isra$22$constprop$28>:

/***********************/
/* Descriptor Handling */
/***********************/

static a_int32_t ath_descdma_setup(struct ath_softc_tgt *sc,
  908110:	6c1006        	entry	a1, 48
	struct ath_buf *bf;
	a_int32_t i, bsize, error;
	a_uint8_t *bf_addr;
	a_uint8_t *ds_addr;

	dd->dd_name = name;
  908113:	9530      	s32i.n	a5, a3, 0
	dd->dd_desc_len = descSize * nbuf * ndesc;
  908115:	851c      	l32i.n	a5, a1, 48
adf_os_dmamem_alloc(adf_os_device_t     osdev, 
                    adf_os_size_t       size, 
                    a_bool_t            coherent, 
                    adf_os_dma_map_t   *dmap)
{
    return __adf_os_dmamem_alloc(osdev, size, coherent, dmap);
  908117:	8a20      	l32i.n	a10, a2, 0
  908119:	056b28        	mull	a11, a6, a5
  90811c:	b83d      	addi.n	a13, a3, 8
  90811e:	9b34      	s32i.n	a11, a3, 16
  908120:	c0c1      	movi.n	a12, 1
  908122:	580ac8        	call8	90ac44 <__adf_os_dmamem_alloc>
 * @return the (bus) address
 */
static inline adf_os_dma_addr_t
adf_os_dmamem_map2addr(adf_os_dma_map_t dmap)
{
    return(__adf_os_dmamem_map2addr(dmap));
  908125:	8532      	l32i.n	a5, a3, 8

	dd->dd_desc = adf_os_dmamem_alloc(sc->sc_dev,
  908127:	9a31      	s32i.n	a10, a3, 4
				  dd->dd_desc_len, 1, &dd->dd_desc_dmamap);
	dd->dd_desc_paddr = adf_os_dmamem_map2addr(dd->dd_desc_dmamap);
  908129:	8551      	l32i.n	a5, a5, 4
  90812b:	9533      	s32i.n	a5, a3, 12
adf_os_dmamem_alloc(adf_os_device_t     osdev, 
                    adf_os_size_t       size, 
                    a_bool_t            coherent, 
                    adf_os_dma_map_t   *dmap)
{
    return __adf_os_dmamem_alloc(osdev, size, coherent, dmap);
  90812d:	d8a0      	mov.n	a8, a10
	if (dd->dd_desc == NULL) {
  90812f:	64a06d        	beqz	a10, 9081a0 <ath_descdma_setup$isra$22$constprop$28+0x90>
		error = -ENOMEM;
		goto fail;
	}
	ds = dd->dd_desc;

	bsize = bfSize * nbuf;
  908132:	076c28        	mull	a12, a6, a7
 * @return Buffer pointer or NULL if there's not enough memory.
 */
static inline void *
adf_os_mem_alloc(adf_os_size_t size)
{
    return __adf_os_mem_alloc(size);
  908135:	9812      	s32i.n	a8, a1, 8
  908137:	dac0      	mov.n	a10, a12
  908139:	9c10      	s32i.n	a12, a1, 0
  90813b:	5bfe70        	call8	907afc <__adf_os_mem_alloc>
  90813e:	d5a0      	mov.n	a5, a10
	bf = adf_os_mem_alloc(bsize);
	if (bf == NULL) {
  908140:	8c10      	l32i.n	a12, a1, 0
  908142:	64a05a        	beqz	a10, 9081a0 <ath_descdma_setup$isra$22$constprop$28+0x90>
 * @param[in] size  buffer size
 */
static inline void
adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
{
    __adf_os_mem_set(buf, b, size);
  908145:	c0b0      	movi.n	a11, 0
  908147:	5bfe77        	call8	907b24 <__adf_os_mem_set>
	dd->dd_bufptr = bf;

	bf_addr = (a_uint8_t *)bf;
	ds_addr = (a_uint8_t *)ds;

	asf_tailq_init(head);
  90814a:	c090      	movi.n	a9, 0
	if (bf == NULL) {
		error = -ENOMEM;
		goto fail2;
	}
	adf_os_mem_set(bf, 0, bsize);
	dd->dd_bufptr = bf;
  90814c:	9535      	s32i.n	a5, a3, 20

	bf_addr = (a_uint8_t *)bf;
	ds_addr = (a_uint8_t *)ds;

	asf_tailq_init(head);
  90814e:	9940      	s32i.n	a9, a4, 0
  908150:	9441      	s32i.n	a4, a4, 4
  908152:	8812      	l32i.n	a8, a1, 8
  908154:	600041        	j	908199 <ath_descdma_setup$isra$22$constprop$28+0x89>
  908157:	00008a        	excw
 */
static inline a_status_t
adf_nbuf_dmamap_create(adf_os_device_t osdev,
                       adf_os_dma_map_t *dmap)
{
    return (__adf_nbuf_dmamap_create(osdev, dmap));
  90815a:	20db50        	l32ai	a0, a13, 0x140
  90815d:	9812      	s32i.n	a8, a1, 8
  90815f:	9911      	s32i.n	a9, a1, 4
  908161:	5bfa3c        	call8	906a54 <__adf_nbuf_dmamap_create>
  908164:	dba0      	mov.n	a11, a10

	for (i = 0; i < nbuf; i++) {
		a_int32_t j;

		if (adf_nbuf_dmamap_create( sc->sc_dev, &bf->bf_dmamap) != A_STATUS_OK) {
  908166:	8812      	l32i.n	a8, a1, 8
  908168:	8911      	l32i.n	a9, a1, 4
  90816a:	cfa2      	bnez.n	a10, 9081a0 <ath_descdma_setup$isra$22$constprop$28+0x90>
			goto fail2;
		}

		bf->bf_desc = bf->bf_descarr = bf->bf_lastds = ds;
  90816c:	985c      	s32i.n	a8, a5, 48
  90816e:	985e      	s32i.n	a8, a5, 56
  908170:	985d      	s32i.n	a8, a5, 52
 * @param[in] head  buf queue head
 */
static inline void
adf_nbuf_queue_init(adf_nbuf_queue_t *head)
{
    __adf_nbuf_queue_init(head);
  908172:	2a5c14        	addi	a10, a5, 20
  908175:	9812      	s32i.n	a8, a1, 8
  908177:	9911      	s32i.n	a9, a1, 4
  908179:	9b10      	s32i.n	a11, a1, 0
  90817b:	5bfac9        	call8	906ca0 <__adf_nbuf_queue_init>
			ATH_BUF_SET_DESC_PHY_ADDR_WITH_IDX(bf, j, (ds_addr + (j*descSize)));

		ATH_BUF_SET_DESC_PHY_ADDR(bf, ATH_BUF_GET_DESC_PHY_ADDR_WITH_IDX(bf, 0));

		adf_nbuf_queue_init(&bf->bf_skbhead);
		asf_tailq_insert_tail(head, bf, bf_list);
  90817e:	8a41      	l32i.n	a10, a4, 4
  908180:	8b10      	l32i.n	a11, a1, 0
  908182:	9a5a      	s32i.n	a10, a5, 40
  908184:	9b59      	s32i.n	a11, a5, 36
  908186:	95a0      	s32i.n	a5, a10, 0
  908188:	2a5c24        	addi	a10, a5, 36
  90818b:	9a41      	s32i.n	a10, a4, 4
	bf_addr = (a_uint8_t *)bf;
	ds_addr = (a_uint8_t *)ds;

	asf_tailq_init(head);

	for (i = 0; i < nbuf; i++) {
  90818d:	8911      	l32i.n	a9, a1, 4
		asf_tailq_insert_tail(head, bf, bf_list);

		bf_addr += bfSize;
		ds_addr += (ndesc * descSize);
		bf = (struct ath_buf *)bf_addr;
		ds = (struct ath_desc *)ds_addr;
  90818f:	8812      	l32i.n	a8, a1, 8
  908191:	8a1c      	l32i.n	a10, a1, 48
	bf_addr = (a_uint8_t *)bf;
	ds_addr = (a_uint8_t *)ds;

	asf_tailq_init(head);

	for (i = 0; i < nbuf; i++) {
  908193:	b199      	addi.n	a9, a9, 1
		asf_tailq_insert_tail(head, bf, bf_list);

		bf_addr += bfSize;
		ds_addr += (ndesc * descSize);
		bf = (struct ath_buf *)bf_addr;
		ds = (struct ath_desc *)ds_addr;
  908195:	aa88      	add.n	a8, a8, a10
		adf_nbuf_queue_init(&bf->bf_skbhead);
		asf_tailq_insert_tail(head, bf, bf_list);

		bf_addr += bfSize;
		ds_addr += (ndesc * descSize);
		bf = (struct ath_buf *)bf_addr;
  908197:	a755      	add.n	a5, a5, a7
	bf_addr = (a_uint8_t *)bf;
	ds_addr = (a_uint8_t *)ds;

	asf_tailq_init(head);

	for (i = 0; i < nbuf; i++) {
  908199:	7692bc        	blt	a9, a6, 908159 <ath_descdma_setup$isra$22$constprop$28+0x49>
		ds_addr += (ndesc * descSize);
		bf = (struct ath_buf *)bf_addr;
		ds = (struct ath_desc *)ds_addr;
	}

	return 0;
  90819c:	c020      	movi.n	a2, 0
  90819e:	d10f      	retw.n
  9081a0:	c1c8      	movi.n	a12, 24
  9081a2:	da30      	mov.n	a10, a3
  9081a4:	c0b0      	movi.n	a11, 0
  9081a6:	5bfe5f        	call8	907b24 <__adf_os_mem_set>
fail2:
	adf_os_dmamem_free(sc->sc_dev, dd->dd_desc_len,
			   1, dd->dd_desc, dd->dd_desc_dmamap);
fail:
	adf_os_mem_set(dd, 0, sizeof(*dd));
	adf_os_assert(0);
  9081a9:	1268bf        	l32r	a2, 8e24a8 <athos_indirection_table_install+0xf34>
  9081ac:	1b69b1        	l32r	a11, 8e2870 <athos_indirection_table_install+0x12fc>
  9081af:	222212        	l32i	a2, a2, 72
  9081b2:	1a69a0        	l32r	a10, 8e2834 <athos_indirection_table_install+0x12c0>
  9081b5:	0b2000        	callx8	a2
  9081b8:	126923        	l32r	a2, 8e2644 <athos_indirection_table_install+0x10d0>
  9081bb:	0c0200        	memw
  9081be:	8220      	l32i.n	a2, a2, 0
	return error;
  9081c0:	c021      	movi.n	a2, 1

#undef DS2PHYS
}
  9081c2:	d10f      	retw.n

009081c4 <tgt_HTCRecvMessageHandler>:
}

static void tgt_HTCRecvMessageHandler(HTC_ENDPOINT_ID EndPt,
				      adf_nbuf_t hdr_buf, adf_nbuf_t buf,
				      void *ServiceCtx)
{
  9081c4:	6c1006        	entry	a1, 48
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  9081c7:	dc10      	mov.n	a12, a1
  9081c9:	b41b      	addi.n	a11, a1, 4
	a_uint32_t len;
	ath_data_hdr_t *dh;
	struct ath_node_target *an;
	struct ath_atx_tid *tid;

	if (!hdr_buf) {
  9081cb:	cc3d      	bnez.n	a3, 9081dc <tgt_HTCRecvMessageHandler+0x18>
  9081cd:	da40      	mov.n	a10, a4
  9081cf:	5bfaae        	call8	906c88 <__adf_nbuf_peek_header>
 *         or NULL if there is not sufficient data to pull.
 */
static inline a_uint8_t *
adf_nbuf_pull_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_pull_head(buf, size);
  9081d2:	c0bc      	movi.n	a11, 12
  9081d4:	da40      	mov.n	a10, a4
  9081d6:	5bf9e0        	call8	906958 <__adf_nbuf_pull_head>
  9081d9:	600005        	j	9081e2 <tgt_HTCRecvMessageHandler+0x1e>
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  9081dc:	033a02        	or	a10, a3, a3
  9081df:	5bfaaa        	call8	906c88 <__adf_nbuf_peek_header>
		adf_nbuf_pull_head(buf, sizeof(ath_data_hdr_t));
	} else {
		adf_nbuf_peek_header(hdr_buf, &data, &len);
	}

	adf_os_assert(len >= sizeof(ath_data_hdr_t));
  9081e2:	8310      	l32i.n	a3, a1, 0
  9081e4:	c06b      	movi.n	a6, 11
  9081e6:	736316        	bltu	a6, a3, 908200 <tgt_HTCRecvMessageHandler+0x3c>
  9081e9:	1368bf        	l32r	a3, 8e24e8 <athos_indirection_table_install+0xf74>
  9081ec:	1b69b2        	l32r	a11, 8e28b4 <athos_indirection_table_install+0x1340>
  9081ef:	233212        	l32i	a3, a3, 72
  9081f2:	1a69a0        	l32r	a10, 8e2874 <athos_indirection_table_install+0x1300>
  9081f5:	0b3000        	callx8	a3
  9081f8:	136923        	l32r	a3, 8e2684 <athos_indirection_table_install+0x1110>
  9081fb:	0c0200        	memw
  9081fe:	8330      	l32i.n	a3, a3, 0
	dh = (ath_data_hdr_t *)data;

	an = &sc->sc_sta[dh->ni_index];
	tid = ATH_AN_2_TID(an, dh->tidno);

	sc->sc_tx_stats.tx_tgt++;
  908200:	29525b        	l32i	a9, a5, 0x16c
	} else {
		adf_nbuf_peek_header(hdr_buf, &data, &len);
	}

	adf_os_assert(len >= sizeof(ath_data_hdr_t));
	dh = (ath_data_hdr_t *)data;
  908203:	8311      	l32i.n	a3, a1, 4

	an = &sc->sc_sta[dh->ni_index];
	tid = ATH_AN_2_TID(an, dh->tidno);

	sc->sc_tx_stats.tx_tgt++;
  908205:	b199      	addi.n	a9, a9, 1
	}

	adf_os_assert(len >= sizeof(ath_data_hdr_t));
	dh = (ath_data_hdr_t *)data;

	an = &sc->sc_sta[dh->ni_index];
  908207:	263001        	l8ui	a6, a3, 1
	tid = ATH_AN_2_TID(an, dh->tidno);
  90820a:	273003        	l8ui	a7, a3, 3

	sc->sc_tx_stats.tx_tgt++;

	bf = ath_tgt_tx_prepare(sc, buf, dh);
  90820d:	db40      	mov.n	a11, a4
	dh = (ath_data_hdr_t *)data;

	an = &sc->sc_sta[dh->ni_index];
	tid = ATH_AN_2_TID(an, dh->tidno);

	sc->sc_tx_stats.tx_tgt++;
  90820f:	29565b        	s32i	a9, a5, 0x16c

	bf = ath_tgt_tx_prepare(sc, buf, dh);
  908212:	dc30      	mov.n	a12, a3
  908214:	da50      	mov.n	a10, a5
  908216:	58164e        	call8	90db50 <ath_tgt_tx_prepare>
  908219:	dba0      	mov.n	a11, a10
	if (!bf) {
  90821b:	cda1      	bnez.n	a10, 908230 <tgt_HTCRecvMessageHandler+0x6c>
		ath_free_tx_skb(sc->tgt_htc_handle,EndPt,buf);
  90821d:	1368bf        	l32r	a3, 8e251c <athos_indirection_table_install+0xfa8>
  908220:	8a52      	l32i.n	a10, a5, 8
  908222:	233282        	l32i	a3, a3, 0x208
  908225:	dc40      	mov.n	a12, a4
  908227:	db20      	mov.n	a11, a2
  908229:	0b3000        	callx8	a3
  90822c:	d10f      	retw.n
  90822e:	000022        	excw
		return;
	}

	bf->bf_endpt = EndPt;
  908231:	a623      	add.n	a3, a2, a6
	bf->bf_cookie = dh->cookie;
  908233:	22300a        	l8ui	a2, a3, 10

	if (tid->flag & TID_AGGR_ENABLED)
  908236:	0c7811        	slli	a8, a7, 4
		ath_free_tx_skb(sc->tgt_htc_handle,EndPt,buf);
		return;
	}

	bf->bf_endpt = EndPt;
	bf->bf_cookie = dh->cookie;
  908239:	22a492        	s8i	a2, a10, 146

	if (tid->flag & TID_AGGR_ENABLED)
  90823c:	07820c        	sub	a2, a8, a7
  90823f:	0a6811        	slli	a8, a6, 6
  908242:	a688      	add.n	a8, a8, a6
  908244:	0f8811        	slli	a8, a8, 1
  908247:	a688      	add.n	a8, a8, a6
  908249:	a288      	add.n	a8, a8, a2
  90824b:	0e8811        	slli	a8, a8, 2
  90824e:	225a92        	movi	a2, 0x592
  908251:	a858      	add.n	a8, a5, a8
  908253:	a288      	add.n	a8, a8, a2
  908255:	228000        	l8ui	a2, a8, 0
		ath_tgt_handle_aggr(sc, bf);
  908258:	da50      	mov.n	a10, a5
	}

	bf->bf_endpt = EndPt;
	bf->bf_cookie = dh->cookie;

	if (tid->flag & TID_AGGR_ENABLED)
  90825a:	7e2707        	bbci	a2, 30, 908265 <tgt_HTCRecvMessageHandler+0xa1>
		ath_tgt_handle_aggr(sc, bf);
  90825d:	581840        	call8	90e360 <ath_tgt_handle_aggr>
  908260:	d10f      	retw.n
  908262:	000000        	ill
	else
		ath_tgt_handle_normal(sc, bf);
  908265:	58180f        	call8	90e2a4 <ath_tgt_handle_normal>
  908268:	d10f      	retw.n
	...

0090826c <tgt_HTCRecv_cabhandler>:
}

static void tgt_HTCRecv_cabhandler(HTC_ENDPOINT_ID EndPt, adf_nbuf_t hdr_buf,
				   adf_nbuf_t buf, void *ServiceCtx)
{
  90826c:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)ServiceCtx;
	struct ath_hal *ah = sc->sc_ah;
  90826f:	285d05        	addmi	a8, a5, 0x500
  908272:	8a8b      	l32i.n	a10, a8, 44
	a_uint64_t tsf;
	a_uint32_t tmp;

#ifdef ATH_ENABLE_CABQ
	tsf = ah->ah_getTsf64(ah);
  908274:	28a21e        	l32i	a8, a10, 120
  908277:	0b8000        	callx8	a8
	tmp = tsf - sc->sc_swba_tsf;
  90827a:	285d16        	addmi	a8, a5, 0x1600
  90827d:	888d      	l32i.n	a8, a8, 52
  90827f:	08bb0c        	sub	a11, a11, a8

	if ( tmp > ATH_CABQ_HANDLING_THRESHOLD ) {
  908282:	1869b3        	l32r	a8, 8e2950 <athos_indirection_table_install+0x13dc>
  908285:	7b8b11        	bgeu	a8, a11, 90829a <tgt_HTCRecv_cabhandler+0x2e>
		HTC_ReturnBuffers(sc->tgt_htc_handle, EndPt, buf);
  908288:	1368bf        	l32r	a3, 8e2584 <athos_indirection_table_install+0x1010>
  90828b:	8a52      	l32i.n	a10, a5, 8
  90828d:	233282        	l32i	a3, a3, 0x208
  908290:	dc40      	mov.n	a12, a4
  908292:	022b02        	or	a11, a2, a2
  908295:	0b3000        	callx8	a3
  908298:	d10f      	retw.n
		return;
	}

	tgt_HTCRecvMessageHandler(EndPt, hdr_buf, buf, ServiceCtx);
  90829a:	dd50      	mov.n	a13, a5
  90829c:	dc40      	mov.n	a12, a4
  90829e:	db30      	mov.n	a11, a3
  9082a0:	da20      	mov.n	a10, a2
  9082a2:	5bffc8        	call8	9081c4 <tgt_HTCRecvMessageHandler>
  9082a5:	d10f      	retw.n
	...

009082a8 <wmi_event>:

}

void wmi_event(wmi_handle_t handle, WMI_EVENT_ID evt_id,
	       void *buffer, a_int32_t Length)
{
  9082a8:	6c1004        	entry	a1, 32
	adf_nbuf_t netbuf = ADF_NBUF_NULL;
	a_uint8_t *pData;

	netbuf = WMI_AllocEvent(handle, WMI_EVT_CLASS_CMD_EVENT,
  9082ab:	1668bf        	l32r	a6, 8e25a8 <athos_indirection_table_install+0x1034>
  9082ae:	b45c      	addi.n	a12, a5, 4
  9082b0:	27628d        	l32i	a7, a6, 0x234
  9082b3:	c0b0      	movi.n	a11, 0
  9082b5:	da20      	mov.n	a10, a2
  9082b7:	0b7000        	callx8	a7
  9082ba:	d7a0      	mov.n	a7, a10
				sizeof(WMI_CMD_HDR) + Length);

	if (netbuf == ADF_NBUF_NULL) {
  9082bc:	65a00a        	bnez	a10, 9082ca <wmi_event+0x22>
		adf_os_print("Buf null\n");
  9082bf:	226212        	l32i	a2, a6, 72
  9082c2:	1a69b4        	l32r	a10, 8e2994 <athos_indirection_table_install+0x1420>
  9082c5:	0b2000        	callx8	a2
  9082c8:	d10f      	retw.n
		return;
	}

	if (buffer != NULL && Length != 0 && Length < WMI_SVC_MAX_BUFFERED_EVENT_SIZE) {
  9082ca:	c090      	movi.n	a9, 0
  9082cc:	c081      	movi.n	a8, 1
  9082ce:	da90      	mov.n	a10, a9
  9082d0:	2b0a63        	movi	a11, 99
  9082d3:	058a39        	movnez	a10, a8, a5
  9082d6:	75ba02        	bge	a11, a5, 9082dc <wmi_event+0x34>
  9082d9:	099802        	or	a8, a9, a9
  9082dc:	78a010        	bnone	a10, a8, 9082f0 <wmi_event+0x48>
  9082df:	c84d      	beqz.n	a4, 9082f0 <wmi_event+0x48>
 *         put, or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_put_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_put_tail(buf, size);
  9082e1:	db50      	mov.n	a11, a5
  9082e3:	077a02        	or	a10, a7, a7
  9082e6:	5bfa3d        	call8	906bdc <__adf_nbuf_put_tail>
 * @param[in] size    buffer size
 */
static inline void
adf_os_mem_copy(void *dst, const void *src, adf_os_size_t size)
{
    __adf_os_mem_copy(dst, src, size);
  9082e9:	dc50      	mov.n	a12, a5
  9082eb:	db40      	mov.n	a11, a4
  9082ed:	5bfe08        	call8	907b10 <__adf_os_mem_copy>
		pData = adf_nbuf_put_tail(netbuf, Length);
		adf_os_mem_copy(pData, buffer, Length);
	}

	WMI_SendEvent(handle, netbuf, evt_id, 0, Length);
  9082f0:	24628e        	l32i	a4, a6, 0x238
  9082f3:	de50      	mov.n	a14, a5
  9082f5:	c0d0      	movi.n	a13, 0
  9082f7:	030c4f        	extui	a12, a3, 0, 16
  9082fa:	db70      	mov.n	a11, a7
  9082fc:	da20      	mov.n	a10, a2
  9082fe:	0b4000        	callx8	a4
  908301:	d10f      	retw.n
	...

00908304 <ath_intr>:
/**********************/
/* Interrupt Handling */
/**********************/

adf_os_irq_resp_t ath_intr(adf_drv_handle_t hdl)
{
  908304:	6c100a        	entry	a1, 80
  908307:	022402        	or	a4, a2, a2
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)hdl;
	struct ath_hal *ah = sc->sc_ah;
	HAL_INT status;

	if (sc->sc_invalid)
  90830a:	222249        	l32i	a2, a2, 0x124
  90830d:	672004        	bgez	a2, 908315 <ath_intr+0x11>
		return ADF_OS_IRQ_NONE;
  908310:	c020      	movi.n	a2, 0
  908312:	d10f      	retw.n
  908314:	00234d        	extui	a3, a0, 2, 14
/**********************/

adf_os_irq_resp_t ath_intr(adf_drv_handle_t hdl)
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)hdl;
	struct ath_hal *ah = sc->sc_ah;
  908317:	05823b        	movgez	a2, a8, a5
  90831a:	9214      	s32i.n	a2, a1, 16
	HAL_INT status;

	if (sc->sc_invalid)
		return ADF_OS_IRQ_NONE;

	if (!ah->ah_isInterruptPending(ah))
  90831c:	2a1204        	l32i	a10, a1, 16
  90831f:	222226        	l32i	a2, a2, 152
  908322:	0b2000        	callx8	a2
  908325:	64afe7        	beqz	a10, 908310 <ath_intr+0xc>
		return ADF_OS_IRQ_NONE;

	ah->ah_getPendingInterrupts(ah, &status);
  908328:	8514      	l32i.n	a5, a1, 16
  90832a:	bc1b      	addi.n	a11, a1, 12
  90832c:	225227        	l32i	a2, a5, 156
  90832f:	da50      	mov.n	a10, a5
  908331:	0b2000        	callx8	a2

	status &= sc->sc_imask;
  908334:	8513      	l32i.n	a5, a1, 12
  908336:	2242c4        	l32i	a2, a4, 0x310
  908339:	052201        	and	a2, a2, a5
  90833c:	9213      	s32i.n	a2, a1, 12

	if (status & HAL_INT_FATAL) {
  90833e:	712617        	bbci	a2, 1, 908359 <ath_intr+0x55>
		ah->ah_setInterrupts(ah, 0);
  908341:	8614      	l32i.n	a6, a1, 16
  908343:	c0b0      	movi.n	a11, 0
  908345:	226228        	l32i	a2, a6, 160
  908348:	da60      	mov.n	a10, a6
  90834a:	0b2000        	callx8	a2
 * @param[in] bh    bottom instance
 */
static inline void 
adf_os_sched_bh(adf_os_handle_t hdl, adf_os_bh_t *bh)
{
    __adf_os_sched_bh(hdl, bh);
  90834d:	2a3a44        	movi	a10, 0x344
  908350:	aa4a      	add.n	a10, a4, a10
  908352:	5bfe3f        	call8	907c50 <__adf_os_sched_bh$isra$6>

		if (status & HAL_INT_CST)
			sc->sc_int_stats.ast_cst++;
	}

	return ADF_OS_IRQ_HANDLED;
  908355:	c021      	movi.n	a2, 1
  908357:	d10f      	retw.n

	if (status & HAL_INT_FATAL) {
		ah->ah_setInterrupts(ah, 0);
		ATH_SCHEDULE_TQUEUE(sc->sc_dev, &sc->sc_fataltq);
	} else {
		if (status & HAL_INT_SWBA) {
  908359:	7f2647        	bbci	a2, 15, 9083a4 <ath_intr+0xa0>
			WMI_SWBA_EVENT swbaEvt;
			struct ath_txq *txq = ATH_TXQ(sc, 8);

			swbaEvt.tsf = ah->ah_getTsf64(ah);
  90835c:	8814      	l32i.n	a8, a1, 16
  90835e:	22821e        	l32i	a2, a8, 120
  908361:	da80      	mov.n	a10, a8
  908363:	0b2000        	callx8	a2
			swbaEvt.beaconPendingCount = ah->ah_numTxPending(ah, sc->sc_bhalq);
  908366:	8614      	l32i.n	a6, a1, 16
  908368:	224d01        	addmi	a2, a4, 0x100
	} else {
		if (status & HAL_INT_SWBA) {
			WMI_SWBA_EVENT swbaEvt;
			struct ath_txq *txq = ATH_TXQ(sc, 8);

			swbaEvt.tsf = ah->ah_getTsf64(ah);
  90836b:	9b11      	s32i.n	a11, a1, 4
			swbaEvt.beaconPendingCount = ah->ah_numTxPending(ah, sc->sc_bhalq);
  90836d:	856b      	l32i.n	a5, a6, 44
  90836f:	2b201c        	l8ui	a11, a2, 28
	} else {
		if (status & HAL_INT_SWBA) {
			WMI_SWBA_EVENT swbaEvt;
			struct ath_txq *txq = ATH_TXQ(sc, 8);

			swbaEvt.tsf = ah->ah_getTsf64(ah);
  908372:	9a10      	s32i.n	a10, a1, 0
			swbaEvt.beaconPendingCount = ah->ah_numTxPending(ah, sc->sc_bhalq);
  908374:	da60      	mov.n	a10, a6
  908376:	0b5000        	callx8	a5
  908379:	2a1408        	s8i	a10, a1, 8
			sc->sc_swba_tsf = ah->ah_getTsf64(ah);
  90837c:	22621e        	l32i	a2, a6, 120
  90837f:	2a1204        	l32i	a10, a1, 16
  908382:	0b2000        	callx8	a2
  908385:	224d16        	addmi	a2, a4, 0x1600
  908388:	9a2c      	s32i.n	a10, a2, 48
  90838a:	9b2d      	s32i.n	a11, a2, 52

			wmi_event(sc->tgt_wmi_handle,
  90838c:	8a43      	l32i.n	a10, a4, 12
  90838e:	1b69b5        	l32r	a11, 8e2a64 <athos_indirection_table_install+0x14f0>
  908391:	dc10      	mov.n	a12, a1
  908393:	c0d9      	movi.n	a13, 9
  908395:	5bffc4        	call8	9082a8 <wmi_event>
	ah->ah_stopTxDma(ah, txq->axq_qnum);
}

static void owltgt_txq_drain(struct ath_softc_tgt *sc, struct ath_txq *txq)
{
	owltgt_tx_processq(sc, txq, OWL_TXQ_STOPPED);
  908398:	2b4acc        	movi	a11, 0x4cc
  90839b:	c0c1      	movi.n	a12, 1
  90839d:	ab4b      	add.n	a11, a4, a11
  90839f:	da40      	mov.n	a10, a4
  9083a1:	581943        	call8	90e8b0 <owltgt_tx_processq>
				  sizeof(WMI_SWBA_EVENT));

			ath_tx_draintxq(sc, txq);
		}

		if (status & HAL_INT_RXORN)
  9083a4:	8213      	l32i.n	a2, a1, 12
  9083a6:	7a2707        	bbci	a2, 26, 9083b1 <ath_intr+0xad>
			sc->sc_int_stats.ast_rxorn++;
  9083a9:	25424d        	l32i	a5, a4, 0x134
  9083ac:	b155      	addi.n	a5, a5, 1
  9083ae:	25464d        	s32i	a5, a4, 0x134

		if (status & HAL_INT_RXEOL)
  9083b1:	7b2708        	bbci	a2, 27, 9083bd <ath_intr+0xb9>
			sc->sc_int_stats.ast_rxeol++;
  9083b4:	25424e        	l32i	a5, a4, 0x138
  9083b7:	255c01        	addi	a5, a5, 1
  9083ba:	25464e        	s32i	a5, a4, 0x138

		if (status & (HAL_INT_RX | HAL_INT_RXEOL | HAL_INT_RXORN)) {
  9083bd:	c351      	movi.n	a5, 49
  9083bf:	752802        	bany	a2, a5, 9083c5 <ath_intr+0xc1>
  9083c2:	60054e        	j	908914 <ath_intr+0x610>
			if (status & HAL_INT_RX)
  9083c5:	7f2707        	bbci	a2, 31, 9083d0 <ath_intr+0xcc>
				sc->sc_int_stats.ast_rx++;
  9083c8:	22424c        	l32i	a2, a4, 0x130
  9083cb:	b122      	addi.n	a2, a2, 1
  9083cd:	22464c        	s32i	a2, a4, 0x130
	}
}

static void ath_uapsd_processtriggers(struct ath_softc_tgt *sc)
{
	struct ath_hal *ah = sc->sc_ah;
  9083d0:	833b      	l32i.n	a3, a3, 44

#define	PA2DESC(_sc, _pa)						\
	((struct ath_desc *)((caddr_t)(_sc)->sc_rxdma.dd_desc +		\
			     ((_pa) - (_sc)->sc_rxdma.dd_desc_paddr)))

	tsf = ah->ah_getTsf64(ah);
  9083d2:	22321e        	l32i	a2, a3, 120
  9083d5:	da30      	mov.n	a10, a3
	}
}

static void ath_uapsd_processtriggers(struct ath_softc_tgt *sc)
{
	struct ath_hal *ah = sc->sc_ah;
  9083d7:	9315      	s32i.n	a3, a1, 20

#define	PA2DESC(_sc, _pa)						\
	((struct ath_desc *)((caddr_t)(_sc)->sc_rxdma.dd_desc +		\
			     ((_pa) - (_sc)->sc_rxdma.dd_desc_paddr)))

	tsf = ah->ah_getTsf64(ah);
  9083d9:	0b2000        	callx8	a2
	bf = asf_tailq_first(&sc->sc_rxbuf);
  9083dc:	2742d5        	l32i	a7, a4, 0x354

	ds = asf_tailq_first(&sc->sc_rxdesc);
  9083df:	2342d9        	l32i	a3, a4, 0x364
  9083e2:	6004f9        	j	9088df <ath_intr+0x5db>
	ds_head = ds;

	while(ds) {
		++cnt;

		if (cnt == ath_numrxbufs - 1) {
  9083e5:	1869b6        	l32r	a8, 8e2ac0 <athos_indirection_table_install+0x154c>

	ds = asf_tailq_first(&sc->sc_rxdesc);
	ds_head = ds;

	while(ds) {
		++cnt;
  9083e8:	b122      	addi.n	a2, a2, 1

		if (cnt == ath_numrxbufs - 1) {
  9083ea:	8a80      	l32i.n	a10, a8, 0
  9083ec:	b0aa      	addi.n	a10, a10, -1
  9083ee:	7a2102        	beq	a2, a10, 9083f4 <ath_intr+0xf0>
  9083f1:	600207        	j	9085fc <ath_intr+0x2f8>
			adf_os_print("VERY LONG PACKET!!!!!\n");
  9083f4:	1668bf        	l32r	a6, 8e26f0 <athos_indirection_table_install+0x117c>
  9083f7:	1a69b7        	l32r	a10, 8e2ad4 <athos_indirection_table_install+0x1560>
  9083fa:	226212        	l32i	a2, a6, 72
  9083fd:	0b2000        	callx8	a2
  908400:	6001f2        	j	9085f6 <ath_intr+0x2f2>
			ds_tail = ds;
			ds_tmp = ds_head;
			while (ds_tmp) {
				struct ath_rx_desc *ds_rmv;
				adf_nbuf_unmap(sc->sc_dev, ds_tmp->ds_dmap, ADF_OS_DMA_FROM_DEVICE);
  908403:	223038        	l8ui	a2, a3, 56
  908406:	2b3039        	l8ui	a11, a3, 57
  908409:	082210        	slli	a2, a2, 24
  90840c:	00bb11        	slli	a11, a11, 16
  90840f:	02bb02        	or	a11, a11, a2
  908412:	22303a        	l8ui	a2, a3, 58
static inline void
adf_nbuf_unmap(adf_os_device_t      osdev, 
               adf_os_dma_map_t     bmap, 
               adf_os_dma_dir_t     dir)
{
    __adf_nbuf_unmap(osdev, bmap, dir);
  908415:	2a4246        	l32i	a10, a4, 0x118
  908418:	082211        	slli	a2, a2, 8
  90841b:	0b2202        	or	a2, a2, a11
  90841e:	2b303b        	l8ui	a11, a3, 59
  908421:	c0c1      	movi.n	a12, 1
  908423:	02bb02        	or	a11, a11, a2
  908426:	5bf995        	call8	906a7c <__adf_nbuf_unmap>
				ds_rmv = ds_tmp;
				ds_tmp = asf_tailq_next(ds_tmp, ds_list);
  908429:	26304c        	l8ui	a6, a3, 76
  90842c:	22304d        	l8ui	a2, a3, 77
  90842f:	086610        	slli	a6, a6, 24
  908432:	002211        	slli	a2, a2, 16
  908435:	062602        	or	a6, a2, a6
  908438:	22304e        	l8ui	a2, a3, 78
  90843b:	082211        	slli	a2, a2, 8
  90843e:	062202        	or	a2, a2, a6
  908441:	26304f        	l8ui	a6, a3, 79
  908444:	026602        	or	a6, a6, a2
  908447:	9615      	s32i.n	a6, a1, 20

				if (ds_tmp == NULL) {
  908449:	656023        	bnez	a6, 908470 <ath_intr+0x16c>
					adf_os_print("ds_tmp is NULL\n");
  90844c:	1868bf        	l32r	a8, 8e2748 <athos_indirection_table_install+0x11d4>
  90844f:	1a69b8        	l32r	a10, 8e2b30 <athos_indirection_table_install+0x15bc>
  908452:	228212        	l32i	a2, a8, 72
  908455:	0b2000        	callx8	a2
					adf_os_assert(0);
  908458:	1668bf        	l32r	a6, 8e2754 <athos_indirection_table_install+0x11e0>
  90845b:	1b69b9        	l32r	a11, 8e2b40 <athos_indirection_table_install+0x15cc>
  90845e:	226212        	l32i	a2, a6, 72
  908461:	1a69a0        	l32r	a10, 8e2ae4 <athos_indirection_table_install+0x1570>
  908464:	0b2000        	callx8	a2
  908467:	126923        	l32r	a2, 8e28f4 <athos_indirection_table_install+0x1380>
  90846a:	0c0200        	memw
  90846d:	222200        	l32i	a2, a2, 0
				}

				BUF_Pool_free_buf(sc->pool_handle, POOL_ID_WLAN_RX_BUF, ds_rmv->ds_nbuf);
  908470:	223034        	l8ui	a2, a3, 52
  908473:	2c3035        	l8ui	a12, a3, 53
  908476:	082210        	slli	a2, a2, 24
  908479:	00cc11        	slli	a12, a12, 16
  90847c:	02cc02        	or	a12, a12, a2
  90847f:	223036        	l8ui	a2, a3, 54
  908482:	1868bf        	l32r	a8, 8e2780 <athos_indirection_table_install+0x120c>
  908485:	082211        	slli	a2, a2, 8
  908488:	0c2202        	or	a2, a2, a12
  90848b:	2c3037        	l8ui	a12, a3, 55
  90848e:	26829e        	l32i	a6, a8, 0x278
  908491:	8a40      	l32i.n	a10, a4, 0
  908493:	02cc02        	or	a12, a12, a2
  908496:	2b0a03        	movi	a11, 3
  908499:	0b6000        	callx8	a6
				ds_rmv->ds_nbuf = ADF_NBUF_NULL;
  90849c:	c020      	movi.n	a2, 0
  90849e:	223434        	s8i	a2, a3, 52
  9084a1:	223435        	s8i	a2, a3, 53
  9084a4:	223436        	s8i	a2, a3, 54
  9084a7:	223437        	s8i	a2, a3, 55

				if (ath_rxdesc_init(sc, ds_rmv) == 0) {
  9084aa:	db30      	mov.n	a11, a3
  9084ac:	da40      	mov.n	a10, a4
  9084ae:	5bfe1a        	call8	907d18 <ath_rxdesc_init>
  9084b1:	2e304c        	l8ui	a14, a3, 76
  9084b4:	2c304d        	l8ui	a12, a3, 77
  9084b7:	26304e        	l8ui	a6, a3, 78
  9084ba:	2b3050        	l8ui	a11, a3, 80
  9084bd:	273051        	l8ui	a7, a3, 81
  9084c0:	223052        	l8ui	a2, a3, 82
					asf_tailq_remove(&sc->sc_rxdesc, ds_rmv, ds_list);
  9084c3:	08ee10        	slli	a14, a14, 24
  9084c6:	00cc11        	slli	a12, a12, 16
  9084c9:	2f304f        	l8ui	a15, a3, 79
  9084cc:	0ece02        	or	a14, a12, a14
  9084cf:	086611        	slli	a6, a6, 8
  9084d2:	08bb10        	slli	a11, a11, 24
  9084d5:	007711        	slli	a7, a7, 16
  9084d8:	0e6e02        	or	a14, a6, a14
  9084db:	0b7702        	or	a7, a7, a11
  9084de:	082211        	slli	a2, a2, 8
  9084e1:	2d3053        	l8ui	a13, a3, 83
  9084e4:	0eff02        	or	a15, a15, a14
  9084e7:	072202        	or	a2, a2, a7
				}

				BUF_Pool_free_buf(sc->pool_handle, POOL_ID_WLAN_RX_BUF, ds_rmv->ds_nbuf);
				ds_rmv->ds_nbuf = ADF_NBUF_NULL;

				if (ath_rxdesc_init(sc, ds_rmv) == 0) {
  9084ea:	65a072        	bnez	a10, 908560 <ath_intr+0x25c>
					asf_tailq_remove(&sc->sc_rxdesc, ds_rmv, ds_list);
  9084ed:	02dd02        	or	a13, a13, a2
  9084f0:	c9f8      	beqz.n	a15, 90850c <ath_intr+0x208>
  9084f2:	0d8257        	extui	a2, a13, 24, 8
  9084f5:	22f450        	s8i	a2, a15, 80
  9084f8:	0d0257        	extui	a2, a13, 16, 8
  9084fb:	22f451        	s8i	a2, a15, 81
  9084fe:	0d8247        	extui	a2, a13, 8, 8
  908501:	22f452        	s8i	a2, a15, 82
  908504:	2df453        	s8i	a13, a15, 83
  908507:	600004        	j	90850f <ath_intr+0x20b>
  90850a:	00002d        	excw
  90850d:	46da26        	excw
  908510:	305022        	excw
  908513:	305108        	excw
  908516:	661000        	bltz	a1, 90851a <ath_intr+0x216>
  908519:	221106        	l16ui	a2, a1, 12
  90851c:	260222        	l32i	a6, a0, 136
  90851f:	305208        	excw
  908522:	221106        	l16ui	a2, a1, 12
  908525:	220226        	l32i	a2, a0, 152
  908528:	305302        	excw
  90852b:	62029f        	j	8e87ce <memset+0x1986>
  90852e:	20c020        	l8ui	a0, a12, 32
					asf_tailq_insert_tail(&sc->sc_rxdesc, ds_rmv, ds_list);
  908531:	22344c        	s8i	a2, a3, 76
  908534:	22344d        	s8i	a2, a3, 77
  908537:	22344e        	s8i	a2, a3, 78
  90853a:	22344f        	s8i	a2, a3, 79
  90853d:	2242da        	l32i	a2, a4, 0x368
  908540:	028657        	extui	a6, a2, 24, 8
  908543:	263450        	s8i	a6, a3, 80
  908546:	020657        	extui	a6, a2, 16, 8
  908549:	263451        	s8i	a6, a3, 81
  90854c:	028647        	extui	a6, a2, 8, 8
  90854f:	223453        	s8i	a2, a3, 83
  908552:	263452        	s8i	a6, a3, 82
  908555:	9320      	s32i.n	a3, a2, 0
  908557:	223c4c        	addi	a2, a3, 76
  90855a:	2246da        	s32i	a2, a4, 0x368
  90855d:	600070        	j	9085d1 <ath_intr+0x2cd>
				}
				else {
					asf_tailq_remove(&sc->sc_rxdesc, ds_rmv, ds_list);
  908560:	c9f9      	beqz.n	a15, 90857d <ath_intr+0x279>
  908562:	02dd02        	or	a13, a13, a2
  908565:	0d8257        	extui	a2, a13, 24, 8
  908568:	22f450        	s8i	a2, a15, 80
  90856b:	0d0257        	extui	a2, a13, 16, 8
  90856e:	22f451        	s8i	a2, a15, 81
  908571:	0d8247        	extui	a2, a13, 8, 8
  908574:	22f452        	s8i	a2, a15, 82
  908577:	2df453        	s8i	a13, a15, 83
  90857a:	600005        	j	908583 <ath_intr+0x27f>
  90857d:	02d202        	or	a2, a13, a2
  908580:	2246da        	s32i	a2, a4, 0x368
  908583:	263050        	l8ui	a6, a3, 80
  908586:	223051        	l8ui	a2, a3, 81
  908589:	086610        	slli	a6, a6, 24
  90858c:	002211        	slli	a2, a2, 16
  90858f:	062602        	or	a6, a2, a6
  908592:	223052        	l8ui	a2, a3, 82
  908595:	082211        	slli	a2, a2, 8
  908598:	062202        	or	a2, a2, a6
  90859b:	263053        	l8ui	a6, a3, 83
  90859e:	026202        	or	a2, a6, a2
  9085a1:	9f20      	s32i.n	a15, a2, 0
					asf_tailq_insert_tail(&sc->sc_rxdesc_idle, ds_rmv, ds_list);
  9085a3:	c020      	movi.n	a2, 0
  9085a5:	22344c        	s8i	a2, a3, 76
  9085a8:	22344d        	s8i	a2, a3, 77
  9085ab:	22344e        	s8i	a2, a3, 78
  9085ae:	22344f        	s8i	a2, a3, 79
  9085b1:	2242d8        	l32i	a2, a4, 0x360
  9085b4:	028657        	extui	a6, a2, 24, 8
  9085b7:	263450        	s8i	a6, a3, 80
  9085ba:	020657        	extui	a6, a2, 16, 8
  9085bd:	263451        	s8i	a6, a3, 81
  9085c0:	028647        	extui	a6, a2, 8, 8
  9085c3:	223453        	s8i	a2, a3, 83
  9085c6:	263452        	s8i	a6, a3, 82
  9085c9:	9320      	s32i.n	a3, a2, 0
  9085cb:	223c4c        	addi	a2, a3, 76
  9085ce:	2246d8        	s32i	a2, a4, 0x360
				}

				if (ds_rmv == ds_tail) {
  9085d1:	75391f        	bne	a3, a5, 9085f4 <ath_intr+0x2f0>
			if (status & HAL_INT_RX)
				sc->sc_int_stats.ast_rx++;

			ath_uapsd_processtriggers(sc);

			sc->sc_imask &= ~HAL_INT_RX;
  9085d4:	2242c4        	l32i	a2, a4, 0x310
			ah->ah_setInterrupts(ah, sc->sc_imask);
  9085d7:	8314      	l32i.n	a3, a1, 16
			if (status & HAL_INT_RX)
				sc->sc_int_stats.ast_rx++;

			ath_uapsd_processtriggers(sc);

			sc->sc_imask &= ~HAL_INT_RX;
  9085d9:	c7be      	movi.n	a11, -2
  9085db:	02bb01        	and	a11, a11, a2
			ah->ah_setInterrupts(ah, sc->sc_imask);
  9085de:	223228        	l32i	a2, a3, 160
			if (status & HAL_INT_RX)
				sc->sc_int_stats.ast_rx++;

			ath_uapsd_processtriggers(sc);

			sc->sc_imask &= ~HAL_INT_RX;
  9085e1:	2b46c4        	s32i	a11, a4, 0x310
			ah->ah_setInterrupts(ah, sc->sc_imask);
  9085e4:	da30      	mov.n	a10, a3
  9085e6:	0b2000        	callx8	a2
  9085e9:	2a3a14        	movi	a10, 0x314
  9085ec:	aa4a      	add.n	a10, a4, a10
  9085ee:	5bfd98        	call8	907c50 <__adf_os_sched_bh$isra$6>
  9085f1:	60031f        	j	908914 <ath_intr+0x610>
			ds_tmp = ds_head;
			while (ds_tmp) {
				struct ath_rx_desc *ds_rmv;
				adf_nbuf_unmap(sc->sc_dev, ds_tmp->ds_dmap, ADF_OS_DMA_FROM_DEVICE);
				ds_rmv = ds_tmp;
				ds_tmp = asf_tailq_next(ds_tmp, ds_list);
  9085f4:	8315      	l32i.n	a3, a1, 20

		if (cnt == ath_numrxbufs - 1) {
			adf_os_print("VERY LONG PACKET!!!!!\n");
			ds_tail = ds;
			ds_tmp = ds_head;
			while (ds_tmp) {
  9085f6:	653e09        	bnez	a3, 908403 <ath_intr+0xff>
  9085f9:	63ffd7        	j	9085d4 <ath_intr+0x2d0>
				}
			}
			break;
		}

		if (ds->ds_link == 0) {
  9085fc:	2d5000        	l8ui	a13, a5, 0
  9085ff:	2b5001        	l8ui	a11, a5, 1
  908602:	08dd10        	slli	a13, a13, 24
  908605:	00bb11        	slli	a11, a11, 16
  908608:	0dbb02        	or	a11, a11, a13
  90860b:	2d5002        	l8ui	a13, a5, 2
  90860e:	08dd11        	slli	a13, a13, 8
  908611:	0bdd02        	or	a13, a13, a11
  908614:	2b5003        	l8ui	a11, a5, 3
  908617:	0dbb02        	or	a11, a11, a13
  90861a:	64bfb6        	beqz	a11, 9085d4 <ath_intr+0x2d0>
			break;
		}

		if (bf->bf_status & ATH_BUFSTATUS_DONE) {
  90861d:	8a7f      	l32i.n	a10, a7, 60
  90861f:	7fa702        	bbci	a10, 31, 908625 <ath_intr+0x321>
  908622:	6002e8        	j	90890e <ath_intr+0x60a>
			continue;
		}

		retval = ah->ah_procRxDescFast(ah, ds, ds->ds_daddr,
						PA2DESC(sc, ds->ds_link), &bf->bf_rx_status);
  908625:	2a42de        	l32i	a10, a4, 0x378
  908628:	2d42e0        	l32i	a13, a4, 0x380

		if (bf->bf_status & ATH_BUFSTATUS_DONE) {
			continue;
		}

		retval = ah->ah_procRxDescFast(ah, ds, ds->ds_daddr,
  90862b:	2c5049        	l8ui	a12, a5, 73
						PA2DESC(sc, ds->ds_link), &bf->bf_rx_status);
  90862e:	0dad0c        	sub	a13, a10, a13

		if (bf->bf_status & ATH_BUFSTATUS_DONE) {
			continue;
		}

		retval = ah->ah_procRxDescFast(ah, ds, ds->ds_daddr,
  908631:	2a5048        	l8ui	a10, a5, 72
  908634:	00cc11        	slli	a12, a12, 16
  908637:	08aa10        	slli	a10, a10, 24
  90863a:	0acc02        	or	a12, a12, a10
  90863d:	2a504a        	l8ui	a10, a5, 74
  908640:	8815      	l32i.n	a8, a1, 20
  908642:	08aa11        	slli	a10, a10, 8
  908645:	0caa02        	or	a10, a10, a12
  908648:	2c504b        	l8ui	a12, a5, 75
  90864b:	2f8222        	l32i	a15, a8, 136
  90864e:	abdd      	add.n	a13, a13, a11
  908650:	0acc02        	or	a12, a12, a10
  908653:	db50      	mov.n	a11, a5
  908655:	2e7c40        	addi	a14, a7, 64
  908658:	da80      	mov.n	a10, a8
  90865a:	0bf000        	callx8	a15
						PA2DESC(sc, ds->ds_link), &bf->bf_rx_status);
		if (HAL_EINPROGRESS == retval) {
  90865d:	c0bf      	movi.n	a11, 15
  90865f:	7ba902        	bne	a10, a11, 908665 <ath_intr+0x361>
  908662:	63ff6e        	j	9085d4 <ath_intr+0x2d0>
			break;
		}

		if (adf_nbuf_len(ds->ds_nbuf) == 0) {
  908665:	2b5034        	l8ui	a11, a5, 52
  908668:	2a5035        	l8ui	a10, a5, 53
  90866b:	08bb10        	slli	a11, a11, 24
  90866e:	00aa11        	slli	a10, a10, 16
  908671:	0bab02        	or	a11, a10, a11
  908674:	2a5036        	l8ui	a10, a5, 54
  908677:	08aa11        	slli	a10, a10, 8
  90867a:	0baa02        	or	a10, a10, a11
  90867d:	2b5037        	l8ui	a11, a5, 55
 * @return The total length of this buf.
 */
static inline adf_os_size_t
adf_nbuf_len(adf_nbuf_t buf)
{
    return (__adf_nbuf_len(buf));
  908680:	0aba02        	or	a10, a11, a10
  908683:	5bf979        	call8	906c68 <__adf_nbuf_len>
  908686:	cea2      	bnez.n	a10, 9086ac <ath_intr+0x3a8>
			adf_nbuf_put_tail(ds->ds_nbuf, bf->bf_rx_status.rs_datalen);
  908688:	2b5034        	l8ui	a11, a5, 52
  90868b:	2a5035        	l8ui	a10, a5, 53
  90868e:	08bb10        	slli	a11, a11, 24
  908691:	00aa11        	slli	a10, a10, 16
  908694:	0bab02        	or	a11, a10, a11
  908697:	2a5036        	l8ui	a10, a5, 54
  90869a:	2c5037        	l8ui	a12, a5, 55
  90869d:	08aa11        	slli	a10, a10, 8
  9086a0:	0baa02        	or	a10, a10, a11
 *         put, or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_put_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_put_tail(buf, size);
  9086a3:	2b7124        	l16ui	a11, a7, 72
  9086a6:	0aca02        	or	a10, a12, a10
  9086a9:	5bf94c        	call8	906bdc <__adf_nbuf_put_tail>
		}

		frame_len += bf->bf_rx_status.rs_datalen;
  9086ac:	2a7124        	l16ui	a10, a7, 72

		if (bf->bf_rx_status.rs_more == 0) {
  9086af:	2d7056        	l8ui	a13, a7, 86

		if (adf_nbuf_len(ds->ds_nbuf) == 0) {
			adf_nbuf_put_tail(ds->ds_nbuf, bf->bf_rx_status.rs_datalen);
		}

		frame_len += bf->bf_rx_status.rs_datalen;
  9086b2:	aa66      	add.n	a6, a6, a10
  9086b4:	06064f        	extui	a6, a6, 0, 16

		if (bf->bf_rx_status.rs_more == 0) {
  9086b7:	65d235        	bnez	a13, 9088f0 <ath_intr+0x5ec>
 * @param[in] head  buf queue head
 */
static inline void
adf_nbuf_queue_init(adf_nbuf_queue_t *head)
{
    __adf_nbuf_queue_init(head);
  9086ba:	da10      	mov.n	a10, a1
  9086bc:	9d18      	s32i.n	a13, a1, 32
  9086be:	5bf978        	call8	906ca0 <__adf_nbuf_queue_init>
			adf_nbuf_queue_init(&nbuf_head);

			cnt = 0;

			ds_tail = ds;
			ds = asf_tailq_next(ds, ds_list);
  9086c1:	2a504c        	l8ui	a10, a5, 76
  9086c4:	22504d        	l8ui	a2, a5, 77
  9086c7:	08aa10        	slli	a10, a10, 24
  9086ca:	002211        	slli	a2, a2, 16
  9086cd:	0a2a02        	or	a10, a2, a10
  9086d0:	22504e        	l8ui	a2, a5, 78
			while (ds_tmp) {
				struct ath_rx_desc *ds_rmv;

				adf_nbuf_unmap(sc->sc_dev, ds_tmp->ds_dmap, ADF_OS_DMA_FROM_DEVICE);
				adf_nbuf_queue_add(&nbuf_head, ds_tmp->ds_nbuf);
				ds_tmp->ds_nbuf = ADF_NBUF_NULL;
  9086d3:	8d18      	l32i.n	a13, a1, 32
			adf_nbuf_queue_init(&nbuf_head);

			cnt = 0;

			ds_tail = ds;
			ds = asf_tailq_next(ds, ds_list);
  9086d5:	082211        	slli	a2, a2, 8
  9086d8:	0a2202        	or	a2, a2, a10
  9086db:	2a504f        	l8ui	a10, a5, 79
  9086de:	02aa02        	or	a10, a10, a2
  9086e1:	9a17      	s32i.n	a10, a1, 28
  9086e3:	600203        	j	9088ea <ath_intr+0x5e6>
  9086e6:	000000        	ill
			ds_head = asf_tailq_next(ds_tail, ds_list);

			while (ds_tmp) {
				struct ath_rx_desc *ds_rmv;

				adf_nbuf_unmap(sc->sc_dev, ds_tmp->ds_dmap, ADF_OS_DMA_FROM_DEVICE);
  9086e9:	223038        	l8ui	a2, a3, 56
  9086ec:	2b3039        	l8ui	a11, a3, 57
  9086ef:	082210        	slli	a2, a2, 24
  9086f2:	00bb11        	slli	a11, a11, 16
  9086f5:	02bb02        	or	a11, a11, a2
  9086f8:	22303a        	l8ui	a2, a3, 58
static inline void
adf_nbuf_unmap(adf_os_device_t      osdev, 
               adf_os_dma_map_t     bmap, 
               adf_os_dma_dir_t     dir)
{
    __adf_nbuf_unmap(osdev, bmap, dir);
  9086fb:	2a4246        	l32i	a10, a4, 0x118
  9086fe:	082211        	slli	a2, a2, 8
  908701:	0b2202        	or	a2, a2, a11
  908704:	2b303b        	l8ui	a11, a3, 59
  908707:	c0c1      	movi.n	a12, 1
  908709:	02bb02        	or	a11, a11, a2
  90870c:	9d18      	s32i.n	a13, a1, 32
  90870e:	5bf8db        	call8	906a7c <__adf_nbuf_unmap>
				adf_nbuf_queue_add(&nbuf_head, ds_tmp->ds_nbuf);
  908711:	2b3035        	l8ui	a11, a3, 53
  908714:	223034        	l8ui	a2, a3, 52
  908717:	00bb11        	slli	a11, a11, 16
  90871a:	082210        	slli	a2, a2, 24
  90871d:	02bb02        	or	a11, a11, a2
  908720:	223036        	l8ui	a2, a3, 54
 * @param[in] buf   buf
 */
static inline void
adf_nbuf_queue_add(adf_nbuf_queue_t *head, adf_nbuf_t buf)
{
    __adf_nbuf_queue_add(head, buf);
  908723:	da10      	mov.n	a10, a1
  908725:	082211        	slli	a2, a2, 8
  908728:	0b2202        	or	a2, a2, a11
  90872b:	2b3037        	l8ui	a11, a3, 55
  90872e:	02bb02        	or	a11, a11, a2
  908731:	5bf8b6        	call8	906a0c <__adf_nbuf_queue_add>
				ds_tmp->ds_nbuf = ADF_NBUF_NULL;

				ds_rmv = ds_tmp;
				ds_tmp = asf_tailq_next(ds_tmp, ds_list);
  908734:	2a304c        	l8ui	a10, a3, 76
  908737:	22304d        	l8ui	a2, a3, 77
  90873a:	08aa10        	slli	a10, a10, 24
  90873d:	002211        	slli	a2, a2, 16
  908740:	0a2a02        	or	a10, a2, a10
  908743:	22304e        	l8ui	a2, a3, 78
			while (ds_tmp) {
				struct ath_rx_desc *ds_rmv;

				adf_nbuf_unmap(sc->sc_dev, ds_tmp->ds_dmap, ADF_OS_DMA_FROM_DEVICE);
				adf_nbuf_queue_add(&nbuf_head, ds_tmp->ds_nbuf);
				ds_tmp->ds_nbuf = ADF_NBUF_NULL;
  908746:	8d18      	l32i.n	a13, a1, 32

				ds_rmv = ds_tmp;
				ds_tmp = asf_tailq_next(ds_tmp, ds_list);
  908748:	082211        	slli	a2, a2, 8
  90874b:	0a2202        	or	a2, a2, a10
  90874e:	2a304f        	l8ui	a10, a3, 79
			while (ds_tmp) {
				struct ath_rx_desc *ds_rmv;

				adf_nbuf_unmap(sc->sc_dev, ds_tmp->ds_dmap, ADF_OS_DMA_FROM_DEVICE);
				adf_nbuf_queue_add(&nbuf_head, ds_tmp->ds_nbuf);
				ds_tmp->ds_nbuf = ADF_NBUF_NULL;
  908751:	2d3434        	s8i	a13, a3, 52

				ds_rmv = ds_tmp;
				ds_tmp = asf_tailq_next(ds_tmp, ds_list);
  908754:	02aa02        	or	a10, a10, a2
			while (ds_tmp) {
				struct ath_rx_desc *ds_rmv;

				adf_nbuf_unmap(sc->sc_dev, ds_tmp->ds_dmap, ADF_OS_DMA_FROM_DEVICE);
				adf_nbuf_queue_add(&nbuf_head, ds_tmp->ds_nbuf);
				ds_tmp->ds_nbuf = ADF_NBUF_NULL;
  908757:	2d3435        	s8i	a13, a3, 53
  90875a:	2d3436        	s8i	a13, a3, 54
  90875d:	2d3437        	s8i	a13, a3, 55

				ds_rmv = ds_tmp;
				ds_tmp = asf_tailq_next(ds_tmp, ds_list);
  908760:	9a16      	s32i.n	a10, a1, 24
				if (ds_tmp == NULL) {
  908762:	cdaa      	bnez.n	a10, 908780 <ath_intr+0x47c>
					adf_os_assert(0);
  908764:	1268bf        	l32r	a2, 8e2a60 <athos_indirection_table_install+0x14ec>
  908767:	1b69b9        	l32r	a11, 8e2e4c <athos_indirection_table_install+0x18d8>
  90876a:	222212        	l32i	a2, a2, 72
  90876d:	1a69a0        	l32r	a10, 8e2df0 <athos_indirection_table_install+0x187c>
  908770:	9d18      	s32i.n	a13, a1, 32
  908772:	0b2000        	callx8	a2
  908775:	126923        	l32r	a2, 8e2c04 <athos_indirection_table_install+0x1690>
  908778:	8d18      	l32i.n	a13, a1, 32
  90877a:	0c0200        	memw
  90877d:	222200        	l32i	a2, a2, 0
				}

				if (ath_rxdesc_init(sc, ds_rmv) == 0) {
  908780:	db30      	mov.n	a11, a3
  908782:	da40      	mov.n	a10, a4
  908784:	9d18      	s32i.n	a13, a1, 32
  908786:	5bfd64        	call8	907d18 <ath_rxdesc_init>
  908789:	2f304c        	l8ui	a15, a3, 76
  90878c:	2e304d        	l8ui	a14, a3, 77
  90878f:	2c304e        	l8ui	a12, a3, 78
					asf_tailq_remove(&sc->sc_rxdesc, ds_rmv, ds_list);
  908792:	00ee11        	slli	a14, a14, 16
  908795:	08ff10        	slli	a15, a15, 24
  908798:	0fef02        	or	a15, a14, a15
  90879b:	2b3050        	l8ui	a11, a3, 80
  90879e:	223051        	l8ui	a2, a3, 81
  9087a1:	08cc11        	slli	a12, a12, 8
  9087a4:	2e304f        	l8ui	a14, a3, 79
  9087a7:	0fcf02        	or	a15, a12, a15
				ds_tmp = asf_tailq_next(ds_tmp, ds_list);
				if (ds_tmp == NULL) {
					adf_os_assert(0);
				}

				if (ath_rxdesc_init(sc, ds_rmv) == 0) {
  9087aa:	8d18      	l32i.n	a13, a1, 32
					asf_tailq_remove(&sc->sc_rxdesc, ds_rmv, ds_list);
  9087ac:	0fef02        	or	a15, a14, a15
  9087af:	08bb10        	slli	a11, a11, 24
  9087b2:	002211        	slli	a2, a2, 16
				ds_tmp = asf_tailq_next(ds_tmp, ds_list);
				if (ds_tmp == NULL) {
					adf_os_assert(0);
				}

				if (ath_rxdesc_init(sc, ds_rmv) == 0) {
  9087b5:	65a07d        	bnez	a10, 908836 <ath_intr+0x532>
					asf_tailq_remove(&sc->sc_rxdesc, ds_rmv, ds_list);
  9087b8:	0b2b02        	or	a11, a2, a11
  9087bb:	223052        	l8ui	a2, a3, 82
  9087be:	082211        	slli	a2, a2, 8
  9087c1:	0b2202        	or	a2, a2, a11
  9087c4:	2b3053        	l8ui	a11, a3, 83
  9087c7:	02b202        	or	a2, a11, a2
  9087ca:	c9f6      	beqz.n	a15, 9087e4 <ath_intr+0x4e0>
  9087cc:	028a57        	extui	a10, a2, 24, 8
  9087cf:	2af450        	s8i	a10, a15, 80
  9087d2:	020a57        	extui	a10, a2, 16, 8
  9087d5:	2af451        	s8i	a10, a15, 81
  9087d8:	028a47        	extui	a10, a2, 8, 8
  9087db:	2af452        	s8i	a10, a15, 82
  9087de:	22f453        	s8i	a2, a15, 83
  9087e1:	600002        	j	9087e7 <ath_intr+0x4e3>
  9087e4:	2246da        	s32i	a2, a4, 0x368
  9087e7:	2a3050        	l8ui	a10, a3, 80
  9087ea:	223051        	l8ui	a2, a3, 81
  9087ed:	08aa10        	slli	a10, a10, 24
  9087f0:	002211        	slli	a2, a2, 16
  9087f3:	0a2a02        	or	a10, a2, a10
  9087f6:	223052        	l8ui	a2, a3, 82
  9087f9:	082211        	slli	a2, a2, 8
  9087fc:	0a2202        	or	a2, a2, a10
  9087ff:	2a3053        	l8ui	a10, a3, 83
  908802:	02a202        	or	a2, a10, a2
  908805:	9f20      	s32i.n	a15, a2, 0
					asf_tailq_insert_tail(&sc->sc_rxdesc, ds_rmv, ds_list);
  908807:	2242da        	l32i	a2, a4, 0x368
  90880a:	2d344c        	s8i	a13, a3, 76
  90880d:	028a57        	extui	a10, a2, 24, 8
  908810:	2a3450        	s8i	a10, a3, 80
  908813:	020a57        	extui	a10, a2, 16, 8
  908816:	2a3451        	s8i	a10, a3, 81
  908819:	028a47        	extui	a10, a2, 8, 8
  90881c:	223453        	s8i	a2, a3, 83
  90881f:	2d344d        	s8i	a13, a3, 77
  908822:	2d344e        	s8i	a13, a3, 78
  908825:	2d344f        	s8i	a13, a3, 79
  908828:	2a3452        	s8i	a10, a3, 82
  90882b:	9320      	s32i.n	a3, a2, 0
  90882d:	223c4c        	addi	a2, a3, 76
  908830:	2246da        	s32i	a2, a4, 0x368
  908833:	60008e        	j	9088c5 <ath_intr+0x5c1>
				}  else {
					asf_tailq_remove(&sc->sc_rxdesc, ds_rmv, ds_list);
  908836:	cafa      	beqz.n	a15, 908864 <ath_intr+0x560>
  908838:	0b2b02        	or	a11, a2, a11
  90883b:	223052        	l8ui	a2, a3, 82
  90883e:	082211        	slli	a2, a2, 8
  908841:	0b2202        	or	a2, a2, a11
  908844:	2b3053        	l8ui	a11, a3, 83
  908847:	02b202        	or	a2, a11, a2
  90884a:	028a57        	extui	a10, a2, 24, 8
  90884d:	2af450        	s8i	a10, a15, 80
  908850:	020a57        	extui	a10, a2, 16, 8
  908853:	2af451        	s8i	a10, a15, 81
  908856:	028a47        	extui	a10, a2, 8, 8
  908859:	2af452        	s8i	a10, a15, 82
  90885c:	22f453        	s8i	a2, a15, 83
  90885f:	600016        	j	908879 <ath_intr+0x575>
  908862:	00000b        	addx8	a0, a0, a0
  908865:	22022b        	l32i	a2, a0, 172
  908868:	305208        	excw
  90886b:	bb11      	addi.n	a1, a1, 11
  90886d:	02b202        	or	a2, a11, a2
  908870:	2b3053        	l8ui	a11, a3, 83
  908873:	02b202        	or	a2, a11, a2
  908876:	2246da        	s32i	a2, a4, 0x368
  908879:	2a3050        	l8ui	a10, a3, 80
  90887c:	223051        	l8ui	a2, a3, 81
  90887f:	08aa10        	slli	a10, a10, 24
  908882:	002211        	slli	a2, a2, 16
  908885:	0a2a02        	or	a10, a2, a10
  908888:	223052        	l8ui	a2, a3, 82
  90888b:	082211        	slli	a2, a2, 8
  90888e:	0a2202        	or	a2, a2, a10
  908891:	2a3053        	l8ui	a10, a3, 83
  908894:	02a202        	or	a2, a10, a2
  908897:	9f20      	s32i.n	a15, a2, 0
					asf_tailq_insert_tail(&sc->sc_rxdesc_idle, ds_rmv, ds_list);
  908899:	2242d8        	l32i	a2, a4, 0x360
  90889c:	2d344c        	s8i	a13, a3, 76
  90889f:	028a57        	extui	a10, a2, 24, 8
  9088a2:	2a3450        	s8i	a10, a3, 80
  9088a5:	020a57        	extui	a10, a2, 16, 8
  9088a8:	2a3451        	s8i	a10, a3, 81
  9088ab:	028a47        	extui	a10, a2, 8, 8
  9088ae:	223453        	s8i	a2, a3, 83
  9088b1:	2d344d        	s8i	a13, a3, 77
  9088b4:	2d344e        	s8i	a13, a3, 78
  9088b7:	2d344f        	s8i	a13, a3, 79
  9088ba:	2a3452        	s8i	a10, a3, 82
  9088bd:	9320      	s32i.n	a3, a2, 0
  9088bf:	223c4c        	addi	a2, a3, 76
  9088c2:	2246d8        	s32i	a2, a4, 0x360
				}

				if (ds_rmv == ds_tail) {
  9088c5:	73591f        	bne	a5, a3, 9088e8 <ath_intr+0x5e4>
					break;
				}
			}


			bf->bf_rx_status.rs_datalen = frame_len;
  9088c8:	267524        	s16i	a6, a7, 72
}

static inline adf_nbuf_t
adf_nbuf_create_frm_frag(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_create_frm_frag(head);
  9088cb:	da10      	mov.n	a10, a1
  9088cd:	5bf87f        	call8	906acc <__adf_nbuf_create_frm_frag>
			frame_len = 0;

			bf->bf_skb = adf_nbuf_create_frm_frag(&nbuf_head);

			bf->bf_status |= ATH_BUFSTATUS_DONE;
  9088d0:	827f      	l32i.n	a2, a7, 60
  9088d2:	c031      	movi.n	a3, 1
  9088d4:	032202        	or	a2, a2, a3


			bf->bf_rx_status.rs_datalen = frame_len;
			frame_len = 0;

			bf->bf_skb = adf_nbuf_create_frm_frag(&nbuf_head);
  9088d7:	9a78      	s32i.n	a10, a7, 32

			bf->bf_status |= ATH_BUFSTATUS_DONE;
  9088d9:	927f      	s32i.n	a2, a7, 60

			ds_tail = ds;
			ds = asf_tailq_next(ds, ds_list);

			ds_tmp = ds_head;
			ds_head = asf_tailq_next(ds_tail, ds_list);
  9088db:	8317      	l32i.n	a3, a1, 28

			bf->bf_skb = adf_nbuf_create_frm_frag(&nbuf_head);

			bf->bf_status |= ATH_BUFSTATUS_DONE;

			bf = (struct ath_rx_buf *)asf_tailq_next(bf, bf_list);
  9088dd:	8779      	l32i.n	a7, a7, 36
				}
			}


			bf->bf_rx_status.rs_datalen = frame_len;
			frame_len = 0;
  9088df:	c060      	movi.n	a6, 0
			adf_nbuf_queue_init(&nbuf_head);

			cnt = 0;

			ds_tail = ds;
			ds = asf_tailq_next(ds, ds_list);
  9088e1:	d530      	mov.n	a5, a3

		if (bf->bf_rx_status.rs_more == 0) {
			adf_nbuf_queue_t nbuf_head;
			adf_nbuf_queue_init(&nbuf_head);

			cnt = 0;
  9088e3:	d260      	mov.n	a2, a6
  9088e5:	600025        	j	90890e <ath_intr+0x60a>
				adf_nbuf_unmap(sc->sc_dev, ds_tmp->ds_dmap, ADF_OS_DMA_FROM_DEVICE);
				adf_nbuf_queue_add(&nbuf_head, ds_tmp->ds_nbuf);
				ds_tmp->ds_nbuf = ADF_NBUF_NULL;

				ds_rmv = ds_tmp;
				ds_tmp = asf_tailq_next(ds_tmp, ds_list);
  9088e8:	8316      	l32i.n	a3, a1, 24
			ds = asf_tailq_next(ds, ds_list);

			ds_tmp = ds_head;
			ds_head = asf_tailq_next(ds_tail, ds_list);

			while (ds_tmp) {
  9088ea:	653dfb        	bnez	a3, 9086e9 <ath_intr+0x3e5>
  9088ed:	63ffd7        	j	9088c8 <ath_intr+0x5c4>
			bf->bf_status |= ATH_BUFSTATUS_DONE;

			bf = (struct ath_rx_buf *)asf_tailq_next(bf, bf_list);
		}
		else {
			ds = asf_tailq_next(ds, ds_list);
  9088f0:	2b504c        	l8ui	a11, a5, 76
  9088f3:	2a504d        	l8ui	a10, a5, 77
  9088f6:	08bb10        	slli	a11, a11, 24
  9088f9:	00aa11        	slli	a10, a10, 16
  9088fc:	0bab02        	or	a11, a10, a11
  9088ff:	2a504e        	l8ui	a10, a5, 78
  908902:	29504f        	l8ui	a9, a5, 79
  908905:	08aa11        	slli	a10, a10, 8
  908908:	0baa02        	or	a10, a10, a11
  90890b:	0a9502        	or	a5, a9, a10
	bf = asf_tailq_first(&sc->sc_rxbuf);

	ds = asf_tailq_first(&sc->sc_rxdesc);
	ds_head = ds;

	while(ds) {
  90890e:	655ad3        	bnez	a5, 9083e5 <ath_intr+0xe1>
  908911:	63fcbf        	j	9085d4 <ath_intr+0x2d0>
			ah->ah_setInterrupts(ah, sc->sc_imask);

			ATH_SCHEDULE_TQUEUE(sc->sc_dev, &sc->sc_rxtq);
		}

		if (status & HAL_INT_TXURN) {
  908914:	8213      	l32i.n	a2, a1, 12
  908916:	742712        	bbci	a2, 20, 90892c <ath_intr+0x628>
			sc->sc_int_stats.ast_txurn++;
  908919:	22424f        	l32i	a2, a4, 0x13c
			ah->ah_updateTxTrigLevel(ah, AH_TRUE);
  90891c:	8314      	l32i.n	a3, a1, 16

			ATH_SCHEDULE_TQUEUE(sc->sc_dev, &sc->sc_rxtq);
		}

		if (status & HAL_INT_TXURN) {
			sc->sc_int_stats.ast_txurn++;
  90891e:	b122      	addi.n	a2, a2, 1
  908920:	22464f        	s32i	a2, a4, 0x13c
			ah->ah_updateTxTrigLevel(ah, AH_TRUE);
  908923:	8237      	l32i.n	a2, a3, 28
  908925:	c0b1      	movi.n	a11, 1
  908927:	da30      	mov.n	a10, a3
  908929:	0b2000        	callx8	a2
  90892c:	2a5a1c        	movi	a10, 0x51c
  90892f:	aa4a      	add.n	a10, a4, a10
  908931:	5bfcc7        	call8	907c50 <__adf_os_sched_bh$isra$6>
		}

		ATH_SCHEDULE_TQUEUE(sc->sc_dev, &sc->sc_txtq);

		if (status & HAL_INT_BMISS) {
  908934:	8213      	l32i.n	a2, a1, 12
  908936:	7d2607        	bbci	a2, 13, 908941 <ath_intr+0x63d>
  908939:	2a3a24        	movi	a10, 0x324
  90893c:	aa4a      	add.n	a10, a4, a10
  90893e:	5bfcc4        	call8	907c50 <__adf_os_sched_bh$isra$6>
			ATH_SCHEDULE_TQUEUE(sc->sc_dev, &sc->sc_bmisstq);
		}

		if (status & HAL_INT_GTT)
  908941:	8313      	l32i.n	a3, a1, 12
  908943:	723607        	bbci	a3, 2, 90894e <ath_intr+0x64a>
			sc->sc_int_stats.ast_txto++;
  908946:	224250        	l32i	a2, a4, 0x140
  908949:	b122      	addi.n	a2, a2, 1
  90894b:	224650        	s32i	a2, a4, 0x140

		if (status & HAL_INT_CST)
			sc->sc_int_stats.ast_cst++;
	}

	return ADF_OS_IRQ_HANDLED;
  90894e:	c021      	movi.n	a2, 1
		}

		if (status & HAL_INT_GTT)
			sc->sc_int_stats.ast_txto++;

		if (status & HAL_INT_CST)
  908950:	763608        	bbci	a3, 6, 90895c <ath_intr+0x658>
			sc->sc_int_stats.ast_cst++;
  908953:	234251        	l32i	a3, a4, 0x144
  908956:	023308        	add	a3, a3, a2
  908959:	234651        	s32i	a3, a4, 0x144
	}

	return ADF_OS_IRQ_HANDLED;
}
  90895c:	d10f      	retw.n
	...

00908960 <ath_fatal_tasklet>:

static void ath_fatal_tasklet(TQUEUE_ARG data )
{
  908960:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)data;

	wmi_event(sc->tgt_wmi_handle, WMI_FATAL_EVENTID, NULL, 0);
  908963:	c0d0      	movi.n	a13, 0
  908965:	1b69ba        	l32r	a11, 8e3050 <athos_indirection_table_install+0x1adc>
  908968:	8a23      	l32i.n	a10, a2, 12
  90896a:	0ddc02        	or	a12, a13, a13
  90896d:	5bfe4e        	call8	9082a8 <wmi_event>
  908970:	d10f      	retw.n
	...

00908974 <ath_bmiss_tasklet>:
}

static void ath_bmiss_tasklet(TQUEUE_ARG data)
{
  908974:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)data;

	wmi_event(sc->tgt_wmi_handle, WMI_BMISS_EVENTID, NULL, 0);
  908977:	c0d0      	movi.n	a13, 0
  908979:	1b69bb        	l32r	a11, 8e3068 <athos_indirection_table_install+0x1af4>
  90897c:	8a23      	l32i.n	a10, a2, 12
  90897e:	0ddc02        	or	a12, a13, a13
  908981:	5bfe49        	call8	9082a8 <wmi_event>
  908984:	d10f      	retw.n
	...

00908988 <wmi_cmd_rsp>:
	WMI_SendEvent(handle, netbuf, evt_id, 0, Length);
}

void wmi_cmd_rsp(void *pContext, WMI_COMMAND_ID cmd_id, A_UINT16 SeqNo,
		 void *buffer, a_int32_t Length)
{
  908988:	6c1006        	entry	a1, 48
	adf_nbuf_t netbuf = ADF_NBUF_NULL;
	A_UINT8 *pData;

	netbuf = WMI_AllocEvent(pContext, WMI_EVT_CLASS_CMD_REPLY,
  90898b:	1768bf        	l32r	a7, 8e2c88 <athos_indirection_table_install+0x1714>
  90898e:	b46c      	addi.n	a12, a6, 4
  908990:	28728d        	l32i	a8, a7, 0x234
  908993:	2b0a01        	movi	a11, 1
  908996:	022a02        	or	a10, a2, a2
  908999:	0b8000        	callx8	a8
	WMI_SendEvent(handle, netbuf, evt_id, 0, Length);
}

void wmi_cmd_rsp(void *pContext, WMI_COMMAND_ID cmd_id, A_UINT16 SeqNo,
		 void *buffer, a_int32_t Length)
{
  90899c:	04044f        	extui	a4, a4, 0, 16
	adf_nbuf_t netbuf = ADF_NBUF_NULL;
	A_UINT8 *pData;

	netbuf = WMI_AllocEvent(pContext, WMI_EVT_CLASS_CMD_REPLY,
  90899f:	d8a0      	mov.n	a8, a10
				sizeof(WMI_CMD_HDR) + Length);

	if (netbuf == ADF_NBUF_NULL) {
  9089a1:	65a015        	bnez	a10, 9089ba <wmi_cmd_rsp+0x32>
		adf_os_assert(0);
  9089a4:	227212        	l32i	a2, a7, 72
  9089a7:	1b69bc        	l32r	a11, 8e3098 <athos_indirection_table_install+0x1b24>
  9089aa:	1a69a0        	l32r	a10, 8e302c <athos_indirection_table_install+0x1ab8>
  9089ad:	0b2000        	callx8	a2
  9089b0:	126923        	l32r	a2, 8e2e3c <athos_indirection_table_install+0x18c8>
  9089b3:	0c0200        	memw
  9089b6:	8220      	l32i.n	a2, a2, 0
  9089b8:	d10f      	retw.n
		return;
	}

	if (Length != 0 && buffer != NULL) {
  9089ba:	c962      	beqz.n	a6, 9089d0 <wmi_cmd_rsp+0x48>
  9089bc:	c950      	beqz.n	a5, 9089d0 <wmi_cmd_rsp+0x48>
 *         put, or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_put_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_put_tail(buf, size);
  9089be:	db60      	mov.n	a11, a6
  9089c0:	2a1600        	s32i	a10, a1, 0
  9089c3:	5bf886        	call8	906bdc <__adf_nbuf_put_tail>
  9089c6:	dc60      	mov.n	a12, a6
  9089c8:	055b02        	or	a11, a5, a5
  9089cb:	5bfc51        	call8	907b10 <__adf_os_mem_copy>
  9089ce:	8810      	l32i.n	a8, a1, 0
		pData = (A_UINT8 *)adf_nbuf_put_tail(netbuf, Length);
		adf_os_mem_copy(pData, buffer, Length);
	}

	WMI_SendEvent(pContext, netbuf, cmd_id, SeqNo, Length);
  9089d0:	25728e        	l32i	a5, a7, 0x238
  9089d3:	de60      	mov.n	a14, a6
  9089d5:	dd40      	mov.n	a13, a4
  9089d7:	030c4f        	extui	a12, a3, 0, 16
  9089da:	db80      	mov.n	a11, a8
  9089dc:	da20      	mov.n	a10, a2
  9089de:	0b5000        	callx8	a5
  9089e1:	d10f      	retw.n
	...

009089e4 <ath_hal_reg_rmw_tgt>:
}

static void ath_hal_reg_rmw_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data,
				a_int32_t datalen)
{
  9089e4:	6c1006        	entry	a1, 48
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  9089e7:	272d05        	addmi	a7, a2, 0x500
  9089ea:	887b      	l32i.n	a8, a7, 44
}

static void ath_hal_reg_rmw_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data,
				a_int32_t datalen)
{
  9089ec:	03034f        	extui	a3, a3, 0, 16
  9089ef:	04044f        	extui	a4, a4, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  9089f2:	9810      	s32i.n	a8, a1, 0
	struct register_rmw *buf = (struct register_rmw *)data;
	int i;

	for (i = 0; i < datalen;
  9089f4:	d750      	mov.n	a7, a5
  9089f6:	60003f        	j	908a39 <ath_hal_reg_rmw_tgt+0x55>
	     i += sizeof(struct register_rmw)) {
		a_uint32_t val;
		buf = (struct register_rmw *)(data + i);

		val = ath_reg_read_filter(ah, buf->reg);
  9089f9:	8b70      	l32i.n	a11, a7, 0
  9089fb:	8a10      	l32i.n	a10, a1, 0
  9089fd:	5bfd57        	call8	907f5c <ath_reg_read_filter>
		val &= ~buf->clr;
  908a00:	8872      	l32i.n	a8, a7, 8
  908a02:	c79f      	movi.n	a9, -1
  908a04:	089803        	xor	a8, a9, a8
  908a07:	0a8a01        	and	a10, a8, a10
		val |= buf->set;
  908a0a:	8871      	l32i.n	a8, a7, 4
}

static void ath_hal_reg_write_filter(struct ath_hal *ah,
			a_uint32_t reg, a_uint32_t val)
{
	if(reg > 0xffff) {
  908a0c:	1b69b0        	l32r	a11, 8e30cc <athos_indirection_table_install+0x1b58>
		a_uint32_t val;
		buf = (struct register_rmw *)(data + i);

		val = ath_reg_read_filter(ah, buf->reg);
		val &= ~buf->clr;
		val |= buf->set;
  908a0f:	08aa02        	or	a10, a10, a8
		ath_hal_reg_write_filter(ah, buf->reg, val);
  908a12:	8870      	l32i.n	a8, a7, 0
}

static void ath_hal_reg_write_filter(struct ath_hal *ah,
			a_uint32_t reg, a_uint32_t val)
{
	if(reg > 0xffff) {
  908a14:	78bb04        	bgeu	a11, a8, 908a1c <ath_hal_reg_rmw_tgt+0x38>
  908a17:	600017        	j	908a32 <ath_hal_reg_rmw_tgt+0x4e>
  908a1a:	00001b        	sra	a0, a0
				flg = 1;
			}
		}
#endif
	} else {
		if(reg == 0x7014)
  908a1d:	69bd7b        	bnei	a11, 64, 908a9c <ath_rc_mask_tgt+0x4c>
  908a20:	890a      	l32i.n	a9, a0, 40
			ath_pll_reset_ones(ah);
  908a22:	9812      	s32i.n	a8, a1, 8
  908a24:	9a11      	s32i.n	a10, a1, 4
  908a26:	5bfd22        	call8	907eb0 <ath_pll_reset_ones$isra$12>
  908a29:	8a11      	l32i.n	a10, a1, 4
  908a2b:	8812      	l32i.n	a8, a1, 8

		iowrite32_mac(reg, val);
  908a2d:	1b69ab        	l32r	a11, 8e30dc <athos_indirection_table_install+0x1b68>
  908a30:	ab88      	add.n	a8, a8, a11
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  908a32:	0c0200        	memw
  908a35:	9a80      	s32i.n	a10, a8, 0
  908a37:	bc77      	addi.n	a7, a7, 12
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
	struct register_rmw *buf = (struct register_rmw *)data;
	int i;

	for (i = 0; i < datalen;
  908a39:	05780c        	sub	a8, a7, a5
  908a3c:	7682b9        	blt	a8, a6, 9089f9 <ath_hal_reg_rmw_tgt+0x15>
		val = ath_reg_read_filter(ah, buf->reg);
		val &= ~buf->clr;
		val |= buf->set;
		ath_hal_reg_write_filter(ah, buf->reg, val);
	}
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  908a3f:	c0e0      	movi.n	a14, 0
  908a41:	8a23      	l32i.n	a10, a2, 12
  908a43:	dde0      	mov.n	a13, a14
  908a45:	dc40      	mov.n	a12, a4
  908a47:	db30      	mov.n	a11, a3
  908a49:	5bffcf        	call8	908988 <wmi_cmd_rsp>
  908a4c:	d10f      	retw.n
	...

00908a50 <ath_rc_mask_tgt>:
	adf_os_assert(0);
}

static void ath_rc_mask_tgt(void *Context, A_UINT16 Command,
			    A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
  908a50:	6c1004        	entry	a1, 32
	int idx, band, i;

	idx = wmi_data->vap_index;
	band = wmi_data->band;

	sc->sc_vap[idx].av_rate_mask[band] = adf_os_ntohl(wmi_data->mask);
  908a53:	2a5002        	l8ui	a10, a5, 2
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_rate_mask_cmd *wmi_data = (struct wmi_rc_rate_mask_cmd *)buffer;
	int idx, band, i;

	idx = wmi_data->vap_index;
  908a56:	2f5000        	l8ui	a15, a5, 0
	band = wmi_data->band;

	sc->sc_vap[idx].av_rate_mask[band] = adf_os_ntohl(wmi_data->mask);
  908a59:	08ae10        	slli	a14, a10, 24
  908a5c:	2a5003        	l8ui	a10, a5, 3
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_rate_mask_cmd *wmi_data = (struct wmi_rc_rate_mask_cmd *)buffer;
	int idx, band, i;

	idx = wmi_data->vap_index;
	band = wmi_data->band;
  908a5f:	2d5001        	l8ui	a13, a5, 1

	sc->sc_vap[idx].av_rate_mask[band] = adf_os_ntohl(wmi_data->mask);
  908a62:	00aa11        	slli	a10, a10, 16
  908a65:	0eaa02        	or	a10, a10, a14
  908a68:	2e5004        	l8ui	a14, a5, 4
  908a6b:	0cf811        	slli	a8, a15, 4
  908a6e:	08ee11        	slli	a14, a14, 8
  908a71:	0aea02        	or	a10, a14, a10
  908a74:	2e5005        	l8ui	a14, a5, 5
  908a77:	af89      	add.n	a9, a8, a15
  908a79:	0aee02        	or	a14, a14, a10
	adf_os_assert(0);
}

static void ath_rc_mask_tgt(void *Context, A_UINT16 Command,
			    A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
  908a7c:	030b4f        	extui	a11, a3, 0, 16
	int idx, band, i;

	idx = wmi_data->vap_index;
	band = wmi_data->band;

	sc->sc_vap[idx].av_rate_mask[band] = adf_os_ntohl(wmi_data->mask);
  908a7f:	ad9a      	add.n	a10, a9, a13
  908a81:	235a70        	movi	a3, 0x570
  908a84:	a3aa      	add.n	a10, a10, a3
  908a86:	0eaa11        	slli	a10, a10, 2
  908a89:	aa2a      	add.n	a10, a2, a10
  908a8b:	9ea4      	s32i.n	a14, a10, 16
	adf_os_assert(0);
}

static void ath_rc_mask_tgt(void *Context, A_UINT16 Command,
			    A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
  908a8d:	040c4f        	extui	a12, a4, 0, 16
	idx = wmi_data->vap_index;
	band = wmi_data->band;

	sc->sc_vap[idx].av_rate_mask[band] = adf_os_ntohl(wmi_data->mask);

	if (sc->sc_vap[idx].av_rate_mask[band]) {
  908a90:	caea      	beqz.n	a14, 908abe <ath_rc_mask_tgt+0x6e>
  908a92:	c050      	movi.n	a5, 0
		for (i = 0; i < RATE_TABLE_SIZE; i++) {
			if ((1 << i) & sc->sc_vap[idx].av_rate_mask[band]) {
  908a94:	c0a1      	movi.n	a10, 1
  908a96:	290a20        	movi	a9, 32
  908a99:	6d981e        	loop	a9, 908abb <ath_rc_mask_tgt+0x6b>
  908a9c:	005104        	ssl	a5
  908a9f:	00a31a        	sll	a3, a10
  908aa2:	7e3013        	bnone	a3, a14, 908ab9 <ath_rc_mask_tgt+0x69>
				sc->sc_vap[idx].av_minrateidx[band] = i;
  908aa5:	af89      	add.n	a9, a8, a15
  908aa7:	0e9911        	slli	a9, a9, 2
  908aaa:	a929      	add.n	a9, a2, a9
  908aac:	1869be        	l32r	a8, 8e31a4 <athos_indirection_table_install+0x1c30>
  908aaf:	ad99      	add.n	a9, a9, a13
  908ab1:	a899      	add.n	a9, a9, a8
  908ab3:	259400        	s8i	a5, a9, 0
				break;
  908ab6:	600013        	j	908acd <ath_rc_mask_tgt+0x7d>
	band = wmi_data->band;

	sc->sc_vap[idx].av_rate_mask[band] = adf_os_ntohl(wmi_data->mask);

	if (sc->sc_vap[idx].av_rate_mask[band]) {
		for (i = 0; i < RATE_TABLE_SIZE; i++) {
  908ab9:	b155      	addi.n	a5, a5, 1
  908abb:	60000e        	j	908acd <ath_rc_mask_tgt+0x7d>
				sc->sc_vap[idx].av_minrateidx[band] = i;
				break;
			}
		}
	} else {
		sc->sc_vap[idx].av_minrateidx[band] = 0;
  908abe:	0e9911        	slli	a9, a9, 2
  908ac1:	a929      	add.n	a9, a2, a9
  908ac3:	1569be        	l32r	a5, 8e31bc <athos_indirection_table_install+0x1c48>
  908ac6:	ad99      	add.n	a9, a9, a13
  908ac8:	a599      	add.n	a9, a9, a5
  908aca:	2e9400        	s8i	a14, a9, 0
	}

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  908acd:	c0e0      	movi.n	a14, 0
  908acf:	8a23      	l32i.n	a10, a2, 12
  908ad1:	dde0      	mov.n	a13, a14
  908ad3:	5bffad        	call8	908988 <wmi_cmd_rsp>
  908ad6:	d10f      	retw.n

00908ad8 <ath_rx_stats_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
}

static void ath_rx_stats_tgt(void *Context,A_UINT16 Command, A_UINT16 SeqNo,
			     A_UINT8 *data, a_int32_t datalen)
{
  908ad8:	6c1006        	entry	a1, 48
		a_uint32_t   ast_rx_done;
	};

	struct fusion_stats stats;

	stats.ast_rx_nobuf = sc->sc_rx_stats.ast_rx_nobuf;
  908adb:	28227c        	l32i	a8, a2, 0x1f0
	stats.ast_rx_send = sc->sc_rx_stats.ast_rx_send;
	stats.ast_rx_done = sc->sc_rx_stats.ast_rx_done;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  908ade:	8a23      	l32i.n	a10, a2, 12
		a_uint32_t   ast_rx_done;
	};

	struct fusion_stats stats;

	stats.ast_rx_nobuf = sc->sc_rx_stats.ast_rx_nobuf;
  908ae0:	9810      	s32i.n	a8, a1, 0
	stats.ast_rx_send = sc->sc_rx_stats.ast_rx_send;
  908ae2:	28227d        	l32i	a8, a2, 0x1f4
	stats.ast_rx_done = sc->sc_rx_stats.ast_rx_done;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  908ae5:	c0ec      	movi.n	a14, 12
	};

	struct fusion_stats stats;

	stats.ast_rx_nobuf = sc->sc_rx_stats.ast_rx_nobuf;
	stats.ast_rx_send = sc->sc_rx_stats.ast_rx_send;
  908ae7:	9811      	s32i.n	a8, a1, 4
	stats.ast_rx_done = sc->sc_rx_stats.ast_rx_done;
  908ae9:	28227e        	l32i	a8, a2, 0x1f8

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  908aec:	dd10      	mov.n	a13, a1
  908aee:	040c4f        	extui	a12, a4, 0, 16
  908af1:	030b4f        	extui	a11, a3, 0, 16

	struct fusion_stats stats;

	stats.ast_rx_nobuf = sc->sc_rx_stats.ast_rx_nobuf;
	stats.ast_rx_send = sc->sc_rx_stats.ast_rx_send;
	stats.ast_rx_done = sc->sc_rx_stats.ast_rx_done;
  908af4:	9812      	s32i.n	a8, a1, 8

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  908af6:	5bffa4        	call8	908988 <wmi_cmd_rsp>
  908af9:	d10f      	retw.n
	...

00908afc <ath_tx_stats_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
}

static void ath_tx_stats_tgt(void *Context,A_UINT16 Command, A_UINT16 SeqNo,
			     A_UINT8 *data, a_int32_t datalen)
{
  908afc:	6c100a        	entry	a1, 80
		a_uint32_t   tx_nobufs;
	};

	struct fusion_stats stats;

	stats.ast_tx_xretries = sc->sc_tx_stats.ast_tx_xretries;
  908aff:	282252        	l32i	a8, a2, 0x148
	stats.ast_tx_longretry = sc->sc_tx_stats.ast_tx_longretry;
	stats.tx_qnull = sc->sc_tx_stats.tx_qnull;
	stats.tx_noskbs = sc->sc_tx_stats.tx_noskbs;
	stats.tx_nobufs = sc->sc_tx_stats.tx_nobufs;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  908b02:	8a23      	l32i.n	a10, a2, 12
		a_uint32_t   tx_nobufs;
	};

	struct fusion_stats stats;

	stats.ast_tx_xretries = sc->sc_tx_stats.ast_tx_xretries;
  908b04:	9810      	s32i.n	a8, a1, 0
	stats.ast_tx_fifoerr = sc->sc_tx_stats.ast_tx_fifoerr;
  908b06:	282253        	l32i	a8, a2, 0x14c
	stats.ast_tx_longretry = sc->sc_tx_stats.ast_tx_longretry;
	stats.tx_qnull = sc->sc_tx_stats.tx_qnull;
	stats.tx_noskbs = sc->sc_tx_stats.tx_noskbs;
	stats.tx_nobufs = sc->sc_tx_stats.tx_nobufs;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  908b09:	c2e4      	movi.n	a14, 36
	};

	struct fusion_stats stats;

	stats.ast_tx_xretries = sc->sc_tx_stats.ast_tx_xretries;
	stats.ast_tx_fifoerr = sc->sc_tx_stats.ast_tx_fifoerr;
  908b0b:	9811      	s32i.n	a8, a1, 4
	stats.ast_tx_filtered = sc->sc_tx_stats.ast_tx_filtered;
  908b0d:	282254        	l32i	a8, a2, 0x150
	stats.ast_tx_longretry = sc->sc_tx_stats.ast_tx_longretry;
	stats.tx_qnull = sc->sc_tx_stats.tx_qnull;
	stats.tx_noskbs = sc->sc_tx_stats.tx_noskbs;
	stats.tx_nobufs = sc->sc_tx_stats.tx_nobufs;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  908b10:	dd10      	mov.n	a13, a1

	struct fusion_stats stats;

	stats.ast_tx_xretries = sc->sc_tx_stats.ast_tx_xretries;
	stats.ast_tx_fifoerr = sc->sc_tx_stats.ast_tx_fifoerr;
	stats.ast_tx_filtered = sc->sc_tx_stats.ast_tx_filtered;
  908b12:	9812      	s32i.n	a8, a1, 8
	stats.ast_tx_timer_exp = sc->sc_tx_stats.ast_tx_timer_exp;
  908b14:	282255        	l32i	a8, a2, 0x154
	stats.ast_tx_longretry = sc->sc_tx_stats.ast_tx_longretry;
	stats.tx_qnull = sc->sc_tx_stats.tx_qnull;
	stats.tx_noskbs = sc->sc_tx_stats.tx_noskbs;
	stats.tx_nobufs = sc->sc_tx_stats.tx_nobufs;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  908b17:	040c4f        	extui	a12, a4, 0, 16
	struct fusion_stats stats;

	stats.ast_tx_xretries = sc->sc_tx_stats.ast_tx_xretries;
	stats.ast_tx_fifoerr = sc->sc_tx_stats.ast_tx_fifoerr;
	stats.ast_tx_filtered = sc->sc_tx_stats.ast_tx_filtered;
	stats.ast_tx_timer_exp = sc->sc_tx_stats.ast_tx_timer_exp;
  908b1a:	9813      	s32i.n	a8, a1, 12
	stats.ast_tx_shortretry = sc->sc_tx_stats.ast_tx_shortretry;
  908b1c:	282256        	l32i	a8, a2, 0x158
	stats.ast_tx_longretry = sc->sc_tx_stats.ast_tx_longretry;
	stats.tx_qnull = sc->sc_tx_stats.tx_qnull;
	stats.tx_noskbs = sc->sc_tx_stats.tx_noskbs;
	stats.tx_nobufs = sc->sc_tx_stats.tx_nobufs;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  908b1f:	030b4f        	extui	a11, a3, 0, 16

	stats.ast_tx_xretries = sc->sc_tx_stats.ast_tx_xretries;
	stats.ast_tx_fifoerr = sc->sc_tx_stats.ast_tx_fifoerr;
	stats.ast_tx_filtered = sc->sc_tx_stats.ast_tx_filtered;
	stats.ast_tx_timer_exp = sc->sc_tx_stats.ast_tx_timer_exp;
	stats.ast_tx_shortretry = sc->sc_tx_stats.ast_tx_shortretry;
  908b22:	9814      	s32i.n	a8, a1, 16
	stats.ast_tx_longretry = sc->sc_tx_stats.ast_tx_longretry;
  908b24:	282257        	l32i	a8, a2, 0x15c
  908b27:	9815      	s32i.n	a8, a1, 20
	stats.tx_qnull = sc->sc_tx_stats.tx_qnull;
  908b29:	28225c        	l32i	a8, a2, 0x170
  908b2c:	9816      	s32i.n	a8, a1, 24
	stats.tx_noskbs = sc->sc_tx_stats.tx_noskbs;
  908b2e:	282276        	l32i	a8, a2, 0x1d8
  908b31:	9817      	s32i.n	a8, a1, 28
	stats.tx_nobufs = sc->sc_tx_stats.tx_nobufs;
  908b33:	282277        	l32i	a8, a2, 0x1dc
  908b36:	281608        	s32i	a8, a1, 32

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  908b39:	5bff93        	call8	908988 <wmi_cmd_rsp>
  908b3c:	d10f      	retw.n
	...

00908b40 <ath_int_stats_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_int_stats_tgt(void *Context,A_UINT16 Command, A_UINT16 SeqNo,
			      A_UINT8 *data, a_int32_t datalen)
{
  908b40:	6c1008        	entry	a1, 64
		a_uint32_t ast_cst;
	};

	struct fusion_stats stats;

	stats.ast_rx = sc->sc_int_stats.ast_rx;
  908b43:	28224c        	l32i	a8, a2, 0x130
	stats.ast_rxeol = sc->sc_int_stats.ast_rxeol;
	stats.ast_txurn = sc->sc_int_stats.ast_txurn;
	stats.ast_txto = sc->sc_int_stats.ast_txto;
	stats.ast_cst = sc->sc_int_stats.ast_cst;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  908b46:	8a23      	l32i.n	a10, a2, 12
		a_uint32_t ast_cst;
	};

	struct fusion_stats stats;

	stats.ast_rx = sc->sc_int_stats.ast_rx;
  908b48:	9810      	s32i.n	a8, a1, 0
	stats.ast_rxorn = sc->sc_int_stats.ast_rxorn;
  908b4a:	28224d        	l32i	a8, a2, 0x134
	stats.ast_rxeol = sc->sc_int_stats.ast_rxeol;
	stats.ast_txurn = sc->sc_int_stats.ast_txurn;
	stats.ast_txto = sc->sc_int_stats.ast_txto;
	stats.ast_cst = sc->sc_int_stats.ast_cst;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  908b4d:	c1e8      	movi.n	a14, 24
	};

	struct fusion_stats stats;

	stats.ast_rx = sc->sc_int_stats.ast_rx;
	stats.ast_rxorn = sc->sc_int_stats.ast_rxorn;
  908b4f:	9811      	s32i.n	a8, a1, 4
	stats.ast_rxeol = sc->sc_int_stats.ast_rxeol;
  908b51:	28224e        	l32i	a8, a2, 0x138
	stats.ast_txurn = sc->sc_int_stats.ast_txurn;
	stats.ast_txto = sc->sc_int_stats.ast_txto;
	stats.ast_cst = sc->sc_int_stats.ast_cst;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  908b54:	dd10      	mov.n	a13, a1

	struct fusion_stats stats;

	stats.ast_rx = sc->sc_int_stats.ast_rx;
	stats.ast_rxorn = sc->sc_int_stats.ast_rxorn;
	stats.ast_rxeol = sc->sc_int_stats.ast_rxeol;
  908b56:	9812      	s32i.n	a8, a1, 8
	stats.ast_txurn = sc->sc_int_stats.ast_txurn;
  908b58:	28224f        	l32i	a8, a2, 0x13c
	stats.ast_txto = sc->sc_int_stats.ast_txto;
	stats.ast_cst = sc->sc_int_stats.ast_cst;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  908b5b:	040c4f        	extui	a12, a4, 0, 16
	struct fusion_stats stats;

	stats.ast_rx = sc->sc_int_stats.ast_rx;
	stats.ast_rxorn = sc->sc_int_stats.ast_rxorn;
	stats.ast_rxeol = sc->sc_int_stats.ast_rxeol;
	stats.ast_txurn = sc->sc_int_stats.ast_txurn;
  908b5e:	9813      	s32i.n	a8, a1, 12
	stats.ast_txto = sc->sc_int_stats.ast_txto;
  908b60:	282250        	l32i	a8, a2, 0x140
	stats.ast_cst = sc->sc_int_stats.ast_cst;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  908b63:	030b4f        	extui	a11, a3, 0, 16

	stats.ast_rx = sc->sc_int_stats.ast_rx;
	stats.ast_rxorn = sc->sc_int_stats.ast_rxorn;
	stats.ast_rxeol = sc->sc_int_stats.ast_rxeol;
	stats.ast_txurn = sc->sc_int_stats.ast_txurn;
	stats.ast_txto = sc->sc_int_stats.ast_txto;
  908b66:	9814      	s32i.n	a8, a1, 16
	stats.ast_cst = sc->sc_int_stats.ast_cst;
  908b68:	282251        	l32i	a8, a2, 0x144
  908b6b:	9815      	s32i.n	a8, a1, 20

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
  908b6d:	5bff86        	call8	908988 <wmi_cmd_rsp>
  908b70:	d10f      	retw.n
	...

00908b74 <ath_node_update_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_node_update_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  908b74:	6c1004        	entry	a1, 32
	a_uint8_t vap_index;
	a_uint8_t node_index;

	node = (struct ieee80211_node_target *)data;

	node_index = node->ni_nodeindex;
  908b77:	26500c        	l8ui	a6, a5, 12

	node->ni_htcap = adf_os_ntohs(node->ni_htcap);
	node->ni_flags = adf_os_ntohs(node->ni_flags);
	node->ni_maxampdu = adf_os_ntohs(node->ni_maxampdu);

	adf_os_mem_copy(&(sc->sc_sta[node_index].ni), node,
  908b7a:	2a5a38        	movi	a10, 0x538
  908b7d:	0a6811        	slli	a8, a6, 6
  908b80:	a688      	add.n	a8, a8, a6
  908b82:	0f8811        	slli	a8, a8, 1
  908b85:	a688      	add.n	a8, a8, a6
  908b87:	0e8611        	slli	a6, a8, 2
  908b8a:	aa6a      	add.n	a10, a6, a10
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_node_update_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  908b8c:	db50      	mov.n	a11, a5
  908b8e:	aa2a      	add.n	a10, a2, a10
  908b90:	c1c6      	movi.n	a12, 22
  908b92:	5bfbdf        	call8	907b10 <__adf_os_mem_copy>

	adf_os_mem_copy(&(sc->sc_sta[node_index].ni), node,
			NODE_TARGET_SIZE);

	vap_index = sc->sc_sta[node_index].ni.ni_vapindex;
	sc->sc_sta[node_index].ni.ni_vap = &(sc->sc_vap[vap_index].av_vap);
  908b95:	a628      	add.n	a8, a2, a6
	node->ni_maxampdu = adf_os_ntohs(node->ni_maxampdu);

	adf_os_mem_copy(&(sc->sc_sta[node_index].ni), node,
			NODE_TARGET_SIZE);

	vap_index = sc->sc_sta[node_index].ni.ni_vapindex;
  908b97:	265a45        	movi	a6, 0x545
  908b9a:	a686      	add.n	a6, a8, a6
	sc->sc_sta[node_index].ni.ni_vap = &(sc->sc_vap[vap_index].av_vap);
  908b9c:	2a6000        	l8ui	a10, a6, 0
  908b9f:	295a58        	movi	a9, 0x558
  908ba2:	0ca611        	slli	a6, a10, 4
  908ba5:	aa66      	add.n	a6, a6, a10
  908ba7:	1a69bf        	l32r	a10, 8e32a4 <athos_indirection_table_install+0x1d30>
  908baa:	0e6611        	slli	a6, a6, 2
  908bad:	aa66      	add.n	a6, a6, a10
  908baf:	a989      	add.n	a9, a8, a9
  908bb1:	a626      	add.n	a6, a2, a6
  908bb3:	9690      	s32i.n	a6, a9, 0

	sc->sc_sta[node_index].ni.ni_txseqmgmt = 0;
  908bb5:	265a50        	movi	a6, 0x550
  908bb8:	a686      	add.n	a6, a8, a6
  908bba:	c090      	movi.n	a9, 0
  908bbc:	296500        	s16i	a9, a6, 0
	sc->sc_sta[node_index].ni.ni_iv16 = 0;
  908bbf:	265a52        	movi	a6, 0x552
  908bc2:	a686      	add.n	a6, a8, a6
  908bc4:	296500        	s16i	a9, a6, 0
	sc->sc_sta[node_index].ni.ni_iv32 = 0;
  908bc7:	265a54        	movi	a6, 0x554
  908bca:	c0d0      	movi.n	a13, 0
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_node_update_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  908bcc:	03034f        	extui	a3, a3, 0, 16
  908bcf:	04044f        	extui	a4, a4, 0, 16
	vap_index = sc->sc_sta[node_index].ni.ni_vapindex;
	sc->sc_sta[node_index].ni.ni_vap = &(sc->sc_vap[vap_index].av_vap);

	sc->sc_sta[node_index].ni.ni_txseqmgmt = 0;
	sc->sc_sta[node_index].ni.ni_iv16 = 0;
	sc->sc_sta[node_index].ni.ni_iv32 = 0;
  908bd2:	a688      	add.n	a8, a8, a6

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  908bd4:	8a23      	l32i.n	a10, a2, 12
	vap_index = sc->sc_sta[node_index].ni.ni_vapindex;
	sc->sc_sta[node_index].ni.ni_vap = &(sc->sc_vap[vap_index].av_vap);

	sc->sc_sta[node_index].ni.ni_txseqmgmt = 0;
	sc->sc_sta[node_index].ni.ni_iv16 = 0;
	sc->sc_sta[node_index].ni.ni_iv32 = 0;
  908bd6:	9d80      	s32i.n	a13, a8, 0

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  908bd8:	ded0      	mov.n	a14, a13
  908bda:	dc40      	mov.n	a12, a4
  908bdc:	db30      	mov.n	a11, a3
  908bde:	5bff6a        	call8	908988 <wmi_cmd_rsp>
  908be1:	d10f      	retw.n
	...

00908be4 <ath_detach_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_detach_tgt(void *Context, A_UINT16 Command, A_UINT16 SeqNo,
				 A_UINT8 *data, a_int32_t datalen)
{
  908be4:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  908be7:	252d05        	addmi	a5, a2, 0x500
  908bea:	855b      	l32i.n	a5, a5, 44

	ath_desc_free(sc);
  908bec:	022a02        	or	a10, a2, a2
  908bef:	5bfd35        	call8	9080c4 <ath_desc_free>
	ah->ah_detach(ah);
  908bf2:	8856      	l32i.n	a8, a5, 24
  908bf4:	da50      	mov.n	a10, a5
  908bf6:	0b8000        	callx8	a8
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_detach_tgt(void *Context, A_UINT16 Command, A_UINT16 SeqNo,
				 A_UINT8 *data, a_int32_t datalen)
{
  908bf9:	03034f        	extui	a3, a3, 0, 16
  908bfc:	04044f        	extui	a4, a4, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;

	ath_desc_free(sc);
	ah->ah_detach(ah);
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  908bff:	c0e0      	movi.n	a14, 0
  908c01:	8a23      	l32i.n	a10, a2, 12
  908c03:	dde0      	mov.n	a13, a14
  908c05:	dc40      	mov.n	a12, a4
  908c07:	db30      	mov.n	a11, a3
  908c09:	5bff5f        	call8	908988 <wmi_cmd_rsp>
  908c0c:	d10f      	retw.n
	...

00908c10 <ath_enable_aggr_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &ver, sizeof(ver));
}

static void ath_enable_aggr_tgt(void *Context,A_UINT16 Command, A_UINT16 SeqNo,
				A_UINT8 *data, a_int32_t datalen)
{
  908c10:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_aggr_info *aggr = (struct ath_aggr_info *)data;
	a_uint8_t nodeindex = aggr->nodeindex;
  908c13:	2d5000        	l8ui	a13, a5, 0
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &ver, sizeof(ver));
}

static void ath_enable_aggr_tgt(void *Context,A_UINT16 Command, A_UINT16 SeqNo,
				A_UINT8 *data, a_int32_t datalen)
{
  908c16:	03034f        	extui	a3, a3, 0, 16
  908c19:	04044f        	extui	a4, a4, 0, 16
	a_uint8_t nodeindex = aggr->nodeindex;
	a_uint8_t tidno = aggr->tidno;
	struct ath_node_target *an = NULL ;
	struct ath_atx_tid  *tid = NULL;

	if (nodeindex >= TARGET_NODE_MAX) {
  908c1c:	6ed802        	bltui	a13, 8, 908c22 <ath_enable_aggr_tgt+0x12>
  908c1f:	600089        	j	908cac <ath_enable_aggr_tgt+0x9c>
		goto done;
	}

	an = &sc->sc_sta[nodeindex];
	if (!an->an_valid) {
  908c22:	0ad811        	slli	a8, a13, 6
  908c25:	ad88      	add.n	a8, a8, a13
  908c27:	0f8811        	slli	a8, a8, 1
  908c2a:	ad88      	add.n	a8, a8, a13
  908c2c:	0e8b11        	slli	a11, a8, 2
  908c2f:	ab28      	add.n	a8, a2, a11
  908c31:	297a3c        	movi	a9, 0x73c
  908c34:	a988      	add.n	a8, a8, a9
  908c36:	288000        	l8ui	a8, a8, 0
  908c39:	64806f        	beqz	a8, 908cac <ath_enable_aggr_tgt+0x9c>
				A_UINT8 *data, a_int32_t datalen)
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_aggr_info *aggr = (struct ath_aggr_info *)data;
	a_uint8_t nodeindex = aggr->nodeindex;
	a_uint8_t tidno = aggr->tidno;
  908c3c:	2c5001        	l8ui	a12, a5, 1
	an = &sc->sc_sta[nodeindex];
	if (!an->an_valid) {
		goto done;
	}

	if (tidno >= WME_NUM_TID) {
  908c3f:	6ec811        	bltui	a12, 8, 908c54 <ath_enable_aggr_tgt+0x44>
		adf_os_print("[%s] enable_aggr with invalid tid %d(node = %d)\n",
  908c42:	1568bf        	l32r	a5, 8e2f40 <athos_indirection_table_install+0x19cc>
  908c45:	1b69c0        	l32r	a11, 8e3348 <athos_indirection_table_install+0x1dd4>
  908c48:	255212        	l32i	a5, a5, 72
  908c4b:	1a69c1        	l32r	a10, 8e3350 <athos_indirection_table_install+0x1ddc>
  908c4e:	0b5000        	callx8	a5
			     __FUNCTION__, tidno, nodeindex);
		goto done;
  908c51:	600057        	j	908cac <ath_enable_aggr_tgt+0x9c>
  908c54:	0cc811        	slli	a8, a12, 4
	}

	tid = ATH_AN_2_TID(an, tidno);

	if (aggr->aggr_enable) {
		tid->flag |= TID_AGGR_ENABLED;
  908c57:	0c880c        	sub	a8, a8, a12
  908c5a:	0e8811        	slli	a8, a8, 2
		goto done;
	}

	tid = ATH_AN_2_TID(an, tidno);

	if (aggr->aggr_enable) {
  908c5d:	255002        	l8ui	a5, a5, 2
		tid->flag |= TID_AGGR_ENABLED;
  908c60:	ab88      	add.n	a8, a8, a11
  908c62:	a828      	add.n	a8, a2, a8
		goto done;
	}

	tid = ATH_AN_2_TID(an, tidno);

	if (aggr->aggr_enable) {
  908c64:	c951      	beqz.n	a5, 908c79 <ath_enable_aggr_tgt+0x69>
		tid->flag |= TID_AGGR_ENABLED;
  908c66:	255a92        	movi	a5, 0x592
  908c69:	a588      	add.n	a8, a8, a5
  908c6b:	298000        	l8ui	a9, a8, 0
  908c6e:	c052      	movi.n	a5, 2
  908c70:	059902        	or	a9, a9, a5
  908c73:	298400        	s8i	a9, a8, 0
  908c76:	600032        	j	908cac <ath_enable_aggr_tgt+0x9c>
	} else if ( tid->flag & TID_AGGR_ENABLED ) {
  908c79:	255a92        	movi	a5, 0x592
  908c7c:	a588      	add.n	a8, a8, a5
  908c7e:	298000        	l8ui	a9, a8, 0
  908c81:	7e9727        	bbci	a9, 30, 908cac <ath_enable_aggr_tgt+0x9c>
		tid->flag &= ~TID_AGGR_ENABLED;
  908c84:	c75d      	movi.n	a5, -3
  908c86:	059901        	and	a9, a9, a5
  908c89:	298400        	s8i	a9, a8, 0
		adf_os_print("[%s] enable_aggr with invalid tid %d(node = %d)\n",
			     __FUNCTION__, tidno, nodeindex);
		goto done;
	}

	tid = ATH_AN_2_TID(an, tidno);
  908c8c:	0cc911        	slli	a9, a12, 4
  908c8f:	0c9c0c        	sub	a12, a9, a12
  908c92:	0ecc11        	slli	a12, a12, 2
  908c95:	abcc      	add.n	a12, a12, a11
  908c97:	255a5c        	movi	a5, 0x55c

	if (nodeindex >= TARGET_NODE_MAX) {
		goto done;
	}

	an = &sc->sc_sta[nodeindex];
  908c9a:	285a38        	movi	a8, 0x538
		adf_os_print("[%s] enable_aggr with invalid tid %d(node = %d)\n",
			     __FUNCTION__, tidno, nodeindex);
		goto done;
	}

	tid = ATH_AN_2_TID(an, tidno);
  908c9d:	a5cc      	add.n	a12, a12, a5

	if (nodeindex >= TARGET_NODE_MAX) {
		goto done;
	}

	an = &sc->sc_sta[nodeindex];
  908c9f:	a8bb      	add.n	a11, a11, a8

	if (aggr->aggr_enable) {
		tid->flag |= TID_AGGR_ENABLED;
	} else if ( tid->flag & TID_AGGR_ENABLED ) {
		tid->flag &= ~TID_AGGR_ENABLED;
		ath_tgt_tx_cleanup(sc, an, tid, 1);
  908ca1:	c0d1      	movi.n	a13, 1
  908ca3:	ac2c      	add.n	a12, a2, a12
  908ca5:	ab2b      	add.n	a11, a2, a11
  908ca7:	da20      	mov.n	a10, a2
  908ca9:	581882        	call8	90eeb4 <ath_tgt_tx_cleanup>
	}
done:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  908cac:	c0e0      	movi.n	a14, 0
  908cae:	8a23      	l32i.n	a10, a2, 12
  908cb0:	dde0      	mov.n	a13, a14
  908cb2:	dc40      	mov.n	a12, a4
  908cb4:	db30      	mov.n	a11, a3
  908cb6:	5bff34        	call8	908988 <wmi_cmd_rsp>
  908cb9:	d10f      	retw.n
	...

00908cbc <ath_ic_update_tgt>:
}

static void ath_ic_update_tgt(void *Context,A_UINT16 Command, A_UINT16 SeqNo,
			      A_UINT8 *data, a_int32_t datalen)
{
  908cbc:	6c1004        	entry	a1, 32
  908cbf:	1a69c2        	l32r	a10, 8e33c8 <athos_indirection_table_install+0x1e54>
  908cc2:	db50      	mov.n	a11, a5
  908cc4:	0a2a08        	add	a10, a2, a10
  908cc7:	c0c8      	movi.n	a12, 8
  908cc9:	5bfb91        	call8	907b10 <__adf_os_mem_copy>
	struct ieee80211com_target *ic = (struct ieee80211com_target * )data;
	struct ieee80211com_target *ictgt = &sc->sc_ic ;

	adf_os_mem_copy(ictgt, ic, sizeof(struct  ieee80211com_target));

	ictgt->ic_ampdu_limit         = adf_os_ntohl(ic->ic_ampdu_limit);
  908ccc:	8850      	l32i.n	a8, a5, 0
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_ic_update_tgt(void *Context,A_UINT16 Command, A_UINT16 SeqNo,
			      A_UINT8 *data, a_int32_t datalen)
{
  908cce:	03034f        	extui	a3, a3, 0, 16
  908cd1:	04044f        	extui	a4, a4, 0, 16
	struct ieee80211com_target *ic = (struct ieee80211com_target * )data;
	struct ieee80211com_target *ictgt = &sc->sc_ic ;

	adf_os_mem_copy(ictgt, ic, sizeof(struct  ieee80211com_target));

	ictgt->ic_ampdu_limit         = adf_os_ntohl(ic->ic_ampdu_limit);
  908cd4:	252d16        	addmi	a5, a2, 0x1600

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  908cd7:	c0e0      	movi.n	a14, 0
  908cd9:	8a23      	l32i.n	a10, a2, 12
	struct ieee80211com_target *ic = (struct ieee80211com_target * )data;
	struct ieee80211com_target *ictgt = &sc->sc_ic ;

	adf_os_mem_copy(ictgt, ic, sizeof(struct  ieee80211com_target));

	ictgt->ic_ampdu_limit         = adf_os_ntohl(ic->ic_ampdu_limit);
  908cdb:	9858      	s32i.n	a8, a5, 32

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  908cdd:	dde0      	mov.n	a13, a14
  908cdf:	dc40      	mov.n	a12, a4
  908ce1:	db30      	mov.n	a11, a3
  908ce3:	5bff29        	call8	908988 <wmi_cmd_rsp>
  908ce6:	d10f      	retw.n

00908ce8 <handle_rc_rate_update_cmd>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void handle_rc_rate_update_cmd(void *Context, A_UINT16 Command,
				      A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
  908ce8:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_rate_update_cmd *wmi_data = (struct wmi_rc_rate_update_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);

	ath_rate_node_update(sc, &sc->sc_sta[wmi_data->node_index],
  908ceb:	295000        	l8ui	a9, a5, 0
				      A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_rate_update_cmd *wmi_data = (struct wmi_rc_rate_update_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);
  908cee:	285004        	l8ui	a8, a5, 4
  908cf1:	2d5005        	l8ui	a13, a5, 5
  908cf4:	088810        	slli	a8, a8, 24

	ath_rate_node_update(sc, &sc->sc_sta[wmi_data->node_index],
  908cf7:	0a9b11        	slli	a11, a9, 6
				      A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_rate_update_cmd *wmi_data = (struct wmi_rc_rate_update_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);
  908cfa:	00dd11        	slli	a13, a13, 16
  908cfd:	08dd02        	or	a13, a13, a8

	ath_rate_node_update(sc, &sc->sc_sta[wmi_data->node_index],
  908d00:	a9bb      	add.n	a11, a11, a9
				      A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_rate_update_cmd *wmi_data = (struct wmi_rc_rate_update_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);
  908d02:	285006        	l8ui	a8, a5, 6

	ath_rate_node_update(sc, &sc->sc_sta[wmi_data->node_index],
  908d05:	0fbb11        	slli	a11, a11, 1
  908d08:	a9bb      	add.n	a11, a11, a9
				      A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_rate_update_cmd *wmi_data = (struct wmi_rc_rate_update_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);
  908d0a:	088811        	slli	a8, a8, 8
  908d0d:	0d8802        	or	a8, a8, a13

	ath_rate_node_update(sc, &sc->sc_sta[wmi_data->node_index],
  908d10:	295a38        	movi	a9, 0x538
				      A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_rate_update_cmd *wmi_data = (struct wmi_rc_rate_update_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);
  908d13:	2d5007        	l8ui	a13, a5, 7

	ath_rate_node_update(sc, &sc->sc_sta[wmi_data->node_index],
  908d16:	0ebb11        	slli	a11, a11, 2
  908d19:	a9bb      	add.n	a11, a11, a9
  908d1b:	2c5001        	l8ui	a12, a5, 1
  908d1e:	b85e      	addi.n	a14, a5, 8
  908d20:	08dd02        	or	a13, a13, a8
  908d23:	0b2b08        	add	a11, a2, a11
  908d26:	022a02        	or	a10, a2, a2
  908d29:	581027        	call8	90cdc8 <ath_rate_node_update>
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void handle_rc_rate_update_cmd(void *Context, A_UINT16 Command,
				      A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
  908d2c:	03034f        	extui	a3, a3, 0, 16
  908d2f:	04044f        	extui	a4, a4, 0, 16
	ath_rate_node_update(sc, &sc->sc_sta[wmi_data->node_index],
			     wmi_data->isNew,
			     capflag,
			     &wmi_data->rs);

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  908d32:	c0e0      	movi.n	a14, 0
  908d34:	8a23      	l32i.n	a10, a2, 12
  908d36:	dde0      	mov.n	a13, a14
  908d38:	dc40      	mov.n	a12, a4
  908d3a:	033b02        	or	a11, a3, a3
  908d3d:	5bff12        	call8	908988 <wmi_cmd_rsp>
  908d40:	d10f      	retw.n
	...

00908d44 <handle_rc_state_change_cmd>:
}

static void handle_rc_state_change_cmd(void *Context, A_UINT16 Command,
				       A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)

{
  908d44:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_state_change_cmd *wmi_data = (struct wmi_rc_state_change_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);
  908d47:	285004        	l8ui	a8, a5, 4
  908d4a:	2d5005        	l8ui	a13, a5, 5

	ath_rate_newstate(sc, &sc->sc_vap[wmi_data->vap_index].av_vap,
  908d4d:	295000        	l8ui	a9, a5, 0

{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_state_change_cmd *wmi_data = (struct wmi_rc_state_change_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);
  908d50:	088810        	slli	a8, a8, 24
  908d53:	00dd11        	slli	a13, a13, 16
  908d56:	08dd02        	or	a13, a13, a8
  908d59:	285006        	l8ui	a8, a5, 6

	ath_rate_newstate(sc, &sc->sc_vap[wmi_data->vap_index].av_vap,
  908d5c:	0c9b11        	slli	a11, a9, 4
  908d5f:	a9bb      	add.n	a11, a11, a9

{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_state_change_cmd *wmi_data = (struct wmi_rc_state_change_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);
  908d61:	088811        	slli	a8, a8, 8

	ath_rate_newstate(sc, &sc->sc_vap[wmi_data->vap_index].av_vap,
  908d64:	1969bf        	l32r	a9, 8e3460 <athos_indirection_table_install+0x1eec>

{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_state_change_cmd *wmi_data = (struct wmi_rc_state_change_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);
  908d67:	0d8802        	or	a8, a8, a13

	ath_rate_newstate(sc, &sc->sc_vap[wmi_data->vap_index].av_vap,
  908d6a:	0ebb11        	slli	a11, a11, 2

{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_rc_state_change_cmd *wmi_data = (struct wmi_rc_state_change_cmd *)buffer;

	a_uint32_t capflag = adf_os_ntohl(wmi_data->capflag);
  908d6d:	2d5007        	l8ui	a13, a5, 7

	ath_rate_newstate(sc, &sc->sc_vap[wmi_data->vap_index].av_vap,
  908d70:	a9bb      	add.n	a11, a11, a9
  908d72:	2c5001        	l8ui	a12, a5, 1
  908d75:	b85e      	addi.n	a14, a5, 8
  908d77:	08dd02        	or	a13, a13, a8
  908d7a:	ab2b      	add.n	a11, a2, a11
  908d7c:	da20      	mov.n	a10, a2
  908d7e:	581017        	call8	90cddc <ath_rate_newstate>
}

static void handle_rc_state_change_cmd(void *Context, A_UINT16 Command,
				       A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)

{
  908d81:	03034f        	extui	a3, a3, 0, 16
  908d84:	04044f        	extui	a4, a4, 0, 16
	ath_rate_newstate(sc, &sc->sc_vap[wmi_data->vap_index].av_vap,
			  wmi_data->vap_state,
			  capflag,
			  &wmi_data->rs);

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  908d87:	c0e0      	movi.n	a14, 0
  908d89:	8a23      	l32i.n	a10, a2, 12
  908d8b:	dde0      	mov.n	a13, a14
  908d8d:	dc40      	mov.n	a12, a4
  908d8f:	db30      	mov.n	a11, a3
  908d91:	5bfefd        	call8	908988 <wmi_cmd_rsp>
  908d94:	d10f      	retw.n
	...

00908d98 <ath_hal_reg_write_tgt>:
	}
}

static void ath_hal_reg_write_tgt(void *Context, A_UINT16 Command,
				  A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  908d98:	6c1006        	entry	a1, 48
  908d9b:	030b4f        	extui	a11, a3, 0, 16
  908d9e:	040c4f        	extui	a12, a4, 0, 16
	struct registerWrite {
		a_uint32_t reg;
		a_uint32_t val;
	}*t;

	for (i = 0; i < datalen; i += sizeof(struct registerWrite)) {
  908da1:	d350      	mov.n	a3, a5
  908da3:	60002a        	j	908dd1 <ath_hal_reg_write_tgt+0x39>
		t = (struct registerWrite *)(data+i);

		ath_hal_reg_write_filter(ah, t->reg, t->val);
  908da6:	8730      	l32i.n	a7, a3, 0
}

static void ath_hal_reg_write_filter(struct ath_hal *ah,
			a_uint32_t reg, a_uint32_t val)
{
	if(reg > 0xffff) {
  908da8:	1869b0        	l32r	a8, 8e3468 <athos_indirection_table_install+0x1ef4>
	}*t;

	for (i = 0; i < datalen; i += sizeof(struct registerWrite)) {
		t = (struct registerWrite *)(data+i);

		ath_hal_reg_write_filter(ah, t->reg, t->val);
  908dab:	8431      	l32i.n	a4, a3, 4
}

static void ath_hal_reg_write_filter(struct ath_hal *ah,
			a_uint32_t reg, a_uint32_t val)
{
	if(reg > 0xffff) {
  908dad:	778b03        	bgeu	a8, a7, 908db4 <ath_hal_reg_write_tgt+0x1c>
  908db0:	600016        	j	908dca <ath_hal_reg_write_tgt+0x32>
  908db3:	001869        	excw
				flg = 1;
			}
		}
#endif
	} else {
		if(reg == 0x7014)
  908db6:	bd78      	addi.n	a8, a7, 13
  908db8:	790a9b        	bge	a0, a9, 908d57 <handle_rc_state_change_cmd+0x13>
			ath_pll_reset_ones(ah);
  908dbb:	109c11        	l32r	a0, 8efe00 <memset+0x8fb8>
  908dbe:	5bfc3c        	call8	907eb0 <ath_pll_reset_ones$isra$12>
  908dc1:	8c11      	l32i.n	a12, a1, 4
  908dc3:	8b10      	l32i.n	a11, a1, 0

		iowrite32_mac(reg, val);
  908dc5:	1869ab        	l32r	a8, 8e3474 <athos_indirection_table_install+0x1f00>
  908dc8:	a877      	add.n	a7, a7, a8
  908dca:	0c0200        	memw
  908dcd:	9470      	s32i.n	a4, a7, 0
  908dcf:	b833      	addi.n	a3, a3, 8
	struct registerWrite {
		a_uint32_t reg;
		a_uint32_t val;
	}*t;

	for (i = 0; i < datalen; i += sizeof(struct registerWrite)) {
  908dd1:	05340c        	sub	a4, a3, a5
  908dd4:	7642ce        	blt	a4, a6, 908da6 <ath_hal_reg_write_tgt+0xe>
		t = (struct registerWrite *)(data+i);

		ath_hal_reg_write_filter(ah, t->reg, t->val);
	}

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  908dd7:	c0e0      	movi.n	a14, 0
  908dd9:	8a23      	l32i.n	a10, a2, 12
  908ddb:	dde0      	mov.n	a13, a14
  908ddd:	5bfeea        	call8	908988 <wmi_cmd_rsp>
  908de0:	d10f      	retw.n
	...

00908de4 <ath_hal_reg_read_tgt>:
		return ioread32_mac(addr);
}

static void ath_hal_reg_read_tgt(void *Context, A_UINT16 Command,
				 A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  908de4:	6c1016        	entry	a1, 176
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  908de7:	272d05        	addmi	a7, a2, 0x500
  908dea:	897b      	l32i.n	a9, a7, 44
		return ioread32_mac(addr);
}

static void ath_hal_reg_read_tgt(void *Context, A_UINT16 Command,
				 A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  908dec:	03034f        	extui	a3, a3, 0, 16
  908def:	04044f        	extui	a4, a4, 0, 16
	struct ath_hal *ah = sc->sc_ah;
	a_uint32_t addr;
	a_uint32_t val[32];
	int i;

	for (i = 0; i < datalen; i += sizeof(a_int32_t)) {
  908df2:	c070      	movi.n	a7, 0
  908df4:	60001c        	j	908e14 <ath_hal_reg_read_tgt+0x30>
  908df7:	0000a7        	excw
		addr = *(a_uint32_t *)(data + i);
  908dfa:	588b80        	call8	92bbfc <_etext+0x1c9cb>
		addr = adf_os_ntohl(addr);

		val[i/sizeof(a_int32_t)] =
			adf_os_ntohl(ath_reg_read_filter(ah, addr));
  908dfd:	da90      	mov.n	a10, a9
  908dff:	291620        	s32i	a9, a1, 128
  908e02:	5bfc56        	call8	907f5c <ath_reg_read_filter>

	for (i = 0; i < datalen; i += sizeof(a_int32_t)) {
		addr = *(a_uint32_t *)(data + i);
		addr = adf_os_ntohl(addr);

		val[i/sizeof(a_int32_t)] =
  908e05:	072814        	srli	a8, a7, 2
  908e08:	0e8811        	slli	a8, a8, 2
  908e0b:	a818      	add.n	a8, a1, a8
	struct ath_hal *ah = sc->sc_ah;
	a_uint32_t addr;
	a_uint32_t val[32];
	int i;

	for (i = 0; i < datalen; i += sizeof(a_int32_t)) {
  908e0d:	291220        	l32i	a9, a1, 128
		addr = *(a_uint32_t *)(data + i);
		addr = adf_os_ntohl(addr);

		val[i/sizeof(a_int32_t)] =
  908e10:	9a80      	s32i.n	a10, a8, 0
	struct ath_hal *ah = sc->sc_ah;
	a_uint32_t addr;
	a_uint32_t val[32];
	int i;

	for (i = 0; i < datalen; i += sizeof(a_int32_t)) {
  908e12:	b477      	addi.n	a7, a7, 4
  908e14:	7672e1        	blt	a7, a6, 908df9 <ath_hal_reg_read_tgt+0x15>

		val[i/sizeof(a_int32_t)] =
			adf_os_ntohl(ath_reg_read_filter(ah, addr));
	}

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &val[0], datalen);
  908e17:	8a23      	l32i.n	a10, a2, 12
  908e19:	de60      	mov.n	a14, a6
  908e1b:	dd10      	mov.n	a13, a1
  908e1d:	dc40      	mov.n	a12, a4
  908e1f:	db30      	mov.n	a11, a3
  908e21:	5bfed9        	call8	908988 <wmi_cmd_rsp>
  908e24:	d10f      	retw.n
	...

00908e28 <ath_vap_create_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_vap_create_tgt(void *Context, A_UINT16 Command, A_UINT16 SeqNo,
			       A_UINT8 *data, a_int32_t datalen)
{
  908e28:	6c1004        	entry	a1, 32
	vap = (struct ieee80211vap_target *)data;

	vap->iv_rtsthreshold    = adf_os_ntohs(vap->iv_rtsthreshold);
	vap->iv_opmode          = adf_os_ntohl(vap->iv_opmode);

	vap_index = vap->iv_vapindex;
  908e2b:	275000        	l8ui	a7, a5, 0

	adf_os_assert(sc->sc_vap[vap_index].av_valid == 0);
  908e2e:	1969c3        	l32r	a9, 8e353c <_HIFusb_start+0x9c>
  908e31:	0c7611        	slli	a6, a7, 4
  908e34:	a768      	add.n	a8, a6, a7
  908e36:	0e8811        	slli	a8, a8, 2
  908e39:	a828      	add.n	a8, a2, a8
  908e3b:	a988      	add.n	a8, a8, a9
  908e3d:	288000        	l8ui	a8, a8, 0
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_vap_create_tgt(void *Context, A_UINT16 Command, A_UINT16 SeqNo,
			       A_UINT8 *data, a_int32_t datalen)
{
  908e40:	03034f        	extui	a3, a3, 0, 16
  908e43:	04044f        	extui	a4, a4, 0, 16
	vap->iv_rtsthreshold    = adf_os_ntohs(vap->iv_rtsthreshold);
	vap->iv_opmode          = adf_os_ntohl(vap->iv_opmode);

	vap_index = vap->iv_vapindex;

	adf_os_assert(sc->sc_vap[vap_index].av_valid == 0);
  908e46:	648016        	beqz	a8, 908e60 <ath_vap_create_tgt+0x38>
  908e49:	1868bf        	l32r	a8, 8e3148 <athos_indirection_table_install+0x1bd4>
  908e4c:	1b69c4        	l32r	a11, 8e355c <_HIFusb_start+0xbc>
  908e4f:	288212        	l32i	a8, a8, 72
  908e52:	1a69a0        	l32r	a10, 8e34d4 <_HIFusb_start+0x34>
  908e55:	0b8000        	callx8	a8
  908e58:	186923        	l32r	a8, 8e32e4 <athos_indirection_table_install+0x1d70>
  908e5b:	0c0200        	memw
  908e5e:	8880      	l32i.n	a8, a8, 0

	adf_os_mem_copy(&(sc->sc_vap[vap_index].av_vap), vap,
  908e60:	0c7a11        	slli	a10, a7, 4
  908e63:	1869bf        	l32r	a8, 8e3560 <_HIFusb_start+0xc0>
  908e66:	a7aa      	add.n	a10, a10, a7
  908e68:	0eaa11        	slli	a10, a10, 2
  908e6b:	a8aa      	add.n	a10, a10, a8
  908e6d:	db50      	mov.n	a11, a5
  908e6f:	aa2a      	add.n	a10, a2, a10
  908e71:	c0cc      	movi.n	a12, 12
			VAP_TARGET_SIZE);

	sc->sc_vap[vap_index].av_bcbuf = asf_tailq_first(&(sc->sc_bbuf));
  908e73:	a766      	add.n	a6, a6, a7
  908e75:	5bfb26        	call8	907b10 <__adf_os_mem_copy>
  908e78:	272d16        	addmi	a7, a2, 0x1600
  908e7b:	0e6611        	slli	a6, a6, 2
  908e7e:	1569c5        	l32r	a5, 8e3594 <_HIFusb_start+0xf4>
  908e81:	a626      	add.n	a6, a2, a6
  908e83:	877a      	l32i.n	a7, a7, 40
  908e85:	a565      	add.n	a5, a6, a5
  908e87:	9750      	s32i.n	a7, a5, 0
	sc->sc_vap[vap_index].av_valid = 1;
  908e89:	1569c3        	l32r	a5, 8e3598 <_HIFusb_start+0xf8>

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  908e8c:	c0e0      	movi.n	a14, 0

	adf_os_mem_copy(&(sc->sc_vap[vap_index].av_vap), vap,
			VAP_TARGET_SIZE);

	sc->sc_vap[vap_index].av_bcbuf = asf_tailq_first(&(sc->sc_bbuf));
	sc->sc_vap[vap_index].av_valid = 1;
  908e8e:	a566      	add.n	a6, a6, a5
  908e90:	c051      	movi.n	a5, 1
  908e92:	256400        	s8i	a5, a6, 0

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  908e95:	8a23      	l32i.n	a10, a2, 12
  908e97:	dde0      	mov.n	a13, a14
  908e99:	dc40      	mov.n	a12, a4
  908e9b:	db30      	mov.n	a11, a3
  908e9d:	5bfeba        	call8	908988 <wmi_cmd_rsp>
  908ea0:	d10f      	retw.n
	...

00908ea4 <ath_vap_delete_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_vap_delete_tgt(void *Context, A_UINT16 Command,
			       A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  908ea4:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	a_uint8_t vap_index;

	vap_index = *(a_uint8_t *)data;
  908ea7:	2d5000        	l8ui	a13, a5, 0

	sc->sc_vap[vap_index].av_valid = 0;
  908eaa:	1969c3        	l32r	a9, 8e35b8 <_HIFusb_start+0x118>
  908ead:	0cd811        	slli	a8, a13, 4
  908eb0:	ad88      	add.n	a8, a8, a13
  908eb2:	0e8811        	slli	a8, a8, 2
  908eb5:	a828      	add.n	a8, a2, a8
  908eb7:	a989      	add.n	a9, a8, a9
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_vap_delete_tgt(void *Context, A_UINT16 Command,
			       A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  908eb9:	030b4f        	extui	a11, a3, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	a_uint8_t vap_index;

	vap_index = *(a_uint8_t *)data;

	sc->sc_vap[vap_index].av_valid = 0;
  908ebc:	c030      	movi.n	a3, 0
  908ebe:	239400        	s8i	a3, a9, 0
	sc->sc_vap[vap_index].av_bcbuf = NULL;
  908ec1:	1369c5        	l32r	a3, 8e35d8 <_HIFusb_start+0x138>
  908ec4:	c090      	movi.n	a9, 0
  908ec6:	a388      	add.n	a8, a8, a3
  908ec8:	9980      	s32i.n	a9, a8, 0
  908eca:	285a45        	movi	a8, 0x545
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_vap_delete_tgt(void *Context, A_UINT16 Command,
			       A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  908ecd:	040c4f        	extui	a12, a4, 0, 16
  908ed0:	a828      	add.n	a8, a2, a8
{
	a_int32_t i;

	for (i = 0; i < TARGET_NODE_MAX; i++) {
		if(sc->sc_sta[i].ni.ni_vapindex == vap_index)
			sc->sc_sta[i].an_valid = 0;
  908ed2:	2f1af7        	movi	a15, 0x1f7
  908ed5:	2e2a0c        	movi	a14, 0x20c
  908ed8:	c0a8      	movi.n	a10, 8
  908eda:	6da80c        	loop	a10, 908eea <ath_vap_delete_tgt+0x46>
static void ath_node_vdelete_tgt(struct ath_softc_tgt *sc, a_uint8_t vap_index)
{
	a_int32_t i;

	for (i = 0; i < TARGET_NODE_MAX; i++) {
		if(sc->sc_sta[i].ni.ni_vapindex == vap_index)
  908edd:	238000        	l8ui	a3, a8, 0
  908ee0:	7d3904        	bne	a3, a13, 908ee8 <ath_vap_delete_tgt+0x44>
			sc->sc_sta[i].an_valid = 0;
  908ee3:	af83      	add.n	a3, a8, a15
  908ee5:	293400        	s8i	a9, a3, 0
  908ee8:	ae88      	add.n	a8, a8, a14
	vap_index = *(a_uint8_t *)data;

	sc->sc_vap[vap_index].av_valid = 0;
	sc->sc_vap[vap_index].av_bcbuf = NULL;
	ath_node_vdelete_tgt(sc, vap_index);
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  908eea:	c0e0      	movi.n	a14, 0
  908eec:	8a23      	l32i.n	a10, a2, 12
  908eee:	0eed02        	or	a13, a14, a14
  908ef1:	5bfea5        	call8	908988 <wmi_cmd_rsp>
  908ef4:	d10f      	retw.n
	...

00908ef8 <ath_node_cleanup_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_node_cleanup_tgt(void *Context, A_UINT16 Command,
				 A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  908ef8:	6c1004        	entry	a1, 32
	a_uint8_t node_index;
	a_uint8_t *nodedata;

	nodedata = (a_uint8_t *)data;
	node_index = *nodedata;
	sc->sc_sta[node_index].an_valid = 0;
  908efb:	295000        	l8ui	a9, a5, 0

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  908efe:	c0e0      	movi.n	a14, 0
	a_uint8_t node_index;
	a_uint8_t *nodedata;

	nodedata = (a_uint8_t *)data;
	node_index = *nodedata;
	sc->sc_sta[node_index].an_valid = 0;
  908f00:	0a9811        	slli	a8, a9, 6
  908f03:	a988      	add.n	a8, a8, a9
  908f05:	0f8811        	slli	a8, a8, 1
  908f08:	a988      	add.n	a8, a8, a9
  908f0a:	0e8811        	slli	a8, a8, 2
  908f0d:	a828      	add.n	a8, a2, a8
  908f0f:	297a3c        	movi	a9, 0x73c
  908f12:	a988      	add.n	a8, a8, a9
  908f14:	c090      	movi.n	a9, 0
  908f16:	298400        	s8i	a9, a8, 0

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  908f19:	8a23      	l32i.n	a10, a2, 12
  908f1b:	dde0      	mov.n	a13, a14
  908f1d:	040c4f        	extui	a12, a4, 0, 16
  908f20:	030b4f        	extui	a11, a3, 0, 16
  908f23:	5bfe99        	call8	908988 <wmi_cmd_rsp>
  908f26:	d10f      	retw.n

00908f28 <ath_node_create_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_node_create_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  908f28:	6c1006        	entry	a1, 48
  908f2b:	db50      	mov.n	a11, a5
	a_uint8_t vap_index;
	a_uint8_t node_index;

	node = (struct ieee80211_node_target *)data;

	node_index = node->ni_nodeindex;
  908f2d:	25500c        	l8ui	a5, a5, 12

	node->ni_htcap = adf_os_ntohs(node->ni_htcap);
	node->ni_flags = adf_os_ntohs(node->ni_flags);
	node->ni_maxampdu = adf_os_ntohs(node->ni_maxampdu);

	adf_os_mem_copy(&(sc->sc_sta[node_index].ni), node,
  908f30:	275a38        	movi	a7, 0x538
  908f33:	0a5611        	slli	a6, a5, 6
  908f36:	a569      	add.n	a9, a6, a5
  908f38:	0f9911        	slli	a9, a9, 1
  908f3b:	a599      	add.n	a9, a9, a5
  908f3d:	0e9911        	slli	a9, a9, 2
  908f40:	a797      	add.n	a7, a9, a7
  908f42:	a727      	add.n	a7, a2, a7
  908f44:	c1c6      	movi.n	a12, 22
  908f46:	da70      	mov.n	a10, a7
  908f48:	9910      	s32i.n	a9, a1, 0
  908f4a:	5bfaf1        	call8	907b10 <__adf_os_mem_copy>
			NODE_TARGET_SIZE);

    	vap_index = sc->sc_sta[node_index].ni.ni_vapindex;
  908f4d:	8910      	l32i.n	a9, a1, 0
  908f4f:	285a45        	movi	a8, 0x545
  908f52:	a929      	add.n	a9, a2, a9
  908f54:	a898      	add.n	a8, a9, a8
  908f56:	2a8000        	l8ui	a10, a8, 0
	sc->sc_sta[node_index].ni.ni_vap = &(sc->sc_vap[vap_index].av_vap);
  908f59:	1c69bf        	l32r	a12, 8e3658 <_HIFusb_start+0x1b8>
  908f5c:	0ca811        	slli	a8, a10, 4
  908f5f:	aa88      	add.n	a8, a8, a10
  908f61:	0e8811        	slli	a8, a8, 2
  908f64:	2b5a58        	movi	a11, 0x558
  908f67:	ac88      	add.n	a8, a8, a12
  908f69:	ab9b      	add.n	a11, a9, a11
  908f6b:	a828      	add.n	a8, a2, a8
  908f6d:	98b0      	s32i.n	a8, a11, 0
	if(sc->sc_sta[node_index].ni.ni_is_vapnode == 1)
  908f6f:	285a46        	movi	a8, 0x546
  908f72:	a899      	add.n	a9, a9, a8
  908f74:	289000        	l8ui	a8, a9, 0
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_node_create_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  908f77:	03034f        	extui	a3, a3, 0, 16
  908f7a:	04044f        	extui	a4, a4, 0, 16
	adf_os_mem_copy(&(sc->sc_sta[node_index].ni), node,
			NODE_TARGET_SIZE);

    	vap_index = sc->sc_sta[node_index].ni.ni_vapindex;
	sc->sc_sta[node_index].ni.ni_vap = &(sc->sc_vap[vap_index].av_vap);
	if(sc->sc_sta[node_index].ni.ni_is_vapnode == 1)
  908f7d:	698111        	bnei	a8, 1, 908f92 <ath_node_create_tgt+0x6a>
		sc->sc_vap[vap_index].av_vap.iv_nodeindex = node_index;
  908f80:	0ca911        	slli	a9, a10, 4
  908f83:	aa99      	add.n	a9, a9, a10
  908f85:	0e9911        	slli	a9, a9, 2
  908f88:	1869c6        	l32r	a8, 8e36a0 <_HIFusb_start+0x200>
  908f8b:	a929      	add.n	a9, a2, a9
  908f8d:	a899      	add.n	a9, a9, a8
  908f8f:	259400        	s8i	a5, a9, 0

	sc->sc_sta[node_index].an_valid = 1;
  908f92:	a568      	add.n	a8, a6, a5
  908f94:	0f8811        	slli	a8, a8, 1
  908f97:	a588      	add.n	a8, a8, a5
  908f99:	0e8811        	slli	a8, a8, 2
  908f9c:	a828      	add.n	a8, a2, a8
  908f9e:	257a3c        	movi	a5, 0x73c
  908fa1:	a585      	add.n	a5, a8, a5
  908fa3:	c061      	movi.n	a6, 1
  908fa5:	265400        	s8i	a6, a5, 0
	sc->sc_sta[node_index].ni.ni_txseqmgmt = 0;
  908fa8:	255a50        	movi	a5, 0x550
  908fab:	a585      	add.n	a5, a8, a5
  908fad:	c060      	movi.n	a6, 0
  908faf:	265500        	s16i	a6, a5, 0
	sc->sc_sta[node_index].ni.ni_iv16 = 0;
  908fb2:	255a52        	movi	a5, 0x552
  908fb5:	a585      	add.n	a5, a8, a5
  908fb7:	265500        	s16i	a6, a5, 0
	sc->sc_sta[node_index].ni.ni_iv32 = 0;
  908fba:	255a54        	movi	a5, 0x554
  908fbd:	a588      	add.n	a8, a8, a5
  908fbf:	c050      	movi.n	a5, 0

	owl_tgt_node_init(&sc->sc_sta[node_index]);
  908fc1:	da70      	mov.n	a10, a7
		sc->sc_vap[vap_index].av_vap.iv_nodeindex = node_index;

	sc->sc_sta[node_index].an_valid = 1;
	sc->sc_sta[node_index].ni.ni_txseqmgmt = 0;
	sc->sc_sta[node_index].ni.ni_iv16 = 0;
	sc->sc_sta[node_index].ni.ni_iv32 = 0;
  908fc3:	9580      	s32i.n	a5, a8, 0

	owl_tgt_node_init(&sc->sc_sta[node_index]);
  908fc5:	5811de        	call8	90d740 <owl_tgt_node_init>

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  908fc8:	8a23      	l32i.n	a10, a2, 12
  908fca:	de50      	mov.n	a14, a5
  908fcc:	dd50      	mov.n	a13, a5
  908fce:	dc40      	mov.n	a12, a4
  908fd0:	db30      	mov.n	a11, a3
  908fd2:	5bfe6d        	call8	908988 <wmi_cmd_rsp>
  908fd5:	d10f      	retw.n
	...

00908fd8 <ath_setcurmode_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_setcurmode_tgt(void *Context, A_UINT16 Command,
			       A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  908fd8:	6c1004        	entry	a1, 32
 * @param[in] size  buffer size
 */
static inline void
adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
{
    __adf_os_mem_set(buf, b, size);
  908fdb:	2a2a08        	movi	a10, 0x208
	a_uint16_t mode;

	mode= *((a_uint16_t *)data);
	mode = adf_os_ntohs(mode);

	ath_setcurmode(sc, mode);
  908fde:	255100        	l16ui	a5, a5, 0
  908fe1:	2c1a00        	movi	a12, 0x100
  908fe4:	2b0aff        	movi	a11, 255
  908fe7:	aa2a      	add.n	a10, a2, a10
  908fe9:	5bface        	call8	907b24 <__adf_os_mem_set>
	const HAL_RATE_TABLE *rt;
	a_int32_t i;

	adf_os_mem_set(sc->sc_rixmap, 0xff, sizeof(sc->sc_rixmap));

	rt = sc->sc_rates[mode];
  908fec:	285c7c        	addi	a8, a5, 124
  908fef:	0e8811        	slli	a8, a8, 2
  908ff2:	a828      	add.n	a8, a2, a8
  908ff4:	8683      	l32i.n	a6, a8, 12
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_setcurmode_tgt(void *Context, A_UINT16 Command,
			       A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  908ff6:	03034f        	extui	a3, a3, 0, 16
  908ff9:	04044f        	extui	a4, a4, 0, 16
	a_int32_t i;

	adf_os_mem_set(sc->sc_rixmap, 0xff, sizeof(sc->sc_rixmap));

	rt = sc->sc_rates[mode];
	adf_os_assert(rt != NULL);
  908ffc:	cd65      	bnez.n	a6, 909015 <ath_setcurmode_tgt+0x3d>
  908ffe:	1868bf        	l32r	a8, 8e32fc <athos_indirection_table_install+0x1d88>
  909001:	1b69c7        	l32r	a11, 8e3720 <_HIFusb_isr_handler+0x3c>
  909004:	288212        	l32i	a8, a8, 72
  909007:	1a69a0        	l32r	a10, 8e3688 <_HIFusb_start+0x1e8>
  90900a:	0b8000        	callx8	a8
  90900d:	186923        	l32r	a8, 8e349c <athos_indirection_table_install+0x1f28>
  909010:	0c0200        	memw
  909013:	8880      	l32i.n	a8, a8, 0

	for (i = 0; i < rt->rateCount; i++) {
  909015:	8b60      	l32i.n	a11, a6, 0
  909017:	2a6c34        	addi	a10, a6, 52
  90901a:	c090      	movi.n	a9, 0
		sc->sc_rixmap[rt->info[i].rateCode] = i;
  90901c:	2c2a08        	movi	a12, 0x208
  90901f:	60000e        	j	909031 <ath_setcurmode_tgt+0x59>
  909022:	28a000        	l8ui	a8, a10, 0
  909025:	2aac14        	addi	a10, a10, 20
  909028:	a828      	add.n	a8, a2, a8
  90902a:	ac88      	add.n	a8, a8, a12
  90902c:	298400        	s8i	a9, a8, 0
	adf_os_mem_set(sc->sc_rixmap, 0xff, sizeof(sc->sc_rixmap));

	rt = sc->sc_rates[mode];
	adf_os_assert(rt != NULL);

	for (i = 0; i < rt->rateCount; i++) {
  90902f:	b199      	addi.n	a9, a9, 1
  909031:	7b92ed        	blt	a9, a11, 909022 <ath_setcurmode_tgt+0x4a>
		sc->sc_rixmap[rt->info[i].rateCode] = i;
	}

	sc->sc_currates = rt;
  909034:	262681        	s32i	a6, a2, 0x204
	sc->sc_curmode = mode;
  909037:	2526c2        	s32i	a5, a2, 0x308
	sc->sc_protrix = ((mode == IEEE80211_MODE_11NG) ? 3 : 0);
  90903a:	c0d0      	movi.n	a13, 0
  90903c:	b055      	addi.n	a5, a5, -1
  90903e:	c063      	movi.n	a6, 3
  909040:	05d639        	movnez	a6, a13, a5
  909043:	d560      	mov.n	a5, a6
  909045:	262d03        	addmi	a6, a2, 0x300
  909048:	25640c        	s8i	a5, a6, 12
	mode= *((a_uint16_t *)data);
	mode = adf_os_ntohs(mode);

	ath_setcurmode(sc, mode);

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  90904b:	8a23      	l32i.n	a10, a2, 12
  90904d:	ded0      	mov.n	a14, a13
  90904f:	dc40      	mov.n	a12, a4
  909051:	db30      	mov.n	a11, a3
  909053:	5bfe4d        	call8	908988 <wmi_cmd_rsp>
  909056:	d10f      	retw.n

00909058 <ath_flushrecv_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo,NULL, 0);
}

static void ath_flushrecv_tgt(void *Context, A_UINT16 Command,
			      A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  909058:	6c1004        	entry	a1, 32
  90905b:	03034f        	extui	a3, a3, 0, 16
  90905e:	04044f        	extui	a4, a4, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_rx_buf *bf;

	asf_tailq_foreach(bf, &sc->sc_rxbuf, bf_list)
  909061:	2522d5        	l32i	a5, a2, 0x354
  909064:	60002e        	j	909096 <ath_flushrecv_tgt+0x3e>
  909067:	000000        	ill
		if (bf->bf_skb != NULL) {
  90906a:	8658      	l32i.n	a6, a5, 32
  90906c:	ca64      	beqz.n	a6, 909094 <ath_flushrecv_tgt+0x3c>
static inline void
adf_nbuf_unmap(adf_os_device_t      osdev, 
               adf_os_dma_map_t     bmap, 
               adf_os_dma_dir_t     dir)
{
    __adf_nbuf_unmap(osdev, bmap, dir);
  90906e:	8b50      	l32i.n	a11, a5, 0
  909070:	2a2246        	l32i	a10, a2, 0x118
  909073:	c0c1      	movi.n	a12, 1
  909075:	5bf681        	call8	906a7c <__adf_nbuf_unmap>
			adf_nbuf_unmap(sc->sc_dev, bf->bf_dmamap,
				       ADF_OS_DMA_FROM_DEVICE);
			ath_free_rx_skb(sc, adf_nbuf_queue_remove(&bf->bf_skbhead));
  909078:	1868bf        	l32r	a8, 8e3374 <athos_indirection_table_install+0x1e00>
  90907b:	8720      	l32i.n	a7, a2, 0
 * @return The head buf in the buf queue.
 */
static inline adf_nbuf_t
adf_nbuf_queue_remove(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_remove(head);
  90907d:	2a5c14        	addi	a10, a5, 20
  909080:	26829e        	l32i	a6, a8, 0x278
  909083:	5bf66a        	call8	906a2c <__adf_nbuf_queue_remove>
  909086:	dca0      	mov.n	a12, a10
  909088:	2b0a03        	movi	a11, 3
  90908b:	da70      	mov.n	a10, a7
  90908d:	0b6000        	callx8	a6
			bf->bf_skb = NULL;
  909090:	c080      	movi.n	a8, 0
  909092:	9858      	s32i.n	a8, a5, 32
			      A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_rx_buf *bf;

	asf_tailq_foreach(bf, &sc->sc_rxbuf, bf_list)
  909094:	8559      	l32i.n	a5, a5, 36
  909096:	655fd0        	bnez	a5, 90906a <ath_flushrecv_tgt+0x12>
				       ADF_OS_DMA_FROM_DEVICE);
			ath_free_rx_skb(sc, adf_nbuf_queue_remove(&bf->bf_skbhead));
			bf->bf_skb = NULL;
		}

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  909099:	8a23      	l32i.n	a10, a2, 12
  90909b:	de50      	mov.n	a14, a5
  90909d:	dd50      	mov.n	a13, a5
  90909f:	dc40      	mov.n	a12, a4
  9090a1:	db30      	mov.n	a11, a3
  9090a3:	5bfe39        	call8	908988 <wmi_cmd_rsp>
  9090a6:	d10f      	retw.n

009090a8 <ath_stoprecv_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_stoprecv_tgt(void *Context, A_UINT16 Command,
			     A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  9090a8:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  9090ab:	252d05        	addmi	a5, a2, 0x500
  9090ae:	855b      	l32i.n	a5, a5, 44
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_stoprecv_tgt(void *Context, A_UINT16 Command,
			     A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  9090b0:	03034f        	extui	a3, a3, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;

	ah->ah_stopPcuReceive(ah);
  9090b3:	285224        	l32i	a8, a5, 144
  9090b6:	055a02        	or	a10, a5, a5
  9090b9:	0b8000        	callx8	a8
	ah->ah_setRxFilter(ah, 0);
  9090bc:	8859      	l32i.n	a8, a5, 36
  9090be:	c0b0      	movi.n	a11, 0
  9090c0:	da50      	mov.n	a10, a5
  9090c2:	0b8000        	callx8	a8
	ah->ah_stopDmaReceive(ah);
  9090c5:	285223        	l32i	a8, a5, 140
  9090c8:	da50      	mov.n	a10, a5
  9090ca:	0b8000        	callx8	a8

	sc->sc_rxlink = NULL;
  9090cd:	c0d0      	movi.n	a13, 0
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_stoprecv_tgt(void *Context, A_UINT16 Command,
			     A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  9090cf:	04044f        	extui	a4, a4, 0, 16
	ah->ah_stopPcuReceive(ah);
	ah->ah_setRxFilter(ah, 0);
	ah->ah_stopDmaReceive(ah);

	sc->sc_rxlink = NULL;
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  9090d2:	8a23      	l32i.n	a10, a2, 12

	ah->ah_stopPcuReceive(ah);
	ah->ah_setRxFilter(ah, 0);
	ah->ah_stopDmaReceive(ah);

	sc->sc_rxlink = NULL;
  9090d4:	2d26ef        	s32i	a13, a2, 0x3bc
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  9090d7:	ded0      	mov.n	a14, a13
  9090d9:	dc40      	mov.n	a12, a4
  9090db:	db30      	mov.n	a11, a3
  9090dd:	5bfe2a        	call8	908988 <wmi_cmd_rsp>
  9090e0:	d10f      	retw.n
	...

009090e4 <ath_startrecv_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_startrecv_tgt(void *Context, A_UINT16 Command,
			      A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  9090e4:	6c1004        	entry	a1, 32
#undef PA2DESC
}

static a_int32_t ath_startrecv(struct ath_softc_tgt *sc)
{
	struct ath_hal *ah = sc->sc_ah;
  9090e7:	252d05        	addmi	a5, a2, 0x500
  9090ea:	865b      	l32i.n	a6, a5, 44
	struct ath_rx_desc *ds;

	sc->sc_rxbufsize = 1024+512+128;
  9090ec:	256a80        	movi	a5, 0x680
  9090ef:	25264a        	s32i	a5, a2, 0x128
	sc->sc_rxlink = NULL;
  9090f2:	c050      	movi.n	a5, 0
  9090f4:	2526ef        	s32i	a5, a2, 0x3bc

	sc->sc_rxdesc_held = NULL;
  9090f7:	2526db        	s32i	a5, a2, 0x36c
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_startrecv_tgt(void *Context, A_UINT16 Command,
			      A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  9090fa:	03034f        	extui	a3, a3, 0, 16
  9090fd:	04044f        	extui	a4, a4, 0, 16
	sc->sc_rxbufsize = 1024+512+128;
	sc->sc_rxlink = NULL;

	sc->sc_rxdesc_held = NULL;

	asf_tailq_foreach(ds, &sc->sc_rxdesc, ds_list) {
  909100:	2522d9        	l32i	a5, a2, 0x364
  909103:	600027        	j	90912e <ath_startrecv_tgt+0x4a>
		a_int32_t error = ath_rxdesc_init(sc, ds);
  909106:	db50      	mov.n	a11, a5
  909108:	da20      	mov.n	a10, a2
  90910a:	5bfb03        	call8	907d18 <ath_rxdesc_init>
		if (error != 0) {
  90910d:	65a049        	bnez	a10, 90915a <ath_startrecv_tgt+0x76>
	sc->sc_rxbufsize = 1024+512+128;
	sc->sc_rxlink = NULL;

	sc->sc_rxdesc_held = NULL;

	asf_tailq_foreach(ds, &sc->sc_rxdesc, ds_list) {
  909110:	29504c        	l8ui	a9, a5, 76
  909113:	28504d        	l8ui	a8, a5, 77
  909116:	089910        	slli	a9, a9, 24
  909119:	008811        	slli	a8, a8, 16
  90911c:	098902        	or	a9, a8, a9
  90911f:	28504e        	l8ui	a8, a5, 78
  909122:	25504f        	l8ui	a5, a5, 79
  909125:	088811        	slli	a8, a8, 8
  909128:	098802        	or	a8, a8, a9
  90912b:	085502        	or	a5, a5, a8
  90912e:	655fd4        	bnez	a5, 909106 <ath_startrecv_tgt+0x22>
			return error;
		}
	}

	ds = asf_tailq_first(&sc->sc_rxdesc);
	ah->ah_setRxDP(ah, ds->ds_daddr);
  909131:	2822d9        	l32i	a8, a2, 0x364
  909134:	da60      	mov.n	a10, a6
  909136:	258048        	l8ui	a5, a8, 72
  909139:	2b8049        	l8ui	a11, a8, 73
  90913c:	085510        	slli	a5, a5, 24
  90913f:	00bb11        	slli	a11, a11, 16
  909142:	05bb02        	or	a11, a11, a5
  909145:	25804a        	l8ui	a5, a8, 74
  909148:	085511        	slli	a5, a5, 8
  90914b:	0b5502        	or	a5, a5, a11
  90914e:	2b804b        	l8ui	a11, a8, 75
  909151:	28621f        	l32i	a8, a6, 124
  909154:	05bb02        	or	a11, a11, a5
  909157:	0b8000        	callx8	a8
{

	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;

	ath_startrecv(sc);
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  90915a:	c0e0      	movi.n	a14, 0
  90915c:	8a23      	l32i.n	a10, a2, 12
  90915e:	dde0      	mov.n	a13, a14
  909160:	dc40      	mov.n	a12, a4
  909162:	033b02        	or	a11, a3, a3
  909165:	5bfe08        	call8	908988 <wmi_cmd_rsp>
  909168:	d10f      	retw.n
	...

0090916c <ath_draintxq_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_draintxq_tgt(void *Context, A_UINT16 Command,
			     A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  90916c:	6c1006        	entry	a1, 48
  90916f:	04044f        	extui	a4, a4, 0, 16
	a_uint16_t i;
	struct ath_txq *txq = NULL;
	struct ath_atx_tid *tid = NULL;

	ath_tx_status_clear(sc);
	sc->sc_tx_draining = 1;
  909172:	252d01        	addmi	a5, a2, 0x100
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_draintxq_tgt(void *Context, A_UINT16 Command,
			     A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  909175:	03034f        	extui	a3, a3, 0, 16
  909178:	9411      	s32i.n	a4, a1, 4
	struct ath_hal *ah = sc->sc_ah;
	a_uint16_t i;
	struct ath_txq *txq = NULL;
	struct ath_atx_tid *tid = NULL;

	ath_tx_status_clear(sc);
  90917a:	022a02        	or	a10, a2, a2
	owltgt_txq_drain(sc, txq);
}

static void ath_draintxq(struct ath_softc_tgt *sc, HAL_BOOL drain_softq)
{
	struct ath_hal *ah = sc->sc_ah;
  90917d:	242d05        	addmi	a4, a2, 0x500
  909180:	27420b        	l32i	a7, a4, 44
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_draintxq_tgt(void *Context, A_UINT16 Command,
			     A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  909183:	9310      	s32i.n	a3, a1, 0
	struct ath_hal *ah = sc->sc_ah;
	a_uint16_t i;
	struct ath_txq *txq = NULL;
	struct ath_atx_tid *tid = NULL;

	ath_tx_status_clear(sc);
  909185:	58117f        	call8	90d784 <ath_tx_status_clear>
	sc->sc_tx_draining = 1;
  909188:	265024        	l8ui	a6, a5, 36
  90918b:	c480      	movi.n	a8, 64
  90918d:	086602        	or	a6, a6, a8
  909190:	265424        	s8i	a6, a5, 36

	ah->ah_stopTxDma(ah, sc->sc_bhalq);
  909193:	867d      	l32i.n	a6, a7, 52
  909195:	2b501c        	l8ui	a11, a5, 28
  909198:	da70      	mov.n	a10, a7
  90919a:	0b6000        	callx8	a6
  90919d:	283acc        	movi	a8, 0x3cc
  9091a0:	a823      	add.n	a3, a2, a8
  9091a2:	d930      	mov.n	a9, a3
  9091a4:	c070      	movi.n	a7, 0

	for (i = 0; i < HAL_NUM_TX_QUEUES; i++)
		if (ATH_TXQ_SETUP(sc, i))
  9091a6:	262d03        	addmi	a6, a2, 0x300
  9091a9:	2a60c8        	l8ui	a10, a6, 200
  9091ac:	007004        	ssr	a7
  9091af:	0a0a1b        	sra	a10, a10
  9091b2:	7fa70c        	bbci	a10, 31, 9091c2 <ath_draintxq_tgt+0x56>
  9091b5:	8a4b      	l32i.n	a10, a4, 44

static void ath_tx_stopdma(struct ath_softc_tgt *sc, struct ath_txq *txq)
{
	struct ath_hal *ah = sc->sc_ah;

	ah->ah_stopTxDma(ah, txq->axq_qnum);
  9091b7:	8b90      	l32i.n	a11, a9, 0
  9091b9:	8dad      	l32i.n	a13, a10, 52
  9091bb:	9912      	s32i.n	a9, a1, 8
  9091bd:	0bd000        	callx8	a13
  9091c0:	8912      	l32i.n	a9, a1, 8
  9091c2:	b177      	addi.n	a7, a7, 1
  9091c4:	299c20        	addi	a9, a9, 32
	ath_tx_status_clear(sc);
	sc->sc_tx_draining = 1;

	ah->ah_stopTxDma(ah, sc->sc_bhalq);

	for (i = 0; i < HAL_NUM_TX_QUEUES; i++)
  9091c7:	6979de        	bnei	a7, 10, 9091a9 <ath_draintxq_tgt+0x3d>
  9091ca:	270a00        	movi	a7, 0
			txq = ATH_TXQ(sc,i);
			while (!asf_tailq_empty(&txq->axq_tidq)){
				TAILQ_DEQ(&txq->axq_tidq, tid, tid_qelem);
				if(tid == NULL)
					break;
				tid->sched = AH_FALSE;
  9091cd:	077402        	or	a4, a7, a7
	for (i = 0; i < HAL_NUM_TX_QUEUES; i++)
		if (ATH_TXQ_SETUP(sc, i))
			ath_tx_stopdma(sc, ATH_TXQ(sc, i));

	for (i = 0; i < HAL_NUM_TX_QUEUES; i++)
		if (ATH_TXQ_SETUP(sc, i)) {
  9091d0:	2a60c8        	l8ui	a10, a6, 200
  9091d3:	007004        	ssr	a7
  9091d6:	0a0a1b        	sra	a10, a10
  9091d9:	7faf0b        	bbsi	a10, 31, 9091e8 <ath_draintxq_tgt+0x7c>
  9091dc:	b177      	addi.n	a7, a7, 1
  9091de:	233c20        	addi	a3, a3, 32

	for (i = 0; i < HAL_NUM_TX_QUEUES; i++)
		if (ATH_TXQ_SETUP(sc, i))
			ath_tx_stopdma(sc, ATH_TXQ(sc, i));

	for (i = 0; i < HAL_NUM_TX_QUEUES; i++)
  9091e1:	6979eb        	bnei	a7, 10, 9091d0 <ath_draintxq_tgt+0x64>
  9091e4:	60002e        	j	909216 <ath_draintxq_tgt+0xaa>
  9091e7:	00c0c1        	excw
		if (ATH_TXQ_SETUP(sc, i)) {
			owltgt_tx_processq(sc, ATH_TXQ(sc,i), OWL_TXQ_STOPPED);
  9091ea:	db30      	mov.n	a11, a3
  9091ec:	da20      	mov.n	a10, a2
  9091ee:	5815b0        	call8	90e8b0 <owltgt_tx_processq>
  9091f1:	600019        	j	90920e <ath_draintxq_tgt+0xa2>

			txq = ATH_TXQ(sc,i);
			while (!asf_tailq_empty(&txq->axq_tidq)){
				TAILQ_DEQ(&txq->axq_tidq, tid, tid_qelem);
  9091f4:	8ab9      	l32i.n	a10, a11, 36
  9091f6:	8cba      	l32i.n	a12, a11, 40
  9091f8:	c8a4      	beqz.n	a10, 909200 <ath_draintxq_tgt+0x94>
  9091fa:	9caa      	s32i.n	a12, a10, 40
  9091fc:	600002        	j	909202 <ath_draintxq_tgt+0x96>
  9091ff:	009c37        	maxu	a12, a9, a0
  909202:	8cba      	l32i.n	a12, a11, 40
  909204:	9ac0      	s32i.n	a10, a12, 0
				if(tid == NULL)
					break;
				tid->sched = AH_FALSE;
  909206:	24b435        	s8i	a4, a11, 53
				ath_tgt_tid_drain(sc,tid);
  909209:	da20      	mov.n	a10, a2
  90920b:	581245        	call8	90db20 <ath_tgt_tid_drain>
	for (i = 0; i < HAL_NUM_TX_QUEUES; i++)
		if (ATH_TXQ_SETUP(sc, i)) {
			owltgt_tx_processq(sc, ATH_TXQ(sc,i), OWL_TXQ_STOPPED);

			txq = ATH_TXQ(sc,i);
			while (!asf_tailq_empty(&txq->axq_tidq)){
  90920e:	8b36      	l32i.n	a11, a3, 24
  909210:	65bfe0        	bnez	a11, 9091f4 <ath_draintxq_tgt+0x88>
  909213:	63ffc5        	j	9091dc <ath_draintxq_tgt+0x70>
				tid->sched = AH_FALSE;
				ath_tgt_tid_drain(sc,tid);
			}
		}

	sc->sc_tx_draining = 0;
  909216:	265024        	l8ui	a6, a5, 36
  909219:	27fabf        	movi	a7, -65
  90921c:	076601        	and	a6, a6, a7
  90921f:	265424        	s8i	a6, a5, 36
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	HAL_BOOL b = (HAL_BOOL) *(a_int32_t *)data;

	ath_draintxq(Context, b);
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  909222:	c0e0      	movi.n	a14, 0
  909224:	8c11      	l32i.n	a12, a1, 4
  909226:	8b10      	l32i.n	a11, a1, 0
  909228:	8a23      	l32i.n	a10, a2, 12
  90922a:	0eed02        	or	a13, a14, a14
  90922d:	5bfdd6        	call8	908988 <wmi_cmd_rsp>
  909230:	d10f      	retw.n
	...

00909234 <ath_tx_draintxq_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_tx_draintxq_tgt(void *Context, A_UINT16 Command, A_UINT16 SeqNo,
				A_UINT8 *data, a_int32_t datalen)
{
  909234:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	a_uint32_t q = *(a_uint32_t *)data;
	struct ath_txq *txq = NULL;

	q = adf_os_ntohl(q);
	txq = ATH_TXQ(sc, q);
  909237:	8b50      	l32i.n	a11, a5, 0
	ah->ah_stopTxDma(ah, txq->axq_qnum);
}

static void owltgt_txq_drain(struct ath_softc_tgt *sc, struct ath_txq *txq)
{
	owltgt_tx_processq(sc, txq, OWL_TXQ_STOPPED);
  909239:	da20      	mov.n	a10, a2
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	a_uint32_t q = *(a_uint32_t *)data;
	struct ath_txq *txq = NULL;

	q = adf_os_ntohl(q);
	txq = ATH_TXQ(sc, q);
  90923b:	2bbc1e        	addi	a11, a11, 30
  90923e:	0bbb11        	slli	a11, a11, 5
  909241:	bcbb      	addi.n	a11, a11, 12
	ah->ah_stopTxDma(ah, txq->axq_qnum);
}

static void owltgt_txq_drain(struct ath_softc_tgt *sc, struct ath_txq *txq)
{
	owltgt_tx_processq(sc, txq, OWL_TXQ_STOPPED);
  909243:	0b2b08        	add	a11, a2, a11
  909246:	2c0a01        	movi	a12, 1
  909249:	581599        	call8	90e8b0 <owltgt_tx_processq>
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_tx_draintxq_tgt(void *Context, A_UINT16 Command, A_UINT16 SeqNo,
				A_UINT8 *data, a_int32_t datalen)
{
  90924c:	03034f        	extui	a3, a3, 0, 16
  90924f:	04044f        	extui	a4, a4, 0, 16

	q = adf_os_ntohl(q);
	txq = ATH_TXQ(sc, q);

	ath_tx_draintxq(sc, txq);
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  909252:	c0e0      	movi.n	a14, 0
  909254:	8a23      	l32i.n	a10, a2, 12
  909256:	dde0      	mov.n	a13, a14
  909258:	dc40      	mov.n	a12, a4
  90925a:	033b02        	or	a11, a3, a3
  90925d:	5bfdca        	call8	908988 <wmi_cmd_rsp>
  909260:	d10f      	retw.n
	...

00909264 <ath_aborttx_dma_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_aborttx_dma_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  909264:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  909267:	282d05        	addmi	a8, a2, 0x500
  90926a:	8a8b      	l32i.n	a10, a8, 44
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_aborttx_dma_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  90926c:	03034f        	extui	a3, a3, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;

	ah->ah_abortTxDma(sc->sc_ah);
  90926f:	28a20e        	l32i	a8, a10, 56
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_aborttx_dma_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  909272:	04044f        	extui	a4, a4, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;

	ah->ah_abortTxDma(sc->sc_ah);
  909275:	0b8000        	callx8	a8
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  909278:	c0e0      	movi.n	a14, 0
  90927a:	8a23      	l32i.n	a10, a2, 12
  90927c:	dde0      	mov.n	a13, a14
  90927e:	dc40      	mov.n	a12, a4
  909280:	db30      	mov.n	a11, a3
  909282:	5bfdc1        	call8	908988 <wmi_cmd_rsp>
  909285:	d10f      	retw.n
	...

00909288 <ath_stop_tx_dma_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_stop_tx_dma_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  909288:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  90928b:	282d05        	addmi	a8, a2, 0x500
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_stop_tx_dma_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  90928e:	03034f        	extui	a3, a3, 0, 16
  909291:	04044f        	extui	a4, a4, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  909294:	8a8b      	l32i.n	a10, a8, 44
	a_uint32_t q;

	if (data)
  909296:	c850      	beqz.n	a5, 90929a <ath_stop_tx_dma_tgt+0x12>
		q = *(a_uint32_t *)data;
  909298:	8b50      	l32i.n	a11, a5, 0

	q = adf_os_ntohl(q);
	ah->ah_stopTxDma(ah, q);
  90929a:	85ad      	l32i.n	a5, a10, 52
  90929c:	0b5000        	callx8	a5
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  90929f:	c0e0      	movi.n	a14, 0
  9092a1:	8a23      	l32i.n	a10, a2, 12
  9092a3:	dde0      	mov.n	a13, a14
  9092a5:	dc40      	mov.n	a12, a4
  9092a7:	db30      	mov.n	a11, a3
  9092a9:	5bfdb7        	call8	908988 <wmi_cmd_rsp>
  9092ac:	d10f      	retw.n
	...

009092b0 <ath_aborttxq_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_aborttxq_tgt(void *Context, A_UINT16 Command,
			     A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  9092b0:	6c1004        	entry	a1, 32
  9092b3:	253acc        	movi	a5, 0x3cc
  9092b6:	03034f        	extui	a3, a3, 0, 16
  9092b9:	04044f        	extui	a4, a4, 0, 16
  9092bc:	a525      	add.n	a5, a2, a5
  9092be:	260a00        	movi	a6, 0

	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	a_uint16_t i;

	for (i = 0; i < HAL_NUM_TX_QUEUES; i++) {
		if (ATH_TXQ_SETUP(sc, i))
  9092c1:	272d03        	addmi	a7, a2, 0x300
  9092c4:	2870c8        	l8ui	a8, a7, 200
  9092c7:	006004        	ssr	a6
  9092ca:	08081b        	sra	a8, a8
  9092cd:	7f8708        	bbci	a8, 31, 9092d9 <ath_aborttxq_tgt+0x29>
	ah->ah_stopTxDma(ah, txq->axq_qnum);
}

static void owltgt_txq_drain(struct ath_softc_tgt *sc, struct ath_txq *txq)
{
	owltgt_tx_processq(sc, txq, OWL_TXQ_STOPPED);
  9092d0:	c0c1      	movi.n	a12, 1
  9092d2:	db50      	mov.n	a11, a5
  9092d4:	da20      	mov.n	a10, a2
  9092d6:	581576        	call8	90e8b0 <owltgt_tx_processq>
  9092d9:	b166      	addi.n	a6, a6, 1
  9092db:	255c20        	addi	a5, a5, 32
{

	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	a_uint16_t i;

	for (i = 0; i < HAL_NUM_TX_QUEUES; i++) {
  9092de:	6969e2        	bnei	a6, 10, 9092c4 <ath_aborttxq_tgt+0x14>
		if (ATH_TXQ_SETUP(sc, i))
			ath_tx_draintxq(sc, ATH_TXQ(sc,i));
	}

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  9092e1:	c0e0      	movi.n	a14, 0
  9092e3:	8a23      	l32i.n	a10, a2, 12
  9092e5:	dde0      	mov.n	a13, a14
  9092e7:	dc40      	mov.n	a12, a4
  9092e9:	db30      	mov.n	a11, a3
  9092eb:	5bfda7        	call8	908988 <wmi_cmd_rsp>
  9092ee:	d10f      	retw.n

009092f0 <ath_init_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo,NULL, 0);
}

static void ath_init_tgt(void *Context, A_UINT16 Command,
			 A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  9092f0:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  9092f3:	252d05        	addmi	a5, a2, 0x500
  9092f6:	855b      	l32i.n	a5, a5, 44

	sc->sc_imask = HAL_INT_RX | HAL_INT_TX
		| HAL_INT_RXEOL | HAL_INT_RXORN
		| HAL_INT_FATAL | HAL_INT_GLOBAL;

	sc->sc_imask |= HAL_INT_GTT;
  9092f8:	1869c8        	l32r	a8, 8e3a18 <HIFusb_DescTraceDump+0x230>

	if (ath_hal_getcapability(ah, HAL_CAP_HT))
  9092fb:	2b0a05        	movi	a11, 5

	sc->sc_imask = HAL_INT_RX | HAL_INT_TX
		| HAL_INT_RXEOL | HAL_INT_RXORN
		| HAL_INT_FATAL | HAL_INT_GLOBAL;

	sc->sc_imask |= HAL_INT_GTT;
  9092fe:	2826c4        	s32i	a8, a2, 0x310

	if (ath_hal_getcapability(ah, HAL_CAP_HT))
  909301:	da50      	mov.n	a10, a5
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo,NULL, 0);
}

static void ath_init_tgt(void *Context, A_UINT16 Command,
			 A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  909303:	03034f        	extui	a3, a3, 0, 16
  909306:	04044f        	extui	a4, a4, 0, 16
		| HAL_INT_RXEOL | HAL_INT_RXORN
		| HAL_INT_FATAL | HAL_INT_GLOBAL;

	sc->sc_imask |= HAL_INT_GTT;

	if (ath_hal_getcapability(ah, HAL_CAP_HT))
  909309:	580664        	call8	90ac9c <ath_hal_getcapability>
  90930c:	c8aa      	beqz.n	a10, 90931a <ath_init_tgt+0x2a>
		sc->sc_imask |= HAL_INT_CST;
  90930e:	2822c4        	l32i	a8, a2, 0x310
  909311:	1969c9        	l32r	a9, 8e3a38 <HIFusb_DescTraceDump+0x250>
  909314:	098802        	or	a8, a8, a9
  909317:	2826c4        	s32i	a8, a2, 0x310
#include <adf_os_irq_pvt.h>

static inline int
adf_os_setup_intr(adf_os_device_t  osdev, adf_os_drv_intr fn)
{
    return __adf_os_setup_intr(osdev, fn);
  90931a:	1b69ca        	l32r	a11, 8e3a44 <HIFusb_DescTraceDump+0x25c>
  90931d:	2a2246        	l32i	a10, a2, 0x118
  909320:	580654        	call8	90ac74 <__adf_os_setup_intr>

	adf_os_setup_intr(sc->sc_dev, ath_intr);
	ah->ah_setInterrupts(ah, sc->sc_imask);
  909323:	2b22c4        	l32i	a11, a2, 0x310
  909326:	285228        	l32i	a8, a5, 160
  909329:	da50      	mov.n	a10, a5
  90932b:	0b8000        	callx8	a8

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
  90932e:	c0e0      	movi.n	a14, 0
  909330:	8a23      	l32i.n	a10, a2, 12
  909332:	dde0      	mov.n	a13, a14
  909334:	dc40      	mov.n	a12, a4
  909336:	033b02        	or	a11, a3, a3
  909339:	5bfd93        	call8	908988 <wmi_cmd_rsp>
  90933c:	d10f      	retw.n
	...

00909340 <ath_enable_intr_tgt>:
/* WMI Commands */
/****************/

static void ath_enable_intr_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  909340:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  909343:	282d05        	addmi	a8, a2, 0x500
/* WMI Commands */
/****************/

static void ath_enable_intr_tgt(void *Context, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  909346:	03034f        	extui	a3, a3, 0, 16
  909349:	04044f        	extui	a4, a4, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  90934c:	8a8b      	l32i.n	a10, a8, 44
	a_uint32_t intr;

	if (data)
  90934e:	645002        	beqz	a5, 909354 <ath_enable_intr_tgt+0x14>
		intr = (*(a_uint32_t *)data);
  909351:	2b5200        	l32i	a11, a5, 0

	intr = adf_os_ntohl(intr);

	if (intr & HAL_INT_SWBA) {
  909354:	1968fc        	l32r	a9, 8e3744 <_HIFusb_isr_handler+0x60>
  909357:	2822c4        	l32i	a8, a2, 0x310
  90935a:	79b006        	bnone	a11, a9, 909364 <ath_enable_intr_tgt+0x24>
		sc->sc_imask |= HAL_INT_SWBA;
  90935d:	098802        	or	a8, a8, a9
  909360:	600006        	j	90936a <ath_enable_intr_tgt+0x2a>
  909363:	001569        	excw
	} else {
		sc->sc_imask &= ~HAL_INT_SWBA;
  909366:	cb05      	beqz.n	a0, 90939f <ath_disable_intr_tgt+0xb>
  909368:	8801      	l32i.n	a8, a0, 4
	}

	if (intr & HAL_INT_BMISS) {
  90936a:	1969cc        	l32r	a9, 8e3a9c <bGet_descriptor>
	intr = adf_os_ntohl(intr);

	if (intr & HAL_INT_SWBA) {
		sc->sc_imask |= HAL_INT_SWBA;
	} else {
		sc->sc_imask &= ~HAL_INT_SWBA;
  90936d:	2826c4        	s32i	a8, a2, 0x310
	}

	if (intr & HAL_INT_BMISS) {
  909370:	79b008        	bnone	a11, a9, 90937c <ath_enable_intr_tgt+0x3c>
		sc->sc_imask |= HAL_INT_BMISS;
  909373:	2822c4        	l32i	a8, a2, 0x310
  909376:	098802        	or	a8, a8, a9
  909379:	2826c4        	s32i	a8, a2, 0x310
	}

	ah->ah_setInterrupts(ah, sc->sc_imask);
  90937c:	2b22c4        	l32i	a11, a2, 0x310
  90937f:	25a228        	l32i	a5, a10, 160
  909382:	0b5000        	callx8	a5
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo,NULL, 0);
  909385:	c0e0      	movi.n	a14, 0
  909387:	8a23      	l32i.n	a10, a2, 12
  909389:	dde0      	mov.n	a13, a14
  90938b:	dc40      	mov.n	a12, a4
  90938d:	db30      	mov.n	a11, a3
  90938f:	5bfd7e        	call8	908988 <wmi_cmd_rsp>
  909392:	d10f      	retw.n

00909394 <ath_disable_intr_tgt>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_disable_intr_tgt(void *Context, A_UINT16 Command,
				 A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  909394:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;
  909397:	282d05        	addmi	a8, a2, 0x500
  90939a:	8a8b      	l32i.n	a10, a8, 44

	ah->ah_setInterrupts(ah, 0);
  90939c:	2b0a00        	movi	a11, 0
  90939f:	28a228        	l32i	a8, a10, 160
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_disable_intr_tgt(void *Context, A_UINT16 Command,
				 A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  9093a2:	03034f        	extui	a3, a3, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;

	ah->ah_setInterrupts(ah, 0);
  9093a5:	0b8000        	callx8	a8
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, NULL, 0);
}

static void ath_disable_intr_tgt(void *Context, A_UINT16 Command,
				 A_UINT16 SeqNo, A_UINT8 *data, a_int32_t datalen)
{
  9093a8:	04044f        	extui	a4, a4, 0, 16
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct ath_hal *ah = sc->sc_ah;

	ah->ah_setInterrupts(ah, 0);
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo,NULL, 0);
  9093ab:	c0e0      	movi.n	a14, 0
  9093ad:	8a23      	l32i.n	a10, a2, 12
  9093af:	dde0      	mov.n	a13, a14
  9093b1:	dc40      	mov.n	a12, a4
  9093b3:	db30      	mov.n	a11, a3
  9093b5:	5bfd74        	call8	908988 <wmi_cmd_rsp>
  9093b8:	d10f      	retw.n
	...

009093bc <ath_get_tgt_version>:
	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &stats, sizeof(stats));
}

static void ath_get_tgt_version(void *Context,A_UINT16 Command, A_UINT16 SeqNo,
				A_UINT8 *data, a_int32_t datalen)
{
  9093bc:	6c1006        	entry	a1, 48
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_fw_version ver;

	ver.major = ATH_VERSION_MAJOR;
  9093bf:	c081      	movi.n	a8, 1
	ver.minor = ATH_VERSION_MINOR;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &ver, sizeof(ver));
  9093c1:	8a23      	l32i.n	a10, a2, 12
				A_UINT8 *data, a_int32_t datalen)
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_fw_version ver;

	ver.major = ATH_VERSION_MAJOR;
  9093c3:	281500        	s16i	a8, a1, 0
	ver.minor = ATH_VERSION_MINOR;

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &ver, sizeof(ver));
  9093c6:	c0e4      	movi.n	a14, 4
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_fw_version ver;

	ver.major = ATH_VERSION_MAJOR;
	ver.minor = ATH_VERSION_MINOR;
  9093c8:	c084      	movi.n	a8, 4

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &ver, sizeof(ver));
  9093ca:	dd10      	mov.n	a13, a1
  9093cc:	040c4f        	extui	a12, a4, 0, 16
  9093cf:	030b4f        	extui	a11, a3, 0, 16
{
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)Context;
	struct wmi_fw_version ver;

	ver.major = ATH_VERSION_MAJOR;
	ver.minor = ATH_VERSION_MINOR;
  9093d2:	281501        	s16i	a8, a1, 2

	wmi_cmd_rsp(sc->tgt_wmi_handle, Command, SeqNo, &ver, sizeof(ver));
  9093d5:	5bfd6c        	call8	908988 <wmi_cmd_rsp>
  9093d8:	d10f      	retw.n
	...

009093dc <handle_echo_command>:
	adf_os_mem_free(sc);
}

static void handle_echo_command(void *pContext, A_UINT16 Command,
				A_UINT16 SeqNo, A_UINT8 *buffer, a_int32_t Length)
{
  9093dc:	6c1004        	entry	a1, 32
	wmi_cmd_rsp(pContext, WMI_ECHO_CMDID, SeqNo, buffer, Length);
  9093df:	de60      	mov.n	a14, a6
  9093e1:	dd50      	mov.n	a13, a5
  9093e3:	040c4f        	extui	a12, a4, 0, 16
  9093e6:	c0b1      	movi.n	a11, 1
  9093e8:	da20      	mov.n	a10, a2
  9093ea:	5bfd67        	call8	908988 <wmi_cmd_rsp>
  9093ed:	d10f      	retw.n
	...

009093f0 <ath_get_minrateidx>:
			sc->sc_sta[i].an_valid = 0;
	}
}

a_uint8_t ath_get_minrateidx(struct ath_softc_tgt *sc, struct ath_vap_target *avp)
{
  9093f0:	6c1004        	entry	a1, 32
	if (sc->sc_curmode == IEEE80211_MODE_11NG)
  9093f3:	2822c2        	l32i	a8, a2, 0x308
  9093f6:	698104        	bnei	a8, 1, 9093fe <ath_get_minrateidx+0xe>
		return avp->av_minrateidx[0];
  9093f9:	223040        	l8ui	a2, a3, 64
  9093fc:	d10f      	retw.n
	else if (sc->sc_curmode == IEEE80211_MODE_11NA)
		return avp->av_minrateidx[1];

	return 0;
  9093fe:	c020      	movi.n	a2, 0

a_uint8_t ath_get_minrateidx(struct ath_softc_tgt *sc, struct ath_vap_target *avp)
{
	if (sc->sc_curmode == IEEE80211_MODE_11NG)
		return avp->av_minrateidx[0];
	else if (sc->sc_curmode == IEEE80211_MODE_11NA)
  909400:	728902        	bne	a8, a2, 909406 <ath_get_minrateidx+0x16>
		return avp->av_minrateidx[1];
  909403:	223041        	l8ui	a2, a3, 65

	return 0;
}
  909406:	d10f      	retw.n

00909408 <tgt_HTCRecv_beaconhandler>:
#undef N
}

static void tgt_HTCRecv_beaconhandler(HTC_ENDPOINT_ID EndPt, adf_nbuf_t hdr_buf,
				      adf_nbuf_t buf, void *ServiceCtx)
{
  909408:	6c101c        	entry	a1, 224
}

static void ath_tgt_send_beacon(struct ath_softc_tgt *sc, adf_nbuf_t bc_hdr,
				adf_nbuf_t nbuf, HTC_ENDPOINT_ID EndPt)
{
	struct ath_hal *ah = sc->sc_ah;
  90940b:	265d05        	addmi	a6, a5, 0x500
  90940e:	866b      	l32i.n	a6, a6, 44
	ath_beacon_hdr_t *bhdr;
	struct ieee80211vap_target  *vap;
	a_uint32_t anblen;
	struct ieee80211_frame *wh;

	if (!bc_hdr) {
  909410:	cd35      	bnez.n	a3, 909429 <tgt_HTCRecv_beaconhandler+0x21>
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  909412:	231c20        	addi	a3, a1, 32
  909415:	2c3c70        	addi	a12, a3, 112
  909418:	2b3c74        	addi	a11, a3, 116
  90941b:	da40      	mov.n	a10, a4
  90941d:	5bf61a        	call8	906c88 <__adf_nbuf_peek_header>
		adf_nbuf_peek_header(nbuf, &anbdata, &anblen);
		bhdr = (ath_beacon_hdr_t *)anbdata;
  909420:	271225        	l32i	a7, a1, 148
  909423:	600011        	j	909438 <tgt_HTCRecv_beaconhandler+0x30>
  909426:	000000        	ill
	} else {
		adf_os_print("found bc_hdr! 0x%x\n", bc_hdr);
  909429:	1868bf        	l32r	a8, 8e3728 <_HIFusb_isr_handler+0x44>
  90942c:	1a69cd        	l32r	a10, 8e3b60 <bSet_configuration+0xc>
  90942f:	288212        	l32i	a8, a8, 72
  909432:	033b02        	or	a11, a3, a3
  909435:	0b8000        	callx8	a8
	}

	vap_index = bhdr->vap_index;
  909438:	277000        	l8ui	a7, a7, 0
	adf_os_assert(vap_index < TARGET_VAP_MAX);
  90943b:	6e7217        	bltui	a7, 2, 909456 <tgt_HTCRecv_beaconhandler+0x4e>
  90943e:	1368bf        	l32r	a3, 8e373c <_HIFusb_isr_handler+0x58>
  909441:	1b69ce        	l32r	a11, 8e3b7c <bSet_configuration+0x28>
  909444:	233212        	l32i	a3, a3, 72
  909447:	1a69a0        	l32r	a10, 8e3ac8 <bGet_descriptor+0x2c>
  90944a:	0b3000        	callx8	a3
  90944d:	136923        	l32r	a3, 8e38dc <HIFusb_DescTraceDump+0xf4>
  909450:	0c0200        	memw
  909453:	233200        	l32i	a3, a3, 0
 *         or NULL if there is not sufficient data to pull.
 */
static inline a_uint8_t *
adf_nbuf_pull_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_pull_head(buf, size);
  909456:	c0b4      	movi.n	a11, 4
  909458:	044a02        	or	a10, a4, a4
	vap = &sc->sc_vap[vap_index].av_vap;

	wh = (struct ieee80211_frame *)adf_nbuf_pull_head(nbuf,
						  sizeof(ath_beacon_hdr_t));

	bf = sc->sc_vap[vap_index].av_bcbuf;
  90945b:	0c7311        	slli	a3, a7, 4
  90945e:	5bf53e        	call8	906958 <__adf_nbuf_pull_head>
  909461:	a733      	add.n	a3, a3, a7
  909463:	0e3311        	slli	a3, a3, 2
  909466:	1869c5        	l32r	a8, 8e3b7c <bSet_configuration+0x28>
  909469:	a353      	add.n	a3, a5, a3
  90946b:	a833      	add.n	a3, a3, a8
  90946d:	8330      	l32i.n	a3, a3, 0
	adf_os_assert(bf);
  90946f:	cd35      	bnez.n	a3, 909488 <tgt_HTCRecv_beaconhandler+0x80>
  909471:	1868bf        	l32r	a8, 8e3770 <_HIFusb_isr_handler+0x8c>
  909474:	1b69ce        	l32r	a11, 8e3bac <bSet_configuration+0x58>
  909477:	288212        	l32i	a8, a8, 72
  90947a:	1a69a0        	l32r	a10, 8e3afc <bGet_descriptor+0x60>
  90947d:	0b8000        	callx8	a8
  909480:	186923        	l32r	a8, 8e390c <HIFusb_DescTraceDump+0x124>
  909483:	0c0200        	memw
  909486:	8880      	l32i.n	a8, a8, 0
	bf->bf_endpt = EndPt;
  909488:	223623        	s32i	a2, a3, 140

	if (bf->bf_skb) {
  90948b:	8238      	l32i.n	a2, a3, 32
  90948d:	c92f      	beqz.n	a2, 9094b0 <tgt_HTCRecv_beaconhandler+0xa8>
static inline void
adf_nbuf_unmap(adf_os_device_t      osdev, 
               adf_os_dma_map_t     bmap, 
               adf_os_dma_dir_t     dir)
{
    __adf_nbuf_unmap(osdev, bmap, dir);
  90948f:	8b30      	l32i.n	a11, a3, 0
  909491:	2a5246        	l32i	a10, a5, 0x118
  909494:	c0c0      	movi.n	a12, 0
  909496:	5bf579        	call8	906a7c <__adf_nbuf_unmap>
 *         or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_push_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_push_head(buf, size);
  909499:	8a38      	l32i.n	a10, a3, 32
  90949b:	c0b4      	movi.n	a11, 4
  90949d:	5bf523        	call8	90692c <__adf_nbuf_push_head>
		adf_nbuf_unmap(sc->sc_dev, bf->bf_dmamap, ADF_OS_DMA_TO_DEVICE);
		adf_nbuf_push_head(bf->bf_skb, sizeof(ath_beacon_hdr_t));
		ath_free_tx_skb(sc->tgt_htc_handle, bf->bf_endpt, bf->bf_skb);
  9094a0:	1268bf        	l32r	a2, 8e379c <_HIFusb_isr_handler+0xb8>
  9094a3:	8c38      	l32i.n	a12, a3, 32
  9094a5:	222282        	l32i	a2, a2, 0x208
  9094a8:	2b3223        	l32i	a11, a3, 140
  9094ab:	8a52      	l32i.n	a10, a5, 8
  9094ad:	0b2000        	callx8	a2
adf_nbuf_map(adf_os_device_t        osdev, 
             adf_os_dma_map_t       bmap, 
             adf_nbuf_t             buf, 
             adf_os_dma_dir_t       dir)
{
    return __adf_nbuf_map(osdev, bmap, buf, dir);
  9094b0:	2a5246        	l32i	a10, a5, 0x118
  9094b3:	8b30      	l32i.n	a11, a3, 0
  9094b5:	c0d0      	movi.n	a13, 0
  9094b7:	dc40      	mov.n	a12, a4
	}

	bf->bf_skb = nbuf;
  9094b9:	9438      	s32i.n	a4, a3, 32
  9094bb:	5bf56d        	call8	906a70 <__adf_nbuf_map>
 * @param[out] sg   map info
 */
static inline void
adf_nbuf_dmamap_info(adf_os_dma_map_t bmap, adf_os_dmamap_info_t *sg)
{
    __adf_nbuf_dmamap_info(bmap, sg);
  9094be:	8a30      	l32i.n	a10, a3, 0
  9094c0:	b43b      	addi.n	a11, a3, 4
static void ath_beacon_setup(struct ath_softc_tgt *sc,
			     struct ath_tx_buf *bf,
			     struct ath_vap_target *avp)
{
	adf_nbuf_t skb = bf->bf_skb;
	struct ath_hal *ah = sc->sc_ah;
  9094c2:	225d05        	addmi	a2, a5, 0x500
  9094c5:	5bf572        	call8	906a90 <__adf_nbuf_dmamap_info>
  9094c8:	822b      	l32i.n	a2, a2, 44
	struct ath_tx_desc *ds;
	a_int32_t flags;
	const HAL_RATE_TABLE *rt;
	a_uint8_t rix, rate;
	HAL_11N_RATE_SERIES series[4] = {{ 0 }};
  9094ca:	2c0a70        	movi	a12, 112
  9094cd:	c0b0      	movi.n	a11, 0
  9094cf:	2a1c20        	addi	a10, a1, 32
 */
static void ath_beacon_setup(struct ath_softc_tgt *sc,
			     struct ath_tx_buf *bf,
			     struct ath_vap_target *avp)
{
	adf_nbuf_t skb = bf->bf_skb;
  9094d2:	8438      	l32i.n	a4, a3, 32
	struct ath_hal *ah = sc->sc_ah;
  9094d4:	22162d        	s32i	a2, a1, 180
	struct ath_tx_desc *ds;
	a_int32_t flags;
	const HAL_RATE_TABLE *rt;
	a_uint8_t rix, rate;
	HAL_11N_RATE_SERIES series[4] = {{ 0 }};
  9094d7:	5b765c        	call8	8e6e48 <memset>

	flags = HAL_TXDESC_NOACK;

	ds = bf->bf_desc;
  9094da:	883c      	l32i.n	a8, a3, 48
	ds->ds_link = 0;
	ds->ds_data = bf->bf_dmamap_info.dma_segs[0].paddr;
  9094dc:	2a3008        	l8ui	a10, a3, 8
	bf->bf_skb = nbuf;

	adf_nbuf_map(sc->sc_dev, bf->bf_dmamap, nbuf, ADF_OS_DMA_TO_DEVICE);
	adf_nbuf_dmamap_info(bf->bf_dmamap,&bf->bf_dmamap_info);

	ath_beacon_setup(sc, bf, &sc->sc_vap[vap_index]);
  9094df:	0c7b11        	slli	a11, a7, 4

	flags = HAL_TXDESC_NOACK;

	ds = bf->bf_desc;
	ds->ds_link = 0;
	ds->ds_data = bf->bf_dmamap_info.dma_segs[0].paddr;
  9094e2:	2a8404        	s8i	a10, a8, 4
  9094e5:	2a3009        	l8ui	a10, a3, 9
	bf->bf_skb = nbuf;

	adf_nbuf_map(sc->sc_dev, bf->bf_dmamap, nbuf, ADF_OS_DMA_TO_DEVICE);
	adf_nbuf_dmamap_info(bf->bf_dmamap,&bf->bf_dmamap_info);

	ath_beacon_setup(sc, bf, &sc->sc_vap[vap_index]);
  9094e8:	a7bb      	add.n	a11, a11, a7

	flags = HAL_TXDESC_NOACK;

	ds = bf->bf_desc;
	ds->ds_link = 0;
	ds->ds_data = bf->bf_dmamap_info.dma_segs[0].paddr;
  9094ea:	2a8405        	s8i	a10, a8, 5
  9094ed:	2a300a        	l8ui	a10, a3, 10
	bf->bf_skb = nbuf;

	adf_nbuf_map(sc->sc_dev, bf->bf_dmamap, nbuf, ADF_OS_DMA_TO_DEVICE);
	adf_nbuf_dmamap_info(bf->bf_dmamap,&bf->bf_dmamap_info);

	ath_beacon_setup(sc, bf, &sc->sc_vap[vap_index]);
  9094f0:	1769bf        	l32r	a7, 8e3bec <bSet_configuration+0x98>

	flags = HAL_TXDESC_NOACK;

	ds = bf->bf_desc;
	ds->ds_link = 0;
	ds->ds_data = bf->bf_dmamap_info.dma_segs[0].paddr;
  9094f3:	2a8406        	s8i	a10, a8, 6
	bf->bf_skb = nbuf;

	adf_nbuf_map(sc->sc_dev, bf->bf_dmamap, nbuf, ADF_OS_DMA_TO_DEVICE);
	adf_nbuf_dmamap_info(bf->bf_dmamap,&bf->bf_dmamap_info);

	ath_beacon_setup(sc, bf, &sc->sc_vap[vap_index]);
  9094f6:	0ebb11        	slli	a11, a11, 2

	flags = HAL_TXDESC_NOACK;

	ds = bf->bf_desc;
	ds->ds_link = 0;
	ds->ds_data = bf->bf_dmamap_info.dma_segs[0].paddr;
  9094f9:	2a300b        	l8ui	a10, a3, 11
	HAL_11N_RATE_SERIES series[4] = {{ 0 }};

	flags = HAL_TXDESC_NOACK;

	ds = bf->bf_desc;
	ds->ds_link = 0;
  9094fc:	c090      	movi.n	a9, 0
	bf->bf_skb = nbuf;

	adf_nbuf_map(sc->sc_dev, bf->bf_dmamap, nbuf, ADF_OS_DMA_TO_DEVICE);
	adf_nbuf_dmamap_info(bf->bf_dmamap,&bf->bf_dmamap_info);

	ath_beacon_setup(sc, bf, &sc->sc_vap[vap_index]);
  9094fe:	a7bb      	add.n	a11, a11, a7
	HAL_11N_RATE_SERIES series[4] = {{ 0 }};

	flags = HAL_TXDESC_NOACK;

	ds = bf->bf_desc;
	ds->ds_link = 0;
  909500:	298400        	s8i	a9, a8, 0
  909503:	298401        	s8i	a9, a8, 1
  909506:	298402        	s8i	a9, a8, 2
  909509:	298403        	s8i	a9, a8, 3
	ds->ds_data = bf->bf_dmamap_info.dma_segs[0].paddr;
  90950c:	2a8407        	s8i	a10, a8, 7

	rix = ath_get_minrateidx(sc, avp);
  90950f:	ab5b      	add.n	a11, a5, a11
  909511:	055a02        	or	a10, a5, a5
  909514:	28162b        	s32i	a8, a1, 172
  909517:	29162c        	s32i	a9, a1, 176
  90951a:	5bffb5        	call8	9093f0 <ath_get_minrateidx>
	rt  = sc->sc_currates;
	rate = rt->info[rix].rateCode;
  90951d:	0ea711        	slli	a7, a10, 2
  909520:	2b5281        	l32i	a11, a5, 0x204
  909523:	aa7a      	add.n	a10, a7, a10
  909525:	0eaa11        	slli	a10, a10, 2
  909528:	aaba      	add.n	a10, a11, a10
  90952a:	2aa034        	l8ui	a10, a10, 52

	ah->ah_setupTxDesc(ds
  90952d:	222217        	l32i	a2, a2, 92
	ds->ds_link = 0;
	ds->ds_data = bf->bf_dmamap_info.dma_segs[0].paddr;

	rix = ath_get_minrateidx(sc, avp);
	rt  = sc->sc_currates;
	rate = rt->info[rix].rateCode;
  909530:	2a1628        	s32i	a10, a1, 160
 * @return The total length of this buf.
 */
static inline adf_os_size_t
adf_nbuf_len(adf_nbuf_t buf)
{
    return (__adf_nbuf_len(buf));
  909533:	044a02        	or	a10, a4, a4
  909536:	5bf5cc        	call8	906c68 <__adf_nbuf_len>

	ah->ah_setupTxDesc(ds
  909539:	c072      	movi.n	a7, 2
  90953b:	29122c        	l32i	a9, a1, 176
  90953e:	28122b        	l32i	a8, a1, 172
  909541:	9712      	s32i.n	a7, a1, 8
  909543:	270aff        	movi	a7, 255
  909546:	9711      	s32i.n	a7, a1, 4
  909548:	2f1228        	l32i	a15, a1, 160
  90954b:	c071      	movi.n	a7, 1
  90954d:	9914      	s32i.n	a9, a1, 16
  90954f:	9913      	s32i.n	a9, a1, 12
  909551:	b4ab      	addi.n	a11, a10, 4
  909553:	c3ef      	movi.n	a14, 63
  909555:	c0d3      	movi.n	a13, 3
  909557:	c1c8      	movi.n	a12, 24
  909559:	da80      	mov.n	a10, a8
  90955b:	271600        	s32i	a7, a1, 0
  90955e:	0b2000        	callx8	a2
			    , HAL_TXKEYIX_INVALID
			    , flags
			    , 0
			    , 0);

	ah->ah_fillTxDesc(ds
  909561:	22122d        	l32i	a2, a1, 180
  909564:	044a02        	or	a10, a4, a4
  909567:	2f2218        	l32i	a15, a2, 96
  90956a:	2f162a        	s32i	a15, a1, 168
  90956d:	5bf5be        	call8	906c68 <__adf_nbuf_len>
  909570:	28122b        	l32i	a8, a1, 172
  909573:	2f122a        	l32i	a15, a1, 168
			   , asf_roundup(adf_nbuf_len(skb), 4)
  909576:	b3aa      	addi.n	a10, a10, 3
			    , HAL_TXKEYIX_INVALID
			    , flags
			    , 0
			    , 0);

	ah->ah_fillTxDesc(ds
  909578:	c7bc      	movi.n	a11, -4
  90957a:	de80      	mov.n	a14, a8
  90957c:	dd70      	mov.n	a13, a7
  90957e:	dc70      	mov.n	a12, a7
  909580:	0bab01        	and	a11, a10, a11
  909583:	da80      	mov.n	a10, a8
  909585:	0bf000        	callx8	a15
			   , AH_TRUE
			   , AH_TRUE
			   , ds);

	series[0].Tries = 1;
	series[0].Rate = rate;
  909588:	241228        	l32i	a4, a1, 160
	series[0].ChSel = sc->sc_ic.ic_tx_chainmask;
	series[0].RateFlags = 0;
  90958b:	29122c        	l32i	a9, a1, 176
			   , AH_TRUE
			   , AH_TRUE
			   , ds);

	series[0].Tries = 1;
	series[0].Rate = rate;
  90958e:	9419      	s32i.n	a4, a1, 36
	series[0].ChSel = sc->sc_ic.ic_tx_chainmask;
  909590:	245d16        	addmi	a4, a5, 0x1600
  909593:	244026        	l8ui	a4, a4, 38
	series[0].RateFlags = 0;
	ah->ah_set11nRateScenario(ds, 0, 0, series, 4, 0);
  909596:	28122b        	l32i	a8, a1, 172
			   , AH_TRUE
			   , ds);

	series[0].Tries = 1;
	series[0].Rate = rate;
	series[0].ChSel = sc->sc_ic.ic_tx_chainmask;
  909599:	941b      	s32i.n	a4, a1, 44
	series[0].RateFlags = 0;
	ah->ah_set11nRateScenario(ds, 0, 0, series, 4, 0);
  90959b:	24122d        	l32i	a4, a1, 180
  90959e:	dc90      	mov.n	a12, a9
  9095a0:	224210        	l32i	a2, a4, 64
  9095a3:	db90      	mov.n	a11, a9
  9095a5:	da80      	mov.n	a10, a8
			   , ds);

	series[0].Tries = 1;
	series[0].Rate = rate;
	series[0].ChSel = sc->sc_ic.ic_tx_chainmask;
	series[0].RateFlags = 0;
  9095a7:	991c      	s32i.n	a9, a1, 48
	ah->ah_set11nRateScenario(ds, 0, 0, series, 4, 0);
  9095a9:	df90      	mov.n	a15, a9
  9095ab:	c0e4      	movi.n	a14, 4
  9095ad:	2d1c20        	addi	a13, a1, 32
			   , asf_roundup(adf_nbuf_len(skb), 4)
			   , AH_TRUE
			   , AH_TRUE
			   , ds);

	series[0].Tries = 1;
  9095b0:	9718      	s32i.n	a7, a1, 32
	series[0].Rate = rate;
	series[0].ChSel = sc->sc_ic.ic_tx_chainmask;
	series[0].RateFlags = 0;
	ah->ah_set11nRateScenario(ds, 0, 0, series, 4, 0);
  9095b2:	0b2000        	callx8	a2

	adf_nbuf_map(sc->sc_dev, bf->bf_dmamap, nbuf, ADF_OS_DMA_TO_DEVICE);
	adf_nbuf_dmamap_info(bf->bf_dmamap,&bf->bf_dmamap_info);

	ath_beacon_setup(sc, bf, &sc->sc_vap[vap_index]);
	ah->ah_stopTxDma(ah, sc->sc_bhalq);
  9095b5:	255d01        	addmi	a5, a5, 0x100
  9095b8:	22620d        	l32i	a2, a6, 52
  9095bb:	2b501c        	l8ui	a11, a5, 28
  9095be:	066a02        	or	a10, a6, a6
  9095c1:	0b2000        	callx8	a2
	ah->ah_setTxDP(ah, sc->sc_bhalq, ATH_BUF_GET_DESC_PHY_ADDR(bf));
  9095c4:	2b501c        	l8ui	a11, a5, 28
  9095c7:	826a      	l32i.n	a2, a6, 40
  9095c9:	8c3c      	l32i.n	a12, a3, 48
  9095cb:	da60      	mov.n	a10, a6
  9095cd:	0b2000        	callx8	a2
	ah->ah_startTxDma(ah, sc->sc_bhalq);
  9095d0:	2b501c        	l8ui	a11, a5, 28
  9095d3:	826c      	l32i.n	a2, a6, 48
  9095d5:	da60      	mov.n	a10, a6
  9095d7:	0b2000        	callx8	a2
  9095da:	d10f      	retw.n

009095dc <ath_tgt_attach>:
	/* Start HTC messages exchange */
	HTC_Ready(sc->tgt_htc_handle);
}

a_int32_t ath_tgt_attach(a_uint32_t devid, struct ath_softc_tgt *sc, adf_os_device_t osdev)
{
  9095dc:	6c100e        	entry	a1, 112
 * @return int
 */
static inline int 
__adf_os_pci_config_read8(adf_os_device_t osdev, int offset, a_uint8_t *val)
{
    (*val) = wlan_pci_config_read(offset, 1);
  9095df:	2b0a01        	movi	a11, 1
  9095e2:	2a0a0c        	movi	a10, 12
  9095e5:	580131        	call8	909aac <wlan_pci_config_read>
  9095e8:	0a0a47        	extui	a10, a10, 0, 8
	a_uint8_t csz;

	adf_os_pci_config_read8(osdev, ATH_PCI_CACHE_LINE_SIZE, &csz);

	if (csz == 0)
		csz = 16;
  9095eb:	c150      	movi.n	a5, 16
  9095ed:	0a5a38        	moveqz	a10, a5, a10
	sc->sc_cachelsz = csz << 2;
  9095f0:	0eaa11        	slli	a10, a10, 2
  9095f3:	2a3596        	s16i	a10, a3, 0x12c
 */
static inline void 
adf_os_init_bh(adf_os_handle_t  hdl, adf_os_bh_t  *bh,
               adf_os_defer_fn_t  func,void  *arg)
{
    __adf_os_init_bh(hdl, bh, func, arg);
  9095f6:	1b69cf        	l32r	a11, 8e3d34 <bSet_configuration+0x1e0>
  9095f9:	2a3a14        	movi	a10, 0x314

	sc->sc_dev = osdev;
  9095fc:	243646        	s32i	a4, a3, 0x118
	sc->sc_hdl = osdev;
  9095ff:	243645        	s32i	a4, a3, 0x114
  909602:	dc30      	mov.n	a12, a3
  909604:	aa3a      	add.n	a10, a3, a10
  909606:	5bf98d        	call8	907c3c <__adf_os_init_bh$isra$5>
  909609:	1b69d0        	l32r	a11, 8e3d4c <bSet_configuration+0x1f8>
  90960c:	2a5a1c        	movi	a10, 0x51c
  90960f:	033c02        	or	a12, a3, a3
  909612:	0a3a08        	add	a10, a3, a10
  909615:	5bf989        	call8	907c3c <__adf_os_init_bh$isra$5>
  909618:	1b69d1        	l32r	a11, 8e3d5c <bSet_configuration+0x208>
  90961b:	2a3a24        	movi	a10, 0x324
  90961e:	dc30      	mov.n	a12, a3
  909620:	aa3a      	add.n	a10, a3, a10
  909622:	5bf986        	call8	907c3c <__adf_os_init_bh$isra$5>
  909625:	1b69d2        	l32r	a11, 8e3d70 <bSet_configuration+0x21c>
  909628:	2a3a44        	movi	a10, 0x344
  90962b:	033c02        	or	a12, a3, a3
  90962e:	0a3a08        	add	a10, a3, a10
  909631:	5bf982        	call8	907c3c <__adf_os_init_bh$isra$5>
	ATH_INIT_TQUEUE(sc->sc_dev, &sc->sc_txtq, owl_tgt_tx_tasklet, sc);
	ATH_INIT_TQUEUE(sc->sc_dev, &sc->sc_bmisstq, ath_bmiss_tasklet, sc);
	ATH_INIT_TQUEUE(sc->sc_dev, &sc->sc_fataltq, ath_fatal_tasklet, sc);

	flags |= AH_USE_EEPROM;
	ah = _ath_hal_attach_tgt(devid, sc, sc->sc_dev, flags, &status);
  909634:	2c3246        	l32i	a12, a3, 0x118
  909637:	2e1c34        	addi	a14, a1, 52
  90963a:	c0d1      	movi.n	a13, 1
  90963c:	033b02        	or	a11, a3, a3
  90963f:	da20      	mov.n	a10, a2
  909641:	5bf90f        	call8	907a80 <_ath_hal_attach_tgt>
  909644:	0aa402        	or	a4, a10, a10
	if (ah == NULL) {
  909647:	64a3e5        	beqz	a10, 909a30 <ath_tgt_attach+0x454>
	HTC_CONFIG htc_conf;
	WMI_SVC_CONFIG wmiConfig;
	WMI_DISPATCH_TABLE *Magpie_Sys_Commands_Tbl;

	/* Init dynamic buf pool */
	sc->pool_handle = BUF_Pool_init(sc->sc_hdl);
  90964a:	1668bf        	l32r	a6, 8e3948 <HIFusb_DescTraceDump+0x160>
	ah = _ath_hal_attach_tgt(devid, sc, sc->sc_dev, flags, &status);
	if (ah == NULL) {
		error = ENXIO;
		goto bad;
	}
	sc->sc_ah = ah;
  90964d:	223d05        	addmi	a2, a3, 0x500
  909650:	2a260b        	s32i	a10, a2, 44
	HTC_CONFIG htc_conf;
	WMI_SVC_CONFIG wmiConfig;
	WMI_DISPATCH_TABLE *Magpie_Sys_Commands_Tbl;

	/* Init dynamic buf pool */
	sc->pool_handle = BUF_Pool_init(sc->sc_hdl);
  909653:	276299        	l32i	a7, a6, 0x264
  909656:	2a3245        	l32i	a10, a3, 0x114
  909659:	0b7000        	callx8	a7

	/* Init target-side HIF */
	sc->tgt_hif_handle = HIF_init(0);
  90965c:	276270        	l32i	a7, a6, 0x1c0
	HTC_CONFIG htc_conf;
	WMI_SVC_CONFIG wmiConfig;
	WMI_DISPATCH_TABLE *Magpie_Sys_Commands_Tbl;

	/* Init dynamic buf pool */
	sc->pool_handle = BUF_Pool_init(sc->sc_hdl);
  90965f:	2a3600        	s32i	a10, a3, 0

	/* Init target-side HIF */
	sc->tgt_hif_handle = HIF_init(0);
  909662:	2a0a00        	movi	a10, 0
  909665:	0b7000        	callx8	a7

	/* Init target-side HTC */
	htc_conf.HIFHandle = sc->tgt_hif_handle;
	htc_conf.CreditSize = 320;
  909668:	271a40        	movi	a7, 0x140
  90966b:	9714      	s32i.n	a7, a1, 16
	htc_conf.CreditNumber = ATH_TXBUF;
  90966d:	c27d      	movi.n	a7, 45
  90966f:	9715      	s32i.n	a7, a1, 20
	htc_conf.OSHandle = sc->sc_hdl;
  909671:	273245        	l32i	a7, a3, 0x114

	/* Init dynamic buf pool */
	sc->pool_handle = BUF_Pool_init(sc->sc_hdl);

	/* Init target-side HIF */
	sc->tgt_hif_handle = HIF_init(0);
  909674:	9a31      	s32i.n	a10, a3, 4

	/* Init target-side HTC */
	htc_conf.HIFHandle = sc->tgt_hif_handle;
	htc_conf.CreditSize = 320;
	htc_conf.CreditNumber = ATH_TXBUF;
	htc_conf.OSHandle = sc->sc_hdl;
  909676:	9716      	s32i.n	a7, a1, 24
	htc_conf.PoolHandle = sc->pool_handle;
  909678:	8730      	l32i.n	a7, a3, 0

	/* Init target-side HIF */
	sc->tgt_hif_handle = HIF_init(0);

	/* Init target-side HTC */
	htc_conf.HIFHandle = sc->tgt_hif_handle;
  90967a:	9a17      	s32i.n	a10, a1, 28
	htc_conf.CreditSize = 320;
	htc_conf.CreditNumber = ATH_TXBUF;
	htc_conf.OSHandle = sc->sc_hdl;
	htc_conf.PoolHandle = sc->pool_handle;
  90967c:	9718      	s32i.n	a7, a1, 32
	sc->tgt_htc_handle = HTC_init(htc_setup_comp, &htc_conf);
  90967e:	1a69d3        	l32r	a10, 8e3dcc <bSet_configuration+0x278>
  909681:	27627e        	l32i	a7, a6, 0x1f8
  909684:	a51b      	add.n	a11, a1, a5
  909686:	0b7000        	callx8	a7
#if defined(PROJECT_MAGPIE)
	init_htc_handle = sc->tgt_htc_handle;
  909689:	176911        	l32r	a7, 8e3ad0 <bGet_descriptor+0x34>
#endif

	tgt_reg_service(sc, &sc->htc_beacon_service, WMI_BEACON_SVC, tgt_HTCRecv_beaconhandler);
  90968c:	1d69d4        	l32r	a13, 8e3ddc <bSet_configuration+0x288>
	htc_conf.CreditNumber = ATH_TXBUF;
	htc_conf.OSHandle = sc->sc_hdl;
	htc_conf.PoolHandle = sc->pool_handle;
	sc->tgt_htc_handle = HTC_init(htc_setup_comp, &htc_conf);
#if defined(PROJECT_MAGPIE)
	init_htc_handle = sc->tgt_htc_handle;
  90968f:	9a70      	s32i.n	a10, a7, 0
#endif

	tgt_reg_service(sc, &sc->htc_beacon_service, WMI_BEACON_SVC, tgt_HTCRecv_beaconhandler);
  909691:	a53b      	add.n	a11, a3, a5
	htc_conf.HIFHandle = sc->tgt_hif_handle;
	htc_conf.CreditSize = 320;
	htc_conf.CreditNumber = ATH_TXBUF;
	htc_conf.OSHandle = sc->sc_hdl;
	htc_conf.PoolHandle = sc->pool_handle;
	sc->tgt_htc_handle = HTC_init(htc_setup_comp, &htc_conf);
  909693:	9a32      	s32i.n	a10, a3, 8
#if defined(PROJECT_MAGPIE)
	init_htc_handle = sc->tgt_htc_handle;
#endif

	tgt_reg_service(sc, &sc->htc_beacon_service, WMI_BEACON_SVC, tgt_HTCRecv_beaconhandler);
  909695:	2c1a01        	movi	a12, 0x101
  909698:	da30      	mov.n	a10, a3
  90969a:	5bf932        	call8	907b64 <tgt_reg_service>
	tgt_reg_service(sc, &sc->htc_cab_service, WMI_CAB_SVC, tgt_HTCRecv_cabhandler);
  90969d:	1d69d5        	l32r	a13, 8e3df4 <bSet_configuration+0x2a0>
  9096a0:	2c1a02        	movi	a12, 0x102
  9096a3:	2b3c2c        	addi	a11, a3, 44
  9096a6:	033a02        	or	a10, a3, a3
  9096a9:	5bf92e        	call8	907b64 <tgt_reg_service>
	tgt_reg_service(sc, &sc->htc_uapsd_service, WMI_UAPSD_SVC, tgt_HTCRecv_uapsdhandler);
  9096ac:	1d69d6        	l32r	a13, 8e3e04 <bSet_configuration+0x2b0>
  9096af:	2c1a03        	movi	a12, 0x103
  9096b2:	2b3c48        	addi	a11, a3, 72
  9096b5:	da30      	mov.n	a10, a3
  9096b7:	5bf92b        	call8	907b64 <tgt_reg_service>
	tgt_reg_service(sc, &sc->htc_mgmt_service, WMI_MGMT_SVC, tgt_HTCRecv_mgmthandler);
  9096ba:	1d69d7        	l32r	a13, 8e3e18 <bSet_configuration+0x2c4>
  9096bd:	2c1a04        	movi	a12, 0x104
  9096c0:	2b3c64        	addi	a11, a3, 100
  9096c3:	033a02        	or	a10, a3, a3
  9096c6:	5bf927        	call8	907b64 <tgt_reg_service>
	tgt_reg_service(sc, &sc->htc_data_BE_service, WMI_DATA_BE_SVC, tgt_HTCRecvMessageHandler);
  9096c9:	1769d8        	l32r	a7, 8e3e2c <bSet_configuration+0x2d8>
  9096cc:	2b0ab8        	movi	a11, 184
  9096cf:	dd70      	mov.n	a13, a7
  9096d1:	2c1a07        	movi	a12, 0x107
  9096d4:	ab3b      	add.n	a11, a3, a11
  9096d6:	033a02        	or	a10, a3, a3
  9096d9:	5bf922        	call8	907b64 <tgt_reg_service>
	tgt_reg_service(sc, &sc->htc_data_BK_service, WMI_DATA_BK_SVC, tgt_HTCRecvMessageHandler);
  9096dc:	2b0ad4        	movi	a11, 212
  9096df:	dd70      	mov.n	a13, a7
  9096e1:	2c1a08        	movi	a12, 0x108
  9096e4:	ab3b      	add.n	a11, a3, a11
  9096e6:	033a02        	or	a10, a3, a3
  9096e9:	5bf91e        	call8	907b64 <tgt_reg_service>
	tgt_reg_service(sc, &sc->htc_data_VI_service, WMI_DATA_VI_SVC, tgt_HTCRecvMessageHandler);
  9096ec:	2b0a9c        	movi	a11, 156
  9096ef:	dd70      	mov.n	a13, a7
  9096f1:	2c1a06        	movi	a12, 0x106
  9096f4:	ab3b      	add.n	a11, a3, a11
  9096f6:	033a02        	or	a10, a3, a3
  9096f9:	5bf91a        	call8	907b64 <tgt_reg_service>
	tgt_reg_service(sc, &sc->htc_data_VO_service, WMI_DATA_VO_SVC, tgt_HTCRecvMessageHandler);
  9096fc:	2b0a80        	movi	a11, 128
  9096ff:	dd70      	mov.n	a13, a7
  909701:	2c1a05        	movi	a12, 0x105
  909704:	ab3b      	add.n	a11, a3, a11
  909706:	033a02        	or	a10, a3, a3
  909709:	5bf916        	call8	907b64 <tgt_reg_service>
 * @return Buffer pointer or NULL if there's not enough memory.
 */
static inline void *
adf_os_mem_alloc(adf_os_size_t size)
{
    return __adf_os_mem_alloc(size);
  90970c:	da50      	mov.n	a10, a5
  90970e:	5bf8fb        	call8	907afc <__adf_os_mem_alloc>
}
/* zero a memory buffer */
static inline void
__adf_os_mem_zero(void *buf, adf_os_size_t size)
{
    A_MEMZERO(buf,size);
  909711:	8864      	l32i.n	a8, a6, 16
  909713:	dc50      	mov.n	a12, a5
  909715:	c0b0      	movi.n	a11, 0
  909717:	d7a0      	mov.n	a7, a10
  909719:	0b8000        	callx8	a8

	/* Init target-side WMI */
	Magpie_Sys_Commands_Tbl = (WMI_DISPATCH_TABLE *)adf_os_mem_alloc(sizeof(WMI_DISPATCH_TABLE));
	adf_os_mem_zero(Magpie_Sys_Commands_Tbl, sizeof(WMI_DISPATCH_TABLE));
	Magpie_Sys_Commands_Tbl->NumberOfEntries = WMI_DISPATCH_ENTRY_COUNT(Magpie_Sys_DispatchEntries);
  90971c:	c280      	movi.n	a8, 32
  90971e:	9872      	s32i.n	a8, a7, 8
	Magpie_Sys_Commands_Tbl->pTable = Magpie_Sys_DispatchEntries;
  909720:	1869d9        	l32r	a8, 8e3e84 <bStandardCommand+0x20>
  909723:	dc50      	mov.n	a12, a5
  909725:	9873      	s32i.n	a8, a7, 12
  909727:	8864      	l32i.n	a8, a6, 16
  909729:	c0b0      	movi.n	a11, 0
  90972b:	2a1c24        	addi	a10, a1, 36
  90972e:	0b8000        	callx8	a8

	adf_os_mem_zero(&wmiConfig, sizeof(WMI_SVC_CONFIG));
	wmiConfig.HtcHandle = sc->tgt_htc_handle;
  909731:	8532      	l32i.n	a5, a3, 8
	wmiConfig.PoolHandle = sc->pool_handle;
	wmiConfig.MaxCmdReplyEvts = ATH_WMI_MAX_CMD_REPLY;
	wmiConfig.MaxEventEvts = ATH_WMI_MAX_EVENTS;

	sc->tgt_wmi_handle = WMI_Init(&wmiConfig);
  909733:	2a1c24        	addi	a10, a1, 36
	adf_os_mem_zero(Magpie_Sys_Commands_Tbl, sizeof(WMI_DISPATCH_TABLE));
	Magpie_Sys_Commands_Tbl->NumberOfEntries = WMI_DISPATCH_ENTRY_COUNT(Magpie_Sys_DispatchEntries);
	Magpie_Sys_Commands_Tbl->pTable = Magpie_Sys_DispatchEntries;

	adf_os_mem_zero(&wmiConfig, sizeof(WMI_SVC_CONFIG));
	wmiConfig.HtcHandle = sc->tgt_htc_handle;
  909736:	9519      	s32i.n	a5, a1, 36
	wmiConfig.PoolHandle = sc->pool_handle;
  909738:	8530      	l32i.n	a5, a3, 0
  90973a:	951a      	s32i.n	a5, a1, 40
	wmiConfig.MaxCmdReplyEvts = ATH_WMI_MAX_CMD_REPLY;
  90973c:	c052      	movi.n	a5, 2
  90973e:	951b      	s32i.n	a5, a1, 44
	wmiConfig.MaxEventEvts = ATH_WMI_MAX_EVENTS;
  909740:	c058      	movi.n	a5, 8
  909742:	951c      	s32i.n	a5, a1, 48

	sc->tgt_wmi_handle = WMI_Init(&wmiConfig);
  909744:	25628b        	l32i	a5, a6, 0x22c
  909747:	0b5000        	callx8	a5
  90974a:	9a33      	s32i.n	a10, a3, 12
	Magpie_Sys_Commands_Tbl->pContext = sc;
	WMI_RegisterDispatchTable(sc->tgt_wmi_handle, Magpie_Sys_Commands_Tbl);
  90974c:	25628c        	l32i	a5, a6, 0x230
  90974f:	db70      	mov.n	a11, a7
	wmiConfig.PoolHandle = sc->pool_handle;
	wmiConfig.MaxCmdReplyEvts = ATH_WMI_MAX_CMD_REPLY;
	wmiConfig.MaxEventEvts = ATH_WMI_MAX_EVENTS;

	sc->tgt_wmi_handle = WMI_Init(&wmiConfig);
	Magpie_Sys_Commands_Tbl->pContext = sc;
  909751:	9371      	s32i.n	a3, a7, 4
	WMI_RegisterDispatchTable(sc->tgt_wmi_handle, Magpie_Sys_Commands_Tbl);
  909753:	0b5000        	callx8	a5

	HTC_NotifyTargetInserted(sc->tgt_htc_handle);

	/* Start HTC messages exchange */
	HTC_Ready(sc->tgt_htc_handle);
  909756:	8a32      	l32i.n	a10, a3, 8
  909758:	256281        	l32i	a5, a6, 0x204
	}
	sc->sc_ah = ah;

	tgt_hif_htc_wmi_init(sc);

	sc->sc_bhalq = HAL_NUM_TX_QUEUES - 1;
  90975b:	c079      	movi.n	a7, 9
	WMI_RegisterDispatchTable(sc->tgt_wmi_handle, Magpie_Sys_Commands_Tbl);

	HTC_NotifyTargetInserted(sc->tgt_htc_handle);

	/* Start HTC messages exchange */
	HTC_Ready(sc->tgt_htc_handle);
  90975d:	0b5000        	callx8	a5
	}
	sc->sc_ah = ah;

	tgt_hif_htc_wmi_init(sc);

	sc->sc_bhalq = HAL_NUM_TX_QUEUES - 1;
  909760:	253d01        	addmi	a5, a3, 0x100
  909763:	27541c        	s8i	a7, a5, 28
	return (tsf + (u_int64_t)tsf_delta);
}

static a_int32_t ath_rate_setup(struct ath_softc_tgt *sc, a_uint32_t mode)
{
	struct ath_hal *ah = sc->sc_ah;
  909766:	8a2b      	l32i.n	a10, a2, 44
	const HAL_RATE_TABLE *rt;

	switch (mode) {
	case IEEE80211_MODE_11NA:
		sc->sc_rates[mode] = ah->ah_getRateTable(ah, HAL_MODE_11NA);
  909768:	1b69da        	l32r	a11, 8e3ed0 <bStandardCommand+0x6c>
  90976b:	85a5      	l32i.n	a5, a10, 20
  90976d:	0b5000        	callx8	a5
  909770:	2a367f        	s32i	a10, a3, 0x1fc
	return (tsf + (u_int64_t)tsf_delta);
}

static a_int32_t ath_rate_setup(struct ath_softc_tgt *sc, a_uint32_t mode)
{
	struct ath_hal *ah = sc->sc_ah;
  909773:	8a2b      	l32i.n	a10, a2, 44
	switch (mode) {
	case IEEE80211_MODE_11NA:
		sc->sc_rates[mode] = ah->ah_getRateTable(ah, HAL_MODE_11NA);
		break;
	case IEEE80211_MODE_11NG:
		sc->sc_rates[mode] = ah->ah_getRateTable(ah, HAL_MODE_11NG);
  909775:	1b69db        	l32r	a11, 8e3ee4 <bStandardCommand+0x80>
  909778:	85a5      	l32i.n	a5, a10, 20
  90977a:	0b5000        	callx8	a5
  90977d:	2a3680        	s32i	a10, a3, 0x200
	sc->sc_bhalq = HAL_NUM_TX_QUEUES - 1;

	ath_rate_setup(sc, IEEE80211_MODE_11NA);
	ath_rate_setup(sc, IEEE80211_MODE_11NG);

	sc->sc_rc = ath_rate_attach(sc);
  909780:	da30      	mov.n	a10, a3
  909782:	580d66        	call8	90cd1c <ath_rate_attach>
  909785:	2a3648        	s32i	a10, a3, 0x120
	if (sc->sc_rc == NULL) {
  909788:	64a295        	beqz	a10, 909a21 <ath_tgt_attach+0x445>
  90978b:	1769dc        	l32r	a7, 8e3efc <bStandardCommand+0x98>
  90978e:	257a40        	movi	a5, 0x740
  909791:	a535      	add.n	a5, a3, a5
  909793:	073708        	add	a7, a3, a7
  909796:	282a0c        	movi	a8, 0x20c
		error = EIO;
		goto bad2;
	}

	for (i=0; i < TARGET_NODE_MAX; i++) {
		sc->sc_sta[i].an_rcnode = adf_os_mem_alloc(sc->sc_rc->arc_space);
  909799:	293248        	l32i	a9, a3, 0x120
  90979c:	8a90      	l32i.n	a10, a9, 0
  90979e:	281613        	s32i	a8, a1, 76
  9097a1:	5bf8d6        	call8	907afc <__adf_os_mem_alloc>
  9097a4:	281213        	l32i	a8, a1, 76
  9097a7:	9a50      	s32i.n	a10, a5, 0
  9097a9:	a855      	add.n	a5, a5, a8
	if (sc->sc_rc == NULL) {
		error = EIO;
		goto bad2;
	}

	for (i=0; i < TARGET_NODE_MAX; i++) {
  9097ab:	7759ea        	bne	a5, a7, 909799 <ath_tgt_attach+0x1bd>
	((_dd)->dd_desc_paddr + ((caddr_t)(_ds) - (caddr_t)(_dd)->dd_desc))

	a_int32_t error;
	struct ath_tx_buf *bf;

	if(ath_numrxbufs == -1)
  9097ae:	1569b6        	l32r	a5, 8e3e88 <bStandardCommand+0x24>
  9097b1:	8750      	l32i.n	a7, a5, 0
  9097b3:	697005        	bnei	a7, -1, 9097bc <ath_tgt_attach+0x1e0>
		ath_numrxbufs = ATH_RXBUF;
  9097b6:	270a14        	movi	a7, 20
  9097b9:	275600        	s32i	a7, a5, 0

	if (ath_numrxdescs == -1)
  9097bc:	1769dd        	l32r	a7, 8e3f30 <bStandardCommand+0xcc>
  9097bf:	8570      	l32i.n	a5, a7, 0
  9097c1:	695003        	bnei	a5, -1, 9097c8 <ath_tgt_attach+0x1ec>
		ath_numrxdescs = ATH_RXDESC;
  9097c4:	c154      	movi.n	a5, 20
  9097c6:	9570      	s32i.n	a5, a7, 0

	error = ath_descdma_setup(sc, &sc->sc_rxdma, (ath_bufhead *)&sc->sc_rxbuf,
  9097c8:	253a74        	movi	a5, 0x374
  9097cb:	a535      	add.n	a5, a3, a5
  9097cd:	251610        	s32i	a5, a1, 64
  9097d0:	253a54        	movi	a5, 0x354
  9097d3:	a535      	add.n	a5, a3, a5
  9097d5:	c584      	movi.n	a8, 84
  9097d7:	251611        	s32i	a5, a1, 68
  9097da:	9810      	s32i.n	a8, a1, 0
  9097dc:	251a18        	movi	a5, 0x118
  9097df:	a535      	add.n	a5, a3, a5
  9097e1:	8e70      	l32i.n	a14, a7, 0
  9097e3:	1d69de        	l32r	a13, 8e3f5c <bStandardCommand+0xf8>
  9097e6:	2c1211        	l32i	a12, a1, 68
  9097e9:	2b1210        	l32i	a11, a1, 64
  9097ec:	2f0a68        	movi	a15, 104
  9097ef:	da50      	mov.n	a10, a5
  9097f1:	5bfa47        	call8	908110 <ath_descdma_setup$isra$22$constprop$28>
				  "rx", ath_numrxdescs, 1,
				  sizeof(struct ath_rx_buf),
				  sizeof(struct ath_rx_desc));
	if (error != 0)
  9097f4:	65a229        	bnez	a10, 909a21 <ath_tgt_attach+0x445>
	a_uint32_t i;
	struct ath_descdma *dd = &sc->sc_rxdma;
	struct ath_rx_desc *ds = (struct ath_rx_desc *)dd->dd_desc;
	struct ath_rx_desc *ds_prev = NULL;

	asf_tailq_init(&sc->sc_rxdesc);
  9097f7:	283a64        	movi	a8, 0x364
  9097fa:	a838      	add.n	a8, a3, a8
  9097fc:	2836da        	s32i	a8, a3, 0x368
	asf_tailq_init(&sc->sc_rxdesc_idle);
  9097ff:	283a5c        	movi	a8, 0x35c
  909802:	a838      	add.n	a8, a3, a8
  909804:	2836d8        	s32i	a8, a3, 0x360
	if (error != 0)
		return error;

	a_uint32_t i;
	struct ath_descdma *dd = &sc->sc_rxdma;
	struct ath_rx_desc *ds = (struct ath_rx_desc *)dd->dd_desc;
  909807:	2732de        	l32i	a7, a3, 0x378
	struct ath_rx_desc *ds_prev = NULL;

	asf_tailq_init(&sc->sc_rxdesc);
  90980a:	2a36d9        	s32i	a10, a3, 0x364
	asf_tailq_init(&sc->sc_rxdesc_idle);
  90980d:	2a36d7        	s32i	a10, a3, 0x35c
		return error;

	a_uint32_t i;
	struct ath_descdma *dd = &sc->sc_rxdma;
	struct ath_rx_desc *ds = (struct ath_rx_desc *)dd->dd_desc;
	struct ath_rx_desc *ds_prev = NULL;
  909810:	d8a0      	mov.n	a8, a10

	asf_tailq_init(&sc->sc_rxdesc);
	asf_tailq_init(&sc->sc_rxdesc_idle);

	for (i = 0; i < ath_numrxdescs; i++, ds++) {
  909812:	dca0      	mov.n	a12, a10
  909814:	6000d6        	j	9098ee <ath_tgt_attach+0x312>
  909817:	00002a        	muluh	a0, a0, a0

		if (ds->ds_nbuf != ADF_NBUF_NULL) {
  90981a:	703429        	ball	a3, a0, 909847 <ath_tgt_attach+0x26b>
  90981d:	703508        	bbc	a3, a0, 909829 <ath_tgt_attach+0x24d>
  909820:	aa10      	add.n	a0, a1, a10
  909822:	009911        	slli	a9, a9, 16
  909825:	0a9a02        	or	a10, a9, a10
  909828:	297036        	l8ui	a9, a7, 54
  90982b:	089911        	slli	a9, a9, 8
  90982e:	0a9902        	or	a9, a9, a10
  909831:	2a7037        	l8ui	a10, a7, 55
  909834:	09a902        	or	a9, a10, a9
  909837:	64900e        	beqz	a9, 909849 <ath_tgt_attach+0x26d>
			ds->ds_nbuf = ADF_NBUF_NULL;
  90983a:	290a00        	movi	a9, 0
  90983d:	297434        	s8i	a9, a7, 52
  909840:	297435        	s8i	a9, a7, 53
  909843:	297436        	s8i	a9, a7, 54
  909846:	297437        	s8i	a9, a7, 55
 */
static inline a_status_t
adf_nbuf_dmamap_create(adf_os_device_t osdev,
                       adf_os_dma_map_t *dmap)
{
    return (__adf_nbuf_dmamap_create(osdev, dmap));
  909849:	2a3246        	l32i	a10, a3, 0x118
  90984c:	2b7c38        	addi	a11, a7, 56
  90984f:	281613        	s32i	a8, a1, 76
  909852:	2c1612        	s32i	a12, a1, 72
  909855:	5bf47f        	call8	906a54 <__adf_nbuf_dmamap_create>
		}

		if (adf_nbuf_dmamap_create(sc->sc_dev, &ds->ds_dmap) != A_STATUS_OK) {
  909858:	281213        	l32i	a8, a1, 76
  90985b:	2c1212        	l32i	a12, a1, 72
  90985e:	64a01a        	beqz	a10, 90987c <ath_tgt_attach+0x2a0>
			adf_os_assert(0);
  909861:	296212        	l32i	a9, a6, 72
  909864:	1b69df        	l32r	a11, 8e3fe0 <bStandardCommand+0x17c>
  909867:	1a69a0        	l32r	a10, 8e3ee8 <bStandardCommand+0x84>
  90986a:	0b9000        	callx8	a9
  90986d:	196923        	l32r	a9, 8e3cfc <bSet_configuration+0x1a8>
  909870:	2c1212        	l32i	a12, a1, 72
  909873:	0c0200        	memw
  909876:	299200        	l32i	a9, a9, 0
  909879:	281213        	l32i	a8, a1, 76
		}

		ds->ds_daddr = DS2PHYS(&sc->sc_rxdma, ds);
  90987c:	2932de        	l32i	a9, a3, 0x378
  90987f:	2a32e0        	l32i	a10, a3, 0x380
  909882:	09790c        	sub	a9, a7, a9
  909885:	aa99      	add.n	a9, a9, a10
  909887:	098d57        	extui	a13, a9, 24, 8
  90988a:	090b57        	extui	a11, a9, 16, 8
  90988d:	098a47        	extui	a10, a9, 8, 8
  909890:	090947        	extui	a9, a9, 0, 8
  909893:	2d7448        	s8i	a13, a7, 72
  909896:	2b7449        	s8i	a11, a7, 73
  909899:	2a744a        	s8i	a10, a7, 74
  90989c:	29744b        	s8i	a9, a7, 75

		if (ds_prev) {
  90989f:	c88a      	beqz.n	a8, 9098ad <ath_tgt_attach+0x2d1>
			ds_prev->ds_link = ds->ds_daddr;
  9098a1:	2d8400        	s8i	a13, a8, 0
  9098a4:	2b8401        	s8i	a11, a8, 1
  9098a7:	2a8402        	s8i	a10, a8, 2
  9098aa:	298403        	s8i	a9, a8, 3
		}

		ds->ds_link = 0;
  9098ad:	c080      	movi.n	a8, 0
  9098af:	287400        	s8i	a8, a7, 0
  9098b2:	287401        	s8i	a8, a7, 1
  9098b5:	287402        	s8i	a8, a7, 2
  9098b8:	287403        	s8i	a8, a7, 3
		ds_prev = ds;

		asf_tailq_insert_tail(&sc->sc_rxdesc, ds, ds_list);
  9098bb:	28744c        	s8i	a8, a7, 76
  9098be:	28744d        	s8i	a8, a7, 77
  9098c1:	28744e        	s8i	a8, a7, 78
  9098c4:	28744f        	s8i	a8, a7, 79
  9098c7:	2832da        	l32i	a8, a3, 0x368
	struct ath_rx_desc *ds_prev = NULL;

	asf_tailq_init(&sc->sc_rxdesc);
	asf_tailq_init(&sc->sc_rxdesc_idle);

	for (i = 0; i < ath_numrxdescs; i++, ds++) {
  9098ca:	b1cc      	addi.n	a12, a12, 1
		}

		ds->ds_link = 0;
		ds_prev = ds;

		asf_tailq_insert_tail(&sc->sc_rxdesc, ds, ds_list);
  9098cc:	088957        	extui	a9, a8, 24, 8
  9098cf:	297450        	s8i	a9, a7, 80
  9098d2:	080957        	extui	a9, a8, 16, 8
  9098d5:	297451        	s8i	a9, a7, 81
  9098d8:	088947        	extui	a9, a8, 8, 8
  9098db:	287453        	s8i	a8, a7, 83
  9098de:	297452        	s8i	a9, a7, 82
  9098e1:	9780      	s32i.n	a7, a8, 0
  9098e3:	287c4c        	addi	a8, a7, 76
  9098e6:	2836da        	s32i	a8, a3, 0x368
	struct ath_rx_desc *ds_prev = NULL;

	asf_tailq_init(&sc->sc_rxdesc);
	asf_tailq_init(&sc->sc_rxdesc_idle);

	for (i = 0; i < ath_numrxdescs; i++, ds++) {
  9098e9:	d870      	mov.n	a8, a7
  9098eb:	277c54        	addi	a7, a7, 84
  9098ee:	1a69dd        	l32r	a10, 8e4064 <bStandardCommand+0x200>
  9098f1:	89a0      	l32i.n	a9, a10, 0
  9098f3:	79cb02        	bgeu	a12, a9, 9098f9 <ath_tgt_attach+0x31d>
  9098f6:	63ff1f        	j	909819 <ath_tgt_attach+0x23d>
		ds_prev = ds;

		asf_tailq_insert_tail(&sc->sc_rxdesc, ds, ds_list);
	}

	error = ath_descdma_setup(sc, &sc->sc_txdma, (ath_bufhead *)&sc->sc_txbuf,
  9098f9:	263a8c        	movi	a6, 0x38c
  9098fc:	273ac0        	movi	a7, 0x3c0
  9098ff:	290a88        	movi	a9, 136
  909902:	a636      	add.n	a6, a3, a6
  909904:	a737      	add.n	a7, a3, a7
  909906:	1d69e0        	l32r	a13, 8e4088 <bStandardCommand+0x224>
  909909:	9910      	s32i.n	a9, a1, 0
  90990b:	2f0a94        	movi	a15, 148
  90990e:	c2ee      	movi.n	a14, 46
  909910:	dc70      	mov.n	a12, a7
  909912:	db60      	mov.n	a11, a6
  909914:	da50      	mov.n	a10, a5
  909916:	291612        	s32i	a9, a1, 72
  909919:	5bf9fd        	call8	908110 <ath_descdma_setup$isra$22$constprop$28>
  90991c:	d8a0      	mov.n	a8, a10
				  "tx", ATH_TXBUF + 1, ATH_TXDESC,
				  sizeof(struct ath_tx_buf),
				  sizeof(struct ath_tx_desc));
	if (error != 0) {
  90991e:	291212        	l32i	a9, a1, 72
  909921:	c8a3      	beqz.n	a10, 909928 <ath_tgt_attach+0x34c>
  909923:	60002d        	j	909954 <ath_tgt_attach+0x378>
  909926:	00001c        	mul16u	a0, a0, a0
		ath_descdma_cleanup(sc, &sc->sc_rxdma, (ath_bufhead *)&sc->sc_rxbuf,
				    ADF_OS_DMA_FROM_DEVICE);
		return error;
	}

	error = ath_descdma_setup(sc, &sc->sc_bdma, (ath_bufhead *)&sc->sc_bbuf,
  909929:	69e21d        	bnei	a14, 2, 90994a <ath_tgt_attach+0x36e>
  90992c:	69e12b        	bnei	a14, 1, 90995b <ath_tgt_attach+0x37f>
  90992f:	3aa499        	excw
  909932:	102f0a        	l32r	a0, 8d555c <_bss_end+0x3c264c>
  909935:	94c0      	s32i.n	a4, a12, 0
  909937:	e1          	.byte 0xe1
  909938:	ac3c      	add.n	a12, a3, a12
  90993a:	ab3b      	add.n	a11, a3, a11
  90993c:	da50      	mov.n	a10, a5
  90993e:	281613        	s32i	a8, a1, 76
  909941:	5bf9f3        	call8	908110 <ath_descdma_setup$isra$22$constprop$28>
				  "beacon", ATH_BCBUF, 1,
				  sizeof(struct ath_tx_buf),
				  sizeof(struct ath_tx_desc));
	if (error != 0) {
  909944:	281213        	l32i	a8, a1, 76
  909947:	c9a9      	beqz.n	a10, 909964 <ath_tgt_attach+0x388>
		ath_descdma_cleanup(sc, &sc->sc_txdma, (ath_bufhead *)&sc->sc_txbuf,
  909949:	dd80      	mov.n	a13, a8
  90994b:	dc70      	mov.n	a12, a7
  90994d:	db60      	mov.n	a11, a6
  90994f:	da30      	mov.n	a10, a3
  909951:	5bf894        	call8	907ba4 <ath_descdma_cleanup>
				    ADF_OS_DMA_TO_DEVICE);
		ath_descdma_cleanup(sc, &sc->sc_rxdma, (ath_bufhead *)&sc->sc_rxbuf,
  909954:	2c1211        	l32i	a12, a1, 68
  909957:	2b1210        	l32i	a11, a1, 64
  90995a:	c0d1      	movi.n	a13, 1
  90995c:	da30      	mov.n	a10, a3
  90995e:	5bf891        	call8	907ba4 <ath_descdma_cleanup>
  909961:	6000bc        	j	909a21 <ath_tgt_attach+0x445>
				    ADF_OS_DMA_FROM_DEVICE);
		return error;
	}

	bf = asf_tailq_first(&sc->sc_txbuf);
  909964:	2532f0        	l32i	a5, a3, 0x3c0
	bf->bf_isaggr = bf->bf_isretried = bf->bf_retries = 0;
  909967:	c67f      	movi.n	a7, -17
  909969:	265087        	l8ui	a6, a5, 135
  90996c:	2a5486        	s8i	a10, a5, 134
  90996f:	076601        	and	a6, a6, a7
  909972:	27fadf        	movi	a7, -33
  909975:	076601        	and	a6, a6, a7
  909978:	265487        	s8i	a6, a5, 135
	asf_tailq_remove(&sc->sc_txbuf, bf, bf_list);
  90997b:	8659      	l32i.n	a6, a5, 36
  90997d:	875a      	l32i.n	a7, a5, 40
  90997f:	c866      	beqz.n	a6, 909989 <ath_tgt_attach+0x3ad>
  909981:	976a      	s32i.n	a7, a6, 40
  909983:	600005        	j	90998c <ath_tgt_attach+0x3b0>
  909986:	000000        	ill
  909989:	2736f1        	s32i	a7, a3, 0x3c4
  90998c:	875a      	l32i.n	a7, a5, 40
	error = ath_desc_alloc(sc);
	if (error != 0) {
		goto bad;
	}

	BUF_Pool_create_pool(sc->pool_handle, POOL_ID_WLAN_RX_BUF, ath_numrxdescs, 1664);
  90998e:	c0b3      	movi.n	a11, 3
		return error;
	}

	bf = asf_tailq_first(&sc->sc_txbuf);
	bf->bf_isaggr = bf->bf_isretried = bf->bf_retries = 0;
	asf_tailq_remove(&sc->sc_txbuf, bf, bf_list);
  909990:	9670      	s32i.n	a6, a7, 0

	sc->sc_txbuf_held = bf;
  909992:	2536dc        	s32i	a5, a3, 0x370
	error = ath_desc_alloc(sc);
	if (error != 0) {
		goto bad;
	}

	BUF_Pool_create_pool(sc->pool_handle, POOL_ID_WLAN_RX_BUF, ath_numrxdescs, 1664);
  909995:	1669dd        	l32r	a6, 8e410c <bStandardCommand+0x2a8>
  909998:	1568bf        	l32r	a5, 8e3c94 <bSet_configuration+0x140>
  90999b:	8c60      	l32i.n	a12, a6, 0
  90999d:	25529b        	l32i	a5, a5, 0x26c
  9099a0:	8a30      	l32i.n	a10, a3, 0
  9099a2:	2d6a80        	movi	a13, 0x680
  9099a5:	0b5000        	callx8	a5
  9099a8:	c060      	movi.n	a6, 0
  9099aa:	253acc        	movi	a5, 0x3cc
  9099ad:	a535      	add.n	a5, a3, a5
	a_int32_t qnum;
	struct ath_txq *txq;

	sc->sc_txqsetup=0;

	for (qnum=0;qnum<HAL_NUM_TX_QUEUES;qnum++) {
  9099af:	d860      	mov.n	a8, a6
		txq= &sc->sc_txq[qnum];
		txq->axq_qnum = qnum;
		txq->axq_link = NULL;
  9099b1:	d760      	mov.n	a7, a6
		asf_tailq_init(&txq->axq_q);
		txq->axq_depth = 0;
		txq->axq_linkbuf = NULL;
		asf_tailq_init(&txq->axq_tidq);
		sc->sc_txqsetup |= 1<<qnum;
  9099b3:	c0b1      	movi.n	a11, 1
  9099b5:	c09a      	movi.n	a9, 10
  9099b7:	6d9825        	loop	a9, 9099e0 <ath_tgt_attach+0x404>

	for (qnum=0;qnum<HAL_NUM_TX_QUEUES;qnum++) {
		txq= &sc->sc_txq[qnum];
		txq->axq_qnum = qnum;
		txq->axq_link = NULL;
		asf_tailq_init(&txq->axq_q);
  9099ba:	b85a      	addi.n	a10, a5, 8
  9099bc:	9a53      	s32i.n	a10, a5, 12
		txq->axq_depth = 0;
		txq->axq_linkbuf = NULL;
		asf_tailq_init(&txq->axq_tidq);
  9099be:	2a5c18        	addi	a10, a5, 24
  9099c1:	9a57      	s32i.n	a10, a5, 28
		sc->sc_txqsetup |= 1<<qnum;
  9099c3:	008104        	ssl	a8
  9099c6:	00ba1a        	sll	a10, a11

	sc->sc_txqsetup=0;

	for (qnum=0;qnum<HAL_NUM_TX_QUEUES;qnum++) {
		txq= &sc->sc_txq[qnum];
		txq->axq_qnum = qnum;
  9099c9:	9850      	s32i.n	a8, a5, 0
		txq->axq_link = NULL;
  9099cb:	9751      	s32i.n	a7, a5, 4
		asf_tailq_init(&txq->axq_q);
  9099cd:	9752      	s32i.n	a7, a5, 8
		txq->axq_depth = 0;
  9099cf:	9754      	s32i.n	a7, a5, 16
		txq->axq_linkbuf = NULL;
  9099d1:	9755      	s32i.n	a7, a5, 20
		asf_tailq_init(&txq->axq_tidq);
  9099d3:	9756      	s32i.n	a7, a5, 24
		sc->sc_txqsetup |= 1<<qnum;
  9099d5:	06a602        	or	a6, a10, a6
  9099d8:	060647        	extui	a6, a6, 0, 8
	a_int32_t qnum;
	struct ath_txq *txq;

	sc->sc_txqsetup=0;

	for (qnum=0;qnum<HAL_NUM_TX_QUEUES;qnum++) {
  9099db:	b188      	addi.n	a8, a8, 1
  9099dd:	255c20        	addi	a5, a5, 32
  9099e0:	253d03        	addmi	a5, a3, 0x300
  9099e3:	2654c8        	s8i	a6, a5, 200
		txq->axq_linkbuf = NULL;
		asf_tailq_init(&txq->axq_tidq);
		sc->sc_txqsetup |= 1<<qnum;
	}

	sc->sc_uapsdq  = &sc->sc_txq[UAPSDQ_NUM];
  9099e6:	254aec        	movi	a5, 0x4ec
  9099e9:	a535      	add.n	a5, a3, a5
  9099eb:	952d      	s32i.n	a5, a2, 52
	sc->sc_cabq    = &sc->sc_txq[CABQ_NUM];
  9099ed:	254acc        	movi	a5, 0x4cc
  9099f0:	a535      	add.n	a5, a3, a5
  9099f2:	952c      	s32i.n	a5, a2, 48

	sc->sc_ac2q[WME_AC_BE]  = &sc->sc_txq[0];
  9099f4:	253acc        	movi	a5, 0x3cc
  9099f7:	a535      	add.n	a5, a3, a5
  9099f9:	9523      	s32i.n	a5, a2, 12
	sc->sc_ac2q[WME_AC_BK]  = &sc->sc_txq[1];
  9099fb:	253aec        	movi	a5, 0x3ec
  9099fe:	a535      	add.n	a5, a3, a5
  909a00:	9524      	s32i.n	a5, a2, 16
	sc->sc_ac2q[WME_AC_VI]  = &sc->sc_txq[2];
  909a02:	254a0c        	movi	a5, 0x40c
  909a05:	a535      	add.n	a5, a3, a5
  909a07:	9525      	s32i.n	a5, a2, 20
	sc->sc_ac2q[WME_AC_VO]  = &sc->sc_txq[3];
  909a09:	254a2c        	movi	a5, 0x42c
  909a0c:	a535      	add.n	a5, a3, a5
  909a0e:	9526      	s32i.n	a5, a2, 24

	BUF_Pool_create_pool(sc->pool_handle, POOL_ID_WLAN_RX_BUF, ath_numrxdescs, 1664);

	ath_tgt_txq_setup(sc);
	sc->sc_imask =0;
	ah->ah_setInterrupts(ah, 0);
  909a10:	224228        	l32i	a2, a4, 160
	}

	BUF_Pool_create_pool(sc->pool_handle, POOL_ID_WLAN_RX_BUF, ath_numrxdescs, 1664);

	ath_tgt_txq_setup(sc);
	sc->sc_imask =0;
  909a13:	2736c4        	s32i	a7, a3, 0x310
	ah->ah_setInterrupts(ah, 0);
  909a16:	c0b0      	movi.n	a11, 0
  909a18:	da40      	mov.n	a10, a4
  909a1a:	0b2000        	callx8	a2

	return 0;
  909a1d:	c020      	movi.n	a2, 0
  909a1f:	d10f      	retw.n
bad:
bad2:
	ath_desc_free(sc);
  909a21:	da30      	mov.n	a10, a3
  909a23:	5bf9a8        	call8	9080c4 <ath_desc_free>
	if (ah)
		ah->ah_detach(ah);
  909a26:	8246      	l32i.n	a2, a4, 24
  909a28:	da40      	mov.n	a10, a4
  909a2a:	0b2000        	callx8	a2
}
  909a2d:	d10f      	retw.n
  909a2f:	00da30        	excw
	ah->ah_setInterrupts(ah, 0);

	return 0;
bad:
bad2:
	ath_desc_free(sc);
  909a32:	5bf9a4        	call8	9080c4 <ath_desc_free>
  909a35:	63fff4        	j	909a2d <ath_tgt_attach+0x451>

00909a38 <ath_detach>:
	HIF_shutdown(sc->tgt_hif_handle);
	BUF_Pool_shutdown(sc->pool_handle);
}

a_int32_t ath_detach(struct ath_softc_tgt *sc)
{
  909a38:	6c1004        	entry	a1, 32

static void tgt_hif_htc_wmi_shutdown(struct ath_softc_tgt *sc)
{
	HTC_NotifyTargetDetached(sc->tgt_htc_handle);

	WMI_Shutdown(sc->tgt_wmi_handle);
  909a3b:	1368bf        	l32r	a3, 8e3d38 <bSet_configuration+0x1e4>
  909a3e:	8a23      	l32i.n	a10, a2, 12
  909a40:	283292        	l32i	a8, a3, 0x248
  909a43:	0b8000        	callx8	a8
	HTC_Shutdown(sc->tgt_htc_handle);
  909a46:	8a22      	l32i.n	a10, a2, 8
  909a48:	28327f        	l32i	a8, a3, 0x1fc
  909a4b:	0b8000        	callx8	a8
	HIF_shutdown(sc->tgt_hif_handle);
  909a4e:	8a21      	l32i.n	a10, a2, 4
  909a50:	283271        	l32i	a8, a3, 0x1c4
  909a53:	0b8000        	callx8	a8
	BUF_Pool_shutdown(sc->pool_handle);
  909a56:	8a20      	l32i.n	a10, a2, 0
  909a58:	23329a        	l32i	a3, a3, 0x268
  909a5b:	0b3000        	callx8	a3
}

a_int32_t ath_detach(struct ath_softc_tgt *sc)
{
	tgt_hif_htc_wmi_shutdown(sc);
}
  909a5e:	d10f      	retw.n

00909a60 <wlan_pci_module_init>:
adf_drv_info_t* g_wlan_drv = NULL;
adf_drv_handle_t g_wlan_drv_handle = NULL;
adf_os_drv_intr g_wlan_intr = NULL;

void wlan_pci_module_init(void)
{
  909a60:	6c1004        	entry	a1, 32
	if (g_pci_init_func != NULL) {
  909a63:	1869e3        	l32r	a8, 8e41f0 <bStandardCommand+0x38c>
  909a66:	8a80      	l32i.n	a10, a8, 0
  909a68:	c8a1      	beqz.n	a10, 909a6d <wlan_pci_module_init+0xd>
		g_pci_init_func();
  909a6a:	0ba000        	callx8	a10
  909a6d:	d10f      	retw.n
	...

00909a70 <wlan_pci_register_drv>:
	}
}

void wlan_pci_register_drv(adf_drv_info_t *drv)
{
  909a70:	6c1004        	entry	a1, 32
	g_wlan_drv = drv;
  909a73:	1869e4        	l32r	a8, 8e4204 <bStandardCommand+0x3a0>
  909a76:	9280      	s32i.n	a2, a8, 0
  909a78:	d10f      	retw.n
	...

00909a7c <wlan_pci_config_write>:
mem_fail:
	return;        
}

int wlan_pci_config_write(int offset, a_uint32_t val, int width)
{
  909a7c:	6c1006        	entry	a1, 48
#if MAGPIE_ENABLE_PCIE == 1    
	unsigned long addr = ( PCI_CONFIG_BASE_ADDR + offset ) & 0xfffffffc;
  909a7f:	1869e5        	l32r	a8, 8e4214 <bStandardCommand+0x3b0>
  909a82:	c7ac      	movi.n	a10, -4
  909a84:	a828      	add.n	a8, a2, a8
  909a86:	0a8801        	and	a8, a8, a10
	A_UINT8 *ptr = (A_UINT8 *)addr;   
	A_UINT8 *valptr = (A_UINT8 *)&val; 
	int idx = offset & 0x3;
  909a89:	020241        	extui	a2, a2, 0, 2
  909a8c:	028202        	or	a2, a8, a2
mem_fail:
	return;        
}

int wlan_pci_config_write(int offset, a_uint32_t val, int width)
{
  909a8f:	9310      	s32i.n	a3, a1, 0
  909a91:	d910      	mov.n	a9, a1
	A_UINT8 *ptr = (A_UINT8 *)addr;   
	A_UINT8 *valptr = (A_UINT8 *)&val; 
	int idx = offset & 0x3;
	int i;
    
	for (i = 0; i < width; i++) {
  909a93:	d820      	mov.n	a8, a2
  909a95:	600007        	j	909aa0 <wlan_pci_config_write+0x24>
		ptr[idx + i] = valptr[3-i];
  909a98:	2a9004        	l8ui	a10, a9, 4
  909a9b:	2a8400        	s8i	a10, a8, 0
  909a9e:	b188      	addi.n	a8, a8, 1
	A_UINT8 *ptr = (A_UINT8 *)addr;   
	A_UINT8 *valptr = (A_UINT8 *)&val; 
	int idx = offset & 0x3;
	int i;
    
	for (i = 0; i < width; i++) {
  909aa0:	028a0c        	sub	a10, a8, a2
  909aa3:	b099      	addi.n	a9, a9, -1
  909aa5:	74a2ef        	blt	a10, a4, 909a98 <wlan_pci_config_write+0x1c>
		ptr[idx + i] = valptr[3-i];
	}            
#endif
    
	return 0;    
}
  909aa8:	c020      	movi.n	a2, 0
  909aaa:	d10f      	retw.n

00909aac <wlan_pci_config_read>:

int wlan_pci_config_read(int offset, int width)
{
  909aac:	6c1006        	entry	a1, 48
#if MAGPIE_ENABLE_PCIE == 0    
	return 0;    
#else
	unsigned long addr = ( PCI_CONFIG_BASE_ADDR + offset ) & 0xfffffffc;
  909aaf:	1969e5        	l32r	a9, 8e4244 <bStandardCommand+0x3e0>
  909ab2:	c78c      	movi.n	a8, -4
  909ab4:	a929      	add.n	a9, a2, a9
  909ab6:	089901        	and	a9, a9, a8
	unsigned long value = *((unsigned long *)addr);
  909ab9:	8890      	l32i.n	a8, a9, 0
	A_UINT8 *ptr = (A_UINT8 *)&value;   
	int idx = offset & 0x3;
	int result = 0;
	int i;
    
	for (i = 0; i < width; i++) {
  909abb:	c090      	movi.n	a9, 0
{
#if MAGPIE_ENABLE_PCIE == 0    
	return 0;    
#else
	unsigned long addr = ( PCI_CONFIG_BASE_ADDR + offset ) & 0xfffffffc;
	unsigned long value = *((unsigned long *)addr);
  909abd:	9810      	s32i.n	a8, a1, 0
  909abf:	c78f      	movi.n	a8, -1
  909ac1:	028803        	xor	a8, a8, a2
  909ac4:	080841        	extui	a8, a8, 0, 2
  909ac7:	a818      	add.n	a8, a1, a8
	A_UINT8 *ptr = (A_UINT8 *)&value;   
	int idx = offset & 0x3;
	int result = 0;
  909ac9:	d290      	mov.n	a2, a9
	int i;
    
	for (i = 0; i < width; i++) {
  909acb:	600014        	j	909ae3 <wlan_pci_config_read+0x37>
  909ace:	00002a        	muluh	a0, a0, a0
		result |= (ptr[ 3 - (idx + i)] << (8*i));
  909ad1:	8000      	l32i.n	a0, a0, 0
  909ad3:	0d9b11        	slli	a11, a9, 3
  909ad6:	00b104        	ssl	a11
  909ad9:	00aa1a        	sll	a10, a10
  909adc:	0a2202        	or	a2, a2, a10
	A_UINT8 *ptr = (A_UINT8 *)&value;   
	int idx = offset & 0x3;
	int result = 0;
	int i;
    
	for (i = 0; i < width; i++) {
  909adf:	b199      	addi.n	a9, a9, 1
  909ae1:	b088      	addi.n	a8, a8, -1
  909ae3:	7392e9        	blt	a9, a3, 909ad0 <wlan_pci_config_read+0x24>
		result |= (ptr[ 3 - (idx + i)] << (8*i));
	}            
    
	return result;    
#endif    
}
  909ae6:	d10f      	retw.n

00909ae8 <wlan_pci_probe>:

#define ATHEROS_VENDOR_ID 0x168c
#define AR5416_DEVID_PCIE 0x24 	

void wlan_pci_probe(void)
{
  909ae8:	6c100a        	entry	a1, 80
	__adf_softc_t           *sc;
	adf_os_resource_t       drv_res = {0};
  909aeb:	c1c8      	movi.n	a12, 24
  909aed:	2b0a00        	movi	a11, 0
  909af0:	011a02        	or	a10, a1, a1
  909af3:	5b74d5        	call8	8e6e48 <memset>
	adf_os_attach_data_t    drv_data = {{0}};   
  909af6:	c1c0      	movi.n	a12, 16
  909af8:	2b0a00        	movi	a11, 0
  909afb:	2a1c18        	addi	a10, a1, 24
  909afe:	5b74d2        	call8	8e6e48 <memset>
	int vendor_id;
	int device_id;

	A_PRINTF("<wlan_pci_probe>: Attaching the driver\n");
  909b01:	1268bf        	l32r	a2, 8e3e00 <bSet_configuration+0x2ac>
  909b04:	1a69e6        	l32r	a10, 8e429c <bStandardCommand+0x438>
  909b07:	232212        	l32i	a3, a2, 72
  909b0a:	0b3000        	callx8	a3

#if MAGPIE_ENABLE_PCIE == 0
	vendor_id = ATHEROS_VENDOR_ID;
	device_id = AR5416_DEVID_PCIE;
#else    
	vendor_id = wlan_pci_config_read(0, 2);
  909b0d:	c0b2      	movi.n	a11, 2
  909b0f:	c0a0      	movi.n	a10, 0
  909b11:	5bffe6        	call8	909aac <wlan_pci_config_read>
	device_id = wlan_pci_config_read(2, 2);
  909b14:	c0b2      	movi.n	a11, 2

#if MAGPIE_ENABLE_PCIE == 0
	vendor_id = ATHEROS_VENDOR_ID;
	device_id = AR5416_DEVID_PCIE;
#else    
	vendor_id = wlan_pci_config_read(0, 2);
  909b16:	d3a0      	mov.n	a3, a10
	device_id = wlan_pci_config_read(2, 2);
  909b18:	dab0      	mov.n	a10, a11
  909b1a:	5bffe4        	call8	909aac <wlan_pci_config_read>
#endif    
	A_PRINTF("<wlan_pci_probe>: Vendor id 0x%x Dev id 0x%x\n", vendor_id, device_id);    
  909b1d:	282212        	l32i	a8, a2, 72
  909b20:	0aac02        	or	a12, a10, a10
  909b23:	1a69e7        	l32r	a10, 8e42c0 <bStandardCommand+0x45c>
  909b26:	033b02        	or	a11, a3, a3
  909b29:	0b8000        	callx8	a8
    
	if (vendor_id != ATHEROS_VENDOR_ID) {
  909b2c:	1869e8        	l32r	a8, 8e42cc <bStandardCommand+0x468>
  909b2f:	783109        	beq	a3, a8, 909b3c <wlan_pci_probe+0x54>
		A_PRINTF("<wlan_pci_probe>: Atheros card not found\n"); 
  909b32:	222212        	l32i	a2, a2, 72
  909b35:	1a69e9        	l32r	a10, 8e42dc <bStandardCommand+0x478>
  909b38:	600012        	j	909b4e <wlan_pci_probe+0x66>
  909b3b:	002822        	excw
	}
            
	/**
	 * Allocate the sc & zero down
	 */
	sc = A_ALLOCRAM(sizeof(__adf_softc_t));
  909b3e:	52c0b4        	call0	8b9e10 <_bss_end+0x3a6f00>
  909b41:	c0a0      	movi.n	a10, 0
  909b43:	0b8000        	callx8	a8
	if (!sc) {
  909b46:	ccaa      	bnez.n	a10, 909b54 <wlan_pci_probe+0x6c>
		A_PRINTF("Cannot malloc softc\n");
  909b48:	222212        	l32i	a2, a2, 72
  909b4b:	1a69ea        	l32r	a10, 8e42f4 <bStandardCommand+0x490>
  909b4e:	0b2000        	callx8	a2
        
	g_wlan_drv_handle = g_wlan_drv->drv_attach(&drv_res, 1, &drv_data, NULL);
        
	return;
mem_fail:
	return;        
  909b51:	d10f      	retw.n
  909b53:	00c224        	excw
		goto mem_fail;
	}
    
#define AR5416_DEVID_PCIE 0x24 		

	drv_data.pci.device    = AR5416_DEVID_PCIE;
  909b56:	9217      	s32i.n	a2, a1, 28
	drv_data.pci.vendor    = 0x168c;
	drv_data.pci.subvendor = 0;
	drv_data.pci.subdevice = 0;
    
	drv_res.start  = (a_uint32_t) 0;
  909b58:	1269eb        	l32r	a2, 8e4304 <bStandardCommand+0x4a0>
    
#define AR5416_DEVID_PCIE 0x24 		

	drv_data.pci.device    = AR5416_DEVID_PCIE;
	drv_data.pci.vendor    = 0x168c;
	drv_data.pci.subvendor = 0;
  909b5b:	c0d0      	movi.n	a13, 0
	drv_data.pci.subdevice = 0;
    
	drv_res.start  = (a_uint32_t) 0;
  909b5d:	9210      	s32i.n	a2, a1, 0
	drv_res.end    = 0;
  909b5f:	9212      	s32i.n	a2, a1, 8
	drv_res.type   = ADF_OS_RESOURCE_TYPE_MEM;
        
	g_wlan_drv_handle = g_wlan_drv->drv_attach(&drv_res, 1, &drv_data, NULL);
  909b61:	1269e4        	l32r	a2, 8e42f4 <bStandardCommand+0x490>
	}
    
#define AR5416_DEVID_PCIE 0x24 		

	drv_data.pci.device    = AR5416_DEVID_PCIE;
	drv_data.pci.vendor    = 0x168c;
  909b64:	9316      	s32i.n	a3, a1, 24
    
	drv_res.start  = (a_uint32_t) 0;
	drv_res.end    = 0;
	drv_res.type   = ADF_OS_RESOURCE_TYPE_MEM;
        
	g_wlan_drv_handle = g_wlan_drv->drv_attach(&drv_res, 1, &drv_data, NULL);
  909b66:	8220      	l32i.n	a2, a2, 0
	drv_data.pci.device    = AR5416_DEVID_PCIE;
	drv_data.pci.vendor    = 0x168c;
	drv_data.pci.subvendor = 0;
	drv_data.pci.subdevice = 0;
    
	drv_res.start  = (a_uint32_t) 0;
  909b68:	1369eb        	l32r	a3, 8e4314 <bStandardCommand+0x4b0>
    
#define AR5416_DEVID_PCIE 0x24 		

	drv_data.pci.device    = AR5416_DEVID_PCIE;
	drv_data.pci.vendor    = 0x168c;
	drv_data.pci.subvendor = 0;
  909b6b:	9d18      	s32i.n	a13, a1, 32
	drv_data.pci.subdevice = 0;
  909b6d:	9d19      	s32i.n	a13, a1, 36
    
	drv_res.start  = (a_uint32_t) 0;
	drv_res.end    = 0;
	drv_res.type   = ADF_OS_RESOURCE_TYPE_MEM;
        
	g_wlan_drv_handle = g_wlan_drv->drv_attach(&drv_res, 1, &drv_data, NULL);
  909b6f:	8220      	l32i.n	a2, a2, 0
	drv_data.pci.device    = AR5416_DEVID_PCIE;
	drv_data.pci.vendor    = 0x168c;
	drv_data.pci.subvendor = 0;
	drv_data.pci.subdevice = 0;
    
	drv_res.start  = (a_uint32_t) 0;
  909b71:	9311      	s32i.n	a3, a1, 4
	drv_res.end    = 0;
  909b73:	9313      	s32i.n	a3, a1, 12
	drv_res.type   = ADF_OS_RESOURCE_TYPE_MEM;
  909b75:	9d14      	s32i.n	a13, a1, 16
        
	g_wlan_drv_handle = g_wlan_drv->drv_attach(&drv_res, 1, &drv_data, NULL);
  909b77:	2c1c18        	addi	a12, a1, 24
  909b7a:	c0b1      	movi.n	a11, 1
  909b7c:	da10      	mov.n	a10, a1
  909b7e:	0b2000        	callx8	a2
  909b81:	1269ec        	l32r	a2, 8e4334 <bStandardCommand+0x4d0>
  909b84:	9a20      	s32i.n	a10, a2, 0
  909b86:	d10f      	retw.n

00909b88 <wlan_pci_isr>:
	return result;    
#endif    
}

void wlan_pci_isr()
{
  909b88:	6c1004        	entry	a1, 32
	if (g_wlan_intr != NULL && g_wlan_drv_handle != NULL) {
  909b8b:	1869ed        	l32r	a8, 8e4340 <bStandardCommand+0x4dc>
  909b8e:	8880      	l32i.n	a8, a8, 0
  909b90:	c888      	beqz.n	a8, 909b9c <wlan_pci_isr+0x14>
  909b92:	1969ec        	l32r	a9, 8e4344 <bStandardCommand+0x4e0>
  909b95:	8a90      	l32i.n	a10, a9, 0
  909b97:	c8a1      	beqz.n	a10, 909b9c <wlan_pci_isr+0x14>
		g_wlan_intr(g_wlan_drv_handle);
  909b99:	0b8000        	callx8	a8
  909b9c:	d10f      	retw.n
	...

00909ba0 <_HTC_Shutdown>:
    
	return pHTC;
}

LOCAL void _HTC_Shutdown(htc_handle_t htcHandle)
{
  909ba0:	6c1004        	entry	a1, 32
  909ba3:	d10f      	retw.n
  909ba5:	000000        	ill

00909ba8 <_HTC_RegisterService>:
    
	adf_os_mem_free(pHTC);
}

LOCAL void _HTC_RegisterService(htc_handle_t htcHandle, HTC_SERVICE *pService)
{
  909ba8:	6c1004        	entry	a1, 32
	HTC_CONTEXT *pHTC = (HTC_CONTEXT *)htcHandle;
    
        /* add it to the list */
	pService->pNext = pHTC->pServiceList;
  909bab:	282290        	l32i	a8, a2, 0x240
  909bae:	9830      	s32i.n	a8, a3, 0
	pHTC->pServiceList = pService;
  909bb0:	232690        	s32i	a3, a2, 0x240
  909bb3:	d10f      	retw.n
  909bb5:	000000        	ill

00909bb8 <_HTC_GetReservedHeadroom>:
void _HTC_ResumeRecv(HTC_ENDPOINT_ID EndpointID)
{
}

int _HTC_GetReservedHeadroom(htc_handle_t htcHandle)
{
  909bb8:	6c1004        	entry	a1, 32
	HTC_CONTEXT *pHTC = (HTC_CONTEXT *)htcHandle;  
    
	return HTC_HDR_LENGTH + HIF_get_reserved_headroom(pHTC->hifHandle);
  909bbb:	1868bf        	l32r	a8, 8e3eb8 <bStandardCommand+0x54>
  909bbe:	2a229a        	l32i	a10, a2, 0x268
  909bc1:	28827a        	l32i	a8, a8, 0x1e8
  909bc4:	0b8000        	callx8	a8
}
  909bc7:	b8a2      	addi.n	a2, a10, 8
  909bc9:	d10f      	retw.n
	...

00909bcc <HTCSendDoneHandler>:
		HTCCheckAndSendCreditReport(pHTC, HTC_ANY_ENDPOINT_MASK,NULL,ENDPOINT_MAX);
	}  
}

LOCAL void HTCSendDoneHandler(adf_nbuf_t buf, void *context)
{
  909bcc:	6c1004        	entry	a1, 32
 * @return data pointer to typecast into your priv structure
 */
static inline a_uint8_t *
adf_nbuf_get_priv(adf_nbuf_t buf)
{
    return (__adf_nbuf_get_priv(buf));
  909bcf:	022a02        	or	a10, a2, a2
  909bd2:	5bf386        	call8	9069ec <__adf_nbuf_get_priv>
	A_UINT8 current_eid;
	HTC_CONTEXT *pHTC = (HTC_CONTEXT *)context;
	HTC_BUF_CONTEXT *ctx;
      
	ctx = (HTC_BUF_CONTEXT *)adf_nbuf_get_priv(buf);
	current_eid = ctx->end_point;
  909bd5:	24a000        	l8ui	a4, a10, 0
 *         or NULL if there is not sufficient data to pull.
 */
static inline a_uint8_t *
adf_nbuf_pull_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_pull_head(buf, size);
  909bd8:	c0b8      	movi.n	a11, 8
  909bda:	022a02        	or	a10, a2, a2
  909bdd:	5bf35e        	call8	906958 <__adf_nbuf_pull_head>
	/* Walk through the buffers and fixup the ones we used for HTC headers.
	 * The buffer list may contain more than one string of HTC buffers comprising of an
	 * HTC message so we need to check every buffer */            
	adf_nbuf_pull_head(buf, HTC_HDR_LENGTH);
                   
	pHTC->Endpoints[current_eid].pService->
  909be0:	0f4811        	slli	a8, a4, 1
  909be3:	a488      	add.n	a8, a8, a4
  909be5:	0d8811        	slli	a8, a8, 3
  909be8:	a833      	add.n	a3, a3, a8
  909bea:	8332      	l32i.n	a3, a3, 8
  909bec:	db20      	mov.n	a11, a2
  909bee:	8832      	l32i.n	a8, a3, 8
  909bf0:	8c36      	l32i.n	a12, a3, 24
  909bf2:	044a02        	or	a10, a4, a4
  909bf5:	0b8000        	callx8	a8
  909bf8:	d10f      	retw.n
	...

00909bfc <HTC_AssembleBuffers>:
	if ((pEndpoint)->ConnectionFlags & HTC_CONNECT_FLAGS_REDUCE_CREDIT_DRIBBLE) { \
		AdjustCreditThreshold((pEndpoint));			\
	}    

LOCAL void HTC_AssembleBuffers(HTC_CONTEXT *pHTC, int Count, int Size)
{
  909bfc:	6c1004        	entry	a1, 32
	BUF_Pool_create_pool(pHTC->PoolHandle, POOL_ID_HTC_CONTROL, Count, Size);       
  909bff:	1868bf        	l32r	a8, 8e3efc <bStandardCommand+0x98>
  909c02:	2a229b        	l32i	a10, a2, 0x26c
  909c05:	28829b        	l32i	a8, a8, 0x26c
  909c08:	dd40      	mov.n	a13, a4
  909c0a:	dc30      	mov.n	a12, a3
  909c0c:	c0b0      	movi.n	a11, 0
  909c0e:	0b8000        	callx8	a8
  909c11:	d10f      	retw.n
	...

00909c14 <_HTC_Init>:
}

LOCAL htc_handle_t _HTC_Init(HTC_SETUP_COMPLETE_CB SetupComplete,
                             HTC_CONFIG *pConfig)
{
  909c14:	6c1006        	entry	a1, 48
#include "Magpie_api.h"

static inline void *	__adf_os_mem_alloc(adf_os_size_t size)
{
//    return (malloc(size,M_DEVBUF,M_DONTWAIT | M_ZERO));
    return A_ALLOCRAM(size);
  909c17:	1468bf        	l32r	a4, 8e3f14 <bStandardCommand+0xb0>
  909c1a:	022502        	or	a5, a2, a2
  909c1d:	224252        	l32i	a2, a4, 0x148
  909c20:	2b2a74        	movi	a11, 0x274
  909c23:	c0a0      	movi.n	a10, 0
  909c25:	0b2000        	callx8	a2
}
/* zero a memory buffer */
static inline void
__adf_os_mem_zero(void *buf, adf_os_size_t size)
{
    A_MEMZERO(buf,size);
  909c28:	8844      	l32i.n	a8, a4, 16
  909c2a:	2c2a74        	movi	a12, 0x274
  909c2d:	c0b0      	movi.n	a11, 0
#include "Magpie_api.h"

static inline void *	__adf_os_mem_alloc(adf_os_size_t size)
{
//    return (malloc(size,M_DEVBUF,M_DONTWAIT | M_ZERO));
    return A_ALLOCRAM(size);
  909c2f:	d2a0      	mov.n	a2, a10
}
/* zero a memory buffer */
static inline void
__adf_os_mem_zero(void *buf, adf_os_size_t size)
{
    A_MEMZERO(buf,size);
  909c31:	0b8000        	callx8	a8
    
        pHTC = (HTC_CONTEXT *)adf_os_mem_alloc(sizeof(HTC_CONTEXT));
    
	adf_os_mem_zero(pHTC, sizeof(HTC_CONTEXT));

	pHTC->OSHandle = pConfig->OSHandle;
  909c34:	8832      	l32i.n	a8, a3, 8
	pHTC->PoolHandle = pConfig->PoolHandle;
	pHTC->hifHandle = pConfig->HIFHandle;
  909c36:	8a33      	l32i.n	a10, a3, 12
    
        pHTC = (HTC_CONTEXT *)adf_os_mem_alloc(sizeof(HTC_CONTEXT));
    
	adf_os_mem_zero(pHTC, sizeof(HTC_CONTEXT));

	pHTC->OSHandle = pConfig->OSHandle;
  909c38:	9820      	s32i.n	a8, a2, 0
	pHTC->PoolHandle = pConfig->PoolHandle;
  909c3a:	8834      	l32i.n	a8, a3, 16
	hifCBConfig.send_buf_done = A_INDIR(htc._HTC_SendDoneHandler);
	hifCBConfig.recv_buf = A_INDIR(htc._HTC_MsgRecvHandler);
	hifCBConfig.context = pHTC;
    
	/* initialize hardware layer */
	HIF_register_callback(pConfig->HIFHandle, &hifCBConfig);
  909c3c:	db10      	mov.n	a11, a1
        pHTC = (HTC_CONTEXT *)adf_os_mem_alloc(sizeof(HTC_CONTEXT));
    
	adf_os_mem_zero(pHTC, sizeof(HTC_CONTEXT));

	pHTC->OSHandle = pConfig->OSHandle;
	pHTC->PoolHandle = pConfig->PoolHandle;
  909c3e:	28269b        	s32i	a8, a2, 0x26c
	pHTC->hifHandle = pConfig->HIFHandle;
                        
	hifCBConfig.send_buf_done = A_INDIR(htc._HTC_SendDoneHandler);
  909c41:	284287        	l32i	a8, a4, 0x21c
    
	adf_os_mem_zero(pHTC, sizeof(HTC_CONTEXT));

	pHTC->OSHandle = pConfig->OSHandle;
	pHTC->PoolHandle = pConfig->PoolHandle;
	pHTC->hifHandle = pConfig->HIFHandle;
  909c44:	2a269a        	s32i	a10, a2, 0x268
                        
	hifCBConfig.send_buf_done = A_INDIR(htc._HTC_SendDoneHandler);
  909c47:	9810      	s32i.n	a8, a1, 0
	hifCBConfig.recv_buf = A_INDIR(htc._HTC_MsgRecvHandler);
  909c49:	284286        	l32i	a8, a4, 0x218
	hifCBConfig.context = pHTC;
  909c4c:	9212      	s32i.n	a2, a1, 8
	pHTC->OSHandle = pConfig->OSHandle;
	pHTC->PoolHandle = pConfig->PoolHandle;
	pHTC->hifHandle = pConfig->HIFHandle;
                        
	hifCBConfig.send_buf_done = A_INDIR(htc._HTC_SendDoneHandler);
	hifCBConfig.recv_buf = A_INDIR(htc._HTC_MsgRecvHandler);
  909c4e:	9811      	s32i.n	a8, a1, 4
	hifCBConfig.context = pHTC;
    
	/* initialize hardware layer */
	HIF_register_callback(pConfig->HIFHandle, &hifCBConfig);
  909c50:	284272        	l32i	a8, a4, 0x1c8
  909c53:	0b8000        	callx8	a8
        /* see if the host wants us to override the number of ctrl buffers */
	pHTC->NumBuffersForCreditRpts = 0;
    
	if (0 == pHTC->NumBuffersForCreditRpts) {
		/* nothing to override, simply set default */
		pHTC->NumBuffersForCreditRpts = HTC_DEFAULT_NUM_CTRL_BUFFERS; 
  909c56:	c086      	movi.n	a8, 6
  909c58:	282696        	s32i	a8, a2, 0x258
	}    
    
	pHTC->MaxEpPendingCreditRpts = 0;
    
	if (0 == pHTC->MaxEpPendingCreditRpts) {
		pHTC->MaxEpPendingCreditRpts = HTC_DEFAULT_MAX_EP_PENDING_CREDIT_REPORTS;    
  909c5b:	c083      	movi.n	a8, 3
  909c5d:	282699        	s32i	a8, a2, 0x264
	}
	/* calculate the total allocation size based on the number of credit report buffers */
	pHTC->CtrlBufferAllocSize = MIN_CREDIT_BUFFER_ALLOC_SIZE * pHTC->NumBuffersForCreditRpts;
  909c60:	280ad8        	movi	a8, 216
  909c63:	282697        	s32i	a8, a2, 0x25c
	/* we need at least enough buffer space for 1 ctrl message */
	pHTC->CtrlBufferAllocSize = A_MAX(pHTC->CtrlBufferAllocSize,MAX_HTC_SETUP_MSG_SIZE);
    
	/* save the size of each buffer/credit we will receive */
	pHTC->RecvBufferSize = pConfig->CreditSize; //RecvBufferSize;
  909c66:	8830      	l32i.n	a8, a3, 0
	pHTC->TotalCredits = pConfig->CreditNumber;
  909c68:	8331      	l32i.n	a3, a3, 4
	pHTC->CtrlBufferAllocSize = MIN_CREDIT_BUFFER_ALLOC_SIZE * pHTC->NumBuffersForCreditRpts;
	/* we need at least enough buffer space for 1 ctrl message */
	pHTC->CtrlBufferAllocSize = A_MAX(pHTC->CtrlBufferAllocSize,MAX_HTC_SETUP_MSG_SIZE);
    
	/* save the size of each buffer/credit we will receive */
	pHTC->RecvBufferSize = pConfig->CreditSize; //RecvBufferSize;
  909c6a:	282691        	s32i	a8, a2, 0x244
	pHTC->TotalCredits = pConfig->CreditNumber;
  909c6d:	232694        	s32i	a3, a2, 0x250
	pHTC->TotalCreditsAssigned = 0;
  909c70:	c030      	movi.n	a3, 0
  909c72:	232695        	s32i	a3, a2, 0x254
     
	/* setup the pseudo service that handles HTC control messages */
	pHTC->HTCControlService.ProcessRecvMsg = A_INDIR(htc._HTC_ControlSvcProcessMsg);
  909c75:	234288        	l32i	a3, a4, 0x220
	pHTC->HTCControlService.ProcessSendBufferComplete = A_INDIR(htc._HTC_ControlSvcProcessSendComplete);
	pHTC->HTCControlService.TrailerSpcCheckLimit = HTC_CTRL_BUFFER_CHECK_SIZE;
  909c78:	c18c      	movi.n	a8, 28
	pHTC->RecvBufferSize = pConfig->CreditSize; //RecvBufferSize;
	pHTC->TotalCredits = pConfig->CreditNumber;
	pHTC->TotalCreditsAssigned = 0;
     
	/* setup the pseudo service that handles HTC control messages */
	pHTC->HTCControlService.ProcessRecvMsg = A_INDIR(htc._HTC_ControlSvcProcessMsg);
  909c7a:	23268a        	s32i	a3, a2, 0x228
	pHTC->HTCControlService.ProcessSendBufferComplete = A_INDIR(htc._HTC_ControlSvcProcessSendComplete);
  909c7d:	234289        	l32i	a3, a4, 0x224
	pHTC->HTCControlService.MaxSvcMsgSize = MAX_HTC_SETUP_MSG_SIZE;
	pHTC->HTCControlService.ServiceCtx = pHTC;
    
	/* automatically register this pseudo service to endpoint 1 */
	pHTC->Endpoints[ENDPOINT0].pService = &pHTC->HTCControlService;
	HIF_get_default_pipe(pHTC->hifHandle, &pHTC->Endpoints[ENDPOINT0].UpLinkPipeID, 
  909c80:	2a229a        	l32i	a10, a2, 0x268
	pHTC->TotalCredits = pConfig->CreditNumber;
	pHTC->TotalCreditsAssigned = 0;
     
	/* setup the pseudo service that handles HTC control messages */
	pHTC->HTCControlService.ProcessRecvMsg = A_INDIR(htc._HTC_ControlSvcProcessMsg);
	pHTC->HTCControlService.ProcessSendBufferComplete = A_INDIR(htc._HTC_ControlSvcProcessSendComplete);
  909c83:	23268b        	s32i	a3, a2, 0x22c
	pHTC->HTCControlService.TrailerSpcCheckLimit = HTC_CTRL_BUFFER_CHECK_SIZE;
  909c86:	232d02        	addmi	a3, a2, 0x200
  909c89:	28351d        	s16i	a8, a3, 58
	pHTC->HTCControlService.MaxSvcMsgSize = MAX_HTC_SETUP_MSG_SIZE;
  909c8c:	c480      	movi.n	a8, 64
  909c8e:	28351c        	s16i	a8, a3, 56
	pHTC->HTCControlService.ServiceCtx = pHTC;
    
	/* automatically register this pseudo service to endpoint 1 */
	pHTC->Endpoints[ENDPOINT0].pService = &pHTC->HTCControlService;
  909c91:	232a24        	movi	a3, 0x224
  909c94:	032308        	add	a3, a2, a3
  909c97:	9322      	s32i.n	a3, a2, 8
	HIF_get_default_pipe(pHTC->hifHandle, &pHTC->Endpoints[ENDPOINT0].UpLinkPipeID, 
  909c99:	23427c        	l32i	a3, a4, 0x1f0
  909c9c:	2c2c18        	addi	a12, a2, 24
  909c9f:	2b2c19        	addi	a11, a2, 25
	/* setup the pseudo service that handles HTC control messages */
	pHTC->HTCControlService.ProcessRecvMsg = A_INDIR(htc._HTC_ControlSvcProcessMsg);
	pHTC->HTCControlService.ProcessSendBufferComplete = A_INDIR(htc._HTC_ControlSvcProcessSendComplete);
	pHTC->HTCControlService.TrailerSpcCheckLimit = HTC_CTRL_BUFFER_CHECK_SIZE;
	pHTC->HTCControlService.MaxSvcMsgSize = MAX_HTC_SETUP_MSG_SIZE;
	pHTC->HTCControlService.ServiceCtx = pHTC;
  909ca2:	22268f        	s32i	a2, a2, 0x23c
    
	/* automatically register this pseudo service to endpoint 1 */
	pHTC->Endpoints[ENDPOINT0].pService = &pHTC->HTCControlService;
	HIF_get_default_pipe(pHTC->hifHandle, &pHTC->Endpoints[ENDPOINT0].UpLinkPipeID, 
  909ca5:	0b3000        	callx8	a3
			     &pHTC->Endpoints[ENDPOINT0].DownLinkPipeID);
    
	/* Initialize control pipe so we could receive the HTC control packets */
	// @TODO: msg size!
	HIF_config_pipe(pHTC->hifHandle, pHTC->Endpoints[ENDPOINT0].UpLinkPipeID, 1);    
  909ca8:	2b2019        	l8ui	a11, a2, 25
  909cab:	234275        	l32i	a3, a4, 0x1d4
  909cae:	2a229a        	l32i	a10, a2, 0x268
  909cb1:	c0c1      	movi.n	a12, 1
  909cb3:	0b3000        	callx8	a3
    
	/* set the first free endpoint */
	pHTC->CurrentEpIndex = ENDPOINT1;
  909cb6:	c031      	movi.n	a3, 1
  909cb8:	232688        	s32i	a3, a2, 0x220
	pHTC->SetupCompleteCb = SetupComplete;
    
        /* setup buffers for just the setup phase, we only need 1 buffer to handle
	 * setup */
	HTC_AssembleBuffers(pHTC, 4, MAX_HTC_SETUP_MSG_SIZE);
  909cbb:	da20      	mov.n	a10, a2
	// @TODO: msg size!
	HIF_config_pipe(pHTC->hifHandle, pHTC->Endpoints[ENDPOINT0].UpLinkPipeID, 1);    
    
	/* set the first free endpoint */
	pHTC->CurrentEpIndex = ENDPOINT1;
	pHTC->SetupCompleteCb = SetupComplete;
  909cbd:	252693        	s32i	a5, a2, 0x24c
    
        /* setup buffers for just the setup phase, we only need 1 buffer to handle
	 * setup */
	HTC_AssembleBuffers(pHTC, 4, MAX_HTC_SETUP_MSG_SIZE);
  909cc0:	c4c0      	movi.n	a12, 64
  909cc2:	2b0a04        	movi	a11, 4
  909cc5:	5bffcd        	call8	909bfc <HTC_AssembleBuffers>
   
	/* start hardware layer so that we can queue buffers */
	HIF_start(pHTC->hifHandle);
  909cc8:	2a229a        	l32i	a10, a2, 0x268
  909ccb:	234274        	l32i	a3, a4, 0x1d0
  909cce:	0b3000        	callx8	a3
    
	return pHTC;
}
  909cd1:	d10f      	retw.n
	...

00909cd4 <_HTC_PauseRecv>:
  909cd4:	6c1004        	entry	a1, 32
  909cd7:	d10f      	retw.n
  909cd9:	000000        	ill

00909cdc <_HTC_ResumeRecv>:
void _HTC_PauseRecv(HTC_ENDPOINT_ID EndpointID)
{
}

void _HTC_ResumeRecv(HTC_ENDPOINT_ID EndpointID)
{
  909cdc:	6c1004        	entry	a1, 32
  909cdf:	d10f      	retw.n
  909ce1:	000000        	ill

00909ce4 <htc_module_install>:
    
	return HTC_HDR_LENGTH + HIF_get_reserved_headroom(pHTC->hifHandle);
}

void htc_module_install(struct htc_apis *pAPIs)
{   
  909ce4:	6c1004        	entry	a1, 32
	pAPIs->_HTC_Init = _HTC_Init;
  909ce7:	1869ee        	l32r	a8, 8e44a0 <bStandardCommand+0x63c>
  909cea:	9820      	s32i.n	a8, a2, 0
	pAPIs->_HTC_ReturnBuffers = _HTC_ReturnBuffers;
  909cec:	1869ef        	l32r	a8, 8e44a8 <bStandardCommand+0x644>
  909cef:	9824      	s32i.n	a8, a2, 16
	pAPIs->_HTC_ReturnBuffersList = _HTC_ReturnBuffersList;
  909cf1:	1869f0        	l32r	a8, 8e44b4 <bStandardCommand+0x650>
  909cf4:	9825      	s32i.n	a8, a2, 20
	pAPIs->_HTC_Ready = _HTC_Ready;
  909cf6:	1869f1        	l32r	a8, 8e44bc <bStandardCommand+0x658>
  909cf9:	9823      	s32i.n	a8, a2, 12
	pAPIs->_HTC_RegisterService = _HTC_RegisterService;
  909cfb:	1869f2        	l32r	a8, 8e44c4 <bStandardCommand+0x660>
  909cfe:	9822      	s32i.n	a8, a2, 8
	pAPIs->_HTC_SendMsg = _HTC_SendMsg;   
  909d00:	1869f3        	l32r	a8, 8e44cc <bStandardCommand+0x668>
  909d03:	9826      	s32i.n	a8, a2, 24
	pAPIs->_HTC_Shutdown = _HTC_Shutdown;
  909d05:	1869f4        	l32r	a8, 8e44d8 <bStandardCommand+0x674>
  909d08:	9821      	s32i.n	a8, a2, 4
	pAPIs->_HTC_GetReservedHeadroom = _HTC_GetReservedHeadroom;
  909d0a:	1869f5        	l32r	a8, 8e44e0 <bStandardCommand+0x67c>
  909d0d:	9827      	s32i.n	a8, a2, 28
	pAPIs->_HTC_MsgRecvHandler = HTCMsgRecvHandler;
  909d0f:	1869f6        	l32r	a8, 8e44e8 <bStandardCommand+0x684>
  909d12:	9828      	s32i.n	a8, a2, 32
	pAPIs->_HTC_SendDoneHandler = HTCSendDoneHandler;
  909d14:	1869f7        	l32r	a8, 8e44f0 <bStandardCommand+0x68c>
  909d17:	9829      	s32i.n	a8, a2, 36
	pAPIs->_HTC_ControlSvcProcessMsg = HTCControlSvcProcessMsg;
  909d19:	1869f8        	l32r	a8, 8e44fc <bStandardCommand+0x698>
  909d1c:	982a      	s32i.n	a8, a2, 40
	pAPIs->_HTC_ControlSvcProcessSendComplete = HTCControlSvcProcessSendComplete;
  909d1e:	1869f9        	l32r	a8, 8e4504 <bStandardCommand+0x6a0>
  909d21:	982b      	s32i.n	a8, a2, 44
  909d23:	d10f      	retw.n
  909d25:	000000        	ill

00909d28 <HTCFreeMsgBuffer>:
}

/* free message to the free list */
LOCAL void HTCFreeMsgBuffer(HTC_CONTEXT *pHTC, adf_nbuf_t buf) 
{
  909d28:	6c1004        	entry	a1, 32
	BUF_Pool_free_buf(pHTC->PoolHandle, POOL_ID_HTC_CONTROL, buf);      
  909d2b:	1868bf        	l32r	a8, 8e4028 <bStandardCommand+0x1c4>
  909d2e:	2a229b        	l32i	a10, a2, 0x26c
  909d31:	28829e        	l32i	a8, a8, 0x278
  909d34:	dc30      	mov.n	a12, a3
  909d36:	2b0a00        	movi	a11, 0
  909d39:	0b8000        	callx8	a8
  909d3c:	d10f      	retw.n
	...

00909d40 <HTCAllocMsgBuffer>:
}

/* HTC control message allocator (also used for empty frames to send trailer options) */
LOCAL adf_nbuf_t HTCAllocMsgBuffer(HTC_CONTEXT *pHTC)
{
  909d40:	6c1004        	entry	a1, 32
	return BUF_Pool_alloc_buf(pHTC->PoolHandle,
  909d43:	1868bf        	l32r	a8, 8e4040 <bStandardCommand+0x1dc>
	BUF_Pool_free_buf(pHTC->PoolHandle, POOL_ID_HTC_CONTROL, buf);      
}

/* HTC control message allocator (also used for empty frames to send trailer options) */
LOCAL adf_nbuf_t HTCAllocMsgBuffer(HTC_CONTEXT *pHTC)
{
  909d46:	da20      	mov.n	a10, a2
	return BUF_Pool_alloc_buf(pHTC->PoolHandle,
  909d48:	22829c        	l32i	a2, a8, 0x270
  909d4b:	288285        	l32i	a8, a8, 0x214
  909d4e:	23a29b        	l32i	a3, a10, 0x26c
  909d51:	0b8000        	callx8	a8
  909d54:	dca0      	mov.n	a12, a10
  909d56:	c0b0      	movi.n	a11, 0
  909d58:	da30      	mov.n	a10, a3
  909d5a:	0b2000        	callx8	a2
				  POOL_ID_HTC_CONTROL,
				  HTC_GetReservedHeadroom(pHTC));   
}
  909d5d:	d2a0      	mov.n	a2, a10
  909d5f:	d10f      	retw.n
  909d61:	000000        	ill

00909d64 <_HTC_Ready>:
	pService->pNext = pHTC->pServiceList;
	pHTC->pServiceList = pService;
}

LOCAL void _HTC_Ready(htc_handle_t htcHandle)
{
  909d64:	6c1004        	entry	a1, 32
	adf_nbuf_t pBuffer;
	HTC_READY_MSG *pReady;
	a_uint8_t *addr;
	HTC_CONTEXT *pHTC = (HTC_CONTEXT *)htcHandle;
    
	pBuffer = HTCAllocMsgBuffer(pHTC);
  909d67:	022a02        	or	a10, a2, a2
  909d6a:	5bfff5        	call8	909d40 <HTCAllocMsgBuffer>
 *         put, or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_put_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_put_tail(buf, size);
  909d6d:	c0b8      	movi.n	a11, 8
  909d6f:	d4a0      	mov.n	a4, a10
  909d71:	5bf39a        	call8	906bdc <__adf_nbuf_put_tail>
	/* an optimization... the header length is chosen to
	 * be aligned on a 16 bit bounday, the fields in the message are designed to
	 * be aligned */
	addr = adf_nbuf_put_tail(pBuffer, sizeof(HTC_READY_MSG));       
	pReady = (HTC_READY_MSG *)addr;     
	A_MEMZERO(pReady,sizeof(HTC_READY_MSG));  
  909d74:	1568bf        	l32r	a5, 8e4070 <bStandardCommand+0x20c>
  909d77:	c0c8      	movi.n	a12, 8
  909d79:	8854      	l32i.n	a8, a5, 16
  909d7b:	c0b0      	movi.n	a11, 0
  909d7d:	d3a0      	mov.n	a3, a10
  909d7f:	0b8000        	callx8	a8
	pReady->MessageID = adf_os_htons(HTC_MSG_READY_ID);
  909d82:	c081      	movi.n	a8, 1
  909d84:	283401        	s8i	a8, a3, 1
	pReady->CreditSize = adf_os_htons((A_UINT16)pHTC->RecvBufferSize);
  909d87:	282291        	l32i	a8, a2, 0x244
	 * be aligned on a 16 bit bounday, the fields in the message are designed to
	 * be aligned */
	addr = adf_nbuf_put_tail(pBuffer, sizeof(HTC_READY_MSG));       
	pReady = (HTC_READY_MSG *)addr;     
	A_MEMZERO(pReady,sizeof(HTC_READY_MSG));  
	pReady->MessageID = adf_os_htons(HTC_MSG_READY_ID);
  909d8a:	c0b0      	movi.n	a11, 0
	pReady->CreditSize = adf_os_htons((A_UINT16)pHTC->RecvBufferSize);
  909d8c:	08084f        	extui	a8, a8, 0, 16
  909d8f:	088914        	srli	a9, a8, 8
  909d92:	283405        	s8i	a8, a3, 5
	pReady->CreditCount = adf_os_htons((A_UINT16)pHTC->TotalCredits);
  909d95:	282294        	l32i	a8, a2, 0x250
	 * be aligned */
	addr = adf_nbuf_put_tail(pBuffer, sizeof(HTC_READY_MSG));       
	pReady = (HTC_READY_MSG *)addr;     
	A_MEMZERO(pReady,sizeof(HTC_READY_MSG));  
	pReady->MessageID = adf_os_htons(HTC_MSG_READY_ID);
	pReady->CreditSize = adf_os_htons((A_UINT16)pHTC->RecvBufferSize);
  909d98:	293404        	s8i	a9, a3, 4
	pReady->CreditCount = adf_os_htons((A_UINT16)pHTC->TotalCredits);
  909d9b:	08084f        	extui	a8, a8, 0, 16
  909d9e:	088914        	srli	a9, a8, 8
  909da1:	283403        	s8i	a8, a3, 3
	pReady->MaxEndpoints = ENDPOINT_MAX;
  909da4:	c186      	movi.n	a8, 22
  909da6:	283406        	s8i	a8, a3, 6
	 * be aligned on a 16 bit bounday, the fields in the message are designed to
	 * be aligned */
	addr = adf_nbuf_put_tail(pBuffer, sizeof(HTC_READY_MSG));       
	pReady = (HTC_READY_MSG *)addr;     
	A_MEMZERO(pReady,sizeof(HTC_READY_MSG));  
	pReady->MessageID = adf_os_htons(HTC_MSG_READY_ID);
  909da9:	2b3400        	s8i	a11, a3, 0
	pReady->CreditSize = adf_os_htons((A_UINT16)pHTC->RecvBufferSize);
	pReady->CreditCount = adf_os_htons((A_UINT16)pHTC->TotalCredits);
  909dac:	293402        	s8i	a9, a3, 2
	pReady->MaxEndpoints = ENDPOINT_MAX;
       
	/* send out the message */
	HTC_SendMsg(pHTC, ENDPOINT0, pBuffer);
  909daf:	235284        	l32i	a3, a5, 0x210
  909db2:	dc40      	mov.n	a12, a4
  909db4:	da20      	mov.n	a10, a2
  909db6:	0b3000        	callx8	a3
  909db9:	d10f      	retw.n
	...

00909dbc <HTCCheckAndSendCreditReport>:
				  HTC_GetReservedHeadroom(pHTC));   
}

LOCAL void HTCCheckAndSendCreditReport(HTC_CONTEXT *pHTC, A_UINT32 EpMask,
				       HTC_ENDPOINT *pEndpoint, HTC_ENDPOINT_ID Eid)
{
  909dbc:	6c1004        	entry	a1, 32
	adf_nbuf_t pCredBuffer;
	HTC_BUF_CONTEXT *ctx;    
        
	do {
		/* check if host needs credits */
		if (!(pHTC->EpHostNeedsCreditMap & EpMask)) {
  909dbf:	282285        	l32i	a8, a2, 0x214
  909dc2:	78305a        	bnone	a3, a8, 909e20 <HTCCheckAndSendCreditReport+0x64>
			/* host does not need any credits for this set */
			break;    
		}
		/* check if any are pending */
		if (!(pHTC->EpCreditPendingMap & EpMask)) {
  909dc5:	282286        	l32i	a8, a2, 0x218
  909dc8:	783054        	bnone	a3, a8, 909e20 <HTCCheckAndSendCreditReport+0x64>
			/* nothing to send up */
			break;    
		}  
		/* was an endpoint specified? */
		if (pEndpoint != NULL) {
  909dcb:	c945      	beqz.n	a4, 909de4 <HTCCheckAndSendCreditReport+0x28>
			/* see if a threshold is in effect for this endpoint */
			if (pEndpoint->CreditReturnThreshhold != 0) {
  909dcd:	234904        	l16si	a3, a4, 8
  909dd0:	c834      	beqz.n	a3, 909dd8 <HTCCheckAndSendCreditReport+0x1c>
				if (pEndpoint->CreditsToReturn < pEndpoint->CreditReturnThreshhold) {
  909dd2:	284900        	l16si	a8, a4, 0
  909dd5:	738247        	blt	a8, a3, 909e20 <HTCCheckAndSendCreditReport+0x64>
					 * back to the host */
					break;
				}
			}
         
			if (pEndpoint->PendingCreditReports >= pHTC->MaxEpPendingCreditRpts) {
  909dd8:	8844      	l32i.n	a8, a4, 16
  909dda:	232299        	l32i	a3, a2, 0x264
  909ddd:	738203        	blt	a8, a3, 909de4 <HTCCheckAndSendCreditReport+0x28>
  909de0:	600009        	j	909ded <HTCCheckAndSendCreditReport+0x31>
  909de3:	00da20        	excw
		}
        
		/* if we get here we have some credits to send up */
                        
		/* allocate a message buffer for the trailer */
		pCredBuffer = HTCAllocMsgBuffer(pHTC);
  909de6:	5bffd6        	call8	909d40 <HTCAllocMsgBuffer>
  909de9:	d3a0      	mov.n	a3, a10
		if (NULL == pCredBuffer) {
  909deb:	ccae      	bnez.n	a10, 909dfd <HTCCheckAndSendCreditReport+0x41>
			/* no buffers left to send an empty message with trailers, host will just
			 * have to wait until we get our endpoint 0 messages back.. */
			/* mark that we need to send an update as soon as we can get a buffer back */
			pHTC->StateFlags |= HTC_SEND_CREDIT_UPDATE_SOON;
  909ded:	232292        	l32i	a3, a2, 0x248
  909df0:	c042      	movi.n	a4, 2
  909df2:	043302        	or	a3, a3, a4
  909df5:	232692        	s32i	a3, a2, 0x248
  909df8:	d10f      	retw.n
  909dfa:	000000        	ill
 * @return data pointer to typecast into your priv structure
 */
static inline a_uint8_t *
adf_nbuf_get_priv(adf_nbuf_t buf)
{
    return (__adf_nbuf_get_priv(buf));
  909dfd:	5bf2fb        	call8	9069ec <__adf_nbuf_get_priv>
			break;    
		}
        
		ctx = (HTC_BUF_CONTEXT *)adf_nbuf_get_priv(pCredBuffer);
		if (pEndpoint != NULL) {
  909e00:	c84d      	beqz.n	a4, 909e11 <HTCCheckAndSendCreditReport+0x55>
			/* keep track of pending reports */
			pEndpoint->PendingCreditReports++; 
  909e02:	8844      	l32i.n	a8, a4, 16
  909e04:	b188      	addi.n	a8, a8, 1
  909e06:	9844      	s32i.n	a8, a4, 16
			/* save the endpoint in order to decrement the count when the send completes */
			ctx->htc_flags = Eid | HTC_FLAGS_CREDIT_RPT;
  909e08:	240a20        	movi	a4, 32
  909e0b:	045502        	or	a5, a5, a4
  909e0e:	25a401        	s8i	a5, a10, 1
		}   
            
		/* this is an empty message, the HTC_SendMsg will tack on a trailer in the remaining
		 * space, NOTE: no need to flush the cache, the header and trailers are assembled
		 * using uncached addresses */
		HTC_SendMsg(pHTC, ENDPOINT0, pCredBuffer);    
  909e11:	1468bf        	l32r	a4, 8e4110 <bStandardCommand+0x2ac>
  909e14:	dc30      	mov.n	a12, a3
  909e16:	244284        	l32i	a4, a4, 0x210
  909e19:	c0b0      	movi.n	a11, 0
  909e1b:	da20      	mov.n	a10, a2
  909e1d:	0b4000        	callx8	a4
  909e20:	d10f      	retw.n
	...

00909e24 <ReturnBuffers>:
	/* now we need to wait for service connection requests */
}

LOCAL void ReturnBuffers(htc_handle_t htcHandle, HTC_ENDPOINT_ID EndpointID,
			 adf_nbuf_t pBuffers, A_BOOL sendCreditFlag)
{   
  909e24:	6c1004        	entry	a1, 32
 *         or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_push_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_push_head(buf, size);
  909e27:	c0b8      	movi.n	a11, 8
  909e29:	da40      	mov.n	a10, a4
    
	/* supply some head-room again */
	adf_nbuf_push_head(pBuffers, HTC_HDR_LENGTH);
              
	/* enqueue all buffers to the single mailbox */
	HIF_return_recv_buf(pHTC->hifHandle, pHTC->Endpoints[EndpointID].UpLinkPipeID, pBuffers);    
  909e2b:	0f3611        	slli	a6, a3, 1
  909e2e:	5bf2bf        	call8	90692c <__adf_nbuf_push_head>
  909e31:	a366      	add.n	a6, a6, a3
  909e33:	1868bf        	l32r	a8, 8e4130 <bStandardCommand+0x2cc>
  909e36:	0d6611        	slli	a6, a6, 3
  909e39:	a627      	add.n	a7, a2, a6
  909e3b:	288277        	l32i	a8, a8, 0x1dc
  909e3e:	2b7019        	l8ui	a11, a7, 25
  909e41:	2a229a        	l32i	a10, a2, 0x268
  909e44:	dc40      	mov.n	a12, a4
  909e46:	0b8000        	callx8	a8
     
	if (pHTC->StateFlags & HTC_STATE_SETUP_COMPLETE) {       
  909e49:	242292        	l32i	a4, a2, 0x248
  909e4c:	7f4730        	bbci	a4, 31, 909e80 <ReturnBuffers+0x5c>
		A_UINT32    epCreditMask = (1 << EndpointID);
		/* we are running normally */
		/* update pending credit counts with the number of buffers that were added */
		pHTC->Endpoints[EndpointID].CreditsToReturn += (A_INT16)nbufs;
  909e4f:	287102        	l16ui	a8, a7, 4
              
	/* enqueue all buffers to the single mailbox */
	HIF_return_recv_buf(pHTC->hifHandle, pHTC->Endpoints[EndpointID].UpLinkPipeID, pBuffers);    
     
	if (pHTC->StateFlags & HTC_STATE_SETUP_COMPLETE) {       
		A_UINT32    epCreditMask = (1 << EndpointID);
  909e52:	c0b1      	movi.n	a11, 1
		/* we are running normally */
		/* update pending credit counts with the number of buffers that were added */
		pHTC->Endpoints[EndpointID].CreditsToReturn += (A_INT16)nbufs;
  909e54:	b188      	addi.n	a8, a8, 1
  909e56:	287502        	s16i	a8, a7, 4
		pHTC->Endpoints[EndpointID].CreditsConsumed -= (A_INT16)nbufs;  
  909e59:	287107        	l16ui	a8, a7, 14
              
	/* enqueue all buffers to the single mailbox */
	HIF_return_recv_buf(pHTC->hifHandle, pHTC->Endpoints[EndpointID].UpLinkPipeID, pBuffers);    
     
	if (pHTC->StateFlags & HTC_STATE_SETUP_COMPLETE) {       
		A_UINT32    epCreditMask = (1 << EndpointID);
  909e5c:	003104        	ssl	a3
  909e5f:	00bb1a        	sll	a11, a11
		/* we are running normally */
		/* update pending credit counts with the number of buffers that were added */
		pHTC->Endpoints[EndpointID].CreditsToReturn += (A_INT16)nbufs;
		pHTC->Endpoints[EndpointID].CreditsConsumed -= (A_INT16)nbufs;  
  909e62:	b088      	addi.n	a8, a8, -1
  909e64:	287507        	s16i	a8, a7, 14
		/* update bit map that this endpoint has non-zero credits */
		pHTC->EpCreditPendingMap |= epCreditMask; 
  909e67:	272286        	l32i	a7, a2, 0x218
  909e6a:	0b7702        	or	a7, a7, a11
  909e6d:	272686        	s32i	a7, a2, 0x218

		if (sendCreditFlag) {
  909e70:	c954      	beqz.n	a5, 909e88 <ReturnBuffers+0x64>
			HTCCheckAndSendCreditReport(pHTC, epCreditMask,&pHTC->Endpoints[EndpointID],EndpointID);
  909e72:	b46c      	addi.n	a12, a6, 4
  909e74:	dd30      	mov.n	a13, a3
  909e76:	ac2c      	add.n	a12, a2, a12
  909e78:	da20      	mov.n	a10, a2
  909e7a:	5bffd0        	call8	909dbc <HTCCheckAndSendCreditReport>
  909e7d:	d10f      	retw.n
  909e7f:	002322        	excw
	} else {
		/* we have not started yet so all return operations are simply adding buffers
		 * to the interface at startup, so we can keep track of how many total 
		 * credits we get */
		/* update global count that will be returned to the host */
		pHTC->TotalCredits += nbufs;
  909e82:	94b1      	s32i.n	a4, a11, 4
  909e84:	332326        	excw
  909e87:	94d1      	s32i.n	a4, a13, 4
  909e89:	0f0000        	callx12	a0

00909e8c <_HTC_ReturnBuffers>:
	HTCCheckAndSendCreditReport(pHTC, (1 << EndpointID),&pHTC->Endpoints[EndpointID],EndpointID);
}

LOCAL void _HTC_ReturnBuffers(htc_handle_t htcHandle, HTC_ENDPOINT_ID EndpointID,
			      adf_nbuf_t pBuffers)
{
  909e8c:	6c1004        	entry	a1, 32
	ReturnBuffers(htcHandle, EndpointID, pBuffers, TRUE);
  909e8f:	c0d1      	movi.n	a13, 1
  909e91:	dc40      	mov.n	a12, a4
  909e93:	db30      	mov.n	a11, a3
  909e95:	da20      	mov.n	a10, a2
  909e97:	5bffe3        	call8	909e24 <ReturnBuffers>
  909e9a:	d10f      	retw.n

00909e9c <_HTC_ReturnBuffersList>:
}

LOCAL void _HTC_ReturnBuffersList(htc_handle_t htcHandle,
				  HTC_ENDPOINT_ID EndpointID,
				  adf_nbuf_queue_t bufHead)
{
  909e9c:	6c1006        	entry	a1, 48
 * @return first buffer in queue
 */
static inline adf_nbuf_t 
adf_nbuf_queue_first(adf_nbuf_queue_t *head)
{
    return (__adf_nbuf_queue_first(head));
  909e9f:	da10      	mov.n	a10, a1
  909ea1:	9410      	s32i.n	a4, a1, 0
  909ea3:	9511      	s32i.n	a5, a1, 4
  909ea5:	9612      	s32i.n	a6, a1, 8
  909ea7:	5bf384        	call8	906cb8 <__adf_nbuf_queue_first>
  909eaa:	d4a0      	mov.n	a4, a10
	while (netbuf) {

		tmpNbuf = netbuf;
		netbuf = adf_nbuf_queue_next(netbuf);

		ReturnBuffers(htcHandle, EndpointID, tmpNbuf, FALSE);
  909eac:	c050      	movi.n	a5, 0
	adf_nbuf_t netbuf, tmpNbuf;

	/* retrieve each nbuf in the queue */
	netbuf = adf_nbuf_queue_first(&bufHead);

	while (netbuf) {
  909eae:	600014        	j	909ec6 <_HTC_ReturnBuffersList+0x2a>
 * @return next buffer/packet
 */
static inline adf_nbuf_t
adf_nbuf_queue_next(adf_nbuf_t buf)
{
    return (__adf_nbuf_queue_next(buf));
  909eb1:	da40      	mov.n	a10, a4
  909eb3:	5bf383        	call8	906cc0 <__adf_nbuf_queue_next>
  909eb6:	d6a0      	mov.n	a6, a10

		tmpNbuf = netbuf;
		netbuf = adf_nbuf_queue_next(netbuf);

		ReturnBuffers(htcHandle, EndpointID, tmpNbuf, FALSE);
  909eb8:	dc40      	mov.n	a12, a4
  909eba:	dd50      	mov.n	a13, a5
  909ebc:	db30      	mov.n	a11, a3
  909ebe:	022a02        	or	a10, a2, a2
  909ec1:	5bffd8        	call8	909e24 <ReturnBuffers>
	netbuf = adf_nbuf_queue_first(&bufHead);

	while (netbuf) {

		tmpNbuf = netbuf;
		netbuf = adf_nbuf_queue_next(netbuf);
  909ec4:	d460      	mov.n	a4, a6
	adf_nbuf_t netbuf, tmpNbuf;

	/* retrieve each nbuf in the queue */
	netbuf = adf_nbuf_queue_first(&bufHead);

	while (netbuf) {
  909ec6:	654fe7        	bnez	a4, 909eb1 <_HTC_ReturnBuffersList+0x15>
		netbuf = adf_nbuf_queue_next(netbuf);

		ReturnBuffers(htcHandle, EndpointID, tmpNbuf, FALSE);
	}

	HTCCheckAndSendCreditReport(pHTC, (1 << EndpointID),&pHTC->Endpoints[EndpointID],EndpointID);
  909ec9:	0f3c11        	slli	a12, a3, 1
  909ecc:	a3cc      	add.n	a12, a12, a3
  909ece:	0dcc11        	slli	a12, a12, 3
  909ed1:	b4cc      	addi.n	a12, a12, 4
  909ed3:	c0b1      	movi.n	a11, 1
  909ed5:	dd30      	mov.n	a13, a3
  909ed7:	ac2c      	add.n	a12, a2, a12
  909ed9:	003104        	ssl	a3
  909edc:	00bb1a        	sll	a11, a11
  909edf:	da20      	mov.n	a10, a2
  909ee1:	5bffb6        	call8	909dbc <HTCCheckAndSendCreditReport>
  909ee4:	d10f      	retw.n
	...

00909ee8 <HTCControlSvcProcessSendComplete>:
}

/* callback when endpoint 0 send buffers are completed */
LOCAL void HTCControlSvcProcessSendComplete(HTC_ENDPOINT_ID EndpointID,
					    adf_nbuf_t pBuffers, void *arg)
{
  909ee8:	6c1004        	entry	a1, 32
 * @return data pointer to typecast into your priv structure
 */
static inline a_uint8_t *
adf_nbuf_get_priv(adf_nbuf_t buf)
{
    return (__adf_nbuf_get_priv(buf));
  909eeb:	da30      	mov.n	a10, a3
  909eed:	5bf2bf        	call8	9069ec <__adf_nbuf_get_priv>
	HTC_ENDPOINT_ID creditRptEndpoint;
    
	ctx = (HTC_BUF_CONTEXT *)adf_nbuf_get_priv(pBuffers);       
    
	/* put them back into the pool */
	if ( ctx->htc_flags & HTC_FLAGS_CREDIT_RPT ) {   
  909ef0:	28a001        	l8ui	a8, a10, 1
  909ef3:	7a8712        	bbci	a8, 26, 909f09 <HTCControlSvcProcessSendComplete+0x21>
		/* extract the endpoint number that requested this credit report */ 
		creditRptEndpoint = ctx->htc_flags & HTC_FLAGS_CRPT_EP_MASK;    
  909ef6:	080944        	extui	a9, a8, 0, 5
		pHTC->Endpoints[creditRptEndpoint].PendingCreditReports--;  
  909ef9:	0f9811        	slli	a8, a9, 1
  909efc:	a988      	add.n	a8, a8, a9
  909efe:	0d8811        	slli	a8, a8, 3
  909f01:	a848      	add.n	a8, a4, a8
  909f03:	8985      	l32i.n	a9, a8, 20
  909f05:	b099      	addi.n	a9, a9, -1
  909f07:	9985      	s32i.n	a9, a8, 20
	}
    
	HTCFreeMsgBuffer(pHTC, pBuffers);
  909f09:	db30      	mov.n	a11, a3
  909f0b:	da40      	mov.n	a10, a4
  909f0d:	5bff86        	call8	909d28 <HTCFreeMsgBuffer>
   
	if (pHTC->StateFlags & HTC_SEND_CREDIT_UPDATE_SOON) {
  909f10:	284292        	l32i	a8, a4, 0x248
  909f13:	7e8712        	bbci	a8, 30, 909f29 <HTCControlSvcProcessSendComplete+0x41>
		/* this flag is set when the host could not send a credit report
		 * because we ran out of HTC control buffers */
		pHTC->StateFlags &= ~HTC_SEND_CREDIT_UPDATE_SOON;
  909f16:	c73d      	movi.n	a3, -3
  909f18:	038801        	and	a8, a8, a3
  909f1b:	284692        	s32i	a8, a4, 0x248
		/* send out a report if anything is pending */
		HTCCheckAndSendCreditReport(pHTC, HTC_ANY_ENDPOINT_MASK,NULL,ENDPOINT_MAX);
  909f1e:	c1d6      	movi.n	a13, 22
  909f20:	c0c0      	movi.n	a12, 0
  909f22:	c7bf      	movi.n	a11, -1
  909f24:	da40      	mov.n	a10, a4
  909f26:	5bffa5        	call8	909dbc <HTCCheckAndSendCreditReport>
  909f29:	d10f      	retw.n
	...

00909f2c <HTCProcessConnectMsg>:
	} while (FALSE);      
}
        
/* called in response to the arrival of a service connection message */
LOCAL void HTCProcessConnectMsg(HTC_CONTEXT *pHTC, HTC_CONNECT_SERVICE_MSG *pMsg)
{
  909f2c:	6c1008        	entry	a1, 64
	HTC_SERVICE *pService = pHTC->pServiceList;
	A_UINT8 connectStatus = HTC_SERVICE_NOT_FOUND;
	adf_nbuf_t pBuffer;
	HTC_CONNECT_SERVICE_RESPONSE_MSG *pRspMsg;
	int metaDataOutLen = 0;
  909f2f:	c070      	movi.n	a7, 0
  909f31:	9710      	s32i.n	a7, a1, 0
	A_UINT16 serviceId = adf_os_ntohs(pMsg->ServiceID);
  909f33:	283002        	l8ui	a8, a3, 2
    
	pBuffer = HTCAllocMsgBuffer(pHTC);
  909f36:	da20      	mov.n	a10, a2
	HTC_SERVICE *pService = pHTC->pServiceList;
	A_UINT8 connectStatus = HTC_SERVICE_NOT_FOUND;
	adf_nbuf_t pBuffer;
	HTC_CONNECT_SERVICE_RESPONSE_MSG *pRspMsg;
	int metaDataOutLen = 0;
	A_UINT16 serviceId = adf_os_ntohs(pMsg->ServiceID);
  909f38:	088411        	slli	a4, a8, 8
  909f3b:	283003        	l8ui	a8, a3, 3
}
        
/* called in response to the arrival of a service connection message */
LOCAL void HTCProcessConnectMsg(HTC_CONTEXT *pHTC, HTC_CONNECT_SERVICE_MSG *pMsg)
{
	HTC_SERVICE *pService = pHTC->pServiceList;
  909f3e:	252290        	l32i	a5, a2, 0x240
	A_UINT8 connectStatus = HTC_SERVICE_NOT_FOUND;
	adf_nbuf_t pBuffer;
	HTC_CONNECT_SERVICE_RESPONSE_MSG *pRspMsg;
	int metaDataOutLen = 0;
	A_UINT16 serviceId = adf_os_ntohs(pMsg->ServiceID);
  909f41:	048802        	or	a8, a8, a4
    
	pBuffer = HTCAllocMsgBuffer(pHTC);
  909f44:	9814      	s32i.n	a8, a1, 16
  909f46:	5bff7e        	call8	909d40 <HTCAllocMsgBuffer>
 *         put, or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_put_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_put_tail(buf, size);
  909f49:	c0ba      	movi.n	a11, 10
  909f4b:	d6a0      	mov.n	a6, a10
  909f4d:	5bf323        	call8	906bdc <__adf_nbuf_put_tail>
	/* note : this will be aligned */
	pRspMsg = (HTC_CONNECT_SERVICE_RESPONSE_MSG *)
                adf_nbuf_put_tail(pBuffer, sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
                                 
	A_MEMZERO(pRspMsg,sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
  909f50:	1968bf        	l32r	a9, 8e424c <bStandardCommand+0x3e8>
  909f53:	c0ca      	movi.n	a12, 10
  909f55:	8d94      	l32i.n	a13, a9, 16
  909f57:	db70      	mov.n	a11, a7
  909f59:	d4a0      	mov.n	a4, a10
  909f5b:	0bd000        	callx8	a13
	pRspMsg->MessageID = adf_os_htons(HTC_MSG_CONNECT_SERVICE_RESPONSE_ID);
	/* reflect the service ID for this connect attempt */
	pRspMsg->ServiceID = adf_os_htons(serviceId);
  909f5e:	8814      	l32i.n	a8, a1, 16
	/* note : this will be aligned */
	pRspMsg = (HTC_CONNECT_SERVICE_RESPONSE_MSG *)
                adf_nbuf_put_tail(pBuffer, sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
                                 
	A_MEMZERO(pRspMsg,sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
	pRspMsg->MessageID = adf_os_htons(HTC_MSG_CONNECT_SERVICE_RESPONSE_ID);
  909f60:	c093      	movi.n	a9, 3
  909f62:	294401        	s8i	a9, a4, 1
	/* reflect the service ID for this connect attempt */
	pRspMsg->ServiceID = adf_os_htons(serviceId);
  909f65:	088914        	srli	a9, a8, 8
  909f68:	294402        	s8i	a9, a4, 2
	/* note : this will be aligned */
	pRspMsg = (HTC_CONNECT_SERVICE_RESPONSE_MSG *)
                adf_nbuf_put_tail(pBuffer, sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
                                 
	A_MEMZERO(pRspMsg,sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
	pRspMsg->MessageID = adf_os_htons(HTC_MSG_CONNECT_SERVICE_RESPONSE_ID);
  909f6b:	274400        	s8i	a7, a4, 0
	/* reflect the service ID for this connect attempt */
	pRspMsg->ServiceID = adf_os_htons(serviceId);
  909f6e:	284403        	s8i	a8, a4, 3

	while (pService) {
        
		if (pHTC->CurrentEpIndex >= ENDPOINT_MAX) {
  909f71:	c195      	movi.n	a9, 21
	A_MEMZERO(pRspMsg,sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
	pRspMsg->MessageID = adf_os_htons(HTC_MSG_CONNECT_SERVICE_RESPONSE_ID);
	/* reflect the service ID for this connect attempt */
	pRspMsg->ServiceID = adf_os_htons(serviceId);

	while (pService) {
  909f73:	600077        	j	909fee <HTCProcessConnectMsg+0xc2>
        
		if (pHTC->CurrentEpIndex >= ENDPOINT_MAX) {
  909f76:	2b2288        	l32i	a11, a2, 0x220
  909f79:	7b9279        	blt	a9, a11, 909ff6 <HTCProcessConnectMsg+0xca>
			/* no more endpoints */
			connectStatus = HTC_SERVICE_NO_RESOURCES;
			break;    
		}

		if (serviceId == pService->ServiceID) {
  909f7c:	2a5108        	l16ui	a10, a5, 16
  909f7f:	78a969        	bne	a10, a8, 909fec <HTCProcessConnectMsg+0xc0>
			A_UINT8 *pMetaDataOut;
            
			/* outgoing meta data resides in the space after the response message */
			pMetaDataOut = ((A_UINT8 *)pRspMsg) + sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG);
            
			if (pMsg->ServiceMetaLength != 0) {
  909f82:	2d3008        	l8ui	a13, a3, 8
				/* the meta data follows the connect service message */
				pMetaDataIN = ((A_UINT8 *)pMsg) + sizeof(HTC_CONNECT_SERVICE_MSG);
  909f85:	c080      	movi.n	a8, 0
  909f87:	ba3c      	addi.n	a12, a3, 10
  909f89:	0d8c38        	moveqz	a12, a8, a13
			}

			/* call the connect callback with the endpoint to use and pointers to meta data */
			connectStatus = pService->ProcessConnect(pService,
  909f8c:	8853      	l32i.n	a8, a5, 12
  909f8e:	df10      	mov.n	a15, a1
  909f90:	ba4e      	addi.n	a14, a4, 10
  909f92:	055a02        	or	a10, a5, a5
  909f95:	0b8000        	callx8	a8
								 pMsg->ServiceMetaLength,
								 pMetaDataOut,
								 &metaDataOutLen);
            
			/* check if the service accepted this connection request */
			if (HTC_SERVICE_SUCCESS == connectStatus) {
  909f98:	65a05c        	bnez	a10, 909ff8 <HTCProcessConnectMsg+0xcc>
				/* set the length of the response meta data going back to the host */
				pRspMsg->ServiceMetaLength = (A_UINT8)metaDataOutLen;
  909f9b:	8810      	l32i.n	a8, a1, 0
  909f9d:	284408        	s8i	a8, a4, 8
				/* set the endpoint ID the host will now communicate over */
				pRspMsg->EndpointID = pHTC->CurrentEpIndex;
  909fa0:	292288        	l32i	a9, a2, 0x220
  909fa3:	294405        	s8i	a9, a4, 5
				/* return the maximum message size for this service */
				pRspMsg->MaxMsgSize = adf_os_htons((A_UINT16)pService->MaxSvcMsgSize);
  909fa6:	285014        	l8ui	a8, a5, 20
  909fa9:	284406        	s8i	a8, a4, 6
  909fac:	285015        	l8ui	a8, a5, 21
  909faf:	284407        	s8i	a8, a4, 7
  909fb2:	0f9811        	slli	a8, a9, 1
  909fb5:	a988      	add.n	a8, a8, a9
  909fb7:	0d8811        	slli	a8, a8, 3
  909fba:	a828      	add.n	a8, a2, a8
				/* assign this endpoint to this service, this will be used in routing messages */
				pHTC->Endpoints[pHTC->CurrentEpIndex].pService = pService;
  909fbc:	9582      	s32i.n	a5, a8, 8
				/* set connection flags */
				pHTC->Endpoints[pHTC->CurrentEpIndex].ConnectionFlags = pMsg->ConnectionFlags;
  909fbe:	2b3004        	l8ui	a11, a3, 4
  909fc1:	08bc11        	slli	a12, a11, 8
  909fc4:	2b3005        	l8ui	a11, a3, 5
  909fc7:	0cbb02        	or	a11, a11, a12
  909fca:	2b8508        	s16i	a11, a8, 16
                
				pHTC->Endpoints[pHTC->CurrentEpIndex].DownLinkPipeID = pMsg->DownLinkPipeID;
  909fcd:	2b3006        	l8ui	a11, a3, 6
  909fd0:	2b8418        	s8i	a11, a8, 24
				pHTC->Endpoints[pHTC->CurrentEpIndex].UpLinkPipeID = pMsg->UpLinkPipeID;
  909fd3:	233007        	l8ui	a3, a3, 7
  909fd6:	238419        	s8i	a3, a8, 25
                
				/* mark that we are now connected */
				pService->ServiceFlags |= HTC_SERVICE_FLAGS_CONNECTED;
  909fd9:	235109        	l16ui	a3, a5, 18
  909fdc:	c081      	movi.n	a8, 1
  909fde:	083302        	or	a3, a3, a8
  909fe1:	235509        	s16i	a3, a5, 18
				/* bump up our index, this EP is now in use */
				pHTC->CurrentEpIndex++;   
  909fe4:	b193      	addi.n	a3, a9, 1
  909fe6:	232688        	s32i	a3, a2, 0x220
  909fe9:	60000b        	j	909ff8 <HTCProcessConnectMsg+0xcc>
			}

			break;
		}       
        
		pService = pService->pNext;   
  909fec:	8550      	l32i.n	a5, a5, 0
	A_MEMZERO(pRspMsg,sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG));
	pRspMsg->MessageID = adf_os_htons(HTC_MSG_CONNECT_SERVICE_RESPONSE_ID);
	/* reflect the service ID for this connect attempt */
	pRspMsg->ServiceID = adf_os_htons(serviceId);

	while (pService) {
  909fee:	655f84        	bnez	a5, 909f76 <HTCProcessConnectMsg+0x4a>
        
/* called in response to the arrival of a service connection message */
LOCAL void HTCProcessConnectMsg(HTC_CONTEXT *pHTC, HTC_CONNECT_SERVICE_MSG *pMsg)
{
	HTC_SERVICE *pService = pHTC->pServiceList;
	A_UINT8 connectStatus = HTC_SERVICE_NOT_FOUND;
  909ff1:	c0a1      	movi.n	a10, 1
  909ff3:	600001        	j	909ff8 <HTCProcessConnectMsg+0xcc>

	while (pService) {
        
		if (pHTC->CurrentEpIndex >= ENDPOINT_MAX) {
			/* no more endpoints */
			connectStatus = HTC_SERVICE_NO_RESOURCES;
  909ff6:	c0a3      	movi.n	a10, 3
		}       
        
		pService = pService->pNext;   
	}
                   
	pRspMsg->Status = connectStatus;    
  909ff8:	2a4404        	s8i	a10, a4, 4
    
	/* send out the response message */
	HTC_SendMsg(pHTC, ENDPOINT0, pBuffer); 
  909ffb:	1468bf        	l32r	a4, 8e42f8 <bStandardCommand+0x494>
  909ffe:	dc60      	mov.n	a12, a6
  90a000:	234284        	l32i	a3, a4, 0x210
  90a003:	c0b0      	movi.n	a11, 0
  90a005:	da20      	mov.n	a10, a2
  90a007:	0b3000        	callx8	a3
  90a00a:	d10f      	retw.n

0090a00c <HTCProcessConfigPipeMsg>:
}

LOCAL void HTCProcessConfigPipeMsg(HTC_CONTEXT *pHTC, HTC_CONFIG_PIPE_MSG *pMsg)
{
  90a00c:	6c1004        	entry	a1, 32
	adf_nbuf_t pBuffer;
	HTC_CONFIG_PIPE_RESPONSE_MSG *pRspMsg;
        
	pBuffer = HTCAllocMsgBuffer(pHTC);
  90a00f:	022a02        	or	a10, a2, a2
  90a012:	5bff4b        	call8	909d40 <HTCAllocMsgBuffer>
  90a015:	c0b4      	movi.n	a11, 4
  90a017:	d6a0      	mov.n	a6, a10
  90a019:	5bf2f0        	call8	906bdc <__adf_nbuf_put_tail>
       
	/* note : this will be aligned */
	pRspMsg = (HTC_CONFIG_PIPE_RESPONSE_MSG *)
                adf_nbuf_put_tail(pBuffer, sizeof(HTC_CONFIG_PIPE_RESPONSE_MSG));    
              
	A_MEMZERO(pRspMsg,sizeof(HTC_CONFIG_PIPE_RESPONSE_MSG));
  90a01c:	1568bf        	l32r	a5, 8e4318 <bStandardCommand+0x4b4>
  90a01f:	c0b0      	movi.n	a11, 0
  90a021:	8854      	l32i.n	a8, a5, 16
  90a023:	c0c4      	movi.n	a12, 4
  90a025:	d4a0      	mov.n	a4, a10
  90a027:	0b8000        	callx8	a8
    
	pRspMsg->MessageID = adf_os_htons(HTC_MSG_CONFIG_PIPE_RESPONSE_ID);
  90a02a:	c080      	movi.n	a8, 0
  90a02c:	284400        	s8i	a8, a4, 0
  90a02f:	280a06        	movi	a8, 6
  90a032:	284401        	s8i	a8, a4, 1
	/* reflect the service ID for this connect attempt */
	pRspMsg->PipeID = pMsg->PipeID;
  90a035:	2b3002        	l8ui	a11, a3, 2
  90a038:	2b4402        	s8i	a11, a4, 2

	if ( HIF_is_pipe_supported(pHTC->hifHandle, pMsg->PipeID) ) {
  90a03b:	285278        	l32i	a8, a5, 0x1e0
  90a03e:	2a229a        	l32i	a10, a2, 0x268
  90a041:	0b8000        	callx8	a8
  90a044:	c9a4      	beqz.n	a10, 90a05c <HTCProcessConfigPipeMsg+0x50>
		pRspMsg->Status = 0;            
  90a046:	c080      	movi.n	a8, 0
  90a048:	284403        	s8i	a8, a4, 3
	} else {
		pRspMsg->Status = 1; 
		goto config_done;
	}

	if ( (pHTC->TotalCreditsAssigned + pMsg->CreditCount) <= pHTC->TotalCredits ) {
  90a04b:	2c3003        	l8ui	a12, a3, 3
  90a04e:	282295        	l32i	a8, a2, 0x254
  90a051:	292294        	l32i	a9, a2, 0x250
  90a054:	a8c8      	add.n	a8, a12, a8
  90a056:	78921a        	blt	a9, a8, 90a074 <HTCProcessConfigPipeMsg+0x68>
  90a059:	600004        	j	90a061 <HTCProcessConfigPipeMsg+0x55>
	pRspMsg->PipeID = pMsg->PipeID;

	if ( HIF_is_pipe_supported(pHTC->hifHandle, pMsg->PipeID) ) {
		pRspMsg->Status = 0;            
	} else {
		pRspMsg->Status = 1; 
  90a05c:	c031      	movi.n	a3, 1
  90a05e:	600014        	j	90a076 <HTCProcessConfigPipeMsg+0x6a>
		goto config_done;
	}

	if ( (pHTC->TotalCreditsAssigned + pMsg->CreditCount) <= pHTC->TotalCredits ) {
		pHTC->TotalCreditsAssigned += pMsg->CreditCount;
  90a061:	282695        	s32i	a8, a2, 0x254
	} else {
		pRspMsg->Status = 2;
		goto config_done;
	}
    
	HIF_config_pipe(pHTC->hifHandle, pMsg->PipeID, pMsg->CreditCount);
  90a064:	245275        	l32i	a4, a5, 0x1d4
  90a067:	2b3002        	l8ui	a11, a3, 2
  90a06a:	2a229a        	l32i	a10, a2, 0x268
  90a06d:	0b4000        	callx8	a4
  90a070:	600005        	j	90a079 <HTCProcessConfigPipeMsg+0x6d>
  90a073:	00c032        	sext	a0, a12, 7
	}

	if ( (pHTC->TotalCreditsAssigned + pMsg->CreditCount) <= pHTC->TotalCredits ) {
		pHTC->TotalCreditsAssigned += pMsg->CreditCount;
	} else {
		pRspMsg->Status = 2;
  90a076:	234403        	s8i	a3, a4, 3
    
	HIF_config_pipe(pHTC->hifHandle, pMsg->PipeID, pMsg->CreditCount);
    
config_done:      
	/* send out the response message */
	HTC_SendMsg(pHTC, ENDPOINT0, pBuffer);             
  90a079:	235284        	l32i	a3, a5, 0x210
  90a07c:	dc60      	mov.n	a12, a6
  90a07e:	c0b0      	movi.n	a11, 0
  90a080:	da20      	mov.n	a10, a2
  90a082:	0b3000        	callx8	a3
  90a085:	d10f      	retw.n
	...

0090a088 <HTCControlSvcProcessMsg>:
}

/* process an incomming control message from the host */
LOCAL void HTCControlSvcProcessMsg(HTC_ENDPOINT_ID EndpointID, adf_nbuf_t hdr_buf,
				   adf_nbuf_t pBuffers, void *arg)
{  
  90a088:	6c1006        	entry	a1, 48
  90a08b:	1668bf        	l32r	a6, 8e4388 <bStandardCommand+0x524>
	a_uint8_t *anbdata;
	a_uint32_t anblen;
	HTC_CONTEXT *pHTC = (HTC_CONTEXT *)arg;
	HTC_UNKNOWN_MSG  *pMsg;
	
	adf_os_assert(hdr_buf == ADF_NBUF_NULL);
  90a08e:	643013        	beqz	a3, 90a0a5 <HTCControlSvcProcessMsg+0x1d>
  90a091:	236212        	l32i	a3, a6, 72
  90a094:	1b69fa        	l32r	a11, 8e487c <bStandardCommand+0xa18>
  90a097:	1a69fb        	l32r	a10, 8e4884 <bStandardCommand+0xa20>
  90a09a:	0b3000        	callx8	a3
  90a09d:	136923        	l32r	a3, 8e452c <bStandardCommand+0x6c8>
  90a0a0:	0c0200        	memw
  90a0a3:	8330      	l32i.n	a3, a3, 0
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  90a0a5:	b41b      	addi.n	a11, a1, 4
  90a0a7:	dc10      	mov.n	a12, a1
  90a0a9:	da40      	mov.n	a10, a4
  90a0ab:	5bf2f7        	call8	906c88 <__adf_nbuf_peek_header>

	/* we assume buffers are aligned such that we can access the message
	 * parameters directly*/
	adf_nbuf_peek_header(pBuffers, &anbdata, &anblen);
	pMsg = (HTC_UNKNOWN_MSG *)anbdata;
  90a0ae:	8b11      	l32i.n	a11, a1, 4
    
	/* we cannot handle fragmented messages across buffers */
    
	switch ( adf_os_ntohs(pMsg->MessageID) ) {        
  90a0b0:	28b000        	l8ui	a8, a11, 0
  90a0b3:	088311        	slli	a3, a8, 8
  90a0b6:	28b001        	l8ui	a8, a11, 1
  90a0b9:	038802        	or	a8, a8, a3
		break;            
        case HTC_MSG_SETUP_COMPLETE_ID:
                /* the host has indicated that it has completed all
		   setup tasks and we can now let the services take over to
		   run the rest of the application */
		setupComplete = TRUE;  
  90a0bc:	c031      	movi.n	a3, 1
	adf_nbuf_peek_header(pBuffers, &anbdata, &anblen);
	pMsg = (HTC_UNKNOWN_MSG *)anbdata;
    
	/* we cannot handle fragmented messages across buffers */
    
	switch ( adf_os_ntohs(pMsg->MessageID) ) {        
  90a0be:	688416        	beqi	a8, 4, 90a0d8 <HTCControlSvcProcessMsg+0x50>
  90a0c1:	68850c        	beqi	a8, 5, 90a0d1 <HTCControlSvcProcessMsg+0x49>
  90a0c4:	69820e        	bnei	a8, 2, 90a0d6 <HTCControlSvcProcessMsg+0x4e>
        case HTC_MSG_CONNECT_SERVICE_ID:
		HTCProcessConnectMsg(pHTC, (HTC_CONNECT_SERVICE_MSG *)pMsg); 
  90a0c7:	da50      	mov.n	a10, a5
  90a0c9:	5bff98        	call8	909f2c <HTCProcessConnectMsg>
  90a0cc:	600006        	j	90a0d6 <HTCControlSvcProcessMsg+0x4e>
  90a0cf:	0000da        	excw
		break;
        case HTC_MSG_CONFIG_PIPE_ID:
		HTCProcessConfigPipeMsg(pHTC, (HTC_CONFIG_PIPE_MSG *)pMsg); 
  90a0d2:	505bff        	call0	9210d0 <_etext+0x11e9f>
  90a0d5:	cec0      	bnez.n	a12, 90a0f9 <HTCControlSvcProcessMsg+0x71>

/* process an incomming control message from the host */
LOCAL void HTCControlSvcProcessMsg(HTC_ENDPOINT_ID EndpointID, adf_nbuf_t hdr_buf,
				   adf_nbuf_t pBuffers, void *arg)
{  
	A_BOOL setupComplete = FALSE;
  90a0d7:	302852        	excw
		break;
        default:
		;
	}  
        
	if (pHTC->StateFlags & HTC_STATE_SETUP_COMPLETE) {
  90a0da:	927f      	s32i.n	a2, a7, 60
  90a0dc:	870b      	l32i.n	a7, a0, 44
		/* recycle buffer only if we are fully running */
		HTC_ReturnBuffers(pHTC, ENDPOINT0,pBuffers);
  90a0de:	226282        	l32i	a2, a6, 0x208
  90a0e1:	dc40      	mov.n	a12, a4
  90a0e3:	c0b0      	movi.n	a11, 0
  90a0e5:	da50      	mov.n	a10, a5
  90a0e7:	60001b        	j	90a106 <HTCControlSvcProcessMsg+0x7e>
 *         or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_push_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_push_head(buf, size);
  90a0ea:	c0b8      	movi.n	a11, 8
  90a0ec:	da40      	mov.n	a10, a4
  90a0ee:	5bf20f        	call8	90692c <__adf_nbuf_push_head>
	} else {
		/* supply some head-room again */
		adf_nbuf_push_head(pBuffers, HTC_HDR_LENGTH);
            
		/* otherwise return the packet back to mbox */
		HIF_return_recv_buf(pHTC->hifHandle, pHTC->Endpoints[EndpointID].UpLinkPipeID, pBuffers);        
  90a0f1:	0f2811        	slli	a8, a2, 1
  90a0f4:	a288      	add.n	a8, a8, a2
  90a0f6:	0d8811        	slli	a8, a8, 3
  90a0f9:	a858      	add.n	a8, a5, a8
  90a0fb:	226277        	l32i	a2, a6, 0x1dc
  90a0fe:	2b8019        	l8ui	a11, a8, 25
  90a101:	2a529a        	l32i	a10, a5, 0x268
  90a104:	dc40      	mov.n	a12, a4
  90a106:	0b2000        	callx8	a2
	}

	if (setupComplete) {        
  90a109:	c931      	beqz.n	a3, 90a11e <HTCControlSvcProcessMsg+0x96>
		/* mark that setup has completed */
		pHTC->StateFlags |= HTC_STATE_SETUP_COMPLETE; 
  90a10b:	225292        	l32i	a2, a5, 0x248
  90a10e:	c031      	movi.n	a3, 1
  90a110:	032202        	or	a2, a2, a3
  90a113:	225692        	s32i	a2, a5, 0x248
		if (pHTC->SetupCompleteCb != NULL) {
  90a116:	225293        	l32i	a2, a5, 0x24c
  90a119:	c821      	beqz.n	a2, 90a11e <HTCControlSvcProcessMsg+0x96>
			pHTC->SetupCompleteCb();
  90a11b:	0b2000        	callx8	a2
  90a11e:	d10f      	retw.n

0090a120 <AdjustCreditThreshold>:
					  buf, 
					  pHTC->Endpoints[current_eid].pService->ServiceCtx);
}

LOCAL void AdjustCreditThreshold(HTC_ENDPOINT  *pEndpoint)
{
  90a120:	6c1004        	entry	a1, 32
	A_INT16 creditsOutstanding = pEndpoint->CreditsToReturn + pEndpoint->CreditsConsumed;
  90a123:	292105        	l16ui	a9, a2, 10
  90a126:	282100        	l16ui	a8, a2, 0
  90a129:	a988      	add.n	a8, a8, a9
        /* set the new threshold based on the number of credits that have been consumed
         * and which have not been returned by the app.
         * Note: it is okay for this threshold to be zero which indicates no threshold 
         * is in use */    
	switch (pEndpoint->ConnectionFlags & HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_MASK) {
  90a12b:	292106        	l16ui	a9, a2, 12
					  pHTC->Endpoints[current_eid].pService->ServiceCtx);
}

LOCAL void AdjustCreditThreshold(HTC_ENDPOINT  *pEndpoint)
{
	A_INT16 creditsOutstanding = pEndpoint->CreditsToReturn + pEndpoint->CreditsConsumed;
  90a12e:	088832        	sext	a8, a8, 15
        /* set the new threshold based on the number of credits that have been consumed
         * and which have not been returned by the app.
         * Note: it is okay for this threshold to be zero which indicates no threshold 
         * is in use */    
	switch (pEndpoint->ConnectionFlags & HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_MASK) {
  90a131:	090941        	extui	a9, a9, 0, 2
  90a134:	68910d        	beqi	a9, 1, 90a145 <AdjustCreditThreshold+0x25>
  90a137:	c894      	beqz.n	a9, 90a13f <AdjustCreditThreshold+0x1f>
  90a139:	68920f        	beqi	a9, 2, 90a14c <AdjustCreditThreshold+0x2c>
  90a13c:	600017        	j	90a157 <AdjustCreditThreshold+0x37>
        case HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_ONE_FOURTH :
		creditsOutstanding >>= 2;
  90a13f:	082812        	srai	a8, a8, 2
		break;                    
  90a142:	600011        	j	90a157 <AdjustCreditThreshold+0x37>
        case HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_ONE_HALF :
		creditsOutstanding >>= 1;
  90a145:	081812        	srai	a8, a8, 1
		break;
  90a148:	60000b        	j	90a157 <AdjustCreditThreshold+0x37>
  90a14b:	000f89        	excw
        case HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_THREE_FOURTHS :  
		creditsOutstanding = (creditsOutstanding * 3) >> 2;                  
  90a14e:	11a898        	l32r	a1, 8f43b0 <memset+0xd568>
  90a151:	082812        	srai	a8, a8, 2
  90a154:	088832        	sext	a8, a8, 15
		break;
		/* default case is unity */    
	}
    
	pEndpoint->CreditReturnThreshhold = creditsOutstanding;
  90a157:	282504        	s16i	a8, a2, 8
  90a15a:	d10f      	retw.n

0090a15c <_HTC_SendMsg>:
	ReturnBuffers(htcHandle, EndpointID, pBuffers, TRUE);
}
 
LOCAL void _HTC_SendMsg(htc_handle_t htcHandle, HTC_ENDPOINT_ID EndpointID,
			adf_nbuf_t pBuffers)
{
  90a15c:	6c1008        	entry	a1, 64
 * @return data pointer to typecast into your priv structure
 */
static inline a_uint8_t *
adf_nbuf_get_priv(adf_nbuf_t buf)
{
    return (__adf_nbuf_get_priv(buf));
  90a15f:	044a02        	or	a10, a4, a4
  90a162:	5bf222        	call8	9069ec <__adf_nbuf_get_priv>
  90a165:	d5a0      	mov.n	a5, a10
 * @return The total length of this buf.
 */
static inline adf_os_size_t
adf_nbuf_len(adf_nbuf_t buf)
{
    return (__adf_nbuf_len(buf));
  90a167:	da40      	mov.n	a10, a4
  90a169:	5bf2bf        	call8	906c68 <__adf_nbuf_len>
  90a16c:	9a10      	s32i.n	a10, a1, 0
 *         or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_push_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_push_head(buf, size);
  90a16e:	c0b8      	movi.n	a11, 8
  90a170:	da40      	mov.n	a10, a4
  90a172:	5bf1ee        	call8	90692c <__adf_nbuf_push_head>
	 * Note: in HTCSendDoneHandler(), we undo this so that the caller get's it's buffer
	 * back untainted */   
	pHTCHdr = (HTC_FRAME_HDR *)adf_nbuf_push_head(pBuffers, HTC_HDR_LENGTH);
    
	/* flag that this is the header buffer that was modified */
	ctx->htc_flags |= HTC_FLAGS_BUF_HDR;   
  90a175:	285001        	l8ui	a8, a5, 1
  90a178:	c490      	movi.n	a9, 64
  90a17a:	098802        	or	a8, a8, a9
  90a17d:	285401        	s8i	a8, a5, 1
	/* mark where this buffer came from */
	ctx->end_point = EndpointID;      
  90a180:	030847        	extui	a8, a3, 0, 8
  90a183:	285400        	s8i	a8, a5, 0
	/* the header start is ALWAYS aligned since we DMA it directly */

        /* set some fields, the rest of them will be filled below when we check for
	 * trailer space */
	pHTCHdr->Flags = 0;
  90a186:	c050      	movi.n	a5, 0
  90a188:	25a401        	s8i	a5, a10, 1
		HTC_RECORD_HDR    *pRecHdr;
		int               pipeMaxLen;
		A_UINT32          roomForPipeMaxLen;
                          
		/* figure out how much room the last buffer can spare */
		pipeMaxLen = HIF_get_max_msg_len(pHTC->hifHandle,
  90a18b:	0f3511        	slli	a5, a3, 1
  90a18e:	a355      	add.n	a5, a5, a3
	/* the header start is ALWAYS aligned since we DMA it directly */

        /* set some fields, the rest of them will be filled below when we check for
	 * trailer space */
	pHTCHdr->Flags = 0;
	pHTCHdr->EndpointID = EndpointID;    
  90a190:	28a400        	s8i	a8, a10, 0
		HTC_RECORD_HDR    *pRecHdr;
		int               pipeMaxLen;
		A_UINT32          roomForPipeMaxLen;
                          
		/* figure out how much room the last buffer can spare */
		pipeMaxLen = HIF_get_max_msg_len(pHTC->hifHandle,
  90a193:	0d5511        	slli	a5, a5, 3
  90a196:	1868bf        	l32r	a8, 8e4494 <bStandardCommand+0x630>
  90a199:	a525      	add.n	a5, a2, a5
  90a19b:	2b5018        	l8ui	a11, a5, 24
  90a19e:	288279        	l32i	a8, a8, 0x1e4
  90a1a1:	d6a0      	mov.n	a6, a10
  90a1a3:	2a229a        	l32i	a10, a2, 0x268
  90a1a6:	0b8000        	callx8	a8
  90a1a9:	d5a0      	mov.n	a5, a10
 * @return amount of head room
 */
static inline a_uint32_t
adf_nbuf_headroom(adf_nbuf_t buf)
{
    return (__adf_nbuf_headroom(buf));
  90a1ab:	da40      	mov.n	a10, a4
  90a1ad:	5bf2a4        	call8	906c40 <__adf_nbuf_headroom>
						 pHTC->Endpoints[EndpointID].DownLinkPipeID);
		roomForPipeMaxLen = pipeMaxLen - adf_nbuf_headroom(pBuffers) - adf_nbuf_len(pBuffers);
  90a1b0:	0a550c        	sub	a5, a5, a10
 * @return The total length of this buf.
 */
static inline adf_os_size_t
adf_nbuf_len(adf_nbuf_t buf)
{
    return (__adf_nbuf_len(buf));
  90a1b3:	da40      	mov.n	a10, a4
  90a1b5:	5bf2ac        	call8	906c68 <__adf_nbuf_len>
  90a1b8:	0a550c        	sub	a5, a5, a10
 * @return amount of tail room 
 */
static inline a_uint32_t
adf_nbuf_tailroom(adf_nbuf_t buf)
{
    return (__adf_nbuf_tailroom(buf));
  90a1bb:	da40      	mov.n	a10, a4
  90a1bd:	5bf2a3        	call8	906c4c <__adf_nbuf_tailroom>
		if ( roomForPipeMaxLen < 0 ) {
			roomForPipeMaxLen = 0;
		}
                        
		room = adf_os_min( adf_nbuf_tailroom(pBuffers), roomForPipeMaxLen);
  90a1c0:	75ab06        	bgeu	a10, a5, 90a1ca <_HTC_SendMsg+0x6e>
  90a1c3:	da40      	mov.n	a10, a4
  90a1c5:	5bf2a1        	call8	906c4c <__adf_nbuf_tailroom>
  90a1c8:	d5a0      	mov.n	a5, a10
		if (room < (int)(sizeof(HTC_CREDIT_REPORT) + sizeof(HTC_RECORD_HDR))) {
  90a1ca:	6b5402        	bgei	a5, 4, 90a1d0 <_HTC_SendMsg+0x74>
  90a1cd:	6000ad        	j	90a27e <_HTC_SendMsg+0x122>
		/* note, a record header only has 8 bit fields, so this is safe.
		 * we need an uncached pointer here too */            
		totalReportBytes = 0;
        
		/* get a copy */        
		creditsPendingMap = pHTC->EpCreditPendingMap;   
  90a1d0:	272286        	l32i	a7, a2, 0x218
                           
		/* test pending map to see if we can send a report , if any
		 * credits are available, we might as well send them on the 
		 * unused space in the buffer */
		if (creditsPendingMap) { 
  90a1d3:	6470a7        	beqz	a7, 90a27e <_HTC_SendMsg+0x122>
 *         put, or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_put_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_put_tail(buf, size);
  90a1d6:	c0b2      	movi.n	a11, 2
  90a1d8:	da40      	mov.n	a10, a4
  90a1da:	5bf280        	call8	906bdc <__adf_nbuf_put_tail>
			pRecHdr = (HTC_RECORD_HDR *)adf_nbuf_put_tail(pBuffers,
							      sizeof(HTC_RECORD_HDR));
            
			/* set the ID, the length will be updated with the number of credit reports we
			 * can fit (see below) */
			pRecHdr->RecordID = HTC_RECORD_CREDITS;
  90a1dd:	c091      	movi.n	a9, 1
  90a1df:	29a400        	s8i	a9, a10, 0
			pRecHdr->Length = 0;
  90a1e2:	c090      	movi.n	a9, 0
  90a1e4:	29a401        	s8i	a9, a10, 1
  90a1e7:	dea0      	mov.n	a14, a10
			/* the credit report follows the record header */         
			totalReportBytes += sizeof(HTC_RECORD_HDR);
			room -= sizeof(HTC_RECORD_HDR);
  90a1e9:	255cfe        	addi	a5, a5, -2
  90a1ec:	b429      	addi.n	a9, a2, 4
			/* set the ID, the length will be updated with the number of credit reports we
			 * can fit (see below) */
			pRecHdr->RecordID = HTC_RECORD_CREDITS;
			pRecHdr->Length = 0;
			/* the credit report follows the record header */         
			totalReportBytes += sizeof(HTC_RECORD_HDR);
  90a1ee:	c0c2      	movi.n	a12, 2
			room -= sizeof(HTC_RECORD_HDR);
            
			/* walkthrough pending credits map and build the records */
			for (i = 0; 
  90a1f0:	c0d0      	movi.n	a13, 0
  90a1f2:	600069        	j	90a25f <_HTC_SendMsg+0x103>
			     (creditsPendingMap != 0) && (room >= (int)sizeof(HTC_CREDIT_REPORT)); 
			     i++) {                
				compareMask = (1 << i);
  90a1f5:	c081      	movi.n	a8, 1
  90a1f7:	00d104        	ssl	a13
  90a1fa:	008f1a        	sll	a15, a8
				if (compareMask & creditsPendingMap) {
  90a1fd:	7f7059        	bnone	a7, a15, 90a25a <_HTC_SendMsg+0xfe>
  90a200:	c0b2      	movi.n	a11, 2
  90a202:	da40      	mov.n	a10, a4
  90a204:	9915      	s32i.n	a9, a1, 20
  90a206:	9c13      	s32i.n	a12, a1, 12
  90a208:	9d12      	s32i.n	a13, a1, 8
  90a20a:	9e14      	s32i.n	a14, a1, 16
  90a20c:	9f11      	s32i.n	a15, a1, 4
  90a20e:	5bf273        	call8	906bdc <__adf_nbuf_put_tail>
									    sizeof(HTC_CREDIT_REPORT));
                                    
					/* clear pending mask, we are going to return all these credits */
					creditsPendingMap &= ~(compareMask);
					/* add this record */
					pCreditRpt->EndpointID = i;
  90a211:	8d12      	l32i.n	a13, a1, 8
                        
					pCreditRpt = (HTC_CREDIT_REPORT *)adf_nbuf_put_tail(pBuffers,
									    sizeof(HTC_CREDIT_REPORT));
                                    
					/* clear pending mask, we are going to return all these credits */
					creditsPendingMap &= ~(compareMask);
  90a213:	8f11      	l32i.n	a15, a1, 4
					/* add this record */
					pCreditRpt->EndpointID = i;
  90a215:	2da400        	s8i	a13, a10, 0
					pCreditRpt->Credits = (A_UINT8)pHTC->Endpoints[i].CreditsToReturn;
  90a218:	8915      	l32i.n	a9, a1, 20
                        
					pCreditRpt = (HTC_CREDIT_REPORT *)adf_nbuf_put_tail(pBuffers,
									    sizeof(HTC_CREDIT_REPORT));
                                    
					/* clear pending mask, we are going to return all these credits */
					creditsPendingMap &= ~(compareMask);
  90a21a:	c7bf      	movi.n	a11, -1
  90a21c:	0fbf03        	xor	a15, a11, a15
					/* add this record */
					pCreditRpt->EndpointID = i;
					pCreditRpt->Credits = (A_UINT8)pHTC->Endpoints[i].CreditsToReturn;
  90a21f:	2b9100        	l16ui	a11, a9, 0
                        
					pCreditRpt = (HTC_CREDIT_REPORT *)adf_nbuf_put_tail(pBuffers,
									    sizeof(HTC_CREDIT_REPORT));
                                    
					/* clear pending mask, we are going to return all these credits */
					creditsPendingMap &= ~(compareMask);
  90a222:	0f7701        	and	a7, a7, a15
					/* add this record */
					pCreditRpt->EndpointID = i;
					pCreditRpt->Credits = (A_UINT8)pHTC->Endpoints[i].CreditsToReturn;
  90a225:	2ba401        	s8i	a11, a10, 1
					/* remove pending credits, we always send deltas */
					pHTC->Endpoints[i].CreditsToReturn = 0; 
  90a228:	c0a0      	movi.n	a10, 0
  90a22a:	2a9500        	s16i	a10, a9, 0
					/* adjust new threshold for this endpoint if needed */
					CHECK_AND_ADJUST_CREDIT_THRESHOLD(&pHTC->Endpoints[i]);
  90a22d:	2a9106        	l16ui	a10, a9, 12
  90a230:	8c13      	l32i.n	a12, a1, 12
  90a232:	8e14      	l32i.n	a14, a1, 16
  90a234:	7da710        	bbci	a10, 29, 90a248 <_HTC_SendMsg+0xec>
  90a237:	da90      	mov.n	a10, a9
  90a239:	9915      	s32i.n	a9, a1, 20
  90a23b:	9d12      	s32i.n	a13, a1, 8
  90a23d:	5bffb8        	call8	90a120 <AdjustCreditThreshold>
  90a240:	8e14      	l32i.n	a14, a1, 16
  90a242:	8d12      	l32i.n	a13, a1, 8
  90a244:	8c13      	l32i.n	a12, a1, 12
  90a246:	8915      	l32i.n	a9, a1, 20
					/* update this record length */
					pRecHdr->Length += sizeof(HTC_CREDIT_REPORT);
  90a248:	2ae001        	l8ui	a10, a14, 1
					room -= sizeof(HTC_CREDIT_REPORT);
  90a24b:	255cfe        	addi	a5, a5, -2
					/* remove pending credits, we always send deltas */
					pHTC->Endpoints[i].CreditsToReturn = 0; 
					/* adjust new threshold for this endpoint if needed */
					CHECK_AND_ADJUST_CREDIT_THRESHOLD(&pHTC->Endpoints[i]);
					/* update this record length */
					pRecHdr->Length += sizeof(HTC_CREDIT_REPORT);
  90a24e:	2aac02        	addi	a10, a10, 2
  90a251:	2ae401        	s8i	a10, a14, 1
					room -= sizeof(HTC_CREDIT_REPORT);
					totalReportBytes += sizeof(HTC_CREDIT_REPORT);
  90a254:	2ccc02        	addi	a12, a12, 2

					if ( room < sizeof(HTC_CREDIT_REPORT) ) {
  90a257:	6e5209        	bltui	a5, 2, 90a264 <_HTC_SendMsg+0x108>
			room -= sizeof(HTC_RECORD_HDR);
            
			/* walkthrough pending credits map and build the records */
			for (i = 0; 
			     (creditsPendingMap != 0) && (room >= (int)sizeof(HTC_CREDIT_REPORT)); 
			     i++) {                
  90a25a:	b1dd      	addi.n	a13, a13, 1
  90a25c:	299c18        	addi	a9, a9, 24
			/* the credit report follows the record header */         
			totalReportBytes += sizeof(HTC_RECORD_HDR);
			room -= sizeof(HTC_RECORD_HDR);
            
			/* walkthrough pending credits map and build the records */
			for (i = 0; 
  90a25f:	c871      	beqz.n	a7, 90a264 <_HTC_SendMsg+0x108>
			     (creditsPendingMap != 0) && (room >= (int)sizeof(HTC_CREDIT_REPORT)); 
  90a261:	6b5290        	bgei	a5, 2, 90a1f5 <_HTC_SendMsg+0x99>
					}
				}
			}
            
			/* update new pending credits map */       
			pHTC->EpCreditPendingMap = creditsPendingMap;
  90a264:	272686        	s32i	a7, a2, 0x218
		}
        
		if (totalReportBytes <= 0) {
  90a267:	6ac113        	blti	a12, 1, 90a27e <_HTC_SendMsg+0x122>
		 */
        
		/* set header option bytes */ 
		pHTCHdr->ControlBytes[0] = totalReportBytes;
		/* HTC frame contains a trailer */
		pHTCHdr->Flags |= HTC_FLAGS_RECV_TRAILER;
  90a26a:	256001        	l8ui	a5, a6, 1
  90a26d:	c082      	movi.n	a8, 2
  90a26f:	085502        	or	a5, a5, a8
  90a272:	256401        	s8i	a5, a6, 1
		/* increment total size by the reports we added */
		totsz += totalReportBytes;
  90a275:	8510      	l32i.n	a5, a1, 0
		 * The trailer can have at most 1 credit record with up to 32  reports in the record.
		 * The trailer can have at most 1 lookahead record with only 1 lookahead report in the record.
		 */
        
		/* set header option bytes */ 
		pHTCHdr->ControlBytes[0] = totalReportBytes;
  90a277:	2c6404        	s8i	a12, a6, 4
		/* HTC frame contains a trailer */
		pHTCHdr->Flags |= HTC_FLAGS_RECV_TRAILER;
		/* increment total size by the reports we added */
		totsz += totalReportBytes;
  90a27a:	ac55      	add.n	a5, a5, a12
  90a27c:	9510      	s32i.n	a5, a1, 0
          
	if (totsz == 0) {
	}
    
	/* set length for message (this includes any reports that were added above) */
	pHTCHdr->PayloadLen = adf_os_htons(totsz);  
  90a27e:	8810      	l32i.n	a8, a1, 0
	HIF_send_buffer(pHTC->hifHandle, pHTC->Endpoints[EndpointID].DownLinkPipeID, pBuffers);       
  90a280:	2a229a        	l32i	a10, a2, 0x268
          
	if (totsz == 0) {
	}
    
	/* set length for message (this includes any reports that were added above) */
	pHTCHdr->PayloadLen = adf_os_htons(totsz);  
  90a283:	08074f        	extui	a7, a8, 0, 16
  90a286:	078514        	srli	a5, a7, 8
  90a289:	256402        	s8i	a5, a6, 2
	HIF_send_buffer(pHTC->hifHandle, pHTC->Endpoints[EndpointID].DownLinkPipeID, pBuffers);       
  90a28c:	0f3511        	slli	a5, a3, 1
  90a28f:	a353      	add.n	a3, a5, a3
  90a291:	0d3311        	slli	a3, a3, 3
  90a294:	1568bf        	l32r	a5, 8e4590 <bStandardCommand+0x72c>
          
	if (totsz == 0) {
	}
    
	/* set length for message (this includes any reports that were added above) */
	pHTCHdr->PayloadLen = adf_os_htons(totsz);  
  90a297:	276403        	s8i	a7, a6, 3
	HIF_send_buffer(pHTC->hifHandle, pHTC->Endpoints[EndpointID].DownLinkPipeID, pBuffers);       
  90a29a:	a323      	add.n	a3, a2, a3
  90a29c:	255276        	l32i	a5, a5, 0x1d8
  90a29f:	2b3018        	l8ui	a11, a3, 24
  90a2a2:	044c02        	or	a12, a4, a4
  90a2a5:	0b5000        	callx8	a5
  90a2a8:	d10f      	retw.n
	...

0090a2ac <HTCMsgRecvHandler>:

}
            
/* callback from the mailbox hardware layer when a full message arrives */
LOCAL void HTCMsgRecvHandler(adf_nbuf_t hdr_buf, adf_nbuf_t buffer, void *context)
{
  90a2ac:	6c1008        	entry	a1, 64
  90a2af:	9315      	s32i.n	a3, a1, 20
	a_uint32_t anblen;
	HTC_FRAME_HDR *pHTCHdr;
	HTC_CONTEXT *pHTC = (HTC_CONTEXT *)context;
	adf_nbuf_t tmp_nbuf;
                
	if (hdr_buf == ADF_NBUF_NULL) {
  90a2b1:	022339        	movnez	a3, a2, a2
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  90a2b4:	dc10      	mov.n	a12, a1
  90a2b6:	b41b      	addi.n	a11, a1, 4
  90a2b8:	da30      	mov.n	a10, a3
  90a2ba:	5bf273        	call8	906c88 <__adf_nbuf_peek_header>
	else {
		tmp_nbuf = hdr_buf;
	}
                
	adf_nbuf_peek_header(tmp_nbuf, &anbdata, &anblen);        
	pHTCHdr = (HTC_FRAME_HDR *)anbdata; 
  90a2bd:	8511      	l32i.n	a5, a1, 4
	a_uint32_t anblen;
	HTC_FRAME_HDR *pHTCHdr;
	HTC_CONTEXT *pHTC = (HTC_CONTEXT *)context;
	adf_nbuf_t tmp_nbuf;
                
	if (hdr_buf == ADF_NBUF_NULL) {
  90a2bf:	d730      	mov.n	a7, a3
	eid = pHTCHdr->EndpointID; 
    
	pEndpoint = &pHTC->Endpoints[eid];
	eidMask = 1 << eid;

	if (pHTCHdr->Flags & HTC_FLAGS_CREDIT_REDISTRIBUTION) {
  90a2c1:	265001        	l8ui	a6, a5, 1
  90a2c4:	7d6702        	bbci	a6, 29, 90a2ca <HTCMsgRecvHandler+0x1e>
  90a2c7:	60009d        	j	90a368 <HTCMsgRecvHandler+0xbc>
	adf_nbuf_peek_header(tmp_nbuf, &anbdata, &anblen);        
	pHTCHdr = (HTC_FRAME_HDR *)anbdata; 
      
	totsz = adf_os_ntohs(pHTCHdr->PayloadLen); 
    
	eid = pHTCHdr->EndpointID; 
  90a2ca:	235000        	l8ui	a3, a5, 0
		 * Byte 0 */
		RedistributeCredit(tmp_nbuf, pHTCHdr->ControlBytes[0]);
		return;
	}

	if (pHTC->StateFlags & HTC_STATE_SETUP_COMPLETE) {
  90a2cd:	254292        	l32i	a5, a4, 0x248
  90a2d0:	03094f        	extui	a9, a3, 0, 16
  90a2d3:	7f5711        	bbci	a5, 31, 90a2e8 <HTCMsgRecvHandler+0x3c>
  90a2d6:	0f9511        	slli	a5, a9, 1
  90a2d9:	a955      	add.n	a5, a5, a9
  90a2db:	0d5511        	slli	a5, a5, 3
  90a2de:	a545      	add.n	a5, a4, a5
		/* after setup we keep track of credit consumption to allow us to
		 * adjust thresholds to reduce credit dribbling */  
		pEndpoint->CreditsConsumed ++;
  90a2e0:	2a5107        	l16ui	a10, a5, 14
  90a2e3:	b1aa      	addi.n	a10, a10, 1
  90a2e5:	2a5507        	s16i	a10, a5, 14
      
	totsz = adf_os_ntohs(pHTCHdr->PayloadLen); 
    
	eid = pHTCHdr->EndpointID; 
    
	pEndpoint = &pHTC->Endpoints[eid];
  90a2e8:	0f9511        	slli	a5, a9, 1
  90a2eb:	a955      	add.n	a5, a5, a9
  90a2ed:	0d5511        	slli	a5, a5, 3
  90a2f0:	b455      	addi.n	a5, a5, 4
	eidMask = 1 << eid;
  90a2f2:	c091      	movi.n	a9, 1
      
	totsz = adf_os_ntohs(pHTCHdr->PayloadLen); 
    
	eid = pHTCHdr->EndpointID; 
    
	pEndpoint = &pHTC->Endpoints[eid];
  90a2f4:	a545      	add.n	a5, a4, a5
  90a2f6:	9514      	s32i.n	a5, a1, 16
	/* from the design document, we put the endpoint into a "host-needs-credit" state
	 * when we receive a frame with the NEED_CREDIT_UPDATE flag set .
	 * if the host received credits through an opportunistic path, then it can
	 * issue a another frame with this bit cleared, this signals the target to clear
	 * the "host-needs-credit" state */    
	if (pHTCHdr->Flags & HTC_FLAGS_NEED_CREDIT_UPDATE) {
  90a2f8:	096b01        	and	a11, a6, a9
	totsz = adf_os_ntohs(pHTCHdr->PayloadLen); 
    
	eid = pHTCHdr->EndpointID; 
    
	pEndpoint = &pHTC->Endpoints[eid];
	eidMask = 1 << eid;
  90a2fb:	003104        	ssl	a3
  90a2fe:	00951a        	sll	a5, a9
  90a301:	2a4285        	l32i	a10, a4, 0x214
  90a304:	009104        	ssl	a9
  90a307:	00361a        	sll	a6, a3
	/* from the design document, we put the endpoint into a "host-needs-credit" state
	 * when we receive a frame with the NEED_CREDIT_UPDATE flag set .
	 * if the host received credits through an opportunistic path, then it can
	 * issue a another frame with this bit cleared, this signals the target to clear
	 * the "host-needs-credit" state */    
	if (pHTCHdr->Flags & HTC_FLAGS_NEED_CREDIT_UPDATE) {
  90a30a:	c9bb      	beqz.n	a11, 90a329 <HTCMsgRecvHandler+0x7d>
		/* the host is running low (or is out) of credits on this
		 * endpoint, update mask */
		pHTC->EpHostNeedsCreditMap |= eidMask; 
  90a30c:	05aa02        	or	a10, a10, a5
  90a30f:	2a4685        	s32i	a10, a4, 0x214
		/* check and set new threshold since host has reached a low credit situation */
		CHECK_AND_ADJUST_CREDIT_THRESHOLD(pEndpoint);                          
  90a312:	a36a      	add.n	a10, a6, a3
  90a314:	0daa11        	slli	a10, a10, 3
  90a317:	aa4a      	add.n	a10, a4, a10
  90a319:	2aa108        	l16ui	a10, a10, 16
  90a31c:	7da71e        	bbci	a10, 29, 90a33e <HTCMsgRecvHandler+0x92>
  90a31f:	8a14      	l32i.n	a10, a1, 16
  90a321:	5bff7f        	call8	90a120 <AdjustCreditThreshold>
  90a324:	600016        	j	90a33e <HTCMsgRecvHandler+0x92>
  90a327:	0000c7        	excw
	} else {
		/* clear the flag */
		pHTC->EpHostNeedsCreditMap &= ~(eidMask);       
  90a32a:	cf05      	bnez.n	a0, 90a363 <HTCMsgRecvHandler+0xb7>
  90a32c:	cc03      	bnez.n	a0, 90a333 <HTCMsgRecvHandler+0x87>
  90a32e:	0caa01        	and	a10, a10, a12
  90a331:	2a4685        	s32i	a10, a4, 0x214
		pEndpoint->CreditReturnThreshhold = 0; 
  90a334:	a36a      	add.n	a10, a6, a3
  90a336:	0daa11        	slli	a10, a10, 3
  90a339:	aa4a      	add.n	a10, a4, a10
  90a33b:	2ba506        	s16i	a11, a10, 12
	 *        as the result of parsing this message.  In either case, if there are
	 *        pending credits and the host needs them, a credit report will be sent either through 
	 *        the response message trailer or a NULL message through HTC_ReturnBuffers().
	 */       
        
	pEndpoint->pService->ProcessRecvMsg(eid, hdr_buf, buffer, pEndpoint->pService->ServiceCtx);
  90a33e:	a366      	add.n	a6, a6, a3
  90a340:	0d6611        	slli	a6, a6, 3
 *         or NULL if there is not sufficient data to pull.
 */
static inline a_uint8_t *
adf_nbuf_pull_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_pull_head(buf, size);
  90a343:	c0b8      	movi.n	a11, 8
  90a345:	da70      	mov.n	a10, a7
  90a347:	064608        	add	a6, a4, a6
  90a34a:	5bf183        	call8	906958 <__adf_nbuf_pull_head>
  90a34d:	8662      	l32i.n	a6, a6, 8
  90a34f:	8c15      	l32i.n	a12, a1, 20
  90a351:	8d66      	l32i.n	a13, a6, 24
  90a353:	8761      	l32i.n	a7, a6, 4
  90a355:	db20      	mov.n	a11, a2
  90a357:	033a02        	or	a10, a3, a3
  90a35a:	0b7000        	callx8	a7

	/* Calls to HTC_ReturnBuffers drives the endpoint credit reporting state machine. 
	 * We do not want to delay credits for too long in the event that the application is 
	 * holding onto buffers for excessive periods of time.  This gives us "some" better
	 * opportunities to send up credits. */
	HTCCheckAndSendCreditReport(pHTC, eidMask, pEndpoint, eid); 
  90a35d:	8c14      	l32i.n	a12, a1, 16
  90a35f:	dd30      	mov.n	a13, a3
  90a361:	db50      	mov.n	a11, a5
  90a363:	da40      	mov.n	a10, a4
  90a365:	5bfe95        	call8	909dbc <HTCCheckAndSendCreditReport>
  90a368:	d10f      	retw.n
	...

0090a36c <RedistributeCredit>:
	pEndpoint->CreditReturnThreshhold = creditsOutstanding;
    
}

LOCAL void RedistributeCredit(adf_nbuf_t buf, int toPipeId)
{
  90a36c:	6c1004        	entry	a1, 32
  90a36f:	d10f      	retw.n
  90a371:	000000        	ill

0090a374 <WMIServiceConnect>:
                                 HTC_ENDPOINT_ID eid, 
                                 A_UINT8 *pDataIn, 
                                 int LengthIn,
                                 A_UINT8 *pDataOut,
                                 int *pLengthOut)
{
  90a374:	6c1004        	entry	a1, 32
	WMI_SVC_CONTEXT *pWMI = (WMI_SVC_CONTEXT *)pService->ServiceCtx;
    
        /* save the eid to use */
	pWMI->ControlEp = eid;
  90a377:	8826      	l32i.n	a8, a2, 24
  90a379:	938a      	s32i.n	a3, a8, 40
	return HTC_SERVICE_SUCCESS;
}
  90a37b:	c020      	movi.n	a2, 0
  90a37d:	d10f      	retw.n
	...

0090a380 <_WMI_GetPendingEventsCount>:
    
	return pWMI;
}

static int _WMI_GetPendingEventsCount(wmi_handle_t handle)
{
  90a380:	6c1004        	entry	a1, 32
	WMI_SVC_CONTEXT *pWMI = (WMI_SVC_CONTEXT *)handle;
	return pWMI->PendingEvents;
}
  90a383:	8222      	l32i.n	a2, a2, 8
  90a385:	d10f      	retw.n
	...

0090a388 <_WMI_GetControlEp>:

static int  _WMI_GetControlEp(wmi_handle_t handle)
{
  90a388:	6c1004        	entry	a1, 32
	WMI_SVC_CONTEXT *pWMI = (WMI_SVC_CONTEXT *)handle;
	return pWMI->ControlEp;
}
  90a38b:	822a      	l32i.n	a2, a2, 40
  90a38d:	d10f      	retw.n
	...

0090a390 <_WMI_RegisterDispatchTable>:

static void _WMI_RegisterDispatchTable(wmi_handle_t handle,
				       WMI_DISPATCH_TABLE *pDispatchTable)
{
  90a390:	6c1004        	entry	a1, 32
	WMI_SVC_CONTEXT *pWMI = (WMI_SVC_CONTEXT *)handle;
    
	if (NULL == pWMI->pDispatchHead) {
  90a393:	882b      	l32i.n	a8, a2, 44
  90a395:	cc83      	bnez.n	a8, 90a39c <_WMI_RegisterDispatchTable+0xc>
		pWMI->pDispatchHead = pDispatchTable;
  90a397:	932b      	s32i.n	a3, a2, 44
  90a399:	600003        	j	90a3a0 <_WMI_RegisterDispatchTable+0x10>
		pWMI->pDispatchTail = pDispatchTable;        
	} else {
		/* link to the tail */
		pWMI->pDispatchTail->pNext = pDispatchTable;
  90a39c:	882c      	l32i.n	a8, a2, 48
  90a39e:	9380      	s32i.n	a3, a8, 0
		pWMI->pDispatchTail = pDispatchTable;        
  90a3a0:	932c      	s32i.n	a3, a2, 48
  90a3a2:	d10f      	retw.n

0090a3a4 <_WMI_Shutdown>:
	
	HTC_SendMsg(pWMI->HtcHandle, pWMI->ControlEp, pEvt);    
}

static void _WMI_Shutdown(wmi_handle_t handle)
{
  90a3a4:	6c1004        	entry	a1, 32
  90a3a7:	d10f      	retw.n
  90a3a9:	000000        	ill

0090a3ac <WMIRecvMessageHandler>:

#include "wmi_internal.h"

static void WMIRecvMessageHandler(HTC_ENDPOINT_ID EndPt, adf_nbuf_t hdr_buf,
				  adf_nbuf_t pHTCBuf, void *arg)
{
  90a3ac:	6c1006        	entry	a1, 48
	int length;
	a_uint8_t *anbdata;
	a_uint32_t anblen;
	WMI_CMD_HDR *cmdHdr;
            
	adf_os_assert(hdr_buf == ADF_NBUF_NULL);
  90a3af:	643016        	beqz	a3, 90a3c9 <WMIRecvMessageHandler+0x1d>
  90a3b2:	1368bf        	l32r	a3, 8e46b0 <bStandardCommand+0x84c>
  90a3b5:	1b69fc        	l32r	a11, 8e4ba8 <mUsbEPinHighBandSet+0x208>
  90a3b8:	233212        	l32i	a3, a3, 72
  90a3bb:	1a69fd        	l32r	a10, 8e4bb0 <mUsbEPinHighBandSet+0x210>
  90a3be:	0b3000        	callx8	a3
  90a3c1:	136923        	l32r	a3, 8e4850 <bStandardCommand+0x9ec>
  90a3c4:	0c0200        	memw
  90a3c7:	8330      	l32i.n	a3, a3, 0
 * @return The total length of this buf.
 */
static inline adf_os_size_t
adf_nbuf_len(adf_nbuf_t buf)
{
    return (__adf_nbuf_len(buf));
  90a3c9:	da40      	mov.n	a10, a4
  90a3cb:	5bf227        	call8	906c68 <__adf_nbuf_len>
  90a3ce:	d3a0      	mov.n	a3, a10

	do {
		length = adf_nbuf_len(pHTCBuf);
		if (length < sizeof(WMI_CMD_HDR)) {
  90a3d0:	6ea44d        	bltui	a10, 4, 90a421 <WMIRecvMessageHandler+0x75>
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  90a3d3:	b41b      	addi.n	a11, a1, 4
  90a3d5:	dc10      	mov.n	a12, a1
  90a3d7:	da40      	mov.n	a10, a4
  90a3d9:	5bf22b        	call8	906c88 <__adf_nbuf_peek_header>
		adf_nbuf_peek_header(pHTCBuf, &anbdata, &anblen);
        
		pCurrentTable = pWMI->pDispatchHead;
		length = length - sizeof(WMI_CMD_HDR);
        
		cmdHdr = (WMI_CMD_HDR *)anbdata;
  90a3dc:	8911      	l32i.n	a9, a1, 4
		}

		adf_nbuf_peek_header(pHTCBuf, &anbdata, &anblen);
        
		pCurrentTable = pWMI->pDispatchHead;
		length = length - sizeof(WMI_CMD_HDR);
  90a3de:	2e3cfc        	addi	a14, a3, -4
        
		cmdHdr = (WMI_CMD_HDR *)anbdata;
		cmd = adf_os_ntohs(cmdHdr->commandId);
  90a3e1:	2b9000        	l8ui	a11, a9, 0
  90a3e4:	239001        	l8ui	a3, a9, 1
  90a3e7:	08bb11        	slli	a11, a11, 8
			break;    
		}

		adf_nbuf_peek_header(pHTCBuf, &anbdata, &anblen);
        
		pCurrentTable = pWMI->pDispatchHead;
  90a3ea:	885b      	l32i.n	a8, a5, 44
		length = length - sizeof(WMI_CMD_HDR);
        
		cmdHdr = (WMI_CMD_HDR *)anbdata;
		cmd = adf_os_ntohs(cmdHdr->commandId);
  90a3ec:	0b3b02        	or	a11, a3, a11
		seq = adf_os_ntohs(cmdHdr->seqNo);
        
		pCmdBuffer = anbdata + sizeof(WMI_CMD_HDR); 
  90a3ef:	b49d      	addi.n	a13, a9, 4
		pCmdHandler = NULL;
        
		while (pCurrentTable != NULL) {
  90a3f1:	600029        	j	90a41e <WMIRecvMessageHandler+0x72>
            
			pContext = pCurrentTable->pContext;
			pCurrentEntry = pCurrentTable->pTable;
  90a3f4:	8a83      	l32i.n	a10, a8, 12
        
			/* scan table entries */
			for (i = 0; i < pCurrentTable->NumberOfEntries; i++, pCurrentEntry++) {
  90a3f6:	8382      	l32i.n	a3, a8, 8
  90a3f8:	c0c0      	movi.n	a12, 0
  90a3fa:	600014        	j	90a412 <WMIRecvMessageHandler+0x66>
				if (pCurrentEntry->CmdID == cmd) {
  90a3fd:	2fa102        	l16ui	a15, a10, 4
  90a400:	7bf90a        	bne	a15, a11, 90a40e <WMIRecvMessageHandler+0x62>
					/* found a match */
					pCmdHandler = pCurrentEntry->pCmdHandler;
        
					/* optionally check length */
					if ((pCurrentEntry->CheckLength != 0) &&
  90a403:	2ca103        	l16ui	a12, a10, 6
  90a406:	c8ce      	beqz.n	a12, 90a418 <WMIRecvMessageHandler+0x6c>
  90a408:	7ce210        	blt	a14, a12, 90a41c <WMIRecvMessageHandler+0x70>
  90a40b:	600009        	j	90a418 <WMIRecvMessageHandler+0x6c>
            
			pContext = pCurrentTable->pContext;
			pCurrentEntry = pCurrentTable->pTable;
        
			/* scan table entries */
			for (i = 0; i < pCurrentTable->NumberOfEntries; i++, pCurrentEntry++) {
  90a40e:	b1cc      	addi.n	a12, a12, 1
  90a410:	b8aa      	addi.n	a10, a10, 8
  90a412:	73c2e7        	blt	a12, a3, 90a3fd <WMIRecvMessageHandler+0x51>
  90a415:	600003        	j	90a41c <WMIRecvMessageHandler+0x70>
				if (pCurrentEntry->CmdID == cmd) {
					/* found a match */
					pCmdHandler = pCurrentEntry->pCmdHandler;
  90a418:	8fa0      	l32i.n	a15, a10, 0
					/* end search */                
					break;    
				}                        
			} 
            
			if (pCmdHandler != NULL) {
  90a41a:	cdf4      	bnez.n	a15, 90a432 <WMIRecvMessageHandler+0x86>
				/* found a handler */
				break;
			}
                
			/* scan next table */
			pCurrentTable = pCurrentTable->pNext;
  90a41c:	8880      	l32i.n	a8, a8, 0
		seq = adf_os_ntohs(cmdHdr->seqNo);
        
		pCmdBuffer = anbdata + sizeof(WMI_CMD_HDR); 
		pCmdHandler = NULL;
        
		while (pCurrentTable != NULL) {
  90a41e:	658fd2        	bnez	a8, 90a3f4 <WMIRecvMessageHandler+0x48>
        /* Invalidate the buffer (including HTC header). Note : we only need to invalidate up to the portion
	 * that was used (cache invalidate will also round up to the nearest cache line).  
	 * The rest of the buffer should still be coherent.
	 * */

	HTC_ReturnBuffers(pWMI->HtcHandle, EndPt, pHTCBuf);         
  90a421:	1368bf        	l32r	a3, 8e4720 <bStandardCommand+0x8bc>
  90a424:	8a50      	l32i.n	a10, a5, 0
  90a426:	233282        	l32i	a3, a3, 0x208
  90a429:	dc40      	mov.n	a12, a4
  90a42b:	db20      	mov.n	a11, a2
  90a42d:	0b3000        	callx8	a3
}
  90a430:	d10f      	retw.n
		pCurrentTable = pWMI->pDispatchHead;
		length = length - sizeof(WMI_CMD_HDR);
        
		cmdHdr = (WMI_CMD_HDR *)anbdata;
		cmd = adf_os_ntohs(cmdHdr->commandId);
		seq = adf_os_ntohs(cmdHdr->seqNo);
  90a432:	2a9002        	l8ui	a10, a9, 2
  90a435:	2c9003        	l8ui	a12, a9, 3
  90a438:	08aa11        	slli	a10, a10, 8
		}
            
		/* if we get here, we have a command handler to dispatch */
                
		/* call dispatch function */
		pCmdHandler(pContext, cmd, seq, pCmdBuffer, length);
  90a43b:	0acc02        	or	a12, a12, a10
  90a43e:	2a8201        	l32i	a10, a8, 4
  90a441:	0bf000        	callx8	a15
  90a444:	63ffd9        	j	90a421 <WMIRecvMessageHandler+0x75>
	...

0090a448 <_WMI_SendCompleteHandler>:
	HTC_ReturnBuffers(pWMI->HtcHandle, EndPt, pHTCBuf);         
}

/* send completion handler when any HTC buffers are returned */
static void _WMI_SendCompleteHandler(HTC_ENDPOINT_ID Endpt, adf_nbuf_t pHTCBuf, void *arg)
{
  90a448:	6c1004        	entry	a1, 32
 * @return data pointer to typecast into your priv structure
 */
static inline a_uint8_t *
adf_nbuf_get_priv(adf_nbuf_t buf)
{
    return (__adf_nbuf_get_priv(buf));
  90a44b:	da30      	mov.n	a10, a3
  90a44d:	5bf167        	call8	9069ec <__adf_nbuf_get_priv>
	WMI_BUF_CONTEXT *ctx;
	BUF_POOL_ID poolId;
    
	ctx = (WMI_BUF_CONTEXT *)adf_nbuf_get_priv(pHTCBuf);
        
	if ( ctx->EventClass == WMI_EVT_CLASS_CMD_EVENT ) {
  90a450:	8ba1      	l32i.n	a11, a10, 4
		poolId = POOL_ID_WMI_SVC_EVENT;
	} else {
		poolId = POOL_ID_WMI_SVC_CMD_REPLY;
  90a452:	c091      	movi.n	a9, 1
  90a454:	c080      	movi.n	a8, 0
  90a456:	0b9838        	moveqz	a8, a9, a11
  90a459:	db80      	mov.n	a11, a8
	}
        
	BUF_Pool_free_buf(pWMI->PoolHandle, poolId, pHTCBuf);
  90a45b:	1868bf        	l32r	a8, 8e4758 <bStandardCommand+0x8f4>
  90a45e:	8a41      	l32i.n	a10, a4, 4
  90a460:	28829e        	l32i	a8, a8, 0x278
  90a463:	dc30      	mov.n	a12, a3
  90a465:	a9bb      	add.n	a11, a11, a9
  90a467:	0b8000        	callx8	a8
  90a46a:	d10f      	retw.n

0090a46c <_WMI_AllocEvent>:
	}
}

static adf_nbuf_t _WMI_AllocEvent(wmi_handle_t handle, WMI_EVT_CLASS EventClass,
				  int Length)
{     
  90a46c:	6c1004        	entry	a1, 32
		poolId = POOL_ID_WMI_SVC_EVENT;
	} else {
		poolId = POOL_ID_WMI_SVC_CMD_REPLY;
	}
    
	buf = BUF_Pool_alloc_buf(pWMI->PoolHandle, 
  90a46f:	1868bf        	l32r	a8, 8e476c <bStandardCommand+0x908>
	WMI_BUF_CONTEXT *ctx;
    
	if ( EventClass == WMI_EVT_CLASS_CMD_EVENT ) {
		poolId = POOL_ID_WMI_SVC_EVENT;
	} else {
		poolId = POOL_ID_WMI_SVC_CMD_REPLY;
  90a472:	c0b0      	movi.n	a11, 0
	}
    
	buf = BUF_Pool_alloc_buf(pWMI->PoolHandle, 
  90a474:	25829c        	l32i	a5, a8, 0x270
  90a477:	8a20      	l32i.n	a10, a2, 0
  90a479:	288285        	l32i	a8, a8, 0x214
	WMI_BUF_CONTEXT *ctx;
    
	if ( EventClass == WMI_EVT_CLASS_CMD_EVENT ) {
		poolId = POOL_ID_WMI_SVC_EVENT;
	} else {
		poolId = POOL_ID_WMI_SVC_CMD_REPLY;
  90a47c:	c041      	movi.n	a4, 1
  90a47e:	03b439        	movnez	a4, a11, a3
	}
    
	buf = BUF_Pool_alloc_buf(pWMI->PoolHandle, 
  90a481:	8621      	l32i.n	a6, a2, 4
	WMI_BUF_CONTEXT *ctx;
    
	if ( EventClass == WMI_EVT_CLASS_CMD_EVENT ) {
		poolId = POOL_ID_WMI_SVC_EVENT;
	} else {
		poolId = POOL_ID_WMI_SVC_CMD_REPLY;
  90a483:	b144      	addi.n	a4, a4, 1
	}
    
	buf = BUF_Pool_alloc_buf(pWMI->PoolHandle, 
  90a485:	0b8000        	callx8	a8
  90a488:	b4ac      	addi.n	a12, a10, 4
  90a48a:	db40      	mov.n	a11, a4
  90a48c:	da60      	mov.n	a10, a6
  90a48e:	0b5000        	callx8	a5
  90a491:	d2a0      	mov.n	a2, a10
				 poolId, 
				 sizeof(WMI_CMD_HDR) + HTC_GetReservedHeadroom(pWMI->HtcHandle));
     
	if ( buf != NULL ) {
  90a493:	c8a3      	beqz.n	a10, 90a49a <_WMI_AllocEvent+0x2e>
  90a495:	5bf155        	call8	9069ec <__adf_nbuf_get_priv>
		ctx = (WMI_BUF_CONTEXT *)adf_nbuf_get_priv(buf);
		ctx->EventClass = EventClass;
  90a498:	93a1      	s32i.n	a3, a10, 4
	}
	return buf;
}
  90a49a:	d10f      	retw.n

0090a49c <_WMI_SendEvent>:

static void _WMI_SendEvent(wmi_handle_t handle, adf_nbuf_t pEvt, 
                           A_UINT16 EventId, A_UINT16 SeqNo, int Length)
{
  90a49c:	6c1004        	entry	a1, 32
 *         or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_push_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_push_head(buf, size);
  90a49f:	2b0a04        	movi	a11, 4
  90a4a2:	033a02        	or	a10, a3, a3
  90a4a5:	5bf121        	call8	90692c <__adf_nbuf_push_head>
  90a4a8:	04044f        	extui	a4, a4, 0, 16
  90a4ab:	05054f        	extui	a5, a5, 0, 16
	WMI_SVC_CONTEXT *pWMI = (WMI_SVC_CONTEXT *)handle;
	A_UINT8 *pBuffer;
        
	pBuffer = adf_nbuf_push_head(pEvt, sizeof(WMI_CMD_HDR));
	A_SET_UINT16_FIELD(pBuffer, WMI_CMD_HDR, commandId, adf_os_htons(EventId));        
  90a4ae:	24a401        	s8i	a4, a10, 1
  90a4b1:	048814        	srli	a8, a4, 8
	A_SET_UINT16_FIELD(pBuffer, WMI_CMD_HDR, seqNo, adf_os_htons(SeqNo));
  90a4b4:	058414        	srli	a4, a5, 8
  90a4b7:	24a402        	s8i	a4, a10, 2
	
	HTC_SendMsg(pWMI->HtcHandle, pWMI->ControlEp, pEvt);    
  90a4ba:	1468bf        	l32r	a4, 8e47b8 <bStandardCommand+0x954>
{
	WMI_SVC_CONTEXT *pWMI = (WMI_SVC_CONTEXT *)handle;
	A_UINT8 *pBuffer;
        
	pBuffer = adf_nbuf_push_head(pEvt, sizeof(WMI_CMD_HDR));
	A_SET_UINT16_FIELD(pBuffer, WMI_CMD_HDR, commandId, adf_os_htons(EventId));        
  90a4bd:	28a400        	s8i	a8, a10, 0
	A_SET_UINT16_FIELD(pBuffer, WMI_CMD_HDR, seqNo, adf_os_htons(SeqNo));
  90a4c0:	25a403        	s8i	a5, a10, 3
	
	HTC_SendMsg(pWMI->HtcHandle, pWMI->ControlEp, pEvt);    
  90a4c3:	244284        	l32i	a4, a4, 0x210
  90a4c6:	8b2a      	l32i.n	a11, a2, 40
  90a4c8:	8a20      	l32i.n	a10, a2, 0
  90a4ca:	033c02        	or	a12, a3, a3
  90a4cd:	0b4000        	callx8	a4
  90a4d0:	d10f      	retw.n
	...

0090a4d4 <_WMI_Init>:
}

/**************  public APIS ********************************************/
    
static wmi_handle_t _WMI_Init(WMI_SVC_CONFIG *pWmiConfig)
{
  90a4d4:	6c1004        	entry	a1, 32
#include "Magpie_api.h"

static inline void *	__adf_os_mem_alloc(adf_os_size_t size)
{
//    return (malloc(size,M_DEVBUF,M_DONTWAIT | M_ZERO));
    return A_ALLOCRAM(size);
  90a4d7:	1368bf        	l32r	a3, 8e47d4 <bStandardCommand+0x970>
  90a4da:	d420      	mov.n	a4, a2
  90a4dc:	223252        	l32i	a2, a3, 0x148
  90a4df:	c3b8      	movi.n	a11, 56
  90a4e1:	c0a0      	movi.n	a10, 0
  90a4e3:	0b2000        	callx8	a2
  90a4e6:	d2a0      	mov.n	a2, a10
	WMI_SVC_CONTEXT *pWMI = NULL;
	int eventSize = WMI_SVC_MAX_BUFFERED_EVENT_SIZE + sizeof(WMI_CMD_HDR) + HTC_HDR_SZ;
    
	pWMI = (WMI_SVC_CONTEXT *)adf_os_mem_alloc(sizeof(WMI_SVC_CONTEXT));
	if (pWMI == NULL) {
  90a4e8:	64a055        	beqz	a10, 90a541 <_WMI_Init+0x6d>
		return NULL;    
	}
        
	pWMI->pDispatchHead = NULL;
  90a4eb:	c080      	movi.n	a8, 0
  90a4ed:	98ab      	s32i.n	a8, a10, 44
	pWMI->PoolHandle = pWmiConfig->PoolHandle;
	pWMI->HtcHandle = pWmiConfig->HtcHandle;    
  90a4ef:	8840      	l32i.n	a8, a4, 0
	if (pWMI == NULL) {
		return NULL;    
	}
        
	pWMI->pDispatchHead = NULL;
	pWMI->PoolHandle = pWmiConfig->PoolHandle;
  90a4f1:	8a41      	l32i.n	a10, a4, 4
	pWMI->HtcHandle = pWmiConfig->HtcHandle;    
                                         
	BUF_Pool_create_pool(pWmiConfig->PoolHandle, POOL_ID_WMI_SVC_CMD_REPLY, 
  90a4f3:	8c42      	l32i.n	a12, a4, 8
		return NULL;    
	}
        
	pWMI->pDispatchHead = NULL;
	pWMI->PoolHandle = pWmiConfig->PoolHandle;
	pWMI->HtcHandle = pWmiConfig->HtcHandle;    
  90a4f5:	9820      	s32i.n	a8, a2, 0
                                         
	BUF_Pool_create_pool(pWmiConfig->PoolHandle, POOL_ID_WMI_SVC_CMD_REPLY, 
  90a4f7:	28329b        	l32i	a8, a3, 0x26c
	if (pWMI == NULL) {
		return NULL;    
	}
        
	pWMI->pDispatchHead = NULL;
	pWMI->PoolHandle = pWmiConfig->PoolHandle;
  90a4fa:	9a21      	s32i.n	a10, a2, 4
	pWMI->HtcHandle = pWmiConfig->HtcHandle;    
                                         
	BUF_Pool_create_pool(pWmiConfig->PoolHandle, POOL_ID_WMI_SVC_CMD_REPLY, 
  90a4fc:	2d0a70        	movi	a13, 112
  90a4ff:	2b0a01        	movi	a11, 1
  90a502:	0b8000        	callx8	a8
			     pWmiConfig->MaxCmdReplyEvts, eventSize);
        
	BUF_Pool_create_pool(pWmiConfig->PoolHandle, POOL_ID_WMI_SVC_EVENT, 
  90a505:	28329b        	l32i	a8, a3, 0x26c
  90a508:	8a41      	l32i.n	a10, a4, 4
  90a50a:	8c43      	l32i.n	a12, a4, 12
  90a50c:	c0b2      	movi.n	a11, 2
  90a50e:	2d0a70        	movi	a13, 112
  90a511:	0b8000        	callx8	a8
            
	/* NOTE: since RAM allocation is zero-initialized, there is nothing to do for the 
	 * direct event pool */
     
        /* register the WMI control service */
	pWMI->WMIControlService.ProcessRecvMsg = A_INDIR(wmi_svc_api._WMI_RecvMessageHandler);
  90a514:	283293        	l32i	a8, a3, 0x24c
         * in size.  Any WMI event that supplies a data buffer must insure that the space in the buffer
         * is at least this size. */
	pWMI->WMIControlService.TrailerSpcCheckLimit = WMI_SVC_MAX_BUFFERED_EVENT_SIZE; 
	pWMI->WMIControlService.ServiceID = WMI_CONTROL_SVC;
	pWMI->WMIControlService.ServiceCtx = pWMI;
	HTC_RegisterService(pWmiConfig->HtcHandle, &pWMI->WMIControlService);
  90a517:	8a40      	l32i.n	a10, a4, 0
            
	/* NOTE: since RAM allocation is zero-initialized, there is nothing to do for the 
	 * direct event pool */
     
        /* register the WMI control service */
	pWMI->WMIControlService.ProcessRecvMsg = A_INDIR(wmi_svc_api._WMI_RecvMessageHandler);
  90a519:	9824      	s32i.n	a8, a2, 16
	pWMI->WMIControlService.ProcessSendBufferComplete = A_INDIR(wmi_svc_api._WMI_SendCompleteHandler);
  90a51b:	283290        	l32i	a8, a3, 0x240
         * in size.  Any WMI event that supplies a data buffer must insure that the space in the buffer
         * is at least this size. */
	pWMI->WMIControlService.TrailerSpcCheckLimit = WMI_SVC_MAX_BUFFERED_EVENT_SIZE; 
	pWMI->WMIControlService.ServiceID = WMI_CONTROL_SVC;
	pWMI->WMIControlService.ServiceCtx = pWMI;
	HTC_RegisterService(pWmiConfig->HtcHandle, &pWMI->WMIControlService);
  90a51e:	bc2b      	addi.n	a11, a2, 12
	/* NOTE: since RAM allocation is zero-initialized, there is nothing to do for the 
	 * direct event pool */
     
        /* register the WMI control service */
	pWMI->WMIControlService.ProcessRecvMsg = A_INDIR(wmi_svc_api._WMI_RecvMessageHandler);
	pWMI->WMIControlService.ProcessSendBufferComplete = A_INDIR(wmi_svc_api._WMI_SendCompleteHandler);
  90a520:	9825      	s32i.n	a8, a2, 20
	pWMI->WMIControlService.ProcessConnect = A_INDIR(wmi_svc_api._WMI_ServiceConnect);
  90a522:	283294        	l32i	a8, a3, 0x250
         * in size.  Any WMI event that supplies a data buffer must insure that the space in the buffer
         * is at least this size. */
	pWMI->WMIControlService.TrailerSpcCheckLimit = WMI_SVC_MAX_BUFFERED_EVENT_SIZE; 
	pWMI->WMIControlService.ServiceID = WMI_CONTROL_SVC;
	pWMI->WMIControlService.ServiceCtx = pWMI;
	HTC_RegisterService(pWmiConfig->HtcHandle, &pWMI->WMIControlService);
  90a525:	233280        	l32i	a3, a3, 0x200
	 * direct event pool */
     
        /* register the WMI control service */
	pWMI->WMIControlService.ProcessRecvMsg = A_INDIR(wmi_svc_api._WMI_RecvMessageHandler);
	pWMI->WMIControlService.ProcessSendBufferComplete = A_INDIR(wmi_svc_api._WMI_SendCompleteHandler);
	pWMI->WMIControlService.ProcessConnect = A_INDIR(wmi_svc_api._WMI_ServiceConnect);
  90a528:	9826      	s32i.n	a8, a2, 24
	pWMI->WMIControlService.MaxSvcMsgSize = WMI_SVC_MSG_SIZE + sizeof(WMI_CMD_HDR);
  90a52a:	286a04        	movi	a8, 0x604
  90a52d:	282510        	s16i	a8, a2, 32
        /* all buffers that are sent through the control endpoint are at least WMI_SVC_MAX_BUFFERED_EVENT_SIZE 
         * in size.  Any WMI event that supplies a data buffer must insure that the space in the buffer
         * is at least this size. */
	pWMI->WMIControlService.TrailerSpcCheckLimit = WMI_SVC_MAX_BUFFERED_EVENT_SIZE; 
  90a530:	280a64        	movi	a8, 100
  90a533:	282511        	s16i	a8, a2, 34
	pWMI->WMIControlService.ServiceID = WMI_CONTROL_SVC;
  90a536:	281a00        	movi	a8, 0x100
  90a539:	28250e        	s16i	a8, a2, 28
	pWMI->WMIControlService.ServiceCtx = pWMI;
  90a53c:	9229      	s32i.n	a2, a2, 36
	HTC_RegisterService(pWmiConfig->HtcHandle, &pWMI->WMIControlService);
  90a53e:	0b3000        	callx8	a3
    
	return pWMI;
}
  90a541:	d10f      	retw.n
	...

0090a544 <WMI_service_module_install>:

	adf_os_mem_free(pWMI);
}

void WMI_service_module_install(WMI_SVC_APIS *pTbl)
{
  90a544:	6c1004        	entry	a1, 32
	pTbl->_WMI_Init                     = _WMI_Init;
  90a547:	1869fe        	l32r	a8, 8e4d40 <mUsbEPinHighBandSet+0x3a0>
  90a54a:	9820      	s32i.n	a8, a2, 0
	pTbl->_WMI_RegisterDispatchTable    = _WMI_RegisterDispatchTable;
  90a54c:	1869ff        	l32r	a8, 8e4d48 <mUsbEPinHighBandSet+0x3a8>
  90a54f:	9821      	s32i.n	a8, a2, 4
	pTbl->_WMI_AllocEvent               = _WMI_AllocEvent;
  90a551:	186a00        	l32r	a8, 8e4d54 <mUsbEPinHighBandSet+0x3b4>
  90a554:	9822      	s32i.n	a8, a2, 8
	pTbl->_WMI_SendEvent                = _WMI_SendEvent;
  90a556:	186a01        	l32r	a8, 8e4d5c <mUsbEPinHighBandSet+0x3bc>
  90a559:	9823      	s32i.n	a8, a2, 12
	pTbl->_WMI_SendCompleteHandler      = _WMI_SendCompleteHandler;
  90a55b:	186a02        	l32r	a8, 8e4d64 <mUsbEPinHighBandSet+0x3c4>
  90a55e:	9825      	s32i.n	a8, a2, 20
	pTbl->_WMI_GetPendingEventsCount    = _WMI_GetPendingEventsCount;
  90a560:	186a03        	l32r	a8, 8e4d6c <mUsbEPinHighBandSet+0x3cc>
  90a563:	9824      	s32i.n	a8, a2, 16
	pTbl->_WMI_GetControlEp             = _WMI_GetControlEp;
  90a565:	186a04        	l32r	a8, 8e4d78 <mUsbEPinHighBandSet+0x3d8>
  90a568:	9826      	s32i.n	a8, a2, 24
	pTbl->_WMI_Shutdown                 = _WMI_Shutdown;
  90a56a:	186a05        	l32r	a8, 8e4d80 <mUsbEPinHighBandSet+0x3e0>
  90a56d:	9827      	s32i.n	a8, a2, 28
	pTbl->_WMI_RecvMessageHandler       = WMIRecvMessageHandler;
  90a56f:	186a06        	l32r	a8, 8e4d88 <mUsbEPinHighBandSet+0x3e8>
  90a572:	9828      	s32i.n	a8, a2, 32
	pTbl->_WMI_ServiceConnect           = WMIServiceConnect;
  90a574:	186a07        	l32r	a8, 8e4d90 <mUsbEPinHighBandSet+0x3f0>
  90a577:	9829      	s32i.n	a8, a2, 36
  90a579:	d10f      	retw.n
	...

0090a57c <io32_rmw>:
	iowrite8(addr, val);
}

static inline void io32_rmw(volatile uint32_t addr,
			    const uint32_t set, const uint32_t clr)
{
  90a57c:	6c1006        	entry	a1, 48
  90a57f:	0c0200        	memw
  90a582:	9210      	s32i.n	a2, a1, 0
	uint32_t val;

	val = ioread32(addr);
  90a584:	0c0200        	memw
  90a587:	8810      	l32i.n	a8, a1, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90a589:	0c0200        	memw
  90a58c:	8980      	l32i.n	a9, a8, 0
			    const uint32_t set, const uint32_t clr)
{
	uint32_t val;

	val = ioread32(addr);
	val &= ~clr;
  90a58e:	c78f      	movi.n	a8, -1
  90a590:	048403        	xor	a4, a8, a4
  90a593:	094401        	and	a4, a4, a9
	val |= set;
	iowrite32(addr, val);
  90a596:	0c0200        	memw
  90a599:	8810      	l32i.n	a8, a1, 0
{
	uint32_t val;

	val = ioread32(addr);
	val &= ~clr;
	val |= set;
  90a59b:	034402        	or	a4, a4, a3
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90a59e:	0c0200        	memw
  90a5a1:	9480      	s32i.n	a4, a8, 0
  90a5a3:	d10f      	retw.n
  90a5a5:	000000        	ill

0090a5a8 <_fw_restore_dma_fifo>:
	/* deassert eth_pll bypass mode and trigger update bit */
	io32_clr(MAGPIE_REG_ETH_PLL_BYPASS_ADDR, BIT4 | BIT0);
}

static void _fw_restore_dma_fifo(void)
{
  90a5a8:	6c1004        	entry	a1, 32
	io32_clr(0x5601C, BIT18);
  90a5ab:	1c69cc        	l32r	a12, 8e4cdc <mUsbEPinHighBandSet+0x33c>
  90a5ae:	1a6a08        	l32r	a10, 8e4dd0 <mUsbEPinHighBandSet+0x430>
  90a5b1:	c0b0      	movi.n	a11, 0
  90a5b3:	5bfff2        	call8	90a57c <io32_rmw>
    
	/* reset pcie_rc shift */
	io32_clr(0x50010, BIT10 | BIT8 | BIT7);
  90a5b6:	1268ec        	l32r	a2, 8e4968 <mUsbEPMxPtSzHigh+0x14>
  90a5b9:	2c5a80        	movi	a12, 0x580
  90a5bc:	2b0a00        	movi	a11, 0
  90a5bf:	022a02        	or	a10, a2, a2
  90a5c2:	5bffee        	call8	90a57c <io32_rmw>
	A_DELAY_USECS(1);
  90a5c5:	1368bf        	l32r	a3, 8e48c4 <bStandardCommand+0xa60>
  90a5c8:	c0a1      	movi.n	a10, 1
  90a5ca:	28323b        	l32i	a8, a3, 236
  90a5cd:	0b8000        	callx8	a8
	io32_set(0x50010, BIT10 | BIT8 | BIT7);
  90a5d0:	da20      	mov.n	a10, a2
  90a5d2:	c0c0      	movi.n	a12, 0
  90a5d4:	2b5a80        	movi	a11, 0x580
  90a5d7:	5bffe9        	call8	90a57c <io32_rmw>

	/* reset pci_rc phy */
	io32_set(MAGPIE_REG_RST_RESET_ADDR,
  90a5da:	da20      	mov.n	a10, a2
  90a5dc:	c0c0      	movi.n	a12, 0
  90a5de:	2b5ac0        	movi	a11, 0x5c0
  90a5e1:	5bffe6        	call8	90a57c <io32_rmw>
		 PCI_RC_PHY_SHIFT_RESET_BIT
		 | PCI_RC_PLL_RESET_BIT | PCI_RC_PHY_RESET_BIT
		 | PCI_RC_RESET_BIT);
	A_DELAY_USECS(20);
  90a5e4:	22323b        	l32i	a2, a3, 236
  90a5e7:	c1a4      	movi.n	a10, 20
  90a5e9:	0b2000        	callx8	a2

	// enable dma swap function
	MAGPIE_REG_USB_RX0_SWAP_DATA = 0x1;
  90a5ec:	1268fe        	l32r	a2, 8e49e4 <mUsbEPinHighBandSet+0x44>
  90a5ef:	c081      	movi.n	a8, 1
  90a5f1:	0c0200        	memw
  90a5f4:	9820      	s32i.n	a8, a2, 0
	MAGPIE_REG_USB_TX0_SWAP_DATA = 0x1;
  90a5f6:	1268ff        	l32r	a2, 8e49f4 <mUsbEPinHighBandSet+0x54>
  90a5f9:	0c0200        	memw
  90a5fc:	9820      	s32i.n	a8, a2, 0
	MAGPIE_REG_USB_RX1_SWAP_DATA = 0x1;
  90a5fe:	126900        	l32r	a2, 8e4a00 <mUsbEPinHighBandSet+0x60>
  90a601:	0c0200        	memw
  90a604:	9820      	s32i.n	a8, a2, 0
	MAGPIE_REG_USB_RX2_SWAP_DATA = 0x1;
  90a606:	126901        	l32r	a2, 8e4a0c <mUsbEPinHighBandSet+0x6c>
  90a609:	0c0200        	memw
  90a60c:	9820      	s32i.n	a8, a2, 0
  90a60e:	d10f      	retw.n

0090a610 <_fw_reset_dma_fifo>:
	A_PRINTF("0x4088  0x%x ......\n", ioread32(0x10ff4088));
	_fw_reset_dma_fifo();
}

static void _fw_reset_dma_fifo()
{
  90a610:	6c1012        	entry	a1, 144
  90a613:	126a09        	l32r	a2, 8e4e38 <mUsbEPinHighBandSet+0x498>
{
	uint8_t val;

	val = ioread8(addr);
	val &= ~clr;
	val |= set;
  90a616:	c140      	movi.n	a4, 16

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  90a618:	232000        	l8ui	a3, a2, 0
	io8_set(0x100ae, 0x10);
	io8_set(0x100af, 0x10);
	A_PRINTF("_fw_reset_dma_fifo\n");
  90a61b:	1a6a0b        	l32r	a10, 8e4e48 <mUsbEPinHighBandSet+0x4a8>
  90a61e:	030347        	extui	a3, a3, 0, 8
{
	uint8_t val;

	val = ioread8(addr);
	val &= ~clr;
	val |= set;
  90a621:	043302        	or	a3, a3, a4
  90a624:	030347        	extui	a3, a3, 0, 8
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  90a627:	0c0200        	memw
  90a62a:	232400        	s8i	a3, a2, 0
  90a62d:	136a0a        	l32r	a3, 8e4e58 <mUsbEPinHighBandSet+0x4b8>

	// disable ep3 int enable, so that resume back won't send wdt magic pattern out!!!
	mUSB_STATUS_IN_INT_DISABLE();
  90a630:	250ac0        	movi	a5, 192

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  90a633:	223000        	l8ui	a2, a3, 0
  90a636:	020247        	extui	a2, a2, 0, 8
{
	uint8_t val;

	val = ioread8(addr);
	val &= ~clr;
	val |= set;
  90a639:	042202        	or	a2, a2, a4
  90a63c:	020247        	extui	a2, a2, 0, 8
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  90a63f:	0c0200        	memw
  90a642:	223400        	s8i	a2, a3, 0

static void _fw_reset_dma_fifo()
{
	io8_set(0x100ae, 0x10);
	io8_set(0x100af, 0x10);
	A_PRINTF("_fw_reset_dma_fifo\n");
  90a645:	1268bf        	l32r	a2, 8e4944 <mUsbFIFOConfig+0x10>
  90a648:	232212        	l32i	a3, a2, 72
  90a64b:	0b3000        	callx8	a3

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  90a64e:	146905        	l32r	a4, 8e4a64 <mUsbEPinHighBandSet+0xc4>
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90a651:	166a0c        	l32r	a6, 8e4e84 <mUsbEPinHighBandSet+0x4e4>

#include <adf_os_io_pvt.h>

static inline uint8_t ioread8(const volatile uint32_t addr)
{
	return *(const volatile uint8_t *) addr;
  90a654:	234000        	l8ui	a3, a4, 0
	mUSB_STATUS_IN_INT_DISABLE();

	/* update magic pattern to indicate this is a suspend */
	iowrite32(WATCH_DOG_MAGIC_PATTERN_ADDR, SUS_MAGIC_PATTERN);

	A_PRINTF("org 0x4048  0x%x ......\n", ioread32(0x10ff4048));
  90a657:	1a6a0d        	l32r	a10, 8e4e8c <mUsbEPinHighBandSet+0x4ec>
  90a65a:	030347        	extui	a3, a3, 0, 8
	io8_set(0x100ae, 0x10);
	io8_set(0x100af, 0x10);
	A_PRINTF("_fw_reset_dma_fifo\n");

	// disable ep3 int enable, so that resume back won't send wdt magic pattern out!!!
	mUSB_STATUS_IN_INT_DISABLE();
  90a65d:	053302        	or	a3, a3, a5
	return *(const volatile uint32_t *) addr;
}

static inline void iowrite8(volatile uint32_t addr, const uint8_t b)
{
	*(volatile uint8_t *) addr = b;
  90a660:	0c0200        	memw
  90a663:	234400        	s8i	a3, a4, 0
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90a666:	1468c7        	l32r	a4, 8e4984 <mUsbEPMxPtSzLow+0x8>
  90a669:	1368c2        	l32r	a3, 8e4974 <mUsbEPMxPtSzHigh+0x20>
  90a66c:	0c0200        	memw
  90a66f:	9430      	s32i.n	a4, a3, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90a671:	0c0200        	memw
  90a674:	8b60      	l32i.n	a11, a6, 0

	/* update magic pattern to indicate this is a suspend */
	iowrite32(WATCH_DOG_MAGIC_PATTERN_ADDR, SUS_MAGIC_PATTERN);

	A_PRINTF("org 0x4048  0x%x ......\n", ioread32(0x10ff4048));
  90a676:	232212        	l32i	a3, a2, 72
  90a679:	0b3000        	callx8	a3
  90a67c:	156a0e        	l32r	a5, 8e4eb4 <mUsbEPinHighBandSet+0x514>
	A_PRINTF("org 0x404C  0x%x ......\n", ioread32(0x10ff404C));
  90a67f:	232212        	l32i	a3, a2, 72
  90a682:	0c0200        	memw
  90a685:	8b50      	l32i.n	a11, a5, 0
  90a687:	1a6a0f        	l32r	a10, 8e4ec4 <mUsbEPinHighBandSet+0x524>
  90a68a:	0b3000        	callx8	a3
  90a68d:	146a10        	l32r	a4, 8e4ed0 <mUsbEPinHighBandSet+0x530>
	A_PRINTF("org 0x4088  0x%x ......\n", ioread32(0x10ff4088));
  90a690:	232212        	l32i	a3, a2, 72
  90a693:	0c0200        	memw
  90a696:	8b40      	l32i.n	a11, a4, 0
  90a698:	1a6a11        	l32r	a10, 8e4edc <mUsbEPinHighBandSet+0x53c>
  90a69b:	0b3000        	callx8	a3
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90a69e:	136a12        	l32r	a3, 8e4ee8 <mUsbEPinHighBandSet+0x548>

	/* 1010.1010.1010.0110.1010 for UB94 */
	iowrite32(0x10ff4088, 0xaaa6a);
	iowrite32(0x10ff404C, 0x0);

	A_DELAY_USECS(1000);
  90a6a1:	28223b        	l32i	a8, a2, 236
  90a6a4:	0c0200        	memw
  90a6a7:	234600        	s32i	a3, a4, 0
  90a6aa:	230a00        	movi	a3, 0
  90a6ad:	0c0200        	memw
  90a6b0:	235600        	s32i	a3, a5, 0
  90a6b3:	2a3ae8        	movi	a10, 0x3e8
  90a6b6:	0b8000        	callx8	a8
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90a6b9:	0c0200        	memw
  90a6bc:	2b6200        	l32i	a11, a6, 0
	A_PRINTF("0x4048  0x%x ......\n", ioread32(0x10ff4048));
  90a6bf:	1a6a13        	l32r	a10, 8e4f0c <mUsbEPinHighBandSet+0x56c>
  90a6c2:	262212        	l32i	a6, a2, 72
  90a6c5:	0b6000        	callx8	a6
  90a6c8:	0c0200        	memw
  90a6cb:	8b50      	l32i.n	a11, a5, 0
	A_PRINTF("0x404C  0x%x ......\n", ioread32(0x10ff404C));
  90a6cd:	1a6a14        	l32r	a10, 8e4f20 <mUsbEPinHighBandSet+0x580>
  90a6d0:	252212        	l32i	a5, a2, 72
  90a6d3:	0b5000        	callx8	a5
  90a6d6:	0c0200        	memw
  90a6d9:	8b40      	l32i.n	a11, a4, 0
	A_PRINTF("0x4088  0x%x ......\n", ioread32(0x10ff4088));
  90a6db:	1a6a15        	l32r	a10, 8e4f30 <mUsbEPinHighBandSet+0x590>
  90a6de:	242212        	l32i	a4, a2, 72
  90a6e1:	0b4000        	callx8	a4
	volatile uint32_t default_data[9];
	uint32_t i=0;

	if(1)
	{
		A_PRINTF("turn_off_merlin_ep_start ......\n");
  90a6e4:	1a6a16        	l32r	a10, 8e4f3c <mUsbEPinHighBandSet+0x59c>
  90a6e7:	242212        	l32i	a4, a2, 72
  90a6ea:	0b4000        	callx8	a4
		A_DELAY_USECS(measure_time);
  90a6ed:	24223b        	l32i	a4, a2, 236
  90a6f0:	da30      	mov.n	a10, a3
  90a6f2:	0b4000        	callx8	a4
		default_data[0] = 0x9248fd00;
  90a6f5:	146a17        	l32r	a4, 8e4f54 <mUsbEPinHighBandSet+0x5b4>
  90a6f8:	156a20        	l32r	a5, 8e4f78 <vbuf_module_install+0x18>
  90a6fb:	0c0200        	memw
  90a6fe:	9410      	s32i.n	a4, a1, 0
		default_data[1] = 0x24924924;
  90a700:	146a18        	l32r	a4, 8e4f60 <vbuf_module_install>
  90a703:	0c0200        	memw
  90a706:	9411      	s32i.n	a4, a1, 4
		default_data[2] = 0xa8000019;
  90a708:	146a19        	l32r	a4, 8e4f6c <vbuf_module_install+0xc>
  90a70b:	0c0200        	memw
  90a70e:	9412      	s32i.n	a4, a1, 8
		default_data[3] = 0x17160820;
  90a710:	146a1a        	l32r	a4, 8e4f78 <vbuf_module_install+0x18>
  90a713:	0c0200        	memw
  90a716:	9413      	s32i.n	a4, a1, 12
		default_data[4] = 0x25980560;
  90a718:	146a1b        	l32r	a4, 8e4f84 <vbuf_module_install+0x24>
  90a71b:	0c0200        	memw
  90a71e:	9414      	s32i.n	a4, a1, 16
		default_data[5] = 0xc1c00000;
  90a720:	146a1c        	l32r	a4, 8e4f90 <vbuf_module_install+0x30>
  90a723:	0c0200        	memw
  90a726:	9415      	s32i.n	a4, a1, 20
		default_data[6] = 0x1aaabe40;
  90a728:	146a1d        	l32r	a4, 8e4f9c <vbuf_module_install+0x3c>
  90a72b:	0c0200        	memw
  90a72e:	9416      	s32i.n	a4, a1, 24
		default_data[7] = 0xbe105554;
  90a730:	146a1e        	l32r	a4, 8e4fa8 <vbuf_module_install+0x48>
  90a733:	0c0200        	memw
  90a736:	9417      	s32i.n	a4, a1, 28
		default_data[8] = 0x00043007;
  90a738:	146a1f        	l32r	a4, 8e4fb4 <vbuf_module_install+0x54>
  90a73b:	0c0200        	memw
  90a73e:	9418      	s32i.n	a4, a1, 32
        
		for(i=0; i<9; i++)
		{
			A_DELAY_USECS(10);
  90a740:	24223b        	l32i	a4, a2, 236
  90a743:	c0aa      	movi.n	a10, 10
  90a745:	0b4000        	callx8	a4
        
			iowrite32(0x10ff4040, default_data[i]);
  90a748:	0e3411        	slli	a4, a3, 2
  90a74b:	a414      	add.n	a4, a1, a4
  90a74d:	0c0200        	memw
  90a750:	8440      	l32i.n	a4, a4, 0
		default_data[5] = 0xc1c00000;
		default_data[6] = 0x1aaabe40;
		default_data[7] = 0xbe105554;
		default_data[8] = 0x00043007;
        
		for(i=0; i<9; i++)
  90a752:	b133      	addi.n	a3, a3, 1
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90a754:	0c0200        	memw
  90a757:	245600        	s32i	a4, a5, 0
  90a75a:	240a09        	movi	a4, 9
  90a75d:	7439df        	bne	a3, a4, 90a740 <_fw_reset_dma_fifo+0x130>
		{
			A_DELAY_USECS(10);
        
			iowrite32(0x10ff4040, default_data[i]);
		}
		A_DELAY_USECS(10);
  90a760:	23223b        	l32i	a3, a2, 236
  90a763:	2a0a0a        	movi	a10, 10
  90a766:	0b3000        	callx8	a3
  90a769:	136a21        	l32r	a3, 8e4ff0 <vbuf_module_install+0x90>
  90a76c:	c041      	movi.n	a4, 1
  90a76e:	0c0200        	memw
  90a771:	9430      	s32i.n	a4, a3, 0
		iowrite32(0x10ff4044, BIT0);
		A_PRINTF("turn_off_merlin_ep_end ......\n");
  90a773:	1a6a22        	l32r	a10, 8e4ffc <vbuf_module_install+0x9c>
  90a776:	232212        	l32i	a3, a2, 72
  90a779:	0b3000        	callx8	a3
	A_PRINTF("0x4088  0x%x ......\n", ioread32(0x10ff4088));
         
	// turn off merlin
	turn_off_merlin();
	// pcie ep
	A_PRINTF("turn_off_magpie_ep_start ......\n");
  90a77c:	1a6a23        	l32r	a10, 8e5008 <vbuf_module_install+0xa8>
  90a77f:	232212        	l32i	a3, a2, 72
  90a782:	0b3000        	callx8	a3
	A_DELAY_USECS(measure_time);
  90a785:	23223b        	l32i	a3, a2, 236
  90a788:	c0a0      	movi.n	a10, 0
  90a78a:	0b3000        	callx8	a3
	io32_set(0x40040, BIT0 | BIT1);
  90a78d:	1a6a24        	l32r	a10, 8e5020 <vdesc_module_install+0x10>
  90a790:	c0c0      	movi.n	a12, 0
  90a792:	2b0a03        	movi	a11, 3
  90a795:	5bff79        	call8	90a57c <io32_rmw>
{

	volatile uint32_t default_data[9];
	uint32_t i=0;

	default_data[0] = 0x9248fd00;
  90a798:	136a17        	l32r	a3, 8e4ff4 <vbuf_module_install+0x94>
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90a79b:	156a25        	l32r	a5, 8e5030 <vdesc_module_install+0x20>
  90a79e:	0c0200        	memw
  90a7a1:	9319      	s32i.n	a3, a1, 36
	default_data[1] = 0x24924924;
  90a7a3:	136a18        	l32r	a3, 8e5004 <vbuf_module_install+0xa4>
  90a7a6:	0c0200        	memw
  90a7a9:	931a      	s32i.n	a3, a1, 40
	default_data[2] = 0xa8000019;
  90a7ab:	136a19        	l32r	a3, 8e5010 <vdesc_module_install>
  90a7ae:	0c0200        	memw
  90a7b1:	931b      	s32i.n	a3, a1, 44
	default_data[3] = 0x17160820;
  90a7b3:	136a1a        	l32r	a3, 8e501c <vdesc_module_install+0xc>
  90a7b6:	0c0200        	memw
  90a7b9:	931c      	s32i.n	a3, a1, 48
	default_data[4] = 0x25980560;
  90a7bb:	136a1b        	l32r	a3, 8e5028 <vdesc_module_install+0x18>
  90a7be:	0c0200        	memw
  90a7c1:	931d      	s32i.n	a3, a1, 52
	default_data[5] = 0xc1c00000;
  90a7c3:	136a1c        	l32r	a3, 8e5034 <vdesc_module_install+0x24>
  90a7c6:	0c0200        	memw
  90a7c9:	931e      	s32i.n	a3, a1, 56
	default_data[6] = 0x1aaabe40;
  90a7cb:	136a1d        	l32r	a3, 8e5040 <vdesc_module_install+0x30>
  90a7ce:	0c0200        	memw
  90a7d1:	931f      	s32i.n	a3, a1, 60
	default_data[7] = 0xbe105554;
  90a7d3:	136a1e        	l32r	a3, 8e504c <vdesc_module_install+0x3c>
  90a7d6:	0c0200        	memw
  90a7d9:	231610        	s32i	a3, a1, 64
	default_data[8] = 0x00043007;
  90a7dc:	136a1f        	l32r	a3, 8e5058 <vdesc_module_install+0x48>
  90a7df:	0c0200        	memw
  90a7e2:	231611        	s32i	a3, a1, 68

	for(i=0; i<9; i++)
  90a7e5:	230a00        	movi	a3, 0
  90a7e8:	0c0200        	memw
  90a7eb:	8450      	l32i.n	a4, a5, 0
	{
		// check for the done bit to be set 

		while (1)
		{
			if (ioread32(0x40028) & BIT31)
  90a7ed:	674ff7        	bgez	a4, 90a7e8 <_fw_reset_dma_fifo+0x1d8>
				break;
		}
        
		A_DELAY_USECS(1);
  90a7f0:	24223b        	l32i	a4, a2, 236
  90a7f3:	c0a1      	movi.n	a10, 1
  90a7f5:	0b4000        	callx8	a4
    
		iowrite32(0x40024, default_data[i]);
  90a7f8:	0e3411        	slli	a4, a3, 2
  90a7fb:	a414      	add.n	a4, a1, a4
  90a7fd:	0c0200        	memw
  90a800:	8649      	l32i.n	a6, a4, 36
  90a802:	146a26        	l32r	a4, 8e509c <vdesc_module_install+0x8c>
	default_data[5] = 0xc1c00000;
	default_data[6] = 0x1aaabe40;
	default_data[7] = 0xbe105554;
	default_data[8] = 0x00043007;

	for(i=0; i<9; i++)
  90a805:	b133      	addi.n	a3, a3, 1
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90a807:	0c0200        	memw
  90a80a:	9640      	s32i.n	a6, a4, 0
  90a80c:	c049      	movi.n	a4, 9
  90a80e:	7439d6        	bne	a3, a4, 90a7e8 <_fw_reset_dma_fifo+0x1d8>
	// pcie ep
	A_PRINTF("turn_off_magpie_ep_start ......\n");
	A_DELAY_USECS(measure_time);
	io32_set(0x40040, BIT0 | BIT1);
	turn_off_phy();
	io32_clr(0x40040, BIT0 | BIT1);
  90a811:	136a24        	l32r	a3, 8e50a4 <vdesc_module_install+0x94>
  90a814:	c041      	movi.n	a4, 1
  90a816:	c0c3      	movi.n	a12, 3
  90a818:	c0b0      	movi.n	a11, 0
  90a81a:	da30      	mov.n	a10, a3
  90a81c:	0c0200        	memw
  90a81f:	9450      	s32i.n	a4, a5, 0
  90a821:	5bff56        	call8	90a57c <io32_rmw>
	A_PRINTF("turn_off_magpie_ep_end ......\n");
  90a824:	1a6a27        	l32r	a10, 8e50c0 <vdesc_module_install+0xb0>
  90a827:	252212        	l32i	a5, a2, 72
  90a82a:	0b5000        	callx8	a5

	// pcie rc 
	A_PRINTF("turn_off_magpie_rc_start ......\n");
  90a82d:	1a6a28        	l32r	a10, 8e50d0 <vdesc_module_install+0xc0>
  90a830:	252212        	l32i	a5, a2, 72
  90a833:	0b5000        	callx8	a5
	A_DELAY_USECS(measure_time);
  90a836:	25223b        	l32i	a5, a2, 236
  90a839:	c0a0      	movi.n	a10, 0
  90a83b:	0b5000        	callx8	a5
	io32_clr(0x40040, BIT0);
  90a83e:	da30      	mov.n	a10, a3
  90a840:	dc40      	mov.n	a12, a4
  90a842:	2b0a00        	movi	a11, 0
  90a845:	5bff4d        	call8	90a57c <io32_rmw>
{
    
	volatile uint32_t default_data[9];
	uint32_t i=0;
    
	A_PRINTF("turn_off_phy_rc\n");
  90a848:	1a6a29        	l32r	a10, 8e50ec <vdesc_module_install+0xdc>
  90a84b:	232212        	l32i	a3, a2, 72
  90a84e:	0b3000        	callx8	a3
    
	default_data[0] = 0x9248fd00;
  90a851:	136a17        	l32r	a3, 8e50b0 <vdesc_module_install+0xa0>
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90a854:	156a25        	l32r	a5, 8e50e8 <vdesc_module_install+0xd8>
  90a857:	0c0200        	memw
  90a85a:	231612        	s32i	a3, a1, 72
	default_data[1] = 0x24924924;
  90a85d:	136a18        	l32r	a3, 8e50c0 <vdesc_module_install+0xb0>
  90a860:	0c0200        	memw
  90a863:	231613        	s32i	a3, a1, 76
	default_data[2] = 0xa8000019;
  90a866:	136a19        	l32r	a3, 8e50cc <vdesc_module_install+0xbc>
  90a869:	0c0200        	memw
  90a86c:	231614        	s32i	a3, a1, 80
	default_data[3] = 0x13160820;//PwdClk1MHz=0
  90a86f:	136a2a        	l32r	a3, 8e5118 <vdesc_module_install+0x108>
  90a872:	0c0200        	memw
  90a875:	231615        	s32i	a3, a1, 84
	default_data[4] = 0x25980560;
  90a878:	136a1b        	l32r	a3, 8e50e4 <vdesc_module_install+0xd4>
  90a87b:	0c0200        	memw
  90a87e:	231616        	s32i	a3, a1, 88
	default_data[5] = 0xc1c00000;
  90a881:	136a1c        	l32r	a3, 8e50f4 <vdesc_module_install+0xe4>
  90a884:	0c0200        	memw
  90a887:	231617        	s32i	a3, a1, 92
	default_data[6] = 0x1aaabe40;
  90a88a:	136a1d        	l32r	a3, 8e5100 <vdesc_module_install+0xf0>
  90a88d:	0c0200        	memw
  90a890:	231618        	s32i	a3, a1, 96
	default_data[7] = 0xbe105554;
  90a893:	136a1e        	l32r	a3, 8e510c <vdesc_module_install+0xfc>
  90a896:	0c0200        	memw
  90a899:	231619        	s32i	a3, a1, 100
	default_data[8] = 0x00043007;
  90a89c:	136a1f        	l32r	a3, 8e5118 <vdesc_module_install+0x108>
  90a89f:	0c0200        	memw
  90a8a2:	23161a        	s32i	a3, a1, 104
        
	for(i=0; i<9; i++)
  90a8a5:	230a00        	movi	a3, 0
  90a8a8:	0c0200        	memw
  90a8ab:	8450      	l32i.n	a4, a5, 0
	{
		// check for the done bit to be set 
     
		while (1)
		{
			if (ioread32(0x40028) & BIT31)
  90a8ad:	674ff7        	bgez	a4, 90a8a8 <_fw_reset_dma_fifo+0x298>
				break;
		}

		A_DELAY_USECS(1);
  90a8b0:	24223b        	l32i	a4, a2, 236
  90a8b3:	c0a1      	movi.n	a10, 1
  90a8b5:	0b4000        	callx8	a4

		iowrite32(0x40024, default_data[i]);
  90a8b8:	0e3411        	slli	a4, a3, 2
  90a8bb:	a414      	add.n	a4, a1, a4
  90a8bd:	0c0200        	memw
  90a8c0:	264212        	l32i	a6, a4, 72
  90a8c3:	146a26        	l32r	a4, 8e515c <vdesc_module_install+0x14c>
	default_data[5] = 0xc1c00000;
	default_data[6] = 0x1aaabe40;
	default_data[7] = 0xbe105554;
	default_data[8] = 0x00043007;
        
	for(i=0; i<9; i++)
  90a8c6:	b133      	addi.n	a3, a3, 1
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90a8c8:	0c0200        	memw
  90a8cb:	9640      	s32i.n	a6, a4, 0
  90a8cd:	240a09        	movi	a4, 9
  90a8d0:	7439d4        	bne	a3, a4, 90a8a8 <_fw_reset_dma_fifo+0x298>
	// pcie rc 
	A_PRINTF("turn_off_magpie_rc_start ......\n");
	A_DELAY_USECS(measure_time);
	io32_clr(0x40040, BIT0);
	turn_off_phy_rc();
	A_PRINTF("turn_off_magpie_rc_end ......down\n");
  90a8d3:	232212        	l32i	a3, a2, 72
  90a8d6:	c061      	movi.n	a6, 1
  90a8d8:	1a6a2b        	l32r	a10, 8e5184 <vdesc_module_install+0x174>
  90a8db:	0c0200        	memw
  90a8de:	265600        	s32i	a6, a5, 0
  90a8e1:	0b3000        	callx8	a3
	A_DELAY_USECS(measure_time);
  90a8e4:	23223b        	l32i	a3, a2, 236
  90a8e7:	c0a0      	movi.n	a10, 0
  90a8e9:	0b3000        	callx8	a3
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90a8ec:	136a2c        	l32r	a3, 8e519c <vdesc_module_install+0x18c>

	A_PRINTF("0x4001C  %p ......\n", ioread32(0x4001c));
  90a8ef:	1a6a2d        	l32r	a10, 8e51a4 <vdesc_module_install+0x194>
  90a8f2:	0c0200        	memw
  90a8f5:	8b30      	l32i.n	a11, a3, 0
  90a8f7:	232212        	l32i	a3, a2, 72
  90a8fa:	0b3000        	callx8	a3
  90a8fd:	136a24        	l32r	a3, 8e5190 <vdesc_module_install+0x180>
	A_PRINTF("0x40040  %p ......\n", ioread32(0x40040));
  90a900:	1a6a2e        	l32r	a10, 8e51b8 <vdesc_module_install+0x1a8>
  90a903:	0c0200        	memw
  90a906:	8b30      	l32i.n	a11, a3, 0
  90a908:	232212        	l32i	a3, a2, 72
  90a90b:	0b3000        	callx8	a3
  90a90e:	136a08        	l32r	a3, 8e5130 <vdesc_module_install+0x120>
    
	/* turn off pcie_pll - power down (bit16) */
	A_PRINTF(" before pwd PCIE PLL CFG:0x5601C: 0x%08x\n",
  90a911:	242212        	l32i	a4, a2, 72
  90a914:	0c0200        	memw
  90a917:	2b3200        	l32i	a11, a3, 0
  90a91a:	1a6a2f        	l32r	a10, 8e51d8 <vdesc_module_install+0x1c8>
  90a91d:	0b4000        	callx8	a4
		 ioread32(0x5601C));
	io32_set(0x5601C, BIT18);
  90a920:	1b69cc        	l32r	a11, 8e5050 <vdesc_module_install+0x40>
  90a923:	2c0a00        	movi	a12, 0
  90a926:	033a02        	or	a10, a3, a3
  90a929:	5bff14        	call8	90a57c <io32_rmw>
  90a92c:	0c0200        	memw
  90a92f:	8b30      	l32i.n	a11, a3, 0
	A_PRINTF(" after pwd PCIE PLL CFG:0x5601C:  0x%08x\n",
  90a931:	1a6a30        	l32r	a10, 8e51f4 <vdesc_module_install+0x1e4>
  90a934:	232212        	l32i	a3, a2, 72
  90a937:	0b3000        	callx8	a3
		 ioread32(0x5601C));

	/* set everything to reset state?, requested by Oligo */
	io32_set(0x50010, BIT13 | BIT12
  90a93a:	1468ec        	l32r	a4, 8e4cec <mUsbEPinHighBandSet+0x34c>
  90a93d:	1b6a31        	l32r	a11, 8e5204 <vdesc_module_install+0x1f4>
  90a940:	2c0a00        	movi	a12, 0
  90a943:	da40      	mov.n	a10, a4
  90a945:	5bff0d        	call8	90a57c <io32_rmw>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90a948:	156a32        	l32r	a5, 8e5210 <vdesc_module_install+0x200>
  90a94b:	230a00        	movi	a3, 0
  90a94e:	0c0200        	memw
  90a951:	9350      	s32i.n	a3, a5, 0
		 | BIT11 | BIT9 | BIT7 | BIT6);

	iowrite32(0x5C000, 0);

	A_DELAY_USECS(10);
  90a953:	25223b        	l32i	a5, a2, 236
  90a956:	2a0a0a        	movi	a10, 10
  90a959:	0b5000        	callx8	a5
  90a95c:	1568fb        	l32r	a5, 8e4d48 <mUsbEPinHighBandSet+0x3a8>

	/* reset usb DMA controller */
	iowrite32_usb(ZM_SOC_USB_DMA_RESET_OFFSET, 0x0);

	io32_set(0x50010, BIT4);
  90a95f:	dc30      	mov.n	a12, a3
  90a961:	c1b0      	movi.n	a11, 16
  90a963:	da40      	mov.n	a10, a4
  90a965:	0c0200        	memw
  90a968:	9350      	s32i.n	a3, a5, 0
  90a96a:	5bff04        	call8	90a57c <io32_rmw>
	A_DELAY_USECS(5);
  90a96d:	22223b        	l32i	a2, a2, 236
  90a970:	c0a5      	movi.n	a10, 5
  90a972:	0b2000        	callx8	a2
	io32_clr(0x50010, BIT4);
  90a975:	c1c0      	movi.n	a12, 16
  90a977:	033b02        	or	a11, a3, a3
  90a97a:	044a02        	or	a10, a4, a4
  90a97d:	5bfeff        	call8	90a57c <io32_rmw>
  90a980:	0c0200        	memw
  90a983:	9650      	s32i.n	a6, a5, 0
  90a985:	d10f      	retw.n
	...

0090a988 <_fw_usb_suspend_reboot>:

BOOLEAN bEepromExist = TRUE;
BOOLEAN bJumptoFlash = FALSE;

void _fw_usb_suspend_reboot()
{
  90a988:	6c1004        	entry	a1, 32
	/* reset usb/wlan dma */
	_fw_reset_dma_fifo();
  90a98b:	5bff21        	call8	90a610 <_fw_reset_dma_fifo>

	/* restore gpio setting and usb/wlan dma state */
	_fw_restore_dma_fifo();
  90a98e:	5bff06        	call8	90a5a8 <_fw_restore_dma_fifo>
  90a991:	1268f3        	l32r	a2, 8e4d60 <mUsbEPinHighBandSet+0x3c0>
  90a994:	c181      	movi.n	a8, 17
  90a996:	0c0200        	memw
  90a999:	282600        	s32i	a8, a2, 0

	/* set clock to bypass mode - 40Mhz from XTAL */
	iowrite32(MAGPIE_REG_CPU_PLL_BYPASS_ADDR, BIT0 | BIT4);

	A_DELAY_USECS(100); /* wait for stable */
  90a99c:	1268bf        	l32r	a2, 8e4c98 <mUsbEPinHighBandSet+0x2f8>
  90a99f:	2a0a64        	movi	a10, 100
  90a9a2:	28223b        	l32i	a8, a2, 236
  90a9a5:	0b8000        	callx8	a8
  90a9a8:	1968fc        	l32r	a9, 8e4d98 <mUsbEPinHighBandSet+0x3f8>
  90a9ab:	1868f4        	l32r	a8, 8e4d7c <mUsbEPinHighBandSet+0x3dc>

	iowrite32(MAGPIE_REG_CPU_PLL_ADDR, BIT16);

	A_DELAY_USECS(100); /* wait for stable */
  90a9ae:	2a0a64        	movi	a10, 100
  90a9b1:	0c0200        	memw
  90a9b4:	9980      	s32i.n	a9, a8, 0
  90a9b6:	28223b        	l32i	a8, a2, 236
  90a9b9:	0b8000        	callx8	a8
	A_UART_HWINIT((40*1000*1000), 19200);
  90a9bc:	28221a        	l32i	a8, a2, 104
  90a9bf:	1b697c        	l32r	a11, 8e4fb0 <vbuf_module_install+0x50>
  90a9c2:	1a68be        	l32r	a10, 8e4cbc <mUsbEPinHighBandSet+0x31c>
  90a9c5:	0b8000        	callx8	a8

	A_CLOCK_INIT(40);
  90a9c8:	282238        	l32i	a8, a2, 224
  90a9cb:	c2a8      	movi.n	a10, 40
  90a9cd:	0b8000        	callx8	a8

	if (!bEepromExist) { /* jump to flash boot (eeprom data in flash) */
  90a9d0:	1868c1        	l32r	a8, 8e4cd4 <mUsbEPinHighBandSet+0x334>
  90a9d3:	298100        	l16ui	a9, a8, 0
  90a9d6:	282212        	l32i	a8, a2, 72
  90a9d9:	cc9f      	bnez.n	a9, 90a9ec <_fw_usb_suspend_reboot+0x64>
		bJumptoFlash = TRUE;
  90a9db:	1268c0        	l32r	a2, 8e4cdc <mUsbEPinHighBandSet+0x33c>
  90a9de:	c091      	movi.n	a9, 1
		A_PRINTF("Jump to Flash BOOT\n");
  90a9e0:	1a6a33        	l32r	a10, 8e52ac <vdesc_module_install+0x29c>
	A_UART_HWINIT((40*1000*1000), 19200);

	A_CLOCK_INIT(40);

	if (!bEepromExist) { /* jump to flash boot (eeprom data in flash) */
		bJumptoFlash = TRUE;
  90a9e3:	292500        	s16i	a9, a2, 0
		A_PRINTF("Jump to Flash BOOT\n");
  90a9e6:	0b8000        	callx8	a8
		app_start();
  90a9e9:	5bed85        	call8	906000 <app_start>
	} else {
		A_PRINTF("receive the suspend command...\n");
  90a9ec:	1a6a34        	l32r	a10, 8e52bc <vdesc_module_install+0x2ac>
  90a9ef:	0b8000        	callx8	a8
		/* reboot..... */
		A_USB_JUMP_BOOT();
  90a9f2:	22222c        	l32i	a2, a2, 176
  90a9f5:	0b2000        	callx8	a2
  90a9f8:	d10f      	retw.n
	...

0090a9fc <zfTurnOffPower_patch>:
 *
 * . set suspend counter to non-zero value
 * . 
 */
void zfTurnOffPower_patch(void)
{
  90a9fc:	6c1004        	entry	a1, 32
	A_PRINTF("+++ goto suspend ......\n");
  90a9ff:	1268bf        	l32r	a2, 8e4cfc <mUsbEPinHighBandSet+0x35c>
  90aa02:	1a6a35        	l32r	a10, 8e52d8 <vdesc_module_install+0x2c8>
  90aa05:	232212        	l32i	a3, a2, 72
  90aa08:	c151      	movi.n	a5, 17
  90aa0a:	0b3000        	callx8	a3

	/* setting the go suspend here, power down right away */
	io32_set(0x10000, BIT3);
  90aa0d:	1368fc        	l32r	a3, 8e4e00 <mUsbEPinHighBandSet+0x460>
  90aa10:	c0c0      	movi.n	a12, 0
  90aa12:	c0b8      	movi.n	a11, 8
  90aa14:	da30      	mov.n	a10, a3
  90aa16:	5bfed9        	call8	90a57c <io32_rmw>

	A_DELAY_USECS(100);
  90aa19:	24223b        	l32i	a4, a2, 236
  90aa1c:	2a0a64        	movi	a10, 100
  90aa1f:	0b4000        	callx8	a4
  90aa22:	1468f3        	l32r	a4, 8e4df0 <mUsbEPinHighBandSet+0x450>
	 *  5. set SUSPEND_ENABLE
	 */

	iowrite32(MAGPIE_REG_CPU_PLL_BYPASS_ADDR, BIT0 | BIT4);

	A_DELAY_USECS(100); // wait for stable
  90aa25:	2a0a64        	movi	a10, 100
  90aa28:	0c0200        	memw
  90aa2b:	254600        	s32i	a5, a4, 0
  90aa2e:	24223b        	l32i	a4, a2, 236
  90aa31:	0b4000        	callx8	a4
  90aa34:	1468f4        	l32r	a4, 8e4e04 <mUsbEPinHighBandSet+0x464>

	iowrite32(MAGPIE_REG_CPU_PLL_ADDR, BIT16);

	A_DELAY_USECS(100); // wait for stable
  90aa37:	2a0a64        	movi	a10, 100
  90aa3a:	0c0200        	memw
  90aa3d:	9340      	s32i.n	a3, a4, 0
  90aa3f:	24223b        	l32i	a4, a2, 236
  90aa42:	0b4000        	callx8	a4

	A_UART_HWINIT((40*1000*1000), 19200);
  90aa45:	1b697c        	l32r	a11, 8e5038 <vdesc_module_install+0x28>
  90aa48:	24221a        	l32i	a4, a2, 104
  90aa4b:	1a68be        	l32r	a10, 8e4d44 <mUsbEPinHighBandSet+0x3a4>
  90aa4e:	0b4000        	callx8	a4
	A_CLOCK_INIT(40);
  90aa51:	242238        	l32i	a4, a2, 224
  90aa54:	c2a8      	movi.n	a10, 40
  90aa56:	0b4000        	callx8	a4

	io32_set(MAGPIE_REG_ETH_PLL_ADDR, BIT16);
  90aa59:	176a36        	l32r	a7, 8e5334 <vdesc_module_install+0x324>
  90aa5c:	db30      	mov.n	a11, a3
  90aa5e:	da70      	mov.n	a10, a7
  90aa60:	c0c0      	movi.n	a12, 0
  90aa62:	5bfec6        	call8	90a57c <io32_rmw>

	io32_set(MAGPIE_REG_ETH_PLL_BYPASS_ADDR, BIT4 | BIT0);
  90aa65:	166a37        	l32r	a6, 8e5344 <vdesc_module_install+0x334>
  90aa68:	db50      	mov.n	a11, a5
  90aa6a:	da60      	mov.n	a10, a6
  90aa6c:	c0c0      	movi.n	a12, 0
  90aa6e:	5bfec3        	call8	90a57c <io32_rmw>

	io32_set(MAGPIE_REG_SUSPEND_ENABLE_ADDR, 0x10 << 8);
  90aa71:	146a39        	l32r	a4, 8e5358 <vdesc_module_install+0x348>
  90aa74:	1b6a38        	l32r	a11, 8e5354 <vdesc_module_install+0x344>
  90aa77:	2c0a00        	movi	a12, 0
  90aa7a:	044a02        	or	a10, a4, a4
  90aa7d:	5bfebf        	call8	90a57c <io32_rmw>

	// TURN OFF ETH PLL
	_fw_power_off();

	//32clk wait for External ETH PLL stable
	A_DELAY_USECS(100);
  90aa80:	22223b        	l32i	a2, a2, 236
  90aa83:	2a0a64        	movi	a10, 100
  90aa86:	0b2000        	callx8	a2
  90aa89:	186a3b        	l32r	a8, 8e5378 <vdesc_module_install+0x368>
  90aa8c:	126a3a        	l32r	a2, 8e5374 <vdesc_module_install+0x364>
    
	iowrite32(0x52000, 0x70303); /* read back 0x703f7 */
	iowrite32(0x52008, 0x0e91c); /* read back 0x1e948 */
    
	io32_set(MAGPIE_REG_SUSPEND_ENABLE_ADDR, BIT0);
  90aa8f:	da40      	mov.n	a10, a4
  90aa91:	0c0200        	memw
  90aa94:	9820      	s32i.n	a8, a2, 0
  90aa96:	186a3d        	l32r	a8, 8e538c <vdesc_module_install+0x37c>
  90aa99:	126a3c        	l32r	a2, 8e538c <vdesc_module_install+0x37c>
  90aa9c:	c0c0      	movi.n	a12, 0
  90aa9e:	0c0200        	memw
  90aaa1:	9820      	s32i.n	a8, a2, 0
  90aaa3:	c0b1      	movi.n	a11, 1
  90aaa5:	5bfeb5        	call8	90a57c <io32_rmw>
     *  3. turn on ETH PLL
     *  4. disable ETH PLL bypass and update
     *  5. turn on pcie pll
     */    

	io32_clr(MAGPIE_REG_ETH_PLL_ADDR, BIT16);
  90aaa8:	dc30      	mov.n	a12, a3
  90aaaa:	da70      	mov.n	a10, a7
  90aaac:	c0b0      	movi.n	a11, 0
  90aaae:	5bfeb3        	call8	90a57c <io32_rmw>

	/* deassert eth_pll bypass mode and trigger update bit */
	io32_clr(MAGPIE_REG_ETH_PLL_BYPASS_ADDR, BIT4 | BIT0);
  90aab1:	055c02        	or	a12, a5, a5
  90aab4:	066a02        	or	a10, a6, a6
  90aab7:	2b0a00        	movi	a11, 0
  90aaba:	5bfeb0        	call8	90a57c <io32_rmw>
	io32_set(MAGPIE_REG_SUSPEND_ENABLE_ADDR, BIT0);

	// wake up, and turn on cpu, eth, pcie and usb pll 
	_fw_power_on();
	// restore gpio and other settings
	_fw_restore_dma_fifo();
  90aabd:	5bfeba        	call8	90a5a8 <_fw_restore_dma_fifo>

	/* clear suspend */
	io32_clr(MAGPIE_REG_SUSPEND_ENABLE_ADDR, BIT0);
  90aac0:	da40      	mov.n	a10, a4
  90aac2:	c0c1      	movi.n	a12, 1
  90aac4:	c0b0      	movi.n	a11, 0
  90aac6:	5bfead        	call8	90a57c <io32_rmw>
	io32_clr(0x52028, BIT8 | BIT12 | BIT16);
  90aac9:	1c6a3e        	l32r	a12, 8e53c4 <vdesc_module_install+0x3b4>
  90aacc:	1a6a3f        	l32r	a10, 8e53c8 <vdesc_module_install+0x3b8>
  90aacf:	c0b0      	movi.n	a11, 0
  90aad1:	5bfeaa        	call8	90a57c <io32_rmw>
  90aad4:	d10f      	retw.n
	...

0090aad8 <zfResetUSBFIFO_patch>:
 * . turn off pcie pll
 * . reset all pcie/gmac related registers
 * . reset usb dma
 */
void zfResetUSBFIFO_patch(void)
{
  90aad8:	6c1004        	entry	a1, 32
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90aadb:	126a40        	l32r	a2, 8e53dc <vdesc_module_install+0x3cc>
	A_PRINTF("0x9808  0x%x ......\n", ioread32(0x10ff9808));
  90aade:	1a6a41        	l32r	a10, 8e53e4 <vdesc_module_install+0x3d4>
  90aae1:	0c0200        	memw
  90aae4:	2b2200        	l32i	a11, a2, 0
  90aae7:	1268bf        	l32r	a2, 8e4de4 <mUsbEPinHighBandSet+0x444>
  90aaea:	232212        	l32i	a3, a2, 72
  90aaed:	0b3000        	callx8	a3
  90aaf0:	1469a4        	l32r	a4, 8e5180 <vdesc_module_install+0x170>
	A_PRINTF("0x7890  0x%x ......\n", ioread32(0x10ff7890));
  90aaf3:	136a42        	l32r	a3, 8e53fc <vdesc_module_install+0x3ec>
  90aaf6:	282212        	l32i	a8, a2, 72
  90aaf9:	0c0200        	memw
  90aafc:	2b4200        	l32i	a11, a4, 0
  90aaff:	da30      	mov.n	a10, a3
  90ab01:	0b8000        	callx8	a8
  90ab04:	0c0200        	memw
  90ab07:	8b40      	l32i.n	a11, a4, 0
	A_PRINTF("0x7890  0x%x ......\n", ioread32(0x10ff7890));
  90ab09:	242212        	l32i	a4, a2, 72
  90ab0c:	da30      	mov.n	a10, a3
  90ab0e:	0b4000        	callx8	a4
  90ab11:	136a10        	l32r	a3, 8e5354 <vdesc_module_install+0x344>
	A_PRINTF("0x4088  0x%x ......\n", ioread32(0x10ff4088));
  90ab14:	222212        	l32i	a2, a2, 72
  90ab17:	0c0200        	memw
  90ab1a:	8b30      	l32i.n	a11, a3, 0
  90ab1c:	1a6a15        	l32r	a10, 8e5370 <vdesc_module_install+0x360>
  90ab1f:	0b2000        	callx8	a2
	_fw_reset_dma_fifo();
  90ab22:	5bfebb        	call8	90a610 <_fw_reset_dma_fifo>
  90ab25:	d10f      	retw.n
	...

0090ab28 <cmnos_clock_init_patch>:
extern a_uint32_t cticks;

// clock change 
//
void cmnos_clock_init_patch(a_uint32_t refclk)
{
  90ab28:	6c1004        	entry	a1, 32
    ref_clk = refclk;
  90ab2b:	186a43        	l32r	a8, 8e5438 <vdesc_module_install+0x428>
  90ab2e:	9280      	s32i.n	a2, a8, 0
  90ab30:	d10f      	retw.n
	...

0090ab34 <cmnos_refclk_speed_get_patch>:
}

// retrieve current clock setting
a_uint32_t cmnos_refclk_speed_get_patch(void)
{
  90ab34:	6c1004        	entry	a1, 32
    return ref_clk;
}
  90ab37:	186a43        	l32r	a8, 8e5444 <vdesc_module_install+0x434>
  90ab3a:	8280      	l32i.n	a2, a8, 0
  90ab3c:	d10f      	retw.n
	...

0090ab40 <cmnos_delay_us_patch>:


// software emulate delay function
void cmnos_delay_us_patch(int us)
{
  90ab40:	6c1004        	entry	a1, 32
    a_uint32_t start_time = NOW();
  90ab43:	5b6f85        	call8	8e6958 <xthal_get_ccount>
    unsigned int num_ticks = us*ref_clk; // system_freq == number of ticks per 1us
  90ab46:	186a43        	l32r	a8, 8e5454 <vdesc_module_install+0x444>


// software emulate delay function
void cmnos_delay_us_patch(int us)
{
    a_uint32_t start_time = NOW();
  90ab49:	d3a0      	mov.n	a3, a10
    unsigned int num_ticks = us*ref_clk; // system_freq == number of ticks per 1us
  90ab4b:	288200        	l32i	a8, a8, 0
  90ab4e:	082228        	mull	a2, a2, a8
    
    while ( (NOW() - start_time) < num_ticks) {
  90ab51:	5b6f81        	call8	8e6958 <xthal_get_ccount>
  90ab54:	03aa0c        	sub	a10, a10, a3
  90ab57:	72a3f6        	bltu	a10, a2, 90ab51 <cmnos_delay_us_patch+0x11>
        /* busy spin */
        ;
    }
}
  90ab5a:	d10f      	retw.n

0090ab5c <cmnos_tick_patch>:


// software emulate microsecond ticks
void cmnos_tick_patch(void)
{
  90ab5c:	6c1004        	entry	a1, 32
    static a_uint32_t last_tick = 0;
    a_uint32_t current_tick = NOW();
  90ab5f:	5b6f7e        	call8	8e6958 <xthal_get_ccount>
    a_uint32_t delta_tick;

    delta_tick = (A_UINT32 ) (current_tick - last_tick)/(ref_clk<<10);
  90ab62:	186a43        	l32r	a8, 8e5470 <vdesc_module_install+0x460>
  90ab65:	126a44        	l32r	a2, 8e5478 <vdesc_module_install+0x468>

// software emulate microsecond ticks
void cmnos_tick_patch(void)
{
    static a_uint32_t last_tick = 0;
    a_uint32_t current_tick = NOW();
  90ab68:	d3a0      	mov.n	a3, a10
    a_uint32_t delta_tick;

    delta_tick = (A_UINT32 ) (current_tick - last_tick)/(ref_clk<<10);
  90ab6a:	8b80      	l32i.n	a11, a8, 0
  90ab6c:	2a2200        	l32i	a10, a2, 0
  90ab6f:	06bb11        	slli	a11, a11, 10
  90ab72:	0a3a0c        	sub	a10, a3, a10
  90ab75:	5b6fb5        	call8	8e6a4c <__udivsi3>

    if( delta_tick > 0 )
  90ab78:	c8a0      	beqz.n	a10, 90ab7c <cmnos_tick_patch+0x20>
        last_tick = current_tick;
  90ab7a:	9320      	s32i.n	a3, a2, 0

    cticks += delta_tick;
  90ab7c:	196a45        	l32r	a9, 8e5490 <vdesc_module_install+0x480>
  90ab7f:	8890      	l32i.n	a8, a9, 0
  90ab81:	aa8a      	add.n	a10, a8, a10
  90ab83:	9a90      	s32i.n	a10, a9, 0
  90ab85:	d10f      	retw.n
	...

0090ab88 <cmnos_milliseconds_patch>:
}

// get current sysmem up time in milliseconds based
a_uint32_t cmnos_milliseconds_patch(void)
{
  90ab88:	6c1004        	entry	a1, 32
    cmnos_tick_patch();
  90ab8b:	5bfff4        	call8	90ab5c <cmnos_tick_patch>
    
    return (cticks);
}
  90ab8e:	186a45        	l32r	a8, 8e54a4 <vdesc_module_install+0x494>
  90ab91:	8280      	l32i.n	a2, a8, 0
  90ab93:	d10f      	retw.n
  90ab95:	000000        	ill

0090ab98 <_HIFusb_get_max_msg_len_patch>:

/*
 * -- support more than 64 bytes command on ep4 -- 
 */
int _HIFusb_get_max_msg_len_patch(hif_handle_t handle, int pipe)
{
  90ab98:	6c1004        	entry	a1, 32
    switch(pipe) {
  90ab9b:	233cfd        	addi	a3, a3, -3
        case HIF_USB_PIPE_INTERRUPT:
        case HIF_USB_PIPE_COMMAND:
            return 512;
            
        default:
            return 1600;
  90ab9e:	226a40        	movi	a2, 0x640
/*
 * -- support more than 64 bytes command on ep4 -- 
 */
int _HIFusb_get_max_msg_len_patch(hif_handle_t handle, int pipe)
{
    switch(pipe) {
  90aba1:	6f3202        	bgeui	a3, 2, 90aba7 <_HIFusb_get_max_msg_len_patch+0xf>
        case HIF_USB_PIPE_INTERRUPT:
        case HIF_USB_PIPE_COMMAND:
            return 512;
  90aba4:	222a00        	movi	a2, 0x200
            
        default:
            return 1600;
    }
}
  90aba7:	d10f      	retw.n
  90aba9:	000000        	ill

0090abac <_HIFusb_isr_handler_patch>:

/*
 * -- move the usb_task to here --
 */
void _HIFusb_isr_handler_patch(hif_handle_t h)
{
  90abac:	6c1004        	entry	a1, 32
    A_USB_FW_TASK();
  90abaf:	1868bf        	l32r	a8, 8e4eac <mUsbEPinHighBandSet+0x50c>
  90abb2:	28821e        	l32i	a8, a8, 120
  90abb5:	0b8000        	callx8	a8

    _HIFusb_isr_handler(h);
  90abb8:	da20      	mov.n	a10, a2
  90abba:	5b62ca        	call8	8e36e4 <_HIFusb_isr_handler>
  90abbd:	d10f      	retw.n
	...

0090abc0 <_HIFusb_start_patch>:
 * - update DMA_START bit4 to 1
 * - update DESC_START_ADDR
 * - update DMA_START bit 0
 */
void _HIFusb_start_patch(hif_handle_t handle) 
{
  90abc0:	6c1004        	entry	a1, 32
    MAGPIE_REG_USB_TX0_DMA_START = 0x0;
  90abc3:	1c6a46        	l32r	a12, 8e54dc <vdesc_module_install+0x4cc>
  90abc6:	c0d0      	movi.n	a13, 0
    MAGPIE_REG_USB_RX0_DMA_START = 0x0;
  90abc8:	1b6a47        	l32r	a11, 8e54e4 <vdesc_module_install+0x4d4>
 * - update DESC_START_ADDR
 * - update DMA_START bit 0
 */
void _HIFusb_start_patch(hif_handle_t handle) 
{
    MAGPIE_REG_USB_TX0_DMA_START = 0x0;
  90abcb:	0c0200        	memw
  90abce:	9dc0      	s32i.n	a13, a12, 0
    MAGPIE_REG_USB_RX0_DMA_START = 0x0;
    MAGPIE_REG_USB_RX1_DMA_START = 0x0;
  90abd0:	196a48        	l32r	a9, 8e54f0 <vdesc_module_install+0x4e0>
 * - update DMA_START bit 0
 */
void _HIFusb_start_patch(hif_handle_t handle) 
{
    MAGPIE_REG_USB_TX0_DMA_START = 0x0;
    MAGPIE_REG_USB_RX0_DMA_START = 0x0;
  90abd3:	0c0200        	memw
  90abd6:	9db0      	s32i.n	a13, a11, 0
    MAGPIE_REG_USB_RX1_DMA_START = 0x0;
    MAGPIE_REG_USB_RX2_DMA_START = 0x0;
  90abd8:	186a49        	l32r	a8, 8e54fc <vdesc_module_install+0x4ec>
 */
void _HIFusb_start_patch(hif_handle_t handle) 
{
    MAGPIE_REG_USB_TX0_DMA_START = 0x0;
    MAGPIE_REG_USB_RX0_DMA_START = 0x0;
    MAGPIE_REG_USB_RX1_DMA_START = 0x0;
  90abdb:	0c0200        	memw
  90abde:	9d90      	s32i.n	a13, a9, 0
 * - update DMA_START bit4 to 1
 * - update DESC_START_ADDR
 * - update DMA_START bit 0
 */
void _HIFusb_start_patch(hif_handle_t handle) 
{
  90abe0:	da20      	mov.n	a10, a2
    MAGPIE_REG_USB_TX0_DMA_START = 0x0;
    MAGPIE_REG_USB_RX0_DMA_START = 0x0;
    MAGPIE_REG_USB_RX1_DMA_START = 0x0;
    MAGPIE_REG_USB_RX2_DMA_START = 0x0;
  90abe2:	0c0200        	memw
  90abe5:	2d8600        	s32i	a13, a8, 0
    
    while( 1 )
    {
        if(!MAGPIE_REG_USB_TX0_DMA_START &&
  90abe8:	0c0200        	memw
  90abeb:	8dc0      	l32i.n	a13, a12, 0
  90abed:	65dff7        	bnez	a13, 90abe8 <_HIFusb_start_patch+0x28>
	   !MAGPIE_REG_USB_RX0_DMA_START &&
  90abf0:	0c0200        	memw
  90abf3:	8db0      	l32i.n	a13, a11, 0
    MAGPIE_REG_USB_RX1_DMA_START = 0x0;
    MAGPIE_REG_USB_RX2_DMA_START = 0x0;
    
    while( 1 )
    {
        if(!MAGPIE_REG_USB_TX0_DMA_START &&
  90abf5:	65dfef        	bnez	a13, 90abe8 <_HIFusb_start_patch+0x28>
	   !MAGPIE_REG_USB_RX0_DMA_START &&
	   !MAGPIE_REG_USB_RX1_DMA_START &&
  90abf8:	0c0200        	memw
  90abfb:	8d90      	l32i.n	a13, a9, 0
    MAGPIE_REG_USB_RX2_DMA_START = 0x0;
    
    while( 1 )
    {
        if(!MAGPIE_REG_USB_TX0_DMA_START &&
	   !MAGPIE_REG_USB_RX0_DMA_START &&
  90abfd:	65dfe7        	bnez	a13, 90abe8 <_HIFusb_start_patch+0x28>
	   !MAGPIE_REG_USB_RX1_DMA_START &&
	   !MAGPIE_REG_USB_RX2_DMA_START )
  90ac00:	0c0200        	memw
  90ac03:	8d80      	l32i.n	a13, a8, 0
    
    while( 1 )
    {
        if(!MAGPIE_REG_USB_TX0_DMA_START &&
	   !MAGPIE_REG_USB_RX0_DMA_START &&
	   !MAGPIE_REG_USB_RX1_DMA_START &&
  90ac05:	65dfdf        	bnez	a13, 90abe8 <_HIFusb_start_patch+0x28>
	   !MAGPIE_REG_USB_RX2_DMA_START )
        {
            MAGPIE_REG_USB_TX0_DMA_START = MAGPIE_REG_USB_TX0_DMA_START|BIT4; 
  90ac08:	0c0200        	memw
  90ac0b:	8ec0      	l32i.n	a14, a12, 0
  90ac0d:	c1d0      	movi.n	a13, 16
  90ac0f:	0dee02        	or	a14, a14, a13
  90ac12:	0c0200        	memw
  90ac15:	9ec0      	s32i.n	a14, a12, 0
            MAGPIE_REG_USB_RX0_DMA_START = MAGPIE_REG_USB_RX0_DMA_START|BIT4;
  90ac17:	0c0200        	memw
  90ac1a:	8cb0      	l32i.n	a12, a11, 0
  90ac1c:	0dcc02        	or	a12, a12, a13
  90ac1f:	0c0200        	memw
  90ac22:	9cb0      	s32i.n	a12, a11, 0
            MAGPIE_REG_USB_RX1_DMA_START = MAGPIE_REG_USB_RX1_DMA_START|BIT4;
  90ac24:	0c0200        	memw
  90ac27:	8b90      	l32i.n	a11, a9, 0
  90ac29:	0dbb02        	or	a11, a11, a13
  90ac2c:	0c0200        	memw
  90ac2f:	9b90      	s32i.n	a11, a9, 0
            MAGPIE_REG_USB_RX2_DMA_START = MAGPIE_REG_USB_RX2_DMA_START|BIT4;
  90ac31:	0c0200        	memw
  90ac34:	8980      	l32i.n	a9, a8, 0
  90ac36:	0d9d02        	or	a13, a9, a13
  90ac39:	0c0200        	memw
  90ac3c:	9d80      	s32i.n	a13, a8, 0
            break;
        }
    }
    _HIFusb_start(handle);
  90ac3e:	5b6218        	call8	8e34a0 <_HIFusb_start>
  90ac41:	d10f      	retw.n
	...

0090ac44 <__adf_os_dmamem_alloc>:
 * @return void* (Virtual address)
 */
inline void*
__adf_os_dmamem_alloc(__adf_os_device_t osdev, adf_os_size_t size, 
                      a_bool_t coherent, __adf_os_dma_map_t *dmap)
{    
  90ac44:	6c1004        	entry	a1, 32
    (*dmap) = A_ALLOCRAM(sizeof(struct __adf_dma_map));
  90ac47:	1668bf        	l32r	a6, 8e4f44 <mUsbEPinHighBandSet+0x5a4>
  90ac4a:	c0bc      	movi.n	a11, 12
  90ac4c:	226252        	l32i	a2, a6, 0x148
  90ac4f:	c0a0      	movi.n	a10, 0
  90ac51:	0b2000        	callx8	a2
  90ac54:	9a50      	s32i.n	a10, a5, 0
  90ac56:	d4a0      	mov.n	a4, a10
    (*dmap)->ds_len = size;
    
    return (*dmap)->ds_addr;
    
fail_malloc: 
    return NULL;            
  90ac58:	d2a0      	mov.n	a2, a10
__adf_os_dmamem_alloc(__adf_os_device_t osdev, adf_os_size_t size, 
                      a_bool_t coherent, __adf_os_dma_map_t *dmap)
{    
    (*dmap) = A_ALLOCRAM(sizeof(struct __adf_dma_map));
    
	if((*dmap) == NULL){
  90ac5a:	c9a2      	beqz.n	a10, 90ac70 <__adf_os_dmamem_alloc+0x2c>
		goto fail_malloc;
	}
	    
    (*dmap)->ds_addr = A_ALLOCRAM(size);
  90ac5c:	226252        	l32i	a2, a6, 0x148
  90ac5f:	db30      	mov.n	a11, a3
  90ac61:	c0a0      	movi.n	a10, 0
  90ac63:	0b2000        	callx8	a2
    (*dmap)->ds_len = size;
  90ac66:	8250      	l32i.n	a2, a5, 0
    
	if((*dmap) == NULL){
		goto fail_malloc;
	}
	    
    (*dmap)->ds_addr = A_ALLOCRAM(size);
  90ac68:	9a41      	s32i.n	a10, a4, 4
    (*dmap)->ds_len = size;
  90ac6a:	232504        	s16i	a3, a2, 8
    
    return (*dmap)->ds_addr;
  90ac6d:	222201        	l32i	a2, a2, 4
    
fail_malloc: 
    return NULL;            
}
  90ac70:	d10f      	retw.n
	...

0090ac74 <__adf_os_setup_intr>:
 * @return int
 */

int
__adf_os_setup_intr(__adf_os_device_t  osdev, adf_os_drv_intr fn)
{
  90ac74:	6c1004        	entry	a1, 32
    g_wlan_intr = fn;
  90ac77:	1869ed        	l32r	a8, 8e542c <vdesc_module_install+0x41c>
    
    return 0;    
}
  90ac7a:	c020      	movi.n	a2, 0
 */

int
__adf_os_setup_intr(__adf_os_device_t  osdev, adf_os_drv_intr fn)
{
    g_wlan_intr = fn;
  90ac7c:	9380      	s32i.n	a3, a8, 0
    
    return 0;    
}
  90ac7e:	d10f      	retw.n

0090ac80 <__adf_os_free_intr>:
 * @param[in] dev
 * @param[in] sc
 */
void
__adf_os_free_intr(__adf_os_device_t osdev)
{
  90ac80:	6c1004        	entry	a1, 32
    g_wlan_intr = NULL;  
  90ac83:	1869ed        	l32r	a8, 8e5438 <vdesc_module_install+0x428>
  90ac86:	c090      	movi.n	a9, 0
  90ac88:	9980      	s32i.n	a9, a8, 0
  90ac8a:	d10f      	retw.n

0090ac8c <ath_hal_attach_tgt>:

struct ath_hal*
ath_hal_attach_tgt(a_uint32_t devid,HAL_SOFTC sc,
		   adf_os_device_t dev,
		   a_uint32_t flags, HAL_STATUS *error)
{
  90ac8c:	6c1004        	entry	a1, 32
	struct ath_hal *ah = AH_NULL;

	ah = ar5416Attach(sc, dev, error);
  90ac8f:	dc60      	mov.n	a12, a6
  90ac91:	db40      	mov.n	a11, a4
  90ac93:	da30      	mov.n	a10, a3
  90ac95:	5804da        	call8	90c000 <ar5416Attach>

	return ah;
}
  90ac98:	d2a0      	mov.n	a2, a10
  90ac9a:	d10f      	retw.n

0090ac9c <ath_hal_getcapability>:

HAL_STATUS
ath_hal_getcapability(struct ath_hal *ah, HAL_CAPABILITY_TYPE type)
{
  90ac9c:	6c1004        	entry	a1, 32
	const HAL_CAPABILITIES *pCap = &AH_PRIVATE(ah)->ah_caps;
	switch (type) {
  90ac9f:	683111        	beqi	a3, 1, 90acb4 <ath_hal_getcapability+0x18>
  90aca2:	c93e      	beqz.n	a3, 90acc4 <ath_hal_getcapability+0x28>
	case HAL_CAP_BSSIDMASK:
		return pCap->halBssIdMaskSupport ? HAL_OK : HAL_ENOTSUPP;
	case HAL_CAP_VEOL:
		return pCap->halVEOLSupport ? HAL_OK : HAL_ENOTSUPP;
	default:
		return HAL_EINVAL;
  90aca4:	223cfe        	addi	a2, a3, -2
  90aca7:	c081      	movi.n	a8, 1
  90aca9:	c030      	movi.n	a3, 0
  90acab:	028338        	moveqz	a3, a8, a2
  90acae:	bc32      	addi.n	a2, a3, 12
  90acb0:	d10f      	retw.n
  90acb2:	000013        	srai	a0, a0, 16
	const HAL_CAPABILITIES *pCap = &AH_PRIVATE(ah)->ah_caps;
	switch (type) {
	case HAL_CAP_TSF_ADJUST:
		return HAL_ENOTSUPP;
	case HAL_CAP_BSSIDMASK:
		return pCap->halBssIdMaskSupport ? HAL_OK : HAL_ENOTSUPP;
  90acb5:	69db22        	bnei	a13, 16, 90acdb <ath_hal_computetxtime+0x7>
  90acb8:	222b03        	l32ai	a2, a2, 12
  90acbb:	2201c0        	l16ui	a2, a0, 0x180
  90acbe:	306000        	excw
  90acc1:	070000        	callx4	a0
	case HAL_CAP_VEOL:
		return pCap->halVEOLSupport ? HAL_OK : HAL_ENOTSUPP;
  90acc4:	22222b        	l32i	a2, a2, 172
  90acc7:	02f240        	extui	a2, a2, 15, 1
	const HAL_CAPABILITIES *pCap = &AH_PRIVATE(ah)->ah_caps;
	switch (type) {
	case HAL_CAP_TSF_ADJUST:
		return HAL_ENOTSUPP;
	case HAL_CAP_BSSIDMASK:
		return pCap->halBssIdMaskSupport ? HAL_OK : HAL_ENOTSUPP;
  90acca:	c08d      	movi.n	a8, 13
  90accc:	028338        	moveqz	a3, a8, a2
  90accf:	d230      	mov.n	a2, a3
	case HAL_CAP_VEOL:
		return pCap->halVEOLSupport ? HAL_OK : HAL_ENOTSUPP;
	default:
		return HAL_EINVAL;
	}
}
  90acd1:	d10f      	retw.n
	...

0090acd4 <ath_hal_computetxtime>:

a_uint16_t
ath_hal_computetxtime(struct ath_hal *ah,
		      const HAL_RATE_TABLE *rates, a_uint32_t frameLen, a_uint16_t rateix,
		      HAL_BOOL shortPreamble)
{
  90acd4:	6c1004        	entry	a1, 32
  90acd7:	05024f        	extui	a2, a5, 0, 16
	a_uint32_t bitsPerSymbol, numBits, numSymbols, phyTime, txTime;
	a_uint32_t kbps;

	kbps = rates->info[rateix].rateKbps;
  90acda:	0e2511        	slli	a5, a2, 2
  90acdd:	a255      	add.n	a5, a5, a2
  90acdf:	0e5511        	slli	a5, a5, 2
  90ace2:	a533      	add.n	a3, a3, a5
  90ace4:	8b3c      	l32i.n	a11, a3, 48

	/*
	 * index can be invalid duting dynamic Turbo transitions.
	 */
	if(kbps == 0) return 0;
  90ace6:	c020      	movi.n	a2, 0
  90ace8:	72b159        	beq	a11, a2, 90ad45 <ath_hal_computetxtime+0x71>
	switch (rates->info[rateix].phy) {
  90aceb:	253029        	l8ui	a5, a3, 41
  90acee:	725106        	beq	a5, a2, 90acf8 <ath_hal_computetxtime+0x24>
  90acf1:	68522c        	beqi	a5, 2, 90ad21 <ath_hal_computetxtime+0x4d>
  90acf4:	60004a        	j	90ad42 <ath_hal_computetxtime+0x6e>
  90acf7:	00250a        	addx4	a5, a2, a0

	case IEEE80211_T_CCK:
		phyTime = CCK_PREAMBLE_BITS + CCK_PLCP_BITS;
  90acfa:	c0c8      	movi.n	a12, 8
		if (shortPreamble && rates->info[rateix].shortPreamble)
  90acfc:	672330        	bgez	a2, 90b030 <ar5416ProcRxDescFast_20+0xf4>
  90acff:	35220a        	excw
			phyTime >>= 1;
  90ad02:	600325        	j	90b02b <ar5416ProcRxDescFast_20+0xef>
  90ad05:	390d42        	excw
		numBits = frameLen << 3;
  90ad08:	11084a        	l32r	a1, 8cce30 <_bss_end+0x3b9f20>
		txTime = phyTime + ((numBits * 1000)/kbps);
  90ad0b:	1102aa        	l32r	a1, 8cb7b4 <_bss_end+0x3b88a4>
  90ad0e:	0c0eaa        	excw
  90ad11:	11a2aa        	l32r	a1, 8f37bc <memset+0xc974>
  90ad14:	0daa11        	slli	a10, a10, 3
  90ad17:	5b6f4d        	call8	8e6a4c <__udivsi3>
		/* TODO: make sure the same value of txTime can use in all device */
		if (ath_hal_getcapability(ah, HAL_CAP_HT) != HAL_OK)
			txTime = txTime + CCK_SIFS_TIME;
  90ad1a:	baa2      	addi.n	a2, a10, 10
  90ad1c:	a522      	add.n	a2, a2, a5
  90ad1e:	600020        	j	90ad42 <ath_hal_computetxtime+0x6e>
		break;
	case IEEE80211_T_OFDM:
		/* full rate channel */
		bitsPerSymbol   = (kbps * OFDM_SYMBOL_TIME) / 1000;
  90ad21:	0eb211        	slli	a2, a11, 2
  90ad24:	1b6a4a        	l32r	a11, 8e564c <vdesc_module_install+0x63c>
		HALASSERT(bitsPerSymbol != 0);

		numBits = OFDM_PLCP_BITS + (frameLen << 3);
  90ad27:	0d4411        	slli	a4, a4, 3
		if (ath_hal_getcapability(ah, HAL_CAP_HT) != HAL_OK)
			txTime = txTime + CCK_SIFS_TIME;
		break;
	case IEEE80211_T_OFDM:
		/* full rate channel */
		bitsPerSymbol   = (kbps * OFDM_SYMBOL_TIME) / 1000;
  90ad2a:	0b222a        	muluh	a2, a2, a11
		HALASSERT(bitsPerSymbol != 0);

		numBits = OFDM_PLCP_BITS + (frameLen << 3);
		numSymbols = asf_howmany(numBits, bitsPerSymbol);
  90ad2d:	2a4c15        	addi	a10, a4, 21
		if (ath_hal_getcapability(ah, HAL_CAP_HT) != HAL_OK)
			txTime = txTime + CCK_SIFS_TIME;
		break;
	case IEEE80211_T_OFDM:
		/* full rate channel */
		bitsPerSymbol   = (kbps * OFDM_SYMBOL_TIME) / 1000;
  90ad30:	026214        	srli	a2, a2, 6
		HALASSERT(bitsPerSymbol != 0);

		numBits = OFDM_PLCP_BITS + (frameLen << 3);
		numSymbols = asf_howmany(numBits, bitsPerSymbol);
  90ad33:	022b02        	or	a11, a2, a2
  90ad36:	02aa08        	add	a10, a10, a2
  90ad39:	5b6f44        	call8	8e6a4c <__udivsi3>
		txTime = OFDM_PREAMBLE_TIME + (numSymbols * OFDM_SYMBOL_TIME);
  90ad3c:	0ea211        	slli	a2, a10, 2
		/* TODO: make sure the same value of txTime can use in all device */
		if (ath_hal_getcapability(ah, HAL_CAP_HT) != HAL_OK)
			txTime = txTime + OFDM_SIFS_TIME;
  90ad3f:	222c24        	addi	a2, a2, 36
		break;
	default:
		txTime = 0;
		break;
	}
	return txTime;
  90ad42:	02024f        	extui	a2, a2, 0, 16
}
  90ad45:	d10f      	retw.n
	...

0090ad48 <ath_hal_get_curmode>:
#undef OFDM_SYMBOL_TIME

#ifdef MAGPIE_MERLIN
a_uint32_t 
ath_hal_get_curmode(struct ath_hal *ah, HAL_CHANNEL_INTERNAL *chan)
{
  90ad48:	6c1004        	entry	a1, 32

	if (IS_CHAN_B(chan))
		return HAL_MODE_11B;

	HALASSERT(0);
	return HAL_MODE_11NG;
  90ad4b:	1269db        	l32r	a2, 8e54b8 <vdesc_module_install+0x4a8>

#ifdef MAGPIE_MERLIN
a_uint32_t 
ath_hal_get_curmode(struct ath_hal *ah, HAL_CHANNEL_INTERNAL *chan)
{
	if (!chan)
  90ad4e:	643043        	beqz	a3, 90ad95 <ath_hal_get_curmode+0x4d>
		return HAL_MODE_11NG;

	if (IS_CHAN_NA(chan))
  90ad51:	8831      	l32i.n	a8, a3, 4
  90ad53:	1968e5        	l32r	a9, 8e50e8 <vdesc_module_install+0xd8>
		return HAL_MODE_11NA; 
  90ad56:	1269da        	l32r	a2, 8e54c0 <vdesc_module_install+0x4b0>
ath_hal_get_curmode(struct ath_hal *ah, HAL_CHANNEL_INTERNAL *chan)
{
	if (!chan)
		return HAL_MODE_11NG;

	if (IS_CHAN_NA(chan))
  90ad59:	098301        	and	a3, a8, a9
  90ad5c:	793135        	beq	a3, a9, 90ad95 <ath_hal_get_curmode+0x4d>
		return HAL_MODE_11NA; 

	if (IS_CHAN_A(chan))
  90ad5f:	291a40        	movi	a9, 0x140
  90ad62:	098301        	and	a3, a8, a9
		return HAL_MODE_11A;
  90ad65:	c021      	movi.n	a2, 1
		return HAL_MODE_11NG;

	if (IS_CHAN_NA(chan))
		return HAL_MODE_11NA; 

	if (IS_CHAN_A(chan))
  90ad67:	79312a        	beq	a3, a9, 90ad95 <ath_hal_get_curmode+0x4d>
		return HAL_MODE_11A;

	if (IS_CHAN_NG(chan))
  90ad6a:	196a4b        	l32r	a9, 8e5698 <vdesc_module_install+0x688>

	if (IS_CHAN_B(chan))
		return HAL_MODE_11B;

	HALASSERT(0);
	return HAL_MODE_11NG;
  90ad6d:	1269db        	l32r	a2, 8e54dc <vdesc_module_install+0x4cc>
		return HAL_MODE_11NA; 

	if (IS_CHAN_A(chan))
		return HAL_MODE_11A;

	if (IS_CHAN_NG(chan))
  90ad70:	098301        	and	a3, a8, a9
  90ad73:	79311e        	beq	a3, a9, 90ad95 <ath_hal_get_curmode+0x4d>
		return HAL_MODE_11NG;

	if (IS_CHAN_G(chan))
  90ad76:	290ad0        	movi	a9, 208
  90ad79:	098901        	and	a9, a8, a9
  90ad7c:	230ac0        	movi	a3, 192
		return HAL_MODE_11G;
  90ad7f:	c028      	movi.n	a2, 8
		return HAL_MODE_11A;

	if (IS_CHAN_NG(chan))
		return HAL_MODE_11NG;

	if (IS_CHAN_G(chan))
  90ad81:	739110        	beq	a9, a3, 90ad95 <ath_hal_get_curmode+0x4d>
		return HAL_MODE_11G;

	if (IS_CHAN_B(chan))
  90ad84:	220aa0        	movi	a2, 160
  90ad87:	028801        	and	a8, a8, a2
		return HAL_MODE_11B;
  90ad8a:	1369db        	l32r	a3, 8e54f8 <vdesc_module_install+0x4e8>
  90ad8d:	02880c        	sub	a8, a8, a2
  90ad90:	c024      	movi.n	a2, 4
  90ad92:	083239        	movnez	a2, a3, a8

	HALASSERT(0);
	return HAL_MODE_11NG;
}
  90ad95:	d10f      	retw.n
	...

0090ad98 <ath_hal_wait>:

#endif

HAL_BOOL
ath_hal_wait(struct ath_hal *ah, a_uint32_t reg, a_uint32_t mask, a_uint32_t val)
{
  90ad98:	6c1004        	entry	a1, 32
				return AH_TRUE;
			OS_DELAY(10);
		}
	} else {
		for (i = 0; i < AH_TIMEOUT_11G; i++) {
			if ((ioread32_mac(reg) & mask) == val)
  90ad9b:	1869ab        	l32r	a8, 8e5448 <vdesc_module_install+0x438>

#endif

HAL_BOOL
ath_hal_wait(struct ath_hal *ah, a_uint32_t reg, a_uint32_t mask, a_uint32_t val)
{
  90ad9e:	223ae8        	movi	a2, 0x3e8
				return AH_TRUE;
			OS_DELAY(10);
		}
	} else {
		for (i = 0; i < AH_TIMEOUT_11G; i++) {
			if ((ioread32_mac(reg) & mask) == val)
  90ada1:	083308        	add	a3, a3, a8
  90ada4:	0c0200        	memw
  90ada7:	8830      	l32i.n	a8, a3, 0
  90ada9:	084801        	and	a8, a4, a8
  90adac:	78510d        	beq	a5, a8, 90adbd <ath_hal_wait+0x25>
				return AH_TRUE;
			OS_DELAY(10);
  90adaf:	2a0a0a        	movi	a10, 10
  90adb2:	222cff        	addi	a2, a2, -1
  90adb5:	5bf33c        	call8	907aa8 <ath_hal_delay>
			if ((ioread32_mac(reg) & mask) == val)
				return AH_TRUE;
			OS_DELAY(10);
		}
	} else {
		for (i = 0; i < AH_TIMEOUT_11G; i++) {
  90adb8:	652fe8        	bnez	a2, 90ada4 <ath_hal_wait+0xc>
  90adbb:	d10f      	retw.n
			if ((ioread32_mac(reg) & mask) == val)
				return AH_TRUE;
  90adbd:	c021      	movi.n	a2, 1
	}
	return AH_FALSE;

#undef AH_TIMEOUT_11N
#undef AH_TIMEOUT_11G
}
  90adbf:	d10f      	retw.n
  90adc1:	000000        	ill

0090adc4 <ar5416IsInterruptPending>:
/**********************/
/* Interrupt Handling */
/**********************/

HAL_BOOL ar5416IsInterruptPending(struct ath_hal *ah)
{
  90adc4:	6c1004        	entry	a1, 32
  90adc7:	126a4c        	l32r	a2, 8e56f8 <vdesc_module_install+0x6e8>
  90adca:	0c0200        	memw
  90adcd:	8820      	l32i.n	a8, a2, 0
		ioread32_mac(AR_INTR_ASYNC_CAUSE);
	/*
	 * Some platforms trigger our ISR before applying power to
	 * the card, so make sure.
	 */
	return ((host_isr != AR_INTR_SPURIOUS) && (host_isr & AR_INTR_MAC_IRQ));
  90adcf:	c020      	movi.n	a2, 0
  90add1:	081940        	extui	a9, a8, 1, 1
  90add4:	b188      	addi.n	a8, a8, 1
  90add6:	089239        	movnez	a2, a9, a8
}
  90add9:	d10f      	retw.n
	...

0090addc <ar5416SetInterrupts>:
	return AH_TRUE;
}

HAL_INT
ar5416SetInterrupts(struct ath_hal *ah, HAL_INT ints)
{
  90addc:	6c1004        	entry	a1, 32
	struct ath_hal_5416 *ahp = AH5416(ah);
	a_uint32_t omask = ahp->ah_maskReg;
  90addf:	2b2236        	l32i	a11, a2, 216
	a_uint32_t mask;

	if (omask & HAL_INT_GLOBAL) {
  90ade2:	67b00e        	bgez	a11, 90adf4 <ar5416SetInterrupts+0x18>
  90ade5:	186a4d        	l32r	a8, 8e571c <vdesc_module_install+0x70c>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90ade8:	c090      	movi.n	a9, 0
  90adea:	0c0200        	memw
  90aded:	9980      	s32i.n	a9, a8, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90adef:	0c0200        	memw
  90adf2:	8880      	l32i.n	a8, a8, 0
		iowrite32_mac(AR_IER, AR_IER_DISABLE);
		(void) ioread32_mac(AR_IER);
	}

	mask = ints & HAL_INT_COMMON;
  90adf4:	186a4e        	l32r	a8, 8e572c <vdesc_module_install+0x71c>
#else
		mask |= AR_IMR_TXOK;
		mask |= AR_IMR_TXDESC;
#endif
		mask |= AR_IMR_TXERR;
		mask |= AR_IMR_TXEOL;
  90adf7:	295ac0        	movi	a9, 0x5c0
	if (omask & HAL_INT_GLOBAL) {
		iowrite32_mac(AR_IER, AR_IER_DISABLE);
		(void) ioread32_mac(AR_IER);
	}

	mask = ints & HAL_INT_COMMON;
  90adfa:	083801        	and	a8, a3, a8
	if (ints & HAL_INT_TX) {
  90adfd:	036a40        	extui	a10, a3, 6, 1
#else
		mask |= AR_IMR_TXOK;
		mask |= AR_IMR_TXDESC;
#endif
		mask |= AR_IMR_TXERR;
		mask |= AR_IMR_TXEOL;
  90ae00:	098902        	or	a9, a8, a9
  90ae03:	0a9839        	movnez	a8, a9, a10
	if (ints & HAL_INT_RX) {
		mask |= AR_IMR_RXERR;
#ifdef AR5416_INT_MITIGATION
		mask |=  AR_IMR_RXMINTR | AR_IMR_RXINTM;
#else
		mask |= AR_IMR_RXOK | AR_IMR_RXDESC;
  90ae06:	c097      	movi.n	a9, 7
  90ae08:	098902        	or	a9, a8, a9
		mask |= AR_IMR_TXDESC;
#endif
		mask |= AR_IMR_TXERR;
		mask |= AR_IMR_TXEOL;
	}
	if (ints & HAL_INT_RX) {
  90ae0b:	030a40        	extui	a10, a3, 0, 1
		mask |= AR_IMR_RXERR;
#ifdef AR5416_INT_MITIGATION
		mask |=  AR_IMR_RXMINTR | AR_IMR_RXINTM;
#else
		mask |= AR_IMR_RXOK | AR_IMR_RXDESC;
  90ae0e:	0a9839        	movnez	a8, a9, a10
#endif
	}

	if (ints & (HAL_INT_GTT | HAL_INT_CST)) {
  90ae11:	196a4f        	l32r	a9, 8e5750 <vdesc_module_install+0x740>
  90ae14:	793005        	bnone	a3, a9, 90ae1d <ar5416SetInterrupts+0x41>
		mask |= AR_IMR_BCNMISC;
  90ae17:	196a50        	l32r	a9, 8e5758 <vdesc_module_install+0x748>
  90ae1a:	098802        	or	a8, a8, a9
  90ae1d:	196a51        	l32r	a9, 8e5764 <vdesc_module_install+0x754>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90ae20:	0c0200        	memw
  90ae23:	9890      	s32i.n	a8, a9, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90ae25:	0c0200        	memw
  90ae28:	8890      	l32i.n	a8, a9, 0
	}

	iowrite32_mac(AR_IMR, mask);
	(void) ioread32_mac(AR_IMR);
	ahp->ah_maskReg = ints;
  90ae2a:	232636        	s32i	a3, a2, 216

	/* Re-enable interrupts if they were enabled before. */
	if (ints & HAL_INT_GLOBAL) {
  90ae2d:	67300f        	bgez	a3, 90ae40 <ar5416SetInterrupts+0x64>
  90ae30:	136a4d        	l32r	a3, 8e5764 <vdesc_module_install+0x754>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90ae33:	c021      	movi.n	a2, 1
  90ae35:	0c0200        	memw
  90ae38:	9230      	s32i.n	a2, a3, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90ae3a:	0c0200        	memw
  90ae3d:	223200        	l32i	a2, a3, 0
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90ae40:	126a52        	l32r	a2, 8e5788 <vdesc_module_install+0x778>
  90ae43:	c032      	movi.n	a3, 2
  90ae45:	0c0200        	memw
  90ae48:	9320      	s32i.n	a3, a2, 0
  90ae4a:	126a53        	l32r	a2, 8e5798 <vdesc_module_install+0x788>
  90ae4d:	0c0200        	memw
  90ae50:	9320      	s32i.n	a3, a2, 0
  90ae52:	126a54        	l32r	a2, 8e57a4 <vdesc_module_install+0x794>
  90ae55:	136a55        	l32r	a3, 8e57ac <vdesc_module_install+0x79c>
  90ae58:	0c0200        	memw
  90ae5b:	9320      	s32i.n	a3, a2, 0
	iowrite32_mac(AR_INTR_ASYNC_ENABLE, AR_INTR_MAC_IRQ);
	iowrite32_mac(AR_INTR_ASYNC_MASK, AR_INTR_MAC_IRQ);
	iowrite32_mac(AR_INTR_SYNC_ENABLE, AR_INTR_SYNC_ALL);

	return omask;
}
  90ae5d:	d2b0      	mov.n	a2, a11
  90ae5f:	d10f      	retw.n
  90ae61:	000000        	ill

0090ae64 <ar5416GetTsf64>:
/****************/

#define ATH9K_HTC_MAX_TSF_READ 3

u_int64_t ar5416GetTsf64(struct ath_hal *ah)
{
  90ae64:	6c1004        	entry	a1, 32
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90ae67:	186a56        	l32r	a8, 8e57c0 <vdesc_module_install+0x7b0>
  90ae6a:	1b6a57        	l32r	a11, 8e57c8 <vdesc_module_install+0x7b8>
  90ae6d:	0c0200        	memw
  90ae70:	8a80      	l32i.n	a10, a8, 0
  90ae72:	c093      	movi.n	a9, 3
  90ae74:	0c0200        	memw
  90ae77:	83b0      	l32i.n	a3, a11, 0
  90ae79:	0c0200        	memw
  90ae7c:	8280      	l32i.n	a2, a8, 0

	tsf_upper1 = ioread32_mac(AR_TSF_U32);
	for (i = 0; i < ATH9K_HTC_MAX_TSF_READ; i++) {
		tsf_lower = ioread32_mac(AR_TSF_L32);
		tsf_upper2 = ioread32_mac(AR_TSF_U32);
		if (tsf_upper2 == tsf_upper1)
  90ae7e:	7a2106        	beq	a2, a10, 90ae88 <ar5416GetTsf64+0x24>
  90ae81:	b099      	addi.n	a9, a9, -1
  90ae83:	da20      	mov.n	a10, a2
{
	a_uint32_t tsf_lower, tsf_upper1, tsf_upper2;
	a_int32_t i;

	tsf_upper1 = ioread32_mac(AR_TSF_U32);
	for (i = 0; i < ATH9K_HTC_MAX_TSF_READ; i++) {
  90ae85:	659feb        	bnez	a9, 90ae74 <ar5416GetTsf64+0x10>
			break;
		tsf_upper1 = tsf_upper2;
	}

	return (((u_int64_t)tsf_upper2 << 32) | tsf_lower);
}
  90ae88:	d10f      	retw.n
	...

0090ae8c <ar5416SetRxDP>:

/******/
/* RX */
/******/
void ar5416SetRxDP(struct ath_hal *ah, a_uint32_t rxdp)
{
  90ae8c:	6c1004        	entry	a1, 32
  90ae8f:	186a58        	l32r	a8, 8e57f0 <vdesc_module_install+0x7e0>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90ae92:	0c0200        	memw
  90ae95:	9380      	s32i.n	a3, a8, 0
  90ae97:	d10f      	retw.n
  90ae99:	000000        	ill

0090ae9c <ar5416EnableReceive>:
			     & ~AR_RXCFG_ZLFDMA);
	}
}

void ar5416EnableReceive(struct ath_hal *ah)
{
  90ae9c:	6c1004        	entry	a1, 32
  90ae9f:	186a59        	l32r	a8, 8e5804 <vdesc_module_install+0x7f4>
  90aea2:	c094      	movi.n	a9, 4
  90aea4:	0c0200        	memw
  90aea7:	9980      	s32i.n	a9, a8, 0
  90aea9:	d10f      	retw.n
	...

0090aeac <ar5416StopPcuReceive>:
	iowrite32_mac(AR_CR, AR_CR_RXE);
}

void ar5416StopPcuReceive(struct ath_hal *ah)
{
  90aeac:	6c1004        	entry	a1, 32
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90aeaf:	196a5a        	l32r	a9, 8e5818 <vdesc_module_install+0x808>
	OS_REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_RX_DIS);
  90aeb2:	c2a0      	movi.n	a10, 32
  90aeb4:	0c0200        	memw
  90aeb7:	8890      	l32i.n	a8, a9, 0
  90aeb9:	0a8802        	or	a8, a8, a10
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90aebc:	0c0200        	memw
  90aebf:	9890      	s32i.n	a8, a9, 0
  90aec1:	d10f      	retw.n
	...

0090aec4 <ar5416SetupRxDesc_20>:
}

HAL_BOOL ar5416SetupRxDesc_20(struct ath_rx_desc *ds,
			      a_uint32_t size, a_uint32_t flags)
{
  90aec4:	6c1004        	entry	a1, 32
	struct ar5416_desc *ads = AR5416DESC(ds);

	HALASSERT((size &~ AR_BufLen) == 0);

	ads->ds_ctl1 = size & AR_BufLen;
  90aec7:	03084b        	extui	a8, a3, 0, 12
	if (flags & HAL_RXDESC_INTREQ)
  90aeca:	7a4f16        	bbsi	a4, 26, 90aee4 <ar5416SetupRxDesc_20+0x20>
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	HALASSERT((size &~ AR_BufLen) == 0);

	ads->ds_ctl1 = size & AR_BufLen;
  90aecd:	088957        	extui	a9, a8, 24, 8
  90aed0:	29240c        	s8i	a9, a2, 12
  90aed3:	088814        	srli	a8, a8, 8
  90aed6:	c090      	movi.n	a9, 0
  90aed8:	29240d        	s8i	a9, a2, 13
  90aedb:	28240e        	s8i	a8, a2, 14
  90aede:	23240f        	s8i	a3, a2, 15
  90aee1:	60001a        	j	90aeff <ar5416SetupRxDesc_20+0x3b>
	if (flags & HAL_RXDESC_INTREQ)
		ads->ds_ctl1 |= AR_RxIntrReq;
  90aee4:	1369aa        	l32r	a3, 8e558c <vdesc_module_install+0x57c>
  90aee7:	038802        	or	a8, a8, a3
  90aeea:	088357        	extui	a3, a8, 24, 8
  90aeed:	23240c        	s8i	a3, a2, 12
  90aef0:	080357        	extui	a3, a8, 16, 8
  90aef3:	23240d        	s8i	a3, a2, 13
  90aef6:	088347        	extui	a3, a8, 8, 8
  90aef9:	23240e        	s8i	a3, a2, 14
  90aefc:	28240f        	s8i	a8, a2, 15

	/* this should be enough */
	ads->ds_rxstatus8 &= ~AR_RxDone;
  90aeff:	292030        	l8ui	a9, a2, 48
  90af02:	c73e      	movi.n	a3, -2
  90af04:	089810        	slli	a8, a9, 24
  90af07:	292031        	l8ui	a9, a2, 49
  90af0a:	009911        	slli	a9, a9, 16
  90af0d:	089902        	or	a9, a9, a8
  90af10:	282032        	l8ui	a8, a2, 50
  90af13:	088811        	slli	a8, a8, 8
  90af16:	098902        	or	a9, a8, a9
  90af19:	282033        	l8ui	a8, a2, 51
  90af1c:	098802        	or	a8, a8, a9
  90af1f:	038801        	and	a8, a8, a3
  90af22:	088357        	extui	a3, a8, 24, 8
  90af25:	232430        	s8i	a3, a2, 48
  90af28:	080357        	extui	a3, a8, 16, 8
  90af2b:	232431        	s8i	a3, a2, 49
  90af2e:	088347        	extui	a3, a8, 8, 8
  90af31:	232432        	s8i	a3, a2, 50
  90af34:	282433        	s8i	a8, a2, 51

	return AH_TRUE;
}
  90af37:	c021      	movi.n	a2, 1
  90af39:	d10f      	retw.n
	...

0090af3c <ar5416ProcRxDescFast_20>:

HAL_STATUS ar5416ProcRxDescFast_20(struct ath_hal *ah, struct ath_rx_desc *ds,
				   a_uint32_t pa, struct ath_desc *nds,
				   struct ath_rx_status *rx_stats)
{
  90af3c:	6c1004        	entry	a1, 32
	struct ar5416_desc ads;
	struct ar5416_desc *adsp = AR5416DESC(ds);
	struct ar5416_desc *ands = AR5416DESC(nds);

	if ((adsp->ds_rxstatus8 & AR_RxDone) == 0)
  90af3f:	223030        	l8ui	a2, a3, 48
  90af42:	082810        	slli	a8, a2, 24
  90af45:	223031        	l8ui	a2, a3, 49
  90af48:	002211        	slli	a2, a2, 16
  90af4b:	082202        	or	a2, a2, a8
  90af4e:	283032        	l8ui	a8, a3, 50
  90af51:	088811        	slli	a8, a8, 8
  90af54:	028202        	or	a2, a8, a2
  90af57:	283033        	l8ui	a8, a3, 51
  90af5a:	028802        	or	a8, a8, a2
		return HAL_EINPROGRESS;
  90af5d:	c02f      	movi.n	a2, 15
{
	struct ar5416_desc ads;
	struct ar5416_desc *adsp = AR5416DESC(ds);
	struct ar5416_desc *ands = AR5416DESC(nds);

	if ((adsp->ds_rxstatus8 & AR_RxDone) == 0)
  90af5f:	7f8f02        	bbsi	a8, 31, 90af65 <ar5416ProcRxDescFast_20+0x29>
  90af62:	6001b0        	j	90b116 <ar5416ProcRxDescFast_20+0x1da>
	/*
	 * Given the use of a self-linked tail be very sure that the hw is
	 * done with this descriptor; the hw may have done this descriptor
	 * once and picked it up again...make sure the hw has moved on.
	 */
	if ((ands->ds_rxstatus8 & AR_RxDone) == 0
  90af65:	255033        	l8ui	a5, a5, 51
  90af68:	7f5f0d        	bbsi	a5, 31, 90af79 <ar5416ProcRxDescFast_20+0x3d>
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90af6b:	156a58        	l32r	a5, 8e58cc <vdesc_module_install+0x8bc>
  90af6e:	0c0200        	memw
  90af71:	8550      	l32i.n	a5, a5, 0
	    && ioread32_mac(AR_RXDP) == pa)
  90af73:	754902        	bne	a4, a5, 90af79 <ar5416ProcRxDescFast_20+0x3d>
  90af76:	60019c        	j	90b116 <ar5416ProcRxDescFast_20+0x1da>
	 * Next we fill in all values in a caller passed stack variable.
	 * This reduces the number of uncached accesses.
	 * Do this copy here, after the check so that when the checks fail, we
	 * dont end up copying the entire stats uselessly.
	 */
	ads.u.rx = adsp->u.rx;
  90af79:	223010        	l8ui	a2, a3, 16
  90af7c:	293018        	l8ui	a9, a3, 24
  90af7f:	082a10        	slli	a10, a2, 24
  90af82:	223011        	l8ui	a2, a3, 17
  90af85:	089910        	slli	a9, a9, 24
  90af88:	002211        	slli	a2, a2, 16
  90af8b:	0a2202        	or	a2, a2, a10
  90af8e:	2a3012        	l8ui	a10, a3, 18
  90af91:	2b301c        	l8ui	a11, a3, 28
  90af94:	08aa11        	slli	a10, a10, 8
  90af97:	02a202        	or	a2, a10, a2
  90af9a:	2a3013        	l8ui	a10, a3, 19
  90af9d:	08bb10        	slli	a11, a11, 24
  90afa0:	02aa02        	or	a10, a10, a2
  90afa3:	223014        	l8ui	a2, a3, 20
  90afa6:	2c3020        	l8ui	a12, a3, 32
  90afa9:	082e10        	slli	a14, a2, 24
  90afac:	223015        	l8ui	a2, a3, 21
  90afaf:	08cc10        	slli	a12, a12, 24
  90afb2:	002211        	slli	a2, a2, 16
  90afb5:	0e2202        	or	a2, a2, a14
  90afb8:	2e3016        	l8ui	a14, a3, 22
  90afbb:	2d3024        	l8ui	a13, a3, 36
  90afbe:	08ee11        	slli	a14, a14, 8
  90afc1:	02e202        	or	a2, a14, a2
  90afc4:	2e3017        	l8ui	a14, a3, 23
  90afc7:	08dd10        	slli	a13, a13, 24
  90afca:	02ee02        	or	a14, a14, a2
  90afcd:	223019        	l8ui	a2, a3, 25
  90afd0:	24301b        	l8ui	a4, a3, 27
  90afd3:	002211        	slli	a2, a2, 16
  90afd6:	092902        	or	a9, a2, a9
  90afd9:	22301a        	l8ui	a2, a3, 26
  90afdc:	2f3028        	l8ui	a15, a3, 40
  90afdf:	082211        	slli	a2, a2, 8
  90afe2:	092202        	or	a2, a2, a9
  90afe5:	29301d        	l8ui	a9, a3, 29
  90afe8:	024202        	or	a2, a4, a2
  90afeb:	009911        	slli	a9, a9, 16
  90afee:	0b9b02        	or	a11, a9, a11
  90aff1:	29301e        	l8ui	a9, a3, 30
  90aff4:	24301f        	l8ui	a4, a3, 31
  90aff7:	089911        	slli	a9, a9, 8
  90affa:	0b9902        	or	a9, a9, a11
  90affd:	2b3021        	l8ui	a11, a3, 33
  90b000:	08ff10        	slli	a15, a15, 24
  90b003:	00bb11        	slli	a11, a11, 16
  90b006:	0cbc02        	or	a12, a11, a12
  90b009:	2b3022        	l8ui	a11, a3, 34
  90b00c:	094902        	or	a9, a4, a9
  90b00f:	08bb11        	slli	a11, a11, 8
  90b012:	0cbb02        	or	a11, a11, a12
  90b015:	2c3025        	l8ui	a12, a3, 37
  90b018:	243023        	l8ui	a4, a3, 35
  90b01b:	00cc11        	slli	a12, a12, 16
  90b01e:	0dcd02        	or	a13, a12, a13
  90b021:	2c3026        	l8ui	a12, a3, 38
  90b024:	0b4b02        	or	a11, a4, a11
  90b027:	08cc11        	slli	a12, a12, 8
  90b02a:	0dcc02        	or	a12, a12, a13
  90b02d:	2d3029        	l8ui	a13, a3, 41
  90b030:	243027        	l8ui	a4, a3, 39
  90b033:	00dd11        	slli	a13, a13, 16
  90b036:	0fdf02        	or	a15, a13, a15
  90b039:	2d302a        	l8ui	a13, a3, 42
  90b03c:	23302b        	l8ui	a3, a3, 43
  90b03f:	08dd11        	slli	a13, a13, 8
  90b042:	0fdd02        	or	a13, a13, a15
  90b045:	0d3d02        	or	a13, a3, a13

	rx_stats->rs_status = 0;
  90b048:	c030      	movi.n	a3, 0
  90b04a:	23640a        	s8i	a3, a6, 10
	rx_stats->rs_flags = 0;
  90b04d:	23641a        	s8i	a3, a6, 26

	rx_stats->rs_datalen = ads.ds_rxstatus1 & AR_DataLen;
  90b050:	0e034b        	extui	a3, a14, 0, 12
	rx_stats->rs_tstamp =  ads.AR_RcvTimestamp;
  90b053:	9261      	s32i.n	a2, a6, 4
	ads.u.rx = adsp->u.rx;

	rx_stats->rs_status = 0;
	rx_stats->rs_flags = 0;

	rx_stats->rs_datalen = ads.ds_rxstatus1 & AR_DataLen;
  90b055:	236504        	s16i	a3, a6, 8
	rx_stats->rs_tstamp =  ads.AR_RcvTimestamp;
  90b058:	c020      	movi.n	a2, 0
  90b05a:	9260      	s32i.n	a2, a6, 0

	/* XXX what about KeyCacheMiss? */
	rx_stats->rs_rssi_combined = 
		MS(ads.ds_rxstatus4, AR_RxRSSICombined);
  90b05c:	0b8257        	extui	a2, a11, 24, 8

	rx_stats->rs_datalen = ads.ds_rxstatus1 & AR_DataLen;
	rx_stats->rs_tstamp =  ads.AR_RcvTimestamp;

	/* XXX what about KeyCacheMiss? */
	rx_stats->rs_rssi_combined = 
  90b05f:	22640c        	s8i	a2, a6, 12
		MS(ads.ds_rxstatus4, AR_RxRSSICombined);
	rx_stats->rs_rssi_ctl0 = MS(ads.ds_rxstatus0, AR_RxRSSIAnt00);
	rx_stats->rs_rssi_ctl1 = MS(ads.ds_rxstatus0, AR_RxRSSIAnt01);
  90b062:	0a8214        	srli	a2, a10, 8
  90b065:	22640e        	s8i	a2, a6, 14
	rx_stats->rs_rssi_ctl2 = MS(ads.ds_rxstatus0, AR_RxRSSIAnt02);
  90b068:	0a025f        	extui	a2, a10, 16, 16
  90b06b:	22640f        	s8i	a2, a6, 15
	rx_stats->rs_rssi_ext0 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt10);
	rx_stats->rs_rssi_ext1 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt11);
  90b06e:	0b8214        	srli	a2, a11, 8
  90b071:	226411        	s8i	a2, a6, 17
	rx_stats->rs_rssi_ext2 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt12);
  90b074:	0b025f        	extui	a2, a11, 16, 16
  90b077:	226412        	s8i	a2, a6, 18
	rx_stats->rs_tstamp =  ads.AR_RcvTimestamp;

	/* XXX what about KeyCacheMiss? */
	rx_stats->rs_rssi_combined = 
		MS(ads.ds_rxstatus4, AR_RxRSSICombined);
	rx_stats->rs_rssi_ctl0 = MS(ads.ds_rxstatus0, AR_RxRSSIAnt00);
  90b07a:	2a640d        	s8i	a10, a6, 13
	rx_stats->rs_rssi_ctl1 = MS(ads.ds_rxstatus0, AR_RxRSSIAnt01);
	rx_stats->rs_rssi_ctl2 = MS(ads.ds_rxstatus0, AR_RxRSSIAnt02);
	rx_stats->rs_rssi_ext0 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt10);
  90b07d:	2b6410        	s8i	a11, a6, 16
	 * Next we fill in all values in a caller passed stack variable.
	 * This reduces the number of uncached accesses.
	 * Do this copy here, after the check so that when the checks fail, we
	 * dont end up copying the entire stats uselessly.
	 */
	ads.u.rx = adsp->u.rx;
  90b080:	0c4c02        	or	a12, a4, a12
	rx_stats->rs_rssi_ctl2 = MS(ads.ds_rxstatus0, AR_RxRSSIAnt02);
	rx_stats->rs_rssi_ext0 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt10);
	rx_stats->rs_rssi_ext1 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt11);
	rx_stats->rs_rssi_ext2 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt12);
	if (ads.ds_rxstatus8 & AR_RxKeyIdxValid)
		rx_stats->rs_keyix = MS(ads.ds_rxstatus8, AR_KeyIdx);
  90b083:	089246        	extui	a2, a8, 9, 7
	rx_stats->rs_rssi_ctl1 = MS(ads.ds_rxstatus0, AR_RxRSSIAnt01);
	rx_stats->rs_rssi_ctl2 = MS(ads.ds_rxstatus0, AR_RxRSSIAnt02);
	rx_stats->rs_rssi_ext0 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt10);
	rx_stats->rs_rssi_ext1 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt11);
	rx_stats->rs_rssi_ext2 = MS(ads.ds_rxstatus4, AR_RxRSSIAnt12);
	if (ads.ds_rxstatus8 & AR_RxKeyIdxValid)
  90b086:	778f02        	bbsi	a8, 23, 90b08c <ar5416ProcRxDescFast_20+0x150>
		rx_stats->rs_keyix = MS(ads.ds_rxstatus8, AR_KeyIdx);
	else
		rx_stats->rs_keyix = HAL_RXKEYIX_INVALID;
  90b089:	22faff        	movi	a2, -1
  90b08c:	226413        	s8i	a2, a6, 19
	/* NB: caller expected to do rate table mapping */
	rx_stats->rs_rate = RXSTATUS_RATE(ah, (&ads));
	rx_stats->rs_more = (ads.ds_rxstatus1 & AR_RxMore) ? 1 : 0;

	rx_stats->rs_isaggr = (ads.ds_rxstatus8 & AR_RxAggr) ? 1 : 0;
  90b08f:	081250        	extui	a2, a8, 17, 1
	rx_stats->rs_moreaggr = (ads.ds_rxstatus8 & AR_RxMoreAggr) ? 1 : 0;
	rx_stats->rs_flags  |= (ads.ds_rxstatus3 & AR_GI) ? HAL_RX_GI : 0;
  90b092:	090340        	extui	a3, a9, 0, 1
	if (ads.ds_rxstatus8 & AR_RxKeyIdxValid)
		rx_stats->rs_keyix = MS(ads.ds_rxstatus8, AR_KeyIdx);
	else
		rx_stats->rs_keyix = HAL_RXKEYIX_INVALID;
	/* NB: caller expected to do rate table mapping */
	rx_stats->rs_rate = RXSTATUS_RATE(ah, (&ads));
  90b095:	0a8a57        	extui	a10, a10, 24, 8
	rx_stats->rs_more = (ads.ds_rxstatus1 & AR_RxMore) ? 1 : 0;
  90b098:	0ece40        	extui	a14, a14, 12, 1

	rx_stats->rs_isaggr = (ads.ds_rxstatus8 & AR_RxAggr) ? 1 : 0;
  90b09b:	226417        	s8i	a2, a6, 23
	rx_stats->rs_moreaggr = (ads.ds_rxstatus8 & AR_RxMoreAggr) ? 1 : 0;
	rx_stats->rs_flags  |= (ads.ds_rxstatus3 & AR_GI) ? HAL_RX_GI : 0;
	rx_stats->rs_flags  |= (ads.ds_rxstatus3 & AR_2040) ? HAL_RX_2040 : 0;
  90b09e:	091940        	extui	a9, a9, 1, 1
	/* NB: caller expected to do rate table mapping */
	rx_stats->rs_rate = RXSTATUS_RATE(ah, (&ads));
	rx_stats->rs_more = (ads.ds_rxstatus1 & AR_RxMore) ? 1 : 0;

	rx_stats->rs_isaggr = (ads.ds_rxstatus8 & AR_RxAggr) ? 1 : 0;
	rx_stats->rs_moreaggr = (ads.ds_rxstatus8 & AR_RxMoreAggr) ? 1 : 0;
  90b0a1:	080250        	extui	a2, a8, 16, 1
	rx_stats->rs_flags  |= (ads.ds_rxstatus3 & AR_GI) ? HAL_RX_GI : 0;
  90b0a4:	0e3311        	slli	a3, a3, 2
	rx_stats->rs_flags  |= (ads.ds_rxstatus3 & AR_2040) ? HAL_RX_2040 : 0;
  90b0a7:	0d9911        	slli	a9, a9, 3
	if (ads.ds_rxstatus8 & AR_RxKeyIdxValid)
		rx_stats->rs_keyix = MS(ads.ds_rxstatus8, AR_KeyIdx);
	else
		rx_stats->rs_keyix = HAL_RXKEYIX_INVALID;
	/* NB: caller expected to do rate table mapping */
	rx_stats->rs_rate = RXSTATUS_RATE(ah, (&ads));
  90b0aa:	2a6414        	s8i	a10, a6, 20
	rx_stats->rs_more = (ads.ds_rxstatus1 & AR_RxMore) ? 1 : 0;
  90b0ad:	2e6416        	s8i	a14, a6, 22

	rx_stats->rs_isaggr = (ads.ds_rxstatus8 & AR_RxAggr) ? 1 : 0;
	rx_stats->rs_moreaggr = (ads.ds_rxstatus8 & AR_RxMoreAggr) ? 1 : 0;
  90b0b0:	226418        	s8i	a2, a6, 24
	rx_stats->rs_flags  |= (ads.ds_rxstatus3 & AR_GI) ? HAL_RX_GI : 0;
	rx_stats->rs_flags  |= (ads.ds_rxstatus3 & AR_2040) ? HAL_RX_2040 : 0;
  90b0b3:	093302        	or	a3, a3, a9

	if (ads.ds_rxstatus8 & AR_PreDelimCRCErr)
  90b0b6:	798f04        	bbsi	a8, 25, 90b0be <ar5416ProcRxDescFast_20+0x182>
  90b0b9:	600006        	j	90b0c3 <ar5416ProcRxDescFast_20+0x187>
  90b0bc:	0000c1        	excw
		rx_stats->rs_flags |= HAL_RX_DELIM_CRC_PRE;
  90b0bf:	200233        	l32i	a0, a0, 204
  90b0c2:	022364        	excw
  90b0c5:	1a7d86        	l32r	a10, 8ea6e0 <memset+0x3898>
	if (ads.ds_rxstatus8 & AR_PostDelimCRCErr)
  90b0c8:	0a2260        	excw
		rx_stats->rs_flags |= HAL_RX_DELIM_CRC_POST;
  90b0cb:	1ac230        	l32r	a10, 8fb98c <memset+0x14b44>
  90b0ce:	032202        	or	a2, a2, a3
  90b0d1:	22641a        	s8i	a2, a6, 26
	if (ads.ds_rxstatus8 & AR_DecryptBusyErr)
  90b0d4:	71860a        	bbci	a8, 1, 90b0e2 <ar5416ProcRxDescFast_20+0x1a6>
		rx_stats->rs_flags |= HAL_RX_DECRYPT_BUSY;
  90b0d7:	22601a        	l8ui	a2, a6, 26
  90b0da:	c430      	movi.n	a3, 64
  90b0dc:	032202        	or	a2, a2, a3
  90b0df:	22641a        	s8i	a2, a6, 26

	if ((ads.ds_rxstatus8 & AR_RxFrameOK) == 0) {
  90b0e2:	c032      	movi.n	a3, 2
  90b0e4:	738826        	bany	a8, a3, 90b10e <ar5416ProcRxDescFast_20+0x1d2>
		 * when a CRC error is detected, but these are specious.
		 * Consequently we filter them out here so we don't
		 * confuse and/or complicate drivers.
		 */
		if (ads.ds_rxstatus8 & AR_CRCErr)
			rx_stats->rs_status |= HAL_RXERR_CRC;
  90b0e7:	c021      	movi.n	a2, 1
		 * indicates however that you can also get Michael errors
		 * when a CRC error is detected, but these are specious.
		 * Consequently we filter them out here so we don't
		 * confuse and/or complicate drivers.
		 */
		if (ads.ds_rxstatus8 & AR_CRCErr)
  90b0e9:	7d8f1e        	bbsi	a8, 29, 90b10b <ar5416ProcRxDescFast_20+0x1cf>
			rx_stats->rs_status |= HAL_RXERR_CRC;
		else if (ads.ds_rxstatus8 & AR_PHYErr) {
  90b0ec:	c120      	movi.n	a2, 16
  90b0ee:	72800b        	bnone	a8, a2, 90b0fd <ar5416ProcRxDescFast_20+0x1c1>
			a_uint32_t phyerr;

			rx_stats->rs_status |= HAL_RXERR_PHY;
			phyerr = MS(ads.ds_rxstatus8, AR_PHYErrCode);
  90b0f1:	088814        	srli	a8, a8, 8
		if (ads.ds_rxstatus8 & AR_CRCErr)
			rx_stats->rs_status |= HAL_RXERR_CRC;
		else if (ads.ds_rxstatus8 & AR_PHYErr) {
			a_uint32_t phyerr;

			rx_stats->rs_status |= HAL_RXERR_PHY;
  90b0f4:	23640a        	s8i	a3, a6, 10
			phyerr = MS(ads.ds_rxstatus8, AR_PHYErrCode);
			rx_stats->rs_phyerr = phyerr;
  90b0f7:	28640b        	s8i	a8, a6, 11
  90b0fa:	600010        	j	90b10e <ar5416ProcRxDescFast_20+0x1d2>
		} else if (ads.ds_rxstatus8 & AR_DecryptCRCErr)
  90b0fd:	c038      	movi.n	a3, 8
  90b0ff:	738005        	bnone	a8, a3, 90b108 <ar5416ProcRxDescFast_20+0x1cc>
			rx_stats->rs_status |= HAL_RXERR_DECRYPT;
  90b102:	23640a        	s8i	a3, a6, 10
  90b105:	600005        	j	90b10e <ar5416ProcRxDescFast_20+0x1d2>
		else if (ads.ds_rxstatus8 & AR_MichaelErr)
  90b108:	7a8702        	bbci	a8, 26, 90b10e <ar5416ProcRxDescFast_20+0x1d2>
			rx_stats->rs_status |= HAL_RXERR_MIC;
  90b10b:	22640a        	s8i	a2, a6, 10
	}
	rx_stats->evm0=ads.AR_RxEVM0;
  90b10e:	9b67      	s32i.n	a11, a6, 28
	rx_stats->evm1=ads.AR_RxEVM1;
  90b110:	9c68      	s32i.n	a12, a6, 32
	rx_stats->evm2=ads.AR_RxEVM2;
  90b112:	9d69      	s32i.n	a13, a6, 36

	return HAL_OK;
  90b114:	c020      	movi.n	a2, 0
}
  90b116:	d10f      	retw.n

0090b118 <ar5416UpdateTxTrigLevel>:
/******/
/* TX */
/******/

HAL_BOOL ar5416UpdateTxTrigLevel(struct ath_hal *ah, HAL_BOOL bIncTrigLevel)
{
  90b118:	6c1004        	entry	a1, 32
        HAL_INT omask;

        /*
         * Disable interrupts while futzing with the fifo level.
         */
        omask = ar5416SetInterrupts(ah, ahp->ah_maskReg &~ HAL_INT_GLOBAL);
  90b11b:	146a5b        	l32r	a4, 8e5a88 <vdesc_module_install+0xa78>
  90b11e:	2b2236        	l32i	a11, a2, 216
  90b121:	da20      	mov.n	a10, a2
  90b123:	04bb01        	and	a11, a11, a4
  90b126:	5bff2d        	call8	90addc <ar5416SetInterrupts>
  90b129:	146a5c        	l32r	a4, 8e5a9c <vdesc_module_install+0xa8c>
  90b12c:	0c0200        	memw
  90b12f:	8940      	l32i.n	a9, a4, 0

	txcfg = ioread32_mac(AR_TXCFG);
        curLevel = MS(txcfg, AR_FTRIG);
  90b131:	094445        	extui	a4, a9, 4, 6
        newLevel = curLevel;

        if (bIncTrigLevel)  {
  90b134:	c83a      	beqz.n	a3, 90b142 <ar5416UpdateTxTrigLevel+0x2a>
		if (curLevel < MAX_TX_FIFO_THRESHOLD)
  90b136:	c38f      	movi.n	a8, 63
  90b138:	d340      	mov.n	a3, a4
  90b13a:	784128        	beq	a4, a8, 90b166 <ar5416UpdateTxTrigLevel+0x4e>
			newLevel ++;
  90b13d:	b143      	addi.n	a3, a4, 1
  90b13f:	600006        	j	90b149 <ar5416UpdateTxTrigLevel+0x31>
  90b142:	d340      	mov.n	a3, a4
        } else if (curLevel > MIN_TX_FIFO_THRESHOLD)
  90b144:	6e421e        	bltui	a4, 2, 90b166 <ar5416UpdateTxTrigLevel+0x4e>
                newLevel--;
  90b147:	b043      	addi.n	a3, a4, -1
        if (newLevel != curLevel)
  90b149:	743119        	beq	a3, a4, 90b166 <ar5416UpdateTxTrigLevel+0x4e>
		iowrite32_mac(AR_TXCFG,
  90b14c:	2b3af0        	movi	a11, 0x3f0
  90b14f:	0c3811        	slli	a8, a3, 4
  90b152:	0b8801        	and	a8, a8, a11
  90b155:	2bca0f        	movi	a11, 0xfffffc0f
  90b158:	0b9901        	and	a9, a9, a11
  90b15b:	098802        	or	a8, a8, a9
  90b15e:	196a5c        	l32r	a9, 8e5ad0 <vdesc_module_install+0xac0>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90b161:	0c0200        	memw
  90b164:	9890      	s32i.n	a8, a9, 0
			     (txcfg & ~AR_FTRIG) | SM(newLevel, AR_FTRIG));

        /* re-enable chip interrupts */
        ar5416SetInterrupts(ah, omask);
  90b166:	dba0      	mov.n	a11, a10
  90b168:	da20      	mov.n	a10, a2

        return (newLevel != curLevel);
  90b16a:	03440c        	sub	a4, a4, a3
        if (newLevel != curLevel)
		iowrite32_mac(AR_TXCFG,
			     (txcfg & ~AR_FTRIG) | SM(newLevel, AR_FTRIG));

        /* re-enable chip interrupts */
        ar5416SetInterrupts(ah, omask);
  90b16d:	5bff1b        	call8	90addc <ar5416SetInterrupts>

        return (newLevel != curLevel);
  90b170:	c031      	movi.n	a3, 1
  90b172:	c020      	movi.n	a2, 0
  90b174:	043239        	movnez	a2, a3, a4
}
  90b177:	d10f      	retw.n
  90b179:	000000        	ill

0090b17c <ar5416SetTxDP>:

HAL_BOOL ar5416SetTxDP(struct ath_hal *ah, a_uint32_t q, a_uint32_t txdp)
{
  90b17c:	6c1004        	entry	a1, 32
         * Make sure that TXE is deasserted before setting the TXDP.  If TXE
         * is still asserted, setting TXDP will have no effect.
         */
	HALASSERT((ioread32_mac(AR_Q_TXE) & (1 << q)) == 0);

	iowrite32_mac(AR_QTXDP(q), txdp);
  90b17f:	186a5d        	l32r	a8, 8e5af4 <vdesc_module_install+0xae4>
  90b182:	0e3311        	slli	a3, a3, 2
  90b185:	a833      	add.n	a3, a3, a8
  90b187:	0c0200        	memw
  90b18a:	9430      	s32i.n	a4, a3, 0

        return AH_TRUE;
}
  90b18c:	c021      	movi.n	a2, 1
  90b18e:	d10f      	retw.n

0090b190 <ar5416StartTxDma>:

HAL_BOOL ar5416StartTxDma(struct ath_hal *ah, a_uint32_t q)
{
  90b190:	6c1004        	entry	a1, 32
        HALASSERT(AH5416(ah)->ah_txq[q].tqi_type != HAL_TX_QUEUE_INACTIVE);

        /* Check to be sure we're not enabling a q that has its TXD bit set. */
	HALASSERT((ioread32_mac(AR_Q_TXD) & (1 << q)) == 0);

	iowrite32_mac(AR_Q_TXE, 1 << q);
  90b193:	c021      	movi.n	a2, 1
  90b195:	186a5e        	l32r	a8, 8e5b10 <vdesc_module_install+0xb00>
  90b198:	003104        	ssl	a3
  90b19b:	00231a        	sll	a3, a2
  90b19e:	0c0200        	memw
  90b1a1:	9380      	s32i.n	a3, a8, 0

        return AH_TRUE;
}
  90b1a3:	d10f      	retw.n
  90b1a5:	000000        	ill

0090b1a8 <ar5416NumTxPending>:

a_uint32_t ar5416NumTxPending(struct ath_hal *ah, a_uint32_t q)
{
  90b1a8:	6c1004        	entry	a1, 32
        a_uint32_t npend;

        HALASSERT(q < AH_PRIVATE(ah)->ah_caps.halTotalQueues);
        HALASSERT(AH5416(ah)->ah_txq[q].tqi_type != HAL_TX_QUEUE_INACTIVE);

	npend = ioread32_mac(AR_QSTS(q))
  90b1ab:	186a5f        	l32r	a8, 8e5b28 <vdesc_module_install+0xb18>
  90b1ae:	0e3211        	slli	a2, a3, 2
  90b1b1:	a822      	add.n	a2, a2, a8
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90b1b3:	0c0200        	memw
  90b1b6:	8220      	l32i.n	a2, a2, 0
  90b1b8:	020241        	extui	a2, a2, 0, 2
		& AR_Q_STS_PEND_FR_CNT;
        if (npend == 0) {
  90b1bb:	cd25      	bnez.n	a2, 90b1d4 <ar5416NumTxPending+0x2c>
  90b1bd:	186a5e        	l32r	a8, 8e5b38 <vdesc_module_install+0xb28>
  90b1c0:	0c0200        	memw
  90b1c3:	8980      	l32i.n	a9, a8, 0
                /*
                 * Pending frame count (PFC) can momentarily go to zero
                 * while TXE remains asserted.  In other words a PFC of
                 * zero is not sufficient to say that the queue has stopped.
                 */
		if (ioread32_mac(AR_Q_TXE) & (1 << q))
  90b1c5:	280a01        	movi	a8, 1
  90b1c8:	003104        	ssl	a3
  90b1cb:	00831a        	sll	a3, a8
  90b1ce:	093301        	and	a3, a3, a9
  90b1d1:	038239        	movnez	a2, a8, a3
			iowrite32_mac(AR_Q_RDYTIMESHDN, 1 << q);
                }
        }
#endif
        return npend;
}
  90b1d4:	d10f      	retw.n
	...

0090b1d8 <ar5416SetupTxDesc_20>:
			      a_uint32_t txRate0, a_uint32_t txTries0,
			      a_uint32_t keyIx,
			      a_uint32_t flags,
			      a_uint32_t rtsctsRate,
			      a_uint32_t rtsctsDuration)
{
  90b1d8:	6c1004        	entry	a1, 32

        struct ar5416_desc *ads = AR5416DESC(ds);

        (void) hdrLen;

        ads->ds_txstatus9 &= ~AR_TxDone;
  90b1db:	29205c        	l8ui	a9, a2, 92
			      a_uint32_t txRate0, a_uint32_t txTries0,
			      a_uint32_t keyIx,
			      a_uint32_t flags,
			      a_uint32_t rtsctsRate,
			      a_uint32_t rtsctsDuration)
{
  90b1de:	d820      	mov.n	a8, a2

        struct ar5416_desc *ads = AR5416DESC(ds);

        (void) hdrLen;

        ads->ds_txstatus9 &= ~AR_TxDone;
  90b1e0:	089210        	slli	a2, a9, 24
  90b1e3:	29805d        	l8ui	a9, a8, 93
			      a_uint32_t txRate0, a_uint32_t txTries0,
			      a_uint32_t keyIx,
			      a_uint32_t flags,
			      a_uint32_t rtsctsRate,
			      a_uint32_t rtsctsDuration)
{
  90b1e6:	8a1a      	l32i.n	a10, a1, 40

        struct ar5416_desc *ads = AR5416DESC(ds);

        (void) hdrLen;

        ads->ds_txstatus9 &= ~AR_TxDone;
  90b1e8:	009911        	slli	a9, a9, 16
  90b1eb:	029902        	or	a9, a9, a2
  90b1ee:	22805e        	l8ui	a2, a8, 94
        HALASSERT((flags & RTSCTS) != RTSCTS);

        if (txPower > 63)
		txPower=63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
  90b1f1:	03034b        	extui	a3, a3, 0, 12

        struct ar5416_desc *ads = AR5416DESC(ds);

        (void) hdrLen;

        ads->ds_txstatus9 &= ~AR_TxDone;
  90b1f4:	082211        	slli	a2, a2, 8
  90b1f7:	092902        	or	a9, a2, a9
  90b1fa:	22805f        	l8ui	a2, a8, 95
		txPower=63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
		| (txPower << AR_XmitPower_S)
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
  90b1fd:	1c6a60        	l32r	a12, 8e5b80 <vdesc_module_install+0xb70>

        struct ar5416_desc *ads = AR5416DESC(ds);

        (void) hdrLen;

        ads->ds_txstatus9 &= ~AR_TxDone;
  90b200:	092202        	or	a2, a2, a9
  90b203:	c79e      	movi.n	a9, -2
  90b205:	092201        	and	a2, a2, a9
  90b208:	028957        	extui	a9, a2, 24, 8
  90b20b:	29845c        	s8i	a9, a8, 92
  90b20e:	020957        	extui	a9, a2, 16, 8
  90b211:	29845d        	s8i	a9, a8, 93
  90b214:	028947        	extui	a9, a2, 8, 8
  90b217:	29845e        	s8i	a9, a8, 94

        if (txPower > 63)
		txPower=63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
		| (txPower << AR_XmitPower_S)
  90b21a:	c39f      	movi.n	a9, 63
  90b21c:	096936        	minu	a9, a6, a9
  90b21f:	009911        	slli	a9, a9, 16
  90b222:	039302        	or	a3, a9, a3

        struct ar5416_desc *ads = AR5416DESC(ds);

        (void) hdrLen;

        ads->ds_txstatus9 &= ~AR_TxDone;
  90b225:	22845f        	s8i	a2, a8, 95
        if (txPower > 63)
		txPower=63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
		| (txPower << AR_XmitPower_S)
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
  90b228:	c290      	movi.n	a9, 32
  90b22a:	126a50        	l32r	a2, 8e5b6c <vdesc_module_install+0xb5c>
  90b22d:	09a901        	and	a9, a10, a9
  90b230:	092939        	movnez	a9, a2, a9
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
  90b233:	c0e0      	movi.n	a14, 0
        if (txPower > 63)
		txPower=63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
		| (txPower << AR_XmitPower_S)
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
  90b235:	039902        	or	a9, a9, a3
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
  90b238:	d2c0      	mov.n	a2, a12
  90b23a:	0a0340        	extui	a3, a10, 0, 1
  90b23d:	03e238        	moveqz	a2, a14, a3
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0);
  90b240:	c1f0      	movi.n	a15, 16
		txPower=63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
		| (txPower << AR_XmitPower_S)
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
  90b242:	092902        	or	a9, a2, a9
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0);
  90b245:	126a61        	l32r	a2, 8e5bcc <vdesc_module_install+0xbbc>
  90b248:	0fa301        	and	a3, a10, a15
  90b24b:	032339        	movnez	a3, a2, a3
  90b24e:	093902        	or	a9, a3, a9
        HALASSERT((flags & RTSCTS) != RTSCTS);

        if (txPower > 63)
		txPower=63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
  90b251:	098257        	extui	a2, a9, 24, 8
  90b254:	228408        	s8i	a2, a8, 8
  90b257:	090257        	extui	a2, a9, 16, 8
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0);

        ads->ds_ctl1 = (type << AR_FrameType_S)
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0);
  90b25a:	c032      	movi.n	a3, 2
        HALASSERT((flags & RTSCTS) != RTSCTS);

        if (txPower > 63)
		txPower=63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
  90b25c:	228409        	s8i	a2, a8, 9
  90b25f:	098247        	extui	a2, a9, 8, 8
  90b262:	22840a        	s8i	a2, a8, 10
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0);

        ads->ds_ctl1 = (type << AR_FrameType_S)
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0);
  90b265:	03a201        	and	a2, a10, a3
		| (txPower << AR_XmitPower_S)
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0);

        ads->ds_ctl1 = (type << AR_FrameType_S)
  90b268:	0c5510        	slli	a5, a5, 20
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0);
  90b26b:	02ec38        	moveqz	a12, a14, a2
  90b26e:	05c202        	or	a2, a12, a5
		| (txPower << AR_XmitPower_S)
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0);

        ads->ds_ctl1 = (type << AR_FrameType_S)
  90b271:	028557        	extui	a5, a2, 24, 8
  90b274:	25840c        	s8i	a5, a8, 12
  90b277:	020557        	extui	a5, a2, 16, 8
  90b27a:	25840d        	s8i	a5, a8, 13
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0);
        ads->ds_ctl2 = SM(txTries0, AR_XmitDataTries0);
  90b27d:	8c18      	l32i.n	a12, a1, 32
		| (txPower << AR_XmitPower_S)
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0);

        ads->ds_ctl1 = (type << AR_FrameType_S)
  90b27f:	028547        	extui	a5, a2, 8, 8
  90b282:	25840e        	s8i	a5, a8, 14
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0);
        ads->ds_ctl2 = SM(txTries0, AR_XmitDataTries0);
  90b285:	156a64        	l32r	a5, 8e5c18 <vdesc_module_install+0xc08>
  90b288:	00f104        	ssl	a15
  90b28b:	00cc1a        	sll	a12, a12
  90b28e:	05cc01        	and	a12, a12, a5
  90b291:	0c8557        	extui	a5, a12, 24, 8
  90b294:	258410        	s8i	a5, a8, 16
  90b297:	0c0557        	extui	a5, a12, 16, 8
  90b29a:	258411        	s8i	a5, a8, 17
        ads->ds_ctl3 = (txRate0 << AR_XmitRate0_S);
  90b29d:	078557        	extui	a5, a7, 24, 8
  90b2a0:	258414        	s8i	a5, a8, 20
  90b2a3:	070557        	extui	a5, a7, 16, 8
  90b2a6:	258415        	s8i	a5, a8, 21
  90b2a9:	078547        	extui	a5, a7, 8, 8
        HALASSERT((flags & RTSCTS) != RTSCTS);

        if (txPower > 63)
		txPower=63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
  90b2ac:	29840b        	s8i	a9, a8, 11
		| (txPower << AR_XmitPower_S)
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0);

        ads->ds_ctl1 = (type << AR_FrameType_S)
  90b2af:	22840f        	s8i	a2, a8, 15
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0);
        ads->ds_ctl2 = SM(txTries0, AR_XmitDataTries0);
  90b2b2:	2e8412        	s8i	a14, a8, 18
  90b2b5:	2e8413        	s8i	a14, a8, 19
        ads->ds_ctl3 = (txRate0 << AR_XmitRate0_S);
  90b2b8:	258416        	s8i	a5, a8, 22
  90b2bb:	278417        	s8i	a7, a8, 23
			      a_uint32_t txRate0, a_uint32_t txTries0,
			      a_uint32_t keyIx,
			      a_uint32_t flags,
			      a_uint32_t rtsctsRate,
			      a_uint32_t rtsctsDuration)
{
  90b2be:	8d19      	l32i.n	a13, a1, 36
  90b2c0:	2b120b        	l32i	a11, a1, 44
        ads->ds_ctl1 = (type << AR_FrameType_S)
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0);
        ads->ds_ctl2 = SM(txTries0, AR_XmitDataTries0);
        ads->ds_ctl3 = (txRate0 << AR_XmitRate0_S);

        ads->ds_ctl7 = SM(AR5416_LEGACY_CHAINMASK, AR_ChainSel0) 
  90b2c3:	2e8424        	s8i	a14, a8, 36
  90b2c6:	238425        	s8i	a3, a8, 37
  90b2c9:	23fa84        	movi	a3, -124
  90b2cc:	238427        	s8i	a3, a8, 39
  90b2cf:	2f8426        	s8i	a15, a8, 38
		| SM(AR5416_LEGACY_CHAINMASK, AR_ChainSel1)
		| SM(AR5416_LEGACY_CHAINMASK, AR_ChainSel2) 
		| SM(AR5416_LEGACY_CHAINMASK, AR_ChainSel3);

        if (keyIx != HAL_TXKEYIX_INVALID) {
  90b2d2:	230aff        	movi	a3, 255
  90b2d5:	73d13b        	beq	a13, a3, 90b314 <ar5416SetupTxDesc_20+0x13c>
                /* XXX validate key index */
                ads->ds_ctl1 |= SM(keyIx, AR_DestIdx);
  90b2d8:	136a65        	l32r	a3, 8e5c6c <vdesc_module_install+0xc5c>
  90b2db:	03d511        	slli	a5, a13, 13
  90b2de:	035501        	and	a5, a5, a3
  90b2e1:	025502        	or	a5, a5, a2
  90b2e4:	058257        	extui	a2, a5, 24, 8
  90b2e7:	22840c        	s8i	a2, a8, 12
  90b2ea:	050257        	extui	a2, a5, 16, 8
  90b2ed:	22840d        	s8i	a2, a8, 13
  90b2f0:	058247        	extui	a2, a5, 8, 8
  90b2f3:	22840e        	s8i	a2, a8, 14
                ads->ds_ctl0 |= AR_DestIdxValid;
  90b2f6:	126a66        	l32r	a2, 8e5c90 <vdesc_module_install+0xc80>
		| SM(AR5416_LEGACY_CHAINMASK, AR_ChainSel2) 
		| SM(AR5416_LEGACY_CHAINMASK, AR_ChainSel3);

        if (keyIx != HAL_TXKEYIX_INVALID) {
                /* XXX validate key index */
                ads->ds_ctl1 |= SM(keyIx, AR_DestIdx);
  90b2f9:	25840f        	s8i	a5, a8, 15
                ads->ds_ctl0 |= AR_DestIdxValid;
  90b2fc:	029902        	or	a9, a9, a2
  90b2ff:	098257        	extui	a2, a9, 24, 8
  90b302:	228408        	s8i	a2, a8, 8
  90b305:	090257        	extui	a2, a9, 16, 8
  90b308:	228409        	s8i	a2, a8, 9
  90b30b:	098247        	extui	a2, a9, 8, 8
  90b30e:	22840a        	s8i	a2, a8, 10
  90b311:	29840b        	s8i	a9, a8, 11
        }

        if (flags & RTSCTS) {
  90b314:	c03c      	movi.n	a3, 12
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
                ads->ds_ctl2 |= SM(rtsctsDuration, AR_BurstDur);
                ads->ds_ctl3 |= (rtsctsRate << AR_RTSCTSRate_S);
        }
        return AH_TRUE;
  90b316:	c021      	movi.n	a2, 1
                /* XXX validate key index */
                ads->ds_ctl1 |= SM(keyIx, AR_DestIdx);
                ads->ds_ctl0 |= AR_DestIdxValid;
        }

        if (flags & RTSCTS) {
  90b318:	73a802        	bany	a10, a3, 90b31e <ar5416SetupTxDesc_20+0x146>
  90b31b:	60009d        	j	90b3bc <ar5416SetupTxDesc_20+0x1e4>
                if (!isValidTxRate(rtsctsRate)) {
  90b31e:	136a67        	l32r	a3, 8e5cbc <vdesc_module_install+0xcac>
  90b321:	00b004        	ssr	a11
  90b324:	03031b        	sra	a3, a3
  90b327:	023301        	and	a3, a3, a2
  90b32a:	64308c        	beqz	a3, 90b3ba <ar5416SetupTxDesc_20+0x1e2>
                        return AH_FALSE;
                }
                /* XXX validate rtsctsDuration */
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
  90b32d:	298008        	l8ui	a9, a8, 8
  90b330:	238009        	l8ui	a3, a8, 9
  90b333:	089910        	slli	a9, a9, 24
  90b336:	003311        	slli	a3, a3, 16
  90b339:	093902        	or	a9, a3, a9
  90b33c:	23800a        	l8ui	a3, a8, 10
  90b33f:	1d6a62        	l32r	a13, 8e5cc8 <vdesc_module_install+0xcb8>
  90b342:	083311        	slli	a3, a3, 8
  90b345:	093302        	or	a3, a3, a9
  90b348:	29800b        	l8ui	a9, a8, 11
  90b34b:	c050      	movi.n	a5, 0
  90b34d:	039302        	or	a3, a9, a3
  90b350:	c098      	movi.n	a9, 8
  90b352:	09a901        	and	a9, a10, a9
  90b355:	095d38        	moveqz	a13, a5, a9
  90b358:	d9d0      	mov.n	a9, a13
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
  90b35a:	c0d4      	movi.n	a13, 4
  90b35c:	0daa01        	and	a10, a10, a13
  90b35f:	1d6a63        	l32r	a13, 8e5cec <vdesc_module_install+0xcdc>
        if (flags & RTSCTS) {
                if (!isValidTxRate(rtsctsRate)) {
                        return AH_FALSE;
                }
                /* XXX validate rtsctsDuration */
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
  90b362:	039902        	or	a9, a9, a3
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
  90b365:	0a5d38        	moveqz	a13, a5, a10
        if (flags & RTSCTS) {
                if (!isValidTxRate(rtsctsRate)) {
                        return AH_FALSE;
                }
                /* XXX validate rtsctsDuration */
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
  90b368:	0d9902        	or	a9, a9, a13
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
                ads->ds_ctl2 |= SM(rtsctsDuration, AR_BurstDur);
  90b36b:	851c      	l32i.n	a5, a1, 48
        if (flags & RTSCTS) {
                if (!isValidTxRate(rtsctsRate)) {
                        return AH_FALSE;
                }
                /* XXX validate rtsctsDuration */
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
  90b36d:	098357        	extui	a3, a9, 24, 8
  90b370:	238408        	s8i	a3, a8, 8
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
                ads->ds_ctl2 |= SM(rtsctsDuration, AR_BurstDur);
  90b373:	05054e        	extui	a5, a5, 0, 15
        if (flags & RTSCTS) {
                if (!isValidTxRate(rtsctsRate)) {
                        return AH_FALSE;
                }
                /* XXX validate rtsctsDuration */
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
  90b376:	090357        	extui	a3, a9, 16, 8
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
                ads->ds_ctl2 |= SM(rtsctsDuration, AR_BurstDur);
  90b379:	0c5c02        	or	a12, a5, a12
        if (flags & RTSCTS) {
                if (!isValidTxRate(rtsctsRate)) {
                        return AH_FALSE;
                }
                /* XXX validate rtsctsDuration */
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
  90b37c:	238409        	s8i	a3, a8, 9
  90b37f:	098347        	extui	a3, a9, 8, 8
  90b382:	23840a        	s8i	a3, a8, 10
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
                ads->ds_ctl2 |= SM(rtsctsDuration, AR_BurstDur);
  90b385:	0c8357        	extui	a3, a12, 24, 8
  90b388:	238410        	s8i	a3, a8, 16
                ads->ds_ctl3 |= (rtsctsRate << AR_RTSCTSRate_S);
  90b38b:	0cbb10        	slli	a11, a11, 20
                        return AH_FALSE;
                }
                /* XXX validate rtsctsDuration */
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
                ads->ds_ctl2 |= SM(rtsctsDuration, AR_BurstDur);
  90b38e:	0c0357        	extui	a3, a12, 16, 8
                ads->ds_ctl3 |= (rtsctsRate << AR_RTSCTSRate_S);
  90b391:	07b702        	or	a7, a11, a7
                        return AH_FALSE;
                }
                /* XXX validate rtsctsDuration */
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
                ads->ds_ctl2 |= SM(rtsctsDuration, AR_BurstDur);
  90b394:	238411        	s8i	a3, a8, 17
  90b397:	0c8346        	extui	a3, a12, 8, 7
  90b39a:	238412        	s8i	a3, a8, 18
                ads->ds_ctl3 |= (rtsctsRate << AR_RTSCTSRate_S);
  90b39d:	078357        	extui	a3, a7, 24, 8
  90b3a0:	238414        	s8i	a3, a8, 20
  90b3a3:	070357        	extui	a3, a7, 16, 8
  90b3a6:	238415        	s8i	a3, a8, 21
  90b3a9:	078347        	extui	a3, a7, 8, 8
        if (flags & RTSCTS) {
                if (!isValidTxRate(rtsctsRate)) {
                        return AH_FALSE;
                }
                /* XXX validate rtsctsDuration */
                ads->ds_ctl0 |= (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0)
  90b3ac:	29840b        	s8i	a9, a8, 11
			| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0);
                ads->ds_ctl2 |= SM(rtsctsDuration, AR_BurstDur);
  90b3af:	2c8413        	s8i	a12, a8, 19
                ads->ds_ctl3 |= (rtsctsRate << AR_RTSCTSRate_S);
  90b3b2:	238416        	s8i	a3, a8, 22
  90b3b5:	278417        	s8i	a7, a8, 23
  90b3b8:	d10f      	retw.n
                ads->ds_ctl0 |= AR_DestIdxValid;
        }

        if (flags & RTSCTS) {
                if (!isValidTxRate(rtsctsRate)) {
                        return AH_FALSE;
  90b3ba:	d230      	mov.n	a2, a3
                ads->ds_ctl3 |= (rtsctsRate << AR_RTSCTSRate_S);
        }
        return AH_TRUE;

#undef RTSCTS
}
  90b3bc:	d10f      	retw.n
	...

0090b3c0 <ar5416FillTxDesc_20>:

HAL_BOOL ar5416FillTxDesc_20(struct ath_tx_desc *ds,
			     a_uint32_t segLen, HAL_BOOL firstSeg, HAL_BOOL lastSeg,
			     const struct ath_tx_desc *ds0)
{
  90b3c0:	6c1004        	entry	a1, 32
        struct ar5416_desc *ads = AR5416DESC(ds);

        HALASSERT((segLen &~ AR_BufLen) == 0);

        if (firstSeg) {
  90b3c3:	644045        	beqz	a4, 90b40c <ar5416FillTxDesc_20+0x4c>
                /*
                 * First descriptor, don't clobber xmit control data
                 * setup by ar5416SetupTxDesc.
                 */
                ads->ds_ctl1 |= segLen | (lastSeg ? 0 : AR_TxMore);
  90b3c6:	24200c        	l8ui	a4, a2, 12
  90b3c9:	c060      	movi.n	a6, 0
  90b3cb:	084810        	slli	a8, a4, 24
  90b3ce:	24200d        	l8ui	a4, a2, 13
  90b3d1:	004411        	slli	a4, a4, 16
  90b3d4:	084402        	or	a4, a4, a8
  90b3d7:	28200e        	l8ui	a8, a2, 14
  90b3da:	088811        	slli	a8, a8, 8
  90b3dd:	048402        	or	a4, a8, a4
  90b3e0:	28200f        	l8ui	a8, a2, 15
  90b3e3:	048802        	or	a8, a8, a4
  90b3e6:	146a38        	l32r	a4, 8e5cc8 <vdesc_module_install+0xcb8>
  90b3e9:	038302        	or	a3, a8, a3
  90b3ec:	054638        	moveqz	a6, a4, a5
  90b3ef:	063302        	or	a3, a3, a6
  90b3f2:	038457        	extui	a4, a3, 24, 8
  90b3f5:	24240c        	s8i	a4, a2, 12
  90b3f8:	030457        	extui	a4, a3, 16, 8
  90b3fb:	24240d        	s8i	a4, a2, 13
  90b3fe:	038447        	extui	a4, a3, 8, 8
  90b401:	d560      	mov.n	a5, a6
  90b403:	24240e        	s8i	a4, a2, 14
  90b406:	23240f        	s8i	a3, a2, 15
  90b409:	6000cb        	j	90b4d8 <ar5416FillTxDesc_20+0x118>
        } else if (lastSeg) {
  90b40c:	645089        	beqz	a5, 90b499 <ar5416FillTxDesc_20+0xd9>
                /*
                 * Last descriptor in a multi-descriptor frame,
                 * copy the multi-rate transmit parameters from
                 * the first frame for processing on completion.
                 */
                ads->ds_ctl0 = 0;
  90b40f:	242408        	s8i	a4, a2, 8
  90b412:	242409        	s8i	a4, a2, 9
  90b415:	24240a        	s8i	a4, a2, 10
  90b418:	24240b        	s8i	a4, a2, 11
                ads->ds_ctl1 = segLen;
  90b41b:	038457        	extui	a4, a3, 24, 8
  90b41e:	24240c        	s8i	a4, a2, 12
  90b421:	030457        	extui	a4, a3, 16, 8
  90b424:	24240d        	s8i	a4, a2, 13
  90b427:	038447        	extui	a4, a3, 8, 8
  90b42a:	24240e        	s8i	a4, a2, 14
  90b42d:	23240f        	s8i	a3, a2, 15
                ads->ds_ctl2 = AR5416DESC_CONST(ds0)->ds_ctl2;
  90b430:	256010        	l8ui	a5, a6, 16
  90b433:	085310        	slli	a3, a5, 24
  90b436:	256011        	l8ui	a5, a6, 17
  90b439:	005511        	slli	a5, a5, 16
  90b43c:	035502        	or	a5, a5, a3
  90b43f:	236012        	l8ui	a3, a6, 18
  90b442:	083311        	slli	a3, a3, 8
  90b445:	053502        	or	a5, a3, a5
  90b448:	236013        	l8ui	a3, a6, 19
  90b44b:	053302        	or	a3, a3, a5
  90b44e:	038457        	extui	a4, a3, 24, 8
  90b451:	242410        	s8i	a4, a2, 16
  90b454:	030457        	extui	a4, a3, 16, 8
  90b457:	242411        	s8i	a4, a2, 17
  90b45a:	038447        	extui	a4, a3, 8, 8
  90b45d:	242412        	s8i	a4, a2, 18
  90b460:	232413        	s8i	a3, a2, 19
                ads->ds_ctl3 = AR5416DESC_CONST(ds0)->ds_ctl3;
  90b463:	256014        	l8ui	a5, a6, 20
  90b466:	085310        	slli	a3, a5, 24
  90b469:	256015        	l8ui	a5, a6, 21
  90b46c:	005511        	slli	a5, a5, 16
  90b46f:	035502        	or	a5, a5, a3
  90b472:	236016        	l8ui	a3, a6, 22
  90b475:	083311        	slli	a3, a3, 8
  90b478:	053502        	or	a5, a3, a5
  90b47b:	236017        	l8ui	a3, a6, 23
  90b47e:	053302        	or	a3, a3, a5
  90b481:	038457        	extui	a4, a3, 24, 8
  90b484:	242414        	s8i	a4, a2, 20
  90b487:	030457        	extui	a4, a3, 16, 8
  90b48a:	242415        	s8i	a4, a2, 21
  90b48d:	038447        	extui	a4, a3, 8, 8
  90b490:	242416        	s8i	a4, a2, 22
  90b493:	232417        	s8i	a3, a2, 23
  90b496:	60003e        	j	90b4d8 <ar5416FillTxDesc_20+0x118>
        } else {
                /*
                 * Intermediate descriptor in a multi-descriptor frame.
                 */
                ads->ds_ctl0 = 0;
                ads->ds_ctl1 = segLen | AR_TxMore;
  90b499:	146a38        	l32r	a4, 8e5d7c <vdesc_module_install+0xd6c>
                ads->ds_ctl3 = AR5416DESC_CONST(ds0)->ds_ctl3;
        } else {
                /*
                 * Intermediate descriptor in a multi-descriptor frame.
                 */
                ads->ds_ctl0 = 0;
  90b49c:	252408        	s8i	a5, a2, 8
                ads->ds_ctl1 = segLen | AR_TxMore;
  90b49f:	043302        	or	a3, a3, a4
  90b4a2:	038457        	extui	a4, a3, 24, 8
  90b4a5:	24240c        	s8i	a4, a2, 12
  90b4a8:	030457        	extui	a4, a3, 16, 8
  90b4ab:	24240d        	s8i	a4, a2, 13
  90b4ae:	038447        	extui	a4, a3, 8, 8
                ads->ds_ctl3 = AR5416DESC_CONST(ds0)->ds_ctl3;
        } else {
                /*
                 * Intermediate descriptor in a multi-descriptor frame.
                 */
                ads->ds_ctl0 = 0;
  90b4b1:	252409        	s8i	a5, a2, 9
  90b4b4:	25240a        	s8i	a5, a2, 10
  90b4b7:	25240b        	s8i	a5, a2, 11
                ads->ds_ctl1 = segLen | AR_TxMore;
  90b4ba:	24240e        	s8i	a4, a2, 14
  90b4bd:	23240f        	s8i	a3, a2, 15
                ads->ds_ctl2 = 0;
  90b4c0:	252410        	s8i	a5, a2, 16
  90b4c3:	252411        	s8i	a5, a2, 17
  90b4c6:	252412        	s8i	a5, a2, 18
  90b4c9:	252413        	s8i	a5, a2, 19
                ads->ds_ctl3 = 0;
  90b4cc:	252414        	s8i	a5, a2, 20
  90b4cf:	252415        	s8i	a5, a2, 21
  90b4d2:	252416        	s8i	a5, a2, 22
  90b4d5:	252417        	s8i	a5, a2, 23
        }
        ads->ds_txstatus0 = ads->ds_txstatus1 = 0;
  90b4d8:	c030      	movi.n	a3, 0
  90b4da:	23243c        	s8i	a3, a2, 60
  90b4dd:	23243d        	s8i	a3, a2, 61
  90b4e0:	23243e        	s8i	a3, a2, 62
  90b4e3:	23243f        	s8i	a3, a2, 63
  90b4e6:	232438        	s8i	a3, a2, 56
  90b4e9:	232439        	s8i	a3, a2, 57
  90b4ec:	23243a        	s8i	a3, a2, 58
  90b4ef:	23243b        	s8i	a3, a2, 59

        return AH_TRUE;
}
  90b4f2:	c021      	movi.n	a2, 1
  90b4f4:	d10f      	retw.n
	...

0090b4f8 <ar5416FillKeyTxDesc_20>:

HAL_BOOL ar5416FillKeyTxDesc_20(struct ath_tx_desc *ds,
				HAL_KEY_TYPE keyType)
{
  90b4f8:	6c1004        	entry	a1, 32
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl6 = SM(keyType, AR_EncrType);
  90b4fb:	186a68        	l32r	a8, 8e5e9c <vdesc_module_install+0xe8c>
  90b4fe:	063310        	slli	a3, a3, 26
  90b501:	083301        	and	a3, a3, a8
  90b504:	038357        	extui	a3, a3, 24, 8
  90b507:	232420        	s8i	a3, a2, 32
  90b50a:	c030      	movi.n	a3, 0
  90b50c:	232421        	s8i	a3, a2, 33
  90b50f:	232422        	s8i	a3, a2, 34
  90b512:	232423        	s8i	a3, a2, 35
	return AH_TRUE;
}
  90b515:	c021      	movi.n	a2, 1
  90b517:	d10f      	retw.n
  90b519:	000000        	ill

0090b51c <ar5416ProcTxDesc_20>:

HAL_STATUS ar5416ProcTxDesc_20(struct ath_hal *ah, struct ath_tx_desc *gds)
{
  90b51c:	6c1004        	entry	a1, 32
        struct ar5416_desc *ads = AR5416DESC(gds);
        struct ath_tx_desc *ds = (struct ath_tx_desc *)gds;
        
        if ((ads->ds_txstatus9 & AR_TxDone) == 0)
  90b51f:	28305c        	l8ui	a8, a3, 92
  90b522:	088910        	slli	a9, a8, 24
  90b525:	28305d        	l8ui	a8, a3, 93
  90b528:	008811        	slli	a8, a8, 16
  90b52b:	098802        	or	a8, a8, a9
  90b52e:	29305e        	l8ui	a9, a3, 94
  90b531:	089911        	slli	a9, a9, 8
  90b534:	089802        	or	a8, a9, a8
  90b537:	29305f        	l8ui	a9, a3, 95
  90b53a:	089902        	or	a9, a9, a8
                return HAL_EINPROGRESS;
  90b53d:	c08f      	movi.n	a8, 15
HAL_STATUS ar5416ProcTxDesc_20(struct ath_hal *ah, struct ath_tx_desc *gds)
{
        struct ar5416_desc *ads = AR5416DESC(gds);
        struct ath_tx_desc *ds = (struct ath_tx_desc *)gds;
        
        if ((ads->ds_txstatus9 & AR_TxDone) == 0)
  90b53f:	7f9f02        	bbsi	a9, 31, 90b545 <ar5416ProcTxDesc_20+0x29>
  90b542:	60027a        	j	90b7c0 <ar5416ProcTxDesc_20+0x2a4>
                return HAL_EINPROGRESS;

        ads->ds_txstatus9 &= ~AR_TxDone;
  90b545:	c78e      	movi.n	a8, -2
  90b547:	089801        	and	a8, a9, a8
  90b54a:	088a57        	extui	a10, a8, 24, 8
  90b54d:	2a345c        	s8i	a10, a3, 92
  90b550:	080a57        	extui	a10, a8, 16, 8
  90b553:	2a345d        	s8i	a10, a3, 93
  90b556:	28345f        	s8i	a8, a3, 95
  90b559:	088a47        	extui	a10, a8, 8, 8

        /* Update software copies of the HW status */
        ds->ds_txstat.ts_seqnum = MS(ads->ds_txstatus9, AR_SeqNum);
  90b55c:	08184b        	extui	a8, a8, 1, 12
        struct ath_tx_desc *ds = (struct ath_tx_desc *)gds;
        
        if ((ads->ds_txstatus9 & AR_TxDone) == 0)
                return HAL_EINPROGRESS;

        ads->ds_txstatus9 &= ~AR_TxDone;
  90b55f:	2a345e        	s8i	a10, a3, 94

        /* Update software copies of the HW status */
        ds->ds_txstat.ts_seqnum = MS(ads->ds_txstatus9, AR_SeqNum);
  90b562:	088a14        	srli	a10, a8, 8
  90b565:	2a3464        	s8i	a10, a3, 100
        ds->ds_txstat.ts_tstamp = ads->AR_SendTimestamp;
  90b568:	2a3040        	l8ui	a10, a3, 64
                return HAL_EINPROGRESS;

        ads->ds_txstatus9 &= ~AR_TxDone;

        /* Update software copies of the HW status */
        ds->ds_txstat.ts_seqnum = MS(ads->ds_txstatus9, AR_SeqNum);
  90b56b:	283465        	s8i	a8, a3, 101
        ds->ds_txstat.ts_tstamp = ads->AR_SendTimestamp;
  90b56e:	08a810        	slli	a8, a10, 24
  90b571:	2a3041        	l8ui	a10, a3, 65
        struct ath_tx_desc *ds = (struct ath_tx_desc *)gds;
        
        if ((ads->ds_txstatus9 & AR_TxDone) == 0)
                return HAL_EINPROGRESS;

        ads->ds_txstatus9 &= ~AR_TxDone;
  90b574:	c0b0      	movi.n	a11, 0

        /* Update software copies of the HW status */
        ds->ds_txstat.ts_seqnum = MS(ads->ds_txstatus9, AR_SeqNum);
        ds->ds_txstat.ts_tstamp = ads->AR_SendTimestamp;
  90b576:	00aa11        	slli	a10, a10, 16
  90b579:	08aa02        	or	a10, a10, a8
  90b57c:	283042        	l8ui	a8, a3, 66
        ds->ds_txstat.ts_status = 0;
  90b57f:	2b3466        	s8i	a11, a3, 102

        ads->ds_txstatus9 &= ~AR_TxDone;

        /* Update software copies of the HW status */
        ds->ds_txstat.ts_seqnum = MS(ads->ds_txstatus9, AR_SeqNum);
        ds->ds_txstat.ts_tstamp = ads->AR_SendTimestamp;
  90b582:	088811        	slli	a8, a8, 8
  90b585:	0a8a02        	or	a10, a8, a10
  90b588:	283043        	l8ui	a8, a3, 67
        ds->ds_txstat.ts_status = 0;
        ds->ds_txstat.ts_flags  = 0;
  90b58b:	2b3467        	s8i	a11, a3, 103

        ads->ds_txstatus9 &= ~AR_TxDone;

        /* Update software copies of the HW status */
        ds->ds_txstat.ts_seqnum = MS(ads->ds_txstatus9, AR_SeqNum);
        ds->ds_txstat.ts_tstamp = ads->AR_SendTimestamp;
  90b58e:	0a8802        	or	a8, a8, a10
  90b591:	088a57        	extui	a10, a8, 24, 8
  90b594:	2a3460        	s8i	a10, a3, 96
  90b597:	080a57        	extui	a10, a8, 16, 8
  90b59a:	2a3461        	s8i	a10, a3, 97
  90b59d:	088a47        	extui	a10, a8, 8, 8
  90b5a0:	2a3462        	s8i	a10, a3, 98
  90b5a3:	283463        	s8i	a8, a3, 99
        ds->ds_txstat.ts_status = 0;
        ds->ds_txstat.ts_flags  = 0;

        if (ads->ds_txstatus1 & AR_ExcessiveRetries)
  90b5a6:	2a303c        	l8ui	a10, a3, 60
  90b5a9:	28303d        	l8ui	a8, a3, 61
  90b5ac:	08aa10        	slli	a10, a10, 24
  90b5af:	008811        	slli	a8, a8, 16
  90b5b2:	0a8a02        	or	a10, a8, a10
  90b5b5:	28303e        	l8ui	a8, a3, 62
  90b5b8:	088811        	slli	a8, a8, 8
  90b5bb:	0a8802        	or	a8, a8, a10
  90b5be:	2a303f        	l8ui	a10, a3, 63
  90b5c1:	08a802        	or	a8, a10, a8
  90b5c4:	7e8704        	bbci	a8, 30, 90b5cc <ar5416ProcTxDesc_20+0xb0>
                ds->ds_txstat.ts_status |= HAL_TXERR_XRETRY;
  90b5c7:	c0a1      	movi.n	a10, 1
  90b5c9:	2a3466        	s8i	a10, a3, 102
        if (ads->ds_txstatus1 & AR_Filtered)
  90b5cc:	7c870a        	bbci	a8, 28, 90b5da <ar5416ProcTxDesc_20+0xbe>
                ds->ds_txstat.ts_status |= HAL_TXERR_FILT;
  90b5cf:	2a3066        	l8ui	a10, a3, 102
  90b5d2:	c0b2      	movi.n	a11, 2
  90b5d4:	0baa02        	or	a10, a10, a11
  90b5d7:	2a3466        	s8i	a10, a3, 102
        if (ads->ds_txstatus1 & AR_FIFOUnderrun)
  90b5da:	c0a4      	movi.n	a10, 4
  90b5dc:	7a8008        	bnone	a8, a10, 90b5e8 <ar5416ProcTxDesc_20+0xcc>
                ds->ds_txstat.ts_status |= HAL_TXERR_FIFO;
  90b5df:	2b3066        	l8ui	a11, a3, 102
  90b5e2:	0baa02        	or	a10, a10, a11
  90b5e5:	2a3466        	s8i	a10, a3, 102
        if (ads->ds_txstatus9 & AR_TxOpExceeded)
  90b5e8:	7e960a        	bbci	a9, 14, 90b5f6 <ar5416ProcTxDesc_20+0xda>
		ds->ds_txstat.ts_status |= HAL_TXERR_XTXOP;
  90b5eb:	293066        	l8ui	a9, a3, 102
  90b5ee:	c0a8      	movi.n	a10, 8
  90b5f0:	0a9902        	or	a9, a9, a10
  90b5f3:	293466        	s8i	a9, a3, 102
        if (ads->ds_txstatus1 & AR_TxTimerExpired)
  90b5f6:	7c860a        	bbci	a8, 12, 90b604 <ar5416ProcTxDesc_20+0xe8>
		ds->ds_txstat.ts_status |= HAL_TXERR_TIMER_EXPIRED;
  90b5f9:	293066        	l8ui	a9, a3, 102
  90b5fc:	c1a0      	movi.n	a10, 16
  90b5fe:	0a9902        	or	a9, a9, a10
  90b601:	293466        	s8i	a9, a3, 102

        if (ads->ds_txstatus1 & AR_DescCfgErr)
  90b604:	7d8604        	bbci	a8, 13, 90b60c <ar5416ProcTxDesc_20+0xf0>
		ds->ds_txstat.ts_flags |= HAL_TX_DESC_CFG_ERR;
  90b607:	c094      	movi.n	a9, 4
  90b609:	293467        	s8i	a9, a3, 103
        if (ads->ds_txstatus1 & AR_TxDataUnderrun) {
  90b60c:	7e8611        	bbci	a8, 14, 90b621 <ar5416ProcTxDesc_20+0x105>
		ds->ds_txstat.ts_flags |= HAL_TX_DATA_UNDERRUN;
  90b60f:	283067        	l8ui	a8, a3, 103
  90b612:	c098      	movi.n	a9, 8
  90b614:	098802        	or	a8, a8, a9
  90b617:	283467        	s8i	a8, a3, 103
		ar5416UpdateTxTrigLevel(ah, AH_TRUE);
  90b61a:	c0b1      	movi.n	a11, 1
  90b61c:	da20      	mov.n	a10, a2
  90b61e:	5bfebe        	call8	90b118 <ar5416UpdateTxTrigLevel>
	}
        if (ads->ds_txstatus1 & AR_TxDelimUnderrun) {
  90b621:	28303d        	l8ui	a8, a3, 61
  90b624:	7f8711        	bbci	a8, 31, 90b639 <ar5416ProcTxDesc_20+0x11d>
		ds->ds_txstat.ts_flags |= HAL_TX_DELIM_UNDERRUN;
  90b627:	283067        	l8ui	a8, a3, 103
  90b62a:	c190      	movi.n	a9, 16
  90b62c:	098802        	or	a8, a8, a9
  90b62f:	283467        	s8i	a8, a3, 103
		ar5416UpdateTxTrigLevel(ah, AH_TRUE);
  90b632:	c0b1      	movi.n	a11, 1
  90b634:	da20      	mov.n	a10, a2
  90b636:	5bfeb8        	call8	90b118 <ar5416UpdateTxTrigLevel>
	}
        if (ads->ds_txstatus0 & AR_TxBaStatus) {
  90b639:	293038        	l8ui	a9, a3, 56
  90b63c:	283039        	l8ui	a8, a3, 57
  90b63f:	089910        	slli	a9, a9, 24
  90b642:	008811        	slli	a8, a8, 16
  90b645:	098902        	or	a9, a8, a9
  90b648:	28303a        	l8ui	a8, a3, 58
  90b64b:	22303b        	l8ui	a2, a3, 59
  90b64e:	088811        	slli	a8, a8, 8
  90b651:	098802        	or	a8, a8, a9
  90b654:	082802        	or	a8, a2, a8
  90b657:	718671        	bbci	a8, 1, 90b6cc <ar5416ProcTxDesc_20+0x1b0>
		ds->ds_txstat.ts_flags |= HAL_TX_BA;
  90b65a:	223067        	l8ui	a2, a3, 103
		ds->ds_txstat.ba_low = ads->AR_BaBitmapLow;
  90b65d:	2a3044        	l8ui	a10, a3, 68
        if (ads->ds_txstatus1 & AR_TxDelimUnderrun) {
		ds->ds_txstat.ts_flags |= HAL_TX_DELIM_UNDERRUN;
		ar5416UpdateTxTrigLevel(ah, AH_TRUE);
	}
        if (ads->ds_txstatus0 & AR_TxBaStatus) {
		ds->ds_txstat.ts_flags |= HAL_TX_BA;
  90b660:	290a01        	movi	a9, 1
  90b663:	092202        	or	a2, a2, a9
		ds->ds_txstat.ba_low = ads->AR_BaBitmapLow;
  90b666:	08a910        	slli	a9, a10, 24
  90b669:	2a3045        	l8ui	a10, a3, 69
        if (ads->ds_txstatus1 & AR_TxDelimUnderrun) {
		ds->ds_txstat.ts_flags |= HAL_TX_DELIM_UNDERRUN;
		ar5416UpdateTxTrigLevel(ah, AH_TRUE);
	}
        if (ads->ds_txstatus0 & AR_TxBaStatus) {
		ds->ds_txstat.ts_flags |= HAL_TX_BA;
  90b66c:	223467        	s8i	a2, a3, 103
		ds->ds_txstat.ba_low = ads->AR_BaBitmapLow;
  90b66f:	00aa11        	slli	a10, a10, 16
  90b672:	09aa02        	or	a10, a10, a9
  90b675:	293046        	l8ui	a9, a3, 70
  90b678:	089911        	slli	a9, a9, 8
  90b67b:	0a9a02        	or	a10, a9, a10
  90b67e:	293047        	l8ui	a9, a3, 71
  90b681:	0a9902        	or	a9, a9, a10
  90b684:	098257        	extui	a2, a9, 24, 8
		ds->ds_txstat.ba_high = ads->AR_BaBitmapHigh;
  90b687:	2a3048        	l8ui	a10, a3, 72
		ds->ds_txstat.ts_flags |= HAL_TX_DELIM_UNDERRUN;
		ar5416UpdateTxTrigLevel(ah, AH_TRUE);
	}
        if (ads->ds_txstatus0 & AR_TxBaStatus) {
		ds->ds_txstat.ts_flags |= HAL_TX_BA;
		ds->ds_txstat.ba_low = ads->AR_BaBitmapLow;
  90b68a:	223474        	s8i	a2, a3, 116
  90b68d:	090257        	extui	a2, a9, 16, 8
  90b690:	223475        	s8i	a2, a3, 117
  90b693:	293477        	s8i	a9, a3, 119
  90b696:	098247        	extui	a2, a9, 8, 8
		ds->ds_txstat.ba_high = ads->AR_BaBitmapHigh;
  90b699:	08a910        	slli	a9, a10, 24
  90b69c:	2a3049        	l8ui	a10, a3, 73
		ds->ds_txstat.ts_flags |= HAL_TX_DELIM_UNDERRUN;
		ar5416UpdateTxTrigLevel(ah, AH_TRUE);
	}
        if (ads->ds_txstatus0 & AR_TxBaStatus) {
		ds->ds_txstat.ts_flags |= HAL_TX_BA;
		ds->ds_txstat.ba_low = ads->AR_BaBitmapLow;
  90b69f:	223476        	s8i	a2, a3, 118
		ds->ds_txstat.ba_high = ads->AR_BaBitmapHigh;
  90b6a2:	00aa11        	slli	a10, a10, 16
  90b6a5:	09aa02        	or	a10, a10, a9
  90b6a8:	29304a        	l8ui	a9, a3, 74
  90b6ab:	089911        	slli	a9, a9, 8
  90b6ae:	0a9a02        	or	a10, a9, a10
  90b6b1:	29304b        	l8ui	a9, a3, 75
  90b6b4:	0a9902        	or	a9, a9, a10
  90b6b7:	098257        	extui	a2, a9, 24, 8
  90b6ba:	223478        	s8i	a2, a3, 120
  90b6bd:	090257        	extui	a2, a9, 16, 8
  90b6c0:	223479        	s8i	a2, a3, 121
  90b6c3:	098247        	extui	a2, a9, 8, 8
  90b6c6:	22347a        	s8i	a2, a3, 122
  90b6c9:	29347b        	s8i	a9, a3, 123
         * Extract the transmit rate used and mark the rate as
         * ``alternate'' if it wasn't the series 0 rate.
         */
        ds->ds_txstat.ts_rate = MS(ads->ds_txstatus9, AR_FinalTxIdx);
        ds->ds_txstat.ts_rssi_combined = 
		MS(ads->ds_txstatus5, AR_TxRSSICombined);
  90b6cc:	2a304c        	l8ui	a10, a3, 76

        /*
         * Extract the transmit rate used and mark the rate as
         * ``alternate'' if it wasn't the series 0 rate.
         */
        ds->ds_txstat.ts_rate = MS(ads->ds_txstatus9, AR_FinalTxIdx);
  90b6cf:	22305d        	l8ui	a2, a3, 93
        ds->ds_txstat.ts_rssi_combined = 
		MS(ads->ds_txstatus5, AR_TxRSSICombined);
  90b6d2:	08a910        	slli	a9, a10, 24
  90b6d5:	2a304d        	l8ui	a10, a3, 77

        /*
         * Extract the transmit rate used and mark the rate as
         * ``alternate'' if it wasn't the series 0 rate.
         */
        ds->ds_txstat.ts_rate = MS(ads->ds_txstatus9, AR_FinalTxIdx);
  90b6d8:	025241        	extui	a2, a2, 5, 2
        ds->ds_txstat.ts_rssi_combined = 
		MS(ads->ds_txstatus5, AR_TxRSSICombined);
  90b6db:	00aa11        	slli	a10, a10, 16
  90b6de:	09aa02        	or	a10, a10, a9
  90b6e1:	29304e        	l8ui	a9, a3, 78

        /*
         * Extract the transmit rate used and mark the rate as
         * ``alternate'' if it wasn't the series 0 rate.
         */
        ds->ds_txstat.ts_rate = MS(ads->ds_txstatus9, AR_FinalTxIdx);
  90b6e4:	223468        	s8i	a2, a3, 104
        ds->ds_txstat.ts_rssi_combined = 
		MS(ads->ds_txstatus5, AR_TxRSSICombined);
  90b6e7:	089911        	slli	a9, a9, 8
  90b6ea:	0a9a02        	or	a10, a9, a10
  90b6ed:	29304f        	l8ui	a9, a3, 79
        ds->ds_txstat.ts_rssi_ctl0 = MS(ads->ds_txstatus0, AR_TxRSSIAnt00);
        ds->ds_txstat.ts_rssi_ctl1 = MS(ads->ds_txstatus0, AR_TxRSSIAnt01);
  90b6f0:	088214        	srli	a2, a8, 8
         * Extract the transmit rate used and mark the rate as
         * ``alternate'' if it wasn't the series 0 rate.
         */
        ds->ds_txstat.ts_rate = MS(ads->ds_txstatus9, AR_FinalTxIdx);
        ds->ds_txstat.ts_rssi_combined = 
		MS(ads->ds_txstatus5, AR_TxRSSICombined);
  90b6f3:	0a9902        	or	a9, a9, a10
        ds->ds_txstat.ts_rssi_ctl0 = MS(ads->ds_txstatus0, AR_TxRSSIAnt00);
  90b6f6:	28346a        	s8i	a8, a3, 106
        ds->ds_txstat.ts_rssi_ctl1 = MS(ads->ds_txstatus0, AR_TxRSSIAnt01);
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
  90b6f9:	08085f        	extui	a8, a8, 16, 16
         * Extract the transmit rate used and mark the rate as
         * ``alternate'' if it wasn't the series 0 rate.
         */
        ds->ds_txstat.ts_rate = MS(ads->ds_txstatus9, AR_FinalTxIdx);
        ds->ds_txstat.ts_rssi_combined = 
		MS(ads->ds_txstatus5, AR_TxRSSICombined);
  90b6fc:	098a57        	extui	a10, a9, 24, 8
        ds->ds_txstat.ts_rssi_ctl0 = MS(ads->ds_txstatus0, AR_TxRSSIAnt00);
        ds->ds_txstat.ts_rssi_ctl1 = MS(ads->ds_txstatus0, AR_TxRSSIAnt01);
  90b6ff:	22346b        	s8i	a2, a3, 107
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
  90b702:	28346c        	s8i	a8, a3, 108
        ds->ds_txstat.ts_rssi_ext0 = MS(ads->ds_txstatus5, AR_TxRSSIAnt10);
        ds->ds_txstat.ts_rssi_ext1 = MS(ads->ds_txstatus5, AR_TxRSSIAnt11);
  90b705:	098214        	srli	a2, a9, 8
        ds->ds_txstat.ts_rssi_ext2 = MS(ads->ds_txstatus5, AR_TxRSSIAnt12);
  90b708:	09085f        	extui	a8, a9, 16, 16
        ds->ds_txstat.ts_rssi_combined = 
		MS(ads->ds_txstatus5, AR_TxRSSICombined);
        ds->ds_txstat.ts_rssi_ctl0 = MS(ads->ds_txstatus0, AR_TxRSSIAnt00);
        ds->ds_txstat.ts_rssi_ctl1 = MS(ads->ds_txstatus0, AR_TxRSSIAnt01);
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
        ds->ds_txstat.ts_rssi_ext0 = MS(ads->ds_txstatus5, AR_TxRSSIAnt10);
  90b70b:	29346d        	s8i	a9, a3, 109
        ds->ds_txstat.ts_rssi_ext1 = MS(ads->ds_txstatus5, AR_TxRSSIAnt11);
        ds->ds_txstat.ts_rssi_ext2 = MS(ads->ds_txstatus5, AR_TxRSSIAnt12);
        ds->ds_txstat.evm0 = ads->AR_TxEVM0;
  90b70e:	29347f        	s8i	a9, a3, 127
        ds->ds_txstat.evm1 = ads->AR_TxEVM1;
  90b711:	293050        	l8ui	a9, a3, 80
        ds->ds_txstat.ts_rssi_ctl0 = MS(ads->ds_txstatus0, AR_TxRSSIAnt00);
        ds->ds_txstat.ts_rssi_ctl1 = MS(ads->ds_txstatus0, AR_TxRSSIAnt01);
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
        ds->ds_txstat.ts_rssi_ext0 = MS(ads->ds_txstatus5, AR_TxRSSIAnt10);
        ds->ds_txstat.ts_rssi_ext1 = MS(ads->ds_txstatus5, AR_TxRSSIAnt11);
        ds->ds_txstat.ts_rssi_ext2 = MS(ads->ds_txstatus5, AR_TxRSSIAnt12);
  90b714:	28346f        	s8i	a8, a3, 111
        ds->ds_txstat.evm0 = ads->AR_TxEVM0;
  90b717:	28347d        	s8i	a8, a3, 125
        ds->ds_txstat.evm1 = ads->AR_TxEVM1;
  90b71a:	089810        	slli	a8, a9, 24
  90b71d:	293051        	l8ui	a9, a3, 81
		MS(ads->ds_txstatus5, AR_TxRSSICombined);
        ds->ds_txstat.ts_rssi_ctl0 = MS(ads->ds_txstatus0, AR_TxRSSIAnt00);
        ds->ds_txstat.ts_rssi_ctl1 = MS(ads->ds_txstatus0, AR_TxRSSIAnt01);
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
        ds->ds_txstat.ts_rssi_ext0 = MS(ads->ds_txstatus5, AR_TxRSSIAnt10);
        ds->ds_txstat.ts_rssi_ext1 = MS(ads->ds_txstatus5, AR_TxRSSIAnt11);
  90b720:	22346e        	s8i	a2, a3, 110
        ds->ds_txstat.ts_rssi_ext2 = MS(ads->ds_txstatus5, AR_TxRSSIAnt12);
        ds->ds_txstat.evm0 = ads->AR_TxEVM0;
        ds->ds_txstat.evm1 = ads->AR_TxEVM1;
  90b723:	009911        	slli	a9, a9, 16
  90b726:	089902        	or	a9, a9, a8
  90b729:	283052        	l8ui	a8, a3, 82
        ds->ds_txstat.ts_rssi_ctl1 = MS(ads->ds_txstatus0, AR_TxRSSIAnt01);
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
        ds->ds_txstat.ts_rssi_ext0 = MS(ads->ds_txstatus5, AR_TxRSSIAnt10);
        ds->ds_txstat.ts_rssi_ext1 = MS(ads->ds_txstatus5, AR_TxRSSIAnt11);
        ds->ds_txstat.ts_rssi_ext2 = MS(ads->ds_txstatus5, AR_TxRSSIAnt12);
        ds->ds_txstat.evm0 = ads->AR_TxEVM0;
  90b72c:	22347e        	s8i	a2, a3, 126
        ds->ds_txstat.evm1 = ads->AR_TxEVM1;
  90b72f:	088811        	slli	a8, a8, 8
  90b732:	098902        	or	a9, a8, a9
  90b735:	283053        	l8ui	a8, a3, 83
        /*
         * Extract the transmit rate used and mark the rate as
         * ``alternate'' if it wasn't the series 0 rate.
         */
        ds->ds_txstat.ts_rate = MS(ads->ds_txstatus9, AR_FinalTxIdx);
        ds->ds_txstat.ts_rssi_combined = 
  90b738:	2a3469        	s8i	a10, a3, 105
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
        ds->ds_txstat.ts_rssi_ext0 = MS(ads->ds_txstatus5, AR_TxRSSIAnt10);
        ds->ds_txstat.ts_rssi_ext1 = MS(ads->ds_txstatus5, AR_TxRSSIAnt11);
        ds->ds_txstat.ts_rssi_ext2 = MS(ads->ds_txstatus5, AR_TxRSSIAnt12);
        ds->ds_txstat.evm0 = ads->AR_TxEVM0;
        ds->ds_txstat.evm1 = ads->AR_TxEVM1;
  90b73b:	098802        	or	a8, a8, a9
  90b73e:	088257        	extui	a2, a8, 24, 8
        ds->ds_txstat.evm2 = ads->AR_TxEVM2;
  90b741:	293054        	l8ui	a9, a3, 84
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
        ds->ds_txstat.ts_rssi_ext0 = MS(ads->ds_txstatus5, AR_TxRSSIAnt10);
        ds->ds_txstat.ts_rssi_ext1 = MS(ads->ds_txstatus5, AR_TxRSSIAnt11);
        ds->ds_txstat.ts_rssi_ext2 = MS(ads->ds_txstatus5, AR_TxRSSIAnt12);
        ds->ds_txstat.evm0 = ads->AR_TxEVM0;
        ds->ds_txstat.evm1 = ads->AR_TxEVM1;
  90b744:	223480        	s8i	a2, a3, 128
  90b747:	080257        	extui	a2, a8, 16, 8
  90b74a:	223481        	s8i	a2, a3, 129
  90b74d:	283483        	s8i	a8, a3, 131
  90b750:	088247        	extui	a2, a8, 8, 8
        ds->ds_txstat.evm2 = ads->AR_TxEVM2;
  90b753:	089810        	slli	a8, a9, 24
  90b756:	293055        	l8ui	a9, a3, 85
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
        ds->ds_txstat.ts_rssi_ext0 = MS(ads->ds_txstatus5, AR_TxRSSIAnt10);
        ds->ds_txstat.ts_rssi_ext1 = MS(ads->ds_txstatus5, AR_TxRSSIAnt11);
        ds->ds_txstat.ts_rssi_ext2 = MS(ads->ds_txstatus5, AR_TxRSSIAnt12);
        ds->ds_txstat.evm0 = ads->AR_TxEVM0;
        ds->ds_txstat.evm1 = ads->AR_TxEVM1;
  90b759:	223482        	s8i	a2, a3, 130
        ds->ds_txstat.evm2 = ads->AR_TxEVM2;
  90b75c:	009911        	slli	a9, a9, 16
  90b75f:	089902        	or	a9, a9, a8
  90b762:	283056        	l8ui	a8, a3, 86
        ds->ds_txstat.ts_rssi_ctl1 = MS(ads->ds_txstatus0, AR_TxRSSIAnt01);
        ds->ds_txstat.ts_rssi_ctl2 = MS(ads->ds_txstatus0, AR_TxRSSIAnt02);
        ds->ds_txstat.ts_rssi_ext0 = MS(ads->ds_txstatus5, AR_TxRSSIAnt10);
        ds->ds_txstat.ts_rssi_ext1 = MS(ads->ds_txstatus5, AR_TxRSSIAnt11);
        ds->ds_txstat.ts_rssi_ext2 = MS(ads->ds_txstatus5, AR_TxRSSIAnt12);
        ds->ds_txstat.evm0 = ads->AR_TxEVM0;
  90b765:	2a347c        	s8i	a10, a3, 124
        ds->ds_txstat.evm1 = ads->AR_TxEVM1;
        ds->ds_txstat.evm2 = ads->AR_TxEVM2;
  90b768:	088811        	slli	a8, a8, 8
  90b76b:	098902        	or	a9, a8, a9
  90b76e:	283057        	l8ui	a8, a3, 87
  90b771:	098802        	or	a8, a8, a9
  90b774:	088257        	extui	a2, a8, 24, 8
  90b777:	223484        	s8i	a2, a3, 132
  90b77a:	080257        	extui	a2, a8, 16, 8
  90b77d:	223485        	s8i	a2, a3, 133
  90b780:	088247        	extui	a2, a8, 8, 8
  90b783:	223486        	s8i	a2, a3, 134
  90b786:	283487        	s8i	a8, a3, 135
        ds->ds_txstat.ts_shortretry = MS(ads->ds_txstatus1, AR_RTSFailCnt);
  90b789:	29303c        	l8ui	a9, a3, 60
  90b78c:	089810        	slli	a8, a9, 24
  90b78f:	29303d        	l8ui	a9, a3, 61
  90b792:	009911        	slli	a9, a9, 16
  90b795:	089902        	or	a9, a9, a8
  90b798:	28303e        	l8ui	a8, a3, 62
  90b79b:	088811        	slli	a8, a8, 8
  90b79e:	098902        	or	a9, a8, a9
  90b7a1:	28303f        	l8ui	a8, a3, 63
  90b7a4:	098802        	or	a8, a8, a9
  90b7a7:	084243        	extui	a2, a8, 4, 4
  90b7aa:	223470        	s8i	a2, a3, 112
        ds->ds_txstat.ts_longretry = MS(ads->ds_txstatus1, AR_DataFailCnt);
  90b7ad:	088243        	extui	a2, a8, 8, 4
  90b7b0:	223471        	s8i	a2, a3, 113
        ds->ds_txstat.ts_virtcol = MS(ads->ds_txstatus1, AR_VirtRetryCnt);
  90b7b3:	08c843        	extui	a8, a8, 12, 4
        ds->ds_txstat.ts_antenna = 0;		/* ignored for owl */
  90b7b6:	c020      	movi.n	a2, 0
        ds->ds_txstat.evm0 = ads->AR_TxEVM0;
        ds->ds_txstat.evm1 = ads->AR_TxEVM1;
        ds->ds_txstat.evm2 = ads->AR_TxEVM2;
        ds->ds_txstat.ts_shortretry = MS(ads->ds_txstatus1, AR_RTSFailCnt);
        ds->ds_txstat.ts_longretry = MS(ads->ds_txstatus1, AR_DataFailCnt);
        ds->ds_txstat.ts_virtcol = MS(ads->ds_txstatus1, AR_VirtRetryCnt);
  90b7b8:	283472        	s8i	a8, a3, 114
        ds->ds_txstat.ts_antenna = 0;		/* ignored for owl */
  90b7bb:	223473        	s8i	a2, a3, 115

        return HAL_OK;
  90b7be:	c080      	movi.n	a8, 0
}
  90b7c0:	d280      	mov.n	a2, a8
  90b7c2:	d10f      	retw.n

0090b7c4 <ar5416Set11nTxDesc_20>:

void ar5416Set11nTxDesc_20(struct ath_tx_desc *ds,
			   a_uint32_t pktLen, HAL_PKT_TYPE type, a_uint32_t txPower,
			   a_uint32_t keyIx, HAL_KEY_TYPE keyType,
			   a_uint32_t flags)
{
  90b7c4:	6c1004        	entry	a1, 32
  90b7c7:	8818      	l32i.n	a8, a1, 32
  90b7c9:	c39f      	movi.n	a9, 63
  90b7cb:	095536        	minu	a5, a5, a9

	if (txPower > 63)
                txPower = 63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
		| (flags & HAL_TXDESC_VMF ? AR_VirtMoreFrag : 0)
  90b7ce:	2a1a00        	movi	a10, 0x100
        HALASSERT(isValidKeyType(keyType));

	if (txPower > 63)
                txPower = 63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
  90b7d1:	03094b        	extui	a9, a3, 0, 12
		| (flags & HAL_TXDESC_VMF ? AR_VirtMoreFrag : 0)
  90b7d4:	136a38        	l32r	a3, 8e60b4 <vdesc_module_install+0x10a4>
  90b7d7:	0a8a01        	and	a10, a8, a10
  90b7da:	0a3a39        	movnez	a10, a3, a10
		| SM(txPower, AR_XmitPower)
  90b7dd:	136a6b        	l32r	a3, 8e618c <vdesc_module_install+0x117c>
  90b7e0:	005511        	slli	a5, a5, 16
  90b7e3:	035301        	and	a3, a5, a3
  90b7e6:	093302        	or	a3, a3, a9
		| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0)
  90b7e9:	156a63        	l32r	a5, 8e6178 <vdesc_module_install+0x1168>
  90b7ec:	c094      	movi.n	a9, 4
  90b7ee:	098901        	and	a9, a8, a9
  90b7f1:	095939        	movnez	a9, a5, a9
	if (txPower > 63)
                txPower = 63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
		| (flags & HAL_TXDESC_VMF ? AR_VirtMoreFrag : 0)
		| SM(txPower, AR_XmitPower)
  90b7f4:	0a3302        	or	a3, a3, a10
		| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0)
  90b7f7:	039302        	or	a3, a9, a3
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
  90b7fa:	156a50        	l32r	a5, 8e613c <vdesc_module_install+0x112c>
  90b7fd:	c290      	movi.n	a9, 32
  90b7ff:	098901        	and	a9, a8, a9
  90b802:	095939        	movnez	a9, a5, a9
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
  90b805:	1a6a60        	l32r	a10, 8e6188 <vdesc_module_install+0x1178>

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
		| (flags & HAL_TXDESC_VMF ? AR_VirtMoreFrag : 0)
		| SM(txPower, AR_XmitPower)
		| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0)
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
  90b808:	039902        	or	a9, a9, a3
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
  90b80b:	080540        	extui	a5, a8, 0, 1
  90b80e:	c030      	movi.n	a3, 0
  90b810:	053a38        	moveqz	a10, a3, a5
  90b813:	09a502        	or	a5, a10, a9
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0)
  90b816:	1a6a61        	l32r	a10, 8e619c <vdesc_module_install+0x118c>
  90b819:	290a10        	movi	a9, 16
  90b81c:	098901        	and	a9, a8, a9
  90b81f:	09a939        	movnez	a9, a10, a9
		| (keyIx != HAL_TXKEYIX_INVALID ? AR_DestIdxValid : 0)
  90b822:	1b6a66        	l32r	a11, 8e61bc <vdesc_module_install+0x11ac>
  90b825:	2a0aff        	movi	a10, 255
		| (flags & HAL_TXDESC_VMF ? AR_VirtMoreFrag : 0)
		| SM(txPower, AR_XmitPower)
		| (flags & HAL_TXDESC_RTSENA ? AR_RTSEnable : 0)
		| (flags & HAL_TXDESC_VEOL ? AR_VEOL : 0)
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0)
  90b828:	059902        	or	a9, a9, a5
		| (keyIx != HAL_TXKEYIX_INVALID ? AR_DestIdxValid : 0)
  90b82b:	0a650c        	sub	a5, a6, a10
  90b82e:	053b38        	moveqz	a11, a3, a5
  90b831:	09b502        	or	a5, a11, a9
		| (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0);
  90b834:	290a08        	movi	a9, 8
  90b837:	1b6a62        	l32r	a11, 8e61c0 <vdesc_module_install+0x11b0>
  90b83a:	098901        	and	a9, a8, a9
  90b83d:	09b939        	movnez	a9, a11, a9
  90b840:	059902        	or	a9, a9, a5
        HALASSERT(isValidKeyType(keyType));

	if (txPower > 63)
                txPower = 63;

        ads->ds_ctl0 = (pktLen & AR_FrameLen)
  90b843:	098557        	extui	a5, a9, 24, 8
  90b846:	252408        	s8i	a5, a2, 8
  90b849:	090557        	extui	a5, a9, 16, 8
  90b84c:	252409        	s8i	a5, a2, 9
  90b84f:	098547        	extui	a5, a9, 8, 8
  90b852:	25240a        	s8i	a5, a2, 10
  90b855:	29240b        	s8i	a9, a2, 11
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0)
		| (keyIx != HAL_TXKEYIX_INVALID ? AR_DestIdxValid : 0)
		| (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0);

        ads->ds_ctl1 = (keyIx != HAL_TXKEYIX_INVALID ? SM(keyIx, AR_DestIdx) : 0)
  90b858:	7a6108        	beq	a6, a10, 90b864 <ar5416Set11nTxDesc_20+0xa0>
  90b85b:	136a65        	l32r	a3, 8e61f0 <vdesc_module_install+0x11e0>
  90b85e:	036611        	slli	a6, a6, 13
  90b861:	036301        	and	a3, a6, a3
		| SM(type, AR_FrameType)
  90b864:	16694d        	l32r	a6, 8e5d98 <vdesc_module_install+0xd88>
  90b867:	0c4410        	slli	a4, a4, 20
  90b86a:	064401        	and	a4, a4, a6
  90b86d:	034402        	or	a4, a4, a3
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0)
  90b870:	156a60        	l32r	a5, 8e61f0 <vdesc_module_install+0x11e0>
  90b873:	c032      	movi.n	a3, 2
  90b875:	038301        	and	a3, a8, a3
  90b878:	035339        	movnez	a3, a5, a3
  90b87b:	043402        	or	a4, a3, a4
		| (flags & HAL_TXDESC_EXT_ONLY ? AR_ExtOnly : 0)
  90b87e:	156a69        	l32r	a5, 8e6224 <vdesc_module_install+0x1214>
  90b881:	c430      	movi.n	a3, 64
  90b883:	038301        	and	a3, a8, a3
  90b886:	035339        	movnez	a3, a5, a3
  90b889:	043302        	or	a3, a3, a4
		| (flags & HAL_TXDESC_EXT_AND_CTL ? AR_ExtAndCtl : 0);
  90b88c:	240a80        	movi	a4, 128
  90b88f:	048801        	and	a8, a8, a4
  90b892:	146a6a        	l32r	a4, 8e623c <vdesc_module_install+0x122c>

        ads->ds_ctl6 = SM(keyType, AR_EncrType);
  90b895:	067710        	slli	a7, a7, 26

        ads->ds_ctl1 = (keyIx != HAL_TXKEYIX_INVALID ? SM(keyIx, AR_DestIdx) : 0)
		| SM(type, AR_FrameType)
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0)
		| (flags & HAL_TXDESC_EXT_ONLY ? AR_ExtOnly : 0)
		| (flags & HAL_TXDESC_EXT_AND_CTL ? AR_ExtAndCtl : 0);
  90b898:	084839        	movnez	a8, a4, a8
  90b89b:	038802        	or	a8, a8, a3
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0)
		| (keyIx != HAL_TXKEYIX_INVALID ? AR_DestIdxValid : 0)
		| (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0);

        ads->ds_ctl1 = (keyIx != HAL_TXKEYIX_INVALID ? SM(keyIx, AR_DestIdx) : 0)
  90b89e:	088357        	extui	a3, a8, 24, 8
  90b8a1:	23240c        	s8i	a3, a2, 12
  90b8a4:	080357        	extui	a3, a8, 16, 8
  90b8a7:	23240d        	s8i	a3, a2, 13
  90b8aa:	088347        	extui	a3, a8, 8, 8
  90b8ad:	23240e        	s8i	a3, a2, 14
		| SM(type, AR_FrameType)
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0)
		| (flags & HAL_TXDESC_EXT_ONLY ? AR_ExtOnly : 0)
		| (flags & HAL_TXDESC_EXT_AND_CTL ? AR_ExtAndCtl : 0);

        ads->ds_ctl6 = SM(keyType, AR_EncrType);
  90b8b0:	136a68        	l32r	a3, 8e6250 <vdesc_module_install+0x1240>
		| (flags & HAL_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)
		| (flags & HAL_TXDESC_INTREQ ? AR_TxIntrReq : 0)
		| (keyIx != HAL_TXKEYIX_INVALID ? AR_DestIdxValid : 0)
		| (flags & HAL_TXDESC_CTSENA ? AR_CTSEnable : 0);

        ads->ds_ctl1 = (keyIx != HAL_TXKEYIX_INVALID ? SM(keyIx, AR_DestIdx) : 0)
  90b8b3:	28240f        	s8i	a8, a2, 15
		| SM(type, AR_FrameType)
		| (flags & HAL_TXDESC_NOACK ? AR_NoAck : 0)
		| (flags & HAL_TXDESC_EXT_ONLY ? AR_ExtOnly : 0)
		| (flags & HAL_TXDESC_EXT_AND_CTL ? AR_ExtAndCtl : 0);

        ads->ds_ctl6 = SM(keyType, AR_EncrType);
  90b8b6:	037701        	and	a7, a7, a3
  90b8b9:	078757        	extui	a7, a7, 24, 8
  90b8bc:	c030      	movi.n	a3, 0
  90b8be:	272420        	s8i	a7, a2, 32
  90b8c1:	232421        	s8i	a3, a2, 33
  90b8c4:	232422        	s8i	a3, a2, 34
  90b8c7:	232423        	s8i	a3, a2, 35
  90b8ca:	d10f      	retw.n

0090b8cc <ar5416Set11nRateScenario_20>:

void ar5416Set11nRateScenario_20(struct ath_tx_desc *ds,
				 a_uint32_t durUpdateEn, a_uint32_t rtsctsRate,
				 HAL_11N_RATE_SERIES series[], a_uint32_t nseries,
				 a_uint32_t flags)
{
  90b8cc:	6c1006        	entry	a1, 48
  90b8cf:	9412      	s32i.n	a4, a1, 8
	(void)nseries;

	/*
	* Rate control settings override
	*/
	ds_ctl0 = ads->ds_ctl0;
  90b8d1:	242008        	l8ui	a4, a2, 8

	if (flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA)) {
  90b8d4:	c08c      	movi.n	a8, 12
	(void)nseries;

	/*
	* Rate control settings override
	*/
	ds_ctl0 = ads->ds_ctl0;
  90b8d6:	084610        	slli	a6, a4, 24
  90b8d9:	242009        	l8ui	a4, a2, 9
  90b8dc:	004411        	slli	a4, a4, 16
  90b8df:	064402        	or	a4, a4, a6
  90b8e2:	26200a        	l8ui	a6, a2, 10
  90b8e5:	086611        	slli	a6, a6, 8
  90b8e8:	046402        	or	a4, a6, a4
  90b8eb:	26200b        	l8ui	a6, a2, 11
  90b8ee:	046602        	or	a6, a6, a4
			ds_ctl0 |= AR_CTSEnable;
		}
	} else {
		/* this line is only difference between merlin and k2
		 * Current one is for merlin */
		ds_ctl0 = (ds_ctl0 & ~(AR_RTSEnable | AR_CTSEnable));
  90b8f1:	146a6e        	l32r	a4, 8e62ac <vdesc_module_install+0x129c>
  90b8f4:	046401        	and	a4, a6, a4
	/*
	* Rate control settings override
	*/
	ds_ctl0 = ads->ds_ctl0;

	if (flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA)) {
  90b8f7:	78701a        	bnone	a7, a8, 90b915 <ar5416Set11nRateScenario_20+0x49>
		if (flags & HAL_TXDESC_RTSENA) {
  90b8fa:	7d770b        	bbci	a7, 29, 90b909 <ar5416Set11nRateScenario_20+0x3d>
			ds_ctl0 &= ~AR_CTSEnable;
  90b8fd:	146a5b        	l32r	a4, 8e626c <vdesc_module_install+0x125c>
  90b900:	046601        	and	a6, a6, a4
			ds_ctl0 |= AR_RTSEnable;
  90b903:	146a63        	l32r	a4, 8e6290 <vdesc_module_install+0x1280>
  90b906:	600008        	j	90b912 <ar5416Set11nRateScenario_20+0x46>
		} else {
			ds_ctl0 &= ~AR_RTSEnable;
  90b909:	146a6d        	l32r	a4, 8e62c0 <vdesc_module_install+0x12b0>
  90b90c:	046601        	and	a6, a6, a4
			ds_ctl0 |= AR_CTSEnable;
  90b90f:	146a62        	l32r	a4, 8e6298 <vdesc_module_install+0x1288>
  90b912:	046402        	or	a4, a6, a4
		/* this line is only difference between merlin and k2
		 * Current one is for merlin */
		ds_ctl0 = (ds_ctl0 & ~(AR_RTSEnable | AR_CTSEnable));
	}

	ads->ds_ctl0 = ds_ctl0;
  90b915:	048657        	extui	a6, a4, 24, 8
  90b918:	262408        	s8i	a6, a2, 8
  90b91b:	040657        	extui	a6, a4, 16, 8
  90b91e:	262409        	s8i	a6, a2, 9
  90b921:	24240b        	s8i	a4, a2, 11
  90b924:	048647        	extui	a6, a4, 8, 8

	ads->ds_ctl2 = set11nTries(series, 0)
  90b927:	8450      	l32i.n	a4, a5, 0
		/* this line is only difference between merlin and k2
		 * Current one is for merlin */
		ds_ctl0 = (ds_ctl0 & ~(AR_RTSEnable | AR_CTSEnable));
	}

	ads->ds_ctl0 = ds_ctl0;
  90b929:	26240a        	s8i	a6, a2, 10

	ads->ds_ctl2 = set11nTries(series, 0)
  90b92c:	166a64        	l32r	a6, 8e62bc <vdesc_module_install+0x12ac>
  90b92f:	004411        	slli	a4, a4, 16
  90b932:	064401        	and	a4, a4, a6
				   | set11nTries(series, 1)
  90b935:	8657      	l32i.n	a6, a5, 28
  90b937:	17694d        	l32r	a7, 8e5e6c <vdesc_module_install+0xe5c>
  90b93a:	0c6610        	slli	a6, a6, 20
  90b93d:	076601        	and	a6, a6, a7
  90b940:	064402        	or	a4, a4, a6
				   | set11nTries(series, 2)
				   | set11nTries(series, 3)
  90b943:	265215        	l32i	a6, a5, 84

	ads->ds_ctl0 = ds_ctl0;

	ads->ds_ctl2 = set11nTries(series, 0)
				   | set11nTries(series, 1)
				   | set11nTries(series, 2)
  90b946:	176a6f        	l32r	a7, 8e6304 <vdesc_module_install+0x12f4>
				   | set11nTries(series, 3)
  90b949:	046610        	slli	a6, a6, 28
  90b94c:	064402        	or	a4, a4, a6

	ads->ds_ctl0 = ds_ctl0;

	ads->ds_ctl2 = set11nTries(series, 0)
				   | set11nTries(series, 1)
				   | set11nTries(series, 2)
  90b94f:	865e      	l32i.n	a6, a5, 56
	ads->ds_ctl3 = set11nRate(series, 0)
				   | set11nRate(series, 1)
				   | set11nRate(series, 2)
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
  90b951:	c0c0      	movi.n	a12, 0

	ads->ds_ctl0 = ds_ctl0;

	ads->ds_ctl2 = set11nTries(series, 0)
				   | set11nTries(series, 1)
				   | set11nTries(series, 2)
  90b953:	086610        	slli	a6, a6, 24
  90b956:	076601        	and	a6, a6, a7
				   | set11nTries(series, 3)
				   | (durUpdateEn ? AR_DurUpdateEn : 0);
  90b959:	1769da        	l32r	a7, 8e60c4 <vdesc_module_install+0x10b4>
	ads->ds_ctl0 = ds_ctl0;

	ads->ds_ctl2 = set11nTries(series, 0)
				   | set11nTries(series, 1)
				   | set11nTries(series, 2)
				   | set11nTries(series, 3)
  90b95c:	064402        	or	a4, a4, a6
				   | (durUpdateEn ? AR_DurUpdateEn : 0);
  90b95f:	037339        	movnez	a3, a7, a3
  90b962:	043302        	or	a3, a3, a4
		ds_ctl0 = (ds_ctl0 & ~(AR_RTSEnable | AR_CTSEnable));
	}

	ads->ds_ctl0 = ds_ctl0;

	ads->ds_ctl2 = set11nTries(series, 0)
  90b965:	038457        	extui	a4, a3, 24, 8
  90b968:	242410        	s8i	a4, a2, 16
  90b96b:	030457        	extui	a4, a3, 16, 8
  90b96e:	242411        	s8i	a4, a2, 17
  90b971:	038447        	extui	a4, a3, 8, 8
  90b974:	242412        	s8i	a4, a2, 18
  90b977:	232413        	s8i	a3, a2, 19
				   | (durUpdateEn ? AR_DurUpdateEn : 0);

	ads->ds_ctl3 = set11nRate(series, 0)
				   | set11nRate(series, 1)
				   | set11nRate(series, 2)
				   | set11nRate(series, 3);
  90b97a:	245216        	l32i	a4, a5, 88
				   | set11nTries(series, 1)
				   | set11nTries(series, 2)
				   | set11nTries(series, 3)
				   | (durUpdateEn ? AR_DurUpdateEn : 0);

	ads->ds_ctl3 = set11nRate(series, 0)
  90b97d:	235007        	l8ui	a3, a5, 7
				   | set11nRate(series, 1)
				   | set11nRate(series, 2)
				   | set11nRate(series, 3);
  90b980:	084410        	slli	a4, a4, 24
  90b983:	043302        	or	a3, a3, a4
				   | set11nTries(series, 2)
				   | set11nTries(series, 3)
				   | (durUpdateEn ? AR_DurUpdateEn : 0);

	ads->ds_ctl3 = set11nRate(series, 0)
				   | set11nRate(series, 1)
  90b986:	8458      	l32i.n	a4, a5, 32
				   | set11nRate(series, 2)
  90b988:	166a70        	l32r	a6, 8e6348 <_xtos_set_exception_handler>
				   | set11nTries(series, 2)
				   | set11nTries(series, 3)
				   | (durUpdateEn ? AR_DurUpdateEn : 0);

	ads->ds_ctl3 = set11nRate(series, 0)
				   | set11nRate(series, 1)
  90b98b:	084411        	slli	a4, a4, 8
  90b98e:	04044f        	extui	a4, a4, 0, 16
				   | set11nRate(series, 2)
				   | set11nRate(series, 3);
  90b991:	043302        	or	a3, a3, a4
				   | set11nTries(series, 3)
				   | (durUpdateEn ? AR_DurUpdateEn : 0);

	ads->ds_ctl3 = set11nRate(series, 0)
				   | set11nRate(series, 1)
				   | set11nRate(series, 2)
  90b994:	845f      	l32i.n	a4, a5, 60
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
				   | set11nPktDurRTSCTS(series, 1);
  90b996:	1b6a71        	l32r	a11, 8e635c <_xtos_set_exception_handler+0x14>
				   | set11nTries(series, 3)
				   | (durUpdateEn ? AR_DurUpdateEn : 0);

	ads->ds_ctl3 = set11nRate(series, 0)
				   | set11nRate(series, 1)
				   | set11nRate(series, 2)
  90b999:	004411        	slli	a4, a4, 16
  90b99c:	064401        	and	a4, a4, a6
				   | set11nRate(series, 3);
  90b99f:	043302        	or	a3, a3, a4
				   | set11nTries(series, 1)
				   | set11nTries(series, 2)
				   | set11nTries(series, 3)
				   | (durUpdateEn ? AR_DurUpdateEn : 0);

	ads->ds_ctl3 = set11nRate(series, 0)
  90b9a2:	038457        	extui	a4, a3, 24, 8
  90b9a5:	242414        	s8i	a4, a2, 20
  90b9a8:	030457        	extui	a4, a3, 16, 8
  90b9ab:	242415        	s8i	a4, a2, 21
  90b9ae:	038447        	extui	a4, a3, 8, 8
  90b9b1:	242416        	s8i	a4, a2, 22
  90b9b4:	232417        	s8i	a3, a2, 23
				   | set11nRate(series, 1)
				   | set11nRate(series, 2)
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
  90b9b7:	8354      	l32i.n	a3, a5, 16
  90b9b9:	8652      	l32i.n	a6, a5, 8
  90b9bb:	030440        	extui	a4, a3, 0, 1
  90b9be:	06084e        	extui	a8, a6, 0, 15
  90b9c1:	d670      	mov.n	a6, a7
  90b9c3:	04c638        	moveqz	a6, a12, a4
  90b9c6:	d460      	mov.n	a4, a6
				   | set11nPktDurRTSCTS(series, 1);
  90b9c8:	8659      	l32i.n	a6, a5, 36
  90b9ca:	8a5b      	l32i.n	a10, a5, 44
  90b9cc:	006611        	slli	a6, a6, 16
  90b9cf:	0b6601        	and	a6, a6, a11
  90b9d2:	196a62        	l32r	a9, 8e635c <_xtos_set_exception_handler+0x14>
  90b9d5:	086602        	or	a6, a6, a8
  90b9d8:	0a0840        	extui	a8, a10, 0, 1
  90b9db:	08c938        	moveqz	a9, a12, a8
  90b9de:	064402        	or	a4, a4, a6
  90b9e1:	094402        	or	a4, a4, a9
	ads->ds_ctl3 = set11nRate(series, 0)
				   | set11nRate(series, 1)
				   | set11nRate(series, 2)
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
  90b9e4:	048657        	extui	a6, a4, 24, 8
  90b9e7:	262418        	s8i	a6, a2, 24
  90b9ea:	040657        	extui	a6, a4, 16, 8
  90b9ed:	262419        	s8i	a6, a2, 25
  90b9f0:	048647        	extui	a6, a4, 8, 8
  90b9f3:	26241a        	s8i	a6, a2, 26
  90b9f6:	24241b        	s8i	a4, a2, 27
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
  90b9f9:	285210        	l32i	a8, a5, 64
  90b9fc:	295212        	l32i	a9, a5, 72
  90b9ff:	08044e        	extui	a4, a8, 0, 15
				   | set11nPktDurRTSCTS(series, 3);
  90ba02:	285217        	l32i	a8, a5, 92
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
  90ba05:	090640        	extui	a6, a9, 0, 1
				   | set11nPktDurRTSCTS(series, 3);
  90ba08:	008811        	slli	a8, a8, 16
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
  90ba0b:	dd70      	mov.n	a13, a7
				   | set11nPktDurRTSCTS(series, 3);
  90ba0d:	0b8801        	and	a8, a8, a11
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
  90ba10:	06cd38        	moveqz	a13, a12, a6
  90ba13:	048802        	or	a8, a8, a4
				   | set11nPktDurRTSCTS(series, 3);
  90ba16:	245219        	l32i	a4, a5, 100
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
  90ba19:	d6d0      	mov.n	a6, a13
				   | set11nPktDurRTSCTS(series, 3);
  90ba1b:	1d6a62        	l32r	a13, 8e63a4 <_xtos_set_exception_handler+0x5c>
  90ba1e:	040b40        	extui	a11, a4, 0, 1
  90ba21:	0bcd38        	moveqz	a13, a12, a11
  90ba24:	086602        	or	a6, a6, a8
  90ba27:	0d6602        	or	a6, a6, a13
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
  90ba2a:	068857        	extui	a8, a6, 24, 8
  90ba2d:	28241c        	s8i	a8, a2, 28
  90ba30:	060857        	extui	a8, a6, 16, 8
  90ba33:	28241d        	s8i	a8, a2, 29
  90ba36:	26241f        	s8i	a6, a2, 31
  90ba39:	068847        	extui	a8, a6, 8, 8
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
  90ba3c:	032640        	extui	a6, a3, 2, 1
				   | set11nRate(series, 3);

	ads->ds_ctl4 = set11nPktDurRTSCTS(series, 0)
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
  90ba3f:	28241e        	s8i	a8, a2, 30
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
  90ba42:	0f6611        	slli	a6, a6, 1
  90ba45:	031840        	extui	a8, a3, 1, 1
  90ba48:	086602        	or	a6, a6, a8
  90ba4b:	1d6a6a        	l32r	a13, 8e63f4 <_xtos_set_exception_handler+0xac>
  90ba4e:	c088      	movi.n	a8, 8
  90ba50:	083301        	and	a3, a3, a8
  90ba53:	03cd38        	moveqz	a13, a12, a3
  90ba56:	06d602        	or	a6, a13, a6
  90ba59:	9610      	s32i.n	a6, a1, 0
  90ba5b:	8653      	l32i.n	a6, a5, 12
				   | set11nRateFlags(series, 1)
  90ba5d:	c0c2      	movi.n	a12, 2
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
  90ba5f:	c13c      	movi.n	a3, 28
  90ba61:	0e6611        	slli	a6, a6, 2
  90ba64:	036601        	and	a6, a6, a3
				   | set11nRateFlags(series, 1)
  90ba67:	c0b4      	movi.n	a11, 4
  90ba69:	0ca301        	and	a3, a10, a12
  90ba6c:	c2d0      	movi.n	a13, 32
  90ba6e:	0baf01        	and	a15, a10, a11
  90ba71:	03d339        	movnez	a3, a13, a3
  90ba74:	c4d0      	movi.n	a13, 64
  90ba76:	0fdf39        	movnez	a15, a13, a15
  90ba79:	1d6a61        	l32r	a13, 8e6400 <_xtos_set_exception_handler+0xb8>
  90ba7c:	08aa01        	and	a10, a10, a8
  90ba7f:	0ada39        	movnez	a10, a13, a10
  90ba82:	8d5a      	l32i.n	a13, a5, 40
  90ba84:	2e3a80        	movi	a14, 0x380
  90ba87:	09dd11        	slli	a13, a13, 7
  90ba8a:	0edd01        	and	a13, a13, a14
  90ba8d:	06dd02        	or	a13, a13, a6
				   | set11nRateFlags(series, 2)
  90ba90:	0c9e01        	and	a14, a9, a12
  90ba93:	264a00        	movi	a6, 0x400
  90ba96:	0e6e39        	movnez	a14, a6, a14
  90ba99:	166a6c        	l32r	a6, 8e644c <_xtos_set_exception_handler+0x104>
  90ba9c:	9d11      	s32i.n	a13, a1, 4
  90ba9e:	0b9d01        	and	a13, a9, a11
  90baa1:	0d6d39        	movnez	a13, a6, a13
  90baa4:	166a66        	l32r	a6, 8e643c <_xtos_set_exception_handler+0xf4>
  90baa7:	089901        	and	a9, a9, a8
  90baaa:	096939        	movnez	a9, a6, a9
  90baad:	265211        	l32i	a6, a5, 68
  90bab0:	1b6a72        	l32r	a11, 8e6478 <_xtos_set_exception_handler+0x130>
  90bab3:	046611        	slli	a6, a6, 12
  90bab6:	0b6601        	and	a6, a6, a11
				   | set11nRateFlags(series, 3)
  90bab9:	0c4c01        	and	a12, a4, a12
	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
				   | set11nRateFlags(series, 1)
				   | set11nRateFlags(series, 2)
  90babc:	9613      	s32i.n	a6, a1, 12
				   | set11nRateFlags(series, 3)
  90babe:	0c7c39        	movnez	a12, a7, a12
  90bac1:	c064      	movi.n	a6, 4
  90bac3:	1768fc        	l32r	a7, 8e5eb4 <vdesc_module_install+0xea4>
  90bac6:	064b01        	and	a11, a4, a6
  90bac9:	084801        	and	a8, a4, a8
				   | SM(rtsctsRate, AR_RTSCTSRate);
  90bacc:	8612      	l32i.n	a6, a1, 8
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
				   | set11nRateFlags(series, 1)
				   | set11nRateFlags(series, 2)
				   | set11nRateFlags(series, 3)
  90bace:	146a62        	l32r	a4, 8e6458 <_xtos_set_exception_handler+0x110>
  90bad1:	0b7b39        	movnez	a11, a7, a11
				   | SM(rtsctsRate, AR_RTSCTSRate);
  90bad4:	176a73        	l32r	a7, 8e64a0 <_xtos_set_exception_handler+0x158>
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
				   | set11nRateFlags(series, 1)
				   | set11nRateFlags(series, 2)
				   | set11nRateFlags(series, 3)
  90bad7:	084839        	movnez	a8, a4, a8
				   | SM(rtsctsRate, AR_RTSCTSRate);
  90bada:	0c6410        	slli	a4, a6, 20
  90badd:	8611      	l32i.n	a6, a1, 4
  90badf:	074401        	and	a4, a4, a7
  90bae2:	064402        	or	a4, a4, a6
  90bae5:	8613      	l32i.n	a6, a1, 12
  90bae7:	064702        	or	a7, a4, a6
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
				   | set11nRateFlags(series, 1)
				   | set11nRateFlags(series, 2)
				   | set11nRateFlags(series, 3)
  90baea:	245218        	l32i	a4, a5, 96
  90baed:	156a74        	l32r	a5, 8e64c0 <_xtos_set_exception_handler+0x178>
  90baf0:	0f4410        	slli	a4, a4, 17
  90baf3:	054401        	and	a4, a4, a5
				   | SM(rtsctsRate, AR_RTSCTSRate);
  90baf6:	047602        	or	a6, a7, a4
  90baf9:	8410      	l32i.n	a4, a1, 0
  90bafb:	046602        	or	a6, a6, a4
  90bafe:	036302        	or	a3, a6, a3
  90bb01:	0f3f02        	or	a15, a3, a15
  90bb04:	0afa02        	or	a10, a15, a10
  90bb07:	0eae02        	or	a14, a10, a14
  90bb0a:	0ded02        	or	a13, a14, a13
  90bb0d:	09d902        	or	a9, a13, a9
  90bb10:	0c9c02        	or	a12, a9, a12
  90bb13:	0bcb02        	or	a11, a12, a11
  90bb16:	08b802        	or	a8, a11, a8
				   | set11nPktDurRTSCTS(series, 1);

	ads->ds_ctl5 = set11nPktDurRTSCTS(series, 2)
				   | set11nPktDurRTSCTS(series, 3);

	ads->ds_ctl7 = set11nRateFlags(series, 0)
  90bb19:	088357        	extui	a3, a8, 24, 8
  90bb1c:	232424        	s8i	a3, a2, 36
  90bb1f:	080357        	extui	a3, a8, 16, 8
  90bb22:	232425        	s8i	a3, a2, 37
  90bb25:	088347        	extui	a3, a8, 8, 8
  90bb28:	232426        	s8i	a3, a2, 38
  90bb2b:	282427        	s8i	a8, a2, 39
  90bb2e:	d10f      	retw.n

0090bb30 <ar5416Set11nAggrFirst_20>:
				   | SM(rtsctsRate, AR_RTSCTSRate);
}

void ar5416Set11nAggrFirst_20(struct ath_tx_desc *ds, a_uint32_t aggrLen,
			      a_uint32_t numDelims)
{
  90bb30:	6c1004        	entry	a1, 32
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);
  90bb33:	29200c        	l8ui	a9, a2, 12

	ads->ds_ctl6 &= ~(AR_AggrLen | AR_PadDelim);
	ads->ds_ctl6 |= SM(aggrLen, AR_AggrLen) |
		SM(numDelims, AR_PadDelim);
  90bb36:	0e4410        	slli	a4, a4, 18
void ar5416Set11nAggrFirst_20(struct ath_tx_desc *ds, a_uint32_t aggrLen,
			      a_uint32_t numDelims)
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);
  90bb39:	089810        	slli	a8, a9, 24
  90bb3c:	29200d        	l8ui	a9, a2, 13

	ads->ds_ctl6 &= ~(AR_AggrLen | AR_PadDelim);
	ads->ds_ctl6 |= SM(aggrLen, AR_AggrLen) |
  90bb3f:	03034f        	extui	a3, a3, 0, 16
void ar5416Set11nAggrFirst_20(struct ath_tx_desc *ds, a_uint32_t aggrLen,
			      a_uint32_t numDelims)
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);
  90bb42:	009911        	slli	a9, a9, 16
  90bb45:	089902        	or	a9, a9, a8
  90bb48:	28200e        	l8ui	a8, a2, 14
  90bb4b:	088811        	slli	a8, a8, 8
  90bb4e:	098902        	or	a9, a8, a9
  90bb51:	28200f        	l8ui	a8, a2, 15
  90bb54:	098802        	or	a8, a8, a9
  90bb57:	196a75        	l32r	a9, 8e652c <_xtos_set_exception_handler+0x1e4>
  90bb5a:	098802        	or	a8, a8, a9
  90bb5d:	088957        	extui	a9, a8, 24, 8
  90bb60:	29240c        	s8i	a9, a2, 12
  90bb63:	080957        	extui	a9, a8, 16, 8
  90bb66:	29240d        	s8i	a9, a2, 13
  90bb69:	28240f        	s8i	a8, a2, 15
  90bb6c:	088947        	extui	a9, a8, 8, 8

	ads->ds_ctl6 &= ~(AR_AggrLen | AR_PadDelim);
	ads->ds_ctl6 |= SM(aggrLen, AR_AggrLen) |
		SM(numDelims, AR_PadDelim);
  90bb6f:	186a76        	l32r	a8, 8e6548 <_xtos_set_exception_handler+0x200>
void ar5416Set11nAggrFirst_20(struct ath_tx_desc *ds, a_uint32_t aggrLen,
			      a_uint32_t numDelims)
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);
  90bb72:	29240e        	s8i	a9, a2, 14

	ads->ds_ctl6 &= ~(AR_AggrLen | AR_PadDelim);
	ads->ds_ctl6 |= SM(aggrLen, AR_AggrLen) |
		SM(numDelims, AR_PadDelim);
  90bb75:	084401        	and	a4, a4, a8
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);

	ads->ds_ctl6 &= ~(AR_AggrLen | AR_PadDelim);
  90bb78:	282020        	l8ui	a8, a2, 32
	ads->ds_ctl6 |= SM(aggrLen, AR_AggrLen) |
  90bb7b:	034402        	or	a4, a4, a3
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);

	ads->ds_ctl6 &= ~(AR_AggrLen | AR_PadDelim);
  90bb7e:	088310        	slli	a3, a8, 24
  90bb81:	282021        	l8ui	a8, a2, 33
  90bb84:	008811        	slli	a8, a8, 16
  90bb87:	038802        	or	a8, a8, a3
  90bb8a:	232022        	l8ui	a3, a2, 34
  90bb8d:	083311        	slli	a3, a3, 8
  90bb90:	083802        	or	a8, a3, a8
  90bb93:	232023        	l8ui	a3, a2, 35
  90bb96:	083302        	or	a3, a3, a8
  90bb99:	186a77        	l32r	a8, 8e6578 <strcmp+0x18>
  90bb9c:	083301        	and	a3, a3, a8
	ads->ds_ctl6 |= SM(aggrLen, AR_AggrLen) |
  90bb9f:	034302        	or	a3, a4, a3
  90bba2:	038457        	extui	a4, a3, 24, 8
  90bba5:	242420        	s8i	a4, a2, 32
  90bba8:	030457        	extui	a4, a3, 16, 8
  90bbab:	242421        	s8i	a4, a2, 33
  90bbae:	038447        	extui	a4, a3, 8, 8
  90bbb1:	242422        	s8i	a4, a2, 34
  90bbb4:	232423        	s8i	a3, a2, 35
  90bbb7:	d10f      	retw.n
  90bbb9:	000000        	ill

0090bbbc <ar5416Set11nAggrMiddle_20>:
		SM(numDelims, AR_PadDelim);
}

void ar5416Set11nAggrMiddle_20(struct ath_tx_desc *ds, a_uint32_t numDelims)
{
  90bbbc:	6c1004        	entry	a1, 32
	struct ar5416_desc *ads = AR5416DESC(ds);
	a_uint32_t ctl6;

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);
  90bbbf:	29200c        	l8ui	a9, a2, 12
	 * We use a stack variable to manipulate ctl6 to reduce uncached 
	 * read modify, modfiy, write.
	 */
	ctl6 = ads->ds_ctl6;
	ctl6 &= ~AR_PadDelim;
	ctl6 |= SM(numDelims, AR_PadDelim);
  90bbc2:	0e3310        	slli	a3, a3, 18
void ar5416Set11nAggrMiddle_20(struct ath_tx_desc *ds, a_uint32_t numDelims)
{
	struct ar5416_desc *ads = AR5416DESC(ds);
	a_uint32_t ctl6;

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);
  90bbc5:	089810        	slli	a8, a9, 24
  90bbc8:	29200d        	l8ui	a9, a2, 13
  90bbcb:	009911        	slli	a9, a9, 16
  90bbce:	089902        	or	a9, a9, a8
  90bbd1:	28200e        	l8ui	a8, a2, 14
  90bbd4:	088811        	slli	a8, a8, 8
  90bbd7:	098902        	or	a9, a8, a9
  90bbda:	28200f        	l8ui	a8, a2, 15
  90bbdd:	098802        	or	a8, a8, a9
  90bbe0:	196a75        	l32r	a9, 8e65b4 <strcmp+0x54>
  90bbe3:	098802        	or	a8, a8, a9
  90bbe6:	088957        	extui	a9, a8, 24, 8
  90bbe9:	29240c        	s8i	a9, a2, 12
  90bbec:	080957        	extui	a9, a8, 16, 8
  90bbef:	29240d        	s8i	a9, a2, 13
  90bbf2:	088947        	extui	a9, a8, 8, 8
  90bbf5:	29240e        	s8i	a9, a2, 14

	/*
	 * We use a stack variable to manipulate ctl6 to reduce uncached 
	 * read modify, modfiy, write.
	 */
	ctl6 = ads->ds_ctl6;
  90bbf8:	292020        	l8ui	a9, a2, 32
void ar5416Set11nAggrMiddle_20(struct ath_tx_desc *ds, a_uint32_t numDelims)
{
	struct ar5416_desc *ads = AR5416DESC(ds);
	a_uint32_t ctl6;

	ads->ds_ctl1 |= (AR_IsAggr | AR_MoreAggr);
  90bbfb:	28240f        	s8i	a8, a2, 15

	/*
	 * We use a stack variable to manipulate ctl6 to reduce uncached 
	 * read modify, modfiy, write.
	 */
	ctl6 = ads->ds_ctl6;
  90bbfe:	089810        	slli	a8, a9, 24
  90bc01:	292021        	l8ui	a9, a2, 33
  90bc04:	009911        	slli	a9, a9, 16
  90bc07:	089902        	or	a9, a9, a8
  90bc0a:	282022        	l8ui	a8, a2, 34
  90bc0d:	088811        	slli	a8, a8, 8
  90bc10:	098902        	or	a9, a8, a9
  90bc13:	282023        	l8ui	a8, a2, 35
  90bc16:	098802        	or	a8, a8, a9
	ctl6 &= ~AR_PadDelim;
  90bc19:	196a78        	l32r	a9, 8e65fc <strcmp+0x9c>
  90bc1c:	098801        	and	a8, a8, a9
	ctl6 |= SM(numDelims, AR_PadDelim);
  90bc1f:	196a76        	l32r	a9, 8e65f8 <strcmp+0x98>
  90bc22:	093301        	and	a3, a3, a9
  90bc25:	083302        	or	a3, a3, a8
	ads->ds_ctl6 = ctl6;
  90bc28:	038857        	extui	a8, a3, 24, 8
  90bc2b:	282420        	s8i	a8, a2, 32
  90bc2e:	030857        	extui	a8, a3, 16, 8
  90bc31:	282421        	s8i	a8, a2, 33
  90bc34:	038847        	extui	a8, a3, 8, 8
  90bc37:	282422        	s8i	a8, a2, 34
  90bc3a:	232423        	s8i	a3, a2, 35
  90bc3d:	d10f      	retw.n
	...

0090bc40 <ar5416Set11nAggrLast_20>:
}

void ar5416Set11nAggrLast_20(struct ath_tx_desc *ds)
{
  90bc40:	6c1004        	entry	a1, 32
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 |= AR_IsAggr;
  90bc43:	29200c        	l8ui	a9, a2, 12
  90bc46:	089810        	slli	a8, a9, 24
  90bc49:	29200d        	l8ui	a9, a2, 13
  90bc4c:	009911        	slli	a9, a9, 16
  90bc4f:	089902        	or	a9, a9, a8
  90bc52:	28200e        	l8ui	a8, a2, 14
  90bc55:	088811        	slli	a8, a8, 8
  90bc58:	098902        	or	a9, a8, a9
  90bc5b:	28200f        	l8ui	a8, a2, 15
  90bc5e:	098802        	or	a8, a8, a9
	ads->ds_ctl1 &= ~AR_MoreAggr;
  90bc61:	196a79        	l32r	a9, 8e6648 <strcmp+0xe8>
  90bc64:	098801        	and	a8, a8, a9
  90bc67:	196a66        	l32r	a9, 8e6600 <strcmp+0xa0>
  90bc6a:	098802        	or	a8, a8, a9
  90bc6d:	088957        	extui	a9, a8, 24, 8
  90bc70:	29240c        	s8i	a9, a2, 12
  90bc73:	080957        	extui	a9, a8, 16, 8
  90bc76:	29240d        	s8i	a9, a2, 13
  90bc79:	088947        	extui	a9, a8, 8, 8
  90bc7c:	29240e        	s8i	a9, a2, 14
  90bc7f:	28240f        	s8i	a8, a2, 15
	ads->ds_ctl6 &= ~AR_PadDelim;
  90bc82:	292020        	l8ui	a9, a2, 32
  90bc85:	282021        	l8ui	a8, a2, 33
  90bc88:	089910        	slli	a9, a9, 24
  90bc8b:	008811        	slli	a8, a8, 16
  90bc8e:	098902        	or	a9, a8, a9
  90bc91:	282022        	l8ui	a8, a2, 34
  90bc94:	088811        	slli	a8, a8, 8
  90bc97:	098802        	or	a8, a8, a9
  90bc9a:	292023        	l8ui	a9, a2, 35
  90bc9d:	089902        	or	a9, a9, a8
  90bca0:	186a78        	l32r	a8, 8e6680 <strcmp+0x120>
  90bca3:	292423        	s8i	a9, a2, 35
  90bca6:	089801        	and	a8, a9, a8
  90bca9:	088a57        	extui	a10, a8, 24, 8
  90bcac:	2a2420        	s8i	a10, a2, 32
  90bcaf:	080a57        	extui	a10, a8, 16, 8
  90bcb2:	088847        	extui	a8, a8, 8, 8
  90bcb5:	2a2421        	s8i	a10, a2, 33
  90bcb8:	282422        	s8i	a8, a2, 34
  90bcbb:	d10f      	retw.n
  90bcbd:	000000        	ill

0090bcc0 <ar5416Clr11nAggr_20>:
}

void ar5416Clr11nAggr_20(struct ath_tx_desc *ds)
{
  90bcc0:	6c1004        	entry	a1, 32
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl1 &= (~AR_IsAggr & ~AR_MoreAggr);
  90bcc3:	29200c        	l8ui	a9, a2, 12
  90bcc6:	28200d        	l8ui	a8, a2, 13
  90bcc9:	089910        	slli	a9, a9, 24
  90bccc:	008811        	slli	a8, a8, 16
  90bccf:	098902        	or	a9, a8, a9
  90bcd2:	28200e        	l8ui	a8, a2, 14
  90bcd5:	088811        	slli	a8, a8, 8
  90bcd8:	098802        	or	a8, a8, a9
  90bcdb:	29200f        	l8ui	a9, a2, 15
  90bcde:	089902        	or	a9, a9, a8
  90bce1:	186a7a        	l32r	a8, 8e66cc <strcmp+0x16c>
  90bce4:	29240f        	s8i	a9, a2, 15
  90bce7:	089801        	and	a8, a9, a8
  90bcea:	088a57        	extui	a10, a8, 24, 8
  90bced:	2a240c        	s8i	a10, a2, 12
  90bcf0:	080a57        	extui	a10, a8, 16, 8
  90bcf3:	088847        	extui	a8, a8, 8, 8
  90bcf6:	2a240d        	s8i	a10, a2, 13
  90bcf9:	28240e        	s8i	a8, a2, 14
  90bcfc:	d10f      	retw.n
	...

0090bd00 <ar5416Set11nBurstDuration_20>:
}

void ar5416Set11nBurstDuration_20(struct ath_tx_desc *ds,
				  a_uint32_t burstDuration)
{
  90bd00:	6c1004        	entry	a1, 32
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl2 &= ~AR_BurstDur;
  90bd03:	292010        	l8ui	a9, a2, 16
	ads->ds_ctl2 |= SM(burstDuration, AR_BurstDur);
  90bd06:	03034e        	extui	a3, a3, 0, 15
void ar5416Set11nBurstDuration_20(struct ath_tx_desc *ds,
				  a_uint32_t burstDuration)
{
	struct ar5416_desc *ads = AR5416DESC(ds);

	ads->ds_ctl2 &= ~AR_BurstDur;
  90bd09:	089810        	slli	a8, a9, 24
  90bd0c:	292011        	l8ui	a9, a2, 17
  90bd0f:	009911        	slli	a9, a9, 16
  90bd12:	089902        	or	a9, a9, a8
  90bd15:	282012        	l8ui	a8, a2, 18
  90bd18:	088811        	slli	a8, a8, 8
  90bd1b:	098902        	or	a9, a8, a9
  90bd1e:	282013        	l8ui	a8, a2, 19
  90bd21:	098802        	or	a8, a8, a9
  90bd24:	196a7b        	l32r	a9, 8e6710 <strcmp+0x1b0>
  90bd27:	098801        	and	a8, a8, a9
	ads->ds_ctl2 |= SM(burstDuration, AR_BurstDur);
  90bd2a:	038302        	or	a3, a8, a3
  90bd2d:	038857        	extui	a8, a3, 24, 8
  90bd30:	282410        	s8i	a8, a2, 16
  90bd33:	030857        	extui	a8, a3, 16, 8
  90bd36:	282411        	s8i	a8, a2, 17
  90bd39:	038847        	extui	a8, a3, 8, 8
  90bd3c:	282412        	s8i	a8, a2, 18
  90bd3f:	232413        	s8i	a3, a2, 19
  90bd42:	d10f      	retw.n

0090bd44 <ar5416Set11nVirtualMoreFrag_20>:
}

void ar5416Set11nVirtualMoreFrag_20(struct ath_tx_desc *ds,
				    a_uint32_t vmf)
{
  90bd44:	6c1004        	entry	a1, 32
  90bd47:	2b2008        	l8ui	a11, a2, 8
  90bd4a:	2a2009        	l8ui	a10, a2, 9
  90bd4d:	29200a        	l8ui	a9, a2, 10
  90bd50:	2c200b        	l8ui	a12, a2, 11
	struct ar5416_desc *ads = AR5416DESC(ds);

	if (vmf) {
  90bd53:	ca3d      	beqz.n	a3, 90bd84 <ar5416Set11nVirtualMoreFrag_20+0x40>
		ads->ds_ctl0 |= AR_VirtMoreFrag;
  90bd55:	08b810        	slli	a8, a11, 24
  90bd58:	00aa11        	slli	a10, a10, 16
  90bd5b:	08aa02        	or	a10, a10, a8
  90bd5e:	089811        	slli	a8, a9, 8
  90bd61:	0a8802        	or	a8, a8, a10
  90bd64:	196a38        	l32r	a9, 8e6644 <strcmp+0xe4>
  90bd67:	08c802        	or	a8, a12, a8
  90bd6a:	098802        	or	a8, a8, a9
  90bd6d:	088957        	extui	a9, a8, 24, 8
  90bd70:	292408        	s8i	a9, a2, 8
  90bd73:	080957        	extui	a9, a8, 16, 8
  90bd76:	292409        	s8i	a9, a2, 9
  90bd79:	088947        	extui	a9, a8, 8, 8
  90bd7c:	29240a        	s8i	a9, a2, 10
  90bd7f:	28240b        	s8i	a8, a2, 11
  90bd82:	d10f      	retw.n
	} else {
		ads->ds_ctl0 &= ~AR_VirtMoreFrag;
  90bd84:	08bb10        	slli	a11, a11, 24
  90bd87:	00aa11        	slli	a10, a10, 16
  90bd8a:	0baa02        	or	a10, a10, a11
  90bd8d:	089911        	slli	a9, a9, 8
  90bd90:	0a9902        	or	a9, a9, a10
  90bd93:	1a6a7c        	l32r	a10, 8e6784 <strcmp+0x224>
  90bd96:	09c902        	or	a9, a12, a9
  90bd99:	0a9a01        	and	a10, a9, a10
  90bd9c:	0a8857        	extui	a8, a10, 24, 8
  90bd9f:	282408        	s8i	a8, a2, 8
  90bda2:	0a0857        	extui	a8, a10, 16, 8
  90bda5:	0a8a47        	extui	a10, a10, 8, 8
  90bda8:	282409        	s8i	a8, a2, 9
  90bdab:	2a240a        	s8i	a10, a2, 10
  90bdae:	29240b        	s8i	a9, a2, 11
  90bdb1:	d10f      	retw.n
	...

0090bdb4 <ar5416Detach>:
		.ah_setInterrupts        = ar5416SetInterrupts,
	},
};

void ar5416Detach(struct ath_hal *ah)
{
  90bdb4:	6c1004        	entry	a1, 32
	HALASSERT(ah != AH_NULL);
	ath_hal_free(ah);
  90bdb7:	da20      	mov.n	a10, a2
  90bdb9:	5bef48        	call8	907adc <ath_hal_free>
  90bdbc:	d10f      	retw.n
	...

0090bdc0 <ar5416StopDmaReceive>:
	iowrite32_mac(AR_RXDP, rxdp);
	HALASSERT(ioread32_mac(AR_RXDP) == rxdp);
}

HAL_BOOL ar5416StopDmaReceive(struct ath_hal *ah)
{
  90bdc0:	6c1004        	entry	a1, 32
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90bdc3:	186a59        	l32r	a8, 8e6728 <strcmp+0x1c8>
  90bdc6:	c290      	movi.n	a9, 32
  90bdc8:	0c0200        	memw
  90bdcb:	9980      	s32i.n	a9, a8, 0
	iowrite32_mac(AR_CR, AR_CR_RXD); /* Set receive disable bit */
	if (!ath_hal_wait(ah, AR_CR, AR_CR_RXE, 0)) {
  90bdcd:	c0d0      	movi.n	a13, 0
  90bdcf:	c0c4      	movi.n	a12, 4
  90bdd1:	c0b8      	movi.n	a11, 8
  90bdd3:	da20      	mov.n	a10, a2
  90bdd5:	5bfbf0        	call8	90ad98 <ath_hal_wait>
  90bdd8:	c081      	movi.n	a8, 1
  90bdda:	c020      	movi.n	a2, 0
  90bddc:	0a8239        	movnez	a2, a8, a10
		return AH_FALSE;
	} else {
		return AH_TRUE;
	}
}
  90bddf:	d10f      	retw.n
  90bde1:	000000        	ill

0090bde4 <ar5416AbortTxDma>:
#endif
        return npend;
}

HAL_BOOL ar5416AbortTxDma(struct ath_hal *ah)
{
  90bde4:	6c1004        	entry	a1, 32
  90bde7:	136a7d        	l32r	a3, 8e67dc <strcmp+0x27c>
  90bdea:	243aff        	movi	a4, 0x3ff
  90bded:	0c0200        	memw
  90bdf0:	9430      	s32i.n	a4, a3, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90bdf2:	146a7e        	l32r	a4, 8e67ec <strcmp+0x28c>
	iowrite32_mac(AR_Q_TXD, AR_Q_TXD_M);

	/*
	 * set tx abort bits
	 */
	OS_REG_SET_BIT(ah, AR_PCU_MISC, (AR_PCU_FORCE_QUIET_COLL | AR_PCU_CLEAR_VMF));
  90bdf5:	156a7f        	l32r	a5, 8e67f4 <strcmp+0x294>
  90bdf8:	0c0200        	memw
  90bdfb:	8340      	l32i.n	a3, a4, 0
  90bdfd:	053302        	or	a3, a3, a5
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90be00:	0c0200        	memw
  90be03:	9340      	s32i.n	a3, a4, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90be05:	146a5a        	l32r	a4, 8e6770 <strcmp+0x210>
	OS_REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_FORCE_CH_IDLE_HIGH);
  90be08:	156a63        	l32r	a5, 8e6794 <strcmp+0x234>
  90be0b:	0c0200        	memw
  90be0e:	8340      	l32i.n	a3, a4, 0
  90be10:	053302        	or	a3, a3, a5
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90be13:	0c0200        	memw
  90be16:	9340      	s32i.n	a3, a4, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90be18:	146a80        	l32r	a4, 8e6818 <strcmp+0x2b8>
	OS_REG_SET_BIT(ah, AR_D_GBL_IFS_MISC, AR_D_GBL_IFS_MISC_IGNORE_BACKOFF);
  90be1b:	156a6a        	l32r	a5, 8e67c4 <strcmp+0x264>
  90be1e:	0c0200        	memw
  90be21:	8340      	l32i.n	a3, a4, 0
  90be23:	053302        	or	a3, a3, a5
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90be26:	0c0200        	memw
  90be29:	9340      	s32i.n	a3, a4, 0
	for (q = 0; q < AR_NUM_QCU; q++) {
		for (i = 0; i < AR5416_ABORT_LOOPS; i++) {
			if (!ar5416NumTxPending(ah, q))
				break;

			OS_DELAY(AR5416_ABORT_WAIT);
  90be2b:	c055      	movi.n	a5, 5
	OS_REG_SET_BIT(ah, AR_D_GBL_IFS_MISC, AR_D_GBL_IFS_MISC_IGNORE_BACKOFF);

	/*
	 * wait on all tx queues
	 */
	for (q = 0; q < AR_NUM_QCU; q++) {
  90be2d:	c040      	movi.n	a4, 0
  90be2f:	600019        	j	90be4c <ar5416AbortTxDma+0x68>
		for (i = 0; i < AR5416_ABORT_LOOPS; i++) {
			if (!ar5416NumTxPending(ah, q))
  90be32:	db40      	mov.n	a11, a4
  90be34:	da20      	mov.n	a10, a2
  90be36:	5bfcdc        	call8	90b1a8 <ar5416NumTxPending>
  90be39:	64a05b        	beqz	a10, 90be98 <ar5416AbortTxDma+0xb4>
				break;

			OS_DELAY(AR5416_ABORT_WAIT);
  90be3c:	da50      	mov.n	a10, a5
  90be3e:	233cff        	addi	a3, a3, -1
  90be41:	5bef19        	call8	907aa8 <ath_hal_delay>

	/*
	 * wait on all tx queues
	 */
	for (q = 0; q < AR_NUM_QCU; q++) {
		for (i = 0; i < AR5416_ABORT_LOOPS; i++) {
  90be44:	653fea        	bnez	a3, 90be32 <ar5416AbortTxDma+0x4e>
				break;

			OS_DELAY(AR5416_ABORT_WAIT);
		}
		if (i == AR5416_ABORT_LOOPS) {
			return AH_FALSE;
  90be47:	d230      	mov.n	a2, a3
  90be49:	d10f      	retw.n
  90be4b:	00233a        	movltz	a3, a2, a0
#endif
        return npend;
}

HAL_BOOL ar5416AbortTxDma(struct ath_hal *ah)
{
  90be4e:	e8          	.byte 0xe8
  90be4f:	63ffdf        	j	90be32 <ar5416AbortTxDma+0x4e>
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90be52:	136a7e        	l32r	a3, 8e684c <strcmp+0x2ec>
	}

	/*
	 * clear tx abort bits
	 */
	OS_REG_CLR_BIT(ah, AR_PCU_MISC, (AR_PCU_FORCE_QUIET_COLL | AR_PCU_CLEAR_VMF));
  90be55:	146a81        	l32r	a4, 8e685c <strcmp+0x2fc>
  90be58:	0c0200        	memw
  90be5b:	8230      	l32i.n	a2, a3, 0
  90be5d:	042201        	and	a2, a2, a4
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90be60:	0c0200        	memw
  90be63:	9230      	s32i.n	a2, a3, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90be65:	136a5a        	l32r	a3, 8e67d0 <strcmp+0x270>
	OS_REG_CLR_BIT(ah, AR_DIAG_SW, AR_DIAG_FORCE_CH_IDLE_HIGH);
  90be68:	146a6d        	l32r	a4, 8e681c <strcmp+0x2bc>
  90be6b:	0c0200        	memw
  90be6e:	8230      	l32i.n	a2, a3, 0
  90be70:	042201        	and	a2, a2, a4
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90be73:	0c0200        	memw
  90be76:	9230      	s32i.n	a2, a3, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90be78:	136a80        	l32r	a3, 8e6878 <strcmp+0x318>
	OS_REG_CLR_BIT(ah, AR_D_GBL_IFS_MISC, AR_D_GBL_IFS_MISC_IGNORE_BACKOFF);
  90be7b:	146a82        	l32r	a4, 8e6884 <strcmp+0x324>
  90be7e:	0c0200        	memw
  90be81:	8230      	l32i.n	a2, a3, 0
  90be83:	042201        	and	a2, a2, a4
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90be86:	0c0200        	memw
  90be89:	9230      	s32i.n	a2, a3, 0
  90be8b:	126a7d        	l32r	a2, 8e6880 <strcmp+0x320>
  90be8e:	0c0200        	memw
  90be91:	9a20      	s32i.n	a10, a2, 0
	/*
	 * clear txd
	 */
	iowrite32_mac(AR_Q_TXD, 0);

	return AH_TRUE;
  90be93:	c021      	movi.n	a2, 1
  90be95:	d10f      	retw.n
  90be97:	00b144        	extui	a1, a0, 11, 5
	OS_REG_SET_BIT(ah, AR_D_GBL_IFS_MISC, AR_D_GBL_IFS_MISC_IGNORE_BACKOFF);

	/*
	 * wait on all tx queues
	 */
	for (q = 0; q < AR_NUM_QCU; q++) {
  90be9a:	6949ae        	bnei	a4, 10, 90be4c <ar5416AbortTxDma+0x68>
  90be9d:	63ffb1        	j	90be52 <ar5416AbortTxDma+0x6e>

0090bea0 <ar5416StopTxDma>:

	return AH_TRUE;
}

HAL_BOOL ar5416StopTxDma(struct ath_hal*ah, a_uint32_t q)
{
  90bea0:	6c1004        	entry	a1, 32
  90bea3:	156a7d        	l32r	a5, 8e6898 <strcmp+0x338>
	
        HALASSERT(q < AH_PRIVATE(ah)->ah_caps.halTotalQueues);

        HALASSERT(AH5416(ah)->ah_txq[q].tqi_type != HAL_TX_QUEUE_INACTIVE);

	iowrite32_mac(AR_Q_TXD, 1 << q);
  90bea6:	c041      	movi.n	a4, 1
  90bea8:	003104        	ssl	a3
  90beab:	00441a        	sll	a4, a4
  90beae:	0c0200        	memw
  90beb1:	9450      	s32i.n	a4, a5, 0
        for (i = 1000; i != 0; i--) {
  90beb3:	243ae8        	movi	a4, 0x3e8
                if (ar5416NumTxPending(ah, q) == 0)
                        break;
                OS_DELAY(100);        /* XXX get actual value */
  90beb6:	250a64        	movi	a5, 100

        HALASSERT(AH5416(ah)->ah_txq[q].tqi_type != HAL_TX_QUEUE_INACTIVE);

	iowrite32_mac(AR_Q_TXD, 1 << q);
        for (i = 1000; i != 0; i--) {
                if (ar5416NumTxPending(ah, q) == 0)
  90beb9:	db30      	mov.n	a11, a3
  90bebb:	da20      	mov.n	a10, a2
  90bebd:	5bfcba        	call8	90b1a8 <ar5416NumTxPending>
  90bec0:	c8a8      	beqz.n	a10, 90becc <ar5416StopTxDma+0x2c>
                        break;
                OS_DELAY(100);        /* XXX get actual value */
  90bec2:	da50      	mov.n	a10, a5
        HALASSERT(q < AH_PRIVATE(ah)->ah_caps.halTotalQueues);

        HALASSERT(AH5416(ah)->ah_txq[q].tqi_type != HAL_TX_QUEUE_INACTIVE);

	iowrite32_mac(AR_Q_TXD, 1 << q);
        for (i = 1000; i != 0; i--) {
  90bec4:	b044      	addi.n	a4, a4, -1
                if (ar5416NumTxPending(ah, q) == 0)
                        break;
                OS_DELAY(100);        /* XXX get actual value */
  90bec6:	5beef8        	call8	907aa8 <ath_hal_delay>
        HALASSERT(q < AH_PRIVATE(ah)->ah_caps.halTotalQueues);

        HALASSERT(AH5416(ah)->ah_txq[q].tqi_type != HAL_TX_QUEUE_INACTIVE);

	iowrite32_mac(AR_Q_TXD, 1 << q);
        for (i = 1000; i != 0; i--) {
  90bec9:	654fec        	bnez	a4, 90beb9 <ar5416StopTxDma+0x19>
  90becc:	136a7d        	l32r	a3, 8e68c0 <strcmp+0x360>
  90becf:	c020      	movi.n	a2, 0
  90bed1:	0c0200        	memw
  90bed4:	9230      	s32i.n	a2, a3, 0
                        break;
                OS_DELAY(100);        /* XXX get actual value */
        }

	iowrite32_mac(AR_Q_TXD, 0);
        return (i != 0);
  90bed6:	c031      	movi.n	a3, 1
  90bed8:	043239        	movnez	a2, a3, a4
}
  90bedb:	d10f      	retw.n
  90bedd:	000000        	ill

0090bee0 <ar5416GetPendingInterrupts>:
	 */
	return ((host_isr != AR_INTR_SPURIOUS) && (host_isr & AR_INTR_MAC_IRQ));
}

HAL_BOOL ar5416GetPendingInterrupts(struct ath_hal *ah, HAL_INT *masked)
{
  90bee0:	6c1004        	entry	a1, 32
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90bee3:	186a4c        	l32r	a8, 8e6814 <strcmp+0x2b4>
  90bee6:	0c0200        	memw
  90bee9:	8880      	l32i.n	a8, a8, 0
	a_uint32_t isr;
#ifndef AR9100
	HAL_BOOL fatal_int = AH_FALSE;
	a_uint32_t sync_cause;

	if (ioread32_mac(AR_INTR_ASYNC_CAUSE)
  90beeb:	7e870d        	bbci	a8, 30, 90befc <ar5416GetPendingInterrupts+0x1c>
  90beee:	186a83        	l32r	a8, 8e68fc <strcmp+0x39c>
  90bef1:	0c0200        	memw
  90bef4:	8880      	l32i.n	a8, a8, 0
			& AR_INTR_MAC_IRQ) {
		if ((ioread32_mac(AR_RTC_STATUS)
				& AR_RTC_STATUS_M) != AR_RTC_STATUS_ON) {
  90bef6:	080843        	extui	a8, a8, 0, 4
	HAL_BOOL fatal_int = AH_FALSE;
	a_uint32_t sync_cause;

	if (ioread32_mac(AR_INTR_ASYNC_CAUSE)
			& AR_INTR_MAC_IRQ) {
		if ((ioread32_mac(AR_RTC_STATUS)
  90bef9:	688208        	beqi	a8, 2, 90bf05 <ar5416GetPendingInterrupts+0x25>
				& AR_RTC_STATUS_M) != AR_RTC_STATUS_ON) {
			*masked = 0;
  90befc:	c020      	movi.n	a2, 0
  90befe:	9230      	s32i.n	a2, a3, 0
			return AH_FALSE;
  90bf00:	d10f      	retw.n
  90bf02:	000000        	ill
  90bf05:	186a84        	l32r	a8, 8e6918 <strcmp+0x3b8>
  90bf08:	0c0200        	memw
  90bf0b:	8980      	l32i.n	a9, a8, 0
		*masked = 0;
		return AH_FALSE;
	}
#endif
	isr = ioread32_mac(AR_ISR_RAC);
	if (isr == 0xffffffff) {
  90bf0d:	6890eb        	beqi	a9, -1, 90befc <ar5416GetPendingInterrupts+0x1c>
		*masked = 0;
		return AH_FALSE;
	}

	*masked = isr & HAL_INT_COMMON;
  90bf10:	186a4e        	l32r	a8, 8e6848 <strcmp+0x2e8>
	if (isr & (AR_ISR_TXMINTR | AR_ISR_TXINTM)) {
		*masked |= HAL_INT_TX;
	}
#endif

	if (isr & AR_ISR_BCNMISC) {
  90bf13:	1b6a50        	l32r	a11, 8e6854 <strcmp+0x2f4>
	if (isr == 0xffffffff) {
		*masked = 0;
		return AH_FALSE;
	}

	*masked = isr & HAL_INT_COMMON;
  90bf16:	089801        	and	a8, a9, a8
  90bf19:	9830      	s32i.n	a8, a3, 0
	if (isr & (AR_ISR_TXMINTR | AR_ISR_TXINTM)) {
		*masked |= HAL_INT_TX;
	}
#endif

	if (isr & AR_ISR_BCNMISC) {
  90bf1b:	7b901f        	bnone	a9, a11, 90bf3e <ar5416GetPendingInterrupts+0x5e>
  90bf1e:	1a6a85        	l32r	a10, 8e6934 <strcmp+0x3d4>
  90bf21:	0c0200        	memw
  90bf24:	8aa0      	l32i.n	a10, a10, 0
		a_uint32_t s2_s;

		s2_s = ioread32_mac(AR_ISR_S2_S);

		if (s2_s & AR_ISR_S2_GTT) {
  90bf26:	7ba007        	bnone	a10, a11, 90bf31 <ar5416GetPendingInterrupts+0x51>
			*masked |= HAL_INT_GTT;
  90bf29:	1b6a61        	l32r	a11, 8e68b0 <strcmp+0x350>
  90bf2c:	0b8802        	or	a8, a8, a11
  90bf2f:	9830      	s32i.n	a8, a3, 0
		}

		if (s2_s & AR_ISR_S2_CST) {
  90bf31:	79a609        	bbci	a10, 9, 90bf3e <ar5416GetPendingInterrupts+0x5e>
			*masked |= HAL_INT_CST;
  90bf34:	8830      	l32i.n	a8, a3, 0
  90bf36:	1a69c9        	l32r	a10, 8e665c <strcmp+0xfc>
  90bf39:	0a8802        	or	a8, a8, a10
  90bf3c:	9830      	s32i.n	a8, a3, 0
		}
	}

	if (isr & (AR_ISR_RXOK | AR_ISR_RXERR))
  90bf3e:	c085      	movi.n	a8, 5
  90bf40:	789008        	bnone	a9, a8, 90bf4c <ar5416GetPendingInterrupts+0x6c>
		*masked |= HAL_INT_RX;
  90bf43:	8830      	l32i.n	a8, a3, 0
  90bf45:	c0a1      	movi.n	a10, 1
  90bf47:	0a8802        	or	a8, a8, a10
  90bf4a:	9830      	s32i.n	a8, a3, 0
	if (isr & (AR_ISR_TXOK | AR_ISR_TXDESC | AR_ISR_TXERR | AR_ISR_TXEOL)) {
  90bf4c:	285ac0        	movi	a8, 0x5c0
  90bf4f:	789035        	bnone	a9, a8, 90bf88 <ar5416GetPendingInterrupts+0xa8>
		struct ath_hal_5416 *ahp = AH5416(ah);
		a_uint32_t           s0_s, s1_s;

		*masked |= HAL_INT_TX;
  90bf52:	8830      	l32i.n	a8, a3, 0
  90bf54:	c490      	movi.n	a9, 64
  90bf56:	098802        	or	a8, a8, a9
  90bf59:	283600        	s32i	a8, a3, 0
  90bf5c:	136a86        	l32r	a3, 8e6974 <xthal_get_ccount+0x1c>
  90bf5f:	0c0200        	memw
  90bf62:	8930      	l32i.n	a9, a3, 0
  90bf64:	136a87        	l32r	a3, 8e6980 <xthal_get_intenable>
  90bf67:	0c0200        	memw
  90bf6a:	283200        	l32i	a8, a3, 0
		s0_s = ioread32_mac(AR_ISR_S0_S);
		s1_s = ioread32_mac(AR_ISR_S1_S);
		ahp->ah_intrTxqs |= MS(s0_s, AR_ISR_S0_QCU_TXOK);
		ahp->ah_intrTxqs |= MS(s0_s, AR_ISR_S0_QCU_TXDESC);
		ahp->ah_intrTxqs |= MS(s1_s, AR_ISR_S1_QCU_TXERR);
		ahp->ah_intrTxqs |= MS(s1_s, AR_ISR_S1_QCU_TXEOL);
  90bf6d:	089302        	or	a3, a9, a8

		*masked |= HAL_INT_TX;
		s0_s = ioread32_mac(AR_ISR_S0_S);
		s1_s = ioread32_mac(AR_ISR_S1_S);
		ahp->ah_intrTxqs |= MS(s0_s, AR_ISR_S0_QCU_TXOK);
		ahp->ah_intrTxqs |= MS(s0_s, AR_ISR_S0_QCU_TXDESC);
  90bf70:	09095f        	extui	a9, a9, 16, 16
		ahp->ah_intrTxqs |= MS(s1_s, AR_ISR_S1_QCU_TXERR);
		ahp->ah_intrTxqs |= MS(s1_s, AR_ISR_S1_QCU_TXEOL);
  90bf73:	08085f        	extui	a8, a8, 16, 16
  90bf76:	093302        	or	a3, a3, a9
  90bf79:	083302        	or	a3, a3, a8
  90bf7c:	282239        	l32i	a8, a2, 228
  90bf7f:	030349        	extui	a3, a3, 0, 10
  90bf82:	038302        	or	a3, a8, a3
  90bf85:	232639        	s32i	a3, a2, 228
  90bf88:	136a88        	l32r	a3, 8e69a8 <__divsi3+0x10>
	if (AH_TRUE == fatal_int) {
		iowrite32_mac(AR_INTR_SYNC_CAUSE_CLR, sync_cause);
		(void) ioread32_mac(AR_INTR_SYNC_CAUSE_CLR);
	}
#endif
	return AH_TRUE;
  90bf8b:	c021      	movi.n	a2, 1
  90bf8d:	0c0200        	memw
  90bf90:	8830      	l32i.n	a8, a3, 0

#ifndef AR9100
	sync_cause = ioread32_mac(AR_INTR_SYNC_CAUSE);
	fatal_int = ((sync_cause != AR_INTR_SPURIOUS) &&
		     (sync_cause & (AR_INTR_SYNC_HOST1_FATAL
		      | AR_INTR_SYNC_HOST1_PERR))) ? AH_TRUE : AH_FALSE;
  90bf92:	68800f        	beqi	a8, -1, 90bfa5 <ar5416GetPendingInterrupts+0xc5>
	}

#ifndef AR9100
	sync_cause = ioread32_mac(AR_INTR_SYNC_CAUSE);
	fatal_int = ((sync_cause != AR_INTR_SPURIOUS) &&
		     (sync_cause & (AR_INTR_SYNC_HOST1_FATAL
  90bf95:	290a60        	movi	a9, 96
		      | AR_INTR_SYNC_HOST1_PERR))) ? AH_TRUE : AH_FALSE;
  90bf98:	798009        	bnone	a8, a9, 90bfa5 <ar5416GetPendingInterrupts+0xc5>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90bf9b:	0c0200        	memw
  90bf9e:	9830      	s32i.n	a8, a3, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90bfa0:	0c0200        	memw
  90bfa3:	8330      	l32i.n	a3, a3, 0
		iowrite32_mac(AR_INTR_SYNC_CAUSE_CLR, sync_cause);
		(void) ioread32_mac(AR_INTR_SYNC_CAUSE_CLR);
	}
#endif
	return AH_TRUE;
}
  90bfa5:	d10f      	retw.n
	...

0090bfa8 <ar5416SetRxFilter>:
		return AH_TRUE;
	}
}

void ar5416SetRxFilter(struct ath_hal *ah, a_uint32_t bits)
{
  90bfa8:	6c1004        	entry	a1, 32
	a_uint32_t phybits;
    
	iowrite32_mac(AR_RX_FILTER, (bits & 0xff) | AR_RX_COMPR_BAR);
  90bfab:	294a00        	movi	a9, 0x400
  90bfae:	030847        	extui	a8, a3, 0, 8
  90bfb1:	098802        	or	a8, a8, a9
  90bfb4:	196a89        	l32r	a9, 8e69d8 <__divsi3+0x40>
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90bfb7:	0c0200        	memw
  90bfba:	9890      	s32i.n	a8, a9, 0
	phybits = 0;
	if (bits & HAL_RX_FILTER_PHYRADAR)
  90bfbc:	1869aa        	l32r	a8, 8e6664 <strcmp+0x104>
		phybits |= AR_PHY_ERR_RADAR;
  90bfbf:	c290      	movi.n	a9, 32
{
	a_uint32_t phybits;
    
	iowrite32_mac(AR_RX_FILTER, (bits & 0xff) | AR_RX_COMPR_BAR);
	phybits = 0;
	if (bits & HAL_RX_FILTER_PHYRADAR)
  90bfc1:	083801        	and	a8, a3, a8
		phybits |= AR_PHY_ERR_RADAR;
  90bfc4:	089839        	movnez	a8, a9, a8
	if (bits & HAL_RX_FILTER_PHYERR)
  90bfc7:	773705        	bbci	a3, 23, 90bfd0 <ar5416SetRxFilter+0x28>
		phybits |= AR_PHY_ERR_OFDM_TIMING | AR_PHY_ERR_CCK_TIMING;
  90bfca:	136a8a        	l32r	a3, 8e69f4 <__divsi3+0x5c>
  90bfcd:	038802        	or	a8, a8, a3
  90bfd0:	136a8b        	l32r	a3, 8e69fc <__divsi3+0x64>
  90bfd3:	196a8c        	l32r	a9, 8e6a04 <__divsi3+0x6c>
  90bfd6:	0c0200        	memw
  90bfd9:	9830      	s32i.n	a8, a3, 0
	iowrite32_mac(AR_PHY_ERR, phybits);
	if (phybits) {
  90bfdb:	c88d      	beqz.n	a8, 90bfec <ar5416SetRxFilter+0x44>
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90bfdd:	0c0200        	memw
  90bfe0:	8890      	l32i.n	a8, a9, 0
		iowrite32_mac(AR_RXCFG,
  90bfe2:	c130      	movi.n	a3, 16
  90bfe4:	038802        	or	a8, a8, a3
  90bfe7:	60000b        	j	90bff6 <ar5416SetRxFilter+0x4e>
  90bfea:	00000c        	sub	a0, a0, a0
  90bfed:	020088        	excw
  90bff0:	90c6      	s32i.n	a0, a12, 24
			     ioread32_mac(AR_RXCFG)
			     | AR_RXCFG_ZLFDMA);
	} else {
		iowrite32_mac(AR_RXCFG,
  90bff2:	3f0388        	excw
  90bff5:	010c02        	or	a12, a0, a1
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90bff8:	009890        	l32e	a0, a9, -32
  90bffb:	d10f      	retw.n
  90bffd:	000000        	ill

0090c000 <ar5416Attach>:
	ath_hal_free(ah);
}

struct ath_hal *
ar5416Attach(HAL_SOFTC sc, adf_os_device_t dev, HAL_STATUS *status)
{
  90c000:	6c1004        	entry	a1, 32
	struct ath_hal_5416 *ahp;
	struct ath_hal *ah;

	ahp = ath_hal_malloc(sizeof (struct ath_hal_5416));
  90c003:	2a1a44        	movi	a10, 0x144
  90c006:	5beeac        	call8	907ab8 <ath_hal_malloc>
	ath_hal_free(ah);
}

struct ath_hal *
ar5416Attach(HAL_SOFTC sc, adf_os_device_t dev, HAL_STATUS *status)
{
  90c009:	d520      	mov.n	a5, a2
	struct ath_hal_5416 *ahp;
	struct ath_hal *ah;

	ahp = ath_hal_malloc(sizeof (struct ath_hal_5416));
  90c00b:	d2a0      	mov.n	a2, a10
	if (ahp == AH_NULL) {
  90c00d:	cca4      	bnez.n	a10, 90c015 <ar5416Attach+0x15>
		*status = HAL_ENOMEM;
  90c00f:	c032      	movi.n	a3, 2
  90c011:	9340      	s32i.n	a3, a4, 0
		return AH_NULL;
  90c013:	d10f      	retw.n
	}
	ah = &ahp->ah_priv.h;

	OS_MEMCPY(&ahp->ah_priv, &ar5416hal_10, sizeof(struct ath_hal_private));
  90c015:	1b6a8d        	l32r	a11, 8e6a4c <__udivsi3>
  90c018:	2c0ad4        	movi	a12, 212
  90c01b:	5beeb2        	call8	907ae4 <ath_hal_memcpy>

	ah->ah_dev = dev;
	ah->ah_sc = sc;

	ah->ah_set11nTxDesc        = ar5416Set11nTxDesc_20;
  90c01e:	186a8e        	l32r	a8, 8e6a58 <__udivsi3+0xc>
	}
	ah = &ahp->ah_priv.h;

	OS_MEMCPY(&ahp->ah_priv, &ar5416hal_10, sizeof(struct ath_hal_private));

	ah->ah_dev = dev;
  90c021:	9322      	s32i.n	a3, a2, 8
	ah->ah_sc = sc;

	ah->ah_set11nTxDesc        = ar5416Set11nTxDesc_20;
  90c023:	982f      	s32i.n	a8, a2, 60
	ah->ah_set11nRateScenario  = ar5416Set11nRateScenario_20;
  90c025:	186a8f        	l32r	a8, 8e6a64 <__udivsi3+0x18>
	ah = &ahp->ah_priv.h;

	OS_MEMCPY(&ahp->ah_priv, &ar5416hal_10, sizeof(struct ath_hal_private));

	ah->ah_dev = dev;
	ah->ah_sc = sc;
  90c028:	9521      	s32i.n	a5, a2, 4

	ah->ah_set11nTxDesc        = ar5416Set11nTxDesc_20;
	ah->ah_set11nRateScenario  = ar5416Set11nRateScenario_20;
  90c02a:	282610        	s32i	a8, a2, 64
	ah->ah_set11nAggrFirst     = ar5416Set11nAggrFirst_20;
  90c02d:	186a90        	l32r	a8, 8e6a70 <__udivsi3+0x24>
  90c030:	282611        	s32i	a8, a2, 68
	ah->ah_set11nAggrMiddle    = ar5416Set11nAggrMiddle_20;
  90c033:	186a91        	l32r	a8, 8e6a78 <__udivsi3+0x2c>
  90c036:	282612        	s32i	a8, a2, 72
	ah->ah_set11nAggrLast      = ar5416Set11nAggrLast_20;
  90c039:	186a92        	l32r	a8, 8e6a84 <__udivsi3+0x38>
  90c03c:	282613        	s32i	a8, a2, 76
	ah->ah_clr11nAggr          = ar5416Clr11nAggr_20;
  90c03f:	186a93        	l32r	a8, 8e6a8c <__udivsi3+0x40>
  90c042:	282614        	s32i	a8, a2, 80
	ah->ah_set11nBurstDuration = ar5416Set11nBurstDuration_20;
  90c045:	186a94        	l32r	a8, 8e6a98 <__udivsi3+0x4c>
  90c048:	282615        	s32i	a8, a2, 84
	ah->ah_setupRxDesc         = ar5416SetupRxDesc_20;
  90c04b:	186a95        	l32r	a8, 8e6aa0 <__udivsi3+0x54>
  90c04e:	282620        	s32i	a8, a2, 128
	ah->ah_procRxDescFast      = ar5416ProcRxDescFast_20;
  90c051:	186a96        	l32r	a8, 8e6aac <__udivsi3+0x60>
  90c054:	282622        	s32i	a8, a2, 136
	ah->ah_setupTxDesc         = ar5416SetupTxDesc_20;
  90c057:	186a97        	l32r	a8, 8e6ab4 <__udivsi3+0x68>
  90c05a:	282617        	s32i	a8, a2, 92
	ah->ah_fillTxDesc          = ar5416FillTxDesc_20;
  90c05d:	186a98        	l32r	a8, 8e6ac0 <__udivsi3+0x74>
  90c060:	282618        	s32i	a8, a2, 96
	ah->ah_fillKeyTxDesc       = ar5416FillKeyTxDesc_20;
  90c063:	186a99        	l32r	a8, 8e6ac8 <__udivsi3+0x7c>
  90c066:	282619        	s32i	a8, a2, 100
	ah->ah_procTxDesc          = ar5416ProcTxDesc_20;
  90c069:	186a9a        	l32r	a8, 8e6ad4 <__udivsi3+0x88>
  90c06c:	28261a        	s32i	a8, a2, 104
	ah->ah_set11nVirtualMoreFrag = ar5416Set11nVirtualMoreFrag_20;
  90c06f:	186a9b        	l32r	a8, 8e6adc <__udivsi3+0x90>
  90c072:	282616        	s32i	a8, a2, 88

	return ah;
}
  90c075:	d10f      	retw.n
	...

0090c078 <ar5416GetRateTable>:
#undef  HT
#undef  HT_HGI

const HAL_RATE_TABLE *
ar5416GetRateTable(struct ath_hal *ah, a_uint32_t mode)
{
  90c078:	6c1004        	entry	a1, 32
		break;
	case HAL_MODE_11B:
		rt = &ar5416_11b_table;
		break;
	case HAL_MODE_11G:
		rt =  &ar5416_11g_table;
  90c07b:	126aa0        	l32r	a2, 8e6afc <__udivsi3+0xb0>

const HAL_RATE_TABLE *
ar5416GetRateTable(struct ath_hal *ah, a_uint32_t mode)
{
	HAL_RATE_TABLE *rt;
	switch (mode) {
  90c07e:	683827        	beqi	a3, 8, 90c0a9 <ar5416GetRateTable+0x31>
  90c081:	c028      	movi.n	a2, 8
  90c083:	73230e        	bltu	a2, a3, 90c095 <ar5416GetRateTable+0x1d>
	case HAL_MODE_11A:
		rt = &ar5416_11a_table;
  90c086:	126a9d        	l32r	a2, 8e6afc <__udivsi3+0xb0>

const HAL_RATE_TABLE *
ar5416GetRateTable(struct ath_hal *ah, a_uint32_t mode)
{
	HAL_RATE_TABLE *rt;
	switch (mode) {
  90c089:	68311c        	beqi	a3, 1, 90c0a9 <ar5416GetRateTable+0x31>
	case HAL_MODE_11A:
		rt = &ar5416_11a_table;
		break;
	case HAL_MODE_11B:
		rt = &ar5416_11b_table;
  90c08c:	126a9c        	l32r	a2, 8e6afc <__udivsi3+0xb0>

const HAL_RATE_TABLE *
ar5416GetRateTable(struct ath_hal *ah, a_uint32_t mode)
{
	HAL_RATE_TABLE *rt;
	switch (mode) {
  90c08f:	683416        	beqi	a3, 4, 90c0a9 <ar5416GetRateTable+0x31>
  90c092:	600011        	j	90c0a7 <ar5416GetRateTable+0x2f>
  90c095:	1869db        	l32r	a8, 8e6804 <strcmp+0x2a4>
		break;
	case HAL_MODE_11G:
		rt =  &ar5416_11g_table;
		break;
	case HAL_MODE_11NG:
		rt = &ar5416_11ng_table;
  90c098:	126a9f        	l32r	a2, 8e6b14 <__udivsi3+0xc8>

const HAL_RATE_TABLE *
ar5416GetRateTable(struct ath_hal *ah, a_uint32_t mode)
{
	HAL_RATE_TABLE *rt;
	switch (mode) {
  90c09b:	78310a        	beq	a3, a8, 90c0a9 <ar5416GetRateTable+0x31>
  90c09e:	1869da        	l32r	a8, 8e6808 <strcmp+0x2a8>
		break;
	case HAL_MODE_11NG:
		rt = &ar5416_11ng_table;
		break;
	case HAL_MODE_11NA:
		rt = &ar5416_11na_table;
  90c0a1:	126a9e        	l32r	a2, 8e6b1c <__udivsi3+0xd0>

const HAL_RATE_TABLE *
ar5416GetRateTable(struct ath_hal *ah, a_uint32_t mode)
{
	HAL_RATE_TABLE *rt;
	switch (mode) {
  90c0a4:	783101        	beq	a3, a8, 90c0a9 <ar5416GetRateTable+0x31>
		break;
	case HAL_MODE_11NA:
		rt = &ar5416_11na_table;
		break;
	default:
		return AH_NULL;
  90c0a7:	c020      	movi.n	a2, 0
	}

	return rt;
}
  90c0a9:	d10f      	retw.n
	...

0090c0ac <rcRateSetseries>:
static void
rcRateSetseries(const RATE_TABLE_11N *pRateTable ,
                struct ath_rc_series *series,
		A_UINT8 tries, A_UINT8 rix,
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
  90c0ac:	6c1004        	entry	a1, 32
	series->tries = tries;
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
		(WLAN_RC_PHY_DS(pRateTable->info[rix].phy) ? ATH_RC_DS_FLAG : 0) | 
  90c0af:	0e5911        	slli	a9, a5, 2
                struct ath_rc_series *series,
		A_UINT8 tries, A_UINT8 rix,
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
	series->tries = tries;
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
  90c0b2:	c0e1      	movi.n	a14, 1
		(WLAN_RC_PHY_DS(pRateTable->info[rix].phy) ? ATH_RC_DS_FLAG : 0) | 
  90c0b4:	a598      	add.n	a8, a9, a5
  90c0b6:	00e104        	ssl	a14
  90c0b9:	00881a        	sll	a8, a8
  90c0bc:	a588      	add.n	a8, a8, a5
  90c0be:	0e8811        	slli	a8, a8, 2
rcRateSetseries(const RATE_TABLE_11N *pRateTable ,
                struct ath_rc_series *series,
		A_UINT8 tries, A_UINT8 rix,
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
	series->tries = tries;
  90c0c1:	243401        	s8i	a4, a3, 1
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
		(WLAN_RC_PHY_DS(pRateTable->info[rix].phy) ? ATH_RC_DS_FLAG : 0) | 
  90c0c4:	a828      	add.n	a8, a2, a8
  90c0c6:	2a8010        	l8ui	a10, a8, 16
  90c0c9:	c78d      	movi.n	a8, -3
  90c0cb:	08a801        	and	a8, a10, a8
                struct ath_rc_series *series,
		A_UINT8 tries, A_UINT8 rix,
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
	series->tries = tries;
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
  90c0ce:	c0c0      	movi.n	a12, 0
		(WLAN_RC_PHY_DS(pRateTable->info[rix].phy) ? ATH_RC_DS_FLAG : 0) | 
  90c0d0:	c7db      	movi.n	a13, -5
  90c0d2:	288cfb        	addi	a8, a8, -5
  90c0d5:	0d8801        	and	a8, a8, a13
                struct ath_rc_series *series,
		A_UINT8 tries, A_UINT8 rix,
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
	series->tries = tries;
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
  90c0d8:	d4c0      	mov.n	a4, a12
  90c0da:	06e439        	movnez	a4, a14, a6
		(WLAN_RC_PHY_DS(pRateTable->info[rix].phy) ? ATH_RC_DS_FLAG : 0) | 
  90c0dd:	080847        	extui	a8, a8, 0, 8
                struct ath_rc_series *series,
		A_UINT8 tries, A_UINT8 rix,
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
	series->tries = tries;
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
  90c0e0:	0c4611        	slli	a6, a4, 4
		(WLAN_RC_PHY_DS(pRateTable->info[rix].phy) ? ATH_RC_DS_FLAG : 0) | 
  90c0e3:	08ce39        	movnez	a14, a12, a8
                struct ath_rc_series *series,
		A_UINT8 tries, A_UINT8 rix,
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
	series->tries = tries;
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
  90c0e6:	06e802        	or	a8, a14, a6
		(WLAN_RC_PHY_DS(pRateTable->info[rix].phy) ? ATH_RC_DS_FLAG : 0) | 
		(WLAN_RC_PHY_40(pRateTable->info[rix].phy) ? ATH_RC_CW40_FLAG : 0) | 
  90c0e9:	26acfa        	addi	a6, a10, -6
  90c0ec:	0d6d01        	and	a13, a6, a13
  90c0ef:	0d0d47        	extui	a13, a13, 0, 8
		A_UINT8 tries, A_UINT8 rix,
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
	series->tries = tries;
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
		(WLAN_RC_PHY_DS(pRateTable->info[rix].phy) ? ATH_RC_DS_FLAG : 0) | 
  90c0f2:	c062      	movi.n	a6, 2
static void
rcRateSetseries(const RATE_TABLE_11N *pRateTable ,
                struct ath_rc_series *series,
		A_UINT8 tries, A_UINT8 rix,
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
  90c0f4:	8b18      	l32i.n	a11, a1, 32
	series->tries = tries;
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
		(WLAN_RC_PHY_DS(pRateTable->info[rix].phy) ? ATH_RC_DS_FLAG : 0) | 
		(WLAN_RC_PHY_40(pRateTable->info[rix].phy) ? ATH_RC_CW40_FLAG : 0) | 
  90c0f6:	76d302        	bltu	a13, a6, 90c0fc <rcRateSetseries+0x50>
		A_UINT8 tries, A_UINT8 rix,
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
	series->tries = tries;
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
		(WLAN_RC_PHY_DS(pRateTable->info[rix].phy) ? ATH_RC_DS_FLAG : 0) | 
  90c0f9:	0cc602        	or	a6, a12, a12
		(WLAN_RC_PHY_40(pRateTable->info[rix].phy) ? ATH_RC_CW40_FLAG : 0) | 
		(WLAN_RC_PHY_SGI(pRateTable->info[rix].phy) ? ATH_RC_HT40_SGI_FLAG : 0);
  90c0fc:	2aacf8        	addi	a10, a10, -8
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
	series->tries = tries;
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
		(WLAN_RC_PHY_DS(pRateTable->info[rix].phy) ? ATH_RC_DS_FLAG : 0) | 
		(WLAN_RC_PHY_40(pRateTable->info[rix].phy) ? ATH_RC_CW40_FLAG : 0) | 
  90c0ff:	0a0a47        	extui	a10, a10, 0, 8
		A_UINT8 tries, A_UINT8 rix,
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
	series->tries = tries;
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
		(WLAN_RC_PHY_DS(pRateTable->info[rix].phy) ? ATH_RC_DS_FLAG : 0) | 
  90c102:	086802        	or	a8, a6, a8
		(WLAN_RC_PHY_40(pRateTable->info[rix].phy) ? ATH_RC_CW40_FLAG : 0) | 
  90c105:	c060      	movi.n	a6, 0
  90c107:	6fa401        	bgeui	a10, 4, 90c10c <rcRateSetseries+0x60>
  90c10a:	c064      	movi.n	a6, 4
  90c10c:	086802        	or	a8, a6, a8
                struct ath_rc_series *series,
		A_UINT8 tries, A_UINT8 rix,
		A_BOOL rtsctsenable, A_UINT32 chainmask,int stbc)
{
	series->tries = tries;
	series->flags = (rtsctsenable? ATH_RC_RTSCTS_FLAG : 0) | 
  90c10f:	283403        	s8i	a8, a3, 3
		(WLAN_RC_PHY_DS(pRateTable->info[rix].phy) ? ATH_RC_DS_FLAG : 0) | 
		(WLAN_RC_PHY_40(pRateTable->info[rix].phy) ? ATH_RC_CW40_FLAG : 0) | 
		(WLAN_RC_PHY_SGI(pRateTable->info[rix].phy) ? ATH_RC_HT40_SGI_FLAG : 0);
#ifdef MAGPIE_MERLIN
	if (stbc) {
  90c112:	c9be      	beqz.n	a11, 90c134 <rcRateSetseries+0x88>
		/* For now, only single stream STBC is supported */
		if (pRateTable->info[rix].rateCode >= 0x80 && 
  90c114:	a596      	add.n	a6, a9, a5
  90c116:	0f6611        	slli	a6, a6, 1
  90c119:	a566      	add.n	a6, a6, a5
  90c11b:	0e6611        	slli	a6, a6, 2
  90c11e:	a626      	add.n	a6, a2, a6
  90c120:	26601c        	l8ui	a6, a6, 28
  90c123:	266c80        	addi	a6, a6, -128
  90c126:	060647        	extui	a6, a6, 0, 8
  90c129:	6f6807        	bgeui	a6, 8, 90c134 <rcRateSetseries+0x88>
		    pRateTable->info[rix].rateCode <= 0x87)
		{
			series->flags |= ATH_RC_TX_STBC_FLAG;
  90c12c:	c260      	movi.n	a6, 32
  90c12e:	068802        	or	a8, a8, a6
  90c131:	283403        	s8i	a8, a3, 3
		}
	}
#endif
	series->rix = pRateTable->info[rix].baseIndex;
  90c134:	a599      	add.n	a9, a9, a5
  90c136:	0f9911        	slli	a9, a9, 1
  90c139:	a595      	add.n	a5, a9, a5
  90c13b:	0e5511        	slli	a5, a5, 2
  90c13e:	a522      	add.n	a2, a2, a5
  90c140:	252022        	l8ui	a5, a2, 34
  90c143:	253400        	s8i	a5, a3, 0
	series->max4msframelen = pRateTable->info[rix].max4msframelen;
  90c146:	852a      	l32i.n	a5, a2, 40
  90c148:	9531      	s32i.n	a5, a3, 4
	series->txrateKbps = pRateTable->info[rix].rateKbps;
  90c14a:	8525      	l32i.n	a5, a2, 20
  90c14c:	9532      	s32i.n	a5, a3, 8

	/* If the hardware is capable of multiple transmit chains (chainmask is 3, 5 or 7), 
	 * then choose the number of transmit chains dynamically based on entries in the rate table.
	 */
#ifndef ATH_ENABLE_WLAN_FOR_K2
	if(chainmask == 7)
  90c14e:	697706        	bnei	a7, 7, 90c158 <rcRateSetseries+0xac>
		series->tx_chainmask = pRateTable->info[rix].txChainMask_3ch;
  90c151:	222027        	l8ui	a2, a2, 39
  90c154:	60000b        	j	90c163 <rcRateSetseries+0xb7>
  90c157:	006971        	excw
	else if(chainmask == 1) 
  90c15a:	042734        	min	a7, a2, a4
		series->tx_chainmask = 1;
  90c15d:	02d10f        	subx8	a1, a13, a2
	else 
		series->tx_chainmask = pRateTable->info[rix].txChainMask_2ch;  /*Chainmask is 3 or 5*/
  90c160:	222026        	l8ui	a2, a2, 38
  90c163:	223402        	s8i	a2, a3, 2
  90c166:	d10f      	retw.n

0090c168 <rcIsValidPhyRate>:

/* Return true only for single stream */

static A_BOOL
rcIsValidPhyRate(A_UINT32 phy, A_UINT32 capflag, A_BOOL ignoreCW)
{
  90c168:	6c1004        	entry	a1, 32
	if (WLAN_RC_PHY_HT(phy) && !(capflag & WLAN_RC_HT_FLAG)) {
  90c16b:	6e2405        	bltui	a2, 4, 90c174 <rcIsValidPhyRate+0xc>
		return FALSE;
  90c16e:	280a00        	movi	a8, 0
/* Return true only for single stream */

static A_BOOL
rcIsValidPhyRate(A_UINT32 phy, A_UINT32 capflag, A_BOOL ignoreCW)
{
	if (WLAN_RC_PHY_HT(phy) && !(capflag & WLAN_RC_HT_FLAG)) {
  90c171:	7c3747        	bbci	a3, 28, 90c1bc <rcIsValidPhyRate+0x54>
		return FALSE;
	}

	if (WLAN_RC_PHY_DS(phy) && !(capflag & WLAN_RC_DS_FLAG))  {
  90c174:	c78d      	movi.n	a8, -3
  90c176:	082801        	and	a8, a2, a8
  90c179:	288cfb        	addi	a8, a8, -5
  90c17c:	29fafb        	movi	a9, -5
  90c17f:	098801        	and	a8, a8, a9
  90c182:	658002        	bnez	a8, 90c188 <rcIsValidPhyRate+0x20>
  90c185:	7f3733        	bbci	a3, 31, 90c1bc <rcIsValidPhyRate+0x54>
		return FALSE;
	}
	if (WLAN_RC_PHY_SGI(phy) && !(capflag & WLAN_RC_HT40_SGI_FLAG)) {
  90c188:	282cf8        	addi	a8, a2, -8
  90c18b:	6f8405        	bgeui	a8, 4, 90c194 <rcIsValidPhyRate+0x2c>

static A_BOOL
rcIsValidPhyRate(A_UINT32 phy, A_UINT32 capflag, A_BOOL ignoreCW)
{
	if (WLAN_RC_PHY_HT(phy) && !(capflag & WLAN_RC_HT_FLAG)) {
		return FALSE;
  90c18e:	280a00        	movi	a8, 0
	}

	if (WLAN_RC_PHY_DS(phy) && !(capflag & WLAN_RC_DS_FLAG))  {
		return FALSE;
	}
	if (WLAN_RC_PHY_SGI(phy) && !(capflag & WLAN_RC_HT40_SGI_FLAG)) {
  90c191:	7d3727        	bbci	a3, 29, 90c1bc <rcIsValidPhyRate+0x54>
		return FALSE;
	}

	if (!ignoreCW && WLAN_RC_PHY_HT(phy)) {
  90c194:	c091      	movi.n	a9, 1
  90c196:	ce40      	bnez.n	a4, 90c1ba <rcIsValidPhyRate+0x52>
  90c198:	6e241e        	bltui	a2, 4, 90c1ba <rcIsValidPhyRate+0x52>
		if (WLAN_RC_PHY_40(phy) && !(capflag & WLAN_RC_40_FLAG)) {
  90c19b:	c78b      	movi.n	a8, -5
  90c19d:	222cfa        	addi	a2, a2, -6
  90c1a0:	082201        	and	a2, a2, a8
			return FALSE;
		}

		if (!WLAN_RC_PHY_40(phy) && (capflag & WLAN_RC_40_FLAG)) {
  90c1a3:	031840        	extui	a8, a3, 1, 1
  90c1a6:	098803        	xor	a8, a8, a9
	if (WLAN_RC_PHY_SGI(phy) && !(capflag & WLAN_RC_HT40_SGI_FLAG)) {
		return FALSE;
	}

	if (!ignoreCW && WLAN_RC_PHY_HT(phy)) {
		if (WLAN_RC_PHY_40(phy) && !(capflag & WLAN_RC_40_FLAG)) {
  90c1a9:	6f220f        	bgeui	a2, 2, 90c1bc <rcIsValidPhyRate+0x54>
  90c1ac:	c082      	movi.n	a8, 2
  90c1ae:	083301        	and	a3, a3, a8
		if (!WLAN_RC_PHY_40(phy) && (capflag & WLAN_RC_40_FLAG)) {
			return FALSE;
		}
	}
    
	return TRUE;
  90c1b1:	c080      	movi.n	a8, 0
  90c1b3:	039839        	movnez	a8, a9, a3
  90c1b6:	600002        	j	90c1bc <rcIsValidPhyRate+0x54>
  90c1b9:	00c081        	excw
}
  90c1bc:	d280      	mov.n	a2, a8
  90c1be:	d10f      	retw.n

0090c1c0 <rcSibUpdate_ht$constprop$6>:
 *  (e.g. SME operation, wireless mode change)
 *
 *  It will determine which rates are valid for use.
 */
static void
rcSibUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an,
  90c1c0:	6c1052        	entry	a1, 0x290
	TX_RATE_CTRL *pRc = (TX_RATE_CTRL *)(pSib);
	PHY_STATE_CTRL mPhyCtrlState;  

	A_UINT8 i, j, k, hi = 0, htHi = 0;

	pRateTable = (RATE_TABLE_11N*)asc->hwRateTable[sc->sc_curmode];
  90c1c3:	262248        	l32i	a6, a2, 0x120
  90c1c6:	2222c2        	l32i	a2, a2, 0x308
static void
rcSibUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an,
	       A_UINT32 capflag, A_BOOL keepState, struct ieee80211_rate  *pRateSet)
{
	RATE_TABLE_11N *pRateTable = 0;
	struct atheros_node *pSib = ATH_NODE_ATHEROS(an);
  90c1c9:	233282        	l32i	a3, a3, 0x208
	TX_RATE_CTRL *pRc = (TX_RATE_CTRL *)(pSib);
	PHY_STATE_CTRL mPhyCtrlState;  

	A_UINT8 i, j, k, hi = 0, htHi = 0;

	pRateTable = (RATE_TABLE_11N*)asc->hwRateTable[sc->sc_curmode];
  90c1cc:	0e2211        	slli	a2, a2, 2
  90c1cf:	a262      	add.n	a2, a6, a2
  90c1d1:	8621      	l32i.n	a6, a2, 4

	/* Initial rate table size. Will change depending on the working rate set */
	pRc->rateTableSize = MAX_TX_RATE_TBL;
  90c1d3:	c22e      	movi.n	a2, 46
  90c1d5:	22342e        	s8i	a2, a3, 46
  90c1d8:	d730      	mov.n	a7, a3

	/* Initialize thresholds according to the global rate table */
	for (i = 0 ; (i < pRc->rateTableSize) && (!keepState); i++) {
		pRc->state[i].per       = 0;
  90c1da:	c080      	movi.n	a8, 0
  90c1dc:	c22e      	movi.n	a2, 46
  90c1de:	6d2804        	loop	a2, 90c1e6 <rcSibUpdate_ht$constprop$6+0x26>
  90c1e1:	287400        	s8i	a8, a7, 0
  90c1e4:	b177      	addi.n	a7, a7, 1
  90c1e6:	273c3a        	addi	a7, a3, 58
rcInitValidTxMask(TX_RATE_CTRL *pRc)
{
	A_UINT8 i;

	for (i = 0; i < pRc->rateTableSize; i++) {
		pRc->validRateIndex[i] = FALSE;
  90c1e9:	c080      	movi.n	a8, 0
  90c1eb:	c22e      	movi.n	a2, 46
  90c1ed:	6d2804        	loop	a2, 90c1f5 <rcSibUpdate_ht$constprop$6+0x35>
  90c1f0:	287400        	s8i	a8, a7, 0
  90c1f3:	b177      	addi.n	a7, a7, 1
static void
rcInitValidTxMask(TX_RATE_CTRL *pRc)
{
	A_UINT8 i;

	for (i = 0; i < pRc->rateTableSize; i++) {
  90c1f5:	c070      	movi.n	a7, 0
  90c1f7:	d910      	mov.n	a9, a1
	/* Determine the valid rates */
	rcInitValidTxMask(pRc);

	for (i = 0; i < WLAN_RC_PHY_MAX; i++) {
		for (j = 0; j < MAX_TX_RATE_TBL; j++) {
			mPhyCtrlState.validPhyRateIndex[i][j] = 0;
  90c1f9:	da70      	mov.n	a10, a7
	}

	/* Determine the valid rates */
	rcInitValidTxMask(pRc);

	for (i = 0; i < WLAN_RC_PHY_MAX; i++) {
  90c1fb:	2b2a28        	movi	a11, 0x228
  90c1fe:	600014        	j	90c216 <rcSibUpdate_ht$constprop$6+0x56>
		for (j = 0; j < MAX_TX_RATE_TBL; j++) {
			mPhyCtrlState.validPhyRateIndex[i][j] = 0;
  90c201:	2a2400        	s8i	a10, a2, 0
  90c204:	b122      	addi.n	a2, a2, 1
  90c206:	b088      	addi.n	a8, a8, -1
  90c208:	658ff5        	bnez	a8, 90c201 <rcSibUpdate_ht$constprop$6+0x41>
		}   
		mPhyCtrlState.validPhyRateCount[i] = 0;
  90c20b:	2a9400        	s8i	a10, a9, 0
  90c20e:	277c2e        	addi	a7, a7, 46
  90c211:	b199      	addi.n	a9, a9, 1
	}

	/* Determine the valid rates */
	rcInitValidTxMask(pRc);

	for (i = 0; i < WLAN_RC_PHY_MAX; i++) {
  90c213:	7b710b        	beq	a7, a11, 90c222 <rcSibUpdate_ht$constprop$6+0x62>
  90c216:	bc72      	addi.n	a2, a7, 12
  90c218:	a212      	add.n	a2, a1, a2
	A_UINT8 i, j, k, hi = 0, htHi = 0;

	pRateTable = (RATE_TABLE_11N*)asc->hwRateTable[sc->sc_curmode];

	/* Initial rate table size. Will change depending on the working rate set */
	pRc->rateTableSize = MAX_TX_RATE_TBL;
  90c21a:	c28e      	movi.n	a8, 46
  90c21c:	63ffe1        	j	90c201 <rcSibUpdate_ht$constprop$6+0x41>
  90c21f:	000000        	ill
			mPhyCtrlState.validPhyRateIndex[i][j] = 0;
		}   
		mPhyCtrlState.validPhyRateCount[i] = 0;
	}

	pRc->rcPhyMode = (capflag & WLAN_RC_40_FLAG);
  90c222:	c022      	movi.n	a2, 2
  90c224:	024201        	and	a2, a4, a2
  90c227:	040840        	extui	a8, a4, 0, 1
  90c22a:	22346c        	s8i	a2, a3, 108
  90c22d:	281692        	s32i	a8, a1, 0x248

	if (pRateSet == NULL || !pRateSet->rates.rs_nrates) {
  90c230:	c854      	beqz.n	a5, 90c238 <rcSibUpdate_ht$constprop$6+0x78>
  90c232:	275000        	l8ui	a7, a5, 0
  90c235:	657084        	bnez	a7, 90c2bd <rcSibUpdate_ht$constprop$6+0xfd>
  90c238:	2d6000        	l8ui	a13, a6, 0
static A_UINT8 rcSibInitValidRates(const RATE_TABLE_11N *pRateTable,
				   TX_RATE_CTRL *pRc,
				   A_UINT32 capflag,
				   PHY_STATE_CTRL *pPhyStateCtrl)
{
	A_UINT8 i, hi = 0;
  90c23b:	c020      	movi.n	a2, 0
  90c23d:	b467      	addi.n	a7, a6, 4
  90c23f:	ad3d      	add.n	a13, a3, a13
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT8 valid;
    
	for (i = 0; i < pRateTable->rateCount; i++) {
  90c241:	d530      	mov.n	a5, a3
		}
            
		if (valid == TRUE) {
			A_UINT32 phy = pRateTable->info[i].phy;

			if (!rcIsValidPhyRate(phy, capflag, FALSE)) 
  90c243:	df20      	mov.n	a15, a2
  90c245:	600068        	j	90c2b1 <rcSibUpdate_ht$constprop$6+0xf1>
	A_UINT8 i, hi = 0;
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT8 valid;
    
	for (i = 0; i < pRateTable->rateCount; i++) {
		if (singleStream) {
  90c248:	281292        	l32i	a8, a1, 0x248
  90c24b:	cc85      	bnez.n	a8, 90c254 <rcSibUpdate_ht$constprop$6+0x94>
			valid = pRateTable->info[i].validSingleStream;
  90c24d:	2e7007        	l8ui	a14, a7, 7
  90c250:	600003        	j	90c257 <rcSibUpdate_ht$constprop$6+0x97>
  90c253:	002e70        	excw
		} else {
			valid = pRateTable->info[i].valid;
  90c256:	0369e1        	excw
		}
            
		if (valid == TRUE) {
  90c259:	512870        	call0	95641c <_etext+0x471eb>
			A_UINT32 phy = pRateTable->info[i].phy;
  90c25c:	0cdcf0        	excw

			if (!rcIsValidPhyRate(phy, capflag, FALSE)) 
  90c25f:	da80      	mov.n	a10, a8
  90c261:	db40      	mov.n	a11, a4
  90c263:	28169a        	s32i	a8, a1, 0x268
  90c266:	291698        	s32i	a9, a1, 0x260
  90c269:	2d1697        	s32i	a13, a1, 0x25c
  90c26c:	2e1699        	s32i	a14, a1, 0x264
  90c26f:	2f169b        	s32i	a15, a1, 0x26c
  90c272:	5bffbd        	call8	90c168 <rcIsValidPhyRate>
  90c275:	28129a        	l32i	a8, a1, 0x268
  90c278:	291298        	l32i	a9, a1, 0x260
  90c27b:	2d1297        	l32i	a13, a1, 0x25c
  90c27e:	2e1299        	l32i	a14, a1, 0x264
  90c281:	2f129b        	l32i	a15, a1, 0x26c
  90c284:	caa4      	beqz.n	a10, 90c2ac <rcSibUpdate_ht$constprop$6+0xec>
				continue;

			pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = i;
  90c286:	0f8c11        	slli	a12, a8, 1
  90c289:	a8cc      	add.n	a12, a12, a8
  90c28b:	0dcc11        	slli	a12, a12, 3
  90c28e:	a81b      	add.n	a11, a1, a8
  90c290:	08c80c        	sub	a8, a12, a8
  90c293:	2ab000        	l8ui	a10, a11, 0
  90c296:	0f8811        	slli	a8, a8, 1
  90c299:	a818      	add.n	a8, a1, a8
  90c29b:	aa88      	add.n	a8, a8, a10
			pPhyStateCtrl->validPhyRateCount[phy] += 1;
  90c29d:	2aac01        	addi	a10, a10, 1
			A_UINT32 phy = pRateTable->info[i].phy;

			if (!rcIsValidPhyRate(phy, capflag, FALSE)) 
				continue;

			pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = i;
  90c2a0:	29840c        	s8i	a9, a8, 12
			pPhyStateCtrl->validPhyRateCount[phy] += 1;
  90c2a3:	2ab400        	s8i	a10, a11, 0

static INLINE void
rcSetValidTxMask(TX_RATE_CTRL *pRc, A_UINT8 index, A_BOOL validTxRate)
{
	ASSERT(index < pRc->rateTableSize);
	pRc->validRateIndex[index] = validTxRate ? TRUE : FALSE;
  90c2a6:	2e543a        	s8i	a14, a5, 58
			pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = i;
			pPhyStateCtrl->validPhyRateCount[phy] += 1;

			rcSetValidTxMask(pRc, i, TRUE);

			hi = A_MAX(hi, i);
  90c2a9:	029237        	maxu	a2, a9, a2
  90c2ac:	277c2c        	addi	a7, a7, 44
  90c2af:	b155      	addi.n	a5, a5, 1
  90c2b1:	03590c        	sub	a9, a5, a3
  90c2b4:	090947        	extui	a9, a9, 0, 8
{
	A_UINT8 i, hi = 0;
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT8 valid;
    
	for (i = 0; i < pRateTable->rateCount; i++) {
  90c2b7:	75d98d        	bne	a13, a5, 90c248 <rcSibUpdate_ht$constprop$6+0x88>
  90c2ba:	60020d        	j	90c4cb <rcSibUpdate_ht$constprop$6+0x30b>
  90c2bd:	a75d      	add.n	a13, a5, a7
                   struct ieee80211_rateset *pRateSet,
		   A_UINT32 capflag,
		   struct ath_node_target *an,
		   PHY_STATE_CTRL *pPhyStateCtrl)
{
	A_UINT8 i, j, hi = 0;
  90c2bf:	c080      	movi.n	a8, 0
			 * the validity (TRUE/TRUE_20/TRUE_40) flags
			 */

			if (((pRateSet->rs_rates[i] & 0x7F) == 
			     (pRateTable->info[j].dot11Rate & 0x7F))
			    && ((valid & WLAN_RC_CAP_MODE(capflag)) == 
  90c2c1:	c078      	movi.n	a7, 8
  90c2c3:	2d1694        	s32i	a13, a1, 0x250
                   struct ieee80211_rateset *pRateSet,
		   A_UINT32 capflag,
		   struct ath_node_target *an,
		   PHY_STATE_CTRL *pPhyStateCtrl)
{
	A_UINT8 i, j, hi = 0;
  90c2c6:	281691        	s32i	a8, a1, 0x244
			 * the validity (TRUE/TRUE_20/TRUE_40) flags
			 */

			if (((pRateSet->rs_rates[i] & 0x7F) == 
			     (pRateTable->info[j].dot11Rate & 0x7F))
			    && ((valid & WLAN_RC_CAP_MODE(capflag)) == 
  90c2c9:	074d01        	and	a13, a4, a7
  90c2cc:	c084      	movi.n	a8, 4
  90c2ce:	c072      	movi.n	a7, 2
  90c2d0:	027838        	moveqz	a8, a7, a2
  90c2d3:	251690        	s32i	a5, a1, 0x240
		   A_UINT32 capflag,
		   struct ath_node_target *an,
		   PHY_STATE_CTRL *pPhyStateCtrl)
{
	A_UINT8 i, j, hi = 0;
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
  90c2d6:	d950      	mov.n	a9, a5
			 * the validity (TRUE/TRUE_20/TRUE_40) flags
			 */

			if (((pRateSet->rs_rates[i] & 0x7F) == 
			     (pRateTable->info[j].dot11Rate & 0x7F))
			    && ((valid & WLAN_RC_CAP_MODE(capflag)) == 
  90c2d8:	2d1695        	s32i	a13, a1, 0x254
  90c2db:	281696        	s32i	a8, a1, 0x258
  90c2de:	6000b5        	j	90c397 <rcSibUpdate_ht$constprop$6+0x1d7>
		for (j = 0; j < pRateTable->rateCount; j++) {
			A_UINT32 phy = pRateTable->info[j].phy;
#ifdef MAGPIE_MERLIN
			struct atheros_node *pSib = ATH_NODE_ATHEROS(an);

			if (pSib->stbc) {
  90c2e1:	27321d        	l32i	a7, a3, 116
  90c2e4:	1a6a75        	l32r	a10, 8e6cb8 <memcpy+0x154>
  90c2e7:	7a7005        	bnone	a7, a10, 90c2f0 <rcSibUpdate_ht$constprop$6+0x130>
				valid = pRateTable->info[j].validSTBC;
  90c2ea:	8a22      	l32i.n	a10, a2, 8
  90c2ec:	60000c        	j	90c2fc <rcSibUpdate_ht$constprop$6+0x13c>
  90c2ef:	002b12        	srai	a11, a0, 2
			} else if (singleStream) {
  90c2f2:	92cc      	s32i.n	a2, a12, 48
  90c2f4:	b38a      	addi.n	a10, a8, 3
#else
			if (singleStream) {
#endif            
				valid = pRateTable->info[j].validSingleStream;
  90c2f6:	216000        	l8ui	a1, a6, 0
  90c2f9:	018a20        	excw
			/*
			 * We allow a rate only if its valid and the capflag matches one of
			 * the validity (TRUE/TRUE_20/TRUE_40) flags
			 */

			if (((pRateSet->rs_rates[i] & 0x7F) == 
  90c2fc:	279001        	l8ui	a7, a9, 1
  90c2ff:	2b201a        	l8ui	a11, a2, 26
  90c302:	0b7703        	xor	a7, a7, a11
  90c305:	070746        	extui	a7, a7, 0, 7
  90c308:	657078        	bnez	a7, 90c384 <rcSibUpdate_ht$constprop$6+0x1c4>
			     (pRateTable->info[j].dot11Rate & 0x7F))
			    && ((valid & WLAN_RC_CAP_MODE(capflag)) == 
  90c30b:	2b1296        	l32i	a11, a1, 0x258
  90c30e:	2c1295        	l32i	a12, a1, 0x254
	A_UINT32 valid;
       
	/* Use intersection of working rates and valid rates */
	for (i = 0; i < pRateSet->rs_nrates; i++) {
		for (j = 0; j < pRateTable->rateCount; j++) {
			A_UINT32 phy = pRateTable->info[j].phy;
  90c311:	27200c        	l8ui	a7, a2, 12
			 * the validity (TRUE/TRUE_20/TRUE_40) flags
			 */

			if (((pRateSet->rs_rates[i] & 0x7F) == 
			     (pRateTable->info[j].dot11Rate & 0x7F))
			    && ((valid & WLAN_RC_CAP_MODE(capflag)) == 
  90c314:	0cdb38        	moveqz	a11, a13, a12
  90c317:	0baa01        	and	a10, a10, a11
  90c31a:	0baa0c        	sub	a10, a10, a11
  90c31d:	dbf0      	mov.n	a11, a15
  90c31f:	0adb38        	moveqz	a11, a13, a10
				WLAN_RC_CAP_MODE(capflag)) && !WLAN_RC_PHY_HT(phy)) {
  90c322:	0b0a47        	extui	a10, a11, 0, 8
  90c325:	64a05b        	beqz	a10, 90c384 <rcSibUpdate_ht$constprop$6+0x1c4>
  90c328:	6f7458        	bgeui	a7, 4, 90c384 <rcSibUpdate_ht$constprop$6+0x1c4>
				if (!rcIsValidPhyRate(phy, capflag, FALSE)) 
  90c32b:	dcf0      	mov.n	a12, a15
  90c32d:	db40      	mov.n	a11, a4
  90c32f:	077a02        	or	a10, a7, a7
  90c332:	28169a        	s32i	a8, a1, 0x268
  90c335:	291698        	s32i	a9, a1, 0x260
  90c338:	2d1697        	s32i	a13, a1, 0x25c
  90c33b:	2e1699        	s32i	a14, a1, 0x264
  90c33e:	2f169b        	s32i	a15, a1, 0x26c
  90c341:	5bff89        	call8	90c168 <rcIsValidPhyRate>
  90c344:	28129a        	l32i	a8, a1, 0x268
  90c347:	291298        	l32i	a9, a1, 0x260
  90c34a:	2d1297        	l32i	a13, a1, 0x25c
  90c34d:	2e1299        	l32i	a14, a1, 0x264
  90c350:	2f129b        	l32i	a15, a1, 0x26c
  90c353:	caad      	beqz.n	a10, 90c384 <rcSibUpdate_ht$constprop$6+0x1c4>
					continue;

				pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = j;
  90c355:	0f7c11        	slli	a12, a7, 1
  90c358:	a7cc      	add.n	a12, a12, a7
  90c35a:	0dcc11        	slli	a12, a12, 3
  90c35d:	a71b      	add.n	a11, a1, a7
  90c35f:	07c70c        	sub	a7, a12, a7
  90c362:	2ab000        	l8ui	a10, a11, 0
  90c365:	0f7711        	slli	a7, a7, 1
				pPhyStateCtrl->validPhyRateCount[phy] += 1;

				rcSetValidTxMask(pRc, j, TRUE);
				hi = A_MAX(hi, j);
  90c368:	2c1291        	l32i	a12, a1, 0x244
			    && ((valid & WLAN_RC_CAP_MODE(capflag)) == 
				WLAN_RC_CAP_MODE(capflag)) && !WLAN_RC_PHY_HT(phy)) {
				if (!rcIsValidPhyRate(phy, capflag, FALSE)) 
					continue;

				pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = j;
  90c36b:	a717      	add.n	a7, a1, a7
  90c36d:	aa77      	add.n	a7, a7, a10
				pPhyStateCtrl->validPhyRateCount[phy] += 1;
  90c36f:	b1aa      	addi.n	a10, a10, 1
			    && ((valid & WLAN_RC_CAP_MODE(capflag)) == 
				WLAN_RC_CAP_MODE(capflag)) && !WLAN_RC_PHY_HT(phy)) {
				if (!rcIsValidPhyRate(phy, capflag, FALSE)) 
					continue;

				pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = j;
  90c371:	2e740c        	s8i	a14, a7, 12
				pPhyStateCtrl->validPhyRateCount[phy] += 1;
  90c374:	2ab400        	s8i	a10, a11, 0

static INLINE void
rcSetValidTxMask(TX_RATE_CTRL *pRc, A_UINT8 index, A_BOOL validTxRate)
{
	ASSERT(index < pRc->rateTableSize);
	pRc->validRateIndex[index] = validTxRate ? TRUE : FALSE;
  90c377:	a837      	add.n	a7, a3, a8
  90c379:	c0a1      	movi.n	a10, 1

				pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = j;
				pPhyStateCtrl->validPhyRateCount[phy] += 1;

				rcSetValidTxMask(pRc, j, TRUE);
				hi = A_MAX(hi, j);
  90c37b:	0cec37        	maxu	a12, a14, a12

static INLINE void
rcSetValidTxMask(TX_RATE_CTRL *pRc, A_UINT8 index, A_BOOL validTxRate)
{
	ASSERT(index < pRc->rateTableSize);
	pRc->validRateIndex[index] = validTxRate ? TRUE : FALSE;
  90c37e:	2a743a        	s8i	a10, a7, 58

				pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = j;
				pPhyStateCtrl->validPhyRateCount[phy] += 1;

				rcSetValidTxMask(pRc, j, TRUE);
				hi = A_MAX(hi, j);
  90c381:	2c1691        	s32i	a12, a1, 0x244
  90c384:	b188      	addi.n	a8, a8, 1
  90c386:	222c2c        	addi	a2, a2, 44
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT32 valid;
       
	/* Use intersection of working rates and valid rates */
	for (i = 0; i < pRateSet->rs_nrates; i++) {
		for (j = 0; j < pRateTable->rateCount; j++) {
  90c389:	2a1293        	l32i	a10, a1, 0x24c
  90c38c:	080e47        	extui	a14, a8, 0, 8
  90c38f:	7aeb02        	bgeu	a14, a10, 90c395 <rcSibUpdate_ht$constprop$6+0x1d5>
  90c392:	63ff4b        	j	90c2e1 <rcSibUpdate_ht$constprop$6+0x121>
  90c395:	b199      	addi.n	a9, a9, 1
	A_UINT8 i, j, hi = 0;
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT32 valid;
       
	/* Use intersection of working rates and valid rates */
	for (i = 0; i < pRateSet->rs_nrates; i++) {
  90c397:	2d1294        	l32i	a13, a1, 0x250
  90c39a:	7d9110        	beq	a9, a13, 90c3ae <rcSibUpdate_ht$constprop$6+0x1ee>
		for (j = 0; j < pRateTable->rateCount; j++) {
  90c39d:	226000        	l8ui	a2, a6, 0
  90c3a0:	c080      	movi.n	a8, 0
  90c3a2:	221693        	s32i	a2, a1, 0x24c
			 * the validity (TRUE/TRUE_20/TRUE_40) flags
			 */

			if (((pRateSet->rs_rates[i] & 0x7F) == 
			     (pRateTable->info[j].dot11Rate & 0x7F))
			    && ((valid & WLAN_RC_CAP_MODE(capflag)) == 
  90c3a5:	c0d1      	movi.n	a13, 1
  90c3a7:	b462      	addi.n	a2, a6, 4
  90c3a9:	df80      	mov.n	a15, a8
  90c3ab:	63ffda        	j	90c389 <rcSibUpdate_ht$constprop$6+0x1c9>
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	A_UINT8 *phtMcs = (A_UINT8*)&pRateSet->htrates;
	TX_RATE_CTRL *pRc = (TX_RATE_CTRL *)(pSib);
	PHY_STATE_CTRL mPhyCtrlState;  

	A_UINT8 i, j, k, hi = 0, htHi = 0;
  90c3ae:	c020      	movi.n	a2, 0
	} else {
		/* Use intersection of working rates and valid rates */
		hi = rcSibSetValidRates(pRateTable, pRc, &(pRateSet->rates),
					capflag, an, &mPhyCtrlState);

		if (capflag & WLAN_RC_HT_FLAG) {
  90c3b0:	7c4f02        	bbsi	a4, 28, 90c3b6 <rcSibUpdate_ht$constprop$6+0x1f6>
  90c3b3:	60010e        	j	90c4c5 <rcSibUpdate_ht$constprop$6+0x305>
  90c3b6:	27501f        	l8ui	a7, a5, 31
			}
                           
			if (((((struct ieee80211_rateset *)pMcsSet)->rs_rates[i] & 0x7F) 
			     != (pRateTable->info[j].dot11Rate & 0x7F)) 
			    || !WLAN_RC_PHY_HT(phy) 
			    || !WLAN_RC_PHY_HT_VALID(valid, capflag)
  90c3b9:	c0d2      	movi.n	a13, 2
  90c3bb:	a755      	add.n	a5, a5, a7
  90c3bd:	251694        	s32i	a5, a1, 0x250
			    || ((pRateTable->info[j].dot11Rate == 15) && 
				(valid & TRUE_20) && 
				(capflag & WLAN_RC_WEP_TKIP_FLAG)) )
  90c3c0:	251a00        	movi	a5, 0x100
  90c3c3:	054501        	and	a5, a4, a5
			}
                           
			if (((((struct ieee80211_rateset *)pMcsSet)->rs_rates[i] & 0x7F) 
			     != (pRateTable->info[j].dot11Rate & 0x7F)) 
			    || !WLAN_RC_PHY_HT(phy) 
			    || !WLAN_RC_PHY_HT_VALID(valid, capflag)
  90c3c6:	0d4d01        	and	a13, a4, a13
				valid = pRateTable->info[j].validSingleStream;
			} else {
				valid = pRateTable->info[j].valid;
			}
                           
			if (((((struct ieee80211_rateset *)pMcsSet)->rs_rates[i] & 0x7F) 
  90c3c9:	c0e1      	movi.n	a14, 1
			     != (pRateTable->info[j].dot11Rate & 0x7F)) 
			    || !WLAN_RC_PHY_HT(phy) 
			    || !WLAN_RC_PHY_HT_VALID(valid, capflag)
			    || ((pRateTable->info[j].dot11Rate == 15) && 
				(valid & TRUE_20) && 
				(capflag & WLAN_RC_WEP_TKIP_FLAG)) )
  90c3cb:	251695        	s32i	a5, a1, 0x254
			}
                           
			if (((((struct ieee80211_rateset *)pMcsSet)->rs_rates[i] & 0x7F) 
			     != (pRateTable->info[j].dot11Rate & 0x7F)) 
			    || !WLAN_RC_PHY_HT(phy) 
			    || !WLAN_RC_PHY_HT_VALID(valid, capflag)
  90c3ce:	2d1696        	s32i	a13, a1, 0x258
  90c3d1:	6000d8        	j	90c4ad <rcSibUpdate_ht$constprop$6+0x2ed>
		for (j = 0; j < pRateTable->rateCount; j++) {
			A_UINT32 phy = pRateTable->info[j].phy;
#ifdef MAGPIE_MERLIN
			struct atheros_node *pSib = ATH_NODE_ATHEROS(an);

			if (pSib->stbc) {
  90c3d4:	2a321d        	l32i	a10, a3, 116
  90c3d7:	1b6a75        	l32r	a11, 8e6dac <memcpy+0x248>
	A_UINT8 valid;
    
	/* Use intersection of working rates and valid rates */
	for (i = 0; i <  ((struct ieee80211_rateset *)pMcsSet)->rs_nrates; i++) {
		for (j = 0; j < pRateTable->rateCount; j++) {
			A_UINT32 phy = pRateTable->info[j].phy;
  90c3da:	27500c        	l8ui	a7, a5, 12
#ifdef MAGPIE_MERLIN
			struct atheros_node *pSib = ATH_NODE_ATHEROS(an);

			if (pSib->stbc) {
  90c3dd:	7ba007        	bnone	a10, a11, 90c3e8 <rcSibUpdate_ht$constprop$6+0x228>
				valid = pRateTable->info[j].validSTBC;
  90c3e0:	2c500b        	l8ui	a12, a5, 11
  90c3e3:	600010        	j	90c3f7 <rcSibUpdate_ht$constprop$6+0x237>
  90c3e6:	00002d        	excw
			} else if (singleStream) {
  90c3e9:	1292cc        	l32r	a2, 8f0f1c <memset+0xa0d4>
  90c3ec:	d52c      	excw
#else
			if (singleStream) {
#endif
				valid = pRateTable->info[j].validSingleStream;
  90c3ee:	500760        	call0	90e170 <ath_tgt_send_mgt+0x308>
  90c3f1:	000300        	rfe
			} else {
				valid = pRateTable->info[j].valid;
  90c3f4:	2c5003        	l8ui	a12, a5, 3
			}
                           
			if (((((struct ieee80211_rateset *)pMcsSet)->rs_rates[i] & 0x7F) 
			     != (pRateTable->info[j].dot11Rate & 0x7F)) 
  90c3f7:	2a1290        	l32i	a10, a1, 0x240
  90c3fa:	2b501a        	l8ui	a11, a5, 26
  90c3fd:	2da020        	l8ui	a13, a10, 32
  90c400:	0dba03        	xor	a10, a11, a13
				valid = pRateTable->info[j].validSingleStream;
			} else {
				valid = pRateTable->info[j].valid;
			}
                           
			if (((((struct ieee80211_rateset *)pMcsSet)->rs_rates[i] & 0x7F) 
  90c403:	0a0d46        	extui	a13, a10, 0, 7
  90c406:	da90      	mov.n	a10, a9
  90c408:	0dea39        	movnez	a10, a14, a13
			     != (pRateTable->info[j].dot11Rate & 0x7F)) 
			    || !WLAN_RC_PHY_HT(phy) 
  90c40b:	0a0a47        	extui	a10, a10, 0, 8
  90c40e:	65a082        	bnez	a10, 90c494 <rcSibUpdate_ht$constprop$6+0x2d4>
  90c411:	6e747f        	bltui	a7, 4, 90c494 <rcSibUpdate_ht$constprop$6+0x2d4>
  90c414:	c0d2      	movi.n	a13, 2
  90c416:	0dca01        	and	a10, a12, a13
			    || !WLAN_RC_PHY_HT_VALID(valid, capflag)
  90c419:	c8a3      	beqz.n	a10, 90c420 <rcSibUpdate_ht$constprop$6+0x260>
  90c41b:	2d1296        	l32i	a13, a1, 0x258
  90c41e:	c8d7      	beqz.n	a13, 90c429 <rcSibUpdate_ht$constprop$6+0x269>
  90c420:	7dc770        	bbci	a12, 29, 90c494 <rcSibUpdate_ht$constprop$6+0x2d4>
  90c423:	2d1296        	l32i	a13, a1, 0x258
  90c426:	64d06a        	beqz	a13, 90c494 <rcSibUpdate_ht$constprop$6+0x2d4>
			    || ((pRateTable->info[j].dot11Rate == 15) && 
  90c429:	2bbcf1        	addi	a11, a11, -15
  90c42c:	dc90      	mov.n	a12, a9
  90c42e:	0bec38        	moveqz	a12, a14, a11
  90c431:	0c0b47        	extui	a11, a12, 0, 8
  90c434:	c8be      	beqz.n	a11, 90c446 <rcSibUpdate_ht$constprop$6+0x286>
  90c436:	dd90      	mov.n	a13, a9
  90c438:	0aed39        	movnez	a13, a14, a10
  90c43b:	0d0a47        	extui	a10, a13, 0, 8
  90c43e:	c8a4      	beqz.n	a10, 90c446 <rcSibUpdate_ht$constprop$6+0x286>
				(valid & TRUE_20) && 
  90c440:	2d1295        	l32i	a13, a1, 0x254
  90c443:	65d04d        	bnez	a13, 90c494 <rcSibUpdate_ht$constprop$6+0x2d4>
				(capflag & WLAN_RC_WEP_TKIP_FLAG)) )
			{
				continue;
			}
    
			if (!rcIsValidPhyRate(phy, capflag, FALSE)) 
  90c446:	dc90      	mov.n	a12, a9
  90c448:	db40      	mov.n	a11, a4
  90c44a:	077a02        	or	a10, a7, a7
  90c44d:	28169a        	s32i	a8, a1, 0x268
  90c450:	291698        	s32i	a9, a1, 0x260
  90c453:	2e1699        	s32i	a14, a1, 0x264
  90c456:	2f169b        	s32i	a15, a1, 0x26c
  90c459:	5bff43        	call8	90c168 <rcIsValidPhyRate>
  90c45c:	28129a        	l32i	a8, a1, 0x268
  90c45f:	291298        	l32i	a9, a1, 0x260
  90c462:	2e1299        	l32i	a14, a1, 0x264
  90c465:	2f129b        	l32i	a15, a1, 0x26c
  90c468:	caa8      	beqz.n	a10, 90c494 <rcSibUpdate_ht$constprop$6+0x2d4>
				continue;
    
			pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = j;
  90c46a:	0f7c11        	slli	a12, a7, 1
  90c46d:	a7cc      	add.n	a12, a12, a7
  90c46f:	0dcc11        	slli	a12, a12, 3
  90c472:	a71b      	add.n	a11, a1, a7
  90c474:	07c70c        	sub	a7, a12, a7
  90c477:	2ab000        	l8ui	a10, a11, 0
  90c47a:	0f7711        	slli	a7, a7, 1
  90c47d:	a717      	add.n	a7, a1, a7
  90c47f:	aa77      	add.n	a7, a7, a10
			pPhyStateCtrl->validPhyRateCount[phy] += 1;
  90c481:	b1aa      	addi.n	a10, a10, 1
			}
    
			if (!rcIsValidPhyRate(phy, capflag, FALSE)) 
				continue;
    
			pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = j;
  90c483:	2f740c        	s8i	a15, a7, 12
			pPhyStateCtrl->validPhyRateCount[phy] += 1;
  90c486:	2ab400        	s8i	a10, a11, 0

static INLINE void
rcSetValidTxMask(TX_RATE_CTRL *pRc, A_UINT8 index, A_BOOL validTxRate)
{
	ASSERT(index < pRc->rateTableSize);
	pRc->validRateIndex[index] = validTxRate ? TRUE : FALSE;
  90c489:	a837      	add.n	a7, a3, a8
  90c48b:	2a0a01        	movi	a10, 1
  90c48e:	2a743a        	s8i	a10, a7, 58
    
			pPhyStateCtrl->validPhyRateIndex[phy][pPhyStateCtrl->validPhyRateCount[phy]] = j;
			pPhyStateCtrl->validPhyRateCount[phy] += 1;

			rcSetValidTxMask(pRc, j, TRUE);
			hi = A_MAX(hi, j);
  90c491:	02f237        	maxu	a2, a15, a2
  90c494:	b188      	addi.n	a8, a8, 1
  90c496:	255c2c        	addi	a5, a5, 44
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT8 valid;
    
	/* Use intersection of working rates and valid rates */
	for (i = 0; i <  ((struct ieee80211_rateset *)pMcsSet)->rs_nrates; i++) {
		for (j = 0; j < pRateTable->rateCount; j++) {
  90c499:	2d1293        	l32i	a13, a1, 0x24c
  90c49c:	080f47        	extui	a15, a8, 0, 8
  90c49f:	7dfb02        	bgeu	a15, a13, 90c4a5 <rcSibUpdate_ht$constprop$6+0x2e5>
  90c4a2:	63ff2e        	j	90c3d4 <rcSibUpdate_ht$constprop$6+0x214>
  90c4a5:	251290        	l32i	a5, a1, 0x240
  90c4a8:	b155      	addi.n	a5, a5, 1
  90c4aa:	251690        	s32i	a5, a1, 0x240
	A_UINT8 i, j, hi = 0;
	A_UINT8 singleStream = (capflag & WLAN_RC_DS_FLAG) ? 0 : 1;
	A_UINT8 valid;
    
	/* Use intersection of working rates and valid rates */
	for (i = 0; i <  ((struct ieee80211_rateset *)pMcsSet)->rs_nrates; i++) {
  90c4ad:	281294        	l32i	a8, a1, 0x250
  90c4b0:	2d1290        	l32i	a13, a1, 0x240
  90c4b3:	7d810e        	beq	a8, a13, 90c4c5 <rcSibUpdate_ht$constprop$6+0x305>
		for (j = 0; j < pRateTable->rateCount; j++) {
  90c4b6:	256000        	l8ui	a5, a6, 0
  90c4b9:	c080      	movi.n	a8, 0
  90c4bb:	251693        	s32i	a5, a1, 0x24c
				valid = pRateTable->info[j].validSingleStream;
			} else {
				valid = pRateTable->info[j].valid;
			}
                           
			if (((((struct ieee80211_rateset *)pMcsSet)->rs_rates[i] & 0x7F) 
  90c4be:	d980      	mov.n	a9, a8
  90c4c0:	b465      	addi.n	a5, a6, 4
  90c4c2:	63ffd3        	j	90c499 <rcSibUpdate_ht$constprop$6+0x2d9>
		if (capflag & WLAN_RC_HT_FLAG) {
			htHi = rcSibSetValidHtRates(pRateTable, pRc, phtMcs,
						    capflag, an, &mPhyCtrlState);
		}

		hi = A_MAX(hi, htHi);
  90c4c5:	281291        	l32i	a8, a1, 0x244
  90c4c8:	082237        	maxu	a2, a2, a8
	}

	pRc->rateTableSize = hi + 1;
  90c4cb:	b122      	addi.n	a2, a2, 1
  90c4cd:	22342e        	s8i	a2, a3, 46
	pRc->rateMaxPhy    = 0;
  90c4d0:	c020      	movi.n	a2, 0
	for (i = 0, k = 0; i < WLAN_RC_PHY_MAX; i++) {
		for (j = 0; j < mPhyCtrlState.validPhyRateCount[i]; j++) {
			pRc->validRateIndex[k++] = mPhyCtrlState.validPhyRateIndex[i][j];
		}   

		if (!rcIsValidPhyRate(i, pRateTable->initialRateMax, TRUE) ||
  90c4d2:	c050      	movi.n	a5, 0

		hi = A_MAX(hi, htHi);
	}

	pRc->rateTableSize = hi + 1;
	pRc->rateMaxPhy    = 0;
  90c4d4:	22346d        	s8i	a2, a3, 109
	for (i = 0, k = 0; i < WLAN_RC_PHY_MAX; i++) {
		for (j = 0; j < mPhyCtrlState.validPhyRateCount[i]; j++) {
			pRc->validRateIndex[k++] = mPhyCtrlState.validPhyRateIndex[i][j];
		}   

		if (!rcIsValidPhyRate(i, pRateTable->initialRateMax, TRUE) ||
  90c4d7:	2d6003        	l8ui	a13, a6, 3
  90c4da:	bc18      	addi.n	a8, a1, 12
	pRc->rateTableSize = hi + 1;
	pRc->rateMaxPhy    = 0;
    
	ASSERT(pRc->rateTableSize <= MAX_TX_RATE_TBL);

	for (i = 0, k = 0; i < WLAN_RC_PHY_MAX; i++) {
  90c4dc:	d450      	mov.n	a4, a5
		for (j = 0; j < mPhyCtrlState.validPhyRateCount[i]; j++) {
			pRc->validRateIndex[k++] = mPhyCtrlState.validPhyRateIndex[i][j];
		}   

		if (!rcIsValidPhyRate(i, pRateTable->initialRateMax, TRUE) ||
  90c4de:	c091      	movi.n	a9, 1
  90c4e0:	de50      	mov.n	a14, a5
  90c4e2:	60006a        	j	90c550 <rcSibUpdate_ht$constprop$6+0x390>
    
	ASSERT(pRc->rateTableSize <= MAX_TX_RATE_TBL);

	for (i = 0, k = 0; i < WLAN_RC_PHY_MAX; i++) {
		for (j = 0; j < mPhyCtrlState.validPhyRateCount[i]; j++) {
			pRc->validRateIndex[k++] = mPhyCtrlState.validPhyRateIndex[i][j];
  90c4e5:	2ba000        	l8ui	a11, a10, 0
  90c4e8:	b124      	addi.n	a4, a2, 1
  90c4ea:	a232      	add.n	a2, a3, a2
  90c4ec:	2b243a        	s8i	a11, a2, 58
  90c4ef:	b1aa      	addi.n	a10, a10, 1
  90c4f1:	040247        	extui	a2, a4, 0, 8
	pRc->rateMaxPhy    = 0;
    
	ASSERT(pRc->rateTableSize <= MAX_TX_RATE_TBL);

	for (i = 0, k = 0; i < WLAN_RC_PHY_MAX; i++) {
		for (j = 0; j < mPhyCtrlState.validPhyRateCount[i]; j++) {
  90c4f4:	7729ed        	bne	a2, a7, 90c4e5 <rcSibUpdate_ht$constprop$6+0x325>
			pRc->validRateIndex[k++] = mPhyCtrlState.validPhyRateIndex[i][j];
		}   

		if (!rcIsValidPhyRate(i, pRateTable->initialRateMax, TRUE) ||
  90c4f7:	dbd0      	mov.n	a11, a13
  90c4f9:	099c02        	or	a12, a9, a9
  90c4fc:	da50      	mov.n	a10, a5
  90c4fe:	28169a        	s32i	a8, a1, 0x268
  90c501:	291698        	s32i	a9, a1, 0x260
  90c504:	2d1697        	s32i	a13, a1, 0x25c
  90c507:	2e1699        	s32i	a14, a1, 0x264
  90c50a:	2f169b        	s32i	a15, a1, 0x26c
  90c50d:	5bff16        	call8	90c168 <rcIsValidPhyRate>
  90c510:	2e1299        	l32i	a14, a1, 0x264
  90c513:	291298        	l32i	a9, a1, 0x260
  90c516:	dbe0      	mov.n	a11, a14
  90c518:	0a9b38        	moveqz	a11, a9, a10
  90c51b:	0b0a47        	extui	a10, a11, 0, 8
  90c51e:	28129a        	l32i	a8, a1, 0x268
  90c521:	2d1297        	l32i	a13, a1, 0x25c
  90c524:	2f129b        	l32i	a15, a1, 0x26c
  90c527:	cdab      	bnez.n	a10, 90c546 <rcSibUpdate_ht$constprop$6+0x386>
  90c529:	0f9a38        	moveqz	a10, a9, a15
  90c52c:	cda6      	bnez.n	a10, 90c546 <rcSibUpdate_ht$constprop$6+0x386>
		    !mPhyCtrlState.validPhyRateCount[i]) 
			continue;

		pRc->rateMaxPhy = mPhyCtrlState.validPhyRateIndex[i][j-1];	
  90c52e:	0f5411        	slli	a4, a5, 1
  90c531:	a544      	add.n	a4, a4, a5
  90c533:	0d4411        	slli	a4, a4, 3
  90c536:	05440c        	sub	a4, a4, a5
  90c539:	0f4411        	slli	a4, a4, 1
  90c53c:	a414      	add.n	a4, a1, a4
  90c53e:	af44      	add.n	a4, a4, a15
  90c540:	24400b        	l8ui	a4, a4, 11
  90c543:	24346d        	s8i	a4, a3, 109
  90c546:	b155      	addi.n	a5, a5, 1
  90c548:	288c2e        	addi	a8, a8, 46
  90c54b:	d470      	mov.n	a4, a7
	pRc->rateTableSize = hi + 1;
	pRc->rateMaxPhy    = 0;
    
	ASSERT(pRc->rateTableSize <= MAX_TX_RATE_TBL);

	for (i = 0, k = 0; i < WLAN_RC_PHY_MAX; i++) {
  90c54d:	685a10        	beqi	a5, 12, 90c561 <rcSibUpdate_ht$constprop$6+0x3a1>
		for (j = 0; j < mPhyCtrlState.validPhyRateCount[i]; j++) {
  90c550:	a512      	add.n	a2, a1, a5
  90c552:	2f2000        	l8ui	a15, a2, 0
  90c555:	da80      	mov.n	a10, a8
  90c557:	a4f7      	add.n	a7, a15, a4
  90c559:	070747        	extui	a7, a7, 0, 8
  90c55c:	d240      	mov.n	a2, a4
  90c55e:	63ff92        	j	90c4f4 <rcSibUpdate_ht$constprop$6+0x334>
	}
    
	ASSERT(pRc->rateTableSize <= MAX_TX_RATE_TBL);
	ASSERT(k <= MAX_TX_RATE_TBL);

	pRc->rateMaxPhy = pRc->validRateIndex[k-4];
  90c561:	a234      	add.n	a4, a3, a2
  90c563:	244036        	l8ui	a4, a4, 54
	pRc->maxValidRate = k;
  90c566:	223439        	s8i	a2, a3, 57
static void
rcSortValidRates(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc)
{
	A_UINT8 i,j;

	for (i=pRc->maxValidRate-1; i > 0; i--) {
  90c569:	b022      	addi.n	a2, a2, -1
	}
    
	ASSERT(pRc->rateTableSize <= MAX_TX_RATE_TBL);
	ASSERT(k <= MAX_TX_RATE_TBL);

	pRc->rateMaxPhy = pRc->validRateIndex[k-4];
  90c56b:	24346d        	s8i	a4, a3, 109
static void
rcSortValidRates(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc)
{
	A_UINT8 i,j;

	for (i=pRc->maxValidRate-1; i > 0; i--) {
  90c56e:	020247        	extui	a2, a2, 0, 8
  90c571:	c0c0      	movi.n	a12, 0
  90c573:	600041        	j	90c5b8 <rcSibUpdate_ht$constprop$6+0x3f8>
		for (j=0; j <= i-1; j++) {
#ifdef MAGPIE_MERLIN      
			if (pRateTable->info[pRc->validRateIndex[j]].rateKbps >
  90c576:	a73b      	add.n	a11, a3, a7
			    pRateTable->info[pRc->validRateIndex[j+1]].rateKbps)
  90c578:	b177      	addi.n	a7, a7, 1
  90c57a:	a73a      	add.n	a10, a3, a7
	A_UINT8 i,j;

	for (i=pRc->maxValidRate-1; i > 0; i--) {
		for (j=0; j <= i-1; j++) {
#ifdef MAGPIE_MERLIN      
			if (pRateTable->info[pRc->validRateIndex[j]].rateKbps >
  90c57c:	28b03a        	l8ui	a8, a11, 58
			    pRateTable->info[pRc->validRateIndex[j+1]].rateKbps)
  90c57f:	29a03a        	l8ui	a9, a10, 58
	A_UINT8 i,j;

	for (i=pRc->maxValidRate-1; i > 0; i--) {
		for (j=0; j <= i-1; j++) {
#ifdef MAGPIE_MERLIN      
			if (pRateTable->info[pRc->validRateIndex[j]].rateKbps >
  90c582:	0e8511        	slli	a5, a8, 2
			    pRateTable->info[pRc->validRateIndex[j+1]].rateKbps)
  90c585:	0e9411        	slli	a4, a9, 2
	A_UINT8 i,j;

	for (i=pRc->maxValidRate-1; i > 0; i--) {
		for (j=0; j <= i-1; j++) {
#ifdef MAGPIE_MERLIN      
			if (pRateTable->info[pRc->validRateIndex[j]].rateKbps >
  90c588:	a855      	add.n	a5, a5, a8
			    pRateTable->info[pRc->validRateIndex[j+1]].rateKbps)
  90c58a:	a944      	add.n	a4, a4, a9
	A_UINT8 i,j;

	for (i=pRc->maxValidRate-1; i > 0; i--) {
		for (j=0; j <= i-1; j++) {
#ifdef MAGPIE_MERLIN      
			if (pRateTable->info[pRc->validRateIndex[j]].rateKbps >
  90c58c:	0f5511        	slli	a5, a5, 1
			    pRateTable->info[pRc->validRateIndex[j+1]].rateKbps)
  90c58f:	0f4411        	slli	a4, a4, 1
	A_UINT8 i,j;

	for (i=pRc->maxValidRate-1; i > 0; i--) {
		for (j=0; j <= i-1; j++) {
#ifdef MAGPIE_MERLIN      
			if (pRateTable->info[pRc->validRateIndex[j]].rateKbps >
  90c592:	a855      	add.n	a5, a5, a8
			    pRateTable->info[pRc->validRateIndex[j+1]].rateKbps)
  90c594:	a944      	add.n	a4, a4, a9
	A_UINT8 i,j;

	for (i=pRc->maxValidRate-1; i > 0; i--) {
		for (j=0; j <= i-1; j++) {
#ifdef MAGPIE_MERLIN      
			if (pRateTable->info[pRc->validRateIndex[j]].rateKbps >
  90c596:	0e5511        	slli	a5, a5, 2
			    pRateTable->info[pRc->validRateIndex[j+1]].rateKbps)
  90c599:	0e4411        	slli	a4, a4, 2
	A_UINT8 i,j;

	for (i=pRc->maxValidRate-1; i > 0; i--) {
		for (j=0; j <= i-1; j++) {
#ifdef MAGPIE_MERLIN      
			if (pRateTable->info[pRc->validRateIndex[j]].rateKbps >
  90c59c:	a565      	add.n	a5, a6, a5
			    pRateTable->info[pRc->validRateIndex[j+1]].rateKbps)
  90c59e:	a464      	add.n	a4, a6, a4
	A_UINT8 i,j;

	for (i=pRc->maxValidRate-1; i > 0; i--) {
		for (j=0; j <= i-1; j++) {
#ifdef MAGPIE_MERLIN      
			if (pRateTable->info[pRc->validRateIndex[j]].rateKbps >
  90c5a0:	8555      	l32i.n	a5, a5, 20
  90c5a2:	8445      	l32i.n	a4, a4, 20
  90c5a4:	754b05        	bgeu	a4, a5, 90c5ad <rcSibUpdate_ht$constprop$6+0x3ed>
				    pRateTable->info[pRc->validRateIndex[j+1]].userRateKbps)
#endif
				{
					A_UINT8 tmp=0;
					tmp = pRc->validRateIndex[j];
					pRc->validRateIndex[j] = pRc->validRateIndex[j+1];
  90c5a7:	29b43a        	s8i	a9, a11, 58
					pRc->validRateIndex[j+1] = tmp;
  90c5aa:	28a43a        	s8i	a8, a10, 58
rcSortValidRates(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc)
{
	A_UINT8 i,j;

	for (i=pRc->maxValidRate-1; i > 0; i--) {
		for (j=0; j <= i-1; j++) {
  90c5ad:	070747        	extui	a7, a7, 0, 8
  90c5b0:	7272c2        	blt	a7, a2, 90c576 <rcSibUpdate_ht$constprop$6+0x3b6>
static void
rcSortValidRates(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc)
{
	A_UINT8 i,j;

	for (i=pRc->maxValidRate-1; i > 0; i--) {
  90c5b3:	b022      	addi.n	a2, a2, -1
  90c5b5:	020247        	extui	a2, a2, 0, 8
  90c5b8:	c823      	beqz.n	a2, 90c5bf <rcSibUpdate_ht$constprop$6+0x3ff>
  90c5ba:	d7c0      	mov.n	a7, a12
  90c5bc:	63fff0        	j	90c5b0 <rcSibUpdate_ht$constprop$6+0x3f0>
  90c5bf:	d10f      	retw.n
  90c5c1:	000000        	ill

0090c5c4 <ath_rate_newassoc_11n>:
}

static void
ath_rate_newassoc_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, int isnew, 
		      unsigned int capflag, struct ieee80211_rate *rs)
{
  90c5c4:	6c1004        	entry	a1, 32
  90c5c7:	da20      	mov.n	a10, a2
  90c5c9:	db30      	mov.n	a11, a3
  90c5cb:	dc50      	mov.n	a12, a5
  90c5cd:	dd60      	mov.n	a13, a6
	if (isnew) {
  90c5cf:	c949      	beqz.n	a4, 90c5ec <ath_rate_newassoc_11n+0x28>
#ifdef MAGPIE_MERLIN
		struct atheros_node *oan = ATH_NODE_ATHEROS(an);
		/* Only MERLIN can send STBC */
		oan->stbc = (capflag & ATH_RC_TX_STBC_FLAG) ? 1 : 0;
  90c5d1:	2e3282        	l32i	a14, a3, 0x208
  90c5d4:	055840        	extui	a8, a5, 5, 1
  90c5d7:	0b8911        	slli	a9, a8, 5
  90c5da:	28e074        	l8ui	a8, a14, 116
  90c5dd:	2ffa9f        	movi	a15, -97
  90c5e0:	0f8801        	and	a8, a8, a15
  90c5e3:	098802        	or	a8, a8, a9
  90c5e6:	28e474        	s8i	a8, a14, 116
#endif
		rcSibUpdate_ht(sc, an, capflag, 0, rs);
  90c5e9:	5bfef5        	call8	90c1c0 <rcSibUpdate_ht$constprop$6>
  90c5ec:	d10f      	retw.n
	...

0090c5f0 <rcUpdate_ht$constprop$5>:
		}
	}
}

static void
rcUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an, int txRate, 
  90c5f0:	6c1006        	entry	a1, 48
  90c5f3:	2c1119        	l16ui	a12, a1, 50
  90c5f6:	07094f        	extui	a9, a7, 0, 16
            A_BOOL Xretries, int retries, A_UINT8 curTxAnt, 
            A_UINT16 nFrames, A_UINT16 nBad)
{
	TX_RATE_CTRL *pRc;
	A_UINT32 nowMsec = A_MS_TICKGET();
  90c5f9:	c0a0      	movi.n	a10, 0
  90c5fb:	9912      	s32i.n	a9, a1, 8
  90c5fd:	9510      	s32i.n	a5, a1, 0
  90c5ff:	2c1603        	s32i	a12, a1, 12
  90c602:	261601        	s32i	a6, a1, 4
  90c605:	5bed1a        	call8	907a70 <ath_hal_getuptime>
	A_UINT8 lastPer;
	int rate,count;
	struct atheros_node *pSib = ATH_NODE_ATHEROS(an);
  90c608:	233282        	l32i	a3, a3, 0x208
rcUpdate_ht(struct ath_softc_tgt *sc, struct ath_node_target *an, int txRate, 
            A_BOOL Xretries, int retries, A_UINT8 curTxAnt, 
            A_UINT16 nFrames, A_UINT16 nBad)
{
	TX_RATE_CTRL *pRc;
	A_UINT32 nowMsec = A_MS_TICKGET();
  90c60b:	d5a0      	mov.n	a5, a10
	pRc = (TX_RATE_CTRL *)(pSib);

	ASSERT(retries >= 0 && retries < MAX_TX_RETRIES);
	ASSERT(txRate >= 0);
    
	if (txRate < 0) {
  90c60d:	8811      	l32i.n	a8, a1, 4
  90c60f:	8912      	l32i.n	a9, a1, 8
  90c611:	8b10      	l32i.n	a11, a1, 0
  90c613:	8c13      	l32i.n	a12, a1, 12
  90c615:	6431e3        	beqz	a3, 90c7fc <rcUpdate_ht$constprop$5+0x20c>
  90c618:	6641e0        	bltz	a4, 90c7fc <rcUpdate_ht$constprop$5+0x20c>
	A_UINT32 nowMsec = A_MS_TICKGET();
	A_UINT8 lastPer;
	int rate,count;
	struct atheros_node *pSib = ATH_NODE_ATHEROS(an);
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  90c61b:	272248        	l32i	a7, a2, 0x120
  90c61e:	2222c2        	l32i	a2, a2, 0x308
  90c621:	0e2211        	slli	a2, a2, 2
  90c624:	a272      	add.n	a2, a7, a2
  90c626:	8721      	l32i.n	a7, a2, 4
    
	if (txRate < 0) {
		return;
	}

	lastPer = pRc->state[txRate].per;
  90c628:	a432      	add.n	a2, a3, a4
  90c62a:	262000        	l8ui	a6, a2, 0

	if (Xretries) {
  90c62d:	cbb4      	beqz.n	a11, 90c665 <rcUpdate_ht$constprop$5+0x75>
		/* Update the PER. */
		if (Xretries == 1) {
  90c62f:	69b115        	bnei	a11, 1, 90c648 <rcUpdate_ht$constprop$5+0x58>
			pRc->state[txRate].per += 30;
  90c632:	286c1e        	addi	a8, a6, 30
  90c635:	080847        	extui	a8, a8, 0, 8
			if (pRc->state[txRate].per > 100) {
  90c638:	290a64        	movi	a9, 100
  90c63b:	789302        	bltu	a9, a8, 90c641 <rcUpdate_ht$constprop$5+0x51>
  90c63e:	60000e        	j	90c650 <rcUpdate_ht$constprop$5+0x60>
				pRc->state[txRate].per = 100;
  90c641:	292400        	s8i	a9, a2, 0
  90c644:	60000b        	j	90c653 <rcUpdate_ht$constprop$5+0x63>
  90c647:	00bc68        	excw
			if (retries >= count) {
				retries = count - 1;
			}

			/* new_PER = 7/8*old_PER + 1/8*(currentPER) */
			pRc->state[txRate].per = (A_UINT8)(pRc->state[txRate].per - 
  90c64a:	063914        	srli	a9, a6, 3
  90c64d:	09880c        	sub	a8, a8, a9
  90c650:	282400        	s8i	a8, a2, 0
						   (pRc->state[txRate].per / 8) + ((100) / 8));
		}

		/* Xretries == 1 or 2 */

		if (pRc->probeRate == txRate)
  90c653:	28302f        	l8ui	a8, a3, 47
  90c656:	784102        	beq	a4, a8, 90c65c <rcUpdate_ht$constprop$5+0x6c>
  90c659:	6000bb        	j	90c718 <rcUpdate_ht$constprop$5+0x128>
			pRc->probeRate = 0;
  90c65c:	c080      	movi.n	a8, 0
  90c65e:	28342f        	s8i	a8, a3, 47
  90c661:	6000b3        	j	90c718 <rcUpdate_ht$constprop$5+0x128>
  90c664:	00c0a9        	excw
  90c667:	0a8834        	min	a8, a8, a10
		count = sizeof(nRetry2PerLookup) / sizeof(nRetry2PerLookup[0]);
		if (retries >= count) {
			retries = count - 1;
		}

		if (nBad) {
  90c66a:	cbca      	beqz.n	a12, 90c6a8 <rcUpdate_ht$constprop$5+0xb8>
			 * that part is 100 * nBad / nFrames, and it contributes
			 * 100 * nBad / (nFrames * (retries+1)) to the above
			 * PER.  The expression below is a simplified version
			 * of the sum of these two terms.
			 */
			if (nFrames > 0)
  90c66c:	649050        	beqz	a9, 90c6c0 <rcUpdate_ht$constprop$5+0xd0>
				pRc->state[txRate].per = (A_UINT8)(pRc->state[txRate].per - 
					   (pRc->state[txRate].per / 8) + 
					   ((100*(retries*nFrames + nBad)/(nFrames*(retries+1))) / 8));
  90c66f:	089b28        	mull	a11, a9, a8
  90c672:	9811      	s32i.n	a8, a1, 4
  90c674:	abcd      	add.n	a13, a12, a11
  90c676:	0eda11        	slli	a10, a13, 2
  90c679:	adaa      	add.n	a10, a10, a13
  90c67b:	0ead11        	slli	a13, a10, 2
  90c67e:	adaa      	add.n	a10, a10, a13
  90c680:	ab9b      	add.n	a11, a9, a11
  90c682:	0eaa11        	slli	a10, a10, 2
  90c685:	9912      	s32i.n	a9, a1, 8
  90c687:	9c13      	s32i.n	a12, a1, 12
  90c689:	5b68c3        	call8	8e6998 <__divsi3>
  90c68c:	b7ab      	addi.n	a11, a10, 7
  90c68e:	0aba3a        	movltz	a10, a11, a10
  90c691:	0a3a12        	srai	a10, a10, 3
			 * 100 * nBad / (nFrames * (retries+1)) to the above
			 * PER.  The expression below is a simplified version
			 * of the sum of these two terms.
			 */
			if (nFrames > 0)
				pRc->state[txRate].per = (A_UINT8)(pRc->state[txRate].per - 
  90c694:	aa6a      	add.n	a10, a6, a10
  90c696:	063b14        	srli	a11, a6, 3
  90c699:	0baa0c        	sub	a10, a10, a11
  90c69c:	2a2400        	s8i	a10, a2, 0
  90c69f:	8811      	l32i.n	a8, a1, 4
  90c6a1:	8912      	l32i.n	a9, a1, 8
  90c6a3:	8c13      	l32i.n	a12, a1, 12
  90c6a5:	600017        	j	90c6c0 <rcUpdate_ht$constprop$5+0xd0>
					   ((100*(retries*nFrames + nBad)/(nFrames*(retries+1))) / 8));
		} else {
			/* new_PER = 7/8*old_PER + 1/8*(currentPER) */

			pRc->state[txRate].per = (A_UINT8)(pRc->state[txRate].per - 
				   (pRc->state[txRate].per / 8) + (nRetry2PerLookup[retries] / 8));
  90c6a8:	1a6aa1        	l32r	a10, 8e712c <memset+0x2e4>
  90c6ab:	0e8b11        	slli	a11, a8, 2
  90c6ae:	abaa      	add.n	a10, a10, a11
  90c6b0:	8aa0      	l32i.n	a10, a10, 0
					   (pRc->state[txRate].per / 8) + 
					   ((100*(retries*nFrames + nBad)/(nFrames*(retries+1))) / 8));
		} else {
			/* new_PER = 7/8*old_PER + 1/8*(currentPER) */

			pRc->state[txRate].per = (A_UINT8)(pRc->state[txRate].per - 
  90c6b2:	063b14        	srli	a11, a6, 3
				   (pRc->state[txRate].per / 8) + (nRetry2PerLookup[retries] / 8));
  90c6b5:	0a3a14        	srli	a10, a10, 3
					   (pRc->state[txRate].per / 8) + 
					   ((100*(retries*nFrames + nBad)/(nFrames*(retries+1))) / 8));
		} else {
			/* new_PER = 7/8*old_PER + 1/8*(currentPER) */

			pRc->state[txRate].per = (A_UINT8)(pRc->state[txRate].per - 
  90c6b8:	aa6a      	add.n	a10, a6, a10
  90c6ba:	0baa0c        	sub	a10, a10, a11
  90c6bd:	2a2400        	s8i	a10, a2, 0
		/*
		 * If we got at most one retry then increase the max rate if
		 * this was a probe.  Otherwise, ignore the probe.
		 */

		if (pRc->probeRate && pRc->probeRate == txRate) {
  90c6c0:	2a302f        	l8ui	a10, a3, 47
  90c6c3:	cba5      	beqz.n	a10, 90c6fc <rcUpdate_ht$constprop$5+0x10c>
  90c6c5:	7a4933        	bne	a4, a10, 90c6fc <rcUpdate_ht$constprop$5+0x10c>
			if (retries > 0 || 2 * nBad > nFrames) {
  90c6c8:	6b8105        	bgei	a8, 1, 90c6d1 <rcUpdate_ht$constprop$5+0xe1>
  90c6cb:	0fcc11        	slli	a12, a12, 1
  90c6ce:	7c9a07        	bge	a9, a12, 90c6d9 <rcUpdate_ht$constprop$5+0xe9>
				 * any retries means the probe failed.  Also,
				 * if the attempt worked, but more than half
				 * the subframes were bad then also consider
				 * the probe a failure.
				 */
				pRc->probeRate = 0;
  90c6d1:	c090      	movi.n	a9, 0
  90c6d3:	29342f        	s8i	a9, a3, 47
  90c6d6:	600022        	j	90c6fc <rcUpdate_ht$constprop$5+0x10c>
			} else {
				pRc->rateMaxPhy = pRc->probeRate;
  90c6d9:	24346d        	s8i	a4, a3, 109

				if (pRc->state[pRc->probeRate].per > 30) {
  90c6dc:	282000        	l8ui	a8, a2, 0
  90c6df:	c19e      	movi.n	a9, 30
  90c6e1:	789b04        	bgeu	a9, a8, 90c6e9 <rcUpdate_ht$constprop$5+0xf9>
					pRc->state[pRc->probeRate].per = 20;
  90c6e4:	c184      	movi.n	a8, 20
  90c6e6:	282400        	s8i	a8, a2, 0
				}

				pRc->probeRate = 0;
  90c6e9:	c080      	movi.n	a8, 0
  90c6eb:	28342f        	s8i	a8, a3, 47
				/*
				 * Since this probe succeeded, we allow the next probe
				 * twice as soon.  This allows the maxRate to move up
				 * faster if the probes are succesful.
				 */
				pRc->probeTime = nowMsec - pRateTable->probeInterval / 2;
  90c6ee:	287001        	l8ui	a8, a7, 1
  90c6f1:	081814        	srli	a8, a8, 1
  90c6f4:	08580c        	sub	a8, a5, a8
  90c6f7:	983d      	s32i.n	a8, a3, 52
  90c6f9:	600007        	j	90c704 <rcUpdate_ht$constprop$5+0x114>
			}
		}

		if (retries > 0) {
  90c6fc:	6a8104        	blti	a8, 1, 90c704 <rcUpdate_ht$constprop$5+0x114>
			 *
			 * Later: if rssiAck is close to pRc->state[txRate].rssiThres
			 * and we see lots of retries, then we could increase
			 * pRc->state[txRate].rssiThres.
			 */
			pRc->hwMaxRetryPktCnt = 0;
  90c6ff:	c080      	movi.n	a8, 0
  90c701:	600010        	j	90c715 <rcUpdate_ht$constprop$5+0x125>
		} else {
			/*
			 * It worked with no retries.  First ignore bogus (small)
			 * rssiAck values.
			 */
			if (txRate == pRc->rateMaxPhy && pRc->hwMaxRetryPktCnt < 255) {
  90c704:	28306d        	l8ui	a8, a3, 109
  90c707:	78490d        	bne	a4, a8, 90c718 <rcUpdate_ht$constprop$5+0x128>
  90c70a:	283038        	l8ui	a8, a3, 56
  90c70d:	290aff        	movi	a9, 255
  90c710:	798104        	beq	a8, a9, 90c718 <rcUpdate_ht$constprop$5+0x128>
				pRc->hwMaxRetryPktCnt++;
  90c713:	b188      	addi.n	a8, a8, 1
  90c715:	283438        	s8i	a8, a3, 56
    
	/*
	 * If this rate looks bad (high PER) then stop using it for
	 * a while (except if we are probing).
	 */
	if (pRc->state[txRate].per >= 55 && txRate > 0 &&
  90c718:	2a2000        	l8ui	a10, a2, 0
  90c71b:	644056        	beqz	a4, 90c775 <rcUpdate_ht$constprop$5+0x185>
  90c71e:	c386      	movi.n	a8, 54
  90c720:	7a8b51        	bgeu	a8, a10, 90c775 <rcUpdate_ht$constprop$5+0x185>
	    pRateTable->info[txRate].rateKbps <= 
            pRateTable->info[pRc->rateMaxPhy].rateKbps)
  90c723:	2b306d        	l8ui	a11, a3, 109
	/*
	 * If this rate looks bad (high PER) then stop using it for
	 * a while (except if we are probing).
	 */
	if (pRc->state[txRate].per >= 55 && txRate > 0 &&
	    pRateTable->info[txRate].rateKbps <= 
  90c726:	0e4911        	slli	a9, a4, 2
            pRateTable->info[pRc->rateMaxPhy].rateKbps)
  90c729:	0eb811        	slli	a8, a11, 2
	/*
	 * If this rate looks bad (high PER) then stop using it for
	 * a while (except if we are probing).
	 */
	if (pRc->state[txRate].per >= 55 && txRate > 0 &&
	    pRateTable->info[txRate].rateKbps <= 
  90c72c:	a499      	add.n	a9, a9, a4
            pRateTable->info[pRc->rateMaxPhy].rateKbps)
  90c72e:	ab88      	add.n	a8, a8, a11
	/*
	 * If this rate looks bad (high PER) then stop using it for
	 * a while (except if we are probing).
	 */
	if (pRc->state[txRate].per >= 55 && txRate > 0 &&
	    pRateTable->info[txRate].rateKbps <= 
  90c730:	0f9911        	slli	a9, a9, 1
            pRateTable->info[pRc->rateMaxPhy].rateKbps)
  90c733:	0f8811        	slli	a8, a8, 1
	/*
	 * If this rate looks bad (high PER) then stop using it for
	 * a while (except if we are probing).
	 */
	if (pRc->state[txRate].per >= 55 && txRate > 0 &&
	    pRateTable->info[txRate].rateKbps <= 
  90c736:	a499      	add.n	a9, a9, a4
            pRateTable->info[pRc->rateMaxPhy].rateKbps)
  90c738:	ab88      	add.n	a8, a8, a11
	/*
	 * If this rate looks bad (high PER) then stop using it for
	 * a while (except if we are probing).
	 */
	if (pRc->state[txRate].per >= 55 && txRate > 0 &&
	    pRateTable->info[txRate].rateKbps <= 
  90c73a:	0e9911        	slli	a9, a9, 2
            pRateTable->info[pRc->rateMaxPhy].rateKbps)
  90c73d:	0e8811        	slli	a8, a8, 2
	/*
	 * If this rate looks bad (high PER) then stop using it for
	 * a while (except if we are probing).
	 */
	if (pRc->state[txRate].per >= 55 && txRate > 0 &&
	    pRateTable->info[txRate].rateKbps <= 
  90c740:	a979      	add.n	a9, a7, a9
            pRateTable->info[pRc->rateMaxPhy].rateKbps)
  90c742:	a878      	add.n	a8, a7, a8
    
	/*
	 * If this rate looks bad (high PER) then stop using it for
	 * a while (except if we are probing).
	 */
	if (pRc->state[txRate].per >= 55 && txRate > 0 &&
  90c744:	8995      	l32i.n	a9, a9, 20
  90c746:	8885      	l32i.n	a8, a8, 20
  90c748:	798329        	bltu	a8, a9, 90c775 <rcUpdate_ht$constprop$5+0x185>
  90c74b:	040c47        	extui	a12, a4, 0, 8
rcGetNextLowerValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc,  
                          A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_INT8 i;

	for (i = 1; i < pRc->maxValidRate ; i++) {
  90c74e:	2b3039        	l8ui	a11, a3, 57
  90c751:	c091      	movi.n	a9, 1
  90c753:	600015        	j	90c76c <rcUpdate_ht$constprop$5+0x17c>
		if (pRc->validRateIndex[i] == curValidTxRate) {
  90c756:	a838      	add.n	a8, a3, a8
  90c758:	2d803a        	l8ui	a13, a8, 58
  90c75b:	7cd908        	bne	a13, a12, 90c767 <rcUpdate_ht$constprop$5+0x177>
			*pNextIndex = pRc->validRateIndex[i-1];
  90c75e:	288039        	l8ui	a8, a8, 57
  90c761:	28346d        	s8i	a8, a3, 109
  90c764:	60000a        	j	90c772 <rcUpdate_ht$constprop$5+0x182>
  90c767:	b199      	addi.n	a9, a9, 1
rcGetNextLowerValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc,  
                          A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_INT8 i;

	for (i = 1; i < pRc->maxValidRate ; i++) {
  90c769:	090947        	extui	a9, a9, 0, 8
  90c76c:	009832        	sext	a8, a9, 7
  90c76f:	7b82e3        	blt	a8, a11, 90c756 <rcUpdate_ht$constprop$5+0x166>
	{
		rcGetNextLowerValidTxRate(pRateTable, pRc, (A_UINT8) txRate, 
					  &pRc->rateMaxPhy);

		/* Don't probe for a little while. */
		pRc->probeTime = nowMsec;
  90c772:	25360d        	s32i	a5, a3, 52
	}

	/* Make sure the rates below this have lower PER */
	/* Monotonicity is kept only for rates below the current rate. */
	if (pRc->state[txRate].per < lastPer) {
  90c775:	76a307        	bltu	a10, a6, 90c780 <rcUpdate_ht$constprop$5+0x190>
			}
		}
	}

	/* Maintain monotonicity for rates above the current rate*/
	for (rate = txRate; rate < pRc->rateTableSize - 1; rate++) {
  90c778:	26302e        	l8ui	a6, a3, 46
  90c77b:	b068      	addi.n	a8, a6, -1
  90c77d:	600049        	j	90c7ca <rcUpdate_ht$constprop$5+0x1da>
  90c780:	0e4811        	slli	a8, a4, 2
  90c783:	a488      	add.n	a8, a8, a4
  90c785:	0f8811        	slli	a8, a8, 1
  90c788:	a484      	add.n	a4, a8, a4
  90c78a:	0e4411        	slli	a4, a4, 2
  90c78d:	264ce4        	addi	a6, a4, -28
  90c790:	d920      	mov.n	a9, a2
  90c792:	a676      	add.n	a6, a7, a6

	/* Make sure the rates below this have lower PER */
	/* Monotonicity is kept only for rates below the current rate. */
	if (pRc->state[txRate].per < lastPer) {
		for (rate = txRate - 1; rate >= 0; rate--) {
			if (pRateTable->info[rate].phy != pRateTable->info[txRate].phy) {
  90c794:	a474      	add.n	a4, a7, a4
  90c796:	60001b        	j	90c7b5 <rcUpdate_ht$constprop$5+0x1c5>
  90c799:	2a6000        	l8ui	a10, a6, 0
  90c79c:	284010        	l8ui	a8, a4, 16
  90c79f:	78a9d5        	bne	a10, a8, 90c778 <rcUpdate_ht$constprop$5+0x188>
  90c7a2:	b098      	addi.n	a8, a9, -1
				break;
			}

			if (pRc->state[rate].per > pRc->state[rate+1].per) {
  90c7a4:	2a8000        	l8ui	a10, a8, 0
  90c7a7:	299000        	l8ui	a9, a9, 0
  90c7aa:	7a9b02        	bgeu	a9, a10, 90c7b0 <rcUpdate_ht$constprop$5+0x1c0>
				pRc->state[rate].per = pRc->state[rate+1].per;
  90c7ad:	298400        	s8i	a9, a8, 0
  90c7b0:	d980      	mov.n	a9, a8
  90c7b2:	266cd4        	addi	a6, a6, -44
	}

	/* Make sure the rates below this have lower PER */
	/* Monotonicity is kept only for rates below the current rate. */
	if (pRc->state[txRate].per < lastPer) {
		for (rate = txRate - 1; rate >= 0; rate--) {
  90c7b5:	7939e0        	bne	a3, a9, 90c799 <rcUpdate_ht$constprop$5+0x1a9>
  90c7b8:	63ffbc        	j	90c778 <rcUpdate_ht$constprop$5+0x188>
  90c7bb:	002420        	excw
		}
	}

	/* Maintain monotonicity for rates above the current rate*/
	for (rate = txRate; rate < pRc->rateTableSize - 1; rate++) {
		if (pRc->state[rate+1].per < pRc->state[rate].per) {
  90c7be:	002920        	excw
  90c7c1:	01749b        	excw
  90c7c4:	022424        	excw
			pRc->state[rate+1].per = pRc->state[rate].per;
  90c7c7:	01b122        	excw
			}
		}
	}

	/* Maintain monotonicity for rates above the current rate*/
	for (rate = txRate; rate < pRc->rateTableSize - 1; rate++) {
  90c7ca:	03240c        	sub	a4, a2, a3
  90c7cd:	7842eb        	blt	a4, a8, 90c7bc <rcUpdate_ht$constprop$5+0x1cc>
			pRc->state[rate+1].per = pRc->state[rate].per;
		}
	}

	/* Every so often, we reduce the thresholds and PER (different for CCK and OFDM). */
	if (nowMsec - pRc->perDownTime >= pRateTable->rssiReduceInterval) {
  90c7d0:	22321a        	l32i	a2, a3, 104
  90c7d3:	247002        	l8ui	a4, a7, 2
  90c7d6:	02520c        	sub	a2, a5, a2
  90c7d9:	74231f        	bltu	a2, a4, 90c7fc <rcUpdate_ht$constprop$5+0x20c>
  90c7dc:	d230      	mov.n	a2, a3
  90c7de:	600011        	j	90c7f3 <rcUpdate_ht$constprop$5+0x203>
		for (rate = 0; rate < pRc->rateTableSize; rate++) {
			pRc->state[rate].per = 7*pRc->state[rate].per/8;
  90c7e1:	272000        	l8ui	a7, a2, 0
  90c7e4:	0d7411        	slli	a4, a7, 3
  90c7e7:	07440c        	sub	a4, a4, a7
  90c7ea:	043412        	srai	a4, a4, 3
  90c7ed:	242400        	s8i	a4, a2, 0
  90c7f0:	222c01        	addi	a2, a2, 1
		}
	}

	/* Every so often, we reduce the thresholds and PER (different for CCK and OFDM). */
	if (nowMsec - pRc->perDownTime >= pRateTable->rssiReduceInterval) {
		for (rate = 0; rate < pRc->rateTableSize; rate++) {
  90c7f3:	03240c        	sub	a4, a2, a3
  90c7f6:	7642e7        	blt	a4, a6, 90c7e1 <rcUpdate_ht$constprop$5+0x1f1>
			pRc->state[rate].per = 7*pRc->state[rate].per/8;
		}

		pRc->perDownTime = nowMsec;
  90c7f9:	25361a        	s32i	a5, a3, 104
  90c7fc:	d10f      	retw.n
	...

0090c800 <rcRateGetIndex$constprop$9>:
	series->tx_chainmask = 1;
#endif
}

static A_UINT8 
rcRateGetIndex(struct ath_softc_tgt *sc, struct ath_node_target *an,        
  90c800:	6c1004        	entry	a1, 32
               const RATE_TABLE_11N *pRateTable , 
               A_UINT8 rix, A_UINT16 stepDown, A_UINT16 minRate)
{
	A_UINT32                j;
	A_UINT8                 nextIndex;
	struct atheros_node     *pSib = ATH_NODE_ATHEROS(an);
  90c803:	2a2282        	l32i	a10, a2, 0x208
	TX_RATE_CTRL            *pRc = (TX_RATE_CTRL *)(pSib);
    
	if (minRate) {
  90c806:	64604a        	beqz	a6, 90c854 <rcRateGetIndex$constprop$9+0x54>
rcGetNextLowerValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc,  
                          A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_INT8 i;

	for (i = 1; i < pRc->maxValidRate ; i++) {
  90c809:	2ba039        	l8ui	a11, a10, 57
  90c80c:	c490      	movi.n	a9, 64
  90c80e:	c081      	movi.n	a8, 1
  90c810:	600019        	j	90c82d <rcRateGetIndex$constprop$9+0x2d>
  90c813:	00a5a5        	excw
		if (pRc->validRateIndex[i] == curValidTxRate) {
  90c816:	2c503a        	l8ui	a12, a5, 58
  90c819:	74c90b        	bne	a12, a4, 90c828 <rcRateGetIndex$constprop$9+0x28>
  90c81c:	b099      	addi.n	a9, a9, -1
			*pNextIndex = pRc->validRateIndex[i-1];
  90c81e:	245039        	l8ui	a4, a5, 57
	A_UINT8                 nextIndex;
	struct atheros_node     *pSib = ATH_NODE_ATHEROS(an);
	TX_RATE_CTRL            *pRc = (TX_RATE_CTRL *)(pSib);
    
	if (minRate) {
		for (j = RATE_TABLE_11N_SIZE; j > 0; j-- ) {
  90c821:	659fe9        	bnez	a9, 90c80e <rcRateGetIndex$constprop$9+0xe>
  90c824:	600036        	j	90c85e <rcRateGetIndex$constprop$9+0x5e>
  90c827:	00b188        	excw
rcGetNextLowerValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc,  
                          A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_INT8 i;

	for (i = 1; i < pRc->maxValidRate ; i++) {
  90c82a:	080847        	extui	a8, a8, 0, 8
  90c82d:	008532        	sext	a5, a8, 7
  90c830:	7b52e0        	blt	a5, a11, 90c814 <rcRateGetIndex$constprop$9+0x14>
  90c833:	600027        	j	90c85e <rcRateGetIndex$constprop$9+0x5e>
		if (pRc->validRateIndex[i] == curValidTxRate) {
  90c836:	a9a9      	add.n	a9, a10, a9
  90c838:	2c903a        	l8ui	a12, a9, 58
  90c83b:	74c907        	bne	a12, a4, 90c846 <rcRateGetIndex$constprop$9+0x46>
			} else {
				break;
			}
		}
	} else {
		for (j = stepDown; j > 0; j-- ) {
  90c83e:	b055      	addi.n	a5, a5, -1
{
	A_INT8 i;

	for (i = 1; i < pRc->maxValidRate ; i++) {
		if (pRc->validRateIndex[i] == curValidTxRate) {
			*pNextIndex = pRc->validRateIndex[i-1];
  90c840:	249039        	l8ui	a4, a9, 57
  90c843:	60000d        	j	90c854 <rcRateGetIndex$constprop$9+0x54>
  90c846:	b188      	addi.n	a8, a8, 1
rcGetNextLowerValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc,  
                          A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_INT8 i;

	for (i = 1; i < pRc->maxValidRate ; i++) {
  90c848:	080847        	extui	a8, a8, 0, 8
  90c84b:	008932        	sext	a9, a8, 7
  90c84e:	7b92e4        	blt	a9, a11, 90c836 <rcRateGetIndex$constprop$9+0x36>
  90c851:	600009        	j	90c85e <rcRateGetIndex$constprop$9+0x5e>
			} else {
				break;
			}
		}
	} else {
		for (j = stepDown; j > 0; j-- ) {
  90c854:	c856      	beqz.n	a5, 90c85e <rcRateGetIndex$constprop$9+0x5e>
rcGetNextLowerValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc,  
                          A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_INT8 i;

	for (i = 1; i < pRc->maxValidRate ; i++) {
  90c856:	2ba039        	l8ui	a11, a10, 57
  90c859:	c081      	movi.n	a8, 1
  90c85b:	63ffec        	j	90c84b <rcRateGetIndex$constprop$9+0x4b>
			}
		}
	}

	return rix;
}
  90c85e:	d240      	mov.n	a2, a4
  90c860:	d10f      	retw.n
	...

0090c864 <rcRateFind_11n>:

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
		    int numTries, int numRates, int stepDnInc,
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
  90c864:	6c100c        	entry	a1, 96
  90c867:	9217      	s32i.n	a2, a1, 28
	A_UINT8 i = 0; 
	A_UINT8 tryPerRate  = 0;
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  90c869:	8817      	l32i.n	a8, a1, 28
		    int numTries, int numRates, int stepDnInc,
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
	A_UINT8 i = 0; 
	A_UINT8 tryPerRate  = 0;
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
  90c86b:	222248        	l32i	a2, a2, 0x120
}

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
		    int numTries, int numRates, int stepDnInc,
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
  90c86e:	9715      	s32i.n	a7, a1, 20
	A_UINT8 i = 0; 
	A_UINT8 tryPerRate  = 0;
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
  90c870:	9216      	s32i.n	a2, a1, 24
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  90c872:	2282c2        	l32i	a2, a8, 0x308
  90c875:	8916      	l32i.n	a9, a1, 24
	A_INT8               index;
	TX_RATE_CTRL         *pRc = NULL;

	pRc = (TX_RATE_CTRL *)(pSib ? (pSib) : NULL);

	*isProbing = FALSE;
  90c877:	2b1219        	l32i	a11, a1, 100
	struct atheros_node *asn = ATH_NODE_ATHEROS(an);
	A_UINT8 rix, nrix;
	A_UINT8 dot11Rate;
	WLAN_PHY phy;

	rix = rcRateFind_ht(sc, asn, pRateTable, (rcflag & ATH_RC_PROBE_ALLOWED) ? 1 : 0, 
  90c87a:	8815      	l32i.n	a8, a1, 20
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
	A_UINT8 i = 0; 
	A_UINT8 tryPerRate  = 0;
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  90c87c:	0e2211        	slli	a2, a2, 2
}

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
		    int numTries, int numRates, int stepDnInc,
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
  90c87f:	9419      	s32i.n	a4, a1, 36
	A_UINT8 i = 0; 
	A_UINT8 tryPerRate  = 0;
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  90c881:	a292      	add.n	a2, a9, a2
	A_INT8               index;
	TX_RATE_CTRL         *pRc = NULL;

	pRc = (TX_RATE_CTRL *)(pSib ? (pSib) : NULL);

	*isProbing = FALSE;
  90c883:	c040      	movi.n	a4, 0
	struct atheros_node *asn = ATH_NODE_ATHEROS(an);
	A_UINT8 rix, nrix;
	A_UINT8 dot11Rate;
	WLAN_PHY phy;

	rix = rcRateFind_ht(sc, asn, pRateTable, (rcflag & ATH_RC_PROBE_ALLOWED) ? 1 : 0, 
  90c885:	080940        	extui	a9, a8, 0, 1
}

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
		    int numTries, int numRates, int stepDnInc,
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
  90c888:	931a      	s32i.n	a3, a1, 40
  90c88a:	961b      	s32i.n	a6, a1, 44
	A_UINT8 i = 0; 
	A_UINT8 tryPerRate  = 0;
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
	struct atheros_node *asn = ATH_NODE_ATHEROS(an);
  90c88c:	233282        	l32i	a3, a3, 0x208
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
	A_UINT8 i = 0; 
	A_UINT8 tryPerRate  = 0;
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  90c88f:	8621      	l32i.n	a6, a2, 4
	 *   0msec   <= dt <= 25msec:   don't derate
	 *   25msec  <= dt <= 185msec:  derate linearly from 0 to 10dB
	 *   185msec <= dt:             derate by 10dB
	 */

	nowMsec = A_MS_TICKGET();
  90c891:	da40      	mov.n	a10, a4
	A_INT8               index;
	TX_RATE_CTRL         *pRc = NULL;

	pRc = (TX_RATE_CTRL *)(pSib ? (pSib) : NULL);

	*isProbing = FALSE;
  90c893:	94b0      	s32i.n	a4, a11, 0
}

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
		    int numTries, int numRates, int stepDnInc,
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
  90c895:	9518      	s32i.n	a5, a1, 32
	 *   0msec   <= dt <= 25msec:   don't derate
	 *   25msec  <= dt <= 185msec:  derate linearly from 0 to 10dB
	 *   185msec <= dt:             derate by 10dB
	 */

	nowMsec = A_MS_TICKGET();
  90c897:	29160c        	s32i	a9, a1, 48
}

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
		    int numTries, int numRates, int stepDnInc,
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
  90c89a:	251218        	l32i	a5, a1, 96
	 *   0msec   <= dt <= 25msec:   don't derate
	 *   25msec  <= dt <= 185msec:  derate linearly from 0 to 10dB
	 *   185msec <= dt:             derate by 10dB
	 */

	nowMsec = A_MS_TICKGET();
  90c89d:	5bec74        	call8	907a70 <ath_hal_getuptime>
	 * Now look up the rate in the rssi table and return it.
	 * If no rates match then we return 0 (lowest rate)
	 */

	bestThruput = 0;
	maxIndex = pRc->maxValidRate-1;
  90c8a0:	2b3039        	l8ui	a11, a3, 57
  90c8a3:	b0b7      	addi.n	a7, a11, -1
    
	/*
	 * Try the higher rate first. It will reduce memory moving time
	 * if we have very good channel characteristics.
	 */
	for (index = maxIndex; index >= minIndex ; index--) {
  90c8a5:	070747        	extui	a7, a7, 0, 8
	/*
	 * Now look up the rate in the rssi table and return it.
	 * If no rates match then we return 0 (lowest rate)
	 */

	bestThruput = 0;
  90c8a8:	dc40      	mov.n	a12, a4
		perThres = pRc->state[rate].per;
		if ( perThres < 12 ) {
			perThres = 12;
		}

		thisThruput = pRateTable->info[rate].userRateKbps * (100 - perThres);
  90c8aa:	c0ec      	movi.n	a14, 12
  90c8ac:	2f0a64        	movi	a15, 100
  90c8af:	891c      	l32i.n	a9, a1, 48
  90c8b1:	60004a        	j	90c8ff <rcRateFind_11n+0x9b>
	 * if we have very good channel characteristics.
	 */
	for (index = maxIndex; index >= minIndex ; index--) {
		A_UINT8 perThres;
    
		rate = pRc->validRateIndex[index];
  90c8b4:	a232      	add.n	a2, a3, a2
  90c8b6:	28203a        	l8ui	a8, a2, 58
		if (rate > pRc->rateMaxPhy) {
  90c8b9:	22306d        	l8ui	a2, a3, 109
  90c8bc:	78233a        	bltu	a2, a8, 90c8fa <rcRateFind_11n+0x96>
		}

		/* if the best throughput is already larger than the userRateKbps..
		 * then we could skip of rest of calculation.. 
		 */
		if( bestThruput >= pRateTable->info[rate].userRateKbps)
  90c8bf:	0e8211        	slli	a2, a8, 2
  90c8c2:	a822      	add.n	a2, a2, a8
  90c8c4:	0f2211        	slli	a2, a2, 1
  90c8c7:	a822      	add.n	a2, a2, a8
  90c8c9:	0e2211        	slli	a2, a2, 2
  90c8cc:	a262      	add.n	a2, a6, a2
  90c8ce:	8d26      	l32i.n	a13, a2, 24
  90c8d0:	7dc311        	bltu	a12, a13, 90c8e5 <rcRateFind_11n+0x81>
	/*
	 * Must check the actual rate (rateKbps) to account for non-monoticity of
	 * 11g's rate table
	 */

	if (rate >= pRc->rateMaxPhy && probeAllowed) {
  90c8d3:	22306d        	l8ui	a2, a3, 109
  90c8d6:	72436c        	bltu	a4, a2, 90c946 <rcRateFind_11n+0xe2>
  90c8d9:	8815      	l32i.n	a8, a1, 20
  90c8db:	7f8767        	bbci	a8, 31, 90c946 <rcRateFind_11n+0xe2>
  90c8de:	c040      	movi.n	a4, 0
rcGetNextValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc, 
                     A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_UINT8 i;

	for (i = 0; i < pRc->maxValidRate-1; i++) {
  90c8e0:	b0bb      	addi.n	a11, a11, -1
  90c8e2:	60003d        	j	90c923 <rcRateFind_11n+0xbf>
		 * rate whose PER has decayed close to 0.  If we
		 * used to next lower rate, its PER would grow to
		 * 10-15 and we would be worse off then staying
		 * at the current rate.
		 */
		perThres = pRc->state[rate].per;
  90c8e5:	a832      	add.n	a2, a3, a8
  90c8e7:	222000        	l8ui	a2, a2, 0
		if ( perThres < 12 ) {
			perThres = 12;
		}

		thisThruput = pRateTable->info[rate].userRateKbps * (100 - perThres);
  90c8ea:	0e2237        	maxu	a2, a2, a14
  90c8ed:	02f20c        	sub	a2, a15, a2
  90c8f0:	0d2228        	mull	a2, a2, a13
		if (bestThruput <= thisThruput) {
  90c8f3:	7c2303        	bltu	a2, a12, 90c8fa <rcRateFind_11n+0x96>
  90c8f6:	d480      	mov.n	a4, a8
  90c8f8:	dc20      	mov.n	a12, a2
  90c8fa:	b077      	addi.n	a7, a7, -1
    
	/*
	 * Try the higher rate first. It will reduce memory moving time
	 * if we have very good channel characteristics.
	 */
	for (index = maxIndex; index >= minIndex ; index--) {
  90c8fc:	070747        	extui	a7, a7, 0, 8
  90c8ff:	007232        	sext	a2, a7, 7
  90c902:	672fae        	bgez	a2, 90c8b4 <rcRateFind_11n+0x50>
  90c905:	63ffca        	j	90c8d3 <rcRateFind_11n+0x6f>
                     A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_UINT8 i;

	for (i = 0; i < pRc->maxValidRate-1; i++) {
		if (pRc->validRateIndex[i] == curValidTxRate) {
  90c908:	a437      	add.n	a7, a3, a4
  90c90a:	28703a        	l8ui	a8, a7, 58
  90c90d:	72890d        	bne	a8, a2, 90c91e <rcRateFind_11n+0xba>
		rate = pRc->rateMaxPhy;

		/* Probe the next allowed phy state */
		/* FIXME: Check to make sure ratMax is checked properly */
		if (rcGetNextValidTxRate( pRateTable, pRc, rate, &nextRate) && 
		    (nowMsec - pRc->probeTime > pRateTable->probeInterval) &&
  90c910:	843d      	l32i.n	a4, a3, 52
  90c912:	286001        	l8ui	a8, a6, 1
  90c915:	04a40c        	sub	a4, a10, a4
	if (rate >= pRc->rateMaxPhy && probeAllowed) {
		rate = pRc->rateMaxPhy;

		/* Probe the next allowed phy state */
		/* FIXME: Check to make sure ratMax is checked properly */
		if (rcGetNextValidTxRate( pRateTable, pRc, rate, &nextRate) && 
  90c918:	74830d        	bltu	a8, a4, 90c929 <rcRateFind_11n+0xc5>
  90c91b:	600029        	j	90c948 <rcRateFind_11n+0xe4>
rcGetNextValidTxRate(const RATE_TABLE_11N *pRateTable, TX_RATE_CTRL *pRc, 
                     A_UINT8 curValidTxRate, A_UINT8 *pNextIndex)
{
	A_UINT8 i;

	for (i = 0; i < pRc->maxValidRate-1; i++) {
  90c91e:	b144      	addi.n	a4, a4, 1
  90c920:	040447        	extui	a4, a4, 0, 8
  90c923:	7b42e1        	blt	a4, a11, 90c908 <rcRateFind_11n+0xa4>
  90c926:	60001e        	j	90c948 <rcRateFind_11n+0xe4>
		rate = pRc->rateMaxPhy;

		/* Probe the next allowed phy state */
		/* FIXME: Check to make sure ratMax is checked properly */
		if (rcGetNextValidTxRate( pRateTable, pRc, rate, &nextRate) && 
		    (nowMsec - pRc->probeTime > pRateTable->probeInterval) &&
  90c929:	243038        	l8ui	a4, a3, 56
  90c92c:	c948      	beqz.n	a4, 90c948 <rcRateFind_11n+0xe4>
{
	A_UINT8 i;

	for (i = 0; i < pRc->maxValidRate-1; i++) {
		if (pRc->validRateIndex[i] == curValidTxRate) {
			*pNextIndex = pRc->validRateIndex[i+1];
  90c92e:	22703b        	l8ui	a2, a7, 59
		    (pRc->hwMaxRetryPktCnt >= 1))
		{
			rate                  = nextRate;
			pRc->probeRate        = rate;
			pRc->probeTime        = nowMsec;
			pRc->hwMaxRetryPktCnt = 0;
  90c931:	c040      	movi.n	a4, 0
			*isProbing            = TRUE;
  90c933:	2b1219        	l32i	a11, a1, 100
		    (pRc->hwMaxRetryPktCnt >= 1))
		{
			rate                  = nextRate;
			pRc->probeRate        = rate;
			pRc->probeTime        = nowMsec;
			pRc->hwMaxRetryPktCnt = 0;
  90c936:	243438        	s8i	a4, a3, 56
		if (rcGetNextValidTxRate( pRateTable, pRc, rate, &nextRate) && 
		    (nowMsec - pRc->probeTime > pRateTable->probeInterval) &&
		    (pRc->hwMaxRetryPktCnt >= 1))
		{
			rate                  = nextRate;
			pRc->probeRate        = rate;
  90c939:	22342f        	s8i	a2, a3, 47
			pRc->probeTime        = nowMsec;
  90c93c:	9a3d      	s32i.n	a10, a3, 52
			pRc->hwMaxRetryPktCnt = 0;
			*isProbing            = TRUE;
  90c93e:	c041      	movi.n	a4, 1
  90c940:	94b0      	s32i.n	a4, a11, 0
  90c942:	600002        	j	90c948 <rcRateFind_11n+0xe4>
  90c945:	00d240        	extui	a2, a0, 13, 1
	 * Make sure rate is not higher than the allowed maximum.
	 * We should also enforce the min, but I suspect the min is
	 * normally 1 rather than 0 because of the rate 9 vs 6 issue
	 * in the old code.
	 */
	if (rate > (pRc->rateTableSize - 1)) {
  90c948:	24302e        	l8ui	a4, a3, 46
  90c94b:	742205        	blt	a2, a4, 90c954 <rcRateFind_11n+0xf0>
		rate = pRc->rateTableSize - 1;
  90c94e:	224cff        	addi	a2, a4, -1
  90c951:	020247        	extui	a2, a2, 0, 8
	}

	/* record selected rate, which is used to decide if we want to do fast frame */
	if (!(*isProbing) && pSib) {
  90c954:	2c1219        	l32i	a12, a1, 100
  90c957:	87c0      	l32i.n	a7, a12, 0
  90c959:	657178        	bnez	a7, 90cad5 <rcRateFind_11n+0x271>
		pSib->lastRateKbps = pRateTable->info[rate].rateKbps;
  90c95c:	0e2411        	slli	a4, a2, 2
  90c95f:	a244      	add.n	a4, a4, a2
  90c961:	0f4411        	slli	a4, a4, 1
  90c964:	a244      	add.n	a4, a4, a2
  90c966:	0e4411        	slli	a4, a4, 2
  90c969:	a464      	add.n	a4, a6, a4
		((struct atheros_softc*)sc->sc_rc)->currentTxRateKbps = pSib->lastRateKbps;
  90c96b:	8a17      	l32i.n	a10, a1, 28
		rate = pRc->rateTableSize - 1;
	}

	/* record selected rate, which is used to decide if we want to do fast frame */
	if (!(*isProbing) && pSib) {
		pSib->lastRateKbps = pRateTable->info[rate].rateKbps;
  90c96d:	8845      	l32i.n	a8, a4, 20
		((struct atheros_softc*)sc->sc_rc)->currentTxRateKbps = pSib->lastRateKbps;
  90c96f:	24a248        	l32i	a4, a10, 0x120
		rate = pRc->rateTableSize - 1;
	}

	/* record selected rate, which is used to decide if we want to do fast frame */
	if (!(*isProbing) && pSib) {
		pSib->lastRateKbps = pRateTable->info[rate].rateKbps;
  90c972:	28361c        	s32i	a8, a3, 112
		((struct atheros_softc*)sc->sc_rc)->currentTxRateKbps = pSib->lastRateKbps;
  90c975:	9844      	s32i.n	a8, a4, 16
		((struct atheros_softc*)sc->sc_rc)->currentTxRateIndex = rate;
  90c977:	9245      	s32i.n	a2, a4, 20
	A_UINT8 dot11Rate;
	WLAN_PHY phy;

	rix = rcRateFind_ht(sc, asn, pRateTable, (rcflag & ATH_RC_PROBE_ALLOWED) ? 1 : 0, 
			    isProbe);
	nrix = rix;
  90c979:	d820      	mov.n	a8, a2

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
		    int numTries, int numRates, int stepDnInc,
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
	A_UINT8 i = 0; 
  90c97b:	d490      	mov.n	a4, a9

	rix = rcRateFind_ht(sc, asn, pRateTable, (rcflag & ATH_RC_PROBE_ALLOWED) ? 1 : 0, 
			    isProbe);
	nrix = rix;

	if ((rcflag & ATH_RC_PROBE_ALLOWED) && (*isProbe)) {
  90c97d:	cb91      	beqz.n	a9, 90c9b2 <rcRateFind_11n+0x14e>
  90c97f:	89c0      	l32i.n	a9, a12, 0

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
		    int numTries, int numRates, int stepDnInc,
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
	A_UINT8 i = 0; 
  90c981:	d470      	mov.n	a4, a7

	rix = rcRateFind_ht(sc, asn, pRateTable, (rcflag & ATH_RC_PROBE_ALLOWED) ? 1 : 0, 
			    isProbe);
	nrix = rix;

	if ((rcflag & ATH_RC_PROBE_ALLOWED) && (*isProbe)) {
  90c983:	ca9b      	beqz.n	a9, 90c9b2 <rcRateFind_11n+0x14e>
		/* set one try for probe rates. For the probes don't enable rts */
		rcRateSetseries(pRateTable, &series[i++], 1, nrix,
				FALSE, asc->tx_chainmask, asn->stbc);
  90c985:	24321d        	l32i	a4, a3, 116
			    isProbe);
	nrix = rix;

	if ((rcflag & ATH_RC_PROBE_ALLOWED) && (*isProbe)) {
		/* set one try for probe rates. For the probes don't enable rts */
		rcRateSetseries(pRateTable, &series[i++], 1, nrix,
  90c988:	c0e0      	movi.n	a14, 0
  90c98a:	04d451        	extui	a4, a4, 29, 2
  90c98d:	9410      	s32i.n	a4, a1, 0
  90c98f:	8416      	l32i.n	a4, a1, 24
  90c991:	dd20      	mov.n	a13, a2
  90c993:	8f43      	l32i.n	a15, a4, 12
  90c995:	c0c1      	movi.n	a12, 1
  90c997:	db50      	mov.n	a11, a5
  90c999:	da60      	mov.n	a10, a6
  90c99b:	5bfdc4        	call8	90c0ac <rcRateSetseries>
          
		/*
		 * Get the next tried/allowed rate. No RTS for the next series
		 * after the probe rate
		 */
		nrix = rcRateGetIndex( sc, an, pRateTable, nrix, 1, FALSE);
  90c99e:	8a1a      	l32i.n	a10, a1, 40
  90c9a0:	c0e0      	movi.n	a14, 0
  90c9a2:	c0d1      	movi.n	a13, 1
  90c9a4:	022c02        	or	a12, a2, a2
  90c9a7:	066b02        	or	a11, a6, a6
  90c9aa:	5bff95        	call8	90c800 <rcRateGetIndex$constprop$9>
  90c9ad:	d8a0      	mov.n	a8, a10
			    isProbe);
	nrix = rix;

	if ((rcflag & ATH_RC_PROBE_ALLOWED) && (*isProbe)) {
		/* set one try for probe rates. For the probes don't enable rts */
		rcRateSetseries(pRateTable, &series[i++], 1, nrix,
  90c9af:	240a01        	movi	a4, 1
		 * after the probe rate
		 */
		nrix = rcRateGetIndex( sc, an, pRateTable, nrix, 1, FALSE);
	}

	tryPerRate = (numTries/numRates);
  90c9b2:	8b18      	l32i.n	a11, a1, 32
  90c9b4:	8a19      	l32i.n	a10, a1, 36
  90c9b6:	981c      	s32i.n	a8, a1, 48

	/* Set the choosen rate. No RTS for first series entry. */
	rcRateSetseries(pRateTable, &series[i++], tryPerRate,
  90c9b8:	b147      	addi.n	a7, a4, 1
		 * after the probe rate
		 */
		nrix = rcRateGetIndex( sc, an, pRateTable, nrix, 1, FALSE);
	}

	tryPerRate = (numTries/numRates);
  90c9ba:	5b67f7        	call8	8e6998 <__divsi3>

	/* Set the choosen rate. No RTS for first series entry. */
	rcRateSetseries(pRateTable, &series[i++], tryPerRate,
  90c9bd:	04044f        	extui	a4, a4, 0, 16
  90c9c0:	0f4b11        	slli	a11, a4, 1
  90c9c3:	a4bb      	add.n	a11, a11, a4
			nrix, FALSE, asc->tx_chainmask, asn->stbc);
  90c9c5:	24321d        	l32i	a4, a3, 116
	}

	tryPerRate = (numTries/numRates);

	/* Set the choosen rate. No RTS for first series entry. */
	rcRateSetseries(pRateTable, &series[i++], tryPerRate,
  90c9c8:	881c      	l32i.n	a8, a1, 48
  90c9ca:	04d451        	extui	a4, a4, 29, 2
  90c9cd:	9410      	s32i.n	a4, a1, 0
  90c9cf:	8416      	l32i.n	a4, a1, 24
		 * after the probe rate
		 */
		nrix = rcRateGetIndex( sc, an, pRateTable, nrix, 1, FALSE);
	}

	tryPerRate = (numTries/numRates);
  90c9d1:	0a0947        	extui	a9, a10, 0, 8

	/* Set the choosen rate. No RTS for first series entry. */
	rcRateSetseries(pRateTable, &series[i++], tryPerRate,
  90c9d4:	8f43      	l32i.n	a15, a4, 12
  90c9d6:	0ebb11        	slli	a11, a11, 2
  90c9d9:	dc90      	mov.n	a12, a9
  90c9db:	c0e0      	movi.n	a14, 0
  90c9dd:	dd80      	mov.n	a13, a8
  90c9df:	ab5b      	add.n	a11, a5, a11
  90c9e1:	da60      	mov.n	a10, a6
		 * after the probe rate
		 */
		nrix = rcRateGetIndex( sc, an, pRateTable, nrix, 1, FALSE);
	}

	tryPerRate = (numTries/numRates);
  90c9e3:	9914      	s32i.n	a9, a1, 16

	/* Set the choosen rate. No RTS for first series entry. */
	rcRateSetseries(pRateTable, &series[i++], tryPerRate,
  90c9e5:	5bfdb1        	call8	90c0ac <rcRateSetseries>
  90c9e8:	8914      	l32i.n	a9, a1, 16
  90c9ea:	07941c        	mul16u	a4, a9, a7
  90c9ed:	8919      	l32i.n	a9, a1, 36
  90c9ef:	04940c        	sub	a4, a9, a4
	for (; i < numRates; i++) {
		A_UINT8 tryNum;
		A_UINT8 minRate;

		tryNum  = ((i + 1) == numRates) ? numTries - (tryPerRate * i) : tryPerRate ;
		minRate = (((i + 1) == numRates) && (rcflag & ATH_RC_MINRATE_LASTRATE)) ? 1 : 0;
  90c9f2:	8915      	l32i.n	a9, a1, 20
  90c9f4:	040447        	extui	a4, a4, 0, 8
  90c9f7:	091940        	extui	a9, a9, 1, 1
  90c9fa:	9915      	s32i.n	a9, a1, 20

		nrix = rcRateGetIndex(sc, an, pRateTable, nrix, stepDnInc, minRate);
  90c9fc:	891b      	l32i.n	a9, a1, 44
  90c9fe:	09094f        	extui	a9, a9, 0, 16
  90ca01:	9919      	s32i.n	a9, a1, 36
  90ca03:	60005c        	j	90ca63 <rcRateFind_11n+0x1ff>
	/* Fill in the other rates for multirate retry */
	for (; i < numRates; i++) {
		A_UINT8 tryNum;
		A_UINT8 minRate;

		tryNum  = ((i + 1) == numRates) ? numTries - (tryPerRate * i) : tryPerRate ;
  90ca06:	8c18      	l32i.n	a12, a1, 32
  90ca08:	b17a      	addi.n	a10, a7, 1
  90ca0a:	0acb0c        	sub	a11, a12, a10
  90ca0d:	8c15      	l32i.n	a12, a1, 20
		minRate = (((i + 1) == numRates) && (rcflag & ATH_RC_MINRATE_LASTRATE)) ? 1 : 0;
  90ca0f:	c0e0      	movi.n	a14, 0
	/* Fill in the other rates for multirate retry */
	for (; i < numRates; i++) {
		A_UINT8 tryNum;
		A_UINT8 minRate;

		tryNum  = ((i + 1) == numRates) ? numTries - (tryPerRate * i) : tryPerRate ;
  90ca11:	0bce38        	moveqz	a14, a12, a11
  90ca14:	8b18      	l32i.n	a11, a1, 32
  90ca16:	8914      	l32i.n	a9, a1, 16
  90ca18:	0aba0c        	sub	a10, a11, a10
  90ca1b:	0a4938        	moveqz	a9, a4, a10
		minRate = (((i + 1) == numRates) && (rcflag & ATH_RC_MINRATE_LASTRATE)) ? 1 : 0;

		nrix = rcRateGetIndex(sc, an, pRateTable, nrix, stepDnInc, minRate);
  90ca1e:	8d19      	l32i.n	a13, a1, 36
  90ca20:	8a1a      	l32i.n	a10, a1, 40
  90ca22:	dc80      	mov.n	a12, a8
  90ca24:	066b02        	or	a11, a6, a6
  90ca27:	991c      	s32i.n	a9, a1, 48
  90ca29:	5bff75        	call8	90c800 <rcRateGetIndex$constprop$9>
  90ca2c:	d8a0      	mov.n	a8, a10

		/* All other rates in the series have RTS enabled */
		rcRateSetseries(pRateTable, &series[i], tryNum,
  90ca2e:	070a4f        	extui	a10, a7, 0, 16
  90ca31:	0fab11        	slli	a11, a10, 1
  90ca34:	aabb      	add.n	a11, a11, a10
				nrix, TRUE, asc->tx_chainmask, asn->stbc);
  90ca36:	2a321d        	l32i	a10, a3, 116
		minRate = (((i + 1) == numRates) && (rcflag & ATH_RC_MINRATE_LASTRATE)) ? 1 : 0;

		nrix = rcRateGetIndex(sc, an, pRateTable, nrix, stepDnInc, minRate);

		/* All other rates in the series have RTS enabled */
		rcRateSetseries(pRateTable, &series[i], tryNum,
  90ca39:	8c16      	l32i.n	a12, a1, 24
  90ca3b:	0ada51        	extui	a10, a10, 29, 2
  90ca3e:	891c      	l32i.n	a9, a1, 48
  90ca40:	9a10      	s32i.n	a10, a1, 0
  90ca42:	8fc3      	l32i.n	a15, a12, 12
  90ca44:	0ebb11        	slli	a11, a11, 2
  90ca47:	dc90      	mov.n	a12, a9
  90ca49:	c0e1      	movi.n	a14, 1
  90ca4b:	dd80      	mov.n	a13, a8
  90ca4d:	ab5b      	add.n	a11, a5, a11
  90ca4f:	da60      	mov.n	a10, a6
  90ca51:	981c      	s32i.n	a8, a1, 48
  90ca53:	5bfd96        	call8	90c0ac <rcRateSetseries>
  90ca56:	8914      	l32i.n	a9, a1, 16
	/* Set the choosen rate. No RTS for first series entry. */
	rcRateSetseries(pRateTable, &series[i++], tryPerRate,
			nrix, FALSE, asc->tx_chainmask, asn->stbc);

	/* Fill in the other rates for multirate retry */
	for (; i < numRates; i++) {
  90ca58:	b177      	addi.n	a7, a7, 1
  90ca5a:	09440c        	sub	a4, a4, a9
  90ca5d:	070747        	extui	a7, a7, 0, 8
  90ca60:	040447        	extui	a4, a4, 0, 8
  90ca63:	8918      	l32i.n	a9, a1, 32
  90ca65:	881c      	l32i.n	a8, a1, 48
  90ca67:	79729b        	blt	a7, a9, 90ca06 <rcRateFind_11n+0x1a2>
	 *    {MCS2, MCS1, MCS0, MCS0}.
	 * When first rate in series is MCS3 in HT20 @ 2.4GHz, series should look like:
	 *    {MCS3, MCS2, MCS1, MCS1}
	 * So, set fourth rate in series to be same as third one for above conditions.
	 */
	if (sc->sc_curmode == IEEE80211_MODE_11NG) {
  90ca6a:	8817      	l32i.n	a8, a1, 28
  90ca6c:	2482c2        	l32i	a4, a8, 0x308
  90ca6f:	69416d        	bnei	a4, 1, 90cae0 <rcRateFind_11n+0x27c>
		dot11Rate = pRateTable->info[rix].dot11Rate;
  90ca72:	0e2311        	slli	a3, a2, 2
  90ca75:	a233      	add.n	a3, a3, a2
  90ca77:	0f3311        	slli	a3, a3, 1
  90ca7a:	a232      	add.n	a2, a3, a2
  90ca7c:	0e2211        	slli	a2, a2, 2
  90ca7f:	a266      	add.n	a6, a6, a2
  90ca81:	28601e        	l8ui	a8, a6, 30
		phy = pRateTable->info[rix].phy;
		if (i == 4 &&
  90ca84:	697448        	bnei	a7, 4, 90cad0 <rcRateFind_11n+0x26c>
		    ((dot11Rate == 2 && phy == WLAN_RC_PHY_HT_40_SS) || 
  90ca87:	270a00        	movi	a7, 0
  90ca8a:	238cfe        	addi	a3, a8, -2
  90ca8d:	077902        	or	a9, a7, a7
  90ca90:	034938        	moveqz	a9, a4, a3
	 * So, set fourth rate in series to be same as third one for above conditions.
	 */
	if (sc->sc_curmode == IEEE80211_MODE_11NG) {
		dot11Rate = pRateTable->info[rix].dot11Rate;
		phy = pRateTable->info[rix].phy;
		if (i == 4 &&
  90ca93:	090347        	extui	a3, a9, 0, 8
	 *    {MCS3, MCS2, MCS1, MCS1}
	 * So, set fourth rate in series to be same as third one for above conditions.
	 */
	if (sc->sc_curmode == IEEE80211_MODE_11NG) {
		dot11Rate = pRateTable->info[rix].dot11Rate;
		phy = pRateTable->info[rix].phy;
  90ca96:	266010        	l8ui	a6, a6, 16
		if (i == 4 &&
  90ca99:	77310b        	beq	a3, a7, 90caa8 <rcRateFind_11n+0x244>
		    ((dot11Rate == 2 && phy == WLAN_RC_PHY_HT_40_SS) || 
  90ca9c:	226cfa        	addi	a2, a6, -6
  90ca9f:	027439        	movnez	a4, a7, a2
	 * So, set fourth rate in series to be same as third one for above conditions.
	 */
	if (sc->sc_curmode == IEEE80211_MODE_11NG) {
		dot11Rate = pRateTable->info[rix].dot11Rate;
		phy = pRateTable->info[rix].phy;
		if (i == 4 &&
  90caa2:	040247        	extui	a2, a4, 0, 8
  90caa5:	772905        	bne	a2, a7, 90caae <rcRateFind_11n+0x24a>
		    ((dot11Rate == 2 && phy == WLAN_RC_PHY_HT_40_SS) || 
  90caa8:	698324        	bnei	a8, 3, 90cad0 <rcRateFind_11n+0x26c>
  90caab:	696421        	bnei	a6, 4, 90cad0 <rcRateFind_11n+0x26c>
		     (dot11Rate == 3 && phy == WLAN_RC_PHY_HT_20_SS))) 
		{
			series[3].rix = series[2].rix;
  90caae:	225018        	l8ui	a2, a5, 24
  90cab1:	225424        	s8i	a2, a5, 36
			series[3].flags = series[2].flags;
  90cab4:	22501b        	l8ui	a2, a5, 27
  90cab7:	225427        	s8i	a2, a5, 39
			series[3].max4msframelen = series[2].max4msframelen;
  90caba:	8257      	l32i.n	a2, a5, 28
  90cabc:	925a      	s32i.n	a2, a5, 40
  90cabe:	60000e        	j	90cad0 <rcRateFind_11n+0x26c>
	 *            Enable RTS/CTS at MCS 3-0 for downlink throughput.
	 */
	if (sc->sc_curmode == IEEE80211_MODE_11NG) {
		dot11Rate = pRateTable->info[rix].dot11Rate;
		if (dot11Rate <= 3 ) {
			series[0].flags |= ATH_RC_RTSCTS_FLAG;         
  90cac1:	225003        	l8ui	a2, a5, 3
  90cac4:	c130      	movi.n	a3, 16
  90cac6:	032202        	or	a2, a2, a3
  90cac9:	225403        	s8i	a2, a5, 3
		}
	}
}
  90cacc:	d10f      	retw.n
  90cace:	00006e        	excw
	 * AP91 Kite: NetGear OTA location-4 downlink.
	 *            Enable RTS/CTS at MCS 3-0 for downlink throughput.
	 */
	if (sc->sc_curmode == IEEE80211_MODE_11NG) {
		dot11Rate = pRateTable->info[rix].dot11Rate;
		if (dot11Rate <= 3 ) {
  90cad1:	84ed      	l32i.n	a4, a14, 52
  90cad3:	d10f      	retw.n
	A_UINT8 dot11Rate;
	WLAN_PHY phy;

	rix = rcRateFind_ht(sc, asn, pRateTable, (rcflag & ATH_RC_PROBE_ALLOWED) ? 1 : 0, 
			    isProbe);
	nrix = rix;
  90cad5:	d820      	mov.n	a8, a2

void rcRateFind_11n(struct ath_softc_tgt *sc, struct ath_node_target *an, 
		    int numTries, int numRates, int stepDnInc,
		    unsigned int rcflag, struct ath_rc_series series[], int *isProbe)
{
	A_UINT8 i = 0; 
  90cad7:	d490      	mov.n	a4, a9

	rix = rcRateFind_ht(sc, asn, pRateTable, (rcflag & ATH_RC_PROBE_ALLOWED) ? 1 : 0, 
			    isProbe);
	nrix = rix;

	if ((rcflag & ATH_RC_PROBE_ALLOWED) && (*isProbe)) {
  90cad9:	649ed5        	beqz	a9, 90c9b2 <rcRateFind_11n+0x14e>
  90cadc:	63fea5        	j	90c985 <rcRateFind_11n+0x121>
  90cadf:	00d10f        	subx8	a1, a13, a0
	...

0090cae4 <rcUpdate_11n>:
void rcUpdate_11n(struct ath_softc_tgt *sc, struct ath_node_target *an,
		  A_UINT8 curTxAnt, 
		  int finalTSIdx, int Xretries,
		  struct ath_rc_series rcs[], int nFrames, 
		  int nBad, int long_retry)
{
  90cae4:	6c1008        	entry	a1, 64
  90cae7:	d920      	mov.n	a9, a2
	A_UINT32 series = 0;
	A_UINT32 rix;
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  90cae9:	2492c2        	l32i	a4, a9, 0x308
  90caec:	222248        	l32i	a2, a2, 0x120
  90caef:	0e4411        	slli	a4, a4, 2
  90caf2:	a422      	add.n	a2, a2, a4
  90caf4:	8421      	l32i.n	a4, a2, 4
	struct atheros_node *pSib = ATH_NODE_ATHEROS(an);
  90caf6:	223282        	l32i	a2, a3, 0x208
void rcUpdate_11n(struct ath_softc_tgt *sc, struct ath_node_target *an,
		  A_UINT8 curTxAnt, 
		  int finalTSIdx, int Xretries,
		  struct ath_rc_series rcs[], int nFrames, 
		  int nBad, int long_retry)
{
  90caf9:	d870      	mov.n	a8, a7
	A_UINT32 series = 0;
	A_UINT32 rix;
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
	struct atheros_node *pSib = ATH_NODE_ATHEROS(an);
  90cafb:	9214      	s32i.n	a2, a1, 16
void rcUpdate_11n(struct ath_softc_tgt *sc, struct ath_node_target *an,
		  A_UINT8 curTxAnt, 
		  int finalTSIdx, int Xretries,
		  struct ath_rc_series rcs[], int nFrames, 
		  int nBad, int long_retry)
{
  90cafd:	c071      	movi.n	a7, 1

	/*
	 * If the first rate is not the final index, there are intermediate rate failures
	 * to be processed.
	 */
	if (finalTSIdx != 0) {
  90caff:	6450ba        	beqz	a5, 90cbbd <rcUpdate_11n+0xd9>
  90cb02:	c0a2      	movi.n	a10, 2
  90cb04:	d2a0      	mov.n	a2, a10
  90cb06:	067239        	movnez	a2, a7, a6
  90cb09:	9215      	s32i.n	a2, a1, 20
  90cb0b:	c070      	movi.n	a7, 0
  90cb0d:	d280      	mov.n	a2, a8
  90cb0f:	6000a1        	j	90cbb4 <rcUpdate_11n+0xd0>
  90cb12:	000000        	ill

		/* Process intermediate rates that failed.*/
		for (series = 0; series < finalTSIdx ; series++) {
			if (rcs[series].tries != 0) {
  90cb15:	2e2001        	l8ui	a14, a2, 1
  90cb18:	64e094        	beqz	a14, 90cbb0 <rcUpdate_11n+0xcc>
				flags = rcs[series].flags;
  90cb1b:	2c2003        	l8ui	a12, a2, 3
  90cb1e:	c0b2      	movi.n	a11, 2
  90cb20:	0bca01        	and	a10, a12, a11
				/* If HT40 and we have switched mode from 40 to 20 => don't update */
				if ((flags & ATH_RC_CW40_FLAG) && 
  90cb23:	c8a9      	beqz.n	a10, 90cb30 <rcUpdate_11n+0x4c>
  90cb25:	8d14      	l32i.n	a13, a1, 16
  90cb27:	2bd06c        	l8ui	a11, a13, 108
  90cb2a:	7ab102        	beq	a11, a10, 90cb30 <rcUpdate_11n+0x4c>
  90cb2d:	600147        	j	90cc78 <rcUpdate_11n+0x194>
				    (pRc->rcPhyMode != (flags & ATH_RC_CW40_FLAG))) {
					return;
				}
				if ((flags & ATH_RC_CW40_FLAG) && (flags & ATH_RC_HT40_SGI_FLAG)) {
  90cb30:	c0b6      	movi.n	a11, 6
  90cb32:	0bcb01        	and	a11, a12, a11
  90cb35:	69b617        	bnei	a11, 6, 90cb50 <rcUpdate_11n+0x6c>
					rix = pRateTable->info[rcs[series].rix].htIndex;
  90cb38:	2b2000        	l8ui	a11, a2, 0
  90cb3b:	0eba11        	slli	a10, a11, 2
  90cb3e:	abaa      	add.n	a10, a10, a11
  90cb40:	0faa11        	slli	a10, a10, 1
  90cb43:	abaa      	add.n	a10, a10, a11
  90cb45:	0eaa11        	slli	a10, a10, 2
  90cb48:	aa4a      	add.n	a10, a4, a10
  90cb4a:	2ca025        	l8ui	a12, a10, 37
  90cb4d:	600046        	j	90cb97 <rcUpdate_11n+0xb3>
  90cb50:	2b2000        	l8ui	a11, a2, 0
				} else if (flags & ATH_RC_HT40_SGI_FLAG) {
  90cb53:	7dc715        	bbci	a12, 29, 90cb6c <rcUpdate_11n+0x88>
					rix = pRateTable->info[rcs[series].rix].sgiIndex;
  90cb56:	0eba11        	slli	a10, a11, 2
  90cb59:	abaa      	add.n	a10, a10, a11
  90cb5b:	0faa11        	slli	a10, a10, 1
  90cb5e:	abaa      	add.n	a10, a10, a11
  90cb60:	0eaa11        	slli	a10, a10, 2
  90cb63:	aa4a      	add.n	a10, a4, a10
  90cb65:	2ca024        	l8ui	a12, a10, 36
  90cb68:	60002b        	j	90cb97 <rcUpdate_11n+0xb3>
  90cb6b:	00c9a5        	excw
				} else if (flags & ATH_RC_CW40_FLAG) {
					rix = pRateTable->info[rcs[series].rix].cw40Index;
  90cb6e:	0eba11        	slli	a10, a11, 2
  90cb71:	abaa      	add.n	a10, a10, a11
  90cb73:	0faa11        	slli	a10, a10, 1
  90cb76:	abaa      	add.n	a10, a10, a11
  90cb78:	0eaa11        	slli	a10, a10, 2
  90cb7b:	aa4a      	add.n	a10, a4, a10
  90cb7d:	2ca023        	l8ui	a12, a10, 35
  90cb80:	600013        	j	90cb97 <rcUpdate_11n+0xb3>
  90cb83:	00000e        	subx4	a0, a0, a0
				} else {
					rix = pRateTable->info[rcs[series].rix].baseIndex;
  90cb86:	ba11      	addi.n	a1, a1, 10
  90cb88:	abaa      	add.n	a10, a10, a11
  90cb8a:	0faa11        	slli	a10, a10, 1
  90cb8d:	abaa      	add.n	a10, a10, a11
  90cb8f:	0eaa11        	slli	a10, a10, 2
  90cb92:	aa4a      	add.n	a10, a4, a10
  90cb94:	2ca022        	l8ui	a12, a10, 34
  90cb97:	2a1210        	l32i	a10, a1, 64
				}

				/* FIXME:XXXX, too many args! */
				rcUpdate_ht(sc, an, rix, Xretries? 1 : 2, rcs[series].tries, 
  90cb9a:	8d15      	l32i.n	a13, a1, 20
  90cb9c:	0a0f4f        	extui	a15, a10, 0, 16
  90cb9f:	9f10      	s32i.n	a15, a1, 0
  90cba1:	da90      	mov.n	a10, a9
  90cba3:	db30      	mov.n	a11, a3
  90cba5:	9817      	s32i.n	a8, a1, 28
  90cba7:	9916      	s32i.n	a9, a1, 24
  90cba9:	5bfe91        	call8	90c5f0 <rcUpdate_ht$constprop$5>
  90cbac:	8916      	l32i.n	a9, a1, 24
  90cbae:	8817      	l32i.n	a8, a1, 28
	 * to be processed.
	 */
	if (finalTSIdx != 0) {

		/* Process intermediate rates that failed.*/
		for (series = 0; series < finalTSIdx ; series++) {
  90cbb0:	b177      	addi.n	a7, a7, 1
  90cbb2:	bc22      	addi.n	a2, a2, 12
  90cbb4:	757b02        	bgeu	a7, a5, 90cbba <rcUpdate_11n+0xd6>
  90cbb7:	63ff5a        	j	90cb15 <rcUpdate_11n+0x31>
  90cbba:	600023        	j	90cbe1 <rcUpdate_11n+0xfd>
		/*
		 * Handle the special case of MIMO PS burst, where the second aggregate is sent
		 *  out with only one rate and one try. Treating it as an excessive retry penalizes
		 * the rate inordinately.
		 */
		if (rcs[0].tries == 1 && Xretries == 1) {
  90cbbd:	228001        	l8ui	a2, a8, 1
  90cbc0:	db50      	mov.n	a11, a5
  90cbc2:	b022      	addi.n	a2, a2, -1
  90cbc4:	027b38        	moveqz	a11, a7, a2
  90cbc7:	0b0247        	extui	a2, a11, 0, 8
  90cbca:	c82a      	beqz.n	a2, 90cbd8 <rcUpdate_11n+0xf4>
  90cbcc:	b062      	addi.n	a2, a6, -1
  90cbce:	dd50      	mov.n	a13, a5
  90cbd0:	027d38        	moveqz	a13, a7, a2
  90cbd3:	0d0247        	extui	a2, a13, 0, 8
  90cbd6:	cc23      	bnez.n	a2, 90cbdd <rcUpdate_11n+0xf9>
		  A_UINT8 curTxAnt, 
		  int finalTSIdx, int Xretries,
		  struct ath_rc_series rcs[], int nFrames, 
		  int nBad, int long_retry)
{
	A_UINT32 series = 0;
  90cbd8:	c070      	movi.n	a7, 0
  90cbda:	600003        	j	90cbe1 <rcUpdate_11n+0xfd>
  90cbdd:	d750      	mov.n	a7, a5
		 * Handle the special case of MIMO PS burst, where the second aggregate is sent
		 *  out with only one rate and one try. Treating it as an excessive retry penalizes
		 * the rate inordinately.
		 */
		if (rcs[0].tries == 1 && Xretries == 1) {
			Xretries = 2;
  90cbdf:	c062      	movi.n	a6, 2
		}
	}

	flags = rcs[series].flags;
  90cbe1:	0f7211        	slli	a2, a7, 1
  90cbe4:	a727      	add.n	a7, a2, a7
  90cbe6:	0e7711        	slli	a7, a7, 2
  90cbe9:	a788      	add.n	a8, a8, a7
  90cbeb:	278003        	l8ui	a7, a8, 3
  90cbee:	c052      	movi.n	a5, 2
  90cbf0:	057501        	and	a5, a7, a5
	/* If HT40 and we have switched mode from 40 to 20 => don't update */
	if ((flags & ATH_RC_CW40_FLAG) && 
  90cbf3:	c856      	beqz.n	a5, 90cbfd <rcUpdate_11n+0x119>
  90cbf5:	8a14      	l32i.n	a10, a1, 16
  90cbf7:	22a06c        	l8ui	a2, a10, 108
  90cbfa:	75297a        	bne	a2, a5, 90cc78 <rcUpdate_11n+0x194>
	    (pRc->rcPhyMode != (flags & ATH_RC_CW40_FLAG))) {
		return;
	}
	if ((flags & ATH_RC_CW40_FLAG) && (flags & ATH_RC_HT40_SGI_FLAG)) {
  90cbfd:	c0a6      	movi.n	a10, 6
  90cbff:	0a7a01        	and	a10, a7, a10
  90cc02:	228000        	l8ui	a2, a8, 0
  90cc05:	69a614        	bnei	a10, 6, 90cc1d <rcUpdate_11n+0x139>
		rix = pRateTable->info[rcs[series].rix].htIndex;
  90cc08:	0e2511        	slli	a5, a2, 2
  90cc0b:	a255      	add.n	a5, a5, a2
  90cc0d:	0f5511        	slli	a5, a5, 1
  90cc10:	a252      	add.n	a2, a5, a2
  90cc12:	0e2211        	slli	a2, a2, 2
  90cc15:	a244      	add.n	a4, a4, a2
  90cc17:	2c4025        	l8ui	a12, a4, 37
  90cc1a:	600040        	j	90cc5e <rcUpdate_11n+0x17a>
	} else if (flags & ATH_RC_HT40_SGI_FLAG) {
  90cc1d:	7d7714        	bbci	a7, 29, 90cc35 <rcUpdate_11n+0x151>
		rix = pRateTable->info[rcs[series].rix].sgiIndex;
  90cc20:	0e2511        	slli	a5, a2, 2
  90cc23:	a255      	add.n	a5, a5, a2
  90cc25:	0f5511        	slli	a5, a5, 1
  90cc28:	a252      	add.n	a2, a5, a2
  90cc2a:	0e2211        	slli	a2, a2, 2
  90cc2d:	a244      	add.n	a4, a4, a2
  90cc2f:	2c4024        	l8ui	a12, a4, 36
  90cc32:	600028        	j	90cc5e <rcUpdate_11n+0x17a>
	} else if (flags & ATH_RC_CW40_FLAG) {
  90cc35:	c953      	beqz.n	a5, 90cc4c <rcUpdate_11n+0x168>
		rix = pRateTable->info[rcs[series].rix].cw40Index;
  90cc37:	0e2511        	slli	a5, a2, 2
  90cc3a:	a255      	add.n	a5, a5, a2
  90cc3c:	0f5511        	slli	a5, a5, 1
  90cc3f:	a252      	add.n	a2, a5, a2
  90cc41:	0e2211        	slli	a2, a2, 2
  90cc44:	a244      	add.n	a4, a4, a2
  90cc46:	2c4023        	l8ui	a12, a4, 35
  90cc49:	600011        	j	90cc5e <rcUpdate_11n+0x17a>
	} else {
		rix = pRateTable->info[rcs[series].rix].baseIndex;
  90cc4c:	0e2511        	slli	a5, a2, 2
  90cc4f:	a255      	add.n	a5, a5, a2
  90cc51:	0f5511        	slli	a5, a5, 1
  90cc54:	a252      	add.n	a2, a5, a2
  90cc56:	0e2211        	slli	a2, a2, 2
  90cc59:	a244      	add.n	a4, a4, a2
  90cc5b:	2c4022        	l8ui	a12, a4, 34
	}

	/* FIXME:XXXX, too many args! */
	rcUpdate_ht(sc, an, rix, Xretries, long_retry, curTxAnt, 
  90cc5e:	221211        	l32i	a2, a1, 68
  90cc61:	2e1212        	l32i	a14, a1, 72
  90cc64:	02024f        	extui	a2, a2, 0, 16
  90cc67:	9210      	s32i.n	a2, a1, 0
  90cc69:	221210        	l32i	a2, a1, 64
  90cc6c:	dd60      	mov.n	a13, a6
  90cc6e:	020f4f        	extui	a15, a2, 0, 16
  90cc71:	db30      	mov.n	a11, a3
  90cc73:	da90      	mov.n	a10, a9
  90cc75:	5bfe5e        	call8	90c5f0 <rcUpdate_ht$constprop$5>
  90cc78:	d10f      	retw.n
	...

0090cc7c <ath_tx_status_update_rate>:

void ath_tx_status_update_rate(struct ath_softc_tgt *sc,
			       struct ath_rc_series rcs[],
			       int series,
			       WMI_TXSTATUS_EVENT *txs)
{
  90cc7c:	6c1004        	entry	a1, 32
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  90cc7f:	2922c2        	l32i	a9, a2, 0x308
  90cc82:	282248        	l32i	a8, a2, 0x120
  90cc85:	0e9911        	slli	a9, a9, 2
  90cc88:	a988      	add.n	a8, a8, a9

	/* HT Rate */
	if (pRateTable->info[rcs[series].rix].rateCode & 0x80) {
  90cc8a:	0f4911        	slli	a9, a4, 1
  90cc8d:	a494      	add.n	a4, a9, a4
  90cc8f:	0e4411        	slli	a4, a4, 2
  90cc92:	a433      	add.n	a3, a3, a4
  90cc94:	293000        	l8ui	a9, a3, 0
			       struct ath_rc_series rcs[],
			       int series,
			       WMI_TXSTATUS_EVENT *txs)
{
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];
  90cc97:	8a81      	l32i.n	a10, a8, 4

	/* HT Rate */
	if (pRateTable->info[rcs[series].rix].rateCode & 0x80) {
  90cc99:	0e9811        	slli	a8, a9, 2
  90cc9c:	a988      	add.n	a8, a8, a9
  90cc9e:	0f8811        	slli	a8, a8, 1
  90cca1:	a988      	add.n	a8, a8, a9
  90cca3:	0e8811        	slli	a8, a8, 2
  90cca6:	245000        	l8ui	a4, a5, 0
  90cca9:	a8aa      	add.n	a10, a10, a8
  90ccab:	22a01c        	l8ui	a2, a10, 28
  90ccae:	0f4811        	slli	a8, a4, 1
  90ccb1:	a488      	add.n	a8, a8, a4
  90ccb3:	a858      	add.n	a8, a5, a8
  90ccb5:	782738        	bbci	a2, 24, 90ccf1 <ath_tx_status_update_rate+0x75>
		txs->txstatus[txs->cnt].ts_rate |= SM(pRateTable->info[rcs[series].rix].dot11Rate,
  90ccb8:	29a01e        	l8ui	a9, a10, 30
  90ccbb:	228002        	l8ui	a2, a8, 2
  90ccbe:	090943        	extui	a9, a9, 0, 4
  90ccc1:	029902        	or	a9, a9, a2
								       ATH9K_HTC_TXSTAT_RATE);
		txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_MCS;
  90ccc4:	248003        	l8ui	a4, a8, 3
	struct atheros_softc *asc = (struct atheros_softc*)sc->sc_rc;
	RATE_TABLE_11N *pRateTable = (RATE_TABLE_11N *)asc->hwRateTable[sc->sc_curmode];

	/* HT Rate */
	if (pRateTable->info[rcs[series].rix].rateCode & 0x80) {
		txs->txstatus[txs->cnt].ts_rate |= SM(pRateTable->info[rcs[series].rix].dot11Rate,
  90ccc7:	298402        	s8i	a9, a8, 2
								       ATH9K_HTC_TXSTAT_RATE);
		txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_MCS;
  90ccca:	c098      	movi.n	a9, 8
  90cccc:	094902        	or	a9, a4, a9
  90cccf:	298403        	s8i	a9, a8, 3

		if (rcs[series].flags & ATH_RC_CW40_FLAG)
  90ccd2:	293003        	l8ui	a9, a3, 3
  90ccd5:	7e9707        	bbci	a9, 30, 90cce0 <ath_tx_status_update_rate+0x64>
			txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_CW40;
  90ccd8:	c128      	movi.n	a2, 24
  90ccda:	024402        	or	a4, a4, a2
  90ccdd:	248403        	s8i	a4, a8, 3

		if (rcs[series].flags & ATH_RC_HT40_SGI_FLAG)
  90cce0:	7d9719        	bbci	a9, 29, 90ccfd <ath_tx_status_update_rate+0x81>
			txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_SGI;
  90cce3:	248003        	l8ui	a4, a8, 3
  90cce6:	c220      	movi.n	a2, 32
  90cce8:	024402        	or	a4, a4, a2
  90cceb:	248403        	s8i	a4, a8, 3
  90ccee:	60000b        	j	90ccfd <ath_tx_status_update_rate+0x81>

	} else {
		txs->txstatus[txs->cnt].ts_rate |= SM(rcs[series].rix, ATH9K_HTC_TXSTAT_RATE);
  90ccf1:	228002        	l8ui	a2, a8, 2
  90ccf4:	090943        	extui	a9, a9, 0, 4
  90ccf7:	029902        	or	a9, a9, a2
  90ccfa:	298402        	s8i	a9, a8, 2
	}

	if (rcs[series].flags & ATH_RC_RTSCTS_FLAG)
  90ccfd:	223003        	l8ui	a2, a3, 3
  90cd00:	7b2714        	bbci	a2, 27, 90cd18 <ath_tx_status_update_rate+0x9c>
  90cd03:	245000        	l8ui	a4, a5, 0
		txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_RTC_CTS;
  90cd06:	c024      	movi.n	a2, 4
  90cd08:	0f4311        	slli	a3, a4, 1
  90cd0b:	a433      	add.n	a3, a3, a4
  90cd0d:	a355      	add.n	a5, a5, a3
  90cd0f:	235003        	l8ui	a3, a5, 3
  90cd12:	023302        	or	a3, a3, a2
  90cd15:	235403        	s8i	a3, a5, 3
  90cd18:	d10f      	retw.n
	...

0090cd1c <ath_rate_attach>:

}

struct ath_ratectrl *
ath_rate_attach(struct ath_softc_tgt *sc)
{
  90cd1c:	6c1004        	entry	a1, 32
  90cd1f:	1368bf        	l32r	a3, 8e701c <memset+0x1d4>
  90cd22:	c1b8      	movi.n	a11, 24
  90cd24:	223252        	l32i	a2, a3, 0x148
  90cd27:	c0a0      	movi.n	a10, 0
  90cd29:	0b2000        	callx8	a2
  90cd2c:	d2a0      	mov.n	a2, a10
	struct atheros_softc *asc;

	asc = adf_os_mem_alloc(sizeof(struct atheros_softc));
	if (asc == NULL)
  90cd2e:	c9a6      	beqz.n	a10, 90cd48 <ath_rate_attach+0x2c>

/* set a memory buffer */
static inline void
__adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
{
	A_MEMSET(buf, b, size);
  90cd30:	8334      	l32i.n	a3, a3, 16
  90cd32:	c1c8      	movi.n	a12, 24
  90cd34:	c0b0      	movi.n	a11, 0
  90cd36:	0b3000        	callx8	a3
		return NULL;

	adf_os_mem_set(asc, 0, sizeof(struct atheros_softc));
	asc->arc.arc_space = sizeof(struct atheros_node);
  90cd39:	230a78        	movi	a3, 120
  90cd3c:	9320      	s32i.n	a3, a2, 0

	ar5416AttachRateTables(asc);
  90cd3e:	da20      	mov.n	a10, a2

	asc->tx_chainmask = 1;
  90cd40:	230a01        	movi	a3, 1
		return NULL;

	adf_os_mem_set(asc, 0, sizeof(struct atheros_softc));
	asc->arc.arc_space = sizeof(struct atheros_node);

	ar5416AttachRateTables(asc);
  90cd43:	5808fb        	call8	90f130 <ar5416AttachRateTables>

	asc->tx_chainmask = 1;
  90cd46:	9323      	s32i.n	a3, a2, 12
    
	return &asc->arc;
}
  90cd48:	d10f      	retw.n
	...

0090cd4c <ath_rate_findrate>:
                  int numRates,
                  int stepDnInc,
                  unsigned int rcflag,
                  struct ath_rc_series series[],
                  int *isProbe)
{
  90cd4c:	6c1006        	entry	a1, 48
  90cd4f:	8e1f      	l32i.n	a14, a1, 60
	*isProbe = 0;
  90cd51:	c080      	movi.n	a8, 0

	if (!numRates || !numTries) {
  90cd53:	c091      	movi.n	a9, 1
                  int stepDnInc,
                  unsigned int rcflag,
                  struct ath_rc_series series[],
                  int *isProbe)
{
	*isProbe = 0;
  90cd55:	98e0      	s32i.n	a8, a14, 0

	if (!numRates || !numTries) {
  90cd57:	079838        	moveqz	a8, a9, a7
  90cd5a:	080847        	extui	a8, a8, 0, 8
                  int numRates,
                  int stepDnInc,
                  unsigned int rcflag,
                  struct ath_rc_series series[],
                  int *isProbe)
{
  90cd5d:	dd70      	mov.n	a13, a7
  90cd5f:	da20      	mov.n	a10, a2
  90cd61:	db30      	mov.n	a11, a3
  90cd63:	dc60      	mov.n	a12, a6
	*isProbe = 0;

	if (!numRates || !numTries) {
  90cd65:	cd80      	bnez.n	a8, 90cd79 <ath_rate_findrate+0x2d>
  90cd67:	069838        	moveqz	a8, a9, a6
  90cd6a:	cc8b      	bnez.n	a8, 90cd79 <ath_rate_findrate+0x2d>
	*isProbe = 0;
	if (!numRates || !numTries) {
		return;
	}

	rcRateFind_11n(sc, an, numTries, numRates, stepDnInc, rcflag, series, isProbe);
  90cd6c:	881e      	l32i.n	a8, a1, 56
  90cd6e:	9e11      	s32i.n	a14, a1, 4
  90cd70:	8f1d      	l32i.n	a15, a1, 52
  90cd72:	8e1c      	l32i.n	a14, a1, 48
  90cd74:	9810      	s32i.n	a8, a1, 0
  90cd76:	5bfebb        	call8	90c864 <rcRateFind_11n>
  90cd79:	d10f      	retw.n
	...

0090cd7c <ath_rate_tx_complete>:
ath_rate_tx_complete(struct ath_softc_tgt *sc,
		     struct ath_node_target *an,
		     struct ath_tx_desc *ds,
		     struct ath_rc_series rcs[], 
		     int nframes, int nbad)
{
  90cd7c:	6c1006        	entry	a1, 48
			 int nframes, int nbad)
{
	int finalTSIdx = ds->ds_txstat.ts_rate;
	int tx_status = 0;

	if ((ds->ds_txstat.ts_status & HAL_TXERR_XRETRY) ||
  90cd7f:	284066        	l8ui	a8, a4, 102
  90cd82:	c095      	movi.n	a9, 5
  90cd84:	098801        	and	a8, a8, a9
ath_rate_tx_complete(struct ath_softc_tgt *sc,
		     struct ath_node_target *an,
		     struct ath_tx_desc *ds,
		     struct ath_rc_series rcs[], 
		     int nframes, int nbad)
{
  90cd87:	da20      	mov.n	a10, a2
  90cd89:	db30      	mov.n	a11, a3
  90cd8b:	df50      	mov.n	a15, a5
			 struct ath_node_target *an,
			 struct ath_tx_desc *ds,
			 struct ath_rc_series rcs[], 
			 int nframes, int nbad)
{
	int finalTSIdx = ds->ds_txstat.ts_rate;
  90cd8d:	2d4068        	l8ui	a13, a4, 104
	int tx_status = 0;

	if ((ds->ds_txstat.ts_status & HAL_TXERR_XRETRY) ||
  90cd90:	c0e1      	movi.n	a14, 1
  90cd92:	65800b        	bnez	a8, 90cda1 <ath_rate_tx_complete+0x25>
	    (ds->ds_txstat.ts_status & HAL_TXERR_FIFO) || 
	    (ds->ds_txstat.ts_flags & HAL_TX_DATA_UNDERRUN) ||
  90cd95:	294067        	l8ui	a9, a4, 103
  90cd98:	2c0a18        	movi	a12, 24
  90cd9b:	0c9901        	and	a9, a9, a12
  90cd9e:	098e38        	moveqz	a14, a8, a9
	    (ds->ds_txstat.ts_flags & HAL_TX_DELIM_UNDERRUN)) {
		tx_status = 1;
	}

	rcUpdate_11n(sc, an,
  90cda1:	2c4073        	l8ui	a12, a4, 115
  90cda4:	244071        	l8ui	a4, a4, 113
  90cda7:	9711      	s32i.n	a7, a1, 4
  90cda9:	9412      	s32i.n	a4, a1, 8
  90cdab:	9610      	s32i.n	a6, a1, 0
  90cdad:	5bff4d        	call8	90cae4 <rcUpdate_11n>
  90cdb0:	d10f      	retw.n
	...

0090cdb4 <ath_rate_newassoc>:
}

void
ath_rate_newassoc(struct ath_softc_tgt *sc, struct ath_node_target *an, int isnew, 
		  unsigned int capflag, struct ieee80211_rate *rs)
{
  90cdb4:	6c1004        	entry	a1, 32
	ath_rate_newassoc_11n(sc, an, isnew, capflag, rs);
  90cdb7:	de60      	mov.n	a14, a6
  90cdb9:	dd50      	mov.n	a13, a5
  90cdbb:	dc40      	mov.n	a12, a4
  90cdbd:	db30      	mov.n	a11, a3
  90cdbf:	da20      	mov.n	a10, a2
  90cdc1:	5bfe00        	call8	90c5c4 <ath_rate_newassoc_11n>
  90cdc4:	d10f      	retw.n
	...

0090cdc8 <ath_rate_node_update>:
void ath_rate_node_update(struct ath_softc_tgt *sc,
			  struct ath_node_target *an,
			  a_int32_t isnew,
			  a_uint32_t capflag,
			  struct ieee80211_rate *rs)
{
  90cdc8:	6c1004        	entry	a1, 32

void
ath_rate_newassoc(struct ath_softc_tgt *sc, struct ath_node_target *an, int isnew, 
		  unsigned int capflag, struct ieee80211_rate *rs)
{
	ath_rate_newassoc_11n(sc, an, isnew, capflag, rs);
  90cdcb:	de60      	mov.n	a14, a6
  90cdcd:	dd50      	mov.n	a13, a5
  90cdcf:	dc40      	mov.n	a12, a4
  90cdd1:	db30      	mov.n	a11, a3
  90cdd3:	da20      	mov.n	a10, a2
  90cdd5:	5bfdfb        	call8	90c5c4 <ath_rate_newassoc_11n>
  90cdd8:	d10f      	retw.n
	...

0090cddc <ath_rate_newstate>:
ath_rate_newstate(struct ath_softc_tgt *sc,
		  struct ieee80211vap_target *vap,
		  enum ieee80211_state state,
		  a_uint32_t capflag,
		  struct ieee80211_rate *rs)
{
  90cddc:	6c1004        	entry	a1, 32
	struct ieee80211_node_target *ni = vap->iv_bss;
	struct atheros_softc *asc = (struct atheros_softc *) sc->sc_rc;

	asc->tx_chainmask = sc->sc_ic.ic_tx_chainmask;
  90cddf:	292d16        	addmi	a9, a2, 0x1600
  90cde2:	282248        	l32i	a8, a2, 0x120
  90cde5:	299026        	l8ui	a9, a9, 38
		  struct ieee80211vap_target *vap,
		  enum ieee80211_state state,
		  a_uint32_t capflag,
		  struct ieee80211_rate *rs)
{
	struct ieee80211_node_target *ni = vap->iv_bss;
  90cde8:	8b34      	l32i.n	a11, a3, 16
ath_rate_newstate(struct ath_softc_tgt *sc,
		  struct ieee80211vap_target *vap,
		  enum ieee80211_state state,
		  a_uint32_t capflag,
		  struct ieee80211_rate *rs)
{
  90cdea:	da20      	mov.n	a10, a2
	struct ieee80211_node_target *ni = vap->iv_bss;
	struct atheros_softc *asc = (struct atheros_softc *) sc->sc_rc;

	asc->tx_chainmask = sc->sc_ic.ic_tx_chainmask;
  90cdec:	9983      	s32i.n	a9, a8, 12

void
ath_rate_newassoc(struct ath_softc_tgt *sc, struct ath_node_target *an, int isnew, 
		  unsigned int capflag, struct ieee80211_rate *rs)
{
	ath_rate_newassoc_11n(sc, an, isnew, capflag, rs);
  90cdee:	de60      	mov.n	a14, a6
  90cdf0:	dd50      	mov.n	a13, a5
  90cdf2:	2c0a01        	movi	a12, 1
  90cdf5:	5bfdf3        	call8	90c5c4 <ath_rate_newassoc_11n>
  90cdf8:	d10f      	retw.n
	...

0090cdfc <__adf_os_mem_copy>:
    //free(buf,M_DEVBUF);
}

/* move a memory buffer */
static inline void 		__adf_os_mem_copy(void *dst, const void *src, adf_os_size_t size)
{
  90cdfc:	6c1004        	entry	a1, 32
    A_MEMCPY(dst,src,size);    
  90cdff:	1868bf        	l32r	a8, 8e70fc <memset+0x2b4>
  90ce02:	dc40      	mov.n	a12, a4
  90ce04:	8885      	l32i.n	a8, a8, 20
  90ce06:	db30      	mov.n	a11, a3
  90ce08:	da20      	mov.n	a10, a2
  90ce0a:	0b8000        	callx8	a8
  90ce0d:	d10f      	retw.n
	...

0090ce10 <ieee80211_anyhdrsize>:
/*
 * Like ieee80211_hdrsize, but handles any type of frame.
 */
static __inline a_int32_t
ieee80211_anyhdrsize(const void *data)
{
  90ce10:	6c1004        	entry	a1, 32
	const struct ieee80211_frame *wh = data;

	if ((wh->i_fc[0]&IEEE80211_FC0_TYPE_MASK) == IEEE80211_FC0_TYPE_CTL) {
  90ce13:	282000        	l8ui	a8, a2, 0
  90ce16:	c09c      	movi.n	a9, 12
  90ce18:	098901        	and	a9, a8, a9
  90ce1b:	699415        	bnei	a9, 4, 90ce34 <ieee80211_anyhdrsize+0x24>
		switch (wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK) {
  90ce1e:	c720      	movi.n	a2, -16
  90ce20:	028801        	and	a8, a8, a2
  90ce23:	220ac0        	movi	a2, 192
  90ce26:	72812f        	beq	a8, a2, 90ce59 <ieee80211_anyhdrsize+0x49>
  90ce29:	220ad0        	movi	a2, 208
  90ce2c:	728129        	beq	a8, a2, 90ce59 <ieee80211_anyhdrsize+0x49>
		case IEEE80211_FC0_SUBTYPE_CTS:
		case IEEE80211_FC0_SUBTYPE_ACK:
			return sizeof(struct ieee80211_frame_ack);
		}
		return sizeof(struct ieee80211_frame_min);
  90ce2f:	c120      	movi.n	a2, 16
  90ce31:	d10f      	retw.n
  90ce33:	002220        	excw
	const struct ieee80211_frame *wh = data;
	a_int32_t size = sizeof(struct ieee80211_frame);

	/* NB: we don't handle control frames */
	adf_os_assert((wh->i_fc[0]&IEEE80211_FC0_TYPE_MASK) != IEEE80211_FC0_TYPE_CTL);
	if ((wh->i_fc[1] & IEEE80211_FC1_DIR_MASK) == IEEE80211_FC1_DIR_DSTODS)
  90ce36:	01c1a8        	excw
  90ce39:	020241        	extui	a2, a2, 0, 2
		size += IEEE80211_ADDR_LEN;
  90ce3c:	222cfd        	addi	a2, a2, -3
  90ce3f:	c19e      	movi.n	a9, 30
  90ce41:	02a939        	movnez	a9, a10, a2
  90ce44:	d290      	mov.n	a2, a9
	if (IEEE80211_QOS_HAS_SEQ(wh))
  90ce46:	29fa8c        	movi	a9, -116
  90ce49:	098801        	and	a8, a8, a9
		size += sizeof(a_uint16_t);
  90ce4c:	2a0a88        	movi	a10, 136
  90ce4f:	b229      	addi.n	a9, a2, 2
  90ce51:	0a880c        	sub	a8, a8, a10
  90ce54:	089238        	moveqz	a2, a9, a8
  90ce57:	d10f      	retw.n

	if ((wh->i_fc[0]&IEEE80211_FC0_TYPE_MASK) == IEEE80211_FC0_TYPE_CTL) {
		switch (wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK) {
		case IEEE80211_FC0_SUBTYPE_CTS:
		case IEEE80211_FC0_SUBTYPE_ACK:
			return sizeof(struct ieee80211_frame_ack);
  90ce59:	c02a      	movi.n	a2, 10
		}
		return sizeof(struct ieee80211_frame_min);
	} else
		return ieee80211_hdrsize(data);
}
  90ce5b:	d10f      	retw.n
  90ce5d:	000000        	ill

0090ce60 <owl_tgt_tid_init>:
	ath_rate_findrate(sc, an, 1, frameLen, 10, 4, 1,
			  ATH_RC_PROBE_ALLOWED, series, isProbe);
}

static void owl_tgt_tid_init(struct ath_atx_tid *tid)
{
  90ce60:	6c1004        	entry	a1, 32
	int i;

	tid->seq_start  = tid->seq_next = 0;
  90ce63:	c090      	movi.n	a9, 0
	tid->baw_size   = WME_MAX_BA;
  90ce65:	c480      	movi.n	a8, 64

static void owl_tgt_tid_init(struct ath_atx_tid *tid)
{
	int i;

	tid->seq_start  = tid->seq_next = 0;
  90ce67:	292503        	s16i	a9, a2, 6
  90ce6a:	292502        	s16i	a9, a2, 4
	tid->baw_size   = WME_MAX_BA;
  90ce6d:	282504        	s16i	a8, a2, 8
	tid->baw_head   = tid->baw_tail = 0;
	tid->paused     = 0;
  90ce70:	292434        	s8i	a9, a2, 52
{
	int i;

	tid->seq_start  = tid->seq_next = 0;
	tid->baw_size   = WME_MAX_BA;
	tid->baw_head   = tid->baw_tail = 0;
  90ce73:	c080      	movi.n	a8, 0
	tid->paused     = 0;
	tid->flag       = 0;
  90ce75:	292436        	s8i	a9, a2, 54
	tid->sched      = AH_FALSE;
  90ce78:	292435        	s8i	a9, a2, 53

	asf_tailq_init(&tid->buf_q);
  90ce7b:	292c2c        	addi	a9, a2, 44
{
	int i;

	tid->seq_start  = tid->seq_next = 0;
	tid->baw_size   = WME_MAX_BA;
	tid->baw_head   = tid->baw_tail = 0;
  90ce7e:	9824      	s32i.n	a8, a2, 16
  90ce80:	9823      	s32i.n	a8, a2, 12
	tid->paused     = 0;
	tid->flag       = 0;
	tid->sched      = AH_FALSE;

	asf_tailq_init(&tid->buf_q);
  90ce82:	982b      	s32i.n	a8, a2, 44
  90ce84:	992c      	s32i.n	a9, a2, 48

	for (i = 0; i < ATH_TID_MAX_BUFS; i++) {
		TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, i);
  90ce86:	c0e1      	movi.n	a14, 1
  90ce88:	c7df      	movi.n	a13, -1
  90ce8a:	2a0a80        	movi	a10, 128
  90ce8d:	6da819        	loop	a10, 90ceaa <owl_tgt_tid_init+0x4a>
  90ce90:	085912        	srai	a9, a8, 5
  90ce93:	0e9911        	slli	a9, a9, 2
  90ce96:	008104        	ssl	a8
  90ce99:	00eb1a        	sll	a11, a14
  90ce9c:	a929      	add.n	a9, a2, a9
  90ce9e:	0bdc03        	xor	a12, a13, a11
  90cea1:	8b95      	l32i.n	a11, a9, 20
	tid->flag       = 0;
	tid->sched      = AH_FALSE;

	asf_tailq_init(&tid->buf_q);

	for (i = 0; i < ATH_TID_MAX_BUFS; i++) {
  90cea3:	b188      	addi.n	a8, a8, 1
		TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, i);
  90cea5:	0cbb01        	and	a11, a11, a12
  90cea8:	9b95      	s32i.n	a11, a9, 20
	}
}
  90ceaa:	d10f      	retw.n

0090ceac <ath_tgt_txq_add_ucast>:

	return 0;
}

static void ath_tgt_txq_add_ucast(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90ceac:	6c1006        	entry	a1, 48
	struct ath_hal *ah = sc->sc_ah;
  90ceaf:	222d05        	addmi	a2, a2, 0x500
  90ceb2:	842b      	l32i.n	a4, a2, 44
	struct ath_txq *txq;
	HAL_STATUS status;
	volatile a_int32_t txe_val;

	adf_os_assert(bf);
  90ceb4:	cd35      	bnez.n	a3, 90cecd <ath_tgt_txq_add_ucast+0x21>
  90ceb6:	1268bf        	l32r	a2, 8e71b4 <memset+0x36c>
  90ceb9:	1b6aa2        	l32r	a11, 8e7944 <memset+0xafc>
  90cebc:	222212        	l32i	a2, a2, 72
  90cebf:	1a6aa3        	l32r	a10, 8e794c <memset+0xb04>
  90cec2:	0b2000        	callx8	a2
  90cec5:	126923        	l32r	a2, 8e7354 <memset+0x50c>
  90cec8:	0c0200        	memw
  90cecb:	8220      	l32i.n	a2, a2, 0

	txq = bf->bf_txq;

	status = ah->ah_procTxDesc(ah, bf->bf_lastds);
  90cecd:	28421a        	l32i	a8, a4, 104
  90ced0:	8b3e      	l32i.n	a11, a3, 56
  90ced2:	da40      	mov.n	a10, a4
	HAL_STATUS status;
	volatile a_int32_t txe_val;

	adf_os_assert(bf);

	txq = bf->bf_txq;
  90ced4:	223220        	l32i	a2, a3, 128

	status = ah->ah_procTxDesc(ah, bf->bf_lastds);
  90ced7:	0b8000        	callx8	a8

	ATH_TXQ_INSERT_TAIL(txq, bf, bf_list);
  90ceda:	c080      	movi.n	a8, 0
  90cedc:	9839      	s32i.n	a8, a3, 36
  90cede:	8823      	l32i.n	a8, a2, 12
  90cee0:	983a      	s32i.n	a8, a3, 40
  90cee2:	9380      	s32i.n	a3, a8, 0
  90cee4:	283c24        	addi	a8, a3, 36
  90cee7:	9823      	s32i.n	a8, a2, 12
  90cee9:	8824      	l32i.n	a8, a2, 16
  90ceeb:	9325      	s32i.n	a3, a2, 20
  90ceed:	b188      	addi.n	a8, a8, 1
  90ceef:	9824      	s32i.n	a8, a2, 16

	if (txq->axq_link == NULL) {
  90cef1:	8821      	l32i.n	a8, a2, 4
  90cef3:	cc87      	bnez.n	a8, 90cefe <ath_tgt_txq_add_ucast+0x52>
		ah->ah_setTxDP(ah, txq->axq_qnum, ATH_BUF_GET_DESC_PHY_ADDR(bf));
  90cef5:	884a      	l32i.n	a8, a4, 40
  90cef7:	8c3c      	l32i.n	a12, a3, 48
  90cef9:	8b20      	l32i.n	a11, a2, 0
  90cefb:	600022        	j	90cf21 <ath_tgt_txq_add_ucast+0x75>
	} else {
		*txq->axq_link = ATH_BUF_GET_DESC_PHY_ADDR(bf);
  90cefe:	8c3c      	l32i.n	a12, a3, 48
  90cf00:	9c80      	s32i.n	a12, a8, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90cf02:	186a5e        	l32r	a8, 8e787c <memset+0xa34>

		txe_val = ioread32_mac(0x0840);
		if (!(txe_val & (1<< txq->axq_qnum)))
  90cf05:	8b20      	l32i.n	a11, a2, 0
  90cf07:	0c0200        	memw
  90cf0a:	8880      	l32i.n	a8, a8, 0
	if (txq->axq_link == NULL) {
		ah->ah_setTxDP(ah, txq->axq_qnum, ATH_BUF_GET_DESC_PHY_ADDR(bf));
	} else {
		*txq->axq_link = ATH_BUF_GET_DESC_PHY_ADDR(bf);

		txe_val = ioread32_mac(0x0840);
  90cf0c:	0c0200        	memw
  90cf0f:	9810      	s32i.n	a8, a1, 0
		if (!(txe_val & (1<< txq->axq_qnum)))
  90cf11:	0c0200        	memw
  90cf14:	8810      	l32i.n	a8, a1, 0
  90cf16:	00b004        	ssr	a11
  90cf19:	08081b        	sra	a8, a8
  90cf1c:	7f8f06        	bbsi	a8, 31, 90cf26 <ath_tgt_txq_add_ucast+0x7a>
			ah->ah_setTxDP(ah, txq->axq_qnum, ATH_BUF_GET_DESC_PHY_ADDR(bf));
  90cf1f:	884a      	l32i.n	a8, a4, 40
  90cf21:	da40      	mov.n	a10, a4
  90cf23:	0b8000        	callx8	a8
	}

	txq->axq_link = &bf->bf_lastds->ds_link;
  90cf26:	833e      	l32i.n	a3, a3, 56
	ah->ah_startTxDma(ah, txq->axq_qnum);
  90cf28:	8b20      	l32i.n	a11, a2, 0
		txe_val = ioread32_mac(0x0840);
		if (!(txe_val & (1<< txq->axq_qnum)))
			ah->ah_setTxDP(ah, txq->axq_qnum, ATH_BUF_GET_DESC_PHY_ADDR(bf));
	}

	txq->axq_link = &bf->bf_lastds->ds_link;
  90cf2a:	9321      	s32i.n	a3, a2, 4
	ah->ah_startTxDma(ah, txq->axq_qnum);
  90cf2c:	834c      	l32i.n	a3, a4, 48
  90cf2e:	044a02        	or	a10, a4, a4
  90cf31:	0b3000        	callx8	a3
  90cf34:	d10f      	retw.n
	...

0090cf38 <ath_tx_update_baw>:
	ath_tgt_tx_enqueue(txq, tid);
}

static void
ath_tx_update_baw(ath_atx_tid_t *tid, int seqno)
{
  90cf38:	6c1004        	entry	a1, 32
	int index;
	int cindex;

	index  = ATH_BA_INDEX(tid->seq_start, seqno);
  90cf3b:	282102        	l16ui	a8, a2, 4
	cindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);

	TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, cindex);
  90cf3e:	c091      	movi.n	a9, 1
ath_tx_update_baw(ath_atx_tid_t *tid, int seqno)
{
	int index;
	int cindex;

	index  = ATH_BA_INDEX(tid->seq_start, seqno);
  90cf40:	08330c        	sub	a3, a3, a8
	cindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);
  90cf43:	8823      	l32i.n	a8, a2, 12
ath_tx_update_baw(ath_atx_tid_t *tid, int seqno)
{
	int index;
	int cindex;

	index  = ATH_BA_INDEX(tid->seq_start, seqno);
  90cf45:	03034b        	extui	a3, a3, 0, 12
	cindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);
  90cf48:	a833      	add.n	a3, a3, a8

	TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, cindex);
  90cf4a:	035841        	extui	a8, a3, 5, 2
  90cf4d:	0e8811        	slli	a8, a8, 2
  90cf50:	a828      	add.n	a8, a2, a8
  90cf52:	003104        	ssl	a3
  90cf55:	00931a        	sll	a3, a9
  90cf58:	c7af      	movi.n	a10, -1
  90cf5a:	03aa03        	xor	a10, a10, a3
  90cf5d:	8385      	l32i.n	a3, a8, 20
  90cf5f:	0a3301        	and	a3, a3, a10
  90cf62:	9385      	s32i.n	a3, a8, 20

	while (tid->baw_head != tid->baw_tail &&
  90cf64:	8a24      	l32i.n	a10, a2, 16
  90cf66:	600011        	j	90cf7b <ath_tx_update_baw+0x43>
	       (!TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head))) {
		INCR(tid->seq_start, IEEE80211_SEQ_MAX);
  90cf69:	282102        	l16ui	a8, a2, 4
		INCR(tid->baw_head, ATH_TID_MAX_BUFS);
  90cf6c:	b133      	addi.n	a3, a3, 1

	TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, cindex);

	while (tid->baw_head != tid->baw_tail &&
	       (!TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head))) {
		INCR(tid->seq_start, IEEE80211_SEQ_MAX);
  90cf6e:	b188      	addi.n	a8, a8, 1
  90cf70:	08084b        	extui	a8, a8, 0, 12
		INCR(tid->baw_head, ATH_TID_MAX_BUFS);
  90cf73:	030346        	extui	a3, a3, 0, 7

	TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, cindex);

	while (tid->baw_head != tid->baw_tail &&
	       (!TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head))) {
		INCR(tid->seq_start, IEEE80211_SEQ_MAX);
  90cf76:	282502        	s16i	a8, a2, 4
		INCR(tid->baw_head, ATH_TID_MAX_BUFS);
  90cf79:	9323      	s32i.n	a3, a2, 12
	index  = ATH_BA_INDEX(tid->seq_start, seqno);
	cindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);

	TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, cindex);

	while (tid->baw_head != tid->baw_tail &&
  90cf7b:	8323      	l32i.n	a3, a2, 12
  90cf7d:	7a3114        	beq	a3, a10, 90cf95 <ath_tx_update_baw+0x5d>
	       (!TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head))) {
  90cf80:	035812        	srai	a8, a3, 5
  90cf83:	b488      	addi.n	a8, a8, 4
  90cf85:	0e8811        	slli	a8, a8, 2
  90cf88:	a828      	add.n	a8, a2, a8
  90cf8a:	8c81      	l32i.n	a12, a8, 4
  90cf8c:	003104        	ssl	a3
  90cf8f:	009b1a        	sll	a11, a9
	index  = ATH_BA_INDEX(tid->seq_start, seqno);
	cindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);

	TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, cindex);

	while (tid->baw_head != tid->baw_tail &&
  90cf92:	7cb0d3        	bnone	a11, a12, 90cf69 <ath_tx_update_baw+0x31>
  90cf95:	d10f      	retw.n
	...

0090cf98 <ath_update_stats$isra$1>:
	ath_rate_tx_complete(sc, ATH_NODE_TARGET(bf->bf_node),
			     bf->bf_lastds, bf->bf_rcs, 1, 0);
}

static void
ath_update_stats(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
  90cf98:	6c1004        	entry	a1, 32
{
	struct ath_tx_desc *ds = bf->bf_desc;
	u_int32_t sr, lr;

	if (ds->ds_txstat.ts_status == 0) {
  90cf9b:	283066        	l8ui	a8, a3, 102
  90cf9e:	cc8f      	bnez.n	a8, 90cfb1 <ath_update_stats$isra$1+0x19>
		if (ds->ds_txstat.ts_rate & HAL_TXSTAT_ALTRATE)
  90cfa0:	283068        	l8ui	a8, a3, 104
  90cfa3:	788739        	bbci	a8, 24, 90cfe0 <ath_update_stats$isra$1+0x48>
			sc->sc_tx_stats.ast_tx_altrate++;
  90cfa6:	282259        	l32i	a8, a2, 0x164
  90cfa9:	b188      	addi.n	a8, a8, 1
  90cfab:	282659        	s32i	a8, a2, 0x164
  90cfae:	60002e        	j	90cfe0 <ath_update_stats$isra$1+0x48>
	} else {
		if (ds->ds_txstat.ts_status & HAL_TXERR_XRETRY)
  90cfb1:	7f8708        	bbci	a8, 31, 90cfbd <ath_update_stats$isra$1+0x25>
			sc->sc_tx_stats.ast_tx_xretries++;
  90cfb4:	292252        	l32i	a9, a2, 0x148
  90cfb7:	299c01        	addi	a9, a9, 1
  90cfba:	292652        	s32i	a9, a2, 0x148
		if (ds->ds_txstat.ts_status & HAL_TXERR_FIFO)
  90cfbd:	7d8708        	bbci	a8, 29, 90cfc9 <ath_update_stats$isra$1+0x31>
			sc->sc_tx_stats.ast_tx_fifoerr++;
  90cfc0:	292253        	l32i	a9, a2, 0x14c
  90cfc3:	299c01        	addi	a9, a9, 1
  90cfc6:	292653        	s32i	a9, a2, 0x14c
		if (ds->ds_txstat.ts_status & HAL_TXERR_FILT)
  90cfc9:	7e8708        	bbci	a8, 30, 90cfd5 <ath_update_stats$isra$1+0x3d>
			sc->sc_tx_stats.ast_tx_filtered++;
  90cfcc:	292254        	l32i	a9, a2, 0x150
  90cfcf:	299c01        	addi	a9, a9, 1
  90cfd2:	292654        	s32i	a9, a2, 0x150
		if (ds->ds_txstat.ts_status & HAL_TXERR_TIMER_EXPIRED)
  90cfd5:	7b8707        	bbci	a8, 27, 90cfe0 <ath_update_stats$isra$1+0x48>
			sc->sc_tx_stats.ast_tx_timer_exp++;
  90cfd8:	282255        	l32i	a8, a2, 0x154
  90cfdb:	b188      	addi.n	a8, a8, 1
  90cfdd:	282655        	s32i	a8, a2, 0x154
	}
	sr = ds->ds_txstat.ts_shortretry;
	lr = ds->ds_txstat.ts_longretry;
  90cfe0:	293071        	l8ui	a9, a3, 113
	sc->sc_tx_stats.ast_tx_shortretry += sr;
  90cfe3:	282256        	l32i	a8, a2, 0x158
		if (ds->ds_txstat.ts_status & HAL_TXERR_FILT)
			sc->sc_tx_stats.ast_tx_filtered++;
		if (ds->ds_txstat.ts_status & HAL_TXERR_TIMER_EXPIRED)
			sc->sc_tx_stats.ast_tx_timer_exp++;
	}
	sr = ds->ds_txstat.ts_shortretry;
  90cfe6:	233070        	l8ui	a3, a3, 112
	lr = ds->ds_txstat.ts_longretry;
	sc->sc_tx_stats.ast_tx_shortretry += sr;
  90cfe9:	a388      	add.n	a8, a8, a3
	sc->sc_tx_stats.ast_tx_longretry += lr;
  90cfeb:	232257        	l32i	a3, a2, 0x15c
		if (ds->ds_txstat.ts_status & HAL_TXERR_TIMER_EXPIRED)
			sc->sc_tx_stats.ast_tx_timer_exp++;
	}
	sr = ds->ds_txstat.ts_shortretry;
	lr = ds->ds_txstat.ts_longretry;
	sc->sc_tx_stats.ast_tx_shortretry += sr;
  90cfee:	282656        	s32i	a8, a2, 0x158
	sc->sc_tx_stats.ast_tx_longretry += lr;
  90cff1:	a933      	add.n	a3, a3, a9
  90cff3:	232657        	s32i	a3, a2, 0x15c
  90cff6:	d10f      	retw.n

0090cff8 <ath_tgt_tx_enqueue$isra$3>:
	INCR(tid->seq_start, IEEE80211_SEQ_MAX);
	ath_tgt_tx_send_normal(sc, bf);
}

static void
ath_tgt_tx_enqueue(struct ath_txq *txq, struct ath_atx_tid  *tid)
  90cff8:	6c1004        	entry	a1, 32
{
	if (tid->paused)
  90cffb:	283034        	l8ui	a8, a3, 52
  90cffe:	cd88      	bnez.n	a8, 90d01a <ath_tgt_tx_enqueue$isra$3+0x22>
		return;

	if (tid->sched)
  90d000:	283035        	l8ui	a8, a3, 53
  90d003:	008832        	sext	a8, a8, 7
  90d006:	cd80      	bnez.n	a8, 90d01a <ath_tgt_tx_enqueue$isra$3+0x22>
		return;

	tid->sched = AH_TRUE;
  90d008:	c091      	movi.n	a9, 1
  90d00a:	293435        	s8i	a9, a3, 53
	asf_tailq_insert_tail(&txq->axq_tidq, tid, tid_qelem);
  90d00d:	9839      	s32i.n	a8, a3, 36
  90d00f:	8820      	l32i.n	a8, a2, 0
  90d011:	983a      	s32i.n	a8, a3, 40
  90d013:	9380      	s32i.n	a3, a8, 0
  90d015:	233c24        	addi	a3, a3, 36
  90d018:	9320      	s32i.n	a3, a2, 0
  90d01a:	d10f      	retw.n

0090d01c <ath_update_aggr_stats$isra$5>:
	ath_tx_set_retry(sc, bf);
	asf_tailq_insert_tail(bf_q, bf, bf_list);
}

static void
ath_update_aggr_stats(struct ath_softc_tgt *sc,
  90d01c:	6c1004        	entry	a1, 32
{

	u_int8_t status = ATH_DS_TX_STATUS(ds);
	u_int8_t txflags = ATH_DS_TX_FLAGS(ds);

	__statsn(sc, txaggr_longretries, ds->ds_txstat.ts_longretry);
  90d01f:	282268        	l32i	a8, a2, 0x1a0
  90d022:	068608        	add	a6, a8, a6
	__statsn(sc, txaggr_shortretries, ds->ds_txstat.ts_shortretry);
  90d025:	28226b        	l32i	a8, a2, 0x1ac
{

	u_int8_t status = ATH_DS_TX_STATUS(ds);
	u_int8_t txflags = ATH_DS_TX_FLAGS(ds);

	__statsn(sc, txaggr_longretries, ds->ds_txstat.ts_longretry);
  90d028:	262668        	s32i	a6, a2, 0x1a0
	__statsn(sc, txaggr_shortretries, ds->ds_txstat.ts_shortretry);
  90d02b:	058508        	add	a5, a8, a5
  90d02e:	25266b        	s32i	a5, a2, 0x1ac

	if (txflags & HAL_TX_DESC_CFG_ERR)
  90d031:	7d4708        	bbci	a4, 29, 90d03d <ath_update_aggr_stats$isra$5+0x21>
		__stats(sc, txaggr_desc_cfgerr);
  90d034:	282271        	l32i	a8, a2, 0x1c4
  90d037:	288c01        	addi	a8, a8, 1
  90d03a:	282671        	s32i	a8, a2, 0x1c4

	if (txflags & HAL_TX_DATA_UNDERRUN)
  90d03d:	7c4708        	bbci	a4, 28, 90d049 <ath_update_aggr_stats$isra$5+0x2d>
		__stats(sc, txaggr_data_urun);
  90d040:	282265        	l32i	a8, a2, 0x194
  90d043:	288c01        	addi	a8, a8, 1
  90d046:	282665        	s32i	a8, a2, 0x194

	if (txflags & HAL_TX_DELIM_UNDERRUN)
  90d049:	7b4707        	bbci	a4, 27, 90d054 <ath_update_aggr_stats$isra$5+0x38>
		__stats(sc, txaggr_delim_urun);
  90d04c:	282266        	l32i	a8, a2, 0x198
  90d04f:	b188      	addi.n	a8, a8, 1
  90d051:	282666        	s32i	a8, a2, 0x198

	if (!status) {
  90d054:	cb38      	beqz.n	a3, 90d090 <ath_update_aggr_stats$isra$5+0x74>
		return;
	}

	if (status & HAL_TXERR_XRETRY)
  90d056:	7f3707        	bbci	a3, 31, 90d061 <ath_update_aggr_stats$isra$5+0x45>
		__stats(sc, txaggr_compxretry);
  90d059:	28226a        	l32i	a8, a2, 0x1a8
  90d05c:	b188      	addi.n	a8, a8, 1
  90d05e:	28266a        	s32i	a8, a2, 0x1a8

	if (status & HAL_TXERR_FILT)
  90d061:	7e3708        	bbci	a3, 30, 90d06d <ath_update_aggr_stats$isra$5+0x51>
		__stats(sc, txaggr_filtered);
  90d064:	28226e        	l32i	a8, a2, 0x1b8
  90d067:	288c01        	addi	a8, a8, 1
  90d06a:	28266e        	s32i	a8, a2, 0x1b8

	if (status & HAL_TXERR_FIFO)
  90d06d:	7d3708        	bbci	a3, 29, 90d079 <ath_update_aggr_stats$isra$5+0x5d>
		__stats(sc, txaggr_fifo);
  90d070:	28226f        	l32i	a8, a2, 0x1bc
  90d073:	288c01        	addi	a8, a8, 1
  90d076:	28266f        	s32i	a8, a2, 0x1bc

	if (status & HAL_TXERR_XTXOP)
  90d079:	7c3708        	bbci	a3, 28, 90d085 <ath_update_aggr_stats$isra$5+0x69>
		__stats(sc, txaggr_xtxop);
  90d07c:	282270        	l32i	a8, a2, 0x1c0
  90d07f:	288c01        	addi	a8, a8, 1
  90d082:	282670        	s32i	a8, a2, 0x1c0

	if (status & HAL_TXERR_TIMER_EXPIRED)
  90d085:	7b3707        	bbci	a3, 27, 90d090 <ath_update_aggr_stats$isra$5+0x74>
		__stats(sc, txaggr_timer_exp);
  90d088:	23226c        	l32i	a3, a2, 0x1b0
  90d08b:	b133      	addi.n	a3, a3, 1
  90d08d:	23266c        	s32i	a3, a2, 0x1b0
  90d090:	d10f      	retw.n
	...

0090d094 <ath_dma_unmap$isra$6>:

	skb = adf_nbuf_queue_first(&bf->bf_skbhead);
	adf_nbuf_map(sc->sc_dev, bf->bf_dmamap, skb, ADF_OS_DMA_TO_DEVICE);
}

static void ath_dma_unmap(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
  90d094:	6c1004        	entry	a1, 32
 * @return first buffer in queue
 */
static inline adf_nbuf_t 
adf_nbuf_queue_first(adf_nbuf_queue_t *head)
{
    return (__adf_nbuf_queue_first(head));
  90d097:	2a3c14        	addi	a10, a3, 20
  90d09a:	5be707        	call8	906cb8 <__adf_nbuf_queue_first>
static inline void
adf_nbuf_unmap(adf_os_device_t      osdev, 
               adf_os_dma_map_t     bmap, 
               adf_os_dma_dir_t     dir)
{
    __adf_nbuf_unmap(osdev, bmap, dir);
  90d09d:	8b30      	l32i.n	a11, a3, 0
  90d09f:	8a20      	l32i.n	a10, a2, 0
  90d0a1:	c0c0      	movi.n	a12, 0
  90d0a3:	5be676        	call8	906a7c <__adf_nbuf_unmap>
  90d0a6:	d10f      	retw.n

0090d0a8 <ath_tgt_skb_free$isra$7>:
	sc->sc_txbuf_held = bf;

	return tmp;
}

static void ath_tgt_skb_free(struct ath_softc_tgt *sc,
  90d0a8:	6c1004        	entry	a1, 32
{
	adf_nbuf_t tskb;

	while (adf_nbuf_queue_len(head) != 0) {
		tskb = adf_nbuf_queue_remove(head);
		ath_free_tx_skb(sc->tgt_htc_handle,endpt,tskb);
  90d0ab:	1568bf        	l32r	a5, 8e73a8 <memset+0x560>
  90d0ae:	600012        	j	90d0c4 <ath_tgt_skb_free$isra$7+0x1c>
 * @return The head buf in the buf queue.
 */
static inline adf_nbuf_t
adf_nbuf_queue_remove(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_remove(head);
  90d0b1:	da30      	mov.n	a10, a3
  90d0b3:	5be65e        	call8	906a2c <__adf_nbuf_queue_remove>
  90d0b6:	dca0      	mov.n	a12, a10
  90d0b8:	285282        	l32i	a8, a5, 0x208
  90d0bb:	2a2200        	l32i	a10, a2, 0
  90d0be:	044b02        	or	a11, a4, a4
  90d0c1:	0b8000        	callx8	a8
 * @return length of the queue
 */
static inline a_uint32_t
adf_nbuf_queue_len(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_len(head);
  90d0c4:	da30      	mov.n	a10, a3
  90d0c6:	5be6fa        	call8	906cb0 <__adf_nbuf_queue_len>
			     adf_nbuf_queue_t *head,
			     HTC_ENDPOINT_ID endpt)
{
	adf_nbuf_t tskb;

	while (adf_nbuf_queue_len(head) != 0) {
  90d0c9:	65afe4        	bnez	a10, 90d0b1 <ath_tgt_skb_free$isra$7+0x9>
		tskb = adf_nbuf_queue_remove(head);
		ath_free_tx_skb(sc->tgt_htc_handle,endpt,tskb);
	}
}
  90d0cc:	d10f      	retw.n
	...

0090d0d0 <ath_filltxdesc$isra$9>:

	skb = adf_nbuf_queue_first(&bf->bf_skbhead);
	adf_nbuf_unmap( sc->sc_dev, bf->bf_dmamap, ADF_OS_DMA_TO_DEVICE);
}

static void ath_filltxdesc(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
  90d0d0:	6c1004        	entry	a1, 32
 * @param[out] sg   map info
 */
static inline void
adf_nbuf_dmamap_info(adf_os_dma_map_t bmap, adf_os_dmamap_info_t *sg)
{
    __adf_nbuf_dmamap_info(bmap, sg);
  90d0d3:	8a30      	l32i.n	a10, a3, 0
  90d0d5:	b43b      	addi.n	a11, a3, 4
{
	struct ath_tx_desc *ds0, *ds = bf->bf_desc;
  90d0d7:	853c      	l32i.n	a5, a3, 48
  90d0d9:	5be66d        	call8	906a90 <__adf_nbuf_dmamap_info>
	a_uint8_t i;

	ds0 = ds;
	adf_nbuf_dmamap_info(bf->bf_dmamap, &bf->bf_dmamap_info);

	for (i = 0; i < bf->bf_dmamap_info.nsegs; i++, ds++) {
  90d0dc:	c0c0      	movi.n	a12, 0
	adf_nbuf_unmap( sc->sc_dev, bf->bf_dmamap, ADF_OS_DMA_TO_DEVICE);
}

static void ath_filltxdesc(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_tx_desc *ds0, *ds = bf->bf_desc;
  90d0de:	d450      	mov.n	a4, a5
	for (i = 0; i < bf->bf_dmamap_info.nsegs; i++, ds++) {

		ds->ds_data = bf->bf_dmamap_info.dma_segs[i].paddr;

		if (i == (bf->bf_dmamap_info.nsegs - 1)) {
			ds->ds_link = 0;
  90d0e0:	d6c0      	mov.n	a6, a12
  90d0e2:	60007e        	j	90d164 <ath_filltxdesc$isra$9+0x94>
  90d0e5:	0dc811        	slli	a8, a12, 3
  90d0e8:	a838      	add.n	a8, a3, a8
	ds0 = ds;
	adf_nbuf_dmamap_info(bf->bf_dmamap, &bf->bf_dmamap_info);

	for (i = 0; i < bf->bf_dmamap_info.nsegs; i++, ds++) {

		ds->ds_data = bf->bf_dmamap_info.dma_segs[i].paddr;
  90d0ea:	278008        	l8ui	a7, a8, 8

		if (i == (bf->bf_dmamap_info.nsegs - 1)) {
  90d0ed:	b0dd      	addi.n	a13, a13, -1
	ds0 = ds;
	adf_nbuf_dmamap_info(bf->bf_dmamap, &bf->bf_dmamap_info);

	for (i = 0; i < bf->bf_dmamap_info.nsegs; i++, ds++) {

		ds->ds_data = bf->bf_dmamap_info.dma_segs[i].paddr;
  90d0ef:	274404        	s8i	a7, a4, 4
  90d0f2:	278009        	l8ui	a7, a8, 9
  90d0f5:	274405        	s8i	a7, a4, 5
  90d0f8:	27800a        	l8ui	a7, a8, 10
  90d0fb:	274406        	s8i	a7, a4, 6
  90d0fe:	27800b        	l8ui	a7, a8, 11
  90d101:	274407        	s8i	a7, a4, 7
  90d104:	b1c7      	addi.n	a7, a12, 1

		if (i == (bf->bf_dmamap_info.nsegs - 1)) {
  90d106:	7cd912        	bne	a13, a12, 90d11c <ath_filltxdesc$isra$9+0x4c>
			ds->ds_link = 0;
  90d109:	264400        	s8i	a6, a4, 0
  90d10c:	264401        	s8i	a6, a4, 1
  90d10f:	264402        	s8i	a6, a4, 2
  90d112:	264403        	s8i	a6, a4, 3
			bf->bf_lastds = ds;
  90d115:	943e      	s32i.n	a4, a3, 56
  90d117:	600022        	j	90d13d <ath_filltxdesc$isra$9+0x6d>
  90d11a:	00000c        	sub	a0, a0, a0
		} else
			ds->ds_link = ATH_BUF_GET_DESC_PHY_ADDR_WITH_IDX(bf, i+1);
  90d11d:	7911a7        	beq	a1, a9, 90d0c8 <ath_tgt_skb_free$isra$7+0x20>
  90d120:	990d      	s32i.n	a9, a0, 52
  90d122:	9a11      	s32i.n	a10, a1, 4
  90d124:	893d      	l32i.n	a9, a3, 52
  90d126:	aa99      	add.n	a9, a9, a10
  90d128:	098a57        	extui	a10, a9, 24, 8
  90d12b:	2a4400        	s8i	a10, a4, 0
  90d12e:	090a57        	extui	a10, a9, 16, 8
  90d131:	2a4401        	s8i	a10, a4, 1
  90d134:	098a47        	extui	a10, a9, 8, 8
  90d137:	2a4402        	s8i	a10, a4, 2
  90d13a:	294403        	s8i	a9, a4, 3

		ah->ah_fillTxDesc(ds
  90d13d:	0cdd0c        	sub	a13, a13, a12
  90d140:	c091      	movi.n	a9, 1
  90d142:	da60      	mov.n	a10, a6
  90d144:	0d9a38        	moveqz	a10, a9, a13
  90d147:	2f2218        	l32i	a15, a2, 96
  90d14a:	0c6939        	movnez	a9, a6, a12
  90d14d:	8b83      	l32i.n	a11, a8, 12
  90d14f:	dda0      	mov.n	a13, a10
  90d151:	dc90      	mov.n	a12, a9
  90d153:	044a02        	or	a10, a4, a4
  90d156:	055e02        	or	a14, a5, a5
  90d159:	0bf000        	callx8	a15
	a_uint8_t i;

	ds0 = ds;
	adf_nbuf_dmamap_info(bf->bf_dmamap, &bf->bf_dmamap_info);

	for (i = 0; i < bf->bf_dmamap_info.nsegs; i++, ds++) {
  90d15c:	070c47        	extui	a12, a7, 0, 8
  90d15f:	270a88        	movi	a7, 136
  90d162:	a744      	add.n	a4, a4, a7
  90d164:	8d31      	l32i.n	a13, a3, 4
  90d166:	7dcb02        	bgeu	a12, a13, 90d16c <ath_filltxdesc$isra$9+0x9c>
  90d169:	63ff78        	j	90d0e5 <ath_filltxdesc$isra$9+0x15>
				   , bf->bf_dmamap_info.dma_segs[i].len
				   , i == 0
				   , i == (bf->bf_dmamap_info.nsegs - 1)
				   , ds0);
	}
}
  90d16c:	d10f      	retw.n
	...

0090d170 <ath_tx_tgt_setds>:

static void ath_tx_tgt_setds(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90d170:	6c1006        	entry	a1, 48
	struct ath_tx_desc *ds = bf->bf_desc;
	struct ath_hal *ah = sc->sc_ah;

	switch (bf->bf_protmode) {
  90d173:	293084        	l8ui	a9, a3, 132
}

static void ath_tx_tgt_setds(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_tx_desc *ds = bf->bf_desc;
	struct ath_hal *ah = sc->sc_ah;
  90d176:	222d05        	addmi	a2, a2, 0x500
	}
}

static void ath_tx_tgt_setds(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_tx_desc *ds = bf->bf_desc;
  90d179:	8a3c      	l32i.n	a10, a3, 48
	struct ath_hal *ah = sc->sc_ah;
  90d17b:	8d2b      	l32i.n	a13, a2, 44
  90d17d:	283144        	l16ui	a8, a3, 136

	switch (bf->bf_protmode) {
  90d180:	689108        	beqi	a9, 1, 90d18c <ath_tx_tgt_setds+0x1c>
  90d183:	69920d        	bnei	a9, 2, 90d194 <ath_tx_tgt_setds+0x24>
    	case IEEE80211_PROT_RTSCTS:
		bf->bf_flags |= HAL_TXDESC_RTSENA;
  90d186:	c094      	movi.n	a9, 4
  90d188:	600002        	j	90d18e <ath_tx_tgt_setds+0x1e>
  90d18b:	00c098        	excw
		break;
    	case IEEE80211_PROT_CTSONLY:
		bf->bf_flags |= HAL_TXDESC_CTSENA;
  90d18e:	098802        	or	a8, a8, a9
  90d191:	283544        	s16i	a8, a3, 136
		break;
    	default:
		break;
	}

	ah->ah_set11nTxDesc(ds
  90d194:	283144        	l16ui	a8, a3, 136
  90d197:	c190      	movi.n	a9, 16
  90d199:	098802        	or	a8, a8, a9
  90d19c:	08084f        	extui	a8, a8, 0, 16
  90d19f:	9810      	s32i.n	a8, a1, 0
  90d1a1:	2b3122        	l16ui	a11, a3, 68
  90d1a4:	88df      	l32i.n	a8, a13, 60
  90d1a6:	2f3085        	l8ui	a15, a3, 133
  90d1a9:	2e3049        	l8ui	a14, a3, 73
  90d1ac:	2c304a        	l8ui	a12, a3, 74
  90d1af:	2d0a3c        	movi	a13, 60
  90d1b2:	0b8000        	callx8	a8
			      , 60
			      , bf->bf_keyix
			      , bf->bf_keytype
			      , bf->bf_flags | HAL_TXDESC_INTREQ);

	ath_filltxdesc(sc, bf);
  90d1b5:	8a2b      	l32i.n	a10, a2, 44
  90d1b7:	db30      	mov.n	a11, a3
  90d1b9:	5bffc5        	call8	90d0d0 <ath_filltxdesc$isra$9>
  90d1bc:	d10f      	retw.n
	...

0090d1c0 <__adf_os_mem_set$constprop$19>:
}

/* set a memory buffer */
static inline void
__adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
  90d1c0:	6c1004        	entry	a1, 32
{
	A_MEMSET(buf, b, size);
  90d1c3:	1868bf        	l32r	a8, 8e74c0 <memset+0x678>
  90d1c6:	dc30      	mov.n	a12, a3
  90d1c8:	8884      	l32i.n	a8, a8, 16
  90d1ca:	c0b0      	movi.n	a11, 0
  90d1cc:	da20      	mov.n	a10, a2
  90d1ce:	0b8000        	callx8	a8
  90d1d1:	d10f      	retw.n
	...

0090d1d4 <ath_buf_set_rate>:
		asf_tailq_insert_tail(&sc->sc_txbuf, bf, bf_list);
	}
}

static void ath_buf_set_rate(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90d1d4:	6c1016        	entry	a1, 176
    struct ath_hal *ah = sc->sc_ah;
  90d1d7:	242d05        	addmi	a4, a2, 0x500
  90d1da:	844b      	l32i.n	a4, a4, 44
    a_int32_t prot_mode = AH_FALSE;

    rt = sc->sc_currates;
    rix = bf->bf_rcs[0].rix;
    flags = (bf->bf_flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA));
    cix = rt->info[sc->sc_protrix].controlRate;
  90d1dc:	262d03        	addmi	a6, a2, 0x300
  90d1df:	27600c        	l8ui	a7, a6, 12
	}
}

static void ath_buf_set_rate(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
    struct ath_hal *ah = sc->sc_ah;
  90d1e2:	24161c        	s32i	a4, a1, 112
    const HAL_RATE_TABLE *rt;
    struct ath_tx_desc *ds = bf->bf_desc;
  90d1e5:	843c      	l32i.n	a4, a3, 48
    a_int32_t prot_mode = AH_FALSE;

    rt = sc->sc_currates;
    rix = bf->bf_rcs[0].rix;
    flags = (bf->bf_flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA));
    cix = rt->info[sc->sc_protrix].controlRate;
  90d1e7:	0e7611        	slli	a6, a7, 2
  90d1ea:	a766      	add.n	a6, a6, a7

static void ath_buf_set_rate(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
    struct ath_hal *ah = sc->sc_ah;
    const HAL_RATE_TABLE *rt;
    struct ath_tx_desc *ds = bf->bf_desc;
  90d1ec:	24161d        	s32i	a4, a1, 116
    HAL_11N_RATE_SERIES series[4];
    a_int32_t i, flags;
    a_uint8_t rix, cix, rtsctsrate;
    a_int32_t prot_mode = AH_FALSE;

    rt = sc->sc_currates;
  90d1ef:	242281        	l32i	a4, a2, 0x204
    rix = bf->bf_rcs[0].rix;
    flags = (bf->bf_flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA));
  90d1f2:	283144        	l16ui	a8, a3, 136
    cix = rt->info[sc->sc_protrix].controlRate;
  90d1f5:	0e6611        	slli	a6, a6, 2

    if (bf->bf_protmode != IEEE80211_PROT_NONE &&
  90d1f8:	273084        	l8ui	a7, a3, 132
    a_uint8_t rix, cix, rtsctsrate;
    a_int32_t prot_mode = AH_FALSE;

    rt = sc->sc_currates;
    rix = bf->bf_rcs[0].rix;
    flags = (bf->bf_flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA));
  90d1fb:	c05c      	movi.n	a5, 12
    cix = rt->info[sc->sc_protrix].controlRate;
  90d1fd:	a646      	add.n	a6, a4, a6
    a_uint8_t rix, cix, rtsctsrate;
    a_int32_t prot_mode = AH_FALSE;

    rt = sc->sc_currates;
    rix = bf->bf_rcs[0].rix;
    flags = (bf->bf_flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA));
  90d1ff:	058501        	and	a5, a8, a5
    cix = rt->info[sc->sc_protrix].controlRate;
  90d202:	266037        	l8ui	a6, a6, 55

    if (bf->bf_protmode != IEEE80211_PROT_NONE &&
  90d205:	c97c      	beqz.n	a7, 90d225 <ath_buf_set_rate+0x51>
	(rt->info[rix].phy == IEEE80211_T_OFDM ||
  90d207:	293050        	l8ui	a9, a3, 80
  90d20a:	0e9711        	slli	a7, a9, 2
  90d20d:	a977      	add.n	a7, a7, a9
  90d20f:	0e7711        	slli	a7, a7, 2
  90d212:	a747      	add.n	a7, a4, a7
  90d214:	277029        	l8ui	a7, a7, 41
  90d217:	290afd        	movi	a9, 253
  90d21a:	277cfe        	addi	a7, a7, -2
    rt = sc->sc_currates;
    rix = bf->bf_rcs[0].rix;
    flags = (bf->bf_flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA));
    cix = rt->info[sc->sc_protrix].controlRate;

    if (bf->bf_protmode != IEEE80211_PROT_NONE &&
  90d21d:	797804        	bany	a7, a9, 90d225 <ath_buf_set_rate+0x51>
	(rt->info[rix].phy == IEEE80211_T_OFDM ||
	 rt->info[rix].phy == IEEE80211_T_HT) &&
	(bf->bf_flags & HAL_TXDESC_NOACK) == 0) {
	    cix = rt->info[sc->sc_protrix].controlRate;
	    prot_mode = AH_TRUE;
  90d220:	c071      	movi.n	a7, 1
    flags = (bf->bf_flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA));
    cix = rt->info[sc->sc_protrix].controlRate;

    if (bf->bf_protmode != IEEE80211_PROT_NONE &&
	(rt->info[rix].phy == IEEE80211_T_OFDM ||
	 rt->info[rix].phy == IEEE80211_T_HT) &&
  90d222:	7e874a        	bbci	a8, 30, 90d270 <ath_buf_set_rate+0x9c>
	(bf->bf_flags & HAL_TXDESC_NOACK) == 0) {
	    cix = rt->info[sc->sc_protrix].controlRate;
	    prot_mode = AH_TRUE;
    } else {
	    if (ath_hal_getcapability(ah, HAL_CAP_HT) && (!bf->bf_ismcast))
  90d225:	2a121c        	l32i	a10, a1, 112
  90d228:	c0b5      	movi.n	a11, 5
  90d22a:	5bf69c        	call8	90ac9c <ath_hal_getcapability>
  90d22d:	64a00b        	beqz	a10, 90d23c <ath_buf_set_rate+0x68>
  90d230:	273221        	l32i	a7, a3, 132
		    flags = HAL_TXDESC_RTSENA;
  90d233:	280a04        	movi	a8, 4
	 rt->info[rix].phy == IEEE80211_T_HT) &&
	(bf->bf_flags & HAL_TXDESC_NOACK) == 0) {
	    cix = rt->info[sc->sc_protrix].controlRate;
	    prot_mode = AH_TRUE;
    } else {
	    if (ath_hal_getcapability(ah, HAL_CAP_HT) && (!bf->bf_ismcast))
  90d236:	077740        	extui	a7, a7, 7, 1
		    flags = HAL_TXDESC_RTSENA;
  90d239:	078538        	moveqz	a5, a8, a7
  90d23c:	283c75        	addi	a8, a3, 117

	    for (i = 4; i--;) {
  90d23f:	c074      	movi.n	a7, 4
  90d241:	600024        	j	90d269 <ath_buf_set_rate+0x95>
  90d244:	288cf4        	addi	a8, a8, -12
		    if (bf->bf_rcs[i].tries) {
  90d247:	29800c        	l8ui	a9, a8, 12
  90d24a:	c99b      	beqz.n	a9, 90d269 <ath_buf_set_rate+0x95>
			    cix = rt->info[bf->bf_rcs[i].rix].controlRate;
  90d24c:	0f7611        	slli	a6, a7, 1
  90d24f:	a766      	add.n	a6, a6, a7
  90d251:	0e6611        	slli	a6, a6, 2
  90d254:	a636      	add.n	a6, a3, a6
  90d256:	276050        	l8ui	a7, a6, 80
  90d259:	0e7611        	slli	a6, a7, 2
  90d25c:	a766      	add.n	a6, a6, a7
  90d25e:	0e6611        	slli	a6, a6, 2
  90d261:	a646      	add.n	a6, a4, a6
  90d263:	266037        	l8ui	a6, a6, 55
  90d266:	600004        	j	90d26e <ath_buf_set_rate+0x9a>
	    prot_mode = AH_TRUE;
    } else {
	    if (ath_hal_getcapability(ah, HAL_CAP_HT) && (!bf->bf_ismcast))
		    flags = HAL_TXDESC_RTSENA;

	    for (i = 4; i--;) {
  90d269:	b077      	addi.n	a7, a7, -1
  90d26b:	6970d5        	bnei	a7, -1, 90d244 <ath_buf_set_rate+0x70>
    const HAL_RATE_TABLE *rt;
    struct ath_tx_desc *ds = bf->bf_desc;
    HAL_11N_RATE_SERIES series[4];
    a_int32_t i, flags;
    a_uint8_t rix, cix, rtsctsrate;
    a_int32_t prot_mode = AH_FALSE;
  90d26e:	c070      	movi.n	a7, 0
 * @param[in] size  buffer size
 */
static inline void
adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
{
    __adf_os_mem_set(buf, b, size);
  90d270:	2b0a70        	movi	a11, 112
  90d273:	da10      	mov.n	a10, a1
  90d275:	5bffd2        	call8	90d1c0 <__adf_os_mem_set$constprop$19>
  90d278:	280a80        	movi	a8, 128
  90d27b:	a838      	add.n	a8, a3, a8
  90d27d:	2f3c50        	addi	a15, a3, 80
  90d280:	d910      	mov.n	a9, a1
  90d282:	28161f        	s32i	a8, a1, 124
    }

    adf_os_mem_set(series, 0, sizeof(HAL_11N_RATE_SERIES) * 4);

    for (i = 0; i < 4; i++) {
	    if (!bf->bf_rcs[i].tries)
  90d285:	2bf001        	l8ui	a11, a15, 1
  90d288:	64b119        	beqz	a11, 90d3a5 <ath_buf_set_rate+0x1d1>
		    continue;

	    rix = bf->bf_rcs[i].rix;

	    series[i].Rate = rt->info[rix].rateCode |
  90d28b:	2df000        	l8ui	a13, a15, 0
		    (bf->bf_shpream ? rt->info[rix].shortPreamble : 0);
  90d28e:	2c3221        	l32i	a12, a3, 132
	    if (!bf->bf_rcs[i].tries)
		    continue;

	    rix = bf->bf_rcs[i].rix;

	    series[i].Rate = rt->info[rix].rateCode |
  90d291:	0ed811        	slli	a8, a13, 2
  90d294:	ad88      	add.n	a8, a8, a13
  90d296:	0e8811        	slli	a8, a8, 2
  90d299:	a848      	add.n	a8, a4, a8
  90d29b:	2a8034        	l8ui	a10, a8, 52
		    (bf->bf_shpream ? rt->info[rix].shortPreamble : 0);
  90d29e:	c4e0      	movi.n	a14, 64
	    if (!bf->bf_rcs[i].tries)
		    continue;

	    rix = bf->bf_rcs[i].rix;

	    series[i].Rate = rt->info[rix].rateCode |
  90d2a0:	2a161e        	s32i	a10, a1, 120
  90d2a3:	2a0a00        	movi	a10, 0
		    (bf->bf_shpream ? rt->info[rix].shortPreamble : 0);
  90d2a6:	7ec002        	bnone	a12, a14, 90d2ac <ath_buf_set_rate+0xd8>
  90d2a9:	2a8035        	l8ui	a10, a8, 53
	    if (!bf->bf_rcs[i].tries)
		    continue;

	    rix = bf->bf_rcs[i].rix;

	    series[i].Rate = rt->info[rix].rateCode |
  90d2ac:	28121e        	l32i	a8, a1, 120
		    (bf->bf_shpream ? rt->info[rix].shortPreamble : 0);

	    series[i].Tries = bf->bf_rcs[i].tries;
  90d2af:	9b90      	s32i.n	a11, a9, 0
	    if (!bf->bf_rcs[i].tries)
		    continue;

	    rix = bf->bf_rcs[i].rix;

	    series[i].Rate = rt->info[rix].rateCode |
  90d2b1:	08aa02        	or	a10, a10, a8
		    (bf->bf_shpream ? rt->info[rix].shortPreamble : 0);

	    series[i].Tries = bf->bf_rcs[i].tries;
#ifdef MAGPIE_MERLIN
	    series[i].RateFlags = ((bf->bf_rcs[i].flags & ATH_RC_RTSCTS_FLAG) ?
  90d2b4:	28f003        	l8ui	a8, a15, 3
  90d2b7:	c0b4      	movi.n	a11, 4
  90d2b9:	0b8b01        	and	a11, a8, a11
	    if (!bf->bf_rcs[i].tries)
		    continue;

	    rix = bf->bf_rcs[i].rix;

	    series[i].Rate = rt->info[rix].rateCode |
  90d2bc:	9a91      	s32i.n	a10, a9, 4
  90d2be:	2b161e        	s32i	a11, a1, 120
  90d2c1:	c0a2      	movi.n	a10, 2
	    series[i].Tries = bf->bf_rcs[i].tries;
#ifdef MAGPIE_MERLIN
	    series[i].RateFlags = ((bf->bf_rcs[i].flags & ATH_RC_RTSCTS_FLAG) ?
				   HAL_RATESERIES_RTS_CTS : 0 ) |
		    ((bf->bf_rcs[i].flags & ATH_RC_CW40_FLAG) ?
		     HAL_RATESERIES_2040 : 0 ) |
  90d2c3:	c0b6      	movi.n	a11, 6
		    (bf->bf_shpream ? rt->info[rix].shortPreamble : 0);

	    series[i].Tries = bf->bf_rcs[i].tries;
#ifdef MAGPIE_MERLIN
	    series[i].RateFlags = ((bf->bf_rcs[i].flags & ATH_RC_RTSCTS_FLAG) ?
				   HAL_RATESERIES_RTS_CTS : 0 ) |
  90d2c5:	084e40        	extui	a14, a8, 4, 1
		    ((bf->bf_rcs[i].flags & ATH_RC_CW40_FLAG) ?
		     HAL_RATESERIES_2040 : 0 ) |
  90d2c8:	0b8b01        	and	a11, a8, a11
  90d2cb:	0a8a01        	and	a10, a8, a10
		    ((bf->bf_rcs[i].flags & ATH_RC_HT40_SGI_FLAG) ?
		     HAL_RATESERIES_HALFGI : 0 ) |
		    ((bf->bf_rcs[i].flags & ATH_RC_TX_STBC_FLAG) ?
		     HAL_RATESERIES_STBC: 0);
  90d2ce:	085840        	extui	a8, a8, 5, 1
	    series[i].Tries = bf->bf_rcs[i].tries;
#ifdef MAGPIE_MERLIN
	    series[i].RateFlags = ((bf->bf_rcs[i].flags & ATH_RC_RTSCTS_FLAG) ?
				   HAL_RATESERIES_RTS_CTS : 0 ) |
		    ((bf->bf_rcs[i].flags & ATH_RC_CW40_FLAG) ?
		     HAL_RATESERIES_2040 : 0 ) |
  90d2d1:	0beb02        	or	a11, a14, a11
		    ((bf->bf_rcs[i].flags & ATH_RC_HT40_SGI_FLAG) ?
		     HAL_RATESERIES_HALFGI : 0 ) |
		    ((bf->bf_rcs[i].flags & ATH_RC_TX_STBC_FLAG) ?
		     HAL_RATESERIES_STBC: 0);
  90d2d4:	0d8e11        	slli	a14, a8, 3
	    series[i].RateFlags = ((bf->bf_rcs[i].flags & ATH_RC_RTSCTS_FLAG) ?
				   HAL_RATESERIES_RTS_CTS : 0 ) |
		    ((bf->bf_rcs[i].flags & ATH_RC_CW40_FLAG) ?
		     HAL_RATESERIES_2040 : 0 ) |
		    ((bf->bf_rcs[i].flags & ATH_RC_HT40_SGI_FLAG) ?
		     HAL_RATESERIES_HALFGI : 0 ) |
  90d2d7:	0beb02        	or	a11, a14, a11
	    series[i].Rate = rt->info[rix].rateCode |
		    (bf->bf_shpream ? rt->info[rix].shortPreamble : 0);

	    series[i].Tries = bf->bf_rcs[i].tries;
#ifdef MAGPIE_MERLIN
	    series[i].RateFlags = ((bf->bf_rcs[i].flags & ATH_RC_RTSCTS_FLAG) ?
  90d2da:	9b94      	s32i.n	a11, a9, 16

static a_uint32_t ath_pkt_duration(struct ath_softc_tgt *sc,
				   a_uint8_t rix, struct ath_tx_buf *bf,
				   a_int32_t width, a_int32_t half_gi)
{
	const HAL_RATE_TABLE *rt = sc->sc_currates;
  90d2dc:	2b2281        	l32i	a11, a2, 0x204
	a_uint32_t nbits, nsymbits, duration, nsymbols;
	a_uint8_t rc;
	a_int32_t streams;
	a_int32_t pktlen;

	pktlen = bf->bf_isaggr ? bf->bf_al : bf->bf_pktlen;
  90d2df:	7ac705        	bbci	a12, 26, 90d2e8 <ath_buf_set_rate+0x114>
  90d2e2:	2c3127        	l16ui	a12, a3, 78
  90d2e5:	600002        	j	90d2eb <ath_buf_set_rate+0x117>
  90d2e8:	2c3122        	l16ui	a12, a3, 68
	rc = rt->info[rix].rateCode;
  90d2eb:	0ed811        	slli	a8, a13, 2
  90d2ee:	ad88      	add.n	a8, a8, a13
  90d2f0:	0e8811        	slli	a8, a8, 2
  90d2f3:	08b808        	add	a8, a11, a8
  90d2f6:	288034        	l8ui	a8, a8, 52

	if (!IS_HT_RATE(rc))
  90d2f9:	008e32        	sext	a14, a8, 7
  90d2fc:	66e01d        	bltz	a14, 90d31d <ath_buf_set_rate+0x149>
		return ath_hal_computetxtime(sc->sc_ah, rt, pktlen, rix,
					     bf->bf_shpream);
  90d2ff:	2e3221        	l32i	a14, a3, 132

	pktlen = bf->bf_isaggr ? bf->bf_al : bf->bf_pktlen;
	rc = rt->info[rix].rateCode;

	if (!IS_HT_RATE(rc))
		return ath_hal_computetxtime(sc->sc_ah, rt, pktlen, rix,
  90d302:	282d05        	addmi	a8, a2, 0x500
  90d305:	2a820b        	l32i	a10, a8, 44
  90d308:	0e6e40        	extui	a14, a14, 6, 1
  90d30b:	291622        	s32i	a9, a1, 136
  90d30e:	2f1621        	s32i	a15, a1, 132
  90d311:	5bf670        	call8	90acd4 <ath_hal_computetxtime>
  90d314:	291222        	l32i	a9, a1, 136
  90d317:	2f1221        	l32i	a15, a1, 132
  90d31a:	600061        	j	90d37f <ath_buf_set_rate+0x1ab>
					     bf->bf_shpream);

	nbits = (pktlen << 3) + OFDM_PLCP_BITS;
	nsymbits = bits_per_symbol[HT_RC_2_MCS(rc)][width];
  90d31d:	080b43        	extui	a11, a8, 0, 4
		    ((bf->bf_rcs[i].flags & ATH_RC_CW40_FLAG) ?
		     HAL_RATESERIES_2040 : 0 ) |
		    ((bf->bf_rcs[i].flags & ATH_RC_HT40_SGI_FLAG) ?
		     HAL_RATESERIES_HALFGI : 0 );
#endif
	    series[i].PktDuration = ath_pkt_duration(sc, rix, bf,
  90d320:	c0e1      	movi.n	a14, 1
  90d322:	c0d0      	movi.n	a13, 0
  90d324:	0aed39        	movnez	a13, a14, a10
	if (!IS_HT_RATE(rc))
		return ath_hal_computetxtime(sc->sc_ah, rt, pktlen, rix,
					     bf->bf_shpream);

	nbits = (pktlen << 3) + OFDM_PLCP_BITS;
	nsymbits = bits_per_symbol[HT_RC_2_MCS(rc)][width];
  90d327:	00e104        	ssl	a14
  90d32a:	00ba1a        	sll	a10, a11
  90d32d:	adaa      	add.n	a10, a10, a13
  90d32f:	00e104        	ssl	a14
  90d332:	00aa1a        	sll	a10, a10
  90d335:	1e6aa4        	l32r	a14, 8e7dc8 <memset+0xf80>

	if (!IS_HT_RATE(rc))
		return ath_hal_computetxtime(sc->sc_ah, rt, pktlen, rix,
					     bf->bf_shpream);

	nbits = (pktlen << 3) + OFDM_PLCP_BITS;
  90d338:	0dcc11        	slli	a12, a12, 3
	nsymbits = bits_per_symbol[HT_RC_2_MCS(rc)][width];
  90d33b:	aaea      	add.n	a10, a14, a10
  90d33d:	2ba100        	l16ui	a11, a10, 0
	nsymbols = (nbits + nsymbits - 1) / nsymbits;
  90d340:	281620        	s32i	a8, a1, 128
  90d343:	acba      	add.n	a10, a11, a12
  90d345:	2aac15        	addi	a10, a10, 21
  90d348:	291622        	s32i	a9, a1, 136
  90d34b:	2f1621        	s32i	a15, a1, 132
  90d34e:	5b65bf        	call8	8e6a4c <__udivsi3>

	if (!half_gi)
  90d351:	2e121e        	l32i	a14, a1, 120
  90d354:	281220        	l32i	a8, a1, 128
  90d357:	291222        	l32i	a9, a1, 136
  90d35a:	2f1221        	l32i	a15, a1, 132
		duration = SYMBOL_TIME(nsymbols);
  90d35d:	0eab11        	slli	a11, a10, 2

	nbits = (pktlen << 3) + OFDM_PLCP_BITS;
	nsymbits = bits_per_symbol[HT_RC_2_MCS(rc)][width];
	nsymbols = (nbits + nsymbits - 1) / nsymbits;

	if (!half_gi)
  90d360:	c9e1      	beqz.n	a14, 90d375 <ath_buf_set_rate+0x1a1>
		duration = SYMBOL_TIME(nsymbols);
	else
		duration = SYMBOL_TIME_HALFGI(nsymbols);
  90d362:	0dab11        	slli	a11, a10, 3
  90d365:	aaba      	add.n	a10, a11, a10
  90d367:	0faa11        	slli	a10, a10, 1
  90d36a:	1b6aa5        	l32r	a11, 8e7e00 <memset+0xfb8>
  90d36d:	b4aa      	addi.n	a10, a10, 4
  90d36f:	0baa2a        	muluh	a10, a10, a11
  90d372:	0a2b14        	srli	a11, a10, 2

	streams = HT_RC_2_STREAMS(rc);
  90d375:	083a43        	extui	a10, a8, 3, 4
	duration += L_STF + L_LTF + L_SIG + HT_SIG + HT_STF + HT_LTF(streams);
  90d378:	b9aa      	addi.n	a10, a10, 9
  90d37a:	0eaa11        	slli	a10, a10, 2
  90d37d:	abaa      	add.n	a10, a10, a11
#endif
	    series[i].PktDuration = ath_pkt_duration(sc, rix, bf,
				     (bf->bf_rcs[i].flags & ATH_RC_CW40_FLAG) != 0,
				     (bf->bf_rcs[i].flags & ATH_RC_HT40_SGI_FLAG));

	    series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
  90d37f:	282d16        	addmi	a8, a2, 0x1600
  90d382:	288026        	l8ui	a8, a8, 38
		    ((bf->bf_rcs[i].flags & ATH_RC_CW40_FLAG) ?
		     HAL_RATESERIES_2040 : 0 ) |
		    ((bf->bf_rcs[i].flags & ATH_RC_HT40_SGI_FLAG) ?
		     HAL_RATESERIES_HALFGI : 0 );
#endif
	    series[i].PktDuration = ath_pkt_duration(sc, rix, bf,
  90d385:	9a92      	s32i.n	a10, a9, 8
				     (bf->bf_rcs[i].flags & ATH_RC_CW40_FLAG) != 0,
				     (bf->bf_rcs[i].flags & ATH_RC_HT40_SGI_FLAG));

	    series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
  90d387:	9893      	s32i.n	a8, a9, 12

	    if (prot_mode)
  90d389:	c878      	beqz.n	a7, 90d395 <ath_buf_set_rate+0x1c1>
		    series[i].RateFlags |= HAL_RATESERIES_RTS_CTS;
  90d38b:	8894      	l32i.n	a8, a9, 16
  90d38d:	c0a1      	movi.n	a10, 1
  90d38f:	0a8802        	or	a8, a8, a10
  90d392:	289604        	s32i	a8, a9, 16

	    if (bf->bf_rcs[i].flags & ATH_RC_DS_FLAG)
  90d395:	28f003        	l8ui	a8, a15, 3
  90d398:	7f8709        	bbci	a8, 31, 90d3a5 <ath_buf_set_rate+0x1d1>
		    series[i].RateFlags |= HAL_RATESERIES_RTS_CTS;
  90d39b:	8894      	l32i.n	a8, a9, 16
  90d39d:	c0a1      	movi.n	a10, 1
  90d39f:	0a8802        	or	a8, a8, a10
  90d3a2:	289604        	s32i	a8, a9, 16
	    }
    }

    adf_os_mem_set(series, 0, sizeof(HAL_11N_RATE_SERIES) * 4);

    for (i = 0; i < 4; i++) {
  90d3a5:	28121f        	l32i	a8, a1, 124
  90d3a8:	bcff      	addi.n	a15, a15, 12
  90d3aa:	299c1c        	addi	a9, a9, 28
  90d3ad:	78f102        	beq	a15, a8, 90d3b3 <ath_buf_set_rate+0x1df>
  90d3b0:	63fed1        	j	90d285 <ath_buf_set_rate+0xb1>

	    if (bf->bf_rcs[i].flags & ATH_RC_DS_FLAG)
		    series[i].RateFlags |= HAL_RATESERIES_RTS_CTS;
    }

    rtsctsrate = rt->info[cix].rateCode |
  90d3b3:	0e6211        	slli	a2, a6, 2
  90d3b6:	a626      	add.n	a6, a2, a6
  90d3b8:	0e6611        	slli	a6, a6, 2
	    (bf->bf_shpream ? rt->info[cix].shortPreamble : 0);
  90d3bb:	233221        	l32i	a3, a3, 132

	    if (bf->bf_rcs[i].flags & ATH_RC_DS_FLAG)
		    series[i].RateFlags |= HAL_RATESERIES_RTS_CTS;
    }

    rtsctsrate = rt->info[cix].rateCode |
  90d3be:	a644      	add.n	a4, a4, a6
  90d3c0:	2c4034        	l8ui	a12, a4, 52
  90d3c3:	220a00        	movi	a2, 0
  90d3c6:	793702        	bbci	a3, 25, 90d3cc <ath_buf_set_rate+0x1f8>
	    (bf->bf_shpream ? rt->info[cix].shortPreamble : 0);
  90d3c9:	224035        	l8ui	a2, a4, 53

    ah->ah_set11nRateScenario(ds, 1,
  90d3cc:	24121c        	l32i	a4, a1, 112
  90d3cf:	2a121d        	l32i	a10, a1, 116
  90d3d2:	234210        	l32i	a3, a4, 64
  90d3d5:	df50      	mov.n	a15, a5
  90d3d7:	c0e4      	movi.n	a14, 4
  90d3d9:	dd10      	mov.n	a13, a1
  90d3db:	0c2c02        	or	a12, a2, a12
  90d3de:	2b0a01        	movi	a11, 1
  90d3e1:	0b3000        	callx8	a3
  90d3e4:	d10f      	retw.n
	...

0090d3e8 <ath_dma_map$isra$8>:
	duration += L_STF + L_LTF + L_SIG + HT_SIG + HT_STF + HT_LTF(streams);

	return duration;
}

static void ath_dma_map(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
  90d3e8:	6c1004        	entry	a1, 32
 * @return first buffer in queue
 */
static inline adf_nbuf_t 
adf_nbuf_queue_first(adf_nbuf_queue_t *head)
{
    return (__adf_nbuf_queue_first(head));
  90d3eb:	2a3c14        	addi	a10, a3, 20
  90d3ee:	5be632        	call8	906cb8 <__adf_nbuf_queue_first>
adf_nbuf_map(adf_os_device_t        osdev, 
             adf_os_dma_map_t       bmap, 
             adf_nbuf_t             buf, 
             adf_os_dma_dir_t       dir)
{
    return __adf_nbuf_map(osdev, bmap, buf, dir);
  90d3f1:	dca0      	mov.n	a12, a10
  90d3f3:	8b30      	l32i.n	a11, a3, 0
  90d3f5:	8a20      	l32i.n	a10, a2, 0
  90d3f7:	c0d0      	movi.n	a13, 0
  90d3f9:	5be59d        	call8	906a70 <__adf_nbuf_map>
  90d3fc:	d10f      	retw.n
	...

0090d400 <ath_buf_toggle>:
}

static struct ath_tx_buf *ath_buf_toggle(struct ath_softc_tgt *sc,
				      struct ath_tx_buf *bf,
				      a_uint8_t retry)
{
  90d400:	6c1006        	entry	a1, 48
  90d403:	d520      	mov.n	a5, a2
	struct ath_tx_buf *tmp = NULL;
	adf_nbuf_t buf = NULL;

	adf_os_assert(sc->sc_txbuf_held != NULL);
  90d405:	2222dc        	l32i	a2, a2, 0x370
  90d408:	cd25      	bnez.n	a2, 90d421 <ath_buf_toggle+0x21>
  90d40a:	1268bf        	l32r	a2, 8e7708 <memset+0x8c0>
  90d40d:	1b6aa6        	l32r	a11, 8e7ea8 <memset+0x1060>
  90d410:	222212        	l32i	a2, a2, 72
  90d413:	1a6aa3        	l32r	a10, 8e7ea0 <memset+0x1058>
  90d416:	0b2000        	callx8	a2
  90d419:	126923        	l32r	a2, 8e78a8 <memset+0xa60>
  90d41c:	0c0200        	memw
  90d41f:	8220      	l32i.n	a2, a2, 0

	tmp = sc->sc_txbuf_held;
  90d421:	2252dc        	l32i	a2, a5, 0x370

	if (retry) {
  90d424:	6440e4        	beqz	a4, 90d50c <ath_buf_toggle+0x10c>
  90d427:	241a18        	movi	a4, 0x118
  90d42a:	a454      	add.n	a4, a5, a4
		ath_dma_unmap(sc, bf);
  90d42c:	db30      	mov.n	a11, a3
  90d42e:	044a02        	or	a10, a4, a4
  90d431:	5bff18        	call8	90d094 <ath_dma_unmap$isra$6>
		adf_nbuf_queue_init(&tmp->bf_skbhead);
  90d434:	272c14        	addi	a7, a2, 20
 * @param[in] head  buf queue head
 */
static inline void
adf_nbuf_queue_init(adf_nbuf_queue_t *head)
{
    __adf_nbuf_queue_init(head);
  90d437:	da70      	mov.n	a10, a7
  90d439:	5be619        	call8	906ca0 <__adf_nbuf_queue_init>
		buf = adf_nbuf_queue_remove(&bf->bf_skbhead);
  90d43c:	263c14        	addi	a6, a3, 20
 * @return The head buf in the buf queue.
 */
static inline adf_nbuf_t
adf_nbuf_queue_remove(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_remove(head);
  90d43f:	da60      	mov.n	a10, a6
  90d441:	5be57a        	call8	906a2c <__adf_nbuf_queue_remove>
  90d444:	d8a0      	mov.n	a8, a10
		adf_os_assert(buf);
  90d446:	cdab      	bnez.n	a10, 90d465 <ath_buf_toggle+0x65>
  90d448:	1968bf        	l32r	a9, 8e7744 <memset+0x8fc>
  90d44b:	1b6aa6        	l32r	a11, 8e7ee4 <memset+0x109c>
  90d44e:	299212        	l32i	a9, a9, 72
  90d451:	1a6aa3        	l32r	a10, 8e7ee0 <memset+0x1098>
  90d454:	9810      	s32i.n	a8, a1, 0
  90d456:	0b9000        	callx8	a9
  90d459:	196923        	l32r	a9, 8e78e8 <memset+0xaa0>
  90d45c:	281200        	l32i	a8, a1, 0
  90d45f:	0c0200        	memw
  90d462:	299200        	l32i	a9, a9, 0
 * @param[in] buf   buf
 */
static inline void
adf_nbuf_queue_add(adf_nbuf_queue_t *head, adf_nbuf_t buf)
{
    __adf_nbuf_queue_add(head, buf);
  90d465:	da70      	mov.n	a10, a7
  90d467:	db80      	mov.n	a11, a8
  90d469:	5be568        	call8	906a0c <__adf_nbuf_queue_add>
 * @return length of the queue
 */
static inline a_uint32_t
adf_nbuf_queue_len(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_len(head);
  90d46c:	da60      	mov.n	a10, a6
  90d46e:	5be610        	call8	906cb0 <__adf_nbuf_queue_len>
		adf_nbuf_queue_add(&tmp->bf_skbhead, buf);

		adf_os_assert(adf_nbuf_queue_len(&bf->bf_skbhead) == 0);
  90d471:	c9a5      	beqz.n	a10, 90d48a <ath_buf_toggle+0x8a>
  90d473:	1668bf        	l32r	a6, 8e7770 <memset+0x928>
  90d476:	1b6aa6        	l32r	a11, 8e7f10 <memset+0x10c8>
  90d479:	266212        	l32i	a6, a6, 72
  90d47c:	1a6aa3        	l32r	a10, 8e7f08 <memset+0x10c0>
  90d47f:	0b6000        	callx8	a6
  90d482:	166923        	l32r	a6, 8e7910 <memset+0xac8>
  90d485:	0c0200        	memw
  90d488:	8660      	l32i.n	a6, a6, 0

		tmp->bf_next = bf->bf_next;
  90d48a:	863b      	l32i.n	a6, a3, 44
		tmp->bf_tidno = bf->bf_tidno;
		tmp->bf_skb = bf->bf_skb;
		tmp->bf_node = bf->bf_node;
		tmp->bf_isaggr = bf->bf_isaggr;
		tmp->bf_flags = bf->bf_flags;
		tmp->bf_state = bf->bf_state;
  90d48c:	c4cc      	movi.n	a12, 76
		adf_os_assert(buf);
		adf_nbuf_queue_add(&tmp->bf_skbhead, buf);

		adf_os_assert(adf_nbuf_queue_len(&bf->bf_skbhead) == 0);

		tmp->bf_next = bf->bf_next;
  90d48e:	962b      	s32i.n	a6, a2, 44
		tmp->bf_endpt = bf->bf_endpt;
  90d490:	263223        	l32i	a6, a3, 140
		tmp->bf_tidno = bf->bf_tidno;
		tmp->bf_skb = bf->bf_skb;
		tmp->bf_node = bf->bf_node;
		tmp->bf_isaggr = bf->bf_isaggr;
		tmp->bf_flags = bf->bf_flags;
		tmp->bf_state = bf->bf_state;
  90d493:	2b3c3c        	addi	a11, a3, 60
		adf_nbuf_queue_add(&tmp->bf_skbhead, buf);

		adf_os_assert(adf_nbuf_queue_len(&bf->bf_skbhead) == 0);

		tmp->bf_next = bf->bf_next;
		tmp->bf_endpt = bf->bf_endpt;
  90d496:	262623        	s32i	a6, a2, 140
		tmp->bf_tidno = bf->bf_tidno;
  90d499:	26304d        	l8ui	a6, a3, 77
		tmp->bf_skb = bf->bf_skb;
		tmp->bf_node = bf->bf_node;
		tmp->bf_isaggr = bf->bf_isaggr;
		tmp->bf_flags = bf->bf_flags;
		tmp->bf_state = bf->bf_state;
  90d49c:	2a2c3c        	addi	a10, a2, 60

		adf_os_assert(adf_nbuf_queue_len(&bf->bf_skbhead) == 0);

		tmp->bf_next = bf->bf_next;
		tmp->bf_endpt = bf->bf_endpt;
		tmp->bf_tidno = bf->bf_tidno;
  90d49f:	26244d        	s8i	a6, a2, 77
		tmp->bf_skb = bf->bf_skb;
  90d4a2:	8638      	l32i.n	a6, a3, 32
		tmp->bf_node = bf->bf_node;
		tmp->bf_isaggr = bf->bf_isaggr;
  90d4a4:	283221        	l32i	a8, a3, 132
		adf_os_assert(adf_nbuf_queue_len(&bf->bf_skbhead) == 0);

		tmp->bf_next = bf->bf_next;
		tmp->bf_endpt = bf->bf_endpt;
		tmp->bf_tidno = bf->bf_tidno;
		tmp->bf_skb = bf->bf_skb;
  90d4a7:	9628      	s32i.n	a6, a2, 32
		tmp->bf_node = bf->bf_node;
		tmp->bf_isaggr = bf->bf_isaggr;
  90d4a9:	085840        	extui	a8, a8, 5, 1

		tmp->bf_next = bf->bf_next;
		tmp->bf_endpt = bf->bf_endpt;
		tmp->bf_tidno = bf->bf_tidno;
		tmp->bf_skb = bf->bf_skb;
		tmp->bf_node = bf->bf_node;
  90d4ac:	8634      	l32i.n	a6, a3, 16
		tmp->bf_isaggr = bf->bf_isaggr;
  90d4ae:	0b8911        	slli	a9, a8, 5
  90d4b1:	282087        	l8ui	a8, a2, 135

		tmp->bf_next = bf->bf_next;
		tmp->bf_endpt = bf->bf_endpt;
		tmp->bf_tidno = bf->bf_tidno;
		tmp->bf_skb = bf->bf_skb;
		tmp->bf_node = bf->bf_node;
  90d4b4:	262604        	s32i	a6, a2, 16
		tmp->bf_isaggr = bf->bf_isaggr;
  90d4b7:	26fadf        	movi	a6, -33
  90d4ba:	068801        	and	a8, a8, a6
  90d4bd:	098802        	or	a8, a8, a9
  90d4c0:	282487        	s8i	a8, a2, 135
		tmp->bf_flags = bf->bf_flags;
  90d4c3:	273144        	l16ui	a7, a3, 136
  90d4c6:	272544        	s16i	a7, a2, 136
		tmp->bf_state = bf->bf_state;
  90d4c9:	5b65a6        	call8	8e6b64 <memcpy>
		tmp->bf_retries = bf->bf_retries;
  90d4cc:	273086        	l8ui	a7, a3, 134
		bf->bf_comp = NULL;

		bf->bf_retries = 0;
		bf->bf_nframes = 0;

		ath_dma_map(sc, tmp);
  90d4cf:	db20      	mov.n	a11, a2
		tmp->bf_skb = bf->bf_skb;
		tmp->bf_node = bf->bf_node;
		tmp->bf_isaggr = bf->bf_isaggr;
		tmp->bf_flags = bf->bf_flags;
		tmp->bf_state = bf->bf_state;
		tmp->bf_retries = bf->bf_retries;
  90d4d1:	272486        	s8i	a7, a2, 134
		tmp->bf_comp = bf->bf_comp;
  90d4d4:	873f      	l32i.n	a7, a3, 60
		bf->bf_comp = NULL;

		bf->bf_retries = 0;
		bf->bf_nframes = 0;

		ath_dma_map(sc, tmp);
  90d4d6:	da40      	mov.n	a10, a4
		tmp->bf_node = bf->bf_node;
		tmp->bf_isaggr = bf->bf_isaggr;
		tmp->bf_flags = bf->bf_flags;
		tmp->bf_state = bf->bf_state;
		tmp->bf_retries = bf->bf_retries;
		tmp->bf_comp = bf->bf_comp;
  90d4d8:	972f      	s32i.n	a7, a2, 60
		tmp->bf_nframes = bf->bf_nframes;
  90d4da:	27304c        	l8ui	a7, a3, 76
  90d4dd:	27244c        	s8i	a7, a2, 76
		tmp->bf_cookie = bf->bf_cookie;
  90d4e0:	273092        	l8ui	a7, a3, 146
  90d4e3:	272492        	s8i	a7, a2, 146

		bf->bf_isaggr = 0;
  90d4e6:	283087        	l8ui	a8, a3, 135
  90d4e9:	068801        	and	a8, a8, a6
  90d4ec:	283487        	s8i	a8, a3, 135
		bf->bf_next = NULL;
  90d4ef:	c080      	movi.n	a8, 0
  90d4f1:	983b      	s32i.n	a8, a3, 44
		bf->bf_skb = NULL;
  90d4f3:	9838      	s32i.n	a8, a3, 32
		bf->bf_node = NULL;
  90d4f5:	9834      	s32i.n	a8, a3, 16
		bf->bf_flags = 0;
  90d4f7:	283544        	s16i	a8, a3, 136
		bf->bf_comp = NULL;
  90d4fa:	983f      	s32i.n	a8, a3, 60

		bf->bf_retries = 0;
  90d4fc:	283486        	s8i	a8, a3, 134
		bf->bf_nframes = 0;
  90d4ff:	28344c        	s8i	a8, a3, 76

		ath_dma_map(sc, tmp);
  90d502:	5bffb9        	call8	90d3e8 <ath_dma_map$isra$8>
		ath_tx_tgt_setds(sc, tmp);
  90d505:	db20      	mov.n	a11, a2
  90d507:	da50      	mov.n	a10, a5
  90d509:	5bff19        	call8	90d170 <ath_tx_tgt_setds>
	}

	sc->sc_txbuf_held = bf;
  90d50c:	2356dc        	s32i	a3, a5, 0x370

	return tmp;
}
  90d50f:	d10f      	retw.n
  90d511:	000000        	ill

0090d514 <ath_buf_comp>:
		ath_free_tx_skb(sc->tgt_htc_handle,endpt,tskb);
	}
}

static void ath_buf_comp(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90d514:	6c1004        	entry	a1, 32
	ath_dma_unmap(sc, bf);
  90d517:	2a1a18        	movi	a10, 0x118
  90d51a:	db30      	mov.n	a11, a3
  90d51c:	aa2a      	add.n	a10, a2, a10
  90d51e:	5bfedd        	call8	90d094 <ath_dma_unmap$isra$6>
	ath_tgt_skb_free(sc, &bf->bf_skbhead,bf->bf_endpt);
  90d521:	2c3223        	l32i	a12, a3, 140
  90d524:	2b3c14        	addi	a11, a3, 20
  90d527:	b82a      	addi.n	a10, a2, 8
  90d529:	5bfedf        	call8	90d0a8 <ath_tgt_skb_free$isra$7>
	bf->bf_skb = NULL;
  90d52c:	c040      	movi.n	a4, 0
  90d52e:	9438      	s32i.n	a4, a3, 32
	bf->bf_node = NULL;
  90d530:	9434      	s32i.n	a4, a3, 16
	bf = ath_buf_toggle(sc, bf, 0);
  90d532:	dc40      	mov.n	a12, a4
  90d534:	033b02        	or	a11, a3, a3
  90d537:	da20      	mov.n	a10, a2
  90d539:	5bffb1        	call8	90d400 <ath_buf_toggle>
	if (bf != NULL) {
  90d53c:	74a10e        	beq	a10, a4, 90d54e <ath_buf_comp+0x3a>
		asf_tailq_insert_tail(&sc->sc_txbuf, bf, bf_list);
  90d53f:	2322f1        	l32i	a3, a2, 0x3c4
  90d542:	94a9      	s32i.n	a4, a10, 36
  90d544:	93aa      	s32i.n	a3, a10, 40
  90d546:	9a30      	s32i.n	a10, a3, 0
  90d548:	2aac24        	addi	a10, a10, 36
  90d54b:	2a26f1        	s32i	a10, a2, 0x3c4
  90d54e:	d10f      	retw.n

0090d550 <ath_tx_freebuf>:
	bf->bf_txq_add(sc, bf);
}

static void
ath_tx_freebuf(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90d550:	6c1004        	entry	a1, 32
	a_int32_t i ;
	struct ath_tx_desc *bfd = NULL;
	struct ath_hal *ah = sc->sc_ah;
  90d553:	242d05        	addmi	a4, a2, 0x500
  90d556:	864b      	l32i.n	a6, a4, 44

	for (bfd = bf->bf_desc, i = 0; i < bf->bf_dmamap_info.nsegs; bfd++, i++) {
  90d558:	c050      	movi.n	a5, 0
  90d55a:	843c      	l32i.n	a4, a3, 48
  90d55c:	270a88        	movi	a7, 136
  90d55f:	600023        	j	90d586 <ath_tx_freebuf+0x36>
  90d562:	000028        	mull	a0, a0, a0
		ah->ah_clr11nAggr(bfd);
  90d565:	6214da        	j	8eea43 <memset+0x7bfb>
  90d568:	400b80        	excw
  90d56b:	002862        	excw
		ah->ah_set11nBurstDuration(bfd, 0);
  90d56e:	15044a        	l32r	a5, 8ce698 <_bss_end+0x3bb788>
  90d571:	022b0a        	addx4	a11, a2, a2
  90d574:	000b80        	excw
  90d577:	002862        	excw
		ah->ah_set11nVirtualMoreFrag(bfd, 0);
  90d57a:	16da40        	l32r	a6, 903e7c <memset+0x1d034>
  90d57d:	c0b0      	movi.n	a11, 0
  90d57f:	0b8000        	callx8	a8
{
	a_int32_t i ;
	struct ath_tx_desc *bfd = NULL;
	struct ath_hal *ah = sc->sc_ah;

	for (bfd = bf->bf_desc, i = 0; i < bf->bf_dmamap_info.nsegs; bfd++, i++) {
  90d582:	a744      	add.n	a4, a4, a7
  90d584:	b155      	addi.n	a5, a5, 1
  90d586:	8831      	l32i.n	a8, a3, 4
  90d588:	7853d8        	bltu	a5, a8, 90d564 <ath_tx_freebuf+0x14>
		ah->ah_clr11nAggr(bfd);
		ah->ah_set11nBurstDuration(bfd, 0);
		ah->ah_set11nVirtualMoreFrag(bfd, 0);
	}

	ath_dma_unmap(sc, bf);
  90d58b:	2a1a18        	movi	a10, 0x118
  90d58e:	db30      	mov.n	a11, a3
  90d590:	aa2a      	add.n	a10, a2, a10
  90d592:	5bfec0        	call8	90d094 <ath_dma_unmap$isra$6>

	ath_tgt_skb_free(sc, &bf->bf_skbhead,bf->bf_endpt);
  90d595:	2c3223        	l32i	a12, a3, 140
  90d598:	2b3c14        	addi	a11, a3, 20
  90d59b:	2a2c08        	addi	a10, a2, 8
  90d59e:	5bfec2        	call8	90d0a8 <ath_tgt_skb_free$isra$7>

	bf->bf_skb = NULL;
  90d5a1:	c040      	movi.n	a4, 0
  90d5a3:	9438      	s32i.n	a4, a3, 32
	bf->bf_comp = NULL;
  90d5a5:	943f      	s32i.n	a4, a3, 60
	bf->bf_node = NULL;
  90d5a7:	9434      	s32i.n	a4, a3, 16
	bf->bf_next = NULL;
  90d5a9:	943b      	s32i.n	a4, a3, 44
	bf = ath_buf_toggle(sc, bf, 0);
  90d5ab:	db30      	mov.n	a11, a3
  90d5ad:	dc40      	mov.n	a12, a4
  90d5af:	da20      	mov.n	a10, a2
  90d5b1:	5bff93        	call8	90d400 <ath_buf_toggle>
	bf->bf_retries = 0;
	bf->bf_isretried = 0;
  90d5b4:	23a087        	l8ui	a3, a10, 135
  90d5b7:	c65f      	movi.n	a5, -17
	bf->bf_skb = NULL;
	bf->bf_comp = NULL;
	bf->bf_node = NULL;
	bf->bf_next = NULL;
	bf = ath_buf_toggle(sc, bf, 0);
	bf->bf_retries = 0;
  90d5b9:	24a486        	s8i	a4, a10, 134
	bf->bf_isretried = 0;
  90d5bc:	053301        	and	a3, a3, a5
  90d5bf:	23a487        	s8i	a3, a10, 135

	if (bf != NULL)
		asf_tailq_insert_tail(&sc->sc_txbuf, bf, bf_list);
  90d5c2:	2322f1        	l32i	a3, a2, 0x3c4
  90d5c5:	94a9      	s32i.n	a4, a10, 36
  90d5c7:	93aa      	s32i.n	a3, a10, 40
  90d5c9:	9a30      	s32i.n	a10, a3, 0
  90d5cb:	2aac24        	addi	a10, a10, 36
  90d5ce:	2a26f1        	s32i	a10, a2, 0x3c4
  90d5d1:	d10f      	retw.n
	...

0090d5d4 <ath_bar_tx>:
	ath_buf_comp(sc, bf);
}

static void ath_bar_tx(struct ath_softc_tgt *sc,
		       ath_atx_tid_t *tid, struct ath_tx_buf *bf)
{
  90d5d4:	6c101a        	entry	a1, 208
  90d5d7:	033702        	or	a7, a3, a3
	adf_nbuf_t skb;
	struct ieee80211_frame_bar *bar;
	u_int8_t min_rate;
	struct ath_tx_desc *ds, *ds0;
	struct ath_hal *ah = sc->sc_ah;
  90d5da:	232d05        	addmi	a3, a2, 0x500
  90d5dd:	863b      	l32i.n	a6, a3, 44
  90d5df:	231628        	s32i	a3, a1, 160
	int i = 0;
	adf_nbuf_queue_t skbhead;
	a_uint8_t *anbdata;
	a_uint32_t anblen;

	__stats(sc, tx_bars);
  90d5e2:	232278        	l32i	a3, a2, 0x1e0
  90d5e5:	2b0a70        	movi	a11, 112
  90d5e8:	233c01        	addi	a3, a3, 1
  90d5eb:	232678        	s32i	a3, a2, 0x1e0
  90d5ee:	2a1c20        	addi	a10, a1, 32
  90d5f1:	5bfef3        	call8	90d1c0 <__adf_os_mem_set$constprop$19>

	adf_os_mem_set(&series, 0, sizeof(series));

	ath_aggr_pause_tid(sc, tid);

	skb = adf_nbuf_queue_remove(&bf->bf_skbhead);
  90d5f4:	254c14        	addi	a5, a4, 20
}

static inline void
ath_aggr_pause_tid(struct ath_softc_tgt *sc, ath_atx_tid_t *tid)
{
	tid->paused =1;
  90d5f7:	c031      	movi.n	a3, 1
  90d5f9:	237434        	s8i	a3, a7, 52
 * @return The head buf in the buf queue.
 */
static inline adf_nbuf_t
adf_nbuf_queue_remove(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_remove(head);
  90d5fc:	da50      	mov.n	a10, a5
  90d5fe:	5be50b        	call8	906a2c <__adf_nbuf_queue_remove>
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  90d601:	281c20        	addi	a8, a1, 32
  90d604:	2c8c70        	addi	a12, a8, 112
  90d607:	2b8c74        	addi	a11, a8, 116
 * @return The head buf in the buf queue.
 */
static inline adf_nbuf_t
adf_nbuf_queue_remove(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_remove(head);
  90d60a:	0aa302        	or	a3, a10, a10
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  90d60d:	5be59e        	call8	906c88 <__adf_nbuf_peek_header>
 * @return none
 */
static inline void
adf_nbuf_trim_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    __adf_nbuf_trim_tail(buf, size);
  90d610:	2b1224        	l32i	a11, a1, 144
  90d613:	da30      	mov.n	a10, a3
  90d615:	5be57b        	call8	906c04 <__adf_nbuf_trim_tail>
  90d618:	2c1a18        	movi	a12, 0x118
  90d61b:	ac2c      	add.n	a12, a2, a12
	ath_aggr_pause_tid(sc, tid);

	skb = adf_nbuf_queue_remove(&bf->bf_skbhead);
	adf_nbuf_peek_header(skb, &anbdata, &anblen);
	adf_nbuf_trim_tail(skb, anblen);
	bar = (struct ieee80211_frame_bar *) anbdata;
  90d61d:	291225        	l32i	a9, a1, 148

	min_rate =  0x0b;

	ath_dma_unmap(sc, bf);
  90d620:	dac0      	mov.n	a10, a12
  90d622:	db40      	mov.n	a11, a4
  90d624:	2c162a        	s32i	a12, a1, 168
  90d627:	291629        	s32i	a9, a1, 164
  90d62a:	5bfe9a        	call8	90d094 <ath_dma_unmap$isra$6>
 * @param[in] buf   buf
 */
static inline void
adf_nbuf_queue_add(adf_nbuf_queue_t *head, adf_nbuf_t buf)
{
    __adf_nbuf_queue_add(head, buf);
  90d62d:	db30      	mov.n	a11, a3
  90d62f:	da50      	mov.n	a10, a5
  90d631:	5be4f6        	call8	906a0c <__adf_nbuf_queue_add>
	adf_nbuf_queue_add(&bf->bf_skbhead, skb);

	bar->i_fc[1] = IEEE80211_FC1_DIR_NODS;
  90d634:	291229        	l32i	a9, a1, 164
  90d637:	c050      	movi.n	a5, 0
  90d639:	259401        	s8i	a5, a9, 1
	bar->i_fc[0] = IEEE80211_FC0_VERSION_0 |
  90d63c:	25fa84        	movi	a5, -124
  90d63f:	259400        	s8i	a5, a9, 0
		IEEE80211_FC0_TYPE_CTL |
		IEEE80211_FC0_SUBTYPE_BAR;
	bar->i_ctl = tid->tidno << IEEE80211_BAR_CTL_TID_S |
  90d642:	8570      	l32i.n	a5, a7, 0
  90d644:	c0a4      	movi.n	a10, 4
  90d646:	045511        	slli	a5, a5, 12
  90d649:	0a5502        	or	a5, a5, a10
  90d64c:	05054f        	extui	a5, a5, 0, 16
  90d64f:	259411        	s8i	a5, a9, 17
  90d652:	058a14        	srli	a10, a5, 8
		IEEE80211_BAR_CTL_COMBA;
	bar->i_seq = adf_os_cpu_to_le16(tid->seq_start << IEEE80211_SEQ_SEQ_SHIFT);
  90d655:	257102        	l16ui	a5, a7, 4

	bar->i_fc[1] = IEEE80211_FC1_DIR_NODS;
	bar->i_fc[0] = IEEE80211_FC0_VERSION_0 |
		IEEE80211_FC0_TYPE_CTL |
		IEEE80211_FC0_SUBTYPE_BAR;
	bar->i_ctl = tid->tidno << IEEE80211_BAR_CTL_TID_S |
  90d658:	2a9410        	s8i	a10, a9, 16
		IEEE80211_BAR_CTL_COMBA;
	bar->i_seq = adf_os_cpu_to_le16(tid->seq_start << IEEE80211_SEQ_SEQ_SHIFT);
  90d65b:	0c5511        	slli	a5, a5, 4
  90d65e:	05054f        	extui	a5, a5, 0, 16
  90d661:	058b14        	srli	a11, a5, 8
  90d664:	085a11        	slli	a10, a5, 8
  90d667:	0baa02        	or	a10, a10, a11
  90d66a:	0a0a4f        	extui	a10, a10, 0, 16
  90d66d:	0a8b14        	srli	a11, a10, 8
  90d670:	2b9412        	s8i	a11, a9, 18
  90d673:	2a9413        	s8i	a10, a9, 19

	bf->bf_seqno = tid->seq_start << IEEE80211_SEQ_SEQ_SHIFT;
  90d676:	254523        	s16i	a5, a4, 70
 *         put, or NULL if there is not enough room in this buf.
 */
static inline a_uint8_t *
adf_nbuf_put_tail(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_put_tail(buf, size);
  90d679:	c1b4      	movi.n	a11, 20
  90d67b:	da30      	mov.n	a10, a3
  90d67d:	5be557        	call8	906bdc <__adf_nbuf_put_tail>

	adf_nbuf_put_tail(skb, sizeof(struct ieee80211_frame_bar));

	bf->bf_comp = ath_bar_tx_comp;
  90d680:	156aa7        	l32r	a5, 8e811c <memset+0x12d4>
	bf->bf_tidno = tid->tidno;
	bf->bf_node = &tid->an->ni;
	ath_dma_map(sc, bf);
  90d683:	2c122a        	l32i	a12, a1, 168

	bf->bf_seqno = tid->seq_start << IEEE80211_SEQ_SEQ_SHIFT;

	adf_nbuf_put_tail(skb, sizeof(struct ieee80211_frame_bar));

	bf->bf_comp = ath_bar_tx_comp;
  90d686:	954f      	s32i.n	a5, a4, 60
	bf->bf_tidno = tid->tidno;
  90d688:	8570      	l32i.n	a5, a7, 0
	bf->bf_node = &tid->an->ni;
	ath_dma_map(sc, bf);
  90d68a:	dac0      	mov.n	a10, a12
	bf->bf_seqno = tid->seq_start << IEEE80211_SEQ_SEQ_SHIFT;

	adf_nbuf_put_tail(skb, sizeof(struct ieee80211_frame_bar));

	bf->bf_comp = ath_bar_tx_comp;
	bf->bf_tidno = tid->tidno;
  90d68c:	25444d        	s8i	a5, a4, 77
	bf->bf_node = &tid->an->ni;
  90d68f:	857e      	l32i.n	a5, a7, 56
	ath_dma_map(sc, bf);
  90d691:	db40      	mov.n	a11, a4

	adf_nbuf_put_tail(skb, sizeof(struct ieee80211_frame_bar));

	bf->bf_comp = ath_bar_tx_comp;
	bf->bf_tidno = tid->tidno;
	bf->bf_node = &tid->an->ni;
  90d693:	254604        	s32i	a5, a4, 16
	ath_dma_map(sc, bf);
  90d696:	5bff54        	call8	90d3e8 <ath_dma_map$isra$8>
 * @param[out] sg   map info
 */
static inline void
adf_nbuf_dmamap_info(adf_os_dma_map_t bmap, adf_os_dmamap_info_t *sg)
{
    __adf_nbuf_dmamap_info(bmap, sg);
  90d699:	8a40      	l32i.n	a10, a4, 0
  90d69b:	b44b      	addi.n	a11, a4, 4
  90d69d:	5be4fc        	call8	906a90 <__adf_nbuf_dmamap_info>
	adf_nbuf_dmamap_info(bf->bf_dmamap, &bf->bf_dmamap_info);

	ds = bf->bf_desc;
	ah->ah_setupTxDesc(ds
  90d6a0:	286217        	l32i	a8, a6, 92
 * @return The total length of this buf.
 */
static inline adf_os_size_t
adf_nbuf_len(adf_nbuf_t buf)
{
    return (__adf_nbuf_len(buf));
  90d6a3:	da30      	mov.n	a10, a3
	bf->bf_tidno = tid->tidno;
	bf->bf_node = &tid->an->ni;
	ath_dma_map(sc, bf);
	adf_nbuf_dmamap_info(bf->bf_dmamap, &bf->bf_dmamap_info);

	ds = bf->bf_desc;
  90d6a5:	854c      	l32i.n	a5, a4, 48
  90d6a7:	281629        	s32i	a8, a1, 164
  90d6aa:	5be56f        	call8	906c68 <__adf_nbuf_len>
	ah->ah_setupTxDesc(ds
  90d6ad:	c191      	movi.n	a9, 17
  90d6af:	9912      	s32i.n	a9, a1, 8
  90d6b1:	294049        	l8ui	a9, a4, 73
  90d6b4:	c030      	movi.n	a3, 0
  90d6b6:	c0fb      	movi.n	a15, 11
  90d6b8:	281229        	l32i	a8, a1, 164
  90d6bb:	9911      	s32i.n	a9, a1, 4
  90d6bd:	b4ab      	addi.n	a11, a10, 4
  90d6bf:	9314      	s32i.n	a3, a1, 16
  90d6c1:	9313      	s32i.n	a3, a1, 12
  90d6c3:	9f10      	s32i.n	a15, a1, 0
  90d6c5:	c3ec      	movi.n	a14, 60
  90d6c7:	dd30      	mov.n	a13, a3
  90d6c9:	dc30      	mov.n	a12, a3
  90d6cb:	da50      	mov.n	a10, a5
  90d6cd:	0b8000        	callx8	a8
			    , HAL_TXDESC_INTREQ
			    | HAL_TXDESC_CLRDMASK
			    , 0, 0);

	skbhead = bf->bf_skbhead;
	bf->bf_isaggr = 0;
  90d6d0:	284087        	l8ui	a8, a4, 135
  90d6d3:	29fadf        	movi	a9, -33
  90d6d6:	098801        	and	a8, a8, a9
  90d6d9:	284487        	s8i	a8, a4, 135
	bf->bf_next = NULL;
  90d6dc:	934b      	s32i.n	a3, a4, 44

	for (ds0 = ds, i=0; i < bf->bf_dmamap_info.nsegs; ds0++, i++) {
  90d6de:	290a88        	movi	a9, 136
  90d6e1:	600012        	j	90d6f7 <ath_bar_tx+0x123>
		ah->ah_clr11nAggr(ds0);
  90d6e4:	286214        	l32i	a8, a6, 80
  90d6e7:	055a02        	or	a10, a5, a5
  90d6ea:	291629        	s32i	a9, a1, 164
  90d6ed:	0b8000        	callx8	a8

	skbhead = bf->bf_skbhead;
	bf->bf_isaggr = 0;
	bf->bf_next = NULL;

	for (ds0 = ds, i=0; i < bf->bf_dmamap_info.nsegs; ds0++, i++) {
  90d6f0:	291229        	l32i	a9, a1, 164
  90d6f3:	b133      	addi.n	a3, a3, 1
  90d6f5:	a955      	add.n	a5, a5, a9
  90d6f7:	8841      	l32i.n	a8, a4, 4
  90d6f9:	7833e7        	bltu	a3, a8, 90d6e4 <ath_bar_tx+0x110>
		ah->ah_clr11nAggr(ds0);
	}

	ath_filltxdesc(sc, bf);
  90d6fc:	231228        	l32i	a3, a1, 160
  90d6ff:	db40      	mov.n	a11, a4
  90d701:	8a3b      	l32i.n	a10, a3, 44

	for (i = 0 ; i < 4; i++) {
		series[i].Tries = ATH_TXMAXTRY;
		series[i].Rate = min_rate;
		series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
  90d703:	232d16        	addmi	a3, a2, 0x1600

	for (ds0 = ds, i=0; i < bf->bf_dmamap_info.nsegs; ds0++, i++) {
		ah->ah_clr11nAggr(ds0);
	}

	ath_filltxdesc(sc, bf);
  90d706:	5bfe72        	call8	90d0d0 <ath_filltxdesc$isra$9>

	for (i = 0 ; i < 4; i++) {
		series[i].Tries = ATH_TXMAXTRY;
		series[i].Rate = min_rate;
		series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
  90d709:	283026        	l8ui	a8, a3, 38
	}

	ath_filltxdesc(sc, bf);

	for (i = 0 ; i < 4; i++) {
		series[i].Tries = ATH_TXMAXTRY;
  90d70c:	c07b      	movi.n	a7, 11
  90d70e:	231c20        	addi	a3, a1, 32
  90d711:	250a04        	movi	a5, 4
  90d714:	9730      	s32i.n	a7, a3, 0
		series[i].Rate = min_rate;
  90d716:	9731      	s32i.n	a7, a3, 4
		series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
  90d718:	9833      	s32i.n	a8, a3, 12
  90d71a:	233c1c        	addi	a3, a3, 28
  90d71d:	b055      	addi.n	a5, a5, -1
  90d71f:	655ff1        	bnez	a5, 90d714 <ath_bar_tx+0x140>
	}

	ah->ah_set11nRateScenario(bf->bf_desc, 0, 0, series, 4, 4);
  90d722:	c0f4      	movi.n	a15, 4
  90d724:	c0c0      	movi.n	a12, 0
  90d726:	8a4c      	l32i.n	a10, a4, 48
  90d728:	236210        	l32i	a3, a6, 64
  90d72b:	dbc0      	mov.n	a11, a12
  90d72d:	def0      	mov.n	a14, a15
  90d72f:	2d1c20        	addi	a13, a1, 32
  90d732:	0b3000        	callx8	a3
	ath_tgt_txq_add_ucast(sc, bf);
  90d735:	db40      	mov.n	a11, a4
  90d737:	da20      	mov.n	a10, a2
  90d739:	5bfddc        	call8	90ceac <ath_tgt_txq_add_ucast>
  90d73c:	d10f      	retw.n
	...

0090d740 <owl_tgt_node_init>:
		ath_aggr_resume_tid(sc, tid);
	}
}

void owl_tgt_node_init(struct ath_node_target * an)
{
  90d740:	6c1004        	entry	a1, 32
	struct ath_atx_tid *tid;
	int tidno;

	for (tidno = 0, tid = &an->tid[tidno]; tidno < WME_NUM_TID;tidno++, tid++) {
  90d743:	232c24        	addi	a3, a2, 36
  90d746:	240a00        	movi	a4, 0
		tid->tidno = tidno;
		tid->an = an;

		if ( tid->flag & TID_CLEANUP_INPROGRES ) {
			tid->flag |= TID_REINITIALIZE;
  90d749:	250a04        	movi	a5, 4

	for (tidno = 0, tid = &an->tid[tidno]; tidno < WME_NUM_TID;tidno++, tid++) {
		tid->tidno = tidno;
		tid->an = an;

		if ( tid->flag & TID_CLEANUP_INPROGRES ) {
  90d74c:	283036        	l8ui	a8, a3, 54
{
	struct ath_atx_tid *tid;
	int tidno;

	for (tidno = 0, tid = &an->tid[tidno]; tidno < WME_NUM_TID;tidno++, tid++) {
		tid->tidno = tidno;
  90d74f:	9430      	s32i.n	a4, a3, 0
		tid->an = an;
  90d751:	923e      	s32i.n	a2, a3, 56

		if ( tid->flag & TID_CLEANUP_INPROGRES ) {
  90d753:	7f871d        	bbci	a8, 31, 90d774 <owl_tgt_node_init+0x34>
			tid->flag |= TID_REINITIALIZE;
  90d756:	058802        	or	a8, a8, a5
  90d759:	283436        	s8i	a8, a3, 54
			adf_os_print("tid[%p]->incomp is not 0: %d\n",
  90d75c:	1868bf        	l32r	a8, 8e7a58 <memset+0xc10>
  90d75f:	2c3037        	l8ui	a12, a3, 55
  90d762:	288212        	l32i	a8, a8, 72
  90d765:	1a6aa8        	l32r	a10, 8e8208 <memset+0x13c0>
  90d768:	00cc32        	sext	a12, a12, 7
  90d76b:	db30      	mov.n	a11, a3
  90d76d:	0b8000        	callx8	a8
  90d770:	600005        	j	90d779 <owl_tgt_node_init+0x39>
  90d773:	00da30        	excw
				     tid, tid->incomp);
		} else {
			owl_tgt_tid_init(tid);
  90d776:	5bfdba        	call8	90ce60 <owl_tgt_tid_init>
void owl_tgt_node_init(struct ath_node_target * an)
{
	struct ath_atx_tid *tid;
	int tidno;

	for (tidno = 0, tid = &an->tid[tidno]; tidno < WME_NUM_TID;tidno++, tid++) {
  90d779:	b144      	addi.n	a4, a4, 1
  90d77b:	233c3c        	addi	a3, a3, 60
  90d77e:	6948ca        	bnei	a4, 8, 90d74c <owl_tgt_node_init+0xc>
				     tid, tid->incomp);
		} else {
			owl_tgt_tid_init(tid);
		}
	}
}
  90d781:	d10f      	retw.n
	...

0090d784 <ath_tx_status_clear>:

void ath_tx_status_clear(struct ath_softc_tgt *sc)
{
  90d784:	6c1004        	entry	a1, 32
	int i;

	for (i = 0; i < 2; i++) {
		sc->tx_status[i].cnt = 0;
  90d787:	222d16        	addmi	a2, a2, 0x1600
  90d78a:	c080      	movi.n	a8, 0
  90d78c:	282438        	s8i	a8, a2, 56
  90d78f:	28245d        	s8i	a8, a2, 93
  90d792:	d10f      	retw.n

0090d794 <ath_tx_status_update>:

	return txs;
}

void ath_tx_status_update(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90d794:	6c1004        	entry	a1, 32
	struct ath_tx_desc *ds = bf->bf_lastds;
	WMI_TXSTATUS_EVENT *txs;

	if (sc->sc_tx_draining)
  90d797:	242249        	l32i	a4, a2, 0x124
  90d79a:	156a66        	l32r	a5, 8e8134 <memset+0x12ec>
  90d79d:	054401        	and	a4, a4, a5
  90d7a0:	6540b1        	bnez	a4, 90d855 <ath_tx_status_update+0xc1>
{
	WMI_TXSTATUS_EVENT *txs = NULL;
	int i;

	for (i = 0; i < 2; i++) {
		if (sc->tx_status[i].cnt < HTC_MAX_TX_STATUS) {
  90d7a3:	282d16        	addmi	a8, a2, 0x1600
  90d7a6:	298038        	l8ui	a9, a8, 56
  90d7a9:	c05b      	movi.n	a5, 11
  90d7ab:	795b0a        	bgeu	a5, a9, 90d7b9 <ath_tx_status_update+0x25>
  90d7ae:	24805d        	l8ui	a4, a8, 93
  90d7b1:	745b02        	bgeu	a5, a4, 90d7b7 <ath_tx_status_update+0x23>
  90d7b4:	60009d        	j	90d855 <ath_tx_status_update+0xc1>
static WMI_TXSTATUS_EVENT *ath_tx_status_get(struct ath_softc_tgt *sc)
{
	WMI_TXSTATUS_EVENT *txs = NULL;
	int i;

	for (i = 0; i < 2; i++) {
  90d7b7:	c041      	movi.n	a4, 1
		if (sc->tx_status[i].cnt < HTC_MAX_TX_STATUS) {
			txs = &sc->tx_status[i];
  90d7b9:	0d4511        	slli	a5, a4, 3
  90d7bc:	a459      	add.n	a9, a5, a4
  90d7be:	0e9911        	slli	a9, a9, 2
  90d7c1:	a499      	add.n	a9, a9, a4
  90d7c3:	1b6aa9        	l32r	a11, 8e8268 <memset+0x1420>

	txs = ath_tx_status_get(sc);
	if (txs == NULL)
		return;

	txs->txstatus[txs->cnt].ts_flags = 0;
  90d7c6:	a928      	add.n	a8, a2, a9
  90d7c8:	ab88      	add.n	a8, a8, a11
  90d7ca:	2c8000        	l8ui	a12, a8, 0
	WMI_TXSTATUS_EVENT *txs = NULL;
	int i;

	for (i = 0; i < 2; i++) {
		if (sc->tx_status[i].cnt < HTC_MAX_TX_STATUS) {
			txs = &sc->tx_status[i];
  90d7cd:	ab9d      	add.n	a13, a9, a11

	txs = ath_tx_status_get(sc);
	if (txs == NULL)
		return;

	txs->txstatus[txs->cnt].ts_flags = 0;
  90d7cf:	0fc811        	slli	a8, a12, 1
  90d7d2:	ac8b      	add.n	a11, a8, a12
  90d7d4:	a9b9      	add.n	a9, a11, a9
  90d7d6:	1b6aaa        	l32r	a11, 8e8280 <memset+0x1438>
  90d7d9:	a929      	add.n	a9, a2, a9
  90d7db:	ab9b      	add.n	a11, a9, a11
  90d7dd:	c0e0      	movi.n	a14, 0
	return txs;
}

void ath_tx_status_update(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_tx_desc *ds = bf->bf_lastds;
  90d7df:	8a3e      	l32i.n	a10, a3, 56

	txs = ath_tx_status_get(sc);
	if (txs == NULL)
		return;

	txs->txstatus[txs->cnt].ts_flags = 0;
  90d7e1:	2eb400        	s8i	a14, a11, 0

	txs->txstatus[txs->cnt].cookie = bf->bf_cookie;
  90d7e4:	1e6aab        	l32r	a14, 8e8290 <memset+0x1448>
  90d7e7:	2f3092        	l8ui	a15, a3, 146
  90d7ea:	ae9e      	add.n	a14, a9, a14
  90d7ec:	2fe400        	s8i	a15, a14, 0
	txs->txstatus[txs->cnt].ts_rate = SM(bf->bf_endpt, ATH9K_HTC_TXSTAT_EPID);
  90d7ef:	1e6aac        	l32r	a14, 8e82a0 <memset+0x1458>

	if (ds->ds_txstat.ts_status & HAL_TXERR_FILT)
  90d7f2:	c0f2      	movi.n	a15, 2
		return;

	txs->txstatus[txs->cnt].ts_flags = 0;

	txs->txstatus[txs->cnt].cookie = bf->bf_cookie;
	txs->txstatus[txs->cnt].ts_rate = SM(bf->bf_endpt, ATH9K_HTC_TXSTAT_EPID);
  90d7f4:	0e9908        	add	a9, a9, a14
  90d7f7:	2e3223        	l32i	a14, a3, 140
	WMI_TXSTATUS_EVENT *txs = NULL;
	int i;

	for (i = 0; i < 2; i++) {
		if (sc->tx_status[i].cnt < HTC_MAX_TX_STATUS) {
			txs = &sc->tx_status[i];
  90d7fa:	0d2d08        	add	a13, a2, a13
		return;

	txs->txstatus[txs->cnt].ts_flags = 0;

	txs->txstatus[txs->cnt].cookie = bf->bf_cookie;
	txs->txstatus[txs->cnt].ts_rate = SM(bf->bf_endpt, ATH9K_HTC_TXSTAT_EPID);
  90d7fd:	0cee11        	slli	a14, a14, 4
  90d800:	2e9400        	s8i	a14, a9, 0

	if (ds->ds_txstat.ts_status & HAL_TXERR_FILT)
  90d803:	2ea066        	l8ui	a14, a10, 102
  90d806:	7fe008        	bnone	a14, a15, 90d812 <ath_tx_status_update+0x7e>
		txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_FILT;
  90d809:	29b000        	l8ui	a9, a11, 0
  90d80c:	0f9902        	or	a9, a9, a15
  90d80f:	29b400        	s8i	a9, a11, 0

	if (!(ds->ds_txstat.ts_status & HAL_TXERR_XRETRY) &&
  90d812:	c197      	movi.n	a9, 23
  90d814:	79e81c        	bany	a14, a9, 90d834 <ath_tx_status_update+0xa0>
	    !(ds->ds_txstat.ts_status & HAL_TXERR_FIFO) &&
	    !(ds->ds_txstat.ts_status & HAL_TXERR_TIMER_EXPIRED) &&
	    !(ds->ds_txstat.ts_status & HAL_TXERR_FILT))
		txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_ACK;
  90d817:	a459      	add.n	a9, a5, a4
  90d819:	0e9911        	slli	a9, a9, 2
  90d81c:	a499      	add.n	a9, a9, a4
  90d81e:	ac88      	add.n	a8, a8, a12
  90d820:	a988      	add.n	a8, a8, a9
  90d822:	196aaa        	l32r	a9, 8e82cc <memset+0x1484>
  90d825:	a828      	add.n	a8, a2, a8
  90d827:	a988      	add.n	a8, a8, a9
  90d829:	298000        	l8ui	a9, a8, 0
  90d82c:	c0b1      	movi.n	a11, 1
  90d82e:	0b9902        	or	a9, a9, a11
  90d831:	298400        	s8i	a9, a8, 0

	ath_tx_status_update_rate(sc, bf->bf_rcs, ds->ds_txstat.ts_rate, txs);
  90d834:	2ca068        	l8ui	a12, a10, 104

	txs->cnt++;
  90d837:	a455      	add.n	a5, a5, a4
	    !(ds->ds_txstat.ts_status & HAL_TXERR_FIFO) &&
	    !(ds->ds_txstat.ts_status & HAL_TXERR_TIMER_EXPIRED) &&
	    !(ds->ds_txstat.ts_status & HAL_TXERR_FILT))
		txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_ACK;

	ath_tx_status_update_rate(sc, bf->bf_rcs, ds->ds_txstat.ts_rate, txs);
  90d839:	2b3c50        	addi	a11, a3, 80
  90d83c:	da20      	mov.n	a10, a2

	txs->cnt++;
  90d83e:	0e5511        	slli	a5, a5, 2
	    !(ds->ds_txstat.ts_status & HAL_TXERR_FIFO) &&
	    !(ds->ds_txstat.ts_status & HAL_TXERR_TIMER_EXPIRED) &&
	    !(ds->ds_txstat.ts_status & HAL_TXERR_FILT))
		txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_ACK;

	ath_tx_status_update_rate(sc, bf->bf_rcs, ds->ds_txstat.ts_rate, txs);
  90d841:	5bfd0e        	call8	90cc7c <ath_tx_status_update_rate>

	txs->cnt++;
  90d844:	a454      	add.n	a4, a5, a4
  90d846:	136aa9        	l32r	a3, 8e82ec <memset+0x14a4>
  90d849:	a422      	add.n	a2, a2, a4
  90d84b:	a322      	add.n	a2, a2, a3
  90d84d:	232000        	l8ui	a3, a2, 0
  90d850:	b133      	addi.n	a3, a3, 1
  90d852:	232400        	s8i	a3, a2, 0
  90d855:	d10f      	retw.n
	...

0090d858 <ath_tx_status_update_aggr>:
}

void ath_tx_status_update_aggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
			       struct ath_tx_desc *ds, struct ath_rc_series rcs[],
			       int txok)
{
  90d858:	6c1004        	entry	a1, 32
  90d85b:	da30      	mov.n	a10, a3
	WMI_TXSTATUS_EVENT *txs;

	if (sc->sc_tx_draining)
  90d85d:	272249        	l32i	a7, a2, 0x124
  90d860:	136a66        	l32r	a3, 8e81f8 <memset+0x13b0>
}

void ath_tx_status_update_aggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
			       struct ath_tx_desc *ds, struct ath_rc_series rcs[],
			       int txok)
{
  90d863:	db50      	mov.n	a11, a5
	WMI_TXSTATUS_EVENT *txs;

	if (sc->sc_tx_draining)
  90d865:	037701        	and	a7, a7, a3
  90d868:	65708a        	bnez	a7, 90d8f6 <ath_tx_status_update_aggr+0x9e>
{
	WMI_TXSTATUS_EVENT *txs = NULL;
	int i;

	for (i = 0; i < 2; i++) {
		if (sc->tx_status[i].cnt < HTC_MAX_TX_STATUS) {
  90d86b:	282d16        	addmi	a8, a2, 0x1600
  90d86e:	298038        	l8ui	a9, a8, 56
  90d871:	230a0b        	movi	a3, 11
  90d874:	793b08        	bgeu	a3, a9, 90d880 <ath_tx_status_update_aggr+0x28>
  90d877:	27805d        	l8ui	a7, a8, 93
  90d87a:	773378        	bltu	a3, a7, 90d8f6 <ath_tx_status_update_aggr+0x9e>
static WMI_TXSTATUS_EVENT *ath_tx_status_get(struct ath_softc_tgt *sc)
{
	WMI_TXSTATUS_EVENT *txs = NULL;
	int i;

	for (i = 0; i < 2; i++) {
  90d87d:	270a01        	movi	a7, 1

	txs = ath_tx_status_get(sc);
	if (txs == NULL)
		return;

	txs->txstatus[txs->cnt].cookie = bf->bf_cookie;
  90d880:	0d7311        	slli	a3, a7, 3
  90d883:	a739      	add.n	a9, a3, a7
  90d885:	0e9911        	slli	a9, a9, 2
  90d888:	a799      	add.n	a9, a9, a7
  90d88a:	1c6aa9        	l32r	a12, 8e8330 <memset+0x14e8>
  90d88d:	a928      	add.n	a8, a2, a9
  90d88f:	ac88      	add.n	a8, a8, a12
  90d891:	2c8000        	l8ui	a12, a8, 0
  90d894:	0fc811        	slli	a8, a12, 1
  90d897:	ac88      	add.n	a8, a8, a12
  90d899:	a988      	add.n	a8, a8, a9
  90d89b:	196aab        	l32r	a9, 8e8348 <memset+0x1500>
  90d89e:	2ca092        	l8ui	a12, a10, 146
  90d8a1:	a828      	add.n	a8, a2, a8
  90d8a3:	a989      	add.n	a9, a8, a9
  90d8a5:	2c9400        	s8i	a12, a9, 0
	txs->txstatus[txs->cnt].ts_rate = SM(bf->bf_endpt, ATH9K_HTC_TXSTAT_EPID);
  90d8a8:	2aa223        	l32i	a10, a10, 140
  90d8ab:	196aac        	l32r	a9, 8e835c <memset+0x1514>
  90d8ae:	0caa11        	slli	a10, a10, 4
  90d8b1:	a989      	add.n	a9, a8, a9
  90d8b3:	2a9400        	s8i	a10, a9, 0

	if (txok)
  90d8b6:	c86e      	beqz.n	a6, 90d8c8 <ath_tx_status_update_aggr+0x70>
		txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_ACK;
  90d8b8:	196aaa        	l32r	a9, 8e8360 <memset+0x1518>
  90d8bb:	a989      	add.n	a9, a8, a9
  90d8bd:	269000        	l8ui	a6, a9, 0
  90d8c0:	c081      	movi.n	a8, 1
  90d8c2:	086602        	or	a6, a6, a8
  90d8c5:	269400        	s8i	a6, a9, 0

	if (rcs)
  90d8c8:	c9b4      	beqz.n	a11, 90d8e0 <ath_tx_status_update_aggr+0x88>
	WMI_TXSTATUS_EVENT *txs = NULL;
	int i;

	for (i = 0; i < 2; i++) {
		if (sc->tx_status[i].cnt < HTC_MAX_TX_STATUS) {
			txs = &sc->tx_status[i];
  90d8ca:	a73d      	add.n	a13, a3, a7
  90d8cc:	0edd11        	slli	a13, a13, 2
  90d8cf:	166aa9        	l32r	a6, 8e8374 <memset+0x152c>
  90d8d2:	a7dd      	add.n	a13, a13, a7
  90d8d4:	a6dd      	add.n	a13, a13, a6

	if (txok)
		txs->txstatus[txs->cnt].ts_flags |= ATH9K_HTC_TXSTAT_ACK;

	if (rcs)
		ath_tx_status_update_rate(sc, rcs, ds->ds_txstat.ts_rate, txs);
  90d8d6:	2c4068        	l8ui	a12, a4, 104
  90d8d9:	ad2d      	add.n	a13, a2, a13
  90d8db:	da20      	mov.n	a10, a2
  90d8dd:	5bfce7        	call8	90cc7c <ath_tx_status_update_rate>

	txs->cnt++;
  90d8e0:	a738      	add.n	a8, a3, a7
  90d8e2:	0e8811        	slli	a8, a8, 2
  90d8e5:	a787      	add.n	a7, a8, a7
  90d8e7:	a722      	add.n	a2, a2, a7
  90d8e9:	176aa9        	l32r	a7, 8e8390 <memset+0x1548>
  90d8ec:	a722      	add.n	a2, a2, a7
  90d8ee:	232000        	l8ui	a3, a2, 0
  90d8f1:	b133      	addi.n	a3, a3, 1
  90d8f3:	232400        	s8i	a3, a2, 0
  90d8f6:	d10f      	retw.n

0090d8f8 <ath_tx_status_send>:
}

void ath_tx_status_send(struct ath_softc_tgt *sc)
{
  90d8f8:	6c1004        	entry	a1, 32
	int i;

	if (sc->sc_tx_draining)
  90d8fb:	242249        	l32i	a4, a2, 0x124
  90d8fe:	136a66        	l32r	a3, 8e8298 <memset+0x1450>
  90d901:	034401        	and	a4, a4, a3
  90d904:	cf44      	bnez.n	a4, 90d93c <ath_tx_status_send+0x44>
		return;

	for (i = 0; i < 2; i++) {
		if (sc->tx_status[i].cnt) {
  90d906:	232d16        	addmi	a3, a2, 0x1600
  90d909:	283038        	l8ui	a8, a3, 56
  90d90c:	c980      	beqz.n	a8, 90d920 <ath_tx_status_send+0x28>
			wmi_event(sc->tgt_wmi_handle, WMI_TXSTATUS_EVENTID,
  90d90e:	1c6aa9        	l32r	a12, 8e83b4 <memset+0x156c>
  90d911:	1b6aad        	l32r	a11, 8e83c8 <memset+0x1580>
  90d914:	8a23      	l32i.n	a10, a2, 12
  90d916:	c2d5      	movi.n	a13, 37
  90d918:	ac2c      	add.n	a12, a2, a12
  90d91a:	5bea63        	call8	9082a8 <wmi_event>
				  &sc->tx_status[i], sizeof(WMI_TXSTATUS_EVENT));
			/* FIXME: Handle failures. */
			sc->tx_status[i].cnt = 0;
  90d91d:	243438        	s8i	a4, a3, 56

	if (sc->sc_tx_draining)
		return;

	for (i = 0; i < 2; i++) {
		if (sc->tx_status[i].cnt) {
  90d920:	24305d        	l8ui	a4, a3, 93
  90d923:	c945      	beqz.n	a4, 90d93c <ath_tx_status_send+0x44>
			wmi_event(sc->tgt_wmi_handle, WMI_TXSTATUS_EVENTID,
  90d925:	1c6aae        	l32r	a12, 8e83e0 <memset+0x1598>
  90d928:	8a23      	l32i.n	a10, a2, 12
  90d92a:	1b6aad        	l32r	a11, 8e83e0 <memset+0x1598>
  90d92d:	0c2c08        	add	a12, a2, a12
  90d930:	2d0a25        	movi	a13, 37
				  &sc->tx_status[i], sizeof(WMI_TXSTATUS_EVENT));
			/* FIXME: Handle failures. */
			sc->tx_status[i].cnt = 0;
  90d933:	220a00        	movi	a2, 0
	if (sc->sc_tx_draining)
		return;

	for (i = 0; i < 2; i++) {
		if (sc->tx_status[i].cnt) {
			wmi_event(sc->tgt_wmi_handle, WMI_TXSTATUS_EVENTID,
  90d936:	5bea5c        	call8	9082a8 <wmi_event>
				  &sc->tx_status[i], sizeof(WMI_TXSTATUS_EVENT));
			/* FIXME: Handle failures. */
			sc->tx_status[i].cnt = 0;
  90d939:	22345d        	s8i	a2, a3, 93
  90d93c:	d10f      	retw.n
	...

0090d940 <ATH_SKB_2_WH>:
		}
	}
}

static struct ieee80211_frame* ATH_SKB2_WH(adf_nbuf_t skb)
{
  90d940:	6c1006        	entry	a1, 48
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  90d943:	da20      	mov.n	a10, a2
  90d945:	dc10      	mov.n	a12, a1
  90d947:	b41b      	addi.n	a11, a1, 4
  90d949:	5be4cf        	call8	906c88 <__adf_nbuf_peek_header>
	a_uint8_t *anbdata;
	a_uint32_t anblen;

	adf_nbuf_peek_header(skb, &anbdata, &anblen);
	return((struct ieee80211_frame *)anbdata);
}
  90d94c:	8211      	l32i.n	a2, a1, 4
  90d94e:	d10f      	retw.n

0090d950 <ath_tx_set_retry$isra$12>:
		INCR(tid->seq_start, IEEE80211_SEQ_MAX);
		INCR(tid->baw_head, ATH_TID_MAX_BUFS);
	}
}

static void ath_tx_set_retry(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
  90d950:	6c1004        	entry	a1, 32
{
	struct ieee80211_frame *wh;

	__stats(sc, txaggr_retries);
  90d953:	8820      	l32i.n	a8, a2, 0

	bf->bf_isretried = 1;
	bf->bf_retries ++;
	wh = ATH_SKB_2_WH(bf->bf_skb);
  90d955:	8a38      	l32i.n	a10, a3, 32

static void ath_tx_set_retry(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ieee80211_frame *wh;

	__stats(sc, txaggr_retries);
  90d957:	b188      	addi.n	a8, a8, 1
  90d959:	9820      	s32i.n	a8, a2, 0

	bf->bf_isretried = 1;
  90d95b:	283087        	l8ui	a8, a3, 135
  90d95e:	c120      	movi.n	a2, 16
  90d960:	028802        	or	a8, a8, a2
  90d963:	283487        	s8i	a8, a3, 135
	bf->bf_retries ++;
  90d966:	283086        	l8ui	a8, a3, 134
	wh = ATH_SKB_2_WH(bf->bf_skb);
	wh->i_fc[1] |= IEEE80211_FC1_RETRY;
  90d969:	c028      	movi.n	a2, 8
	struct ieee80211_frame *wh;

	__stats(sc, txaggr_retries);

	bf->bf_isretried = 1;
	bf->bf_retries ++;
  90d96b:	288c01        	addi	a8, a8, 1
  90d96e:	283486        	s8i	a8, a3, 134
	wh = ATH_SKB_2_WH(bf->bf_skb);
  90d971:	5bfff3        	call8	90d940 <ATH_SKB_2_WH>
	wh->i_fc[1] |= IEEE80211_FC1_RETRY;
  90d974:	23a001        	l8ui	a3, a10, 1
  90d977:	023302        	or	a3, a3, a2
  90d97a:	23a401        	s8i	a3, a10, 1
  90d97d:	d10f      	retw.n
	...

0090d980 <ath_tx_retry_subframe$isra$14>:
	ath_update_aggr_stats(sc, ds, nframes, nbad);
	ath_rate_tx_complete(sc, an, ds, rcs, nframes, nbad);
}

static void
ath_tx_retry_subframe(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
  90d980:	6c1006        	entry	a1, 48
{

	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
	struct ath_tx_desc *ds = NULL;
	struct ath_hal *ah = sc->sc_ah;
  90d983:	262d05        	addmi	a6, a2, 0x500
  90d986:	876b      	l32i.n	a7, a6, 44
	int i = 0;

	__stats(sc, txaggr_compretries);
  90d988:	262263        	l32i	a6, a2, 0x18c
static void
ath_tx_retry_subframe(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
		      ath_tx_bufhead *bf_q, struct ath_tx_buf **bar)
{

	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
  90d98b:	8d34      	l32i.n	a13, a3, 16
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
	struct ath_tx_desc *ds = NULL;
	struct ath_hal *ah = sc->sc_ah;
	int i = 0;

	__stats(sc, txaggr_compretries);
  90d98d:	b166      	addi.n	a6, a6, 1
ath_tx_retry_subframe(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
		      ath_tx_bufhead *bf_q, struct ath_tx_buf **bar)
{

	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90d98f:	2c304d        	l8ui	a12, a3, 77
	struct ath_hal *ah = sc->sc_ah;
	int i = 0;

	__stats(sc, txaggr_compretries);

	for(ds = bf->bf_desc, i = 0; i < bf->bf_dmamap_info.nsegs; ds++, i++) {
  90d992:	c080      	movi.n	a8, 0
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
	struct ath_tx_desc *ds = NULL;
	struct ath_hal *ah = sc->sc_ah;
	int i = 0;

	__stats(sc, txaggr_compretries);
  90d994:	262663        	s32i	a6, a2, 0x18c

	for(ds = bf->bf_desc, i = 0; i < bf->bf_dmamap_info.nsegs; ds++, i++) {
  90d997:	2e0a88        	movi	a14, 136
  90d99a:	863c      	l32i.n	a6, a3, 48
  90d99c:	600032        	j	90d9d2 <ath_tx_retry_subframe$isra$14+0x52>
  90d99f:	002972        	excw
		ah->ah_clr11nAggr(ds);
  90d9a2:	14da60        	l32r	a4, 904324 <memset+0x1d4dc>
  90d9a5:	9812      	s32i.n	a8, a1, 8
  90d9a7:	9c11      	s32i.n	a12, a1, 4
  90d9a9:	9d10      	s32i.n	a13, a1, 0
  90d9ab:	9e13      	s32i.n	a14, a1, 12
  90d9ad:	0b9000        	callx8	a9
		ah->ah_set11nBurstDuration(ds, 0);
  90d9b0:	297215        	l32i	a9, a7, 84
  90d9b3:	066a02        	or	a10, a6, a6
  90d9b6:	2b0a00        	movi	a11, 0
  90d9b9:	0b9000        	callx8	a9
		ah->ah_set11nVirtualMoreFrag(ds, 0);
  90d9bc:	297216        	l32i	a9, a7, 88
  90d9bf:	da60      	mov.n	a10, a6
  90d9c1:	c0b0      	movi.n	a11, 0
  90d9c3:	0b9000        	callx8	a9
	struct ath_hal *ah = sc->sc_ah;
	int i = 0;

	__stats(sc, txaggr_compretries);

	for(ds = bf->bf_desc, i = 0; i < bf->bf_dmamap_info.nsegs; ds++, i++) {
  90d9c6:	8e13      	l32i.n	a14, a1, 12
  90d9c8:	8812      	l32i.n	a8, a1, 8
  90d9ca:	8d10      	l32i.n	a13, a1, 0
  90d9cc:	8c11      	l32i.n	a12, a1, 4
  90d9ce:	ae66      	add.n	a6, a6, a14
  90d9d0:	b188      	addi.n	a8, a8, 1
  90d9d2:	8931      	l32i.n	a9, a3, 4
  90d9d4:	7983c8        	bltu	a8, a9, 90d9a0 <ath_tx_retry_subframe$isra$14+0x20>
		ah->ah_clr11nAggr(ds);
		ah->ah_set11nBurstDuration(ds, 0);
		ah->ah_set11nVirtualMoreFrag(ds, 0);
	}

	if (bf->bf_retries >= OWLMAX_RETRIES) {
  90d9d7:	263086        	l8ui	a6, a3, 134
  90d9da:	c089      	movi.n	a8, 9
  90d9dc:	768b3e        	bgeu	a8, a6, 90da1e <ath_tx_retry_subframe$isra$14+0x9e>
ath_tx_retry_subframe(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
		      ath_tx_bufhead *bf_q, struct ath_tx_buf **bar)
{

	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90d9df:	0cca11        	slli	a10, a12, 4
		ah->ah_set11nBurstDuration(ds, 0);
		ah->ah_set11nVirtualMoreFrag(ds, 0);
	}

	if (bf->bf_retries >= OWLMAX_RETRIES) {
		__stats(sc, txaggr_xretries);
  90d9e2:	242274        	l32i	a4, a2, 0x1d0
ath_tx_retry_subframe(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
		      ath_tx_bufhead *bf_q, struct ath_tx_buf **bar)
{

	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90d9e5:	0caa0c        	sub	a10, a10, a12
		ah->ah_set11nVirtualMoreFrag(ds, 0);
	}

	if (bf->bf_retries >= OWLMAX_RETRIES) {
		__stats(sc, txaggr_xretries);
		ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90d9e8:	2b3123        	l16ui	a11, a3, 70
ath_tx_retry_subframe(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
		      ath_tx_bufhead *bf_q, struct ath_tx_buf **bar)
{

	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90d9eb:	0eaa11        	slli	a10, a10, 2
		ah->ah_set11nBurstDuration(ds, 0);
		ah->ah_set11nVirtualMoreFrag(ds, 0);
	}

	if (bf->bf_retries >= OWLMAX_RETRIES) {
		__stats(sc, txaggr_xretries);
  90d9ee:	b144      	addi.n	a4, a4, 1
ath_tx_retry_subframe(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
		      ath_tx_bufhead *bf_q, struct ath_tx_buf **bar)
{

	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90d9f0:	2aac24        	addi	a10, a10, 36
		ah->ah_set11nVirtualMoreFrag(ds, 0);
	}

	if (bf->bf_retries >= OWLMAX_RETRIES) {
		__stats(sc, txaggr_xretries);
		ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90d9f3:	aada      	add.n	a10, a13, a10
		ah->ah_set11nBurstDuration(ds, 0);
		ah->ah_set11nVirtualMoreFrag(ds, 0);
	}

	if (bf->bf_retries >= OWLMAX_RETRIES) {
		__stats(sc, txaggr_xretries);
  90d9f5:	242674        	s32i	a4, a2, 0x1d0
		ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90d9f8:	0b4b14        	srli	a11, a11, 4
  90d9fb:	5bfd4f        	call8	90cf38 <ath_tx_update_baw>
		ath_tx_status_update_aggr(sc, bf, bf->bf_lastds, NULL, 0);
  90d9fe:	c0e0      	movi.n	a14, 0
  90da00:	8c3e      	l32i.n	a12, a3, 56
  90da02:	dde0      	mov.n	a13, a14
  90da04:	db30      	mov.n	a11, a3
  90da06:	022a02        	or	a10, a2, a2
  90da09:	5bff93        	call8	90d858 <ath_tx_status_update_aggr>

		if (!*bar)
  90da0c:	8450      	l32i.n	a4, a5, 0
  90da0e:	cc42      	bnez.n	a4, 90da14 <ath_tx_retry_subframe$isra$14+0x94>
			*bar = bf;
  90da10:	9350      	s32i.n	a3, a5, 0
  90da12:	d10f      	retw.n
		else
			ath_tx_freebuf(sc, bf);
  90da14:	db30      	mov.n	a11, a3
  90da16:	022a02        	or	a10, a2, a2
  90da19:	5bfecd        	call8	90d550 <ath_tx_freebuf>
  90da1c:	d10f      	retw.n
		return;
	}

	if (!bf->bf_next) {
  90da1e:	853b      	l32i.n	a5, a3, 44
  90da20:	cd55      	bnez.n	a5, 90da39 <ath_tx_retry_subframe$isra$14+0xb9>
		__stats(sc, txaggr_errlast);
  90da22:	252267        	l32i	a5, a2, 0x19c
		bf = ath_buf_toggle(sc, bf, 1);
  90da25:	db30      	mov.n	a11, a3
			ath_tx_freebuf(sc, bf);
		return;
	}

	if (!bf->bf_next) {
		__stats(sc, txaggr_errlast);
  90da27:	b155      	addi.n	a5, a5, 1
  90da29:	252667        	s32i	a5, a2, 0x19c
		bf = ath_buf_toggle(sc, bf, 1);
  90da2c:	c0c1      	movi.n	a12, 1
  90da2e:	022a02        	or	a10, a2, a2
  90da31:	5bfe73        	call8	90d400 <ath_buf_toggle>
  90da34:	d3a0      	mov.n	a3, a10
  90da36:	600012        	j	90da4c <ath_tx_retry_subframe$isra$14+0xcc>
	} else
		bf->bf_lastds = &(bf->bf_descarr[bf->bf_dmamap_info.nsegs - 1]);
  90da39:	0c9811        	slli	a8, a9, 4
  90da3c:	a988      	add.n	a8, a8, a9
  90da3e:	0d8811        	slli	a8, a8, 3
  90da41:	25fa78        	movi	a5, -136
  90da44:	863d      	l32i.n	a6, a3, 52
  90da46:	a588      	add.n	a8, a8, a5
  90da48:	a868      	add.n	a8, a6, a8
  90da4a:	983e      	s32i.n	a8, a3, 56

	ath_tx_set_retry(sc, bf);
  90da4c:	2a1a80        	movi	a10, 0x180
  90da4f:	db30      	mov.n	a11, a3
  90da51:	aa2a      	add.n	a10, a2, a10
	asf_tailq_insert_tail(bf_q, bf, bf_list);
  90da53:	c020      	movi.n	a2, 0
		__stats(sc, txaggr_errlast);
		bf = ath_buf_toggle(sc, bf, 1);
	} else
		bf->bf_lastds = &(bf->bf_descarr[bf->bf_dmamap_info.nsegs - 1]);

	ath_tx_set_retry(sc, bf);
  90da55:	5bffbe        	call8	90d950 <ath_tx_set_retry$isra$12>
	asf_tailq_insert_tail(bf_q, bf, bf_list);
  90da58:	9239      	s32i.n	a2, a3, 36
  90da5a:	8240      	l32i.n	a2, a4, 0
  90da5c:	923a      	s32i.n	a2, a3, 40
  90da5e:	9320      	s32i.n	a3, a2, 0
  90da60:	233c24        	addi	a3, a3, 36
  90da63:	9340      	s32i.n	a3, a4, 0
  90da65:	d10f      	retw.n
	...

0090da68 <ath_tx_comp_aggr_error>:
}

static void
ath_tx_comp_aggr_error(struct ath_softc_tgt *sc, struct ath_tx_buf *bf,
		       ath_atx_tid_t *tid)
{
  90da68:	6c1020        	entry	a1, 0x100


	struct ath_tx_desc lastds;
	struct ath_tx_desc *ds = &lastds;
	struct ath_rc_series rcs[4];
	struct ath_tx_buf *bar = NULL;
  90da6b:	c050      	movi.n	a5, 0
  90da6d:	251630        	s32i	a5, a1, 192
	struct ath_tx_buf *bf_next;
	int nframes = bf->bf_nframes;
	ath_tx_bufhead bf_q;
	struct ath_txq *txq;

	asf_tailq_init(&bf_q);
  90da70:	25162e        	s32i	a5, a1, 184
 * @param[in] size    buffer size
 */
static inline void
adf_os_mem_copy(void *dst, const void *src, adf_os_size_t size)
{
    __adf_os_mem_copy(dst, src, size);
  90da73:	8b3e      	l32i.n	a11, a3, 56
  90da75:	250ab8        	movi	a5, 184
  90da78:	051508        	add	a5, a1, a5
  90da7b:	2c0a88        	movi	a12, 136
  90da7e:	011a02        	or	a10, a1, a1
  90da81:	25162f        	s32i	a5, a1, 188
	struct ath_tx_desc lastds;
	struct ath_tx_desc *ds = &lastds;
	struct ath_rc_series rcs[4];
	struct ath_tx_buf *bar = NULL;
	struct ath_tx_buf *bf_next;
	int nframes = bf->bf_nframes;
  90da84:	26304c        	l8ui	a6, a3, 76
	ath_tx_bufhead bf_q;
	struct ath_txq *txq;

	asf_tailq_init(&bf_q);
	txq = bf->bf_txq;
  90da87:	273220        	l32i	a7, a3, 128
  90da8a:	5bfcdc        	call8	90cdfc <__adf_os_mem_copy>
  90da8d:	2a0a88        	movi	a10, 136
  90da90:	2c0a30        	movi	a12, 48
  90da93:	2b3c50        	addi	a11, a3, 80
  90da96:	0a1a08        	add	a10, a1, a10
  90da99:	5bfcd8        	call8	90cdfc <__adf_os_mem_copy>
	adf_os_mem_copy(ds, bf->bf_lastds, sizeof (struct ath_tx_desc));
	adf_os_mem_copy(rcs, bf->bf_rcs, sizeof(rcs));

	while (bf) {
		bf_next = bf->bf_next;
		ath_tx_retry_subframe(sc, bf, &bf_q, &bar);
  90da9c:	b455      	addi.n	a5, a5, 4

	adf_os_mem_copy(ds, bf->bf_lastds, sizeof (struct ath_tx_desc));
	adf_os_mem_copy(rcs, bf->bf_rcs, sizeof(rcs));

	while (bf) {
		bf_next = bf->bf_next;
  90da9e:	883b      	l32i.n	a8, a3, 44
		ath_tx_retry_subframe(sc, bf, &bf_q, &bar);
  90daa0:	2d0ac0        	movi	a13, 192
  90daa3:	db30      	mov.n	a11, a3
  90daa5:	a1dd      	add.n	a13, a13, a1
  90daa7:	dc50      	mov.n	a12, a5
  90daa9:	da20      	mov.n	a10, a2
  90daab:	281634        	s32i	a8, a1, 208
  90daae:	5bffb4        	call8	90d980 <ath_tx_retry_subframe$isra$14>
  90dab1:	281234        	l32i	a8, a1, 208
  90dab4:	088302        	or	a3, a8, a8
	txq = bf->bf_txq;

	adf_os_mem_copy(ds, bf->bf_lastds, sizeof (struct ath_tx_desc));
	adf_os_mem_copy(rcs, bf->bf_rcs, sizeof(rcs));

	while (bf) {
  90dab7:	658fe3        	bnez	a8, 90da9e <ath_tx_comp_aggr_error+0x36>
		bf_next = bf->bf_next;
		ath_tx_retry_subframe(sc, bf, &bf_q, &bar);
		bf = bf_next;
	}

	ath_update_aggr_stats(sc, ds, nframes, nframes);
  90daba:	2e1071        	l8ui	a14, a1, 113
  90dabd:	2d1070        	l8ui	a13, a1, 112
  90dac0:	2c1067        	l8ui	a12, a1, 103
  90dac3:	2b1066        	l8ui	a11, a1, 102
  90dac6:	022a02        	or	a10, a2, a2
  90dac9:	5bfd54        	call8	90d01c <ath_update_aggr_stats$isra$5>
	ath_rate_tx_complete(sc, tid->an, ds, rcs, nframes, nframes);
  90dacc:	2d0a88        	movi	a13, 136
  90dacf:	8b4e      	l32i.n	a11, a4, 56
  90dad1:	dc10      	mov.n	a12, a1
  90dad3:	df60      	mov.n	a15, a6
  90dad5:	de60      	mov.n	a14, a6
  90dad7:	0d1d08        	add	a13, a1, a13
  90dada:	022a02        	or	a10, a2, a2
  90dadd:	5bfca7        	call8	90cd7c <ath_rate_tx_complete>

	if (bar) {
  90dae0:	2c1230        	l32i	a12, a1, 192
  90dae3:	c8c5      	beqz.n	a12, 90daec <ath_tx_comp_aggr_error+0x84>
		ath_bar_tx(sc, tid, bar);
  90dae5:	db40      	mov.n	a11, a4
  90dae7:	da20      	mov.n	a10, a2
  90dae9:	5bfeba        	call8	90d5d4 <ath_bar_tx>
	}

	if (!asf_tailq_empty(&bf_q)) {
  90daec:	23122e        	l32i	a3, a1, 184
  90daef:	ca3a      	beqz.n	a3, 90db1d <ath_tx_comp_aggr_error+0xb5>
		__stats(sc, txaggr_prepends);
  90daf1:	232264        	l32i	a3, a2, 0x190
  90daf4:	b133      	addi.n	a3, a3, 1
  90daf6:	232664        	s32i	a3, a2, 0x190
		TAILQ_INSERTQ_HEAD(&tid->buf_q, &bf_q, bf_list);
  90daf9:	834b      	l32i.n	a3, a4, 44
  90dafb:	22122f        	l32i	a2, a1, 188
  90dafe:	c837      	beqz.n	a3, 90db09 <ath_tx_comp_aggr_error+0xa1>
  90db00:	9320      	s32i.n	a3, a2, 0
  90db02:	834b      	l32i.n	a3, a4, 44
  90db04:	923a      	s32i.n	a2, a3, 40
  90db06:	600001        	j	90db0b <ath_tx_comp_aggr_error+0xa3>
  90db09:	924c      	s32i.n	a2, a4, 48
  90db0b:	22122e        	l32i	a2, a1, 184
  90db0e:	234c2c        	addi	a3, a4, 44
  90db11:	924b      	s32i.n	a2, a4, 44
  90db13:	932a      	s32i.n	a3, a2, 40
		ath_tgt_tx_enqueue(txq, tid);
  90db15:	db40      	mov.n	a11, a4
  90db17:	2a7c1c        	addi	a10, a7, 28
  90db1a:	5bfd37        	call8	90cff8 <ath_tgt_tx_enqueue$isra$3>
  90db1d:	d10f      	retw.n
	...

0090db20 <ath_tgt_tid_drain>:
	return((struct ieee80211_frame *)anbdata);
}

void
ath_tgt_tid_drain(struct ath_softc_tgt *sc, struct ath_atx_tid *tid)
{
  90db20:	6c1004        	entry	a1, 32
	struct ath_tx_buf *bf;

	while (!asf_tailq_empty(&tid->buf_q)) {
  90db23:	600015        	j	90db3c <ath_tgt_tid_drain+0x1c>
		TAILQ_DEQ(&tid->buf_q, bf, bf_list);
  90db26:	88b9      	l32i.n	a8, a11, 36
  90db28:	89ba      	l32i.n	a9, a11, 40
  90db2a:	c883      	beqz.n	a8, 90db31 <ath_tgt_tid_drain+0x11>
  90db2c:	998a      	s32i.n	a9, a8, 40
  90db2e:	600001        	j	90db33 <ath_tgt_tid_drain+0x13>
  90db31:	993c      	s32i.n	a9, a3, 48
  90db33:	89ba      	l32i.n	a9, a11, 40
		ath_tx_freebuf(sc, bf);
  90db35:	da20      	mov.n	a10, a2
ath_tgt_tid_drain(struct ath_softc_tgt *sc, struct ath_atx_tid *tid)
{
	struct ath_tx_buf *bf;

	while (!asf_tailq_empty(&tid->buf_q)) {
		TAILQ_DEQ(&tid->buf_q, bf, bf_list);
  90db37:	9890      	s32i.n	a8, a9, 0
		ath_tx_freebuf(sc, bf);
  90db39:	5bfe85        	call8	90d550 <ath_tx_freebuf>
void
ath_tgt_tid_drain(struct ath_softc_tgt *sc, struct ath_atx_tid *tid)
{
	struct ath_tx_buf *bf;

	while (!asf_tailq_empty(&tid->buf_q)) {
  90db3c:	8b3b      	l32i.n	a11, a3, 44
  90db3e:	65bfe4        	bnez	a11, 90db26 <ath_tgt_tid_drain+0x6>
		TAILQ_DEQ(&tid->buf_q, bf, bf_list);
		ath_tx_freebuf(sc, bf);
	}

	tid->seq_next = tid->seq_start;
  90db41:	283102        	l16ui	a8, a3, 4
  90db44:	283503        	s16i	a8, a3, 6
	tid->baw_tail = tid->baw_head;
  90db47:	8833      	l32i.n	a8, a3, 12
  90db49:	9834      	s32i.n	a8, a3, 16
  90db4b:	d10f      	retw.n
  90db4d:	000000        	ill

0090db50 <ath_tgt_tx_prepare>:
	return  bf;
}

struct ath_tx_buf* ath_tgt_tx_prepare(struct ath_softc_tgt *sc,
				   adf_nbuf_t skb, ath_data_hdr_t *dh)
{
  90db50:	6c1006        	entry	a1, 48
	struct ath_tx_buf *bf;
	struct ieee80211_node_target *ni;
	struct ath_atx_tid *tid;

	ni = ath_tgt_find_node(sc, dh->ni_index);
  90db53:	264001        	l8ui	a6, a4, 1
							a_int32_t node_index)
{
	struct ath_node_target *an;
	struct ieee80211_node_target *ni;

	if (node_index > TARGET_NODE_MAX)
  90db56:	c078      	movi.n	a7, 8
	return  bf;
}

struct ath_tx_buf* ath_tgt_tx_prepare(struct ath_softc_tgt *sc,
				   adf_nbuf_t skb, ath_data_hdr_t *dh)
{
  90db58:	d520      	mov.n	a5, a2
	struct ieee80211_node_target *ni;
	struct ath_atx_tid *tid;

	ni = ath_tgt_find_node(sc, dh->ni_index);
	if (ni == NULL)
		return NULL;
  90db5a:	c020      	movi.n	a2, 0
							a_int32_t node_index)
{
	struct ath_node_target *an;
	struct ieee80211_node_target *ni;

	if (node_index > TARGET_NODE_MAX)
  90db5c:	767a02        	bge	a7, a6, 90db62 <ath_tgt_tx_prepare+0x12>
  90db5f:	600279        	j	90dddc <ath_tgt_tx_prepare+0x28c>
	  	return NULL;

	an = &sc->sc_sta[node_index];
	ni = &an->ni;
  90db62:	0a6811        	slli	a8, a6, 6
  90db65:	a688      	add.n	a8, a8, a6
  90db67:	0f8811        	slli	a8, a8, 1
  90db6a:	a688      	add.n	a8, a8, a6
  90db6c:	0e8811        	slli	a8, a8, 2
  90db6f:	265a38        	movi	a6, 0x538
  90db72:	a686      	add.n	a6, a8, a6

	if (an->an_valid) {
  90db74:	227a3c        	movi	a2, 0x73c
  90db77:	a858      	add.n	a8, a5, a8
  90db79:	a282      	add.n	a2, a8, a2
  90db7b:	272000        	l8ui	a7, a2, 0

	if (node_index > TARGET_NODE_MAX)
	  	return NULL;

	an = &sc->sc_sta[node_index];
	ni = &an->ni;
  90db7e:	a656      	add.n	a6, a5, a6

	if (an->an_valid) {
  90db80:	007732        	sext	a7, a7, 7
	struct ieee80211_node_target *ni;
	struct ath_atx_tid *tid;

	ni = ath_tgt_find_node(sc, dh->ni_index);
	if (ni == NULL)
		return NULL;
  90db83:	d270      	mov.n	a2, a7
	  	return NULL;

	an = &sc->sc_sta[node_index];
	ni = &an->ni;

	if (an->an_valid) {
  90db85:	647253        	beqz	a7, 90dddc <ath_tgt_tx_prepare+0x28c>
		if (ni->ni_vap == NULL) {
  90db88:	225a58        	movi	a2, 0x558
  90db8b:	a288      	add.n	a8, a8, a2
  90db8d:	8280      	l32i.n	a2, a8, 0
  90db8f:	c071      	movi.n	a7, 1
  90db91:	c080      	movi.n	a8, 0
  90db93:	027838        	moveqz	a8, a7, a2
	struct ath_tx_buf *bf;
	struct ieee80211_node_target *ni;
	struct ath_atx_tid *tid;

	ni = ath_tgt_find_node(sc, dh->ni_index);
	if (ni == NULL)
  90db96:	080247        	extui	a2, a8, 0, 8
  90db99:	65223d        	bnez	a2, 90ddda <ath_tgt_tx_prepare+0x28a>
  90db9c:	067238        	moveqz	a2, a7, a6
  90db9f:	652237        	bnez	a2, 90ddda <ath_tgt_tx_prepare+0x28a>
		return NULL;

	tid = ATH_AN_2_TID(ATH_NODE_TARGET(ni), dh->tidno);
  90dba2:	284003        	l8ui	a8, a4, 3
	if (tid->flag & TID_REINITIALIZE) {
  90dba5:	0c8711        	slli	a7, a8, 4
  90dba8:	08770c        	sub	a7, a7, a8
  90dbab:	0e7711        	slli	a7, a7, 2
  90dbae:	a767      	add.n	a7, a6, a7
  90dbb0:	27705a        	l8ui	a7, a7, 90
  90dbb3:	7d770d        	bbci	a7, 29, 90dbc4 <ath_tgt_tx_prepare+0x74>
		adf_os_print("drop frame due to TID reinit\n");
  90dbb6:	1368bf        	l32r	a3, 8e7eb4 <memset+0x106c>
  90dbb9:	1a6aaf        	l32r	a10, 8e8678 <memset+0x1830>
  90dbbc:	233212        	l32i	a3, a3, 72
  90dbbf:	0b3000        	callx8	a3
		return NULL;
  90dbc2:	d10f      	retw.n

static struct ath_tx_buf* ath_tx_buf_alloc(struct ath_softc_tgt *sc)
{
	struct ath_tx_buf *bf = NULL;

	bf = asf_tailq_first(&sc->sc_txbuf);
  90dbc4:	2252f0        	l32i	a2, a5, 0x3c0
	if (bf !=  NULL) {
  90dbc7:	ca28      	beqz.n	a2, 90dbf3 <ath_tgt_tx_prepare+0xa3>
 * @param[in] size  buffer size
 */
static inline void
adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
{
    __adf_os_mem_set(buf, b, size);
  90dbc9:	c4bc      	movi.n	a11, 76
  90dbcb:	2a2c3c        	addi	a10, a2, 60
  90dbce:	5bfd7c        	call8	90d1c0 <__adf_os_mem_set$constprop$19>
		adf_os_mem_set(&bf->bf_state, 0, sizeof(struct ath_buf_state));
		asf_tailq_remove(&sc->sc_txbuf, bf, bf_list);
  90dbd1:	8729      	l32i.n	a7, a2, 36
  90dbd3:	882a      	l32i.n	a8, a2, 40
  90dbd5:	c873      	beqz.n	a7, 90dbdc <ath_tgt_tx_prepare+0x8c>
  90dbd7:	987a      	s32i.n	a8, a7, 40
  90dbd9:	600002        	j	90dbdf <ath_tgt_tx_prepare+0x8f>
  90dbdc:	2856f1        	s32i	a8, a5, 0x3c4
  90dbdf:	882a      	l32i.n	a8, a2, 40
  90dbe1:	9780      	s32i.n	a7, a8, 0
	if (!bf) {
		__stats(sc, tx_nobufs);
		return NULL;
	}

	bf->bf_tidno = dh->tidno;
  90dbe3:	274003        	l8ui	a7, a4, 3
  90dbe6:	27244d        	s8i	a7, a2, 77
	bf->bf_txq = TID_TO_ACTXQ(bf->bf_tidno);
  90dbe9:	c871      	beqz.n	a7, 90dbee <ath_tgt_tx_prepare+0x9e>
  90dbeb:	697327        	bnei	a7, 3, 90dc16 <ath_tgt_tx_prepare+0xc6>
  90dbee:	c080      	movi.n	a8, 0
  90dbf0:	600039        	j	90dc2d <ath_tgt_tx_prepare+0xdd>
	bf = asf_tailq_first(&sc->sc_txbuf);
	if (bf !=  NULL) {
		adf_os_mem_set(&bf->bf_state, 0, sizeof(struct ath_buf_state));
		asf_tailq_remove(&sc->sc_txbuf, bf, bf_list);
	} else {
		adf_os_assert(0);
  90dbf3:	1368bf        	l32r	a3, 8e7ef0 <memset+0x10a8>
  90dbf6:	1b6ab0        	l32r	a11, 8e86b8 <memset+0x1870>
  90dbf9:	233212        	l32i	a3, a3, 72
  90dbfc:	1a6aa3        	l32r	a10, 8e8688 <memset+0x1840>
  90dbff:	0b3000        	callx8	a3
  90dc02:	136923        	l32r	a3, 8e8090 <memset+0x1248>
  90dc05:	0c0200        	memw
  90dc08:	8330      	l32i.n	a3, a3, 0
		return NULL;
	}

	bf = ath_tx_buf_alloc(sc);
	if (!bf) {
		__stats(sc, tx_nobufs);
  90dc0a:	235277        	l32i	a3, a5, 0x1dc
  90dc0d:	b133      	addi.n	a3, a3, 1
  90dc0f:	235677        	s32i	a3, a5, 0x1dc
		return NULL;
  90dc12:	d10f      	retw.n
  90dc14:	0000b0        	excw
	}

	bf->bf_tidno = dh->tidno;
	bf->bf_txq = TID_TO_ACTXQ(bf->bf_tidno);
  90dc17:	790909        	bne	a0, a9, 90dc24 <ath_tgt_tx_prepare+0xd4>
  90dc1a:	47c081        	excw
  90dc1d:	6e920c        	bltui	a9, 2, 90dc2d <ath_tgt_tx_prepare+0xdd>
  90dc20:	277cfc        	addi	a7, a7, -4
  90dc23:	070747        	extui	a7, a7, 0, 8
  90dc26:	c083      	movi.n	a8, 3
  90dc28:	6f7201        	bgeui	a7, 2, 90dc2d <ath_tgt_tx_prepare+0xdd>
  90dc2b:	c082      	movi.n	a8, 2
  90dc2d:	0e8811        	slli	a8, a8, 2
  90dc30:	288d05        	addmi	a8, a8, 0x500
  90dc33:	a858      	add.n	a8, a5, a8
  90dc35:	8783      	l32i.n	a7, a8, 12
 * @param[in] buf   buf
 */
static inline void
adf_nbuf_queue_add(adf_nbuf_queue_t *head, adf_nbuf_t buf)
{
    __adf_nbuf_queue_add(head, buf);
  90dc37:	db30      	mov.n	a11, a3
  90dc39:	272620        	s32i	a7, a2, 128
	bf->bf_keytype = dh->keytype;
  90dc3c:	274008        	l8ui	a7, a4, 8
  90dc3f:	272485        	s8i	a7, a2, 133
	bf->bf_keyix = dh->keyix;
  90dc42:	274009        	l8ui	a7, a4, 9
  90dc45:	272449        	s8i	a7, a2, 73
	bf->bf_protmode = dh->flags & (IEEE80211_PROT_RTSCTS | IEEE80211_PROT_CTSONLY);
  90dc48:	274007        	l8ui	a7, a4, 7
	bf->bf_node = ni;
  90dc4b:	9624      	s32i.n	a6, a2, 16

	bf->bf_tidno = dh->tidno;
	bf->bf_txq = TID_TO_ACTXQ(bf->bf_tidno);
	bf->bf_keytype = dh->keytype;
	bf->bf_keyix = dh->keyix;
	bf->bf_protmode = dh->flags & (IEEE80211_PROT_RTSCTS | IEEE80211_PROT_CTSONLY);
  90dc4d:	070741        	extui	a7, a7, 0, 2
	bf->bf_node = ni;

	adf_nbuf_queue_add(&bf->bf_skbhead, skb);
  90dc50:	262c14        	addi	a6, a2, 20
  90dc53:	066a02        	or	a10, a6, a6

	bf->bf_tidno = dh->tidno;
	bf->bf_txq = TID_TO_ACTXQ(bf->bf_tidno);
	bf->bf_keytype = dh->keytype;
	bf->bf_keyix = dh->keyix;
	bf->bf_protmode = dh->flags & (IEEE80211_PROT_RTSCTS | IEEE80211_PROT_CTSONLY);
  90dc56:	272484        	s8i	a7, a2, 132
  90dc59:	5be36c        	call8	906a0c <__adf_nbuf_queue_add>
 * @return first buffer in queue
 */
static inline adf_nbuf_t 
adf_nbuf_queue_first(adf_nbuf_queue_t *head)
{
    return (__adf_nbuf_queue_first(head));
  90dc5c:	da60      	mov.n	a10, a6
  90dc5e:	5be416        	call8	906cb8 <__adf_nbuf_queue_first>
  90dc61:	d3a0      	mov.n	a3, a10
 * @return length of the queue
 */
static inline a_uint32_t
adf_nbuf_queue_len(adf_nbuf_queue_t *head)
{
    return __adf_nbuf_queue_len(head);
  90dc63:	da60      	mov.n	a10, a6
  90dc65:	5be412        	call8	906cb0 <__adf_nbuf_queue_len>
	bf->bf_node = ni;

	adf_nbuf_queue_add(&bf->bf_skbhead, skb);
	skb = adf_nbuf_queue_first(&(bf->bf_skbhead));

	if (adf_nbuf_queue_len(&(bf->bf_skbhead)) == 0) {
  90dc68:	cca9      	bnez.n	a10, 90dc75 <ath_tgt_tx_prepare+0x125>
		__stats(sc, tx_noskbs);
  90dc6a:	225276        	l32i	a2, a5, 0x1d8
  90dc6d:	b122      	addi.n	a2, a2, 1
  90dc6f:	225676        	s32i	a2, a5, 0x1d8
  90dc72:	600164        	j	90ddda <ath_tgt_tx_prepare+0x28a>
		return NULL;
	}

	adf_os_assert(skb);
  90dc75:	cd35      	bnez.n	a3, 90dc8e <ath_tgt_tx_prepare+0x13e>
  90dc77:	1768bf        	l32r	a7, 8e7f74 <memset+0x112c>
  90dc7a:	1b6ab1        	l32r	a11, 8e8740 <memset+0x18f8>
  90dc7d:	277212        	l32i	a7, a7, 72
  90dc80:	1a6aa3        	l32r	a10, 8e870c <memset+0x18c4>
  90dc83:	0b7000        	callx8	a7
  90dc86:	176923        	l32r	a7, 8e8114 <memset+0x12cc>
  90dc89:	0c0200        	memw
  90dc8c:	8770      	l32i.n	a7, a7, 0

	bf->bf_skb = skb;
  90dc8e:	9328      	s32i.n	a3, a2, 32
static a_int32_t ath_tgt_txbuf_setup(struct ath_softc_tgt *sc,
				     struct ath_tx_buf *bf,
				     ath_data_hdr_t *dh)

{
	struct ieee80211_frame *wh = ATH_SKB2_WH(bf->bf_skb);
  90dc90:	da30      	mov.n	a10, a3
  90dc92:	5bff2b        	call8	90d940 <ATH_SKB_2_WH>
	a_int32_t retval;
	a_uint32_t flags = adf_os_ntohl(dh->flags);
  90dc95:	284004        	l8ui	a8, a4, 4
  90dc98:	234005        	l8ui	a3, a4, 5
  90dc9b:	088810        	slli	a8, a8, 24
  90dc9e:	003311        	slli	a3, a3, 16
  90dca1:	083802        	or	a8, a3, a8
  90dca4:	234006        	l8ui	a3, a4, 6
static a_int32_t ath_tgt_txbuf_setup(struct ath_softc_tgt *sc,
				     struct ath_tx_buf *bf,
				     ath_data_hdr_t *dh)

{
	struct ieee80211_frame *wh = ATH_SKB2_WH(bf->bf_skb);
  90dca7:	d7a0      	mov.n	a7, a10
	a_int32_t retval;
	a_uint32_t flags = adf_os_ntohl(dh->flags);
  90dca9:	083311        	slli	a3, a3, 8
  90dcac:	083302        	or	a3, a3, a8

static void ath_tgt_tx_seqno_normal(struct ath_tx_buf *bf)
{
	struct ieee80211_node_target *ni = bf->bf_node;
	struct ath_node_target *an = ATH_NODE_TARGET(ni);
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);
  90dcaf:	8a28      	l32i.n	a10, a2, 32
	return bf;
}

static void ath_tgt_tx_seqno_normal(struct ath_tx_buf *bf)
{
	struct ieee80211_node_target *ni = bf->bf_node;
  90dcb1:	282204        	l32i	a8, a2, 16
				     ath_data_hdr_t *dh)

{
	struct ieee80211_frame *wh = ATH_SKB2_WH(bf->bf_skb);
	a_int32_t retval;
	a_uint32_t flags = adf_os_ntohl(dh->flags);
  90dcb4:	244007        	l8ui	a4, a4, 7

static void ath_tgt_tx_seqno_normal(struct ath_tx_buf *bf)
{
	struct ieee80211_node_target *ni = bf->bf_node;
	struct ath_node_target *an = ATH_NODE_TARGET(ni);
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);
  90dcb7:	9810      	s32i.n	a8, a1, 0
  90dcb9:	5bff21        	call8	90d940 <ATH_SKB_2_WH>
	struct ath_atx_tid *tid = ATH_AN_2_TID(an, bf->bf_tidno);

	u_int8_t fragno = (wh->i_seq[0] & 0xf);

	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);
  90dcbc:	8810      	l32i.n	a8, a1, 0
static void ath_tgt_tx_seqno_normal(struct ath_tx_buf *bf)
{
	struct ieee80211_node_target *ni = bf->bf_node;
	struct ath_node_target *an = ATH_NODE_TARGET(ni);
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);
	struct ath_atx_tid *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90dcbe:	2d204d        	l8ui	a13, a2, 77
				     ath_data_hdr_t *dh)

{
	struct ieee80211_frame *wh = ATH_SKB2_WH(bf->bf_skb);
	a_int32_t retval;
	a_uint32_t flags = adf_os_ntohl(dh->flags);
  90dcc1:	034402        	or	a4, a4, a3

	u_int8_t fragno = (wh->i_seq[0] & 0xf);

	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);

	bf->bf_seqno = (tid->seq_next << IEEE80211_SEQ_SEQ_SHIFT);
  90dcc4:	0cdb11        	slli	a11, a13, 4
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);
	struct ath_atx_tid *tid = ATH_AN_2_TID(an, bf->bf_tidno);

	u_int8_t fragno = (wh->i_seq[0] & 0xf);

	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);
  90dcc7:	23810c        	l16ui	a3, a8, 24

	bf->bf_seqno = (tid->seq_next << IEEE80211_SEQ_SEQ_SHIFT);
  90dcca:	0db90c        	sub	a9, a11, a13
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);
	struct ath_atx_tid *tid = ATH_AN_2_TID(an, bf->bf_tidno);

	u_int8_t fragno = (wh->i_seq[0] & 0xf);

	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);
  90dccd:	b133      	addi.n	a3, a3, 1

	bf->bf_seqno = (tid->seq_next << IEEE80211_SEQ_SEQ_SHIFT);
  90dccf:	0e9911        	slli	a9, a9, 2
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);
	struct ath_atx_tid *tid = ATH_AN_2_TID(an, bf->bf_tidno);

	u_int8_t fragno = (wh->i_seq[0] & 0xf);

	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);
  90dcd2:	03034b        	extui	a3, a3, 0, 12

	bf->bf_seqno = (tid->seq_next << IEEE80211_SEQ_SEQ_SHIFT);
  90dcd5:	098908        	add	a9, a8, a9
	struct ieee80211_node_target *ni = bf->bf_node;
	struct ath_node_target *an = ATH_NODE_TARGET(ni);
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);
	struct ath_atx_tid *tid = ATH_AN_2_TID(an, bf->bf_tidno);

	u_int8_t fragno = (wh->i_seq[0] & 0xf);
  90dcd8:	2ca016        	l8ui	a12, a10, 22

	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);
  90dcdb:	23850c        	s16i	a3, a8, 24

	bf->bf_seqno = (tid->seq_next << IEEE80211_SEQ_SEQ_SHIFT);
  90dcde:	239115        	l16ui	a3, a9, 42
	struct ieee80211_node_target *ni = bf->bf_node;
	struct ath_node_target *an = ATH_NODE_TARGET(ni);
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);
	struct ath_atx_tid *tid = ATH_AN_2_TID(an, bf->bf_tidno);

	u_int8_t fragno = (wh->i_seq[0] & 0xf);
  90dce1:	0c0c43        	extui	a12, a12, 0, 4

	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);

	bf->bf_seqno = (tid->seq_next << IEEE80211_SEQ_SEQ_SHIFT);
  90dce4:	0c3311        	slli	a3, a3, 4
  90dce7:	03034f        	extui	a3, a3, 0, 16
  90dcea:	232523        	s16i	a3, a2, 70

	*(u_int16_t *)wh->i_seq = adf_os_cpu_to_le16(bf->bf_seqno);
  90dced:	083e11        	slli	a14, a3, 8
  90dcf0:	038314        	srli	a3, a3, 8
  90dcf3:	03e302        	or	a3, a14, a3
  90dcf6:	030e4f        	extui	a14, a3, 0, 16
  90dcf9:	23a50b        	s16i	a3, a10, 22
	wh->i_seq[0] |= fragno;
  90dcfc:	0e8314        	srli	a3, a14, 8
  90dcff:	03cc02        	or	a12, a12, a3

	if (!(wh->i_fc[1] & IEEE80211_FC1_MORE_FRAG))
  90dd02:	23a001        	l8ui	a3, a10, 1
	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);

	bf->bf_seqno = (tid->seq_next << IEEE80211_SEQ_SEQ_SHIFT);

	*(u_int16_t *)wh->i_seq = adf_os_cpu_to_le16(bf->bf_seqno);
	wh->i_seq[0] |= fragno;
  90dd05:	2ca416        	s8i	a12, a10, 22

	if (!(wh->i_fc[1] & IEEE80211_FC1_MORE_FRAG))
  90dd08:	7d3f08        	bbsi	a3, 29, 90dd14 <ath_tgt_tx_prepare+0x1c4>
		INCR(tid->seq_next, IEEE80211_SEQ_MAX);
  90dd0b:	239115        	l16ui	a3, a9, 42
  90dd0e:	233c01        	addi	a3, a3, 1
  90dd11:	239515        	s16i	a3, a9, 42
  90dd14:	0dbb0c        	sub	a11, a11, a13
  90dd17:	0ebb11        	slli	a11, a11, 2
  90dd1a:	ab88      	add.n	a8, a8, a11
  90dd1c:	238115        	l16ui	a3, a8, 42
	a_uint32_t flags = adf_os_ntohl(dh->flags);

	ath_tgt_tx_seqno_normal(bf);

	bf->bf_txq_add  = ath_tgt_txq_add_ucast;
	bf->bf_hdrlen   = ieee80211_anyhdrsize(wh);
  90dd1f:	077a02        	or	a10, a7, a7

	*(u_int16_t *)wh->i_seq = adf_os_cpu_to_le16(bf->bf_seqno);
	wh->i_seq[0] |= fragno;

	if (!(wh->i_fc[1] & IEEE80211_FC1_MORE_FRAG))
		INCR(tid->seq_next, IEEE80211_SEQ_MAX);
  90dd22:	03034b        	extui	a3, a3, 0, 12
  90dd25:	238515        	s16i	a3, a8, 42
	a_int32_t retval;
	a_uint32_t flags = adf_os_ntohl(dh->flags);

	ath_tgt_tx_seqno_normal(bf);

	bf->bf_txq_add  = ath_tgt_txq_add_ucast;
  90dd28:	136ab2        	l32r	a3, 8e87f0 <memset+0x19a8>
  90dd2b:	232610        	s32i	a3, a2, 64
	bf->bf_hdrlen   = ieee80211_anyhdrsize(wh);
  90dd2e:	5bfc38        	call8	90ce10 <ieee80211_anyhdrsize>
  90dd31:	d3a0      	mov.n	a3, a10
  90dd33:	2a2448        	s8i	a10, a2, 72
 * @return first buffer in queue
 */
static inline adf_nbuf_t 
adf_nbuf_queue_first(adf_nbuf_queue_t *head)
{
    return (__adf_nbuf_queue_first(head));
  90dd36:	066a02        	or	a10, a6, a6
  90dd39:	5be3df        	call8	906cb8 <__adf_nbuf_queue_first>
 * @return The total length of this buf.
 */
static inline adf_os_size_t
adf_nbuf_len(adf_nbuf_t buf)
{
    return (__adf_nbuf_len(buf));
  90dd3c:	5be3ca        	call8	906c68 <__adf_nbuf_len>
	a_int32_t pktlen;

	skb = adf_nbuf_queue_first(&bf->bf_skbhead);
	pktlen = adf_nbuf_len(skb);

	pktlen -= (hdrlen & 3);
  90dd3f:	030341        	extui	a3, a3, 0, 2
  90dd42:	03a30c        	sub	a3, a10, a3
	pktlen += IEEE80211_CRC_LEN;
  90dd45:	b433      	addi.n	a3, a3, 4

	ath_tgt_tx_seqno_normal(bf);

	bf->bf_txq_add  = ath_tgt_txq_add_ucast;
	bf->bf_hdrlen   = ieee80211_anyhdrsize(wh);
	bf->bf_pktlen   = ath_get_pktlen(bf, bf->bf_hdrlen);
  90dd47:	232522        	s16i	a3, a2, 68
	bf->bf_ismcast  = IEEE80211_IS_MULTICAST(wh->i_addr1);
  90dd4a:	237004        	l8ui	a3, a7, 4
}

static a_int32_t ath_key_setup(struct ieee80211_node_target *ni,
			       struct ath_tx_buf *bf)
{
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);
  90dd4d:	8a28      	l32i.n	a10, a2, 32
	ath_tgt_tx_seqno_normal(bf);

	bf->bf_txq_add  = ath_tgt_txq_add_ucast;
	bf->bf_hdrlen   = ieee80211_anyhdrsize(wh);
	bf->bf_pktlen   = ath_get_pktlen(bf, bf->bf_hdrlen);
	bf->bf_ismcast  = IEEE80211_IS_MULTICAST(wh->i_addr1);
  90dd4f:	093611        	slli	a6, a3, 7
  90dd52:	232087        	l8ui	a3, a2, 135
static a_int32_t ath_key_setup(struct ieee80211_node_target *ni,
			       struct ath_tx_buf *bf)
{
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);

	if (!(wh->i_fc[1] & IEEE80211_FC1_WEP)) {
  90dd55:	c470      	movi.n	a7, 64
	ath_tgt_tx_seqno_normal(bf);

	bf->bf_txq_add  = ath_tgt_txq_add_ucast;
	bf->bf_hdrlen   = ieee80211_anyhdrsize(wh);
	bf->bf_pktlen   = ath_get_pktlen(bf, bf->bf_hdrlen);
	bf->bf_ismcast  = IEEE80211_IS_MULTICAST(wh->i_addr1);
  90dd57:	030346        	extui	a3, a3, 0, 7
  90dd5a:	063302        	or	a3, a3, a6
  90dd5d:	232487        	s8i	a3, a2, 135

	if ((retval = ath_key_setup(bf->bf_node, bf)) < 0)
  90dd60:	8624      	l32i.n	a6, a2, 16
}

static a_int32_t ath_key_setup(struct ieee80211_node_target *ni,
			       struct ath_tx_buf *bf)
{
	struct ieee80211_frame *wh = ATH_SKB_2_WH(bf->bf_skb);
  90dd62:	5bfef7        	call8	90d940 <ATH_SKB_2_WH>

	if (!(wh->i_fc[1] & IEEE80211_FC1_WEP)) {
  90dd65:	23a001        	l8ui	a3, a10, 1
  90dd68:	073301        	and	a3, a3, a7
  90dd6b:	cc39      	bnez.n	a3, 90dd78 <ath_tgt_tx_prepare+0x228>
		bf->bf_keytype = HAL_KEY_TYPE_CLEAR;
  90dd6d:	232485        	s8i	a3, a2, 133
		bf->bf_keyix = HAL_TXKEYIX_INVALID;
  90dd70:	c73f      	movi.n	a3, -1
  90dd72:	232449        	s8i	a3, a2, 73
  90dd75:	60002d        	j	90dda6 <ath_tgt_tx_prepare+0x256>
		return 0;
	}

	switch (bf->bf_keytype) {
  90dd78:	2c2085        	l8ui	a12, a2, 133
  90dd7b:	68c209        	beqi	a12, 2, 90dd88 <ath_tgt_tx_prepare+0x238>
  90dd7e:	68c30e        	beqi	a12, 3, 90dd90 <ath_tgt_tx_prepare+0x240>
  90dd81:	69c113        	bnei	a12, 1, 90dd98 <ath_tgt_tx_prepare+0x248>
  90dd84:	600008        	j	90dd90 <ath_tgt_tx_prepare+0x240>
  90dd87:	002321        	excw
	case HAL_KEY_TYPE_WEP:
		bf->bf_pktlen += IEEE80211_WEP_ICVLEN;
		break;
	case HAL_KEY_TYPE_AES:
		bf->bf_pktlen += IEEE80211_WEP_MICLEN;
  90dd8a:	22b833        	excw
  90dd8d:	600004        	j	90dd95 <ath_tgt_tx_prepare+0x245>
		break;
	case HAL_KEY_TYPE_TKIP:
		bf->bf_pktlen += IEEE80211_WEP_ICVLEN;
  90dd90:	232122        	l16ui	a3, a2, 68
  90dd93:	b433      	addi.n	a3, a3, 4
  90dd95:	232522        	s16i	a3, a2, 68
		break;
	default:
		break;
	}

	if (bf->bf_keytype == HAL_KEY_TYPE_AES ||
  90dd98:	23ccfe        	addi	a3, a12, -2
  90dd9b:	030347        	extui	a3, a3, 0, 8
  90dd9e:	6f3204        	bgeui	a3, 2, 90dda6 <ath_tgt_tx_prepare+0x256>
	    bf->bf_keytype == HAL_KEY_TYPE_TKIP)
		ieee80211_tgt_crypto_encap(wh, ni, bf->bf_keytype);
  90dda1:	db60      	mov.n	a11, a6
  90dda3:	5804f2        	call8	90f16c <ieee80211_tgt_crypto_encap>
  90dda6:	232087        	l8ui	a3, a2, 135
	bf->bf_ismcast  = IEEE80211_IS_MULTICAST(wh->i_addr1);

	if ((retval = ath_key_setup(bf->bf_node, bf)) < 0)
		return retval;

	if (flags & ATH_SHORT_PREAMBLE)
  90dda9:	7f4707        	bbci	a4, 31, 90ddb4 <ath_tgt_tx_prepare+0x264>
		bf->bf_shpream = AH_TRUE;
  90ddac:	c440      	movi.n	a4, 64
  90ddae:	043302        	or	a3, a3, a4
  90ddb1:	600005        	j	90ddba <ath_tgt_tx_prepare+0x26a>
	else
		bf->bf_shpream = AH_FALSE;
  90ddb4:	24fabf        	movi	a4, -65
  90ddb7:	043301        	and	a3, a3, a4
  90ddba:	232487        	s8i	a3, a2, 135

	bf->bf_flags = HAL_TXDESC_CLRDMASK;
  90ddbd:	c031      	movi.n	a3, 1
  90ddbf:	232544        	s16i	a3, a2, 136
	adf_os_assert(skb);

	bf->bf_skb = skb;

	ath_tgt_txbuf_setup(sc, bf, dh);
	ath_dma_map(sc, bf);
  90ddc2:	2a1a18        	movi	a10, 0x118
		bf->bf_shpream = AH_TRUE;
	else
		bf->bf_shpream = AH_FALSE;

	bf->bf_flags = HAL_TXDESC_CLRDMASK;
	bf->bf_atype = HAL_PKT_TYPE_NORMAL;
  90ddc5:	c030      	movi.n	a3, 0
	adf_os_assert(skb);

	bf->bf_skb = skb;

	ath_tgt_txbuf_setup(sc, bf, dh);
	ath_dma_map(sc, bf);
  90ddc7:	db20      	mov.n	a11, a2
  90ddc9:	aa5a      	add.n	a10, a5, a10
		bf->bf_shpream = AH_TRUE;
	else
		bf->bf_shpream = AH_FALSE;

	bf->bf_flags = HAL_TXDESC_CLRDMASK;
	bf->bf_atype = HAL_PKT_TYPE_NORMAL;
  90ddcb:	23244a        	s8i	a3, a2, 74
	adf_os_assert(skb);

	bf->bf_skb = skb;

	ath_tgt_txbuf_setup(sc, bf, dh);
	ath_dma_map(sc, bf);
  90ddce:	5bfd86        	call8	90d3e8 <ath_dma_map$isra$8>
	ath_tx_tgt_setds(sc, bf);
  90ddd1:	db20      	mov.n	a11, a2
  90ddd3:	da50      	mov.n	a10, a5
  90ddd5:	5bfce6        	call8	90d170 <ath_tx_tgt_setds>

	return bf;
  90ddd8:	d10f      	retw.n
	struct ieee80211_node_target *ni;
	struct ath_atx_tid *tid;

	ni = ath_tgt_find_node(sc, dh->ni_index);
	if (ni == NULL)
		return NULL;
  90ddda:	c020      	movi.n	a2, 0
	ath_tgt_txbuf_setup(sc, bf, dh);
	ath_dma_map(sc, bf);
	ath_tx_tgt_setds(sc, bf);

	return bf;
}
  90dddc:	d10f      	retw.n
	...

0090dde0 <ath_tgt_tx_send_normal>:
	return pktlen;
}

void
ath_tgt_tx_send_normal(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90dde0:	6c1014        	entry	a1, 160
  90dde3:	251c40        	addi	a5, a1, 64
  90dde6:	c3b0      	movi.n	a11, 48
  90dde8:	da50      	mov.n	a10, a5
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	struct ath_rc_series rcs[4];
	struct ath_rc_series mrcs[4];
	a_int32_t shortPreamble = 0;
	a_int32_t isProbe = 0;
  90ddea:	c040      	movi.n	a4, 0
}

void
ath_tgt_tx_send_normal(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
  90ddec:	263204        	l32i	a6, a3, 16
	struct ath_rc_series rcs[4];
	struct ath_rc_series mrcs[4];
	a_int32_t shortPreamble = 0;
	a_int32_t isProbe = 0;
  90ddef:	24161c        	s32i	a4, a1, 112
  90ddf2:	5bfcf3        	call8	90d1c0 <__adf_os_mem_set$constprop$19>
  90ddf5:	c3b0      	movi.n	a11, 48
  90ddf7:	2a1c10        	addi	a10, a1, 16
  90ddfa:	5bfcf1        	call8	90d1c0 <__adf_os_mem_set$constprop$19>

	adf_os_mem_set(rcs, 0, sizeof(struct ath_rc_series)*4 );
	adf_os_mem_set(mrcs, 0, sizeof(struct ath_rc_series)*4 );

	if (!bf->bf_ismcast) {
  90ddfd:	273221        	l32i	a7, a3, 132
  90de00:	2d0a80        	movi	a13, 128
  90de03:	07dd01        	and	a13, a13, a7
  90de06:	273c50        	addi	a7, a3, 80
  90de09:	74d921        	bne	a13, a4, 90de2e <ath_tgt_tx_send_normal+0x4e>
				  a_int32_t stepDnInc,
				  a_uint32_t rcflag,
				  struct ath_rc_series series[],
				  a_int32_t *isProbe)
{
	ath_rate_findrate(sc, an, 1, frameLen, 10, 4, 1,
  90de0c:	c0c1      	movi.n	a12, 1
  90de0e:	241c70        	addi	a4, a1, 112
  90de11:	9c11      	s32i.n	a12, a1, 4
  90de13:	9c10      	s32i.n	a12, a1, 0
  90de15:	db60      	mov.n	a11, a6
  90de17:	9413      	s32i.n	a4, a1, 12
  90de19:	9512      	s32i.n	a5, a1, 8
  90de1b:	c0f4      	movi.n	a15, 4
  90de1d:	c0ea      	movi.n	a14, 10
  90de1f:	da20      	mov.n	a10, a2
  90de21:	5bfbca        	call8	90cd4c <ath_rate_findrate>

	if (!bf->bf_ismcast) {
		ath_tgt_rate_findrate(sc, an, shortPreamble,
				      0, 0, 0, 0, 0,
				      rcs, &isProbe);
		ath_hal_memcpy(bf->bf_rcs, rcs, sizeof(rcs));
  90de24:	c3c0      	movi.n	a12, 48
  90de26:	db50      	mov.n	a11, a5
  90de28:	600024        	j	90de50 <ath_tgt_tx_send_normal+0x70>
  90de2b:	000000        	ill
	} else {
		mrcs[1].tries = mrcs[2].tries = mrcs[3].tries = 0;
		mrcs[1].rix = mrcs[2].rix = mrcs[3].rix = 0;
		mrcs[0].rix   = 0;
		mrcs[0].tries = 1;
  90de2e:	c051      	movi.n	a5, 1
		ath_tgt_rate_findrate(sc, an, shortPreamble,
				      0, 0, 0, 0, 0,
				      rcs, &isProbe);
		ath_hal_memcpy(bf->bf_rcs, rcs, sizeof(rcs));
	} else {
		mrcs[1].tries = mrcs[2].tries = mrcs[3].tries = 0;
  90de30:	241435        	s8i	a4, a1, 53
  90de33:	241429        	s8i	a4, a1, 41
  90de36:	24141d        	s8i	a4, a1, 29
		mrcs[1].rix = mrcs[2].rix = mrcs[3].rix = 0;
  90de39:	241434        	s8i	a4, a1, 52
  90de3c:	241428        	s8i	a4, a1, 40
  90de3f:	24141c        	s8i	a4, a1, 28
		mrcs[0].rix   = 0;
  90de42:	241410        	s8i	a4, a1, 16
		mrcs[0].tries = 1;
  90de45:	251411        	s8i	a5, a1, 17
		mrcs[0].flags = 0;
  90de48:	241413        	s8i	a4, a1, 19
		ath_hal_memcpy(bf->bf_rcs, mrcs, sizeof(mrcs));
  90de4b:	c3c0      	movi.n	a12, 48
  90de4d:	2b1c10        	addi	a11, a1, 16
  90de50:	da70      	mov.n	a10, a7
  90de52:	5be724        	call8	907ae4 <ath_hal_memcpy>
	}

	ath_buf_set_rate(sc, bf);
  90de55:	db30      	mov.n	a11, a3
  90de57:	da20      	mov.n	a10, a2
  90de59:	5bfcde        	call8	90d1d4 <ath_buf_set_rate>
	bf->bf_txq_add(sc, bf);
  90de5c:	243210        	l32i	a4, a3, 64
  90de5f:	db30      	mov.n	a11, a3
  90de61:	da20      	mov.n	a10, a2
  90de63:	0b4000        	callx8	a4
  90de66:	d10f      	retw.n

0090de68 <ath_tgt_send_mgt>:
}

void
ath_tgt_send_mgt(struct ath_softc_tgt *sc,adf_nbuf_t hdr_buf, adf_nbuf_t skb,
		 HTC_ENDPOINT_ID endpt)
{
  90de68:	6c1026        	entry	a1, 0x130
	struct ieee80211_node_target *ni;
	struct ieee80211vap_target *vap;
	struct ath_vap_target *avp;
	struct ath_hal *ah = sc->sc_ah;
  90de6b:	262d05        	addmi	a6, a2, 0x500
  90de6e:	866b      	l32i.n	a6, a6, 44
  90de70:	2c0aa0        	movi	a12, 160
  90de73:	261635        	s32i	a6, a1, 212
  90de76:	2b0aa4        	movi	a11, 164
	struct ath_rc_series rcs[4];
	HAL_11N_RATE_SERIES series[4];
	ath_mgt_hdr_t *mh;
	a_int8_t keyix;

	if (!hdr_buf) {
  90de79:	cd36      	bnez.n	a3, 90de93 <ath_tgt_send_mgt+0x2b>
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  90de7b:	231c20        	addi	a3, a1, 32
  90de7e:	ab3b      	add.n	a11, a3, a11
  90de80:	044a02        	or	a10, a4, a4
  90de83:	0c3c08        	add	a12, a3, a12
  90de86:	5be380        	call8	906c88 <__adf_nbuf_peek_header>
 *         or NULL if there is not sufficient data to pull.
 */
static inline a_uint8_t *
adf_nbuf_pull_head(adf_nbuf_t buf, adf_os_size_t size)
{
    return __adf_nbuf_pull_head(buf, size);
  90de89:	c0b8      	movi.n	a11, 8
  90de8b:	da40      	mov.n	a10, a4
  90de8d:	5be2b2        	call8	906958 <__adf_nbuf_pull_head>
  90de90:	60000c        	j	90dea0 <ath_tgt_send_mgt+0x38>
 *
 */
static inline void
adf_nbuf_peek_header(adf_nbuf_t buf, a_uint8_t **addr, a_uint32_t *len)
{
    __adf_nbuf_peek_header(buf, addr, len);
  90de93:	261c20        	addi	a6, a1, 32
  90de96:	ac6c      	add.n	a12, a6, a12
  90de98:	0b6b08        	add	a11, a6, a11
  90de9b:	da30      	mov.n	a10, a3
  90de9d:	5be37a        	call8	906c88 <__adf_nbuf_peek_header>
		adf_nbuf_pull_head(skb, sizeof(ath_mgt_hdr_t));
	} else {
		adf_nbuf_peek_header(hdr_buf, &data, &len);
	}

	adf_os_assert(len >= sizeof(ath_mgt_hdr_t));
  90dea0:	231230        	l32i	a3, a1, 192
  90dea3:	6f3816        	bgeui	a3, 8, 90debd <ath_tgt_send_mgt+0x55>
  90dea6:	1368bf        	l32r	a3, 8e81a4 <memset+0x135c>
  90dea9:	1b6ab3        	l32r	a11, 8e8978 <memset+0x1b30>
  90deac:	233212        	l32i	a3, a3, 72
  90deaf:	1a6aa3        	l32r	a10, 8e893c <memset+0x1af4>
  90deb2:	0b3000        	callx8	a3
  90deb5:	136923        	l32r	a3, 8e8344 <memset+0x14fc>
  90deb8:	0c0200        	memw
  90debb:	8330      	l32i.n	a3, a3, 0
  90debd:	281c20        	addi	a8, a1, 32
  90dec0:	2c0aa0        	movi	a12, 160
  90dec3:	2b0aa4        	movi	a11, 164
  90dec6:	0b8b08        	add	a11, a8, a11
  90dec9:	0c8c08        	add	a12, a8, a12
  90decc:	da40      	mov.n	a10, a4

	mh = (ath_mgt_hdr_t *)data;
  90dece:	261231        	l32i	a6, a1, 196
  90ded1:	5be36d        	call8	906c88 <__adf_nbuf_peek_header>
	adf_nbuf_peek_header(skb, &data, &len);
	wh = (struct ieee80211_frame *)data;
  90ded4:	291231        	l32i	a9, a1, 196
  90ded7:	231c20        	addi	a3, a1, 32
  90deda:	2a3c70        	addi	a10, a3, 112
  90dedd:	c3b0      	movi.n	a11, 48
  90dedf:	291634        	s32i	a9, a1, 208
  90dee2:	5bfcb7        	call8	90d1c0 <__adf_os_mem_set$constprop$19>
  90dee5:	2b0a70        	movi	a11, 112
  90dee8:	2a1c20        	addi	a10, a1, 32
  90deeb:	5bfcb5        	call8	90d1c0 <__adf_os_mem_set$constprop$19>

	adf_os_mem_set(rcs, 0, sizeof(struct ath_rc_series)*4);
	adf_os_mem_set(series, 0, sizeof(HAL_11N_RATE_SERIES)*4);

	bf = asf_tailq_first(&sc->sc_txbuf);
  90deee:	2322f0        	l32i	a3, a2, 0x3c0
	if (!bf)
  90def1:	64334c        	beqz	a3, 90e241 <ath_tgt_send_mgt+0x3d9>
		goto fail;

	asf_tailq_remove(&sc->sc_txbuf, bf, bf_list);
  90def4:	8739      	l32i.n	a7, a3, 36
  90def6:	883a      	l32i.n	a8, a3, 40
  90def8:	c874      	beqz.n	a7, 90df00 <ath_tgt_send_mgt+0x98>
  90defa:	987a      	s32i.n	a8, a7, 40
  90defc:	600003        	j	90df03 <ath_tgt_send_mgt+0x9b>
  90deff:	002826        	excw
  90df02:	f1          	.byte 0xf1
  90df03:	883a      	l32i.n	a8, a3, 40
  90df05:	9780      	s32i.n	a7, a8, 0

	ni = ath_tgt_find_node(sc, mh->ni_index);
  90df07:	2e6000        	l8ui	a14, a6, 0
							a_int32_t node_index)
{
	struct ath_node_target *an;
	struct ieee80211_node_target *ni;

	if (node_index > TARGET_NODE_MAX)
  90df0a:	c078      	movi.n	a7, 8
  90df0c:	7e7a02        	bge	a7, a14, 90df12 <ath_tgt_send_mgt+0xaa>
  90df0f:	60032e        	j	90e241 <ath_tgt_send_mgt+0x3d9>
	  	return NULL;

	an = &sc->sc_sta[node_index];
	ni = &an->ni;
  90df12:	0ae711        	slli	a7, a14, 6
  90df15:	ae77      	add.n	a7, a7, a14
  90df17:	0f7711        	slli	a7, a7, 1
  90df1a:	ae77      	add.n	a7, a7, a14
  90df1c:	0e7711        	slli	a7, a7, 2
  90df1f:	285a38        	movi	a8, 0x538
  90df22:	a878      	add.n	a8, a7, a8
  90df24:	a828      	add.n	a8, a2, a8
  90df26:	28163d        	s32i	a8, a1, 244

	if (an->an_valid) {
  90df29:	a727      	add.n	a7, a2, a7
  90df2b:	287a3c        	movi	a8, 0x73c
  90df2e:	a878      	add.n	a8, a7, a8
  90df30:	288000        	l8ui	a8, a8, 0
  90df33:	64830a        	beqz	a8, 90e241 <ath_tgt_send_mgt+0x3d9>
		if (ni->ni_vap == NULL) {
  90df36:	285a58        	movi	a8, 0x558
  90df39:	a877      	add.n	a7, a7, a8
  90df3b:	8770      	l32i.n	a7, a7, 0
  90df3d:	657314        	bnez	a7, 90e255 <ath_tgt_send_mgt+0x3ed>
  90df40:	6002fd        	j	90e241 <ath_tgt_send_mgt+0x3d9>
	keyix = HAL_TXKEYIX_INVALID;
	pktlen -= (hdrlen & 3);
	pktlen += IEEE80211_CRC_LEN;

	if (iswep)
		keyix = mh->keyix;
  90df43:	286005        	l8ui	a8, a6, 5
adf_nbuf_map(adf_os_device_t        osdev, 
             adf_os_dma_map_t       bmap, 
             adf_nbuf_t             buf, 
             adf_os_dma_dir_t       dir)
{
    return __adf_nbuf_map(osdev, bmap, buf, dir);
  90df46:	8b30      	l32i.n	a11, a3, 0
  90df48:	2a2246        	l32i	a10, a2, 0x118
  90df4b:	c0d0      	movi.n	a13, 0
  90df4d:	dc40      	mov.n	a12, a4
  90df4f:	28163a        	s32i	a8, a1, 232
  90df52:	2e163e        	s32i	a14, a1, 248
  90df55:	5be2c6        	call8	906a70 <__adf_nbuf_map>
 * @param[in] buf   buf
 */
static inline void
adf_nbuf_queue_add(adf_nbuf_queue_t *head, adf_nbuf_t buf)
{
    __adf_nbuf_queue_add(head, buf);
  90df58:	db40      	mov.n	a11, a4

	adf_nbuf_map(sc->sc_dev, bf->bf_dmamap, skb, ADF_OS_DMA_TO_DEVICE);

	bf->bf_skb = skb;
  90df5a:	9438      	s32i.n	a4, a3, 32
  90df5c:	2a3c14        	addi	a10, a3, 20
  90df5f:	5be2ab        	call8	906a0c <__adf_nbuf_queue_add>
	adf_nbuf_queue_add(&bf->bf_skbhead, skb);

	ds = bf->bf_desc;
  90df62:	893c      	l32i.n	a9, a3, 48
	rt = sc->sc_currates;
  90df64:	282281        	l32i	a8, a2, 0x204
	adf_nbuf_map(sc->sc_dev, bf->bf_dmamap, skb, ADF_OS_DMA_TO_DEVICE);

	bf->bf_skb = skb;
	adf_nbuf_queue_add(&bf->bf_skbhead, skb);

	ds = bf->bf_desc;
  90df67:	291638        	s32i	a9, a1, 224
	rt = sc->sc_currates;
	adf_os_assert(rt != NULL);
  90df6a:	2e123e        	l32i	a14, a1, 248
  90df6d:	cd8f      	bnez.n	a8, 90df90 <ath_tgt_send_mgt+0x128>
  90df6f:	1468bf        	l32r	a4, 8e826c <memset+0x1424>
  90df72:	1b6ab3        	l32r	a11, 8e8a40 <memset+0x1bf8>
  90df75:	244212        	l32i	a4, a4, 72
  90df78:	1a6aa3        	l32r	a10, 8e8a04 <memset+0x1bbc>
  90df7b:	281640        	s32i	a8, a1, 0x100
  90df7e:	0b4000        	callx8	a4
  90df81:	146923        	l32r	a4, 8e8410 <memset+0x15c8>
  90df84:	2e123e        	l32i	a14, a1, 248
  90df87:	0c0200        	memw
  90df8a:	244200        	l32i	a4, a4, 0
  90df8d:	281240        	l32i	a8, a1, 0x100

	if (mh->flags == ATH_SHORT_PREAMBLE)
  90df90:	246003        	l8ui	a4, a6, 3
	else
		shortPreamble = AH_FALSE;

	flags = HAL_TXDESC_CLRDMASK;

	switch (wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) {
  90df93:	291234        	l32i	a9, a1, 208

	ds = bf->bf_desc;
	rt = sc->sc_currates;
	adf_os_assert(rt != NULL);

	if (mh->flags == ATH_SHORT_PREAMBLE)
  90df96:	241639        	s32i	a4, a1, 228
	else
		shortPreamble = AH_FALSE;

	flags = HAL_TXDESC_CLRDMASK;

	switch (wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) {
  90df99:	249000        	l8ui	a4, a9, 0
  90df9c:	c07c      	movi.n	a7, 12
  90df9e:	074701        	and	a7, a4, a7
  90dfa1:	cd7d      	bnez.n	a7, 90dfc2 <ath_tgt_send_mgt+0x15a>
  90dfa3:	c790      	movi.n	a9, -16
	case IEEE80211_FC0_TYPE_MGT:
		subtype = wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK;

		if (subtype == IEEE80211_FC0_SUBTYPE_PROBE_RESP)
			atype = HAL_PKT_TYPE_PROBE_RESP;
  90dfa5:	c0a4      	movi.n	a10, 4
  90dfa7:	094401        	and	a4, a4, a9
  90dfaa:	2a1636        	s32i	a10, a1, 216

	switch (wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) {
	case IEEE80211_FC0_TYPE_MGT:
		subtype = wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK;

		if (subtype == IEEE80211_FC0_SUBTYPE_PROBE_RESP)
  90dfad:	c590      	movi.n	a9, 80
  90dfaf:	794114        	beq	a4, a9, 90dfc7 <ath_tgt_send_mgt+0x15f>
			atype = HAL_PKT_TYPE_PROBE_RESP;
		else if (subtype == IEEE80211_FC0_SUBTYPE_ATIM)
  90dfb2:	29fa70        	movi	a9, -144
  90dfb5:	a944      	add.n	a4, a4, a9
  90dfb7:	c091      	movi.n	a9, 1
  90dfb9:	047939        	movnez	a9, a7, a4
  90dfbc:	291636        	s32i	a9, a1, 216
  90dfbf:	600004        	j	90dfc7 <ath_tgt_send_mgt+0x15f>
		else
			atype = HAL_PKT_TYPE_NORMAL;

		break;
	default:
		atype = HAL_PKT_TYPE_NORMAL;
  90dfc2:	c040      	movi.n	a4, 0
  90dfc4:	241636        	s32i	a4, a1, 216
		break;
	}

	avp = &sc->sc_vap[mh->vap_index];
  90dfc7:	246001        	l8ui	a4, a6, 1

	rcs[0].rix = ath_get_minrateidx(sc, avp);
  90dfca:	da20      	mov.n	a10, a2
	default:
		atype = HAL_PKT_TYPE_NORMAL;
		break;
	}

	avp = &sc->sc_vap[mh->vap_index];
  90dfcc:	0c4b11        	slli	a11, a4, 4
  90dfcf:	a4bb      	add.n	a11, a11, a4
  90dfd1:	1469bf        	l32r	a4, 8e86d0 <memset+0x1888>
  90dfd4:	0ebb11        	slli	a11, a11, 2
  90dfd7:	a4bb      	add.n	a11, a11, a4

	rcs[0].rix = ath_get_minrateidx(sc, avp);
  90dfd9:	0b2b08        	add	a11, a2, a11
  90dfdc:	281640        	s32i	a8, a1, 0x100
  90dfdf:	2e163e        	s32i	a14, a1, 248
  90dfe2:	5bed03        	call8	9093f0 <ath_get_minrateidx>
 * @param[in] size    buffer size
 */
static inline void
adf_os_mem_copy(void *dst, const void *src, adf_os_size_t size)
{
    __adf_os_mem_copy(dst, src, size);
  90dfe5:	291c20        	addi	a9, a1, 32
	rcs[0].tries = ATH_TXMAXTRY;
  90dfe8:	c04b      	movi.n	a4, 11
		break;
	}

	avp = &sc->sc_vap[mh->vap_index];

	rcs[0].rix = ath_get_minrateidx(sc, avp);
  90dfea:	2a1490        	s8i	a10, a1, 144
	rcs[0].tries = ATH_TXMAXTRY;
  90dfed:	241491        	s8i	a4, a1, 145
  90dff0:	2b9c70        	addi	a11, a9, 112
	rcs[0].flags = 0;
  90dff3:	c040      	movi.n	a4, 0
  90dff5:	2a3c50        	addi	a10, a3, 80
  90dff8:	c3c0      	movi.n	a12, 48
  90dffa:	241493        	s8i	a4, a1, 147
  90dffd:	5bfb7f        	call8	90cdfc <__adf_os_mem_copy>

	adf_os_mem_copy(bf->bf_rcs, rcs, sizeof(rcs));
	rix = rcs[0].rix;
	try0 = rcs[0].tries;
	txrate = rt->info[rix].rateCode;
  90e000:	2d1090        	l8ui	a13, a1, 144
  90e003:	281240        	l32i	a8, a1, 0x100
  90e006:	0ed411        	slli	a4, a13, 2
  90e009:	ad44      	add.n	a4, a4, a13
  90e00b:	0e4411        	slli	a4, a4, 2

	if (shortPreamble){
  90e00e:	2a1239        	l32i	a10, a1, 228
	rcs[0].flags = 0;

	adf_os_mem_copy(bf->bf_rcs, rcs, sizeof(rcs));
	rix = rcs[0].rix;
	try0 = rcs[0].tries;
	txrate = rt->info[rix].rateCode;
  90e011:	a484      	add.n	a4, a8, a4
	rcs[0].tries = ATH_TXMAXTRY;
	rcs[0].flags = 0;

	adf_os_mem_copy(bf->bf_rcs, rcs, sizeof(rcs));
	rix = rcs[0].rix;
	try0 = rcs[0].tries;
  90e013:	291091        	l8ui	a9, a1, 145
	txrate = rt->info[rix].rateCode;
  90e016:	274034        	l8ui	a7, a4, 52

	if (shortPreamble){
  90e019:	2e123e        	l32i	a14, a1, 248
  90e01c:	69a105        	bnei	a10, 1, 90e025 <ath_tgt_send_mgt+0x1bd>
		txrate |= rt->info[rix].shortPreamble;
  90e01f:	244035        	l8ui	a4, a4, 53
  90e022:	047702        	or	a7, a7, a4
	}

	vap = ni->ni_vap;
  90e025:	0ae411        	slli	a4, a14, 6
  90e028:	ae44      	add.n	a4, a4, a14
  90e02a:	0f4411        	slli	a4, a4, 1
  90e02d:	ae44      	add.n	a4, a4, a14
  90e02f:	0e4411        	slli	a4, a4, 2
  90e032:	2a5a58        	movi	a10, 0x558
  90e035:	a424      	add.n	a4, a2, a4
  90e037:	aa44      	add.n	a4, a4, a10
	bf->bf_node = ni;
  90e039:	2a123d        	l32i	a10, a1, 244

	if (shortPreamble){
		txrate |= rt->info[rix].shortPreamble;
	}

	vap = ni->ni_vap;
  90e03c:	8440      	l32i.n	a4, a4, 0
	bf->bf_node = ni;
  90e03e:	9a34      	s32i.n	a10, a3, 16

	if (ismcast) {
  90e040:	cd5e      	bnez.n	a5, 90e062 <ath_tgt_send_mgt+0x1fa>
		flags |= HAL_TXDESC_NOACK;
		try0 = 1;
	} else if (pktlen > vap->iv_rtsthreshold) {
  90e042:	254105        	l16ui	a5, a4, 10
  90e045:	2a1237        	l32i	a10, a1, 220
	if (mh->flags == ATH_SHORT_PREAMBLE)
		shortPreamble = AH_TRUE;
	else
		shortPreamble = AH_FALSE;

	flags = HAL_TXDESC_CLRDMASK;
  90e048:	c0f1      	movi.n	a15, 1
{
	struct ieee80211_node_target *ni;
	struct ieee80211vap_target *vap;
	struct ath_vap_target *avp;
	struct ath_hal *ah = sc->sc_ah;
	a_uint8_t rix, txrate, ctsrate, cix = 0xff, *data;
  90e04a:	240aff        	movi	a4, 255
	bf->bf_node = ni;

	if (ismcast) {
		flags |= HAL_TXDESC_NOACK;
		try0 = 1;
	} else if (pktlen > vap->iv_rtsthreshold) {
  90e04d:	7a5a18        	bge	a5, a10, 90e069 <ath_tgt_send_mgt+0x201>
		flags |= HAL_TXDESC_RTSENA;
		cix = rt->info[rix].controlRate;
  90e050:	0ed411        	slli	a4, a13, 2
  90e053:	ad44      	add.n	a4, a4, a13
  90e055:	0e4411        	slli	a4, a4, 2
  90e058:	a484      	add.n	a4, a8, a4
  90e05a:	244037        	l8ui	a4, a4, 55

	if (ismcast) {
		flags |= HAL_TXDESC_NOACK;
		try0 = 1;
	} else if (pktlen > vap->iv_rtsthreshold) {
		flags |= HAL_TXDESC_RTSENA;
  90e05d:	c0f5      	movi.n	a15, 5
  90e05f:	600006        	j	90e069 <ath_tgt_send_mgt+0x201>
	vap = ni->ni_vap;
	bf->bf_node = ni;

	if (ismcast) {
		flags |= HAL_TXDESC_NOACK;
		try0 = 1;
  90e062:	c091      	movi.n	a9, 1

	vap = ni->ni_vap;
	bf->bf_node = ni;

	if (ismcast) {
		flags |= HAL_TXDESC_NOACK;
  90e064:	c0f3      	movi.n	a15, 3
{
	struct ieee80211_node_target *ni;
	struct ieee80211vap_target *vap;
	struct ath_vap_target *avp;
	struct ath_hal *ah = sc->sc_ah;
	a_uint8_t rix, txrate, ctsrate, cix = 0xff, *data;
  90e066:	240aff        	movi	a4, 255
	} else if (pktlen > vap->iv_rtsthreshold) {
		flags |= HAL_TXDESC_RTSENA;
		cix = rt->info[rix].controlRate;
	}

	if ((bf->bf_protmode != IEEE80211_PROT_NONE) &&
  90e069:	253084        	l8ui	a5, a3, 132
  90e06c:	ca5c      	beqz.n	a5, 90e09c <ath_tgt_send_mgt+0x234>
	    rt->info[rix].phy == IEEE80211_T_OFDM &&
  90e06e:	0ed511        	slli	a5, a13, 2
  90e071:	ad55      	add.n	a5, a5, a13
  90e073:	0e5511        	slli	a5, a5, 2
  90e076:	a585      	add.n	a5, a8, a5
	} else if (pktlen > vap->iv_rtsthreshold) {
		flags |= HAL_TXDESC_RTSENA;
		cix = rt->info[rix].controlRate;
	}

	if ((bf->bf_protmode != IEEE80211_PROT_NONE) &&
  90e078:	255029        	l8ui	a5, a5, 41
  90e07b:	69521d        	bnei	a5, 2, 90e09c <ath_tgt_send_mgt+0x234>
	    rt->info[rix].phy == IEEE80211_T_OFDM &&
  90e07e:	75f81a        	bany	a15, a5, 90e09c <ath_tgt_send_mgt+0x234>
	    (flags & HAL_TXDESC_NOACK) == 0) {
		cix = rt->info[sc->sc_protrix].controlRate;
  90e081:	242d03        	addmi	a4, a2, 0x300
  90e084:	25400c        	l8ui	a5, a4, 12
  90e087:	0e5411        	slli	a4, a5, 2
  90e08a:	a544      	add.n	a4, a4, a5
		sc->sc_tx_stats.ast_tx_protect++;
  90e08c:	25225a        	l32i	a5, a2, 0x168
	}

	if ((bf->bf_protmode != IEEE80211_PROT_NONE) &&
	    rt->info[rix].phy == IEEE80211_T_OFDM &&
	    (flags & HAL_TXDESC_NOACK) == 0) {
		cix = rt->info[sc->sc_protrix].controlRate;
  90e08f:	0e4411        	slli	a4, a4, 2
  90e092:	a484      	add.n	a4, a8, a4
		sc->sc_tx_stats.ast_tx_protect++;
  90e094:	b155      	addi.n	a5, a5, 1
	}

	if ((bf->bf_protmode != IEEE80211_PROT_NONE) &&
	    rt->info[rix].phy == IEEE80211_T_OFDM &&
	    (flags & HAL_TXDESC_NOACK) == 0) {
		cix = rt->info[sc->sc_protrix].controlRate;
  90e096:	244037        	l8ui	a4, a4, 55
		sc->sc_tx_stats.ast_tx_protect++;
  90e099:	25265a        	s32i	a5, a2, 0x168
	}

	*(a_uint16_t *)&wh->i_seq[0] =  adf_os_cpu_to_le16(ni->ni_txseqmgmt <<
  90e09c:	0ae511        	slli	a5, a14, 6
  90e09f:	ae55      	add.n	a5, a5, a14
  90e0a1:	0f5511        	slli	a5, a5, 1
  90e0a4:	ae5e      	add.n	a14, a5, a14
  90e0a6:	0eee11        	slli	a14, a14, 2
  90e0a9:	255a50        	movi	a5, 0x550
  90e0ac:	ae2e      	add.n	a14, a2, a14
  90e0ae:	a5ee      	add.n	a14, a14, a5
  90e0b0:	25e100        	l16ui	a5, a14, 0
  90e0b3:	045a11        	slli	a10, a5, 12
  90e0b6:	054547        	extui	a5, a5, 4, 8
  90e0b9:	05a502        	or	a5, a10, a5
  90e0bc:	2a1234        	l32i	a10, a1, 208
  90e0bf:	25a50b        	s16i	a5, a10, 22
							   IEEE80211_SEQ_SEQ_SHIFT);
	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);
  90e0c2:	25e100        	l16ui	a5, a14, 0

	ctsduration = 0;
	if (flags & (HAL_TXDESC_RTSENA|HAL_TXDESC_CTSENA)) {
  90e0c5:	c0ac      	movi.n	a10, 12
		sc->sc_tx_stats.ast_tx_protect++;
	}

	*(a_uint16_t *)&wh->i_seq[0] =  adf_os_cpu_to_le16(ni->ni_txseqmgmt <<
							   IEEE80211_SEQ_SEQ_SHIFT);
	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);
  90e0c7:	b155      	addi.n	a5, a5, 1
  90e0c9:	05054b        	extui	a5, a5, 0, 12
  90e0cc:	25e500        	s16i	a5, a14, 0

	ctsduration = 0;
	if (flags & (HAL_TXDESC_RTSENA|HAL_TXDESC_CTSENA)) {
  90e0cf:	0afa01        	and	a10, a15, a10
		}
		ctsduration += ath_hal_computetxtime(ah,
						     rt, pktlen, rix, shortPreamble);
		try0 = 1;
	} else
		ctsrate = 0;
  90e0d2:	c050      	movi.n	a5, 0
	*(a_uint16_t *)&wh->i_seq[0] =  adf_os_cpu_to_le16(ni->ni_txseqmgmt <<
							   IEEE80211_SEQ_SEQ_SHIFT);
	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);

	ctsduration = 0;
	if (flags & (HAL_TXDESC_RTSENA|HAL_TXDESC_CTSENA)) {
  90e0d4:	75a17c        	beq	a10, a5, 90e154 <ath_tgt_send_mgt+0x2ec>
		adf_os_assert(cix != 0xff);
  90e0d7:	250aff        	movi	a5, 255
  90e0da:	754928        	bne	a4, a5, 90e106 <ath_tgt_send_mgt+0x29e>
  90e0dd:	1568bf        	l32r	a5, 8e83dc <memset+0x1594>
  90e0e0:	1b6ab3        	l32r	a11, 8e8bac <memset+0x1d64>
  90e0e3:	255212        	l32i	a5, a5, 72
  90e0e6:	1a6aa3        	l32r	a10, 8e8b74 <memset+0x1d2c>
  90e0e9:	281640        	s32i	a8, a1, 0x100
  90e0ec:	2d163e        	s32i	a13, a1, 248
  90e0ef:	2f163f        	s32i	a15, a1, 252
  90e0f2:	0b5000        	callx8	a5
  90e0f5:	156923        	l32r	a5, 8e8584 <memset+0x173c>
  90e0f8:	2f123f        	l32i	a15, a1, 252
  90e0fb:	0c0200        	memw
  90e0fe:	8550      	l32i.n	a5, a5, 0
  90e100:	2d123e        	l32i	a13, a1, 248
  90e103:	281240        	l32i	a8, a1, 0x100
		ctsrate = rt->info[cix].rateCode;
  90e106:	0e4511        	slli	a5, a4, 2
  90e109:	a454      	add.n	a4, a5, a4
  90e10b:	0e4411        	slli	a4, a4, 2
		if (shortPreamble) {
  90e10e:	291239        	l32i	a9, a1, 228
	INCR(ni->ni_txseqmgmt, IEEE80211_SEQ_MAX);

	ctsduration = 0;
	if (flags & (HAL_TXDESC_RTSENA|HAL_TXDESC_CTSENA)) {
		adf_os_assert(cix != 0xff);
		ctsrate = rt->info[cix].rateCode;
  90e111:	a484      	add.n	a4, a8, a4
  90e113:	254034        	l8ui	a5, a4, 52
		if (shortPreamble) {
  90e116:	69910b        	bnei	a9, 1, 90e125 <ath_tgt_send_mgt+0x2bd>
			ctsrate |= rt->info[cix].shortPreamble;
  90e119:	294035        	l8ui	a9, a4, 53
			if (flags & HAL_TXDESC_RTSENA)      /* SIFS + CTS */
				ctsduration += rt->info[cix].spAckDuration;
  90e11c:	24411d        	l16ui	a4, a4, 58
	ctsduration = 0;
	if (flags & (HAL_TXDESC_RTSENA|HAL_TXDESC_CTSENA)) {
		adf_os_assert(cix != 0xff);
		ctsrate = rt->info[cix].rateCode;
		if (shortPreamble) {
			ctsrate |= rt->info[cix].shortPreamble;
  90e11f:	095502        	or	a5, a5, a9
  90e122:	600002        	j	90e128 <ath_tgt_send_mgt+0x2c0>
				ctsduration += rt->info[cix].spAckDuration;
			if ((flags & HAL_TXDESC_NOACK) == 0)    /* SIFS + ACK */
				ctsduration += rt->info[cix].spAckDuration;
		} else {
			if (flags & HAL_TXDESC_RTSENA)      /* SIFS + CTS */
				ctsduration += rt->info[cix].lpAckDuration;
  90e125:	24411c        	l16ui	a4, a4, 56

	ds = bf->bf_desc;
	rt = sc->sc_currates;
	adf_os_assert(rt != NULL);

	if (mh->flags == ATH_SHORT_PREAMBLE)
  90e128:	291239        	l32i	a9, a1, 228
  90e12b:	c0a0      	movi.n	a10, 0
  90e12d:	b09e      	addi.n	a14, a9, -1
  90e12f:	c091      	movi.n	a9, 1
  90e131:	0e9a38        	moveqz	a10, a9, a14
  90e134:	0aae02        	or	a14, a10, a10
			if (flags & HAL_TXDESC_RTSENA)      /* SIFS + CTS */
				ctsduration += rt->info[cix].lpAckDuration;
			if ((flags & HAL_TXDESC_NOACK) == 0)    /* SIFS + ACK */
				ctsduration += rt->info[cix].lpAckDuration;
		}
		ctsduration += ath_hal_computetxtime(ah,
  90e137:	2c1237        	l32i	a12, a1, 220
  90e13a:	2a1235        	l32i	a10, a1, 212
  90e13d:	088b02        	or	a11, a8, a8
  90e140:	29163e        	s32i	a9, a1, 248
  90e143:	2f163f        	s32i	a15, a1, 252
  90e146:	5bf2e3        	call8	90acd4 <ath_hal_computetxtime>
				ctsduration += rt->info[cix].spAckDuration;
		} else {
			if (flags & HAL_TXDESC_RTSENA)      /* SIFS + CTS */
				ctsduration += rt->info[cix].lpAckDuration;
			if ((flags & HAL_TXDESC_NOACK) == 0)    /* SIFS + ACK */
				ctsduration += rt->info[cix].lpAckDuration;
  90e149:	0f4411        	slli	a4, a4, 1
		}
		ctsduration += ath_hal_computetxtime(ah,
						     rt, pktlen, rix, shortPreamble);
		try0 = 1;
  90e14c:	29123e        	l32i	a9, a1, 248
  90e14f:	2f123f        	l32i	a15, a1, 252
			if (flags & HAL_TXDESC_RTSENA)      /* SIFS + CTS */
				ctsduration += rt->info[cix].lpAckDuration;
			if ((flags & HAL_TXDESC_NOACK) == 0)    /* SIFS + ACK */
				ctsduration += rt->info[cix].lpAckDuration;
		}
		ctsduration += ath_hal_computetxtime(ah,
  90e152:	a4aa      	add.n	a10, a10, a4
	} else
		ctsrate = 0;

	flags |= HAL_TXDESC_INTREQ;

	ah->ah_setupTxDesc(ds
  90e154:	9a14      	s32i.n	a10, a1, 16
  90e156:	2a123a        	l32i	a10, a1, 232
						     rt, pktlen, rix, shortPreamble);
		try0 = 1;
	} else
		ctsrate = 0;

	flags |= HAL_TXDESC_INTREQ;
  90e159:	c140      	movi.n	a4, 16
  90e15b:	04f402        	or	a4, a15, a4

	ah->ah_setupTxDesc(ds
  90e15e:	00a832        	sext	a8, a10, 7
  90e161:	9910      	s32i.n	a9, a1, 0
  90e163:	291235        	l32i	a9, a1, 212
  90e166:	9412      	s32i.n	a4, a1, 8
  90e168:	9513      	s32i.n	a5, a1, 12
  90e16a:	9811      	s32i.n	a8, a1, 4
  90e16c:	289217        	l32i	a8, a9, 92
  90e16f:	2d1236        	l32i	a13, a1, 216
  90e172:	2c123c        	l32i	a12, a1, 240
  90e175:	2b1237        	l32i	a11, a1, 220
  90e178:	2a1238        	l32i	a10, a1, 224
  90e17b:	077f02        	or	a15, a7, a7
  90e17e:	2e0a3c        	movi	a14, 60
  90e181:	0b8000        	callx8	a8
			    , keyix
			    , flags
			    , ctsrate
			    , ctsduration);

	bf->bf_flags = flags;
  90e184:	243544        	s16i	a4, a3, 136

	/*
	 * Set key type in tx desc while sending the encrypted challenge to AP
	 * in Auth frame 3 of Shared Authentication, owl needs this.
	 */
	if (iswep && (keyix != HAL_TXKEYIX_INVALID) &&
  90e187:	24123b        	l32i	a4, a1, 236
  90e18a:	ca42      	beqz.n	a4, 90e1b0 <ath_tgt_send_mgt+0x348>
  90e18c:	281234        	l32i	a8, a1, 208
  90e18f:	248000        	l8ui	a4, a8, 0
  90e192:	280af0        	movi	a8, 240
  90e195:	084401        	and	a4, a4, a8
  90e198:	280ab0        	movi	a8, 176
  90e19b:	784911        	bne	a4, a8, 90e1b0 <ath_tgt_send_mgt+0x348>
			(wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK) == IEEE80211_FC0_SUBTYPE_AUTH)
		ah->ah_fillKeyTxDesc(ds, mh->keytype);
  90e19e:	291235        	l32i	a9, a1, 212
  90e1a1:	2b6004        	l8ui	a11, a6, 4
  90e1a4:	249219        	l32i	a4, a9, 100
  90e1a7:	2a1238        	l32i	a10, a1, 224
  90e1aa:	00bb32        	sext	a11, a11, 7
  90e1ad:	0b4000        	callx8	a4

	ath_filltxdesc(sc, bf);
  90e1b0:	242d05        	addmi	a4, a2, 0x500
  90e1b3:	2a420b        	l32i	a10, a4, 44
  90e1b6:	033b02        	or	a11, a3, a3
  90e1b9:	5bfbc5        	call8	90d0d0 <ath_filltxdesc$isra$9>

	for (i=0; i<4; i++) {
		series[i].Tries = 2;
		series[i].Rate = txrate;
		series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
  90e1bc:	262d16        	addmi	a6, a2, 0x1600
  90e1bf:	2b6026        	l8ui	a11, a6, 38
  90e1c2:	281c20        	addi	a8, a1, 32
  90e1c5:	c064      	movi.n	a6, 4
  90e1c7:	dd80      	mov.n	a13, a8
		ah->ah_fillKeyTxDesc(ds, mh->keytype);

	ath_filltxdesc(sc, bf);

	for (i=0; i<4; i++) {
		series[i].Tries = 2;
  90e1c9:	c0c2      	movi.n	a12, 2
		series[i].Rate = txrate;
		series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
		series[i].RateFlags = 0;
  90e1cb:	c0a0      	movi.n	a10, 0
  90e1cd:	d960      	mov.n	a9, a6
  90e1cf:	6d980c        	loop	a9, 90e1df <ath_tgt_send_mgt+0x377>
		ah->ah_fillKeyTxDesc(ds, mh->keytype);

	ath_filltxdesc(sc, bf);

	for (i=0; i<4; i++) {
		series[i].Tries = 2;
  90e1d2:	9c80      	s32i.n	a12, a8, 0
		series[i].Rate = txrate;
  90e1d4:	9781      	s32i.n	a7, a8, 4
		series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
  90e1d6:	9b83      	s32i.n	a11, a8, 12
		series[i].RateFlags = 0;
  90e1d8:	9a84      	s32i.n	a10, a8, 16
  90e1da:	b066      	addi.n	a6, a6, -1
  90e1dc:	288c1c        	addi	a8, a8, 28
	}
	ah->ah_set11nRateScenario(ds, 0, ctsrate, series, 4, 0);
  90e1df:	281235        	l32i	a8, a1, 212
  90e1e2:	c0f0      	movi.n	a15, 0
  90e1e4:	278210        	l32i	a7, a8, 64
  90e1e7:	2a1238        	l32i	a10, a1, 224
  90e1ea:	055c02        	or	a12, a5, a5
  90e1ed:	2e0a04        	movi	a14, 4
  90e1f0:	dbf0      	mov.n	a11, a15
  90e1f2:	0b7000        	callx8	a7
  90e1f5:	854b      	l32i.n	a5, a4, 44
		  struct ath_txq *txq, struct ath_tx_buf *bf,
		  struct ath_tx_desc *lastds)
{
	struct ath_hal *ah = sc->sc_ah;

	ATH_TXQ_INSERT_TAIL(txq, bf, bf_list);
  90e1f7:	243aec        	movi	a4, 0x3ec
  90e1fa:	a424      	add.n	a4, a2, a4
  90e1fc:	9639      	s32i.n	a6, a3, 36
  90e1fe:	8643      	l32i.n	a6, a4, 12
		series[i].Rate = txrate;
		series[i].ChSel = sc->sc_ic.ic_tx_chainmask;
		series[i].RateFlags = 0;
	}
	ah->ah_set11nRateScenario(ds, 0, ctsrate, series, 4, 0);
	ath_tgt_txqaddbuf(sc, txq, bf, bf->bf_lastds);
  90e200:	873e      	l32i.n	a7, a3, 56
		  struct ath_txq *txq, struct ath_tx_buf *bf,
		  struct ath_tx_desc *lastds)
{
	struct ath_hal *ah = sc->sc_ah;

	ATH_TXQ_INSERT_TAIL(txq, bf, bf_list);
  90e202:	963a      	s32i.n	a6, a3, 40
  90e204:	9360      	s32i.n	a3, a6, 0
  90e206:	263c24        	addi	a6, a3, 36
  90e209:	9643      	s32i.n	a6, a4, 12
  90e20b:	8644      	l32i.n	a6, a4, 16
  90e20d:	9345      	s32i.n	a3, a4, 20
  90e20f:	b166      	addi.n	a6, a6, 1
  90e211:	9644      	s32i.n	a6, a4, 16

	if (txq->axq_link == NULL) {
  90e213:	8641      	l32i.n	a6, a4, 4
  90e215:	cc6f      	bnez.n	a6, 90e228 <ath_tgt_send_mgt+0x3c0>
		ah->ah_setTxDP(ah, txq->axq_qnum, ATH_BUF_GET_DESC_PHY_ADDR(bf));
  90e217:	865a      	l32i.n	a6, a5, 40
  90e219:	8c3c      	l32i.n	a12, a3, 48
  90e21b:	2b4200        	l32i	a11, a4, 0
  90e21e:	055a02        	or	a10, a5, a5
  90e221:	0b6000        	callx8	a6
  90e224:	600004        	j	90e22c <ath_tgt_send_mgt+0x3c4>
  90e227:	00833c        	excw
	} else {
		*txq->axq_link = ATH_BUF_GET_DESC_PHY_ADDR(bf);
  90e22a:	9360      	s32i.n	a3, a6, 0
	}

	txq->axq_link = &lastds->ds_link;
  90e22c:	233aec        	movi	a3, 0x3ec
  90e22f:	a322      	add.n	a2, a2, a3
	ah->ah_startTxDma(ah, txq->axq_qnum);
  90e231:	8b20      	l32i.n	a11, a2, 0
  90e233:	835c      	l32i.n	a3, a5, 48
		ah->ah_setTxDP(ah, txq->axq_qnum, ATH_BUF_GET_DESC_PHY_ADDR(bf));
	} else {
		*txq->axq_link = ATH_BUF_GET_DESC_PHY_ADDR(bf);
	}

	txq->axq_link = &lastds->ds_link;
  90e235:	9721      	s32i.n	a7, a2, 4
	ah->ah_startTxDma(ah, txq->axq_qnum);
  90e237:	da50      	mov.n	a10, a5
  90e239:	0b3000        	callx8	a3
  90e23c:	d10f      	retw.n
  90e23e:	000000        	ill
	ah->ah_set11nRateScenario(ds, 0, ctsrate, series, 4, 0);
	ath_tgt_txqaddbuf(sc, txq, bf, bf->bf_lastds);

	return;
fail:
	HTC_ReturnBuffers(sc->tgt_htc_handle, endpt, skb);
  90e241:	1368bf        	l32r	a3, 8e8540 <memset+0x16f8>
  90e244:	8a22      	l32i.n	a10, a2, 8
  90e246:	233282        	l32i	a3, a3, 0x208
  90e249:	dc40      	mov.n	a12, a4
  90e24b:	db50      	mov.n	a11, a5
  90e24d:	0b3000        	callx8	a3
	return;
  90e250:	d10f      	retw.n
  90e252:	000000        	ill

	ni = ath_tgt_find_node(sc, mh->ni_index);
	if (!ni)
		goto fail;

	bf->bf_endpt = endpt;
  90e255:	253623        	s32i	a5, a3, 140
	bf->bf_cookie = mh->cookie;
  90e258:	256006        	l8ui	a5, a6, 6
  90e25b:	291234        	l32i	a9, a1, 208
  90e25e:	253492        	s8i	a5, a3, 146
	bf->bf_protmode = mh->flags & (IEEE80211_PROT_RTSCTS | IEEE80211_PROT_CTSONLY);
  90e261:	256003        	l8ui	a5, a6, 3
	txq = &sc->sc_txq[1];
	iswep = wh->i_fc[1] & IEEE80211_FC1_WEP;
	ismcast = IEEE80211_IS_MULTICAST(wh->i_addr1);
	hdrlen = ieee80211_anyhdrsize(wh);
  90e264:	da90      	mov.n	a10, a9
	if (!ni)
		goto fail;

	bf->bf_endpt = endpt;
	bf->bf_cookie = mh->cookie;
	bf->bf_protmode = mh->flags & (IEEE80211_PROT_RTSCTS | IEEE80211_PROT_CTSONLY);
  90e266:	050541        	extui	a5, a5, 0, 2
  90e269:	253484        	s8i	a5, a3, 132
  90e26c:	279001        	l8ui	a7, a9, 1
  90e26f:	c450      	movi.n	a5, 64
  90e271:	057501        	and	a5, a7, a5
  90e274:	25163b        	s32i	a5, a1, 236
  90e277:	259004        	l8ui	a5, a9, 4
	txq = &sc->sc_txq[1];
	iswep = wh->i_fc[1] & IEEE80211_FC1_WEP;
	ismcast = IEEE80211_IS_MULTICAST(wh->i_addr1);
	hdrlen = ieee80211_anyhdrsize(wh);
  90e27a:	2e163e        	s32i	a14, a1, 248
  90e27d:	5bfae4        	call8	90ce10 <ieee80211_anyhdrsize>
	pktlen = len;
	keyix = HAL_TXKEYIX_INVALID;
	pktlen -= (hdrlen & 3);
  90e280:	271230        	l32i	a7, a1, 192
  90e283:	0a0841        	extui	a8, a10, 0, 2
  90e286:	08770c        	sub	a7, a7, a8
	pktlen += IEEE80211_CRC_LEN;
  90e289:	b478      	addi.n	a8, a7, 4

	if (iswep)
  90e28b:	29123b        	l32i	a9, a1, 236
	ismcast = IEEE80211_IS_MULTICAST(wh->i_addr1);
	hdrlen = ieee80211_anyhdrsize(wh);
	pktlen = len;
	keyix = HAL_TXKEYIX_INVALID;
	pktlen -= (hdrlen & 3);
	pktlen += IEEE80211_CRC_LEN;
  90e28e:	281637        	s32i	a8, a1, 220
	bf->bf_cookie = mh->cookie;
	bf->bf_protmode = mh->flags & (IEEE80211_PROT_RTSCTS | IEEE80211_PROT_CTSONLY);
	txq = &sc->sc_txq[1];
	iswep = wh->i_fc[1] & IEEE80211_FC1_WEP;
	ismcast = IEEE80211_IS_MULTICAST(wh->i_addr1);
	hdrlen = ieee80211_anyhdrsize(wh);
  90e291:	2a163c        	s32i	a10, a1, 240
  90e294:	050540        	extui	a5, a5, 0, 1
	pktlen = len;
	keyix = HAL_TXKEYIX_INVALID;
	pktlen -= (hdrlen & 3);
	pktlen += IEEE80211_CRC_LEN;

	if (iswep)
  90e297:	2e123e        	l32i	a14, a1, 248
	txq = &sc->sc_txq[1];
	iswep = wh->i_fc[1] & IEEE80211_FC1_WEP;
	ismcast = IEEE80211_IS_MULTICAST(wh->i_addr1);
	hdrlen = ieee80211_anyhdrsize(wh);
	pktlen = len;
	keyix = HAL_TXKEYIX_INVALID;
  90e29a:	280aff        	movi	a8, 255
	pktlen -= (hdrlen & 3);
	pktlen += IEEE80211_CRC_LEN;

	if (iswep)
  90e29d:	649ca5        	beqz	a9, 90df46 <ath_tgt_send_mgt+0xde>
  90e2a0:	63fc9f        	j	90df43 <ath_tgt_send_mgt+0xdb>
	...

0090e2a4 <ath_tgt_handle_normal>:
	txq->axq_link = &lastds->ds_link;
	ah->ah_startTxDma(ah, txq->axq_qnum);
}

void ath_tgt_handle_normal(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90e2a4:	6c1004        	entry	a1, 32
	ath_atx_tid_t *tid;
	struct ath_node_target *an;

	an = (struct ath_node_target *)bf->bf_node;
  90e2a7:	243204        	l32i	a4, a3, 16
	adf_os_assert(an);
  90e2aa:	654016        	bnez	a4, 90e2c4 <ath_tgt_handle_normal+0x20>
  90e2ad:	1568bf        	l32r	a5, 8e85ac <memset+0x1764>
  90e2b0:	1b6ab4        	l32r	a11, 8e8d80 <memset+0x1f38>
  90e2b3:	255212        	l32i	a5, a5, 72
  90e2b6:	1a6aa3        	l32r	a10, 8e8d44 <memset+0x1efc>
  90e2b9:	0b5000        	callx8	a5
  90e2bc:	156923        	l32r	a5, 8e8748 <memset+0x1900>
  90e2bf:	0c0200        	memw
  90e2c2:	8550      	l32i.n	a5, a5, 0

	tid = &an->tid[bf->bf_tidno];
  90e2c4:	25304d        	l8ui	a5, a3, 77
  90e2c7:	0c5811        	slli	a8, a5, 4
  90e2ca:	05880c        	sub	a8, a8, a5
  90e2cd:	0e8811        	slli	a8, a8, 2
  90e2d0:	288c24        	addi	a8, a8, 36
  90e2d3:	084808        	add	a8, a4, a8
	adf_os_assert(tid);
  90e2d6:	658016        	bnez	a8, 90e2f0 <ath_tgt_handle_normal+0x4c>
  90e2d9:	1868bf        	l32r	a8, 8e85d8 <memset+0x1790>
  90e2dc:	1b6ab4        	l32r	a11, 8e8dac <memset+0x1f64>
  90e2df:	288212        	l32i	a8, a8, 72
  90e2e2:	1a6aa3        	l32r	a10, 8e8d70 <memset+0x1f28>
  90e2e5:	0b8000        	callx8	a8
  90e2e8:	186923        	l32r	a8, 8e8774 <memset+0x192c>
  90e2eb:	0c0200        	memw
  90e2ee:	8880      	l32i.n	a8, a8, 0

	bf->bf_comp = ath_tgt_tx_comp_normal;
  90e2f0:	186ab5        	l32r	a8, 8e8dc4 <memset+0x1f7c>
	INCR(tid->seq_start, IEEE80211_SEQ_MAX);
	ath_tgt_tx_send_normal(sc, bf);
  90e2f3:	db30      	mov.n	a11, a3
	adf_os_assert(an);

	tid = &an->tid[bf->bf_tidno];
	adf_os_assert(tid);

	bf->bf_comp = ath_tgt_tx_comp_normal;
  90e2f5:	983f      	s32i.n	a8, a3, 60
	INCR(tid->seq_start, IEEE80211_SEQ_MAX);
  90e2f7:	0c5811        	slli	a8, a5, 4
  90e2fa:	05880c        	sub	a8, a8, a5
  90e2fd:	0e8811        	slli	a8, a8, 2
  90e300:	a844      	add.n	a4, a4, a8
  90e302:	284114        	l16ui	a8, a4, 40
	ath_tgt_tx_send_normal(sc, bf);
  90e305:	da20      	mov.n	a10, a2

	tid = &an->tid[bf->bf_tidno];
	adf_os_assert(tid);

	bf->bf_comp = ath_tgt_tx_comp_normal;
	INCR(tid->seq_start, IEEE80211_SEQ_MAX);
  90e307:	b188      	addi.n	a8, a8, 1
  90e309:	08084b        	extui	a8, a8, 0, 12
  90e30c:	284514        	s16i	a8, a4, 40
	ath_tgt_tx_send_normal(sc, bf);
  90e30f:	5bfeb4        	call8	90dde0 <ath_tgt_tx_send_normal>
  90e312:	d10f      	retw.n

0090e314 <ath_tx_addto_baw>:

	return ATH_TGT_AGGR_DONE;
}

void ath_tx_addto_baw(ath_atx_tid_t *tid, struct ath_tx_buf *bf)
{
  90e314:	6c1004        	entry	a1, 32
	int index, cindex;

	if (bf->bf_isretried) {
  90e317:	283221        	l32i	a8, a3, 132
  90e31a:	7b8f3e        	bbsi	a8, 27, 90e35c <ath_tx_addto_baw+0x48>
		return;
	}

	index  = ATH_BA_INDEX(tid->seq_start, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90e31d:	283123        	l16ui	a8, a3, 70
  90e320:	232102        	l16ui	a3, a2, 4
  90e323:	084814        	srli	a8, a8, 4
	cindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);
  90e326:	8d23      	l32i.n	a13, a2, 12

	if (bf->bf_isretried) {
		return;
	}

	index  = ATH_BA_INDEX(tid->seq_start, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90e328:	03880c        	sub	a8, a8, a3
  90e32b:	08084b        	extui	a8, a8, 0, 12
	cindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);
  90e32e:	ad8c      	add.n	a12, a8, a13
  90e330:	0c0946        	extui	a9, a12, 0, 7

	TX_BUF_BITMAP_SET(tid->tx_buf_bitmap, cindex);
  90e333:	095a12        	srai	a10, a9, 5
  90e336:	0eaa11        	slli	a10, a10, 2
  90e339:	aa2a      	add.n	a10, a2, a10
  90e33b:	c0b1      	movi.n	a11, 1
  90e33d:	00c104        	ssl	a12
  90e340:	00bc1a        	sll	a12, a11
  90e343:	8ba5      	l32i.n	a11, a10, 20
  90e345:	0cbb02        	or	a11, a11, a12
  90e348:	9ba5      	s32i.n	a11, a10, 20

	if (index >= ((tid->baw_tail - tid->baw_head) & (ATH_TID_MAX_BUFS - 1))) {
  90e34a:	8a24      	l32i.n	a10, a2, 16
  90e34c:	0daa0c        	sub	a10, a10, a13
  90e34f:	0a0a46        	extui	a10, a10, 0, 7
  90e352:	7a8206        	blt	a8, a10, 90e35c <ath_tx_addto_baw+0x48>
		tid->baw_tail = cindex;
		INCR(tid->baw_tail, ATH_TID_MAX_BUFS);
  90e355:	b199      	addi.n	a9, a9, 1
  90e357:	090946        	extui	a9, a9, 0, 7
  90e35a:	9924      	s32i.n	a9, a2, 16
  90e35c:	d10f      	retw.n
	...

0090e360 <ath_tgt_handle_aggr>:
	} while (!asf_tailq_empty(&txq->axq_tidq) && !bdone);
}

void
ath_tgt_handle_aggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90e360:	6c1004        	entry	a1, 32
	ath_atx_tid_t *tid;
	struct ath_node_target *an;
	struct ath_txq *txq = bf->bf_txq;
	a_bool_t queue_frame, within_baw;

	an = (struct ath_node_target *)bf->bf_node;
  90e363:	8534      	l32i.n	a5, a3, 16
void
ath_tgt_handle_aggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	ath_atx_tid_t *tid;
	struct ath_node_target *an;
	struct ath_txq *txq = bf->bf_txq;
  90e365:	263220        	l32i	a6, a3, 128
	a_bool_t queue_frame, within_baw;

	an = (struct ath_node_target *)bf->bf_node;
	adf_os_assert(an);
  90e368:	cd55      	bnez.n	a5, 90e381 <ath_tgt_handle_aggr+0x21>
  90e36a:	1468bf        	l32r	a4, 8e8668 <memset+0x1820>
  90e36d:	1b6ab6        	l32r	a11, 8e8e48 <memset+0x2000>
  90e370:	244212        	l32i	a4, a4, 72
  90e373:	1a6aa3        	l32r	a10, 8e8e00 <memset+0x1fb8>
  90e376:	0b4000        	callx8	a4
  90e379:	146923        	l32r	a4, 8e8808 <memset+0x19c0>
  90e37c:	0c0200        	memw
  90e37f:	8440      	l32i.n	a4, a4, 0

	tid = &an->tid[bf->bf_tidno];
  90e381:	27304d        	l8ui	a7, a3, 77
  90e384:	0c7411        	slli	a4, a7, 4
  90e387:	07440c        	sub	a4, a4, a7
  90e38a:	0e4411        	slli	a4, a4, 2
  90e38d:	244c24        	addi	a4, a4, 36
  90e390:	a454      	add.n	a4, a5, a4
	adf_os_assert(tid);
  90e392:	654017        	bnez	a4, 90e3ad <ath_tgt_handle_aggr+0x4d>
  90e395:	1868bf        	l32r	a8, 8e8694 <memset+0x184c>
  90e398:	1b6ab6        	l32r	a11, 8e8e70 <memset+0x2028>
  90e39b:	288212        	l32i	a8, a8, 72
  90e39e:	1a6aa3        	l32r	a10, 8e8e2c <memset+0x1fe4>
  90e3a1:	0b8000        	callx8	a8
  90e3a4:	186923        	l32r	a8, 8e8830 <memset+0x19e8>
  90e3a7:	0c0200        	memw
  90e3aa:	288200        	l32i	a8, a8, 0

	bf->bf_comp = ath_tgt_tx_comp_aggr;
  90e3ad:	186ab7        	l32r	a8, 8e8e8c <memset+0x2044>
  90e3b0:	0c7a11        	slli	a10, a7, 4
  90e3b3:	983f      	s32i.n	a8, a3, 60
	within_baw = BAW_WITHIN(tid->seq_start, tid->baw_size,
				SEQNO_FROM_BF_SEQNO(bf->bf_seqno));

	queue_frame = ( (txq->axq_depth >= ATH_AGGR_MIN_QDEPTH) ||
			(!asf_tailq_empty(&tid->buf_q)) ||
			(tid->paused) || (!within_baw) );
  90e3b5:	8864      	l32i.n	a8, a6, 16
  90e3b7:	ce8d      	bnez.n	a8, 90e3e8 <ath_tgt_handle_aggr+0x88>

	within_baw = BAW_WITHIN(tid->seq_start, tid->baw_size,
				SEQNO_FROM_BF_SEQNO(bf->bf_seqno));

	queue_frame = ( (txq->axq_depth >= ATH_AGGR_MIN_QDEPTH) ||
			(!asf_tailq_empty(&tid->buf_q)) ||
  90e3b9:	07a80c        	sub	a8, a10, a7
  90e3bc:	0e8811        	slli	a8, a8, 2
  90e3bf:	a858      	add.n	a8, a5, a8
	bf->bf_comp = ath_tgt_tx_comp_aggr;

	within_baw = BAW_WITHIN(tid->seq_start, tid->baw_size,
				SEQNO_FROM_BF_SEQNO(bf->bf_seqno));

	queue_frame = ( (txq->axq_depth >= ATH_AGGR_MIN_QDEPTH) ||
  90e3c1:	2b8214        	l32i	a11, a8, 80
  90e3c4:	ceb0      	bnez.n	a11, 90e3e8 <ath_tgt_handle_aggr+0x88>
	tid = &an->tid[bf->bf_tidno];
	adf_os_assert(tid);

	bf->bf_comp = ath_tgt_tx_comp_aggr;

	within_baw = BAW_WITHIN(tid->seq_start, tid->baw_size,
  90e3c6:	293123        	l16ui	a9, a3, 70
  90e3c9:	2c8114        	l16ui	a12, a8, 40
  90e3cc:	094914        	srli	a9, a9, 4
  90e3cf:	0c990c        	sub	a9, a9, a12
  90e3d2:	2c8116        	l16ui	a12, a8, 44
  90e3d5:	09094b        	extui	a9, a9, 0, 12
				SEQNO_FROM_BF_SEQNO(bf->bf_seqno));

	queue_frame = ( (txq->axq_depth >= ATH_AGGR_MIN_QDEPTH) ||
			(!asf_tailq_empty(&tid->buf_q)) ||
			(tid->paused) || (!within_baw) );
  90e3d8:	7c9a0c        	bge	a9, a12, 90e3e8 <ath_tgt_handle_aggr+0x88>

	within_baw = BAW_WITHIN(tid->seq_start, tid->baw_size,
				SEQNO_FROM_BF_SEQNO(bf->bf_seqno));

	queue_frame = ( (txq->axq_depth >= ATH_AGGR_MIN_QDEPTH) ||
			(!asf_tailq_empty(&tid->buf_q)) ||
  90e3db:	288058        	l8ui	a8, a8, 88
  90e3de:	c091      	movi.n	a9, 1
  90e3e0:	089b39        	movnez	a11, a9, a8
			(tid->paused) || (!within_baw) );
  90e3e3:	0b0847        	extui	a8, a11, 0, 8
  90e3e6:	ca84      	beqz.n	a8, 90e40e <ath_tgt_handle_aggr+0xae>

	if (queue_frame) {
		asf_tailq_insert_tail(&tid->buf_q, bf, bf_list);
  90e3e8:	07a80c        	sub	a8, a10, a7
  90e3eb:	0e8811        	slli	a8, a8, 2
  90e3ee:	a858      	add.n	a8, a5, a8
  90e3f0:	c020      	movi.n	a2, 0
  90e3f2:	9239      	s32i.n	a2, a3, 36
  90e3f4:	228215        	l32i	a2, a8, 84
		ath_tgt_tx_enqueue(txq, tid);
  90e3f7:	db40      	mov.n	a11, a4
	queue_frame = ( (txq->axq_depth >= ATH_AGGR_MIN_QDEPTH) ||
			(!asf_tailq_empty(&tid->buf_q)) ||
			(tid->paused) || (!within_baw) );

	if (queue_frame) {
		asf_tailq_insert_tail(&tid->buf_q, bf, bf_list);
  90e3f9:	923a      	s32i.n	a2, a3, 40
  90e3fb:	9320      	s32i.n	a3, a2, 0
  90e3fd:	233c24        	addi	a3, a3, 36
  90e400:	238615        	s32i	a3, a8, 84
		ath_tgt_tx_enqueue(txq, tid);
  90e403:	2a6c1c        	addi	a10, a6, 28
  90e406:	5bfafc        	call8	90cff8 <ath_tgt_tx_enqueue$isra$3>
  90e409:	d10f      	retw.n
  90e40b:	000000        	ill
	} else {
		ath_tx_addto_baw(tid, bf);
  90e40e:	db30      	mov.n	a11, a3
  90e410:	da40      	mov.n	a10, a4
  90e412:	5bffc0        	call8	90e314 <ath_tx_addto_baw>
		__stats(sc, txaggr_nframes);
  90e415:	24225d        	l32i	a4, a2, 0x174
		ath_tgt_tx_send_normal(sc, bf);
  90e418:	db30      	mov.n	a11, a3
	if (queue_frame) {
		asf_tailq_insert_tail(&tid->buf_q, bf, bf_list);
		ath_tgt_tx_enqueue(txq, tid);
	} else {
		ath_tx_addto_baw(tid, bf);
		__stats(sc, txaggr_nframes);
  90e41a:	b144      	addi.n	a4, a4, 1
  90e41c:	24265d        	s32i	a4, a2, 0x174
		ath_tgt_tx_send_normal(sc, bf);
  90e41f:	da20      	mov.n	a10, a2
  90e421:	5bfe6f        	call8	90dde0 <ath_tgt_tx_send_normal>
  90e424:	d10f      	retw.n
	...

0090e428 <ath_tgt_tx_form_aggr>:
	return aggr_limit;
}

int ath_tgt_tx_form_aggr(struct ath_softc_tgt *sc, ath_atx_tid_t *tid,
			 ath_tx_bufhead *bf_q)
{
  90e428:	6c100c        	entry	a1, 96
  90e42b:	d630      	mov.n	a6, a3
	struct ath_tx_buf *bf_first ,*bf_prev = NULL;
	int nframes = 0, rl = 0;;
	struct ath_tx_desc *ds = NULL;
	struct ath_tx_buf *bf;
	struct ath_hal *ah = sc->sc_ah;
  90e42d:	232d05        	addmi	a3, a2, 0x500
  90e430:	833b      	l32i.n	a3, a3, 44
	return aggr_limit;
}

int ath_tgt_tx_form_aggr(struct ath_softc_tgt *sc, ath_atx_tid_t *tid,
			 ath_tx_bufhead *bf_q)
{
  90e432:	921b      	s32i.n	a2, a1, 44
	struct ath_tx_buf *bf_first ,*bf_prev = NULL;
	int nframes = 0, rl = 0;;
	struct ath_tx_desc *ds = NULL;
	struct ath_tx_buf *bf;
	struct ath_hal *ah = sc->sc_ah;
  90e434:	931e      	s32i.n	a3, a1, 56
	u_int16_t aggr_limit =  (64*1024 -1), al = 0, bpad = 0, al_delta;
	u_int16_t h_baw = tid->baw_size/2, prev_al = 0, prev_frames = 0;
  90e436:	236104        	l16ui	a3, a6, 8
	struct ath_tx_buf *bf_first ,*bf_prev = NULL;
	int nframes = 0, rl = 0;;
	struct ath_tx_desc *ds = NULL;
	struct ath_tx_buf *bf;
	struct ath_hal *ah = sc->sc_ah;
	u_int16_t aggr_limit =  (64*1024 -1), al = 0, bpad = 0, al_delta;
  90e439:	1269b0        	l32r	a2, 8e8afc <memset+0x1cb4>
	u_int16_t h_baw = tid->baw_size/2, prev_al = 0, prev_frames = 0;
  90e43c:	031314        	srli	a3, a3, 1
	struct ath_tx_buf *bf_first ,*bf_prev = NULL;
	int nframes = 0, rl = 0;;
	struct ath_tx_desc *ds = NULL;
	struct ath_tx_buf *bf;
	struct ath_hal *ah = sc->sc_ah;
	u_int16_t aggr_limit =  (64*1024 -1), al = 0, bpad = 0, al_delta;
  90e43f:	c050      	movi.n	a5, 0
	u_int16_t h_baw = tid->baw_size/2, prev_al = 0, prev_frames = 0;
  90e441:	931a      	s32i.n	a3, a1, 40

	bf_first = asf_tailq_first(&tid->buf_q);
  90e443:	836b      	l32i.n	a3, a6, 44
	return aggr_limit;
}

int ath_tgt_tx_form_aggr(struct ath_softc_tgt *sc, ath_atx_tid_t *tid,
			 ath_tx_bufhead *bf_q)
{
  90e445:	941d      	s32i.n	a4, a1, 52
	struct ath_tx_buf *bf_first ,*bf_prev = NULL;
	int nframes = 0, rl = 0;;
	struct ath_tx_desc *ds = NULL;
	struct ath_tx_buf *bf;
	struct ath_hal *ah = sc->sc_ah;
	u_int16_t aggr_limit =  (64*1024 -1), al = 0, bpad = 0, al_delta;
  90e447:	921c      	s32i.n	a2, a1, 48
  90e449:	d450      	mov.n	a4, a5

int ath_tgt_tx_form_aggr(struct ath_softc_tgt *sc, ath_atx_tid_t *tid,
			 ath_tx_bufhead *bf_q)
{
	struct ath_tx_buf *bf_first ,*bf_prev = NULL;
	int nframes = 0, rl = 0;;
  90e44b:	dd50      	mov.n	a13, a5
  90e44d:	9518      	s32i.n	a5, a1, 32
}

int ath_tgt_tx_form_aggr(struct ath_softc_tgt *sc, ath_atx_tid_t *tid,
			 ath_tx_bufhead *bf_q)
{
	struct ath_tx_buf *bf_first ,*bf_prev = NULL;
  90e44f:	9519      	s32i.n	a5, a1, 36
	u_int16_t h_baw = tid->baw_size/2, prev_al = 0, prev_frames = 0;

	bf_first = asf_tailq_first(&tid->buf_q);

	do {
		bf = asf_tailq_first(&tid->buf_q);
  90e451:	826b      	l32i.n	a2, a6, 44
		adf_os_assert(bf);
  90e453:	65201d        	bnez	a2, 90e474 <ath_tgt_tx_form_aggr+0x4c>
  90e456:	1a68bf        	l32r	a10, 8e8754 <memset+0x190c>
  90e459:	1b6ab8        	l32r	a11, 8e8f3c <memset+0x20f4>
  90e45c:	2ca212        	l32i	a12, a10, 72
  90e45f:	1a6aa3        	l32r	a10, 8e8eec <memset+0x20a4>
  90e462:	2d160f        	s32i	a13, a1, 60
  90e465:	0bc000        	callx8	a12
  90e468:	1a6923        	l32r	a10, 8e88f4 <memset+0x1aac>
  90e46b:	2d120f        	l32i	a13, a1, 60
  90e46e:	0c0200        	memw
  90e471:	2aa200        	l32i	a10, a10, 0

		if (!BAW_WITHIN(tid->seq_start, tid->baw_size,
  90e474:	2a2123        	l16ui	a10, a2, 70
  90e477:	2b6102        	l16ui	a11, a6, 4
  90e47a:	0a4a14        	srli	a10, a10, 4
  90e47d:	0baa0c        	sub	a10, a10, a11
  90e480:	2b6104        	l16ui	a11, a6, 8
  90e483:	0a0a4b        	extui	a10, a10, 0, 12
  90e486:	7ba20b        	blt	a10, a11, 90e495 <ath_tgt_tx_form_aggr+0x6d>
				SEQNO_FROM_BF_SEQNO(bf->bf_seqno))) {

			bf_first->bf_al= al;
			bf_first->bf_nframes = nframes;
  90e489:	8818      	l32i.n	a8, a1, 32
		adf_os_assert(bf);

		if (!BAW_WITHIN(tid->seq_start, tid->baw_size,
				SEQNO_FROM_BF_SEQNO(bf->bf_seqno))) {

			bf_first->bf_al= al;
  90e48b:	243527        	s16i	a4, a3, 78
			bf_first->bf_nframes = nframes;
  90e48e:	28344c        	s8i	a8, a3, 76
			return ATH_TGT_AGGR_BAW_CLOSED;
  90e491:	c021      	movi.n	a2, 1
  90e493:	d10f      	retw.n
		}

		if (!rl) {
  90e495:	65d0b4        	bnez	a13, 90e54d <ath_tgt_tx_form_aggr+0x125>
				 struct ath_tx_buf *bf)
{
	int i, prate;
	u_int32_t max4msframelen, frame_length;
	u_int16_t aggr_limit, legacy=0;
	const HAL_RATE_TABLE  *rt = sc->sc_currates;
  90e498:	881b      	l32i.n	a8, a1, 44
	struct ieee80211_node_target *ieee_node = (struct ieee80211_node_target *)an;

	if (bf->bf_ismcast) {
  90e49a:	2a2221        	l32i	a10, a2, 132
				 struct ath_tx_buf *bf)
{
	int i, prate;
	u_int32_t max4msframelen, frame_length;
	u_int16_t aggr_limit, legacy=0;
	const HAL_RATE_TABLE  *rt = sc->sc_currates;
  90e49d:	288281        	l32i	a8, a8, 0x204
			bf_first->bf_nframes = nframes;
			return ATH_TGT_AGGR_BAW_CLOSED;
		}

		if (!rl) {
			aggr_limit = ath_lookup_rate(sc, tid->an, bf);
  90e4a0:	876e      	l32i.n	a7, a6, 56
				 struct ath_tx_buf *bf)
{
	int i, prate;
	u_int32_t max4msframelen, frame_length;
	u_int16_t aggr_limit, legacy=0;
	const HAL_RATE_TABLE  *rt = sc->sc_currates;
  90e4a2:	981c      	s32i.n	a8, a1, 48
	struct ieee80211_node_target *ieee_node = (struct ieee80211_node_target *)an;

	if (bf->bf_ismcast) {
  90e4a4:	78a719        	bbci	a10, 24, 90e4c1 <ath_tgt_tx_form_aggr+0x99>
		bf->bf_rcs[1].tries = bf->bf_rcs[2].tries = bf->bf_rcs[3].tries = 0;
		bf->bf_rcs[0].rix   = 0xb;
  90e4a7:	c0ab      	movi.n	a10, 11
  90e4a9:	2a2450        	s8i	a10, a2, 80
		bf->bf_rcs[0].tries = ATH_TXMAXTRY - 1;
  90e4ac:	c0aa      	movi.n	a10, 10
	u_int16_t aggr_limit, legacy=0;
	const HAL_RATE_TABLE  *rt = sc->sc_currates;
	struct ieee80211_node_target *ieee_node = (struct ieee80211_node_target *)an;

	if (bf->bf_ismcast) {
		bf->bf_rcs[1].tries = bf->bf_rcs[2].tries = bf->bf_rcs[3].tries = 0;
  90e4ae:	2d2475        	s8i	a13, a2, 117
  90e4b1:	2d2469        	s8i	a13, a2, 105
  90e4b4:	2d245d        	s8i	a13, a2, 93
		bf->bf_rcs[0].rix   = 0xb;
		bf->bf_rcs[0].tries = ATH_TXMAXTRY - 1;
  90e4b7:	2a2451        	s8i	a10, a2, 81
		bf->bf_rcs[0].flags = 0;
  90e4ba:	2d2453        	s8i	a13, a2, 83
  90e4bd:	60001c        	j	90e4dd <ath_tgt_tx_form_aggr+0xb5>
  90e4c0:	002a1c        	mul16u	a10, a2, a0
				  a_int32_t stepDnInc,
				  a_uint32_t rcflag,
				  struct ath_rc_series series[],
				  a_int32_t *isProbe)
{
	ath_rate_findrate(sc, an, 1, frameLen, 10, 4, 1,
  90e4c3:	109a13        	l32r	a0, 8f4d10 <memset+0xdec8>
		bf->bf_rcs[0].rix   = 0xb;
		bf->bf_rcs[0].tries = ATH_TXMAXTRY - 1;
		bf->bf_rcs[0].flags = 0;
	} else {
		ath_tgt_rate_findrate(sc, an, AH_TRUE, 0, ATH_TXMAXTRY-1, 4, 1,
				      ATH_RC_PROBE_ALLOWED, bf->bf_rcs, &prate);
  90e4c6:	2a2c50        	addi	a10, a2, 80
				  a_int32_t stepDnInc,
				  a_uint32_t rcflag,
				  struct ath_rc_series series[],
				  a_int32_t *isProbe)
{
	ath_rate_findrate(sc, an, 1, frameLen, 10, 4, 1,
  90e4c9:	c0c1      	movi.n	a12, 1
  90e4cb:	9a12      	s32i.n	a10, a1, 8
  90e4cd:	8a1b      	l32i.n	a10, a1, 44
  90e4cf:	9c11      	s32i.n	a12, a1, 4
  90e4d1:	9c10      	s32i.n	a12, a1, 0
  90e4d3:	c0f4      	movi.n	a15, 4
  90e4d5:	c0ea      	movi.n	a14, 10
  90e4d7:	077b02        	or	a11, a7, a7
  90e4da:	5bfa1c        	call8	90cd4c <ath_rate_findrate>
}

int ath_tgt_tx_form_aggr(struct ath_softc_tgt *sc, ath_atx_tid_t *tid,
			 ath_tx_bufhead *bf_q)
{
	struct ath_tx_buf *bf_first ,*bf_prev = NULL;
  90e4dd:	1d69b0        	l32r	a13, 8e8ba0 <memset+0x1d58>
  90e4e0:	2a2c50        	addi	a10, a2, 80
  90e4e3:	2c0a04        	movi	a12, 4
  90e4e6:	6dc820        	loop	a12, 90e50a <ath_tgt_tx_form_aggr+0xe2>
	}

	max4msframelen = IEEE80211_AMPDU_LIMIT_MAX;

	for (i = 0; i < 4; i++) {
		if (bf->bf_rcs[i].tries) {
  90e4e9:	2ba001        	l8ui	a11, a10, 1
  90e4ec:	c9b8      	beqz.n	a11, 90e508 <ath_tgt_tx_form_aggr+0xe0>
			frame_length = bf->bf_rcs[i].max4msframelen;

			if (rt->info[bf->bf_rcs[i].rix].phy != IEEE80211_T_HT) {
  90e4ee:	2fa000        	l8ui	a15, a10, 0
  90e4f1:	881c      	l32i.n	a8, a1, 48
  90e4f3:	0efb11        	slli	a11, a15, 2
  90e4f6:	afbb      	add.n	a11, a11, a15
  90e4f8:	0ebb11        	slli	a11, a11, 2
  90e4fb:	ab8b      	add.n	a11, a8, a11
  90e4fd:	2bb029        	l8ui	a11, a11, 41

	max4msframelen = IEEE80211_AMPDU_LIMIT_MAX;

	for (i = 0; i < 4; i++) {
		if (bf->bf_rcs[i].tries) {
			frame_length = bf->bf_rcs[i].max4msframelen;
  90e500:	8ea1      	l32i.n	a14, a10, 4

			if (rt->info[bf->bf_rcs[i].rix].phy != IEEE80211_T_HT) {
  90e502:	69b40a        	bnei	a11, 4, 90e510 <ath_tgt_tx_form_aggr+0xe8>
				legacy = 1;
				break;
			}

			max4msframelen = ATH_MIN(max4msframelen, frame_length);
  90e505:	0edd36        	minu	a13, a13, a14
  90e508:	bcaa      	addi.n	a10, a10, 12
				 struct ath_node_target *an,
				 struct ath_tx_buf *bf)
{
	int i, prate;
	u_int32_t max4msframelen, frame_length;
	u_int16_t aggr_limit, legacy=0;
  90e50a:	c0a0      	movi.n	a10, 0
  90e50c:	600002        	j	90e512 <ath_tgt_tx_form_aggr+0xea>
  90e50f:	00c0a1        	excw

			max4msframelen = ATH_MIN(max4msframelen, frame_length);
		}
	}

	if (prate || legacy)
  90e512:	8b14      	l32i.n	a11, a1, 16
  90e514:	cebe      	bnez.n	a11, 90e546 <ath_tgt_tx_form_aggr+0x11e>
  90e516:	ceac      	bnez.n	a10, 90e546 <ath_tgt_tx_form_aggr+0x11e>
		return 0;

	if (sc->sc_ic.ic_enable_coex)
  90e518:	881b      	l32i.n	a8, a1, 44
  90e51a:	2a8d16        	addmi	a10, a8, 0x1600
  90e51d:	8ca8      	l32i.n	a12, a10, 32
  90e51f:	2ea025        	l8ui	a14, a10, 37
		aggr_limit = ATH_MIN((max4msframelen*3)/8, sc->sc_ic.ic_ampdu_limit);
	else
		aggr_limit = ATH_MIN(max4msframelen, sc->sc_ic.ic_ampdu_limit);
  90e522:	0cdb36        	minu	a11, a13, a12
  90e525:	0b0a4f        	extui	a10, a11, 0, 16
	}

	if (prate || legacy)
		return 0;

	if (sc->sc_ic.ic_enable_coex)
  90e528:	c8ec      	beqz.n	a14, 90e538 <ath_tgt_tx_form_aggr+0x110>
		aggr_limit = ATH_MIN((max4msframelen*3)/8, sc->sc_ic.ic_ampdu_limit);
  90e52a:	0fda11        	slli	a10, a13, 1
  90e52d:	adaa      	add.n	a10, a10, a13
  90e52f:	0a3a14        	srli	a10, a10, 3
  90e532:	0caa36        	minu	a10, a10, a12
  90e535:	0a0a4f        	extui	a10, a10, 0, 16
	else
		aggr_limit = ATH_MIN(max4msframelen, sc->sc_ic.ic_ampdu_limit);

	if (ieee_node->ni_maxampdu)
  90e538:	27710a        	l16ui	a7, a7, 20
		aggr_limit = ATH_MIN(aggr_limit, ieee_node->ni_maxampdu);
  90e53b:	0a7b36        	minu	a11, a7, a10
  90e53e:	07ba39        	movnez	a10, a11, a7
  90e541:	d7a0      	mov.n	a7, a10
  90e543:	600001        	j	90e548 <ath_tgt_tx_form_aggr+0x120>
			max4msframelen = ATH_MIN(max4msframelen, frame_length);
		}
	}

	if (prate || legacy)
		return 0;
  90e546:	c070      	movi.n	a7, 0
			bf_first->bf_nframes = nframes;
			return ATH_TGT_AGGR_BAW_CLOSED;
		}

		if (!rl) {
			aggr_limit = ath_lookup_rate(sc, tid->an, bf);
  90e548:	07084f        	extui	a8, a7, 0, 16
  90e54b:	981c      	s32i.n	a8, a1, 48
			rl = 1;
		}

		al_delta = ATH_AGGR_DELIM_SZ + bf->bf_pktlen;
  90e54d:	2c2122        	l16ui	a12, a2, 68

		if (nframes && (aggr_limit < (al + bpad + al_delta + prev_al))) {
  90e550:	8818      	l32i.n	a8, a1, 32
		if (!rl) {
			aggr_limit = ath_lookup_rate(sc, tid->an, bf);
			rl = 1;
		}

		al_delta = ATH_AGGR_DELIM_SZ + bf->bf_pktlen;
  90e552:	b4cc      	addi.n	a12, a12, 4
  90e554:	0c074f        	extui	a7, a12, 0, 16

		if (nframes && (aggr_limit < (al + bpad + al_delta + prev_al))) {
  90e557:	648133        	beqz	a8, 90e68e <ath_tgt_tx_form_aggr+0x266>
  90e55a:	a54a      	add.n	a10, a4, a5
  90e55c:	881c      	l32i.n	a8, a1, 48
  90e55e:	a7aa      	add.n	a10, a10, a7
  90e560:	7a8a0a        	bge	a8, a10, 90e56e <ath_tgt_tx_form_aggr+0x146>
			bf_first->bf_al= al;
			bf_first->bf_nframes = nframes;
  90e563:	8218      	l32i.n	a2, a1, 32
		}

		al_delta = ATH_AGGR_DELIM_SZ + bf->bf_pktlen;

		if (nframes && (aggr_limit < (al + bpad + al_delta + prev_al))) {
			bf_first->bf_al= al;
  90e565:	243527        	s16i	a4, a3, 78
			bf_first->bf_nframes = nframes;
  90e568:	22344c        	s8i	a2, a3, 76
  90e56b:	60001a        	j	90e589 <ath_tgt_tx_form_aggr+0x161>
		}

#ifdef PROJECT_K2
		if ((nframes + prev_frames) >= ATH_MIN((h_baw), 17)) {
#else
		if ((nframes + prev_frames) >= ATH_MIN((h_baw), 22)) {
  90e56e:	881a      	l32i.n	a8, a1, 40
  90e570:	c1b5      	movi.n	a11, 21
  90e572:	c1a6      	movi.n	a10, 22
  90e574:	78b306        	bltu	a11, a8, 90e57e <ath_tgt_tx_form_aggr+0x156>
  90e577:	da80      	mov.n	a10, a8
  90e579:	600001        	j	90e57e <ath_tgt_tx_form_aggr+0x156>
  90e57c:	8a1a      	l32i.n	a10, a1, 40
  90e57e:	8818      	l32i.n	a8, a1, 32
  90e580:	7a8209        	blt	a8, a10, 90e58d <ath_tgt_tx_form_aggr+0x165>
#endif
			bf_first->bf_al= al;
  90e583:	243527        	s16i	a4, a3, 78
			bf_first->bf_nframes = nframes;
  90e586:	28344c        	s8i	a8, a3, 76
			return ATH_TGT_AGGR_LIMITED;
  90e589:	c022      	movi.n	a2, 2
  90e58b:	d10f      	retw.n
		}

		ath_tx_addto_baw(tid, bf);
  90e58d:	db20      	mov.n	a11, a2
  90e58f:	da60      	mov.n	a10, a6
  90e591:	5bff60        	call8	90e314 <ath_tx_addto_baw>
		asf_tailq_remove(&tid->buf_q, bf, bf_list);
  90e594:	8a29      	l32i.n	a10, a2, 36
  90e596:	8b2a      	l32i.n	a11, a2, 40
  90e598:	c8a4      	beqz.n	a10, 90e5a0 <ath_tgt_tx_form_aggr+0x178>
  90e59a:	9baa      	s32i.n	a11, a10, 40
  90e59c:	600002        	j	90e5a2 <ath_tgt_tx_form_aggr+0x17a>
  90e59f:	009b6c        	excw
  90e5a2:	8b2a      	l32i.n	a11, a2, 40
		asf_tailq_insert_tail(bf_q, bf, bf_list);
  90e5a4:	881d      	l32i.n	a8, a1, 52
			bf_first->bf_nframes = nframes;
			return ATH_TGT_AGGR_LIMITED;
		}

		ath_tx_addto_baw(tid, bf);
		asf_tailq_remove(&tid->buf_q, bf, bf_list);
  90e5a6:	9ab0      	s32i.n	a10, a11, 0
		asf_tailq_insert_tail(bf_q, bf, bf_list);
  90e5a8:	c0a0      	movi.n	a10, 0
  90e5aa:	9a29      	s32i.n	a10, a2, 36
  90e5ac:	8a81      	l32i.n	a10, a8, 4
		nframes ++;

		adf_os_assert(bf);

		adf_os_assert(bf->bf_comp == ath_tgt_tx_comp_aggr);
  90e5ae:	8b2f      	l32i.n	a11, a2, 60
			return ATH_TGT_AGGR_LIMITED;
		}

		ath_tx_addto_baw(tid, bf);
		asf_tailq_remove(&tid->buf_q, bf, bf_list);
		asf_tailq_insert_tail(bf_q, bf, bf_list);
  90e5b0:	9a2a      	s32i.n	a10, a2, 40
  90e5b2:	92a0      	s32i.n	a2, a10, 0
  90e5b4:	2a2c24        	addi	a10, a2, 36
  90e5b7:	9a81      	s32i.n	a10, a8, 4
		nframes ++;
  90e5b9:	8818      	l32i.n	a8, a1, 32

		adf_os_assert(bf);

		adf_os_assert(bf->bf_comp == ath_tgt_tx_comp_aggr);
  90e5bb:	1a6ab7        	l32r	a10, 8e9098 <memset+0x2250>
		}

		ath_tx_addto_baw(tid, bf);
		asf_tailq_remove(&tid->buf_q, bf, bf_list);
		asf_tailq_insert_tail(bf_q, bf, bf_list);
		nframes ++;
  90e5be:	b188      	addi.n	a8, a8, 1
  90e5c0:	281608        	s32i	a8, a1, 32

		adf_os_assert(bf);

		adf_os_assert(bf->bf_comp == ath_tgt_tx_comp_aggr);
  90e5c3:	7ab116        	beq	a11, a10, 90e5dd <ath_tgt_tx_form_aggr+0x1b5>
  90e5c6:	1a68bf        	l32r	a10, 8e88c4 <memset+0x1a7c>
  90e5c9:	1b6ab8        	l32r	a11, 8e90ac <memset+0x2264>
  90e5cc:	2da212        	l32i	a13, a10, 72
  90e5cf:	1a6aa3        	l32r	a10, 8e905c <memset+0x2214>
  90e5d2:	0bd000        	callx8	a13
  90e5d5:	1a6923        	l32r	a10, 8e8a64 <memset+0x1c1c>
  90e5d8:	0c0200        	memw
  90e5db:	8aa0      	l32i.n	a10, a10, 0
  90e5dd:	a544      	add.n	a4, a4, a5

		al += bpad + al_delta;
		bf->bf_ndelim = ATH_AGGR_GET_NDELIM(bf->bf_pktlen);
  90e5df:	252122        	l16ui	a5, a2, 68

		adf_os_assert(bf);

		adf_os_assert(bf->bf_comp == ath_tgt_tx_comp_aggr);

		al += bpad + al_delta;
  90e5e2:	a744      	add.n	a4, a4, a7
		bf->bf_ndelim = ATH_AGGR_GET_NDELIM(bf->bf_pktlen);
  90e5e4:	2b0afb        	movi	a11, 251

		adf_os_assert(bf);

		adf_os_assert(bf->bf_comp == ath_tgt_tx_comp_aggr);

		al += bpad + al_delta;
  90e5e7:	04044f        	extui	a4, a4, 0, 16
  90e5ea:	c0a0      	movi.n	a10, 0
		bf->bf_ndelim = ATH_AGGR_GET_NDELIM(bf->bf_pktlen);
  90e5ec:	75b208        	blt	a11, a5, 90e5f8 <ath_tgt_tx_form_aggr+0x1d0>
  90e5ef:	2a0afc        	movi	a10, 252
  90e5f2:	05aa0c        	sub	a10, a10, a5
  90e5f5:	0a2a12        	srai	a10, a10, 2
  90e5f8:	0a0a47        	extui	a10, a10, 0, 8

		switch (bf->bf_keytype) {
  90e5fb:	252085        	l8ui	a5, a2, 133
		adf_os_assert(bf);

		adf_os_assert(bf->bf_comp == ath_tgt_tx_comp_aggr);

		al += bpad + al_delta;
		bf->bf_ndelim = ATH_AGGR_GET_NDELIM(bf->bf_pktlen);
  90e5fe:	2a244b        	s8i	a10, a2, 75

		switch (bf->bf_keytype) {
  90e601:	685213        	beqi	a5, 2, 90e618 <ath_tgt_tx_form_aggr+0x1f0>
  90e604:	6f5305        	bgeui	a5, 3, 90e60d <ath_tgt_tx_form_aggr+0x1e5>
  90e607:	685112        	beqi	a5, 1, 90e61d <ath_tgt_tx_form_aggr+0x1f5>
  90e60a:	60001a        	j	90e628 <ath_tgt_tx_form_aggr+0x200>
  90e60d:	68530c        	beqi	a5, 3, 90e61d <ath_tgt_tx_form_aggr+0x1f5>
		case HAL_KEY_TYPE_WEP:
		case HAL_KEY_TYPE_TKIP:
			bf->bf_ndelim += 64;
			break;
		case HAL_KEY_TYPE_WAPI:
			bf->bf_ndelim += 12;
  90e610:	bcaa      	addi.n	a10, a10, 12
		adf_os_assert(bf->bf_comp == ath_tgt_tx_comp_aggr);

		al += bpad + al_delta;
		bf->bf_ndelim = ATH_AGGR_GET_NDELIM(bf->bf_pktlen);

		switch (bf->bf_keytype) {
  90e612:	68540f        	beqi	a5, 4, 90e625 <ath_tgt_tx_form_aggr+0x1fd>
  90e615:	60000f        	j	90e628 <ath_tgt_tx_form_aggr+0x200>
		case HAL_KEY_TYPE_AES:
			bf->bf_ndelim += ATH_AGGR_ENCRYPTDELIM;
  90e618:	baaa      	addi.n	a10, a10, 10
  90e61a:	600007        	j	90e625 <ath_tgt_tx_form_aggr+0x1fd>
			break;
		case HAL_KEY_TYPE_WEP:
		case HAL_KEY_TYPE_TKIP:
			bf->bf_ndelim += 64;
  90e61d:	2aac40        	addi	a10, a10, 64
  90e620:	600001        	j	90e625 <ath_tgt_tx_form_aggr+0x1fd>
  90e623:	00002a        	muluh	a0, a0, a0
			break;
		case HAL_KEY_TYPE_WAPI:
			bf->bf_ndelim += 12;
  90e626:	244b25        	l32ai	a4, a4, 148
			break;
		default:
			break;
		}

		bpad = PADBYTES(al_delta) + (bf->bf_ndelim << 2);
  90e629:	204b07        	l32ai	a0, a4, 28
  90e62c:	0c0688        	excw

		if (bf_prev) {
  90e62f:	190c0c        	l32r	a9, 8d1660 <_bss_end+0x3be750>
			break;
		default:
			break;
		}

		bpad = PADBYTES(al_delta) + (bf->bf_ndelim << 2);
  90e632:	410e55        	excw
  90e635:	11a5c5        	l32r	a1, 8f7d4c <memset+0x10f04>
  90e638:	8c2c      	l32i.n	a12, a2, 48

		if (bf_prev) {
  90e63a:	c98a      	beqz.n	a8, 90e658 <ath_tgt_tx_form_aggr+0x230>
			bf_prev->bf_next = bf;
			bf_prev->bf_lastds->ds_link = ATH_BUF_GET_DESC_PHY_ADDR(bf);
  90e63c:	8a8e      	l32i.n	a10, a8, 56
		}

		bpad = PADBYTES(al_delta) + (bf->bf_ndelim << 2);

		if (bf_prev) {
			bf_prev->bf_next = bf;
  90e63e:	928b      	s32i.n	a2, a8, 44
			bf_prev->bf_lastds->ds_link = ATH_BUF_GET_DESC_PHY_ADDR(bf);
  90e640:	0c8b57        	extui	a11, a12, 24, 8
  90e643:	2ba400        	s8i	a11, a10, 0
  90e646:	2b2031        	l8ui	a11, a2, 49
  90e649:	2ba401        	s8i	a11, a10, 1
  90e64c:	2b2032        	l8ui	a11, a2, 50
  90e64f:	2ba402        	s8i	a11, a10, 2
  90e652:	2b2033        	l8ui	a11, a2, 51
  90e655:	2ba403        	s8i	a11, a10, 3
		}
		bf_prev = bf;

		for(ds = bf->bf_desc; ds <= bf->bf_lastds; ds++)
  90e658:	d7c0      	mov.n	a7, a12
  90e65a:	2d0a88        	movi	a13, 136
  90e65d:	600013        	j	90e674 <ath_tgt_tx_form_aggr+0x24c>
  90e660:	00881e        	excw
			ah->ah_set11nAggrMiddle(ds, bf->bf_ndelim);
  90e663:	2b204b        	l8ui	a11, a2, 75
  90e666:	2e8212        	l32i	a14, a8, 72
  90e669:	da70      	mov.n	a10, a7
  90e66b:	9d1f      	s32i.n	a13, a1, 60
  90e66d:	0be000        	callx8	a14
			bf_prev->bf_next = bf;
			bf_prev->bf_lastds->ds_link = ATH_BUF_GET_DESC_PHY_ADDR(bf);
		}
		bf_prev = bf;

		for(ds = bf->bf_desc; ds <= bf->bf_lastds; ds++)
  90e670:	8d1f      	l32i.n	a13, a1, 60
  90e672:	ad77      	add.n	a7, a7, a13
  90e674:	8a2e      	l32i.n	a10, a2, 56
  90e676:	77abe7        	bgeu	a10, a7, 90e661 <ath_tgt_tx_form_aggr+0x239>
			ah->ah_set11nAggrMiddle(ds, bf->bf_ndelim);

	} while (!asf_tailq_empty(&tid->buf_q));
  90e679:	886b      	l32i.n	a8, a6, 44
  90e67b:	9219      	s32i.n	a2, a1, 36
  90e67d:	c0d1      	movi.n	a13, 1
  90e67f:	658dce        	bnez	a8, 90e451 <ath_tgt_tx_form_aggr+0x29>

	bf_first->bf_al= al;
	bf_first->bf_nframes = nframes;
  90e682:	8218      	l32i.n	a2, a1, 32
		for(ds = bf->bf_desc; ds <= bf->bf_lastds; ds++)
			ah->ah_set11nAggrMiddle(ds, bf->bf_ndelim);

	} while (!asf_tailq_empty(&tid->buf_q));

	bf_first->bf_al= al;
  90e684:	243527        	s16i	a4, a3, 78
	bf_first->bf_nframes = nframes;
  90e687:	22344c        	s8i	a2, a3, 76

	return ATH_TGT_AGGR_DONE;
  90e68a:	d280      	mov.n	a2, a8
  90e68c:	d10f      	retw.n
		}

#ifdef PROJECT_K2
		if ((nframes + prev_frames) >= ATH_MIN((h_baw), 17)) {
#else
		if ((nframes + prev_frames) >= ATH_MIN((h_baw), 22)) {
  90e68e:	881a      	l32i.n	a8, a1, 40
  90e690:	c1a5      	movi.n	a10, 21
  90e692:	78a302        	bltu	a10, a8, 90e698 <ath_tgt_tx_form_aggr+0x270>
  90e695:	63fee3        	j	90e57c <ath_tgt_tx_form_aggr+0x154>
  90e698:	63fef1        	j	90e58d <ath_tgt_tx_form_aggr+0x165>
	...

0090e69c <ath_tgt_txq_schedule>:
	asf_tailq_insert_tail(&txq->axq_tidq, tid, tid_qelem);
}

static void
ath_tgt_txq_schedule(struct ath_softc_tgt *sc, struct ath_txq *txq)
{
  90e69c:	6c1008        	entry	a1, 64
	u_int8_t bdone;

	bdone = AH_FALSE;

	do {
		TAILQ_DEQ(&txq->axq_tidq, tid, tid_qelem);
  90e69f:	8436      	l32i.n	a4, a3, 24
  90e6a1:	644209        	beqz	a4, 90e8ae <ath_tgt_txq_schedule+0x212>
  90e6a4:	8549      	l32i.n	a5, a4, 36
  90e6a6:	864a      	l32i.n	a6, a4, 40
  90e6a8:	c854      	beqz.n	a5, 90e6b0 <ath_tgt_txq_schedule+0x14>
  90e6aa:	965a      	s32i.n	a6, a5, 40
  90e6ac:	600002        	j	90e6b2 <ath_tgt_txq_schedule+0x16>
  90e6af:	009637        	maxu	a6, a9, a0
  90e6b2:	864a      	l32i.n	a6, a4, 40
  90e6b4:	9560      	s32i.n	a5, a6, 0
		if (tid == NULL)
			return;

		tid->sched = AH_FALSE;

		if (tid->paused)
  90e6b6:	264034        	l8ui	a6, a4, 52
		TAILQ_DEQ(&txq->axq_tidq, tid, tid_qelem);

		if (tid == NULL)
			return;

		tid->sched = AH_FALSE;
  90e6b9:	c050      	movi.n	a5, 0
  90e6bb:	254435        	s8i	a5, a4, 53

		if (tid->paused)
  90e6be:	006732        	sext	a7, a6, 7
  90e6c1:	c050      	movi.n	a5, 0
  90e6c3:	757102        	beq	a7, a5, 90e6c9 <ath_tgt_txq_schedule+0x2d>
  90e6c6:	6001d8        	j	90e8a2 <ath_tgt_txq_schedule+0x206>
			continue;

		if (!(tid->flag & TID_AGGR_ENABLED))
  90e6c9:	264036        	l8ui	a6, a4, 54
  90e6cc:	c052      	movi.n	a5, 2
  90e6ce:	056601        	and	a6, a6, a5
  90e6d1:	c081      	movi.n	a8, 1
  90e6d3:	8540      	l32i.n	a5, a4, 0
  90e6d5:	656050        	bnez	a6, 90e729 <ath_tgt_txq_schedule+0x8d>

static void
ath_tgt_tx_sched_normal(struct ath_softc_tgt *sc, ath_atx_tid_t *tid)
{
	struct ath_tx_buf *bf;
	struct ath_txq *txq =TID_TO_ACTXQ(tid->tidno);;
  90e6d8:	d960      	mov.n	a9, a6
  90e6da:	058939        	movnez	a9, a8, a5
  90e6dd:	c999      	beqz.n	a9, 90e6fa <ath_tgt_txq_schedule+0x5e>
  90e6df:	275cfd        	addi	a7, a5, -3
  90e6e2:	078639        	movnez	a6, a8, a7
  90e6e5:	c961      	beqz.n	a6, 90e6fa <ath_tgt_txq_schedule+0x5e>
  90e6e7:	b056      	addi.n	a6, a5, -1
  90e6e9:	6e620f        	bltui	a6, 2, 90e6fc <ath_tgt_txq_schedule+0x60>
  90e6ec:	255cfc        	addi	a5, a5, -4
  90e6ef:	c082      	movi.n	a8, 2
  90e6f1:	785307        	bltu	a5, a8, 90e6fc <ath_tgt_txq_schedule+0x60>
  90e6f4:	c083      	movi.n	a8, 3
  90e6f6:	600002        	j	90e6fc <ath_tgt_txq_schedule+0x60>
  90e6f9:	00c080        	excw
  90e6fc:	0e8811        	slli	a8, a8, 2
  90e6ff:	288d05        	addmi	a8, a8, 0x500
  90e702:	a828      	add.n	a8, a2, a8
  90e704:	8783      	l32i.n	a7, a8, 12

	do {
		if (asf_tailq_empty(&tid->buf_q))
  90e706:	8b4b      	l32i.n	a11, a4, 44
  90e708:	64b188        	beqz	a11, 90e894 <ath_tgt_txq_schedule+0x1f8>
			break;

		bf = asf_tailq_first(&tid->buf_q);
		asf_tailq_remove(&tid->buf_q, bf, bf_list);
  90e70b:	85b9      	l32i.n	a5, a11, 36
  90e70d:	86ba      	l32i.n	a6, a11, 40
  90e70f:	c853      	beqz.n	a5, 90e716 <ath_tgt_txq_schedule+0x7a>
  90e711:	965a      	s32i.n	a6, a5, 40
  90e713:	600001        	j	90e718 <ath_tgt_txq_schedule+0x7c>
  90e716:	964c      	s32i.n	a6, a4, 48
  90e718:	86ba      	l32i.n	a6, a11, 40
		ath_tgt_tx_send_normal(sc, bf);
  90e71a:	da20      	mov.n	a10, a2
	do {
		if (asf_tailq_empty(&tid->buf_q))
			break;

		bf = asf_tailq_first(&tid->buf_q);
		asf_tailq_remove(&tid->buf_q, bf, bf_list);
  90e71c:	9560      	s32i.n	a5, a6, 0
		ath_tgt_tx_send_normal(sc, bf);
  90e71e:	5bfdb0        	call8	90dde0 <ath_tgt_tx_send_normal>

	} while (txq->axq_depth < ATH_AGGR_MIN_QDEPTH);
  90e721:	8574      	l32i.n	a5, a7, 16
  90e723:	645fdf        	beqz	a5, 90e706 <ath_tgt_txq_schedule+0x6a>
  90e726:	60016a        	j	90e894 <ath_tgt_txq_schedule+0x1f8>
ath_tgt_tx_sched_aggr(struct ath_softc_tgt *sc, ath_atx_tid_t *tid)
{
	struct ath_tx_buf  *bf, *bf_last;
	ATH_AGGR_STATUS status;
	ath_tx_bufhead bf_q;
	struct ath_txq *txq = TID_TO_ACTXQ(tid->tidno);
  90e729:	d670      	mov.n	a6, a7
  90e72b:	058639        	movnez	a6, a8, a5
  90e72e:	060647        	extui	a6, a6, 0, 8
  90e731:	c96d      	beqz.n	a6, 90e752 <ath_tgt_txq_schedule+0xb6>
  90e733:	265cfd        	addi	a6, a5, -3
  90e736:	d970      	mov.n	a9, a7
  90e738:	068939        	movnez	a9, a8, a6
  90e73b:	090647        	extui	a6, a9, 0, 8
  90e73e:	c960      	beqz.n	a6, 90e752 <ath_tgt_txq_schedule+0xb6>
  90e740:	b056      	addi.n	a6, a5, -1
  90e742:	6e620e        	bltui	a6, 2, 90e754 <ath_tgt_txq_schedule+0xb8>
  90e745:	255cfc        	addi	a5, a5, -4
  90e748:	c082      	movi.n	a8, 2
  90e74a:	785306        	bltu	a5, a8, 90e754 <ath_tgt_txq_schedule+0xb8>
  90e74d:	c083      	movi.n	a8, 3
  90e74f:	600001        	j	90e754 <ath_tgt_txq_schedule+0xb8>
  90e752:	c080      	movi.n	a8, 0
  90e754:	0e8811        	slli	a8, a8, 2
  90e757:	288d05        	addmi	a8, a8, 0x500
  90e75a:	a828      	add.n	a8, a2, a8
  90e75c:	8883      	l32i.n	a8, a8, 12
	struct ath_tx_desc *ds = NULL;
	struct ath_hal *ah = sc->sc_ah;
	int i;


	if (asf_tailq_empty(&tid->buf_q))
  90e75e:	864b      	l32i.n	a6, a4, 44
	struct ath_tx_buf  *bf, *bf_last;
	ATH_AGGR_STATUS status;
	ath_tx_bufhead bf_q;
	struct ath_txq *txq = TID_TO_ACTXQ(tid->tidno);
	struct ath_tx_desc *ds = NULL;
	struct ath_hal *ah = sc->sc_ah;
  90e760:	252d05        	addmi	a5, a2, 0x500
ath_tgt_tx_sched_aggr(struct ath_softc_tgt *sc, ath_atx_tid_t *tid)
{
	struct ath_tx_buf  *bf, *bf_last;
	ATH_AGGR_STATUS status;
	ath_tx_bufhead bf_q;
	struct ath_txq *txq = TID_TO_ACTXQ(tid->tidno);
  90e763:	9815      	s32i.n	a8, a1, 20
	struct ath_tx_desc *ds = NULL;
	struct ath_hal *ah = sc->sc_ah;
  90e765:	855b      	l32i.n	a5, a5, 44
	int i;


	if (asf_tailq_empty(&tid->buf_q))
  90e767:	646129        	beqz	a6, 90e894 <ath_tgt_txq_schedule+0x1f8>

	do {
		if (asf_tailq_empty(&tid->buf_q))
			break;

		asf_tailq_init(&bf_q);
  90e76a:	c060      	movi.n	a6, 0

	if (asf_tailq_empty(&tid->buf_q))
		return;

	do {
		if (asf_tailq_empty(&tid->buf_q))
  90e76c:	874b      	l32i.n	a7, a4, 44
  90e76e:	647122        	beqz	a7, 90e894 <ath_tgt_txq_schedule+0x1f8>
			break;

		asf_tailq_init(&bf_q);

		status = ath_tgt_tx_form_aggr(sc, tid, &bf_q);
  90e771:	dc10      	mov.n	a12, a1
  90e773:	db40      	mov.n	a11, a4
  90e775:	da20      	mov.n	a10, a2

	do {
		if (asf_tailq_empty(&tid->buf_q))
			break;

		asf_tailq_init(&bf_q);
  90e777:	9610      	s32i.n	a6, a1, 0
  90e779:	9111      	s32i.n	a1, a1, 4

		status = ath_tgt_tx_form_aggr(sc, tid, &bf_q);
  90e77b:	5bff2b        	call8	90e428 <ath_tgt_tx_form_aggr>

		if (asf_tailq_empty(&bf_q))
  90e77e:	8710      	l32i.n	a7, a1, 0
		if (asf_tailq_empty(&tid->buf_q))
			break;

		asf_tailq_init(&bf_q);

		status = ath_tgt_tx_form_aggr(sc, tid, &bf_q);
  90e780:	9a14      	s32i.n	a10, a1, 16

		if (asf_tailq_empty(&bf_q))
  90e782:	64710e        	beqz	a7, 90e894 <ath_tgt_txq_schedule+0x1f8>
			break;

		bf = asf_tailq_first(&bf_q);
		bf_last = asf_tailq_last(&bf_q, ath_tx_bufhead_s);

		if (bf->bf_nframes == 1) {
  90e785:	2a704c        	l8ui	a10, a7, 76
  90e788:	69a168        	bnei	a10, 1, 90e7f4 <ath_tgt_txq_schedule+0x158>

			if(bf->bf_retries == 0)
  90e78b:	2a7086        	l8ui	a10, a7, 134
  90e78e:	cca6      	bnez.n	a10, 90e798 <ath_tgt_txq_schedule+0xfc>
				__stats(sc, txaggr_single);
  90e790:	2a2261        	l32i	a10, a2, 0x184
  90e793:	b1aa      	addi.n	a10, a10, 1
  90e795:	2a2661        	s32i	a10, a2, 0x184
			bf->bf_isaggr = 0;
  90e798:	2a7087        	l8ui	a10, a7, 135
  90e79b:	2bfadf        	movi	a11, -33
  90e79e:	0baa01        	and	a10, a10, a11
			bf->bf_lastds = &(bf->bf_descarr[bf->bf_dmamap_info.nsegs -1]);
  90e7a1:	8b71      	l32i.n	a11, a7, 4

		if (bf->bf_nframes == 1) {

			if(bf->bf_retries == 0)
				__stats(sc, txaggr_single);
			bf->bf_isaggr = 0;
  90e7a3:	2a7487        	s8i	a10, a7, 135
			bf->bf_lastds = &(bf->bf_descarr[bf->bf_dmamap_info.nsegs -1]);
  90e7a6:	0cba11        	slli	a10, a11, 4
  90e7a9:	abaa      	add.n	a10, a10, a11
  90e7ab:	0daa11        	slli	a10, a10, 3
  90e7ae:	2bfa78        	movi	a11, -136
  90e7b1:	abab      	add.n	a11, a10, a11
  90e7b3:	8a7d      	l32i.n	a10, a7, 52
			bf->bf_lastds->ds_link = 0;
			bf->bf_next = NULL;

			for(ds = bf->bf_desc; ds <= bf->bf_lastds; ds++)
  90e7b5:	2c0a88        	movi	a12, 136
		if (bf->bf_nframes == 1) {

			if(bf->bf_retries == 0)
				__stats(sc, txaggr_single);
			bf->bf_isaggr = 0;
			bf->bf_lastds = &(bf->bf_descarr[bf->bf_dmamap_info.nsegs -1]);
  90e7b8:	abaa      	add.n	a10, a10, a11
  90e7ba:	9a7e      	s32i.n	a10, a7, 56
			bf->bf_lastds->ds_link = 0;
  90e7bc:	26a400        	s8i	a6, a10, 0
  90e7bf:	26a401        	s8i	a6, a10, 1
  90e7c2:	26a402        	s8i	a6, a10, 2
  90e7c5:	26a403        	s8i	a6, a10, 3
			bf->bf_next = NULL;
  90e7c8:	967b      	s32i.n	a6, a7, 44

			for(ds = bf->bf_desc; ds <= bf->bf_lastds; ds++)
  90e7ca:	8b7c      	l32i.n	a11, a7, 48
  90e7cc:	600014        	j	90e7e4 <ath_tgt_txq_schedule+0x148>
  90e7cf:	002e52        	extui	a14, a0, 18, 3
				ah->ah_clr11nAggr(ds);
  90e7d2:	14dab0        	l32r	a4, 905294 <memset+0x1e44c>
  90e7d5:	2b1607        	s32i	a11, a1, 28
  90e7d8:	2c1606        	s32i	a12, a1, 24
  90e7db:	0be000        	callx8	a14
			bf->bf_isaggr = 0;
			bf->bf_lastds = &(bf->bf_descarr[bf->bf_dmamap_info.nsegs -1]);
			bf->bf_lastds->ds_link = 0;
			bf->bf_next = NULL;

			for(ds = bf->bf_desc; ds <= bf->bf_lastds; ds++)
  90e7de:	8b17      	l32i.n	a11, a1, 28
  90e7e0:	8c16      	l32i.n	a12, a1, 24
  90e7e2:	acbb      	add.n	a11, a11, a12
  90e7e4:	8a7e      	l32i.n	a10, a7, 56
  90e7e6:	7babe6        	bgeu	a10, a11, 90e7d0 <ath_tgt_txq_schedule+0x134>
				ah->ah_clr11nAggr(ds);

			ath_buf_set_rate(sc, bf);
  90e7e9:	db70      	mov.n	a11, a7
  90e7eb:	da20      	mov.n	a10, a2
  90e7ed:	5bfa79        	call8	90d1d4 <ath_buf_set_rate>
  90e7f0:	600088        	j	90e87c <ath_tgt_txq_schedule+0x1e0>
  90e7f3:	008a11        	slli	a10, a8, 16

		bf_last->bf_next = NULL;
		bf_last->bf_lastds->ds_link = 0;
		bf_last->bf_ndelim = 0;

		bf->bf_isaggr  = 1;
  90e7f6:	c2b0      	movi.n	a11, 32

		if (asf_tailq_empty(&bf_q))
			break;

		bf = asf_tailq_first(&bf_q);
		bf_last = asf_tailq_last(&bf_q, ath_tx_bufhead_s);
  90e7f8:	8aa1      	l32i.n	a10, a10, 4
  90e7fa:	8ea0      	l32i.n	a14, a10, 0

			continue;
		}

		bf_last->bf_next = NULL;
		bf_last->bf_lastds->ds_link = 0;
  90e7fc:	8aee      	l32i.n	a10, a14, 56
			bf->bf_txq_add(sc, bf);

			continue;
		}

		bf_last->bf_next = NULL;
  90e7fe:	96eb      	s32i.n	a6, a14, 44
		bf_last->bf_lastds->ds_link = 0;
  90e800:	26a400        	s8i	a6, a10, 0
  90e803:	26a401        	s8i	a6, a10, 1
  90e806:	26a402        	s8i	a6, a10, 2
  90e809:	26a403        	s8i	a6, a10, 3
		bf_last->bf_ndelim = 0;
  90e80c:	26e44b        	s8i	a6, a14, 75

		bf->bf_isaggr  = 1;
  90e80f:	2a7087        	l8ui	a10, a7, 135
  90e812:	0baa02        	or	a10, a10, a11
  90e815:	2a7487        	s8i	a10, a7, 135
		ath_buf_set_rate(sc, bf);
  90e818:	db70      	mov.n	a11, a7
  90e81a:	da20      	mov.n	a10, a2
  90e81c:	9e16      	s32i.n	a14, a1, 24
  90e81e:	5bfa6d        	call8	90d1d4 <ath_buf_set_rate>
		ah->ah_set11nAggrFirst(bf->bf_desc, bf->bf_al,
  90e821:	2b7127        	l16ui	a11, a7, 78
  90e824:	2a720c        	l32i	a10, a7, 48
  90e827:	2f5211        	l32i	a15, a5, 68
  90e82a:	2c704b        	l8ui	a12, a7, 75
  90e82d:	0bf000        	callx8	a15
					  bf->bf_ndelim);
		bf->bf_lastds = bf_last->bf_lastds;
  90e830:	8e16      	l32i.n	a14, a1, 24

		for (i = 0; i < bf_last->bf_dmamap_info.nsegs; i++)
  90e832:	c0b0      	movi.n	a11, 0

		bf->bf_isaggr  = 1;
		ath_buf_set_rate(sc, bf);
		ah->ah_set11nAggrFirst(bf->bf_desc, bf->bf_al,
					  bf->bf_ndelim);
		bf->bf_lastds = bf_last->bf_lastds;
  90e834:	8aee      	l32i.n	a10, a14, 56
  90e836:	9a7e      	s32i.n	a10, a7, 56
  90e838:	60001c        	j	90e858 <ath_tgt_txq_schedule+0x1bc>
  90e83b:	000cba        	excw

		for (i = 0; i < bf_last->bf_dmamap_info.nsegs; i++)
			ah->ah_set11nAggrLast(&bf_last->bf_descarr[i]);
  90e83e:	118fed        	l32r	a1, 8f27f4 <memset+0xb9ac>
  90e841:	abaa      	add.n	a10, a10, a11
  90e843:	2c5213        	l32i	a12, a5, 76
  90e846:	0daa11        	slli	a10, a10, 3
  90e849:	9b17      	s32i.n	a11, a1, 28
  90e84b:	9e16      	s32i.n	a14, a1, 24
  90e84d:	aafa      	add.n	a10, a15, a10
  90e84f:	0bc000        	callx8	a12
		ath_buf_set_rate(sc, bf);
		ah->ah_set11nAggrFirst(bf->bf_desc, bf->bf_al,
					  bf->bf_ndelim);
		bf->bf_lastds = bf_last->bf_lastds;

		for (i = 0; i < bf_last->bf_dmamap_info.nsegs; i++)
  90e852:	8b17      	l32i.n	a11, a1, 28
  90e854:	8e16      	l32i.n	a14, a1, 24
  90e856:	b1bb      	addi.n	a11, a11, 1
  90e858:	8ae1      	l32i.n	a10, a14, 4
  90e85a:	7ab3de        	bltu	a11, a10, 90e83c <ath_tgt_txq_schedule+0x1a0>
			ah->ah_set11nAggrLast(&bf_last->bf_descarr[i]);

		if (status == ATH_AGGR_8K_LIMITED) {
  90e85d:	8814      	l32i.n	a8, a1, 16
  90e85f:	698419        	bnei	a8, 4, 90e87c <ath_tgt_txq_schedule+0x1e0>
			adf_os_assert(0);
  90e862:	1568bf        	l32r	a5, 8e8b60 <memset+0x1d18>
  90e865:	1b6ab9        	l32r	a11, 8e934c <memset+0x2504>
  90e868:	255212        	l32i	a5, a5, 72
  90e86b:	1a6aa3        	l32r	a10, 8e92f8 <memset+0x24b0>
  90e86e:	0b5000        	callx8	a5
  90e871:	156923        	l32r	a5, 8e8d00 <memset+0x1eb8>
  90e874:	0c0200        	memw
  90e877:	8550      	l32i.n	a5, a5, 0
  90e879:	600017        	j	90e894 <ath_tgt_txq_schedule+0x1f8>
			break;
		}

		bf->bf_txq_add(sc, bf);
  90e87c:	2c7210        	l32i	a12, a7, 64
  90e87f:	db70      	mov.n	a11, a7
  90e881:	da20      	mov.n	a10, a2
  90e883:	0bc000        	callx8	a12
	} while (txq->axq_depth < ATH_AGGR_MIN_QDEPTH &&
		 status != ATH_TGT_AGGR_BAW_CLOSED);
  90e886:	8915      	l32i.n	a9, a1, 20
  90e888:	8894      	l32i.n	a8, a9, 16
			adf_os_assert(0);
			break;
		}

		bf->bf_txq_add(sc, bf);
	} while (txq->axq_depth < ATH_AGGR_MIN_QDEPTH &&
  90e88a:	cc86      	bnez.n	a8, 90e894 <ath_tgt_txq_schedule+0x1f8>
  90e88c:	8814      	l32i.n	a8, a1, 16
  90e88e:	688102        	beqi	a8, 1, 90e894 <ath_tgt_txq_schedule+0x1f8>
  90e891:	63fed7        	j	90e76c <ath_tgt_txq_schedule+0xd0>
		else
			ath_tgt_tx_sched_aggr(sc,tid);

		bdone = AH_TRUE;

		if (!asf_tailq_empty(&tid->buf_q)) {
  90e894:	864b      	l32i.n	a6, a4, 44
		if (!(tid->flag & TID_AGGR_ENABLED))
			ath_tgt_tx_sched_normal(sc,tid);
		else
			ath_tgt_tx_sched_aggr(sc,tid);

		bdone = AH_TRUE;
  90e896:	c051      	movi.n	a5, 1

		if (!asf_tailq_empty(&tid->buf_q)) {
  90e898:	c866      	beqz.n	a6, 90e8a2 <ath_tgt_txq_schedule+0x206>
			ath_tgt_tx_enqueue(txq, tid);
  90e89a:	db40      	mov.n	a11, a4
  90e89c:	2a3c1c        	addi	a10, a3, 28
  90e89f:	5bf9d6        	call8	90cff8 <ath_tgt_tx_enqueue$isra$3>
		}

	} while (!asf_tailq_empty(&txq->axq_tidq) && !bdone);
  90e8a2:	8736      	l32i.n	a7, a3, 24
  90e8a4:	c061      	movi.n	a6, 1
  90e8a6:	c874      	beqz.n	a7, 90e8ae <ath_tgt_txq_schedule+0x212>
  90e8a8:	765102        	beq	a5, a6, 90e8ae <ath_tgt_txq_schedule+0x212>
  90e8ab:	63fdf0        	j	90e69f <ath_tgt_txq_schedule+0x3>
  90e8ae:	d10f      	retw.n

0090e8b0 <owltgt_tx_processq>:
	ath_tx_status_send(sc);
}

void owltgt_tx_processq(struct ath_softc_tgt *sc, struct ath_txq *txq,
			owl_txq_state_t txqstate)
{
  90e8b0:	6c1006        	entry	a1, 48
	struct ath_tx_buf *bf;
	struct ath_tx_desc *ds;
	struct ath_hal *ah = sc->sc_ah;
  90e8b3:	252d05        	addmi	a5, a2, 0x500
  90e8b6:	865b      	l32i.n	a6, a5, 44
		bf = asf_tailq_first(&txq->axq_q);

		ds = bf->bf_lastds;
		status = ah->ah_procTxDesc(ah, ds);

		if (status == HAL_EINPROGRESS) {
  90e8b8:	c07f      	movi.n	a7, 15
	struct ath_tx_desc *ds;
	struct ath_hal *ah = sc->sc_ah;
	HAL_STATUS status;

	for (;;) {
		if (asf_tailq_empty(&txq->axq_q)) {
  90e8ba:	8532      	l32i.n	a5, a3, 8
  90e8bc:	cc54      	bnez.n	a5, 90e8c4 <owltgt_tx_processq+0x14>
			txq->axq_link = NULL;
  90e8be:	9531      	s32i.n	a5, a3, 4
			txq->axq_linkbuf = NULL;
  90e8c0:	9535      	s32i.n	a5, a3, 20
			break;
  90e8c2:	d10f      	retw.n
		}

		bf = asf_tailq_first(&txq->axq_q);

		ds = bf->bf_lastds;
  90e8c4:	885e      	l32i.n	a8, a5, 56
		status = ah->ah_procTxDesc(ah, ds);
  90e8c6:	29621a        	l32i	a9, a6, 104
  90e8c9:	db80      	mov.n	a11, a8
  90e8cb:	9810      	s32i.n	a8, a1, 0
  90e8cd:	da60      	mov.n	a10, a6
  90e8cf:	0b9000        	callx8	a9

		if (status == HAL_EINPROGRESS) {
  90e8d2:	8810      	l32i.n	a8, a1, 0
  90e8d4:	77a91e        	bne	a10, a7, 90e8f6 <owltgt_tx_processq+0x46>
			if (txqstate == OWL_TXQ_ACTIVE)
  90e8d7:	64406d        	beqz	a4, 90e948 <owltgt_tx_processq+0x98>
				break;
			else if (txqstate == OWL_TXQ_STOPPED) {
  90e8da:	694112        	bnei	a4, 1, 90e8f0 <owltgt_tx_processq+0x40>
				__stats(sc, tx_stopfiltered);
  90e8dd:	292275        	l32i	a9, a2, 0x1d4
  90e8e0:	b199      	addi.n	a9, a9, 1
  90e8e2:	292675        	s32i	a9, a2, 0x1d4
				ds->ds_txstat.ts_flags  = 0;
  90e8e5:	c090      	movi.n	a9, 0
  90e8e7:	298467        	s8i	a9, a8, 103
				ds->ds_txstat.ts_status = HAL_OK;
  90e8ea:	298466        	s8i	a9, a8, 102
  90e8ed:	600005        	j	90e8f6 <owltgt_tx_processq+0x46>
			} else {
				ds->ds_txstat.ts_flags  = HAL_TX_SW_FILTERED;
  90e8f0:	29fa80        	movi	a9, -128
  90e8f3:	298467        	s8i	a9, a8, 103
			}
		}

		ATH_TXQ_REMOVE_HEAD(txq, bf, bf_list);
  90e8f6:	8859      	l32i.n	a8, a5, 36
  90e8f8:	895a      	l32i.n	a9, a5, 40
  90e8fa:	c883      	beqz.n	a8, 90e901 <owltgt_tx_processq+0x51>
  90e8fc:	998a      	s32i.n	a9, a8, 40
  90e8fe:	600001        	j	90e903 <owltgt_tx_processq+0x53>
  90e901:	9933      	s32i.n	a9, a3, 12
  90e903:	895a      	l32i.n	a9, a5, 40
  90e905:	9890      	s32i.n	a8, a9, 0
  90e907:	8834      	l32i.n	a8, a3, 16
  90e909:	b088      	addi.n	a8, a8, -1
  90e90b:	9834      	s32i.n	a8, a3, 16
		if ((asf_tailq_empty(&txq->axq_q))) {
  90e90d:	8832      	l32i.n	a8, a3, 8
  90e90f:	cc8a      	bnez.n	a8, 90e91d <owltgt_tx_processq+0x6d>
			__stats(sc, tx_qnull);
  90e911:	29225c        	l32i	a9, a2, 0x170
  90e914:	b199      	addi.n	a9, a9, 1
  90e916:	29265c        	s32i	a9, a2, 0x170
			txq->axq_link = NULL;
  90e919:	9831      	s32i.n	a8, a3, 4
			txq->axq_linkbuf = NULL;
  90e91b:	9835      	s32i.n	a8, a3, 20
		}

		if (bf->bf_comp) {
  90e91d:	885f      	l32i.n	a8, a5, 60
			bf->bf_comp(sc, bf);
  90e91f:	db50      	mov.n	a11, a5
  90e921:	da20      	mov.n	a10, a2
			__stats(sc, tx_qnull);
			txq->axq_link = NULL;
			txq->axq_linkbuf = NULL;
		}

		if (bf->bf_comp) {
  90e923:	c886      	beqz.n	a8, 90e92d <owltgt_tx_processq+0x7d>
			bf->bf_comp(sc, bf);
  90e925:	0b8000        	callx8	a8
  90e928:	60000c        	j	90e938 <owltgt_tx_processq+0x88>
  90e92b:	00005b        	extui	a0, a0, 16, 12
		} else {
			ath_tx_status_update(sc, bf);
  90e92e:	fb          	.byte 0xfb
  90e92f:	9905      	s32i.n	a9, a0, 20
			ath_buf_comp(sc, bf);
  90e931:	5b02da        	call8	8cf49c <_bss_end+0x3bc58c>
  90e934:	205bfa        	l32ai	a0, a5, 0x3e8
  90e937:	f7          	.byte 0xf7
		}

		if (txqstate == OWL_TXQ_ACTIVE) {
  90e938:	654f7e        	bnez	a4, 90e8ba <owltgt_tx_processq+0xa>
			ath_tgt_txq_schedule(sc, txq);
  90e93b:	033b02        	or	a11, a3, a3
  90e93e:	022a02        	or	a10, a2, a2
  90e941:	5bff56        	call8	90e69c <ath_tgt_txq_schedule>
  90e944:	63ff72        	j	90e8ba <owltgt_tx_processq+0xa>
  90e947:	00d10f        	subx8	a1, a13, a0
	...

0090e94c <owl_tgt_tx_tasklet>:
	owltgt_tx_processq(sc, txq, OWL_TXQ_ACTIVE);
	ah->ah_setInterrupts(ah, sc->sc_imask);
}

void owl_tgt_tx_tasklet(TQUEUE_ARG data)
{
  90e94c:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = (struct ath_softc_tgt *)data;
	a_int32_t i;
	struct ath_txq *txq;

	ath_tx_status_clear(sc);
  90e94f:	022a02        	or	a10, a2, a2
  90e952:	233acc        	movi	a3, 0x3cc
  90e955:	5bfb8b        	call8	90d784 <ath_tx_status_clear>
  90e958:	a323      	add.n	a3, a2, a3

	for (i = 0; i < (HAL_NUM_TX_QUEUES - 6); i++) {
  90e95a:	240a00        	movi	a4, 0
		txq = ATH_TXQ(sc, i);

		if (ATH_TXQ_SETUP(sc, i)) {
  90e95d:	262d03        	addmi	a6, a2, 0x300
  90e960:	2560c8        	l8ui	a5, a6, 200
  90e963:	004004        	ssr	a4
  90e966:	05051b        	sra	a5, a5
  90e969:	7f5740        	bbci	a5, 31, 90e9ad <owl_tgt_tx_tasklet+0x61>
			if (txq == sc->sc_cabq)
  90e96c:	252d05        	addmi	a5, a2, 0x500
  90e96f:	28520c        	l32i	a8, a5, 48
  90e972:	78392e        	bne	a3, a8, 90e9a4 <owl_tgt_tx_tasklet+0x58>
	}
}

static void owltgt_tx_process_cabq(struct ath_softc_tgt *sc, struct ath_txq *txq)
{
	struct ath_hal *ah = sc->sc_ah;
  90e975:	25520b        	l32i	a5, a5, 44
	ah->ah_setInterrupts(ah, sc->sc_imask & ~HAL_INT_SWBA);
  90e978:	1969cb        	l32r	a9, 8e90a4 <memset+0x225c>
  90e97b:	2b22c4        	l32i	a11, a2, 0x310
  90e97e:	285228        	l32i	a8, a5, 160
  90e981:	09bb01        	and	a11, a11, a9
  90e984:	da50      	mov.n	a10, a5
  90e986:	0b8000        	callx8	a8
	owltgt_tx_processq(sc, txq, OWL_TXQ_ACTIVE);
  90e989:	033b02        	or	a11, a3, a3
  90e98c:	022a02        	or	a10, a2, a2
  90e98f:	2c0a00        	movi	a12, 0
  90e992:	5bffc7        	call8	90e8b0 <owltgt_tx_processq>
	ah->ah_setInterrupts(ah, sc->sc_imask);
  90e995:	285228        	l32i	a8, a5, 160
  90e998:	2b22c4        	l32i	a11, a2, 0x310
  90e99b:	da50      	mov.n	a10, a5
  90e99d:	0b8000        	callx8	a8
  90e9a0:	600009        	j	90e9ad <owl_tgt_tx_tasklet+0x61>
  90e9a3:	00c0c0        	excw

		if (ATH_TXQ_SETUP(sc, i)) {
			if (txq == sc->sc_cabq)
				owltgt_tx_process_cabq(sc, txq);
			else
				owltgt_tx_processq(sc, txq, OWL_TXQ_ACTIVE);
  90e9a6:	db30      	mov.n	a11, a3
  90e9a8:	da20      	mov.n	a10, a2
  90e9aa:	5bffc1        	call8	90e8b0 <owltgt_tx_processq>
	a_int32_t i;
	struct ath_txq *txq;

	ath_tx_status_clear(sc);

	for (i = 0; i < (HAL_NUM_TX_QUEUES - 6); i++) {
  90e9ad:	b144      	addi.n	a4, a4, 1
  90e9af:	233c20        	addi	a3, a3, 32
  90e9b2:	6944aa        	bnei	a4, 4, 90e960 <owl_tgt_tx_tasklet+0x14>
			else
				owltgt_tx_processq(sc, txq, OWL_TXQ_ACTIVE);
		}
	}

	ath_tx_status_send(sc);
  90e9b5:	da20      	mov.n	a10, a2
  90e9b7:	5bfbd0        	call8	90d8f8 <ath_tx_status_send>
  90e9ba:	d10f      	retw.n

0090e9bc <ath_aggr_resume_tid>:
	return ((((x) & 0xff00) >> 8) |   (((x) & 0x00ff) << 8));
}

static inline void
ath_aggr_resume_tid(struct ath_softc_tgt *sc, ath_atx_tid_t *tid)
{
  90e9bc:	6c1004        	entry	a1, 32
	struct ath_txq *txq;

	txq = TID_TO_ACTXQ(tid->tidno);
  90e9bf:	8930      	l32i.n	a9, a3, 0
	return ((((x) & 0xff00) >> 8) |   (((x) & 0x00ff) << 8));
}

static inline void
ath_aggr_resume_tid(struct ath_softc_tgt *sc, ath_atx_tid_t *tid)
{
  90e9c1:	db30      	mov.n	a11, a3
	struct ath_txq *txq;

	txq = TID_TO_ACTXQ(tid->tidno);
  90e9c3:	c997      	beqz.n	a9, 90e9de <ath_aggr_resume_tid+0x22>
  90e9c5:	689315        	beqi	a9, 3, 90e9de <ath_aggr_resume_tid+0x22>
  90e9c8:	b09a      	addi.n	a10, a9, -1
  90e9ca:	c081      	movi.n	a8, 1
  90e9cc:	6ea210        	bltui	a10, 2, 90e9e0 <ath_aggr_resume_tid+0x24>
  90e9cf:	299cfc        	addi	a9, a9, -4
  90e9d2:	c082      	movi.n	a8, 2
  90e9d4:	789308        	bltu	a9, a8, 90e9e0 <ath_aggr_resume_tid+0x24>
  90e9d7:	c083      	movi.n	a8, 3
  90e9d9:	600003        	j	90e9e0 <ath_aggr_resume_tid+0x24>
  90e9dc:	0000c0        	excw
  90e9df:	800e      	l32i.n	a0, a0, 56
  90e9e1:	8811      	l32i.n	a8, a1, 4
  90e9e3:	288d05        	addmi	a8, a8, 0x500
  90e9e6:	a828      	add.n	a8, a2, a8
  90e9e8:	8383      	l32i.n	a3, a8, 12
	tid->paused = 0;
  90e9ea:	c080      	movi.n	a8, 0
  90e9ec:	28b434        	s8i	a8, a11, 52

	if (asf_tailq_empty(&tid->buf_q))
  90e9ef:	88bb      	l32i.n	a8, a11, 44
  90e9f1:	c88b      	beqz.n	a8, 90ea00 <ath_aggr_resume_tid+0x44>
		return;

	ath_tgt_tx_enqueue(txq, tid);
  90e9f3:	2a3c1c        	addi	a10, a3, 28
  90e9f6:	5bf980        	call8	90cff8 <ath_tgt_tx_enqueue$isra$3>
	ath_tgt_txq_schedule(sc, txq);
  90e9f9:	db30      	mov.n	a11, a3
  90e9fb:	da20      	mov.n	a10, a2
  90e9fd:	5bff27        	call8	90e69c <ath_tgt_txq_schedule>
  90ea00:	d10f      	retw.n
	...

0090ea04 <owl_tgt_tid_cleanup>:
	}
}

static void owl_tgt_tid_cleanup(struct ath_softc_tgt *sc,
				struct ath_atx_tid *tid)
{
  90ea04:	6c1004        	entry	a1, 32
	tid->incomp--;
  90ea07:	283037        	l8ui	a8, a3, 55
	}
}

static void owl_tgt_tid_cleanup(struct ath_softc_tgt *sc,
				struct ath_atx_tid *tid)
{
  90ea0a:	da20      	mov.n	a10, a2
	tid->incomp--;
  90ea0c:	b088      	addi.n	a8, a8, -1
  90ea0e:	080847        	extui	a8, a8, 0, 8
  90ea11:	283437        	s8i	a8, a3, 55
	if (tid->incomp) {
  90ea14:	cf85      	bnez.n	a8, 90ea4d <owl_tgt_tid_cleanup+0x49>
		return;
	}

	tid->flag &= ~TID_CLEANUP_INPROGRES;
  90ea16:	293036        	l8ui	a9, a3, 54
  90ea19:	28fafe        	movi	a8, -2
  90ea1c:	089801        	and	a8, a9, a8
  90ea1f:	283436        	s8i	a8, a3, 54

	if (tid->flag & TID_REINITIALIZE) {
  90ea22:	7d9722        	bbci	a9, 29, 90ea48 <owl_tgt_tid_cleanup+0x44>
		adf_os_print("TID REINIT DONE for tid %p\n", tid);
  90ea25:	1868bf        	l32r	a8, 8e8d24 <memset+0x1edc>
  90ea28:	1a6aba        	l32r	a10, 8e9510 <memset+0x26c8>
  90ea2b:	288212        	l32i	a8, a8, 72
  90ea2e:	033b02        	or	a11, a3, a3
  90ea31:	0b8000        	callx8	a8
		tid->flag  &= ~TID_REINITIALIZE;
  90ea34:	283036        	l8ui	a8, a3, 54
  90ea37:	c79b      	movi.n	a9, -5
  90ea39:	098801        	and	a8, a8, a9
  90ea3c:	283436        	s8i	a8, a3, 54
		owl_tgt_tid_init(tid);
  90ea3f:	da30      	mov.n	a10, a3
  90ea41:	5bf907        	call8	90ce60 <owl_tgt_tid_init>
  90ea44:	d10f      	retw.n
  90ea46:	0000db        	excw
	} else {
		ath_aggr_resume_tid(sc, tid);
  90ea49:	305bff        	excw
  90ea4c:	dcd1      	excw
  90ea4e:	0f          	.byte 0xf
	...

0090ea50 <ath_tgt_tx_comp_normal>:
	tid->baw_tail = tid->baw_head;
}

static void ath_tgt_tx_comp_normal(struct ath_softc_tgt *sc,
				   struct ath_tx_buf *bf)
{
  90ea50:	6c1004        	entry	a1, 32
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90ea53:	2a304d        	l8ui	a10, a3, 77
}

static void ath_tgt_tx_comp_normal(struct ath_softc_tgt *sc,
				   struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
  90ea56:	8b34      	l32i.n	a11, a3, 16
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);

	if (tid->flag & TID_CLEANUP_INPROGRES) {
  90ea58:	0ca911        	slli	a9, a10, 4
  90ea5b:	0a990c        	sub	a9, a9, a10
  90ea5e:	0e9911        	slli	a9, a9, 2
  90ea61:	a9b9      	add.n	a9, a11, a9
  90ea63:	28905a        	l8ui	a8, a9, 90
  90ea66:	7f8713        	bbci	a8, 31, 90ea7d <ath_tgt_tx_comp_normal+0x2d>

static void ath_tgt_tx_comp_normal(struct ath_softc_tgt *sc,
				   struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90ea69:	0ca811        	slli	a8, a10, 4
  90ea6c:	0a880c        	sub	a8, a8, a10
  90ea6f:	0e8811        	slli	a8, a8, 2
  90ea72:	288c24        	addi	a8, a8, 36

	if (tid->flag & TID_CLEANUP_INPROGRES) {
		owl_tgt_tid_cleanup(sc, tid);
  90ea75:	a8bb      	add.n	a11, a11, a8
  90ea77:	022a02        	or	a10, a2, a2
  90ea7a:	5bffe2        	call8	90ea04 <owl_tgt_tid_cleanup>
	}

	if (bf->bf_node) {
  90ea7d:	8834      	l32i.n	a8, a3, 16
  90ea7f:	c98e      	beqz.n	a8, 90eaa1 <ath_tgt_tx_comp_normal+0x51>
}

static void
ath_tx_uc_comp(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	ath_tx_status_update(sc, bf);
  90ea81:	db30      	mov.n	a11, a3
  90ea83:	022a02        	or	a10, a2, a2
  90ea86:	5bfb43        	call8	90d794 <ath_tx_status_update>
	ath_update_stats(sc, bf);
  90ea89:	8b3c      	l32i.n	a11, a3, 48
  90ea8b:	da20      	mov.n	a10, a2
  90ea8d:	5bf942        	call8	90cf98 <ath_update_stats$isra$1>
	ath_rate_tx_complete(sc, ATH_NODE_TARGET(bf->bf_node),
  90ea90:	8c3e      	l32i.n	a12, a3, 56
  90ea92:	8b34      	l32i.n	a11, a3, 16
  90ea94:	c0f0      	movi.n	a15, 0
  90ea96:	c0e1      	movi.n	a14, 1
  90ea98:	2d3c50        	addi	a13, a3, 80
  90ea9b:	022a02        	or	a10, a2, a2
  90ea9e:	5bf8b7        	call8	90cd7c <ath_rate_tx_complete>

	if (bf->bf_node) {
		ath_tx_uc_comp(sc, bf);
	}

	ath_tx_freebuf(sc, bf);
  90eaa1:	db30      	mov.n	a11, a3
  90eaa3:	da20      	mov.n	a10, a2
  90eaa5:	5bfaaa        	call8	90d550 <ath_tx_freebuf>
  90eaa8:	d10f      	retw.n
	...

0090eaac <ath_tgt_tx_comp_aggr>:
		INCR(tid->baw_tail, ATH_TID_MAX_BUFS);
	}
}

void ath_tgt_tx_comp_aggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90eaac:	6c1024        	entry	a1, 0x120
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90eaaf:	27304d        	l8ui	a7, a3, 77
	}
}

void ath_tgt_tx_comp_aggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
  90eab2:	8434      	l32i.n	a4, a3, 16
  90eab4:	0c7511        	slli	a5, a7, 4
  90eab7:	07550c        	sub	a5, a5, a7
  90eaba:	0e5511        	slli	a5, a5, 2
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90eabd:	265c24        	addi	a6, a5, 36
  90eac0:	251635        	s32i	a5, a1, 212
	struct ath_rc_series rcs[4];
	u_int16_t seq_st;
	u_int32_t *ba;
	int ba_index;
	int nbad = 0;
	int nframes = bf->bf_nframes;
  90eac3:	25304c        	l8ui	a5, a3, 76
}

void ath_tgt_tx_comp_aggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90eac6:	a646      	add.n	a6, a4, a6
	struct ath_rc_series rcs[4];
	u_int16_t seq_st;
	u_int32_t *ba;
	int ba_index;
	int nbad = 0;
	int nframes = bf->bf_nframes;
  90eac8:	251634        	s32i	a5, a1, 208
	struct ath_tx_buf *bf_next;
	ath_tx_bufhead bf_q;
	int tx_ok = 1;
	struct ath_tx_buf *bar = NULL;
  90eacb:	c050      	movi.n	a5, 0
  90eacd:	251630        	s32i	a5, a1, 192
	struct ath_txq *txq;

	txq = bf->bf_txq;

	if (tid->flag & TID_CLEANUP_INPROGRES) {
  90ead0:	0c7511        	slli	a5, a7, 4
  90ead3:	075d0c        	sub	a13, a5, a7
  90ead6:	0ed911        	slli	a9, a13, 2
  90ead9:	a949      	add.n	a9, a4, a9
  90eadb:	28905a        	l8ui	a8, a9, 90
  90eade:	253c50        	addi	a5, a3, 80
  90eae1:	080840        	extui	a8, a8, 0, 1
  90eae4:	6480ed        	beqz	a8, 90ebd5 <ath_tgt_tx_comp_aggr+0x129>
  90eae7:	2b320e        	l32i	a11, a3, 56
  90eaea:	2c0a88        	movi	a12, 136
  90eaed:	011a02        	or	a10, a1, a1
  90eaf0:	29163d        	s32i	a9, a1, 244
  90eaf3:	2d163b        	s32i	a13, a1, 236
  90eaf6:	5bf8c1        	call8	90cdfc <__adf_os_mem_copy>
  90eaf9:	280a88        	movi	a8, 136
  90eafc:	a817      	add.n	a7, a1, a8
  90eafe:	db50      	mov.n	a11, a5
  90eb00:	c3c0      	movi.n	a12, 48
  90eb02:	077a02        	or	a10, a7, a7
  90eb05:	5bf8bd        	call8	90cdfc <__adf_os_mem_copy>

	seq_st = ATH_DS_BA_SEQ(ds);
	ba     = ATH_DS_BA_BITMAP(ds);
	tx_ok  = (ATH_DS_TX_STATUS(ds) == HAL_OK);

	if (!bf->bf_isaggr) {
  90eb08:	253221        	l32i	a5, a3, 132
  90eb0b:	29123d        	l32i	a9, a1, 244
  90eb0e:	2d123b        	l32i	a13, a1, 236
  90eb11:	7a5f35        	bbsi	a5, 26, 90eb4a <ath_tgt_tx_comp_aggr+0x9e>
		ath_update_stats(sc, bf);
  90eb14:	8b3c      	l32i.n	a11, a3, 48
  90eb16:	022a02        	or	a10, a2, a2
  90eb19:	5bf91f        	call8	90cf98 <ath_update_stats$isra$1>

		__stats(sc, tx_compunaggr);
  90eb1c:	24225e        	l32i	a4, a2, 0x178

		ath_tx_status_update(sc, bf);
  90eb1f:	db30      	mov.n	a11, a3
	tx_ok  = (ATH_DS_TX_STATUS(ds) == HAL_OK);

	if (!bf->bf_isaggr) {
		ath_update_stats(sc, bf);

		__stats(sc, tx_compunaggr);
  90eb21:	244c01        	addi	a4, a4, 1

		ath_tx_status_update(sc, bf);
  90eb24:	022a02        	or	a10, a2, a2
	tx_ok  = (ATH_DS_TX_STATUS(ds) == HAL_OK);

	if (!bf->bf_isaggr) {
		ath_update_stats(sc, bf);

		__stats(sc, tx_compunaggr);
  90eb27:	24265e        	s32i	a4, a2, 0x178

		ath_tx_status_update(sc, bf);
  90eb2a:	5bfb1a        	call8	90d794 <ath_tx_status_update>

		ath_tx_freebuf(sc, bf);
  90eb2d:	db30      	mov.n	a11, a3
  90eb2f:	022a02        	or	a10, a2, a2
  90eb32:	5bfa87        	call8	90d550 <ath_tx_freebuf>

		if (tid->flag & TID_CLEANUP_INPROGRES) {
  90eb35:	29123d        	l32i	a9, a1, 244
  90eb38:	23905a        	l8ui	a3, a9, 90
  90eb3b:	7f3f02        	bbsi	a3, 31, 90eb41 <ath_tgt_tx_comp_aggr+0x95>
  90eb3e:	600370        	j	90eeb2 <ath_tgt_tx_comp_aggr+0x406>
			owl_tgt_tid_cleanup(sc, tid);
  90eb41:	db60      	mov.n	a11, a6
  90eb43:	da20      	mov.n	a10, a2
  90eb45:	5bffaf        	call8	90ea04 <owl_tgt_tid_cleanup>
  90eb48:	d10f      	retw.n

	while (bf) {
		ba_index = ATH_BA_INDEX(seq_st, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
		bf_next  = bf->bf_next;

		ath_tx_status_update_aggr(sc, bf, ds, rcs, 0);
  90eb4a:	d870      	mov.n	a8, a7

		ath_tx_freebuf(sc, bf);

		tid->incomp--;
  90eb4c:	d5d0      	mov.n	a5, a13
  90eb4e:	099702        	or	a7, a9, a9
  90eb51:	299c5b        	addi	a9, a9, 91
		return;
	}

	while (bf) {
		ba_index = ATH_BA_INDEX(seq_st, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
		bf_next  = bf->bf_next;
  90eb54:	8f3b      	l32i.n	a15, a3, 44

		ath_tx_status_update_aggr(sc, bf, ds, rcs, 0);
  90eb56:	dd80      	mov.n	a13, a8
  90eb58:	db30      	mov.n	a11, a3
  90eb5a:	c0e0      	movi.n	a14, 0
  90eb5c:	dc10      	mov.n	a12, a1
  90eb5e:	022a02        	or	a10, a2, a2
  90eb61:	28163c        	s32i	a8, a1, 240
  90eb64:	29163d        	s32i	a9, a1, 244
  90eb67:	2f163b        	s32i	a15, a1, 236
  90eb6a:	5bfb3b        	call8	90d858 <ath_tx_status_update_aggr>

		ath_tx_freebuf(sc, bf);
  90eb6d:	db30      	mov.n	a11, a3
  90eb6f:	da20      	mov.n	a10, a2
  90eb71:	5bfa77        	call8	90d550 <ath_tx_freebuf>

		tid->incomp--;
  90eb74:	29123d        	l32i	a9, a1, 244
		if (!tid->incomp) {
  90eb77:	28123c        	l32i	a8, a1, 240

		ath_tx_status_update_aggr(sc, bf, ds, rcs, 0);

		ath_tx_freebuf(sc, bf);

		tid->incomp--;
  90eb7a:	239000        	l8ui	a3, a9, 0
		if (!tid->incomp) {
  90eb7d:	2f123b        	l32i	a15, a1, 236

		ath_tx_status_update_aggr(sc, bf, ds, rcs, 0);

		ath_tx_freebuf(sc, bf);

		tid->incomp--;
  90eb80:	b033      	addi.n	a3, a3, -1
  90eb82:	030347        	extui	a3, a3, 0, 8
  90eb85:	239400        	s8i	a3, a9, 0
		if (!tid->incomp) {
  90eb88:	cd3a      	bnez.n	a3, 90eba6 <ath_tgt_tx_comp_aggr+0xfa>
			tid->flag  &= ~TID_CLEANUP_INPROGRES;
  90eb8a:	0e5511        	slli	a5, a5, 2
  90eb8d:	a545      	add.n	a5, a4, a5
  90eb8f:	23505a        	l8ui	a3, a5, 90
  90eb92:	c75e      	movi.n	a5, -2
  90eb94:	053301        	and	a3, a3, a5
  90eb97:	23745a        	s8i	a3, a7, 90
			ath_aggr_resume_tid(sc, tid);
  90eb9a:	db60      	mov.n	a11, a6
  90eb9c:	da20      	mov.n	a10, a2
  90eb9e:	5bff87        	call8	90e9bc <ath_aggr_resume_tid>
  90eba1:	600006        	j	90ebab <ath_tgt_tx_comp_aggr+0xff>
  90eba4:	0000d3        	excw
  90eba7:	f0          	.byte 0xf0
		}

		return;
	}

	while (bf) {
  90eba8:	65ffa8        	bnez	a15, 90eb54 <ath_tgt_tx_comp_aggr+0xa8>
		}

		bf = bf_next;
	}

	ath_update_aggr_stats(sc, ds, nframes, nbad);
  90ebab:	2e1071        	l8ui	a14, a1, 113
  90ebae:	2d1070        	l8ui	a13, a1, 112
  90ebb1:	2c1067        	l8ui	a12, a1, 103
  90ebb4:	2b1066        	l8ui	a11, a1, 102
  90ebb7:	022a02        	or	a10, a2, a2
  90ebba:	5bf918        	call8	90d01c <ath_update_aggr_stats$isra$5>
	ath_rate_tx_complete(sc, an, ds, rcs, nframes, nbad);
  90ebbd:	2e1234        	l32i	a14, a1, 208
  90ebc0:	2d0a88        	movi	a13, 136
  90ebc3:	c0f0      	movi.n	a15, 0
  90ebc5:	ad1d      	add.n	a13, a1, a13
  90ebc7:	dc10      	mov.n	a12, a1
  90ebc9:	db40      	mov.n	a11, a4
  90ebcb:	da20      	mov.n	a10, a2
  90ebcd:	5bf86b        	call8	90cd7c <ath_rate_tx_complete>
  90ebd0:	d10f      	retw.n
  90ebd2:	000000        	ill
	ath_tx_bufhead bf_q;
	int tx_ok = 1;
	struct ath_tx_buf *bar = NULL;
	struct ath_txq *txq;

	txq = bf->bf_txq;
  90ebd5:	293220        	l32i	a9, a3, 128
  90ebd8:	8b3e      	l32i.n	a11, a3, 56
  90ebda:	2c0a88        	movi	a12, 136
  90ebdd:	da10      	mov.n	a10, a1
  90ebdf:	291636        	s32i	a9, a1, 216
  90ebe2:	28163c        	s32i	a8, a1, 240
  90ebe5:	5bf885        	call8	90cdfc <__adf_os_mem_copy>
  90ebe8:	2a0a88        	movi	a10, 136
  90ebeb:	c3c0      	movi.n	a12, 48
  90ebed:	db50      	mov.n	a11, a5
  90ebef:	aa1a      	add.n	a10, a1, a10
  90ebf1:	5bf882        	call8	90cdfc <__adf_os_mem_copy>
	}

	adf_os_mem_copy(ds, bf->bf_lastds, sizeof (struct ath_tx_desc));
	adf_os_mem_copy(rcs, bf->bf_rcs, sizeof(rcs));

	if (ds->ds_txstat.ts_flags == HAL_TX_SW_FILTERED) {
  90ebf4:	291067        	l8ui	a9, a1, 103
  90ebf7:	28123c        	l32i	a8, a1, 240
  90ebfa:	699e18        	bnei	a9, 128, 90ec16 <ath_tgt_tx_comp_aggr+0x16a>
		adf_os_assert(0);
  90ebfd:	1268bf        	l32r	a2, 8e8efc <memset+0x20b4>
  90ec00:	1b6abb        	l32r	a11, 8e96ec <memset+0x28a4>
  90ec03:	222212        	l32i	a2, a2, 72
  90ec06:	1a6aa3        	l32r	a10, 8e9694 <memset+0x284c>
  90ec09:	0b2000        	callx8	a2
  90ec0c:	126923        	l32r	a2, 8e9098 <memset+0x2250>
  90ec0f:	0c0200        	memw
  90ec12:	8220      	l32i.n	a2, a2, 0
		return;
  90ec14:	d10f      	retw.n
	}

	if (!bf->bf_isaggr) {
  90ec16:	2a3221        	l32i	a10, a3, 132
  90ec19:	c2f0      	movi.n	a15, 32
  90ec1b:	0aff01        	and	a15, a15, a10
  90ec1e:	65f132        	bnez	a15, 90ed54 <ath_tgt_tx_comp_aggr+0x2a8>
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
	struct ath_tx_desc *ds  = bf->bf_lastds;

	ath_update_stats(sc, bf);
  90ec21:	8b3c      	l32i.n	a11, a3, 48
  90ec23:	da20      	mov.n	a10, a2
static void
ath_tx_comp_unaggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
	struct ath_tx_desc *ds  = bf->bf_lastds;
  90ec25:	26320e        	l32i	a6, a3, 56
}

static void
ath_tx_comp_unaggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
  90ec28:	243204        	l32i	a4, a3, 16
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90ec2b:	27304d        	l8ui	a7, a3, 77
	struct ath_tx_desc *ds  = bf->bf_lastds;

	ath_update_stats(sc, bf);
  90ec2e:	2f163b        	s32i	a15, a1, 236
  90ec31:	5bf8d9        	call8	90cf98 <ath_update_stats$isra$1>
	ath_rate_tx_complete(sc, an, ds, bf->bf_rcs, 1, 0);
  90ec34:	2f123b        	l32i	a15, a1, 236
  90ec37:	dd50      	mov.n	a13, a5
  90ec39:	c0e1      	movi.n	a14, 1
  90ec3b:	dc60      	mov.n	a12, a6
  90ec3d:	db40      	mov.n	a11, a4
  90ec3f:	022a02        	or	a10, a2, a2
  90ec42:	5bf84e        	call8	90cd7c <ath_rate_tx_complete>

	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
  90ec45:	256066        	l8ui	a5, a6, 102
  90ec48:	7f5f02        	bbsi	a5, 31, 90ec4e <ath_tgt_tx_comp_aggr+0x1a2>
  90ec4b:	6000d2        	j	90ed21 <ath_tgt_tx_comp_aggr+0x275>

static inline void
ath_tx_retry_unaggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90ec4e:	29304d        	l8ui	a9, a3, 77
}

static inline void
ath_tx_retry_unaggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
  90ec51:	8734      	l32i.n	a7, a3, 16
  90ec53:	0c9411        	slli	a4, a9, 4
  90ec56:	09440c        	sub	a4, a4, a9
  90ec59:	0e4411        	slli	a4, a4, 2
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
	struct ath_txq *txq;

	txq = bf->bf_txq;

	if (bf->bf_retries >= OWLMAX_RETRIES) {
  90ec5c:	263086        	l8ui	a6, a3, 134

static inline void
ath_tx_retry_unaggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90ec5f:	254c24        	addi	a5, a4, 36
	struct ath_txq *txq;

	txq = bf->bf_txq;

	if (bf->bf_retries >= OWLMAX_RETRIES) {
  90ec62:	c089      	movi.n	a8, 9

static inline void
ath_tx_retry_unaggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90ec64:	a575      	add.n	a5, a7, a5
	struct ath_txq *txq;

	txq = bf->bf_txq;

	if (bf->bf_retries >= OWLMAX_RETRIES) {
  90ec66:	768b26        	bgeu	a8, a6, 90ec90 <ath_tgt_tx_comp_aggr+0x1e4>
		__stats(sc, txunaggr_xretry);
  90ec69:	242273        	l32i	a4, a2, 0x1cc
		ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90ec6c:	2b3123        	l16ui	a11, a3, 70
	struct ath_txq *txq;

	txq = bf->bf_txq;

	if (bf->bf_retries >= OWLMAX_RETRIES) {
		__stats(sc, txunaggr_xretry);
  90ec6f:	b144      	addi.n	a4, a4, 1
		ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90ec71:	055a02        	or	a10, a5, a5
	struct ath_txq *txq;

	txq = bf->bf_txq;

	if (bf->bf_retries >= OWLMAX_RETRIES) {
		__stats(sc, txunaggr_xretry);
  90ec74:	242673        	s32i	a4, a2, 0x1cc
		ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90ec77:	0b4b14        	srli	a11, a11, 4
  90ec7a:	5bf8af        	call8	90cf38 <ath_tx_update_baw>
		ath_tx_status_update(sc, bf);
  90ec7d:	db30      	mov.n	a11, a3
  90ec7f:	da20      	mov.n	a10, a2
  90ec81:	5bfac4        	call8	90d794 <ath_tx_status_update>
		ath_bar_tx(sc, tid, bf);
  90ec84:	dc30      	mov.n	a12, a3
  90ec86:	db50      	mov.n	a11, a5
  90ec88:	da20      	mov.n	a10, a2
  90ec8a:	5bfa52        	call8	90d5d4 <ath_bar_tx>
  90ec8d:	d10f      	retw.n
  90ec8f:	002822        	excw
		return;
	}

	__stats(sc, txunaggr_compretries);
  90ec92:	6d8b3e        	excw
  90ec95:	b188      	addi.n	a8, a8, 1
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
	struct ath_txq *txq;

	txq = bf->bf_txq;
  90ec97:	263220        	l32i	a6, a3, 128
		ath_bar_tx(sc, tid, bf);
		return;
	}

	__stats(sc, txunaggr_compretries);
	if (!bf->bf_lastds->ds_link) {
  90ec9a:	2ab000        	l8ui	a10, a11, 0
		ath_tx_status_update(sc, bf);
		ath_bar_tx(sc, tid, bf);
		return;
	}

	__stats(sc, txunaggr_compretries);
  90ec9d:	28266d        	s32i	a8, a2, 0x1b4
	if (!bf->bf_lastds->ds_link) {
  90eca0:	28b001        	l8ui	a8, a11, 1
  90eca3:	08aa10        	slli	a10, a10, 24
  90eca6:	008811        	slli	a8, a8, 16
  90eca9:	0a8a02        	or	a10, a8, a10
  90ecac:	28b002        	l8ui	a8, a11, 2
  90ecaf:	088811        	slli	a8, a8, 8
  90ecb2:	0a8802        	or	a8, a8, a10
  90ecb5:	2ab003        	l8ui	a10, a11, 3
  90ecb8:	08a802        	or	a8, a10, a8
  90ecbb:	cd87      	bnez.n	a8, 90ecd6 <ath_tgt_tx_comp_aggr+0x22a>
		__stats(sc, txunaggr_errlast);
  90ecbd:	282272        	l32i	a8, a2, 0x1c8
		bf = ath_buf_toggle(sc, bf, 1);
  90ecc0:	db30      	mov.n	a11, a3
		return;
	}

	__stats(sc, txunaggr_compretries);
	if (!bf->bf_lastds->ds_link) {
		__stats(sc, txunaggr_errlast);
  90ecc2:	b188      	addi.n	a8, a8, 1
  90ecc4:	282672        	s32i	a8, a2, 0x1c8
		bf = ath_buf_toggle(sc, bf, 1);
  90ecc7:	c0c1      	movi.n	a12, 1
  90ecc9:	da20      	mov.n	a10, a2
  90eccb:	29163d        	s32i	a9, a1, 244
  90ecce:	5bf9cc        	call8	90d400 <ath_buf_toggle>
  90ecd1:	29123d        	l32i	a9, a1, 244
  90ecd4:	d3a0      	mov.n	a3, a10
	}

	ath_tx_set_retry(sc, bf);
  90ecd6:	2a1a80        	movi	a10, 0x180
  90ecd9:	aa2a      	add.n	a10, a2, a10
  90ecdb:	033b02        	or	a11, a3, a3
  90ecde:	29163d        	s32i	a9, a1, 244
  90ece1:	5bfb1b        	call8	90d950 <ath_tx_set_retry$isra$12>
	asf_tailq_insert_head(&tid->buf_q, bf, bf_list);
  90ece4:	29123d        	l32i	a9, a1, 244
  90ece7:	2b3c24        	addi	a11, a3, 36
  90ecea:	0c9211        	slli	a2, a9, 4
  90eced:	09280c        	sub	a8, a2, a9
  90ecf0:	0e8811        	slli	a8, a8, 2
  90ecf3:	a878      	add.n	a8, a7, a8
  90ecf5:	2a8214        	l32i	a10, a8, 80
  90ecf8:	9a39      	s32i.n	a10, a3, 36
  90ecfa:	c8a3      	beqz.n	a10, 90ed01 <ath_tgt_tx_comp_aggr+0x255>
  90ecfc:	9baa      	s32i.n	a11, a10, 40
  90ecfe:	600002        	j	90ed04 <ath_tgt_tx_comp_aggr+0x258>
  90ed01:	2b8615        	s32i	a11, a8, 84
  90ed04:	09220c        	sub	a2, a2, a9
  90ed07:	0e2211        	slli	a2, a2, 2
  90ed0a:	a272      	add.n	a2, a7, a2
  90ed0c:	244c50        	addi	a4, a4, 80
  90ed0f:	232614        	s32i	a3, a2, 80
  90ed12:	a477      	add.n	a7, a7, a4
  90ed14:	973a      	s32i.n	a7, a3, 40
	ath_tgt_tx_enqueue(txq, tid);
  90ed16:	db50      	mov.n	a11, a5
  90ed18:	2a6c1c        	addi	a10, a6, 28
  90ed1b:	600190        	j	90eeaf <ath_tgt_tx_comp_aggr+0x403>
  90ed1e:	000000        	ill

static void
ath_tx_comp_unaggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90ed21:	0c7a11        	slli	a10, a7, 4

	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
		ath_tx_retry_unaggr(sc, bf);
		return;
	}
	__stats(sc, tx_compunaggr);
  90ed24:	25225e        	l32i	a5, a2, 0x178

static void
ath_tx_comp_unaggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90ed27:	07aa0c        	sub	a10, a10, a7
		ath_tx_retry_unaggr(sc, bf);
		return;
	}
	__stats(sc, tx_compunaggr);

	ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90ed2a:	2b3123        	l16ui	a11, a3, 70

static void
ath_tx_comp_unaggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90ed2d:	0eaa11        	slli	a10, a10, 2

	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
		ath_tx_retry_unaggr(sc, bf);
		return;
	}
	__stats(sc, tx_compunaggr);
  90ed30:	b155      	addi.n	a5, a5, 1

static void
ath_tx_comp_unaggr(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);
  90ed32:	2aac24        	addi	a10, a10, 36
		ath_tx_retry_unaggr(sc, bf);
		return;
	}
	__stats(sc, tx_compunaggr);

	ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90ed35:	0a4a08        	add	a10, a4, a10

	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
		ath_tx_retry_unaggr(sc, bf);
		return;
	}
	__stats(sc, tx_compunaggr);
  90ed38:	25265e        	s32i	a5, a2, 0x178

	ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90ed3b:	0b4b14        	srli	a11, a11, 4
  90ed3e:	5bf87e        	call8	90cf38 <ath_tx_update_baw>
	ath_tx_status_update(sc, bf);
  90ed41:	db30      	mov.n	a11, a3
  90ed43:	022a02        	or	a10, a2, a2
  90ed46:	5bfa93        	call8	90d794 <ath_tx_status_update>
	ath_tx_freebuf(sc, bf);
  90ed49:	db30      	mov.n	a11, a3
  90ed4b:	da20      	mov.n	a10, a2
  90ed4d:	5bfa00        	call8	90d550 <ath_tx_freebuf>
  90ed50:	d10f      	retw.n
  90ed52:	000025        	excw
	if (!bf->bf_isaggr) {
		ath_tx_comp_unaggr(sc, bf);
		return;
	}

	__stats(sc, tx_compaggr);
  90ed55:	225f28        	s32ri	a2, a5, 160

	asf_tailq_init(&bf_q);
  90ed58:	162eb1        	l32r	a6, 8da81c <_bss_end+0x3c790c>
	if (!bf->bf_isaggr) {
		ath_tx_comp_unaggr(sc, bf);
		return;
	}

	__stats(sc, tx_compaggr);
  90ed5b:	552526        	call4	9581f4 <_etext+0x48fc3>
  90ed5e:	5f2810        	call12	8d8da0 <_bss_end+0x3c5e90>

	asf_tailq_init(&bf_q);

	seq_st =  ATH_DS_BA_SEQ(ds);
	ba     =  ATH_DS_BA_BITMAP(ds);
	tx_ok  =  (ATH_DS_TX_STATUS(ds) == HAL_OK);
  90ed61:	66250a        	bltz	a2, 90f26f <_etext+0x3e>
		return;
	}

	__stats(sc, tx_compaggr);

	asf_tailq_init(&bf_q);
  90ed64:	b8a5      	addi.n	a5, a10, 8
  90ed66:	152516        	l32r	a5, 8d81c0 <_bss_end+0x3c52b0>
  90ed69:	2f080f        	excw

	seq_st =  ATH_DS_BA_SEQ(ds);
	ba     =  ATH_DS_BA_BITMAP(ds);
	tx_ok  =  (ATH_DS_TX_STATUS(ds) == HAL_OK);

	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
  90ed6c:	40c8f3        	excw
  90ed6f:	600022        	j	90ed95 <ath_tgt_tx_comp_aggr+0x2e9>
  90ed72:	000025        	excw

	__stats(sc, tx_compaggr);

	asf_tailq_init(&bf_q);

	seq_st =  ATH_DS_BA_SEQ(ds);
  90ed75:	113225        	l32r	a1, 8db60c <_bss_end+0x3c86fc>
  90ed78:	1637ce        	l32r	a6, 8dccb0 <_bss_end+0x3c9da0>
	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
		ath_tx_comp_aggr_error(sc, bf, tid);
		return;
	}

	if (tx_ok && !ATH_DS_TX_BA(ds)) {
  90ed7b:	82d5      	l32i.n	a2, a13, 20
  90ed7d:	807f      	l32i.n	a0, a7, 60
  90ed7f:	9f20      	s32i.n	a15, a2, 0
		__stats(sc, txaggr_babug);
  90ed81:	242269        	l32i	a4, a2, 0x1a4
		adf_os_print("BA Bug?\n");
  90ed84:	1a6abc        	l32r	a10, 8e9874 <memset+0x2a2c>
		ath_tx_comp_aggr_error(sc, bf, tid);
		return;
	}

	if (tx_ok && !ATH_DS_TX_BA(ds)) {
		__stats(sc, txaggr_babug);
  90ed87:	b144      	addi.n	a4, a4, 1
  90ed89:	242669        	s32i	a4, a2, 0x1a4
		adf_os_print("BA Bug?\n");
  90ed8c:	1468bf        	l32r	a4, 8e9088 <memset+0x2240>
  90ed8f:	244212        	l32i	a4, a4, 72
  90ed92:	0b4000        	callx8	a4
		ath_tx_comp_aggr_error(sc, bf, tid);
  90ed95:	dc60      	mov.n	a12, a6
  90ed97:	db30      	mov.n	a11, a3
  90ed99:	da20      	mov.n	a10, a2
  90ed9b:	5bfb33        	call8	90da68 <ath_tx_comp_aggr_error>
		return;
  90ed9e:	d10f      	retw.n
  90eda0:	d5f0      	mov.n	a5, a15

	asf_tailq_init(&bf_q);

	seq_st =  ATH_DS_BA_SEQ(ds);
	ba     =  ATH_DS_BA_BITMAP(ds);
	tx_ok  =  (ATH_DS_TX_STATUS(ds) == HAL_OK);
  90eda2:	c090      	movi.n	a9, 0
  90eda4:	c0a1      	movi.n	a10, 1
  90eda6:	089a39        	movnez	a10, a9, a8

	while (bf) {
		ba_index = ATH_BA_INDEX(seq_st, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
		bf_next  = bf->bf_next;

		if (tx_ok && ATH_BA_ISSET(ba, ba_index)) {
  90eda9:	0a0847        	extui	a8, a10, 0, 8
  90edac:	281639        	s32i	a8, a1, 228
			__stats(sc, txaggr_compgood);
			ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
			ath_tx_status_update_aggr(sc, bf, ds, rcs, 1);
			ath_tx_freebuf(sc, bf);
		} else {
			ath_tx_retry_subframe(sc, bf, &bf_q, &bar);
  90edaf:	280abc        	movi	a8, 188
  90edb2:	081808        	add	a8, a1, a8
  90edb5:	28163a        	s32i	a8, a1, 232
		ath_tx_comp_aggr_error(sc, bf, tid);
		return;
	}

	while (bf) {
		ba_index = ATH_BA_INDEX(seq_st, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90edb8:	2b3123        	l16ui	a11, a3, 70
  90edbb:	281237        	l32i	a8, a1, 220
		bf_next  = bf->bf_next;
  90edbe:	8a3b      	l32i.n	a10, a3, 44
		ath_tx_comp_aggr_error(sc, bf, tid);
		return;
	}

	while (bf) {
		ba_index = ATH_BA_INDEX(seq_st, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90edc0:	0b4b14        	srli	a11, a11, 4
  90edc3:	08b90c        	sub	a9, a11, a8
		bf_next  = bf->bf_next;
  90edc6:	2a1638        	s32i	a10, a1, 224

		if (tx_ok && ATH_BA_ISSET(ba, ba_index)) {
  90edc9:	2a1239        	l32i	a10, a1, 228
		ath_tx_comp_aggr_error(sc, bf, tid);
		return;
	}

	while (bf) {
		ba_index = ATH_BA_INDEX(seq_st, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90edcc:	09094f        	extui	a9, a9, 0, 16
  90edcf:	09084b        	extui	a8, a9, 0, 12
		bf_next  = bf->bf_next;

		if (tx_ok && ATH_BA_ISSET(ba, ba_index)) {
  90edd2:	64a043        	beqz	a10, 90ee19 <ath_tgt_tx_comp_aggr+0x36d>
  90edd5:	c3af      	movi.n	a10, 63
  90edd7:	78a23e        	blt	a10, a8, 90ee19 <ath_tgt_tx_comp_aggr+0x36d>
  90edda:	085812        	srai	a8, a8, 5
  90eddd:	0e8811        	slli	a8, a8, 2
  90ede0:	a818      	add.n	a8, a1, a8
  90ede2:	c0a1      	movi.n	a10, 1
  90ede4:	28821d        	l32i	a8, a8, 116
  90ede7:	009104        	ssl	a9
  90edea:	00a91a        	sll	a9, a10
  90eded:	789028        	bnone	a9, a8, 90ee19 <ath_tgt_tx_comp_aggr+0x36d>
			__stats(sc, txaggr_compgood);
  90edf0:	282262        	l32i	a8, a2, 0x188
  90edf3:	aa88      	add.n	a8, a8, a10
  90edf5:	282662        	s32i	a8, a2, 0x188
			ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90edf8:	da60      	mov.n	a10, a6
  90edfa:	5bf84f        	call8	90cf38 <ath_tx_update_baw>
			ath_tx_status_update_aggr(sc, bf, ds, rcs, 1);
  90edfd:	2d0a88        	movi	a13, 136
  90ee00:	db30      	mov.n	a11, a3
  90ee02:	da20      	mov.n	a10, a2
  90ee04:	c0e1      	movi.n	a14, 1
  90ee06:	ad1d      	add.n	a13, a1, a13
  90ee08:	dc10      	mov.n	a12, a1
  90ee0a:	5bfa93        	call8	90d858 <ath_tx_status_update_aggr>
			ath_tx_freebuf(sc, bf);
  90ee0d:	db30      	mov.n	a11, a3
  90ee0f:	da20      	mov.n	a10, a2
  90ee11:	5bf9cf        	call8	90d550 <ath_tx_freebuf>
  90ee14:	600012        	j	90ee2a <ath_tgt_tx_comp_aggr+0x37e>
  90ee17:	00002d        	excw
		} else {
			ath_tx_retry_subframe(sc, bf, &bf_q, &bar);
  90ee1a:	0ac02c        	excw
  90ee1d:	123aad        	l32r	a2, 8dd8d4 <_bss_end+0x3ca9c4>
  90ee20:	1ddb30        	l32r	a13, 905ae0 <memset+0x1ec98>
  90ee23:	da20      	mov.n	a10, a2
  90ee25:	5bfad6        	call8	90d980 <ath_tx_retry_subframe$isra$14>
			nbad ++;
  90ee28:	b155      	addi.n	a5, a5, 1
  90ee2a:	231238        	l32i	a3, a1, 224
		adf_os_print("BA Bug?\n");
		ath_tx_comp_aggr_error(sc, bf, tid);
		return;
	}

	while (bf) {
  90ee2d:	653f87        	bnez	a3, 90edb8 <ath_tgt_tx_comp_aggr+0x30c>
			nbad ++;
		}
		bf = bf_next;
	}

	ath_update_aggr_stats(sc, ds, nframes, nbad);
  90ee30:	2e1071        	l8ui	a14, a1, 113
  90ee33:	2d1070        	l8ui	a13, a1, 112
  90ee36:	2c1067        	l8ui	a12, a1, 103
  90ee39:	2b1066        	l8ui	a11, a1, 102
  90ee3c:	da20      	mov.n	a10, a2
  90ee3e:	5bf877        	call8	90d01c <ath_update_aggr_stats$isra$5>
	ath_rate_tx_complete(sc, an, ds, rcs, nframes, nbad);
  90ee41:	2e1234        	l32i	a14, a1, 208
  90ee44:	2d0a88        	movi	a13, 136
  90ee47:	dc10      	mov.n	a12, a1
  90ee49:	df50      	mov.n	a15, a5
  90ee4b:	ad1d      	add.n	a13, a1, a13
  90ee4d:	db40      	mov.n	a11, a4
  90ee4f:	da20      	mov.n	a10, a2
  90ee51:	5bf7ca        	call8	90cd7c <ath_rate_tx_complete>

	if (bar) {
  90ee54:	2c1230        	l32i	a12, a1, 192
  90ee57:	c8c5      	beqz.n	a12, 90ee60 <ath_tgt_tx_comp_aggr+0x3b4>
		ath_bar_tx(sc, tid, bar);
  90ee59:	db60      	mov.n	a11, a6
  90ee5b:	da20      	mov.n	a10, a2
  90ee5d:	5bf9dd        	call8	90d5d4 <ath_bar_tx>
	}

	if (!asf_tailq_empty(&bf_q)) {
  90ee60:	23122e        	l32i	a3, a1, 184
  90ee63:	64304b        	beqz	a3, 90eeb2 <ath_tgt_tx_comp_aggr+0x406>
		__stats(sc, txaggr_prepends);
  90ee66:	232264        	l32i	a3, a2, 0x190
  90ee69:	25122f        	l32i	a5, a1, 188
  90ee6c:	b133      	addi.n	a3, a3, 1
  90ee6e:	232664        	s32i	a3, a2, 0x190
		TAILQ_INSERTQ_HEAD(&tid->buf_q, &bf_q, bf_list);
  90ee71:	0c7211        	slli	a2, a7, 4
  90ee74:	07230c        	sub	a3, a2, a7
  90ee77:	0e3311        	slli	a3, a3, 2
  90ee7a:	a343      	add.n	a3, a4, a3
  90ee7c:	283214        	l32i	a8, a3, 80
  90ee7f:	c889      	beqz.n	a8, 90ee8c <ath_tgt_tx_comp_aggr+0x3e0>
  90ee81:	9850      	s32i.n	a8, a5, 0
  90ee83:	233214        	l32i	a3, a3, 80
  90ee86:	953a      	s32i.n	a5, a3, 40
  90ee88:	600003        	j	90ee8f <ath_tgt_tx_comp_aggr+0x3e3>
  90ee8b:	002536        	minu	a5, a2, a0
  90ee8e:	150727        	l32r	a5, 8d0b2c <_bss_end+0x3bdc1c>
  90ee91:	0c2512        	srai	a5, a12, 2
  90ee94:	352312        	excw
  90ee97:	2e0e77        	s32c1i	a14, a0, 0x1dc
  90ee9a:	11a747        	l32r	a1, 8f8bb8 <memset+0x11d70>
  90ee9d:	225c50        	addi	a2, a5, 80
		ath_tgt_tx_enqueue(txq, tid);
  90eea0:	281236        	l32i	a8, a1, 216
		ath_bar_tx(sc, tid, bar);
	}

	if (!asf_tailq_empty(&bf_q)) {
		__stats(sc, txaggr_prepends);
		TAILQ_INSERTQ_HEAD(&tid->buf_q, &bf_q, bf_list);
  90eea3:	237614        	s32i	a3, a7, 80
  90eea6:	a244      	add.n	a4, a4, a2
  90eea8:	943a      	s32i.n	a4, a3, 40
		ath_tgt_tx_enqueue(txq, tid);
  90eeaa:	db60      	mov.n	a11, a6
  90eeac:	2a8c1c        	addi	a10, a8, 28
  90eeaf:	5bf852        	call8	90cff8 <ath_tgt_tx_enqueue$isra$3>
  90eeb2:	d10f      	retw.n

0090eeb4 <ath_tgt_tx_cleanup>:
	wh->i_fc[1] |= IEEE80211_FC1_RETRY;
}

void ath_tgt_tx_cleanup(struct ath_softc_tgt *sc, struct ath_node_target *an,
			ath_atx_tid_t *tid, a_uint8_t discard_all)
{
  90eeb4:	6c1004        	entry	a1, 32
  90eeb7:	050547        	extui	a5, a5, 0, 8
	struct ath_tx_buf *bf_next;
	struct ath_txq *txq;

	txq = TID_TO_ACTXQ(tid->tidno);

	bf = asf_tailq_first(&tid->buf_q);
  90eeba:	864b      	l32i.n	a6, a4, 44

	while (bf) {
		if (discard_all || bf->bf_isretried) {
			bf_next = asf_tailq_next(bf, bf_list);
			TAILQ_DEQ(&tid->buf_q, bf, bf_list);
			if (bf->bf_isretried)
  90eebc:	c170      	movi.n	a7, 16

	txq = TID_TO_ACTXQ(tid->tidno);

	bf = asf_tailq_first(&tid->buf_q);

	while (bf) {
  90eebe:	600045        	j	90ef07 <ath_tgt_tx_cleanup+0x53>
  90eec1:	008369        	excw
		if (discard_all || bf->bf_isretried) {
  90eec4:	cc54      	bnez.n	a5, 90eecc <ath_tgt_tx_cleanup+0x18>
  90eec6:	286221        	l32i	a8, a6, 132
  90eec9:	787033        	bnone	a7, a8, 90ef00 <ath_tgt_tx_cleanup+0x4c>
			bf_next = asf_tailq_next(bf, bf_list);
  90eecc:	d630      	mov.n	a6, a3
			TAILQ_DEQ(&tid->buf_q, bf, bf_list);
  90eece:	834b      	l32i.n	a3, a4, 44
  90eed0:	c930      	beqz.n	a3, 90eee4 <ath_tgt_tx_cleanup+0x30>
  90eed2:	8839      	l32i.n	a8, a3, 36
  90eed4:	893a      	l32i.n	a9, a3, 40
  90eed6:	c883      	beqz.n	a8, 90eedd <ath_tgt_tx_cleanup+0x29>
  90eed8:	998a      	s32i.n	a9, a8, 40
  90eeda:	600001        	j	90eedf <ath_tgt_tx_cleanup+0x2b>
  90eedd:	994c      	s32i.n	a9, a4, 48
  90eedf:	893a      	l32i.n	a9, a3, 40
  90eee1:	289600        	s32i	a8, a9, 0
			if (bf->bf_isretried)
  90eee4:	283221        	l32i	a8, a3, 132
  90eee7:	78700a        	bnone	a7, a8, 90eef5 <ath_tgt_tx_cleanup+0x41>
				ath_tx_update_baw(tid, SEQNO_FROM_BF_SEQNO(bf->bf_seqno));
  90eeea:	2b3123        	l16ui	a11, a3, 70
  90eeed:	da40      	mov.n	a10, a4
  90eeef:	0b4b14        	srli	a11, a11, 4
  90eef2:	5bf811        	call8	90cf38 <ath_tx_update_baw>
			ath_tx_freebuf(sc, bf);
  90eef5:	db30      	mov.n	a11, a3
  90eef7:	da20      	mov.n	a10, a2
  90eef9:	5bf995        	call8	90d550 <ath_tx_freebuf>
			bf = bf_next;
			continue;
  90eefc:	600007        	j	90ef07 <ath_tgt_tx_cleanup+0x53>
  90eeff:	00186a        	excw
		}
		bf->bf_comp = ath_tgt_tx_comp_normal;
  90ef02:	b598      	addi.n	a8, a9, 5
  90ef04:	6fd630        	bgeui	a13, 6, 90ef38 <ath_tgt_tx_cleanup+0x84>

	txq = TID_TO_ACTXQ(tid->tidno);

	bf = asf_tailq_first(&tid->buf_q);

	while (bf) {
  90ef07:	656fb7        	bnez	a6, 90eec2 <ath_tgt_tx_cleanup+0xe>
}

static inline void
ath_aggr_pause_tid(struct ath_softc_tgt *sc, ath_atx_tid_t *tid)
{
	tid->paused =1;
  90ef0a:	c031      	movi.n	a3, 1
  90ef0c:	234434        	s8i	a3, a4, 52
		bf = asf_tailq_next(bf, bf_list);
	}

	ath_aggr_pause_tid(sc, tid);

	while (tid->baw_head != tid->baw_tail) {
  90ef0f:	8a44      	l32i.n	a10, a4, 16
		if (TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head)) {
  90ef11:	c061      	movi.n	a6, 1
			tid->incomp++;
			tid->flag |= TID_CLEANUP_INPROGRES;
			TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, tid->baw_head);
  90ef13:	c7bf      	movi.n	a11, -1
  90ef15:	60003d        	j	90ef56 <ath_tgt_tx_cleanup+0xa2>
	}

	ath_aggr_pause_tid(sc, tid);

	while (tid->baw_head != tid->baw_tail) {
		if (TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head)) {
  90ef18:	085312        	srai	a3, a8, 5
  90ef1b:	0e3311        	slli	a3, a3, 2
  90ef1e:	a343      	add.n	a3, a4, a3
  90ef20:	8535      	l32i.n	a5, a3, 20
  90ef22:	008104        	ssl	a8
  90ef25:	00691a        	sll	a9, a6
  90ef28:	795018        	bnone	a5, a9, 90ef44 <ath_tgt_tx_cleanup+0x90>
			tid->incomp++;
  90ef2b:	2c4037        	l8ui	a12, a4, 55
			tid->flag |= TID_CLEANUP_INPROGRES;
			TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, tid->baw_head);
  90ef2e:	09b903        	xor	a9, a11, a9

	ath_aggr_pause_tid(sc, tid);

	while (tid->baw_head != tid->baw_tail) {
		if (TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head)) {
			tid->incomp++;
  90ef31:	b1cc      	addi.n	a12, a12, 1
  90ef33:	2c4437        	s8i	a12, a4, 55
			tid->flag |= TID_CLEANUP_INPROGRES;
  90ef36:	2c4036        	l8ui	a12, a4, 54
			TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, tid->baw_head);
  90ef39:	059901        	and	a9, a9, a5
	ath_aggr_pause_tid(sc, tid);

	while (tid->baw_head != tid->baw_tail) {
		if (TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head)) {
			tid->incomp++;
			tid->flag |= TID_CLEANUP_INPROGRES;
  90ef3c:	0c6c02        	or	a12, a6, a12
  90ef3f:	2c4436        	s8i	a12, a4, 54
			TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, tid->baw_head);
  90ef42:	9935      	s32i.n	a9, a3, 20
		}
		INCR(tid->baw_head, ATH_TID_MAX_BUFS);
		INCR(tid->seq_start, IEEE80211_SEQ_MAX);
  90ef44:	234102        	l16ui	a3, a4, 4
		if (TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head)) {
			tid->incomp++;
			tid->flag |= TID_CLEANUP_INPROGRES;
			TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, tid->baw_head);
		}
		INCR(tid->baw_head, ATH_TID_MAX_BUFS);
  90ef47:	b188      	addi.n	a8, a8, 1
		INCR(tid->seq_start, IEEE80211_SEQ_MAX);
  90ef49:	b133      	addi.n	a3, a3, 1
		if (TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head)) {
			tid->incomp++;
			tid->flag |= TID_CLEANUP_INPROGRES;
			TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, tid->baw_head);
		}
		INCR(tid->baw_head, ATH_TID_MAX_BUFS);
  90ef4b:	080846        	extui	a8, a8, 0, 7
		INCR(tid->seq_start, IEEE80211_SEQ_MAX);
  90ef4e:	03034b        	extui	a3, a3, 0, 12
		if (TX_BUF_BITMAP_IS_SET(tid->tx_buf_bitmap, tid->baw_head)) {
			tid->incomp++;
			tid->flag |= TID_CLEANUP_INPROGRES;
			TX_BUF_BITMAP_CLR(tid->tx_buf_bitmap, tid->baw_head);
		}
		INCR(tid->baw_head, ATH_TID_MAX_BUFS);
  90ef51:	9843      	s32i.n	a8, a4, 12
		INCR(tid->seq_start, IEEE80211_SEQ_MAX);
  90ef53:	234502        	s16i	a3, a4, 4
		bf = asf_tailq_next(bf, bf_list);
	}

	ath_aggr_pause_tid(sc, tid);

	while (tid->baw_head != tid->baw_tail) {
  90ef56:	8843      	l32i.n	a8, a4, 12
  90ef58:	7a89bc        	bne	a8, a10, 90ef18 <ath_tgt_tx_cleanup+0x64>
		}
		INCR(tid->baw_head, ATH_TID_MAX_BUFS);
		INCR(tid->seq_start, IEEE80211_SEQ_MAX);
	}

	if (!(tid->flag & TID_CLEANUP_INPROGRES)) {
  90ef5b:	234036        	l8ui	a3, a4, 54
  90ef5e:	7f3f06        	bbsi	a3, 31, 90ef68 <ath_tgt_tx_cleanup+0xb4>
		ath_aggr_resume_tid(sc, tid);
  90ef61:	db40      	mov.n	a11, a4
  90ef63:	da20      	mov.n	a10, a2
  90ef65:	5bfe95        	call8	90e9bc <ath_aggr_resume_tid>
  90ef68:	d10f      	retw.n
	...

0090ef6c <ath_bar_tx_comp>:
	ath_tx_set_retry(sc, bf);
	ath_tgt_txq_add_ucast(sc, bf);
}

static void ath_bar_tx_comp(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
  90ef6c:	6c1006        	entry	a1, 48
	struct ath_node_target *an;
	ath_atx_tid_t *tid;
	struct ath_txq *txq;

	an = (struct ath_node_target *)bf->bf_node;
	tid = &an->tid[bf->bf_tidno];
  90ef6f:	2a304d        	l8ui	a10, a3, 77
	ath_tgt_txq_add_ucast(sc, bf);
}

static void ath_bar_tx_comp(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_tx_desc *ds = bf->bf_lastds;
  90ef72:	893e      	l32i.n	a9, a3, 56
	struct ath_node_target *an;
	ath_atx_tid_t *tid;
	struct ath_txq *txq;

	an = (struct ath_node_target *)bf->bf_node;
	tid = &an->tid[bf->bf_tidno];
  90ef74:	0ca411        	slli	a4, a10, 4
  90ef77:	0a440c        	sub	a4, a4, a10
	txq = TID_TO_ACTXQ(tid->tidno);

	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
  90ef7a:	269066        	l8ui	a6, a9, 102
	struct ath_tx_desc *ds = bf->bf_lastds;
	struct ath_node_target *an;
	ath_atx_tid_t *tid;
	struct ath_txq *txq;

	an = (struct ath_node_target *)bf->bf_node;
  90ef7d:	8534      	l32i.n	a5, a3, 16
	tid = &an->tid[bf->bf_tidno];
  90ef7f:	0e4411        	slli	a4, a4, 2
  90ef82:	244c24        	addi	a4, a4, 36
	txq = TID_TO_ACTXQ(tid->tidno);

	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
  90ef85:	060640        	extui	a6, a6, 0, 1
	struct ath_node_target *an;
	ath_atx_tid_t *tid;
	struct ath_txq *txq;

	an = (struct ath_node_target *)bf->bf_node;
	tid = &an->tid[bf->bf_tidno];
  90ef88:	a454      	add.n	a4, a5, a4
	txq = TID_TO_ACTXQ(tid->tidno);

	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
  90ef8a:	6460d3        	beqz	a6, 90f061 <ath_bar_tx_comp+0xf5>
static void ath_bar_retry(struct ath_softc_tgt *sc, struct ath_tx_buf *bf)
{
	struct ath_node_target *an = ATH_NODE_TARGET(bf->bf_node);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);

	if (bf->bf_retries >= OWLMAX_BAR_RETRIES) {
  90ef8d:	263086        	l8ui	a6, a3, 134
  90ef90:	c089      	movi.n	a8, 9
  90ef92:	768b6a        	bgeu	a8, a6, 90f000 <ath_bar_tx_comp+0x94>
		ath_tgt_delba_send(sc, bf->bf_node, tid->tidno, 1,
  90ef95:	0ca811        	slli	a8, a10, 4
  90ef98:	0a880c        	sub	a8, a8, a10
  90ef9b:	0e8811        	slli	a8, a8, 2
  90ef9e:	a858      	add.n	a8, a5, a8
  90efa0:	268027        	l8ui	a6, a8, 39
{
	struct ath_node_target *an = ATH_NODE_TARGET(ni);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, tidno);
	struct wmi_data_delba wmi_delba;

	tid->flag &= ~TID_AGGR_ENABLED;
  90efa3:	c79d      	movi.n	a9, -3
  90efa5:	0c6c11        	slli	a12, a6, 4
  90efa8:	06cc0c        	sub	a12, a12, a6
  90efab:	0ecc11        	slli	a12, a12, 2
  90efae:	ac56      	add.n	a6, a5, a12
  90efb0:	28605a        	l8ui	a8, a6, 90
			       struct ieee80211_node_target *ni,
			       a_uint8_t tidno, a_uint8_t initiator,
			       a_uint16_t reasoncode)
{
	struct ath_node_target *an = ATH_NODE_TARGET(ni);
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, tidno);
  90efb3:	2ccc24        	addi	a12, a12, 36
	struct wmi_data_delba wmi_delba;

	tid->flag &= ~TID_AGGR_ENABLED;
  90efb6:	098801        	and	a8, a8, a9
  90efb9:	28645a        	s8i	a8, a6, 90

	ath_tgt_tx_cleanup(sc, an, tid, 1);
  90efbc:	ac5c      	add.n	a12, a5, a12
  90efbe:	db50      	mov.n	a11, a5
  90efc0:	c0d1      	movi.n	a13, 1
  90efc2:	022a02        	or	a10, a2, a2
  90efc5:	5bffbb        	call8	90eeb4 <ath_tgt_tx_cleanup>

	wmi_delba.ni_nodeindex = ni->ni_nodeindex;
  90efc8:	25500c        	l8ui	a5, a5, 12
	wmi_delba.tidno = tid->tidno;
	wmi_delba.initiator = 1;
	wmi_delba.reasoncode = IEEE80211_REASON_UNSPECIFIED;

	__stats(sc, txbar_xretry);
	wmi_event(sc->tgt_wmi_handle,
  90efcb:	1b6abd        	l32r	a11, 8e9ac0 <memset+0x2c78>

	tid->flag &= ~TID_AGGR_ENABLED;

	ath_tgt_tx_cleanup(sc, an, tid, 1);

	wmi_delba.ni_nodeindex = ni->ni_nodeindex;
  90efce:	251400        	s8i	a5, a1, 0
	wmi_delba.tidno = tid->tidno;
  90efd1:	8569      	l32i.n	a5, a6, 36
	wmi_delba.initiator = 1;
	wmi_delba.reasoncode = IEEE80211_REASON_UNSPECIFIED;

	__stats(sc, txbar_xretry);
	wmi_event(sc->tgt_wmi_handle,
  90efd3:	8a23      	l32i.n	a10, a2, 12
	tid->flag &= ~TID_AGGR_ENABLED;

	ath_tgt_tx_cleanup(sc, an, tid, 1);

	wmi_delba.ni_nodeindex = ni->ni_nodeindex;
	wmi_delba.tidno = tid->tidno;
  90efd5:	251401        	s8i	a5, a1, 1
	wmi_delba.initiator = 1;
  90efd8:	c051      	movi.n	a5, 1
  90efda:	251402        	s8i	a5, a1, 2
	wmi_delba.reasoncode = IEEE80211_REASON_UNSPECIFIED;
  90efdd:	251403        	s8i	a5, a1, 3

	__stats(sc, txbar_xretry);
  90efe0:	252279        	l32i	a5, a2, 0x1e4
	wmi_event(sc->tgt_wmi_handle,
  90efe3:	c0d4      	movi.n	a13, 4
	wmi_delba.ni_nodeindex = ni->ni_nodeindex;
	wmi_delba.tidno = tid->tidno;
	wmi_delba.initiator = 1;
	wmi_delba.reasoncode = IEEE80211_REASON_UNSPECIFIED;

	__stats(sc, txbar_xretry);
  90efe5:	b155      	addi.n	a5, a5, 1
	wmi_event(sc->tgt_wmi_handle,
  90efe7:	011c02        	or	a12, a1, a1
	wmi_delba.ni_nodeindex = ni->ni_nodeindex;
	wmi_delba.tidno = tid->tidno;
	wmi_delba.initiator = 1;
	wmi_delba.reasoncode = IEEE80211_REASON_UNSPECIFIED;

	__stats(sc, txbar_xretry);
  90efea:	252679        	s32i	a5, a2, 0x1e4
	wmi_event(sc->tgt_wmi_handle,
  90efed:	5be4ae        	call8	9082a8 <wmi_event>
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);

	if (bf->bf_retries >= OWLMAX_BAR_RETRIES) {
		ath_tgt_delba_send(sc, bf->bf_node, tid->tidno, 1,
				   IEEE80211_REASON_UNSPECIFIED);
		ath_tgt_tid_drain(sc, tid);
  90eff0:	db40      	mov.n	a11, a4
  90eff2:	da20      	mov.n	a10, a2

		bf->bf_comp = NULL;
  90eff4:	c040      	movi.n	a4, 0
	ath_atx_tid_t *tid = ATH_AN_2_TID(an, bf->bf_tidno);

	if (bf->bf_retries >= OWLMAX_BAR_RETRIES) {
		ath_tgt_delba_send(sc, bf->bf_node, tid->tidno, 1,
				   IEEE80211_REASON_UNSPECIFIED);
		ath_tgt_tid_drain(sc, tid);
  90eff6:	5bfaca        	call8	90db20 <ath_tgt_tid_drain>

		bf->bf_comp = NULL;
  90eff9:	943f      	s32i.n	a4, a3, 60
  90effb:	60006b        	j	90f06a <ath_bar_tx_comp+0xfe>
  90effe:	000024        	excw
		ath_buf_comp(sc, bf);
		return;
	}

	__stats(sc, txbar_compretries);
  90f001:	227a25        	movi	a2, 0x725

	if (!bf->bf_lastds->ds_link) {
  90f004:	9000      	s32i.n	a0, a0, 0
		bf->bf_comp = NULL;
		ath_buf_comp(sc, bf);
		return;
	}

	__stats(sc, txbar_compretries);
  90f006:	b144      	addi.n	a4, a4, 1
  90f008:	24267a        	s32i	a4, a2, 0x1e8

	if (!bf->bf_lastds->ds_link) {
  90f00b:	249001        	l8ui	a4, a9, 1
  90f00e:	085510        	slli	a5, a5, 24
  90f011:	004411        	slli	a4, a4, 16
  90f014:	054502        	or	a5, a4, a5
  90f017:	249002        	l8ui	a4, a9, 2
  90f01a:	084411        	slli	a4, a4, 8
  90f01d:	054402        	or	a4, a4, a5
  90f020:	259003        	l8ui	a5, a9, 3
  90f023:	045402        	or	a4, a5, a4
  90f026:	cd42      	bnez.n	a4, 90f03c <ath_bar_tx_comp+0xd0>
		__stats(sc, txbar_errlast);
  90f028:	24227b        	l32i	a4, a2, 0x1ec
		bf = ath_buf_toggle(sc, bf, 1);
  90f02b:	db30      	mov.n	a11, a3
	}

	__stats(sc, txbar_compretries);

	if (!bf->bf_lastds->ds_link) {
		__stats(sc, txbar_errlast);
  90f02d:	b144      	addi.n	a4, a4, 1
  90f02f:	24267b        	s32i	a4, a2, 0x1ec
		bf = ath_buf_toggle(sc, bf, 1);
  90f032:	c0c1      	movi.n	a12, 1
  90f034:	022a02        	or	a10, a2, a2
  90f037:	5bf8f2        	call8	90d400 <ath_buf_toggle>
  90f03a:	d3a0      	mov.n	a3, a10
	}

	bf->bf_lastds->ds_link = 0;
  90f03c:	843e      	l32i.n	a4, a3, 56
  90f03e:	c050      	movi.n	a5, 0

	ath_tx_set_retry(sc, bf);
  90f040:	2a1a80        	movi	a10, 0x180
  90f043:	db30      	mov.n	a11, a3
  90f045:	aa2a      	add.n	a10, a2, a10
	if (!bf->bf_lastds->ds_link) {
		__stats(sc, txbar_errlast);
		bf = ath_buf_toggle(sc, bf, 1);
	}

	bf->bf_lastds->ds_link = 0;
  90f047:	254400        	s8i	a5, a4, 0
  90f04a:	254401        	s8i	a5, a4, 1
  90f04d:	254402        	s8i	a5, a4, 2
  90f050:	254403        	s8i	a5, a4, 3

	ath_tx_set_retry(sc, bf);
  90f053:	5bfa3f        	call8	90d950 <ath_tx_set_retry$isra$12>
	ath_tgt_txq_add_ucast(sc, bf);
  90f056:	db30      	mov.n	a11, a3
  90f058:	da20      	mov.n	a10, a2
  90f05a:	5bf794        	call8	90ceac <ath_tgt_txq_add_ucast>
  90f05d:	d10f      	retw.n
  90f05f:	0000db        	excw
	if (ATH_DS_TX_STATUS(ds) & HAL_TXERR_XRETRY) {
		ath_bar_retry(sc, bf);
		return;
	}

	ath_aggr_resume_tid(sc, tid);
  90f062:	40da20        	excw
  90f065:	5bfe55        	call8	90e9bc <ath_aggr_resume_tid>

	bf->bf_comp = NULL;
  90f068:	963f      	s32i.n	a6, a3, 60
	ath_buf_comp(sc, bf);
  90f06a:	db30      	mov.n	a11, a3
  90f06c:	da20      	mov.n	a10, a2
  90f06e:	5bf929        	call8	90d514 <ath_buf_comp>
  90f071:	d10f      	retw.n
	...

0090f074 <ath_pci_suspend>:
	adf_os_free_intr(sc->sc_dev);
}

static void
ath_pci_suspend(adf_drv_handle_t hdl, adf_os_pm_t pm)
{
  90f074:	6c1004        	entry	a1, 32
  90f077:	d10f      	retw.n
  90f079:	000000        	ill

0090f07c <ath_pci_resume>:
}

static void
ath_pci_resume(adf_drv_handle_t hdl)
{
  90f07c:	6c1004        	entry	a1, 32
  90f07f:	d10f      	retw.n
  90f081:	000000        	ill

0090f084 <ath_pci_remove>:
	return NULL;
}

static void
ath_pci_remove(adf_drv_handle_t hdl)
{
  90f084:	6c1004        	entry	a1, 32
	struct ath_softc_tgt *sc = hdl;

	ath_detach((struct ath_softc_tgt *)hdl);
  90f087:	da20      	mov.n	a10, a2
  90f089:	5bea6b        	call8	909a38 <ath_detach>
}

static inline void
adf_os_free_intr(adf_os_device_t osdev)
{
    __adf_os_free_intr(osdev);
  90f08c:	2a2246        	l32i	a10, a2, 0x118
  90f08f:	5beefc        	call8	90ac80 <__adf_os_free_intr>
  90f092:	d10f      	retw.n

0090f094 <init_ath_pci>:

static adf_drv_info_t ath_drv_info = adf_os_pci_set_drv_info(ath_pci_tgt,&ath_pci_id_table[0], ath_pci_probe, ath_pci_remove, ath_pci_suspend, ath_pci_resume);

a_int32_t
init_ath_pci(void)
{
  90f094:	6c1004        	entry	a1, 32
 * @return status of operation
 */
static inline a_status_t 
adf_net_register_drv(adf_drv_info_t *drv)
{
    return(__adf_net_register_drv(drv));
  90f097:	1a6abe        	l32r	a10, 8e9b90 <memset+0x2d48>
  90f09a:	580061        	call8	90f220 <__adf_net_register_drv>
	return adf_net_register_drv( &ath_drv_info );
}
  90f09d:	d2a0      	mov.n	a2, a10
  90f09f:	d10f      	retw.n
  90f0a1:	000000        	ill

0090f0a4 <ath_pci_probe>:
a_int32_t init_ath_pci(void);

static adf_drv_handle_t
ath_pci_probe(adf_os_resource_t *res,a_int32_t count, adf_os_attach_data_t *data,
	      adf_os_device_t osdev)
{
  90f0a4:	6c1004        	entry	a1, 32
}

static inline int 
__adf_os_pci_config_write8(adf_os_device_t osdev, int offset, a_uint8_t val)
{
    wlan_pci_config_write(offset, val, 1);
  90f0a7:	c0c1      	movi.n	a12, 1
  90f0a9:	2b0a20        	movi	a11, 32
  90f0ac:	2a0a0c        	movi	a10, 12
  90f0af:	5bea73        	call8	909a7c <wlan_pci_config_write>
  90f0b2:	c0c1      	movi.n	a12, 1
  90f0b4:	2b0aa8        	movi	a11, 168
  90f0b7:	c0ad      	movi.n	a10, 13
  90f0b9:	5bea70        	call8	909a7c <wlan_pci_config_write>
#include "Magpie_api.h"

static inline void *	__adf_os_mem_alloc(adf_os_size_t size)
{
//    return (malloc(size,M_DEVBUF,M_DONTWAIT | M_ZERO));
    return A_ALLOCRAM(size);
  90f0bc:	1668bf        	l32r	a6, 8e93b8 <memset+0x2570>
  90f0bf:	136abf        	l32r	a3, 8e9bbc <memset+0x2d74>
  90f0c2:	226252        	l32i	a2, a6, 0x148
  90f0c5:	db30      	mov.n	a11, a3
  90f0c7:	c0a0      	movi.n	a10, 0
  90f0c9:	0b2000        	callx8	a2
  90f0cc:	d2a0      	mov.n	a2, a10
	adf_os_pci_config_write8(osdev, ATH_PCI_CACHE_LINE_SIZE, csz);
	adf_os_pci_config_write8(osdev, ATH_PCI_LATENCY_TIMER, 0xa8);

	sc = adf_os_mem_alloc(sizeof(struct ath_pci_softc));

	if (sc == NULL) {
  90f0ce:	ccaa      	bnez.n	a10, 90f0dc <ath_pci_probe+0x38>
		adf_os_print("ath_pci: no memory for device state\n");
  90f0d0:	236212        	l32i	a3, a6, 72
  90f0d3:	1a6ac0        	l32r	a10, 8e9bd4 <memset+0x2d8c>
  90f0d6:	0b3000        	callx8	a3
		goto bad2;
  90f0d9:	d10f      	retw.n
  90f0db:	008864        	excw

/* set a memory buffer */
static inline void
__adf_os_mem_set(void *buf, a_uint8_t b, adf_os_size_t size)
{
	A_MEMSET(buf, b, size);
  90f0de:	dc30      	mov.n	a12, a3
  90f0e0:	c0b0      	movi.n	a11, 0
  90f0e2:	0b8000        	callx8	a8

	/*
	 * Mark the device as detached to avoid processing
	 * interrupts until setup is complete.
	 */
	sc->aps_sc.sc_invalid = 1;
  90f0e5:	232d01        	addmi	a3, a2, 0x100
  90f0e8:	283024        	l8ui	a8, a3, 36
  90f0eb:	29fa80        	movi	a9, -128
  90f0ee:	098802        	or	a8, a8, a9
  90f0f1:	283424        	s8i	a8, a3, 36

	adf_os_print("ath_pci_probe %x\n",id->device);
  90f0f4:	2b4201        	l32i	a11, a4, 4
  90f0f7:	266212        	l32i	a6, a6, 72
  90f0fa:	1a6ac1        	l32r	a10, 8e9c00 <memset+0x2db8>
  90f0fd:	0b6000        	callx8	a6

	if (ath_tgt_attach(id->device, &sc->aps_sc, osdev) != 0)
  90f100:	8a41      	l32i.n	a10, a4, 4
  90f102:	dc50      	mov.n	a12, a5
  90f104:	db20      	mov.n	a11, a2
  90f106:	5be935        	call8	9095dc <ath_tgt_attach>
  90f109:	cda1      	bnez.n	a10, 90f11e <ath_pci_probe+0x7a>
		goto bad3;

	/* ready to process interrupts */
	sc->aps_sc.sc_invalid = 0;
  90f10b:	263024        	l8ui	a6, a3, 36
#include <adf_os_irq_pvt.h>

static inline int
adf_os_setup_intr(adf_os_device_t  osdev, adf_os_drv_intr fn)
{
    return __adf_os_setup_intr(osdev, fn);
  90f10e:	1b69ca        	l32r	a11, 8e9838 <memset+0x29f0>
  90f111:	060646        	extui	a6, a6, 0, 7
  90f114:	263424        	s8i	a6, a3, 36
  90f117:	da50      	mov.n	a10, a5
  90f119:	5beed6        	call8	90ac74 <__adf_os_setup_intr>
  90f11c:	d10f      	retw.n
	adf_os_setup_intr(osdev, ath_intr);
	return (adf_drv_handle_t)sc;
bad3:
bad2:
	return NULL;
  90f11e:	c020      	movi.n	a2, 0
}
  90f120:	d10f      	retw.n
	...

0090f124 <exit_ath_pci>:
	return adf_net_register_drv( &ath_drv_info );
}

void
exit_ath_pci(void)
{
  90f124:	6c1004        	entry	a1, 32
 * @see adf_net_register_drv()
 */
static inline void
adf_net_unregister_drv(a_uint8_t *drv_name)
{
    __adf_net_unregister_drv(drv_name);
  90f127:	1a6ac2        	l32r	a10, 8e9c30 <memset+0x2de8>
  90f12a:	580040        	call8	90f22c <__adf_net_unregister_drv>
  90f12d:	d10f      	retw.n
	...

0090f130 <ar5416AttachRateTables>:

#endif //#ifdef MAGPIE_MERLIN // MAGPIE_MERLIN 

void
ar5416AttachRateTables(struct atheros_softc *sc)
{
  90f130:	6c1004        	entry	a1, 32
    sc->hwRateTable[WIRELESS_MODE_11NG]  = &ar5416_11ngRateTable;
  90f133:	186ac3        	l32r	a8, 8e9c40 <memset+0x2df8>
  90f136:	9822      	s32i.n	a8, a2, 8
#ifdef ATH_SUPPORT_A_MODE
    sc->hwRateTable[WIRELESS_MODE_11NA]  = &ar5416_11naRateTable;
  90f138:	186ac4        	l32r	a8, 8e9c48 <memset+0x2e00>
  90f13b:	9821      	s32i.n	a8, a2, 4
  90f13d:	d10f      	retw.n
	...

0090f140 <io32_rmw>:
	iowrite8(addr, val);
}

static inline void io32_rmw(volatile uint32_t addr,
			    const uint32_t set, const uint32_t clr)
{
  90f140:	6c1006        	entry	a1, 48
  90f143:	0c0200        	memw
  90f146:	9210      	s32i.n	a2, a1, 0
	uint32_t val;

	val = ioread32(addr);
  90f148:	0c0200        	memw
  90f14b:	8810      	l32i.n	a8, a1, 0
	return *(const volatile uint16_t *) addr;
}

static inline uint32_t ioread32(const volatile uint32_t addr)
{
	return *(const volatile uint32_t *) addr;
  90f14d:	0c0200        	memw
  90f150:	8980      	l32i.n	a9, a8, 0
			    const uint32_t set, const uint32_t clr)
{
	uint32_t val;

	val = ioread32(addr);
	val &= ~clr;
  90f152:	c78f      	movi.n	a8, -1
  90f154:	048403        	xor	a4, a8, a4
  90f157:	094401        	and	a4, a4, a9
	val |= set;
	iowrite32(addr, val);
  90f15a:	0c0200        	memw
  90f15d:	8810      	l32i.n	a8, a1, 0
{
	uint32_t val;

	val = ioread32(addr);
	val &= ~clr;
	val |= set;
  90f15f:	034402        	or	a4, a4, a3
	*(volatile uint16_t *) addr = b;
}

static inline void iowrite32(volatile uint32_t addr, const uint32_t b)
{
	*(volatile uint32_t *) addr = b;
  90f162:	0c0200        	memw
  90f165:	9480      	s32i.n	a4, a8, 0
  90f167:	d10f      	retw.n
  90f169:	000000        	ill

0090f16c <ieee80211_tgt_crypto_encap>:

a_status_t
ieee80211_tgt_crypto_encap(struct ieee80211_frame *wh,
			   struct ieee80211_node_target *ni,
			   a_uint8_t keytype)
{
  90f16c:	6c1004        	entry	a1, 32
	a_uint16_t tmp;
	a_uint16_t offset = IEEE80211_WLAN_HDR_LEN;
	a_uint8_t b1, b2;
	struct ieee80211_qosframe_addr4 *wh_mesh;

	if (IEEE80211_QOS_HAS_SEQ(wh))
  90f16f:	282000        	l8ui	a8, a2, 0
  90f172:	290a8c        	movi	a9, 140
  90f175:	098801        	and	a8, a8, a9
  90f178:	290a88        	movi	a9, 136
		offset += 4;  // pad for 4 byte alignment
  90f17b:	09880c        	sub	a8, a8, a9
  90f17e:	c1a8      	movi.n	a10, 24
  90f180:	c19c      	movi.n	a9, 28
  90f182:	08a939        	movnez	a9, a10, a8
  90f185:	d890      	mov.n	a8, a9

	/* set the offset to 32 if the mesh control field is present */
	wh_mesh = (struct ieee80211_qosframe_addr4 *)wh;
	if (wh_mesh->i_qos[1] & 0x01)
  90f187:	29201f        	l8ui	a9, a2, 31
		offset = 32;
  90f18a:	c2a0      	movi.n	a10, 32
	if (IEEE80211_QOS_HAS_SEQ(wh))
		offset += 4;  // pad for 4 byte alignment

	/* set the offset to 32 if the mesh control field is present */
	wh_mesh = (struct ieee80211_qosframe_addr4 *)wh;
	if (wh_mesh->i_qos[1] & 0x01)
  90f18c:	090940        	extui	a9, a9, 0, 1
		offset = 32;
  90f18f:	09a839        	movnez	a8, a10, a9

a_status_t
ieee80211_tgt_crypto_encap(struct ieee80211_frame *wh,
			   struct ieee80211_node_target *ni,
			   a_uint8_t keytype)
{
  90f192:	040447        	extui	a4, a4, 0, 8
	wh_mesh = (struct ieee80211_qosframe_addr4 *)wh;
	if (wh_mesh->i_qos[1] & 0x01)
		offset = 32;

	iv = (a_uint8_t *) wh;
	iv = iv + offset;
  90f195:	a822      	add.n	a2, a2, a8

	switch (keytype) {
  90f197:	684206        	beqi	a4, 2, 90f1a1 <ieee80211_tgt_crypto_encap+0x35>
  90f19a:	684333        	beqi	a4, 3, 90f1d1 <ieee80211_tgt_crypto_encap+0x65>
  90f19d:	60007a        	j	90f21b <ieee80211_tgt_crypto_encap+0xaf>
  90f1a0:	002831        	excw
	case CRYPTO_KEY_TYPE_AES:
		ni->ni_iv16++;
  90f1a3:	0db188        	excw
  90f1a6:	08084f        	extui	a8, a8, 0, 16
  90f1a9:	28350d        	s16i	a8, a3, 26
		if (ni->ni_iv16 == 0)
  90f1ac:	cc84      	bnez.n	a8, 90f1b4 <ieee80211_tgt_crypto_encap+0x48>
		{
			ni->ni_iv32++;
  90f1ae:	8937      	l32i.n	a9, a3, 28
  90f1b0:	b199      	addi.n	a9, a9, 1
  90f1b2:	9937      	s32i.n	a9, a3, 28
		}

		*iv++ = (a_uint8_t) ni->ni_iv16;
  90f1b4:	282400        	s8i	a8, a2, 0
		*iv++ = (a_uint8_t) (ni->ni_iv16 >> 8);
  90f1b7:	28310d        	l16ui	a8, a3, 26
		*iv++ = 0x00;
  90f1ba:	c040      	movi.n	a4, 0
		{
			ni->ni_iv32++;
		}

		*iv++ = (a_uint8_t) ni->ni_iv16;
		*iv++ = (a_uint8_t) (ni->ni_iv16 >> 8);
  90f1bc:	088814        	srli	a8, a8, 8
  90f1bf:	282401        	s8i	a8, a2, 1
		*iv++ = 0x00;
		*iv++ |= 0x20;
  90f1c2:	282003        	l8ui	a8, a2, 3
			ni->ni_iv32++;
		}

		*iv++ = (a_uint8_t) ni->ni_iv16;
		*iv++ = (a_uint8_t) (ni->ni_iv16 >> 8);
		*iv++ = 0x00;
  90f1c5:	242402        	s8i	a4, a2, 2
		*iv++ |= 0x20;
  90f1c8:	c240      	movi.n	a4, 32
  90f1ca:	048802        	or	a8, a8, a4
  90f1cd:	600030        	j	90f201 <ieee80211_tgt_crypto_encap+0x95>
  90f1d0:	002831        	excw
		tmp = (a_uint16_t) (ni->ni_iv32 >> 16);
		*iv++ = (a_uint8_t) tmp;
		*iv = (a_uint8_t) (tmp >> 8);
		break;
	case CRYPTO_KEY_TYPE_TKIP:
		ni->ni_iv16++;
  90f1d3:	0db188        	excw
  90f1d6:	08084f        	extui	a8, a8, 0, 16
  90f1d9:	28350d        	s16i	a8, a3, 26
		if (ni->ni_iv16 == 0)
  90f1dc:	cc84      	bnez.n	a8, 90f1e4 <ieee80211_tgt_crypto_encap+0x78>
		{
			ni->ni_iv32++;
  90f1de:	8937      	l32i.n	a9, a3, 28
  90f1e0:	b199      	addi.n	a9, a9, 1
  90f1e2:	9937      	s32i.n	a9, a3, 28
		}

		b1 = (a_uint8_t) (ni->ni_iv16 >> 8);
  90f1e4:	088814        	srli	a8, a8, 8
		b2 = (b1 | 0x20) & 0x7f;

		*iv++ = b1;
  90f1e7:	282400        	s8i	a8, a2, 0
		{
			ni->ni_iv32++;
		}

		b1 = (a_uint8_t) (ni->ni_iv16 >> 8);
		b2 = (b1 | 0x20) & 0x7f;
  90f1ea:	c290      	movi.n	a9, 32
  90f1ec:	080846        	extui	a8, a8, 0, 7
  90f1ef:	098802        	or	a8, a8, a9

		*iv++ = b1;
		*iv++ = b2;
  90f1f2:	282401        	s8i	a8, a2, 1

		*iv++ = (a_uint8_t) ni->ni_iv16;
  90f1f5:	24310d        	l16ui	a4, a3, 26
		*iv++ |= 0x20;
  90f1f8:	282003        	l8ui	a8, a2, 3
		b2 = (b1 | 0x20) & 0x7f;

		*iv++ = b1;
		*iv++ = b2;

		*iv++ = (a_uint8_t) ni->ni_iv16;
  90f1fb:	242402        	s8i	a4, a2, 2
		*iv++ |= 0x20;
  90f1fe:	098802        	or	a8, a8, a9
  90f201:	282403        	s8i	a8, a2, 3

		tmp = (a_uint16_t) ni->ni_iv32;
  90f204:	8837      	l32i.n	a8, a3, 28
		*iv++ = (a_uint8_t) tmp;
  90f206:	282404        	s8i	a8, a2, 4
		*iv++ = (a_uint8_t) (tmp >> 8);
  90f209:	088847        	extui	a8, a8, 8, 8
  90f20c:	282405        	s8i	a8, a2, 5

		tmp = (a_uint16_t) (ni->ni_iv32 >> 16);
  90f20f:	23310e        	l16ui	a3, a3, 28
		*iv++ = (a_uint8_t) tmp;
  90f212:	232406        	s8i	a3, a2, 6
		*iv = (a_uint8_t) (tmp >> 8);
  90f215:	038314        	srli	a3, a3, 8
  90f218:	232407        	s8i	a3, a2, 7

#undef CRYPTO_KEY_TYPE_TKIP
#undef CRYPTO_KEY_TYPE_AES
#undef CRYPTO_KEY_TYPE_WAPI
#undef IEEE80211_WLAN_HDR_LEN
}
  90f21b:	c021      	movi.n	a2, 1
  90f21d:	d10f      	retw.n
	...

0090f220 <__adf_net_register_drv>:
 * 
 * @return a_status_t
 */
a_status_t
__adf_net_register_drv(adf_drv_info_t *drv)
{
  90f220:	6c1004        	entry	a1, 32
    wlan_pci_register_drv(drv);    
  90f223:	da20      	mov.n	a10, a2
  90f225:	5bea12        	call8	909a70 <wlan_pci_register_drv>
    return A_STATUS_OK;
}
  90f228:	c020      	movi.n	a2, 0
  90f22a:	d10f      	retw.n

0090f22c <__adf_net_unregister_drv>:
 * @brief unregister the driver from the shim
 * @param[in] name
 */
void
__adf_net_unregister_drv(a_uint8_t *name)
{
  90f22c:	6c1004        	entry	a1, 32
  90f22f:	d10f      	retw.n
